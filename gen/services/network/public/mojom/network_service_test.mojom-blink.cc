// services/network/public/mojom/network_service_test.mojom-blink.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "services/network/public/mojom/network_service_test.mojom-blink.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "services/network/public/mojom/network_service_test.mojom-params-data.h"
#include "services/network/public/mojom/network_service_test.mojom-shared-message-ids.h"

#include "services/network/public/mojom/network_service_test.mojom-blink-import-headers.h"
#include "services/network/public/mojom/network_service_test.mojom-blink-test-utils.h"
#include "mojo/public/cpp/bindings/lib/wtf_serialization.h"


#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_TEST_MOJOM_BLINK_JUMBO_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_TEST_MOJOM_BLINK_JUMBO_H_
#endif



namespace network {
namespace mojom {
namespace blink {
Rule::Rule()
    : resolver_type(),
      host_pattern(),
      replacement(),
      host_resolver_flags(),
      dns_aliases() {}

Rule::Rule(
    ResolverType resolver_type_in,
    const WTF::String& host_pattern_in,
    const WTF::String& replacement_in,
    int32_t host_resolver_flags_in,
    WTF::Vector<WTF::String> dns_aliases_in)
    : resolver_type(std::move(resolver_type_in)),
      host_pattern(std::move(host_pattern_in)),
      replacement(std::move(replacement_in)),
      host_resolver_flags(std::move(host_resolver_flags_in)),
      dns_aliases(std::move(dns_aliases_in)) {}

Rule::~Rule() = default;

void Rule::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "resolver_type"), this->resolver_type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ResolverType>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "host_pattern"), this->host_pattern,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "replacement"), this->replacement,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "host_resolver_flags"), this->host_resolver_flags,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dns_aliases"), this->dns_aliases,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::Vector<WTF::String>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool Rule::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SimpleCacheOpenEntryResult::SimpleCacheOpenEntryResult()
    : error(),
      key(),
      entry() {}

SimpleCacheOpenEntryResult::SimpleCacheOpenEntryResult(
    int32_t error_in,
    const WTF::String& key_in,
    ::mojo::PendingRemote<SimpleCacheEntry> entry_in)
    : error(std::move(error_in)),
      key(std::move(key_in)),
      entry(std::move(entry_in)) {}

SimpleCacheOpenEntryResult::~SimpleCacheOpenEntryResult() = default;

void SimpleCacheOpenEntryResult::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "error"), this->error,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key"), this->key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const WTF::String&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "entry"), this->entry,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<SimpleCacheEntry>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SimpleCacheOpenEntryResult::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char SimpleCacheEntry::Name_[] = "network.mojom.SimpleCacheEntry";

SimpleCacheEntry::IPCStableHashFunction SimpleCacheEntry::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSimpleCacheEntry_WriteData_Name: {
      return &SimpleCacheEntry::WriteData_Sym::IPCStableHash;
    }
    case internal::kSimpleCacheEntry_ReadData_Name: {
      return &SimpleCacheEntry::ReadData_Sym::IPCStableHash;
    }
    case internal::kSimpleCacheEntry_WriteSparseData_Name: {
      return &SimpleCacheEntry::WriteSparseData_Sym::IPCStableHash;
    }
    case internal::kSimpleCacheEntry_ReadSparseData_Name: {
      return &SimpleCacheEntry::ReadSparseData_Sym::IPCStableHash;
    }
    case internal::kSimpleCacheEntry_Close_Name: {
      return &SimpleCacheEntry::Close_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SimpleCacheEntry::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSimpleCacheEntry_WriteData_Name:
            return "Receive network::mojom::SimpleCacheEntry::WriteData";
      case internal::kSimpleCacheEntry_ReadData_Name:
            return "Receive network::mojom::SimpleCacheEntry::ReadData";
      case internal::kSimpleCacheEntry_WriteSparseData_Name:
            return "Receive network::mojom::SimpleCacheEntry::WriteSparseData";
      case internal::kSimpleCacheEntry_ReadSparseData_Name:
            return "Receive network::mojom::SimpleCacheEntry::ReadSparseData";
      case internal::kSimpleCacheEntry_Close_Name:
            return "Receive network::mojom::SimpleCacheEntry::Close";
    }
  } else {
    switch (message.name()) {
      case internal::kSimpleCacheEntry_WriteData_Name:
            return "Receive reply network::mojom::SimpleCacheEntry::WriteData";
      case internal::kSimpleCacheEntry_ReadData_Name:
            return "Receive reply network::mojom::SimpleCacheEntry::ReadData";
      case internal::kSimpleCacheEntry_WriteSparseData_Name:
            return "Receive reply network::mojom::SimpleCacheEntry::WriteSparseData";
      case internal::kSimpleCacheEntry_ReadSparseData_Name:
            return "Receive reply network::mojom::SimpleCacheEntry::ReadSparseData";
      case internal::kSimpleCacheEntry_Close_Name:
            return "Receive reply network::mojom::SimpleCacheEntry::Close";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SimpleCacheEntry::WriteData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCacheEntry::WriteData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCacheEntry::ReadData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCacheEntry::ReadData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCacheEntry::WriteSparseData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCacheEntry::WriteSparseData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCacheEntry::ReadSparseData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCacheEntry::ReadSparseData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCacheEntry::Close_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCacheEntry::Close");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class SimpleCacheEntry_WriteData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCacheEntry_WriteData_ForwardToCallback(
      SimpleCacheEntry::WriteDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCacheEntry_WriteData_ForwardToCallback(const SimpleCacheEntry_WriteData_ForwardToCallback&) = delete;
  SimpleCacheEntry_WriteData_ForwardToCallback& operator=(const SimpleCacheEntry_WriteData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCacheEntry::WriteDataCallback callback_;
};

class SimpleCacheEntry_ReadData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCacheEntry_ReadData_ForwardToCallback(
      SimpleCacheEntry::ReadDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCacheEntry_ReadData_ForwardToCallback(const SimpleCacheEntry_ReadData_ForwardToCallback&) = delete;
  SimpleCacheEntry_ReadData_ForwardToCallback& operator=(const SimpleCacheEntry_ReadData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCacheEntry::ReadDataCallback callback_;
};

class SimpleCacheEntry_WriteSparseData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCacheEntry_WriteSparseData_ForwardToCallback(
      SimpleCacheEntry::WriteSparseDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCacheEntry_WriteSparseData_ForwardToCallback(const SimpleCacheEntry_WriteSparseData_ForwardToCallback&) = delete;
  SimpleCacheEntry_WriteSparseData_ForwardToCallback& operator=(const SimpleCacheEntry_WriteSparseData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCacheEntry::WriteSparseDataCallback callback_;
};

class SimpleCacheEntry_ReadSparseData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCacheEntry_ReadSparseData_ForwardToCallback(
      SimpleCacheEntry::ReadSparseDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCacheEntry_ReadSparseData_ForwardToCallback(const SimpleCacheEntry_ReadSparseData_ForwardToCallback&) = delete;
  SimpleCacheEntry_ReadSparseData_ForwardToCallback& operator=(const SimpleCacheEntry_ReadSparseData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCacheEntry::ReadSparseDataCallback callback_;
};

class SimpleCacheEntry_Close_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCacheEntry_Close_ForwardToCallback(
      SimpleCacheEntry::CloseCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCacheEntry_Close_ForwardToCallback(const SimpleCacheEntry_Close_ForwardToCallback&) = delete;
  SimpleCacheEntry_Close_ForwardToCallback& operator=(const SimpleCacheEntry_Close_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCacheEntry::CloseCallback callback_;
};

SimpleCacheEntryProxy::SimpleCacheEntryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SimpleCacheEntryProxy::WriteData(
    int32_t in_index, int32_t in_offset, const WTF::Vector<uint8_t>& in_data, bool in_truncate, WriteDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCacheEntry::WriteData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index"), in_index,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type const WTF::Vector<uint8_t>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("truncate"), in_truncate,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_WriteData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_WriteData_Params_Data> params(
          message);
  params.Allocate();
  params->index = in_index;
  params->offset = in_offset;
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType>
      data_fragment(params.message());
  const mojo::internal::ContainerValidateParams data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_data, data_fragment, &data_validate_params);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in SimpleCacheEntry.WriteData request");
  params->truncate = in_truncate;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("WriteData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCacheEntry_WriteData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheEntryProxy::ReadData(
    int32_t in_index, int32_t in_offset, uint32_t in_length, ReadDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCacheEntry::ReadData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("index"), in_index,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("length"), in_length,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_ReadData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_ReadData_Params_Data> params(
          message);
  params.Allocate();
  params->index = in_index;
  params->offset = in_offset;
  params->length = in_length;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("ReadData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCacheEntry_ReadData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheEntryProxy::WriteSparseData(
    int32_t in_offset, const WTF::Vector<uint8_t>& in_data, WriteSparseDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCacheEntry::WriteSparseData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type const WTF::Vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_WriteSparseData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_WriteSparseData_Params_Data> params(
          message);
  params.Allocate();
  params->offset = in_offset;
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType>
      data_fragment(params.message());
  const mojo::internal::ContainerValidateParams data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_data, data_fragment, &data_validate_params);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in SimpleCacheEntry.WriteSparseData request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("WriteSparseData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCacheEntry_WriteSparseData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheEntryProxy::ReadSparseData(
    int32_t in_offset, uint32_t in_length, ReadSparseDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCacheEntry::ReadSparseData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("length"), in_length,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_ReadSparseData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_ReadSparseData_Params_Data> params(
          message);
  params.Allocate();
  params->offset = in_offset;
  params->length = in_length;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("ReadSparseData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCacheEntry_ReadSparseData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheEntryProxy::Close(
    CloseCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::SimpleCacheEntry::Close");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_Close_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_Close_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("Close");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCacheEntry_Close_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class SimpleCacheEntry_WriteData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCacheEntry::WriteDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCacheEntry_WriteData_ProxyToResponder> proxy(
        new SimpleCacheEntry_WriteData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCacheEntry_WriteData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCacheEntry_WriteData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCacheEntry_WriteData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCacheEntry::WriteDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result);
};

bool SimpleCacheEntry_WriteData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCacheEntry_WriteData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCacheEntry_WriteData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  SimpleCacheEntry_WriteData_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCacheEntry::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void SimpleCacheEntry_WriteData_ProxyToResponder::Run(
    int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCacheEntry::WriteData", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_WriteData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_WriteData_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("WriteData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCacheEntry_ReadData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCacheEntry::ReadDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCacheEntry_ReadData_ProxyToResponder> proxy(
        new SimpleCacheEntry_ReadData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCacheEntry_ReadData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCacheEntry_ReadData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCacheEntry_ReadData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCacheEntry::ReadDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const WTF::Vector<uint8_t>& in_data, int32_t in_result);
};

bool SimpleCacheEntry_ReadData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCacheEntry_ReadData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCacheEntry_ReadData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  WTF::Vector<uint8_t> p_data{};
  int32_t p_result{};
  SimpleCacheEntry_ReadData_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadData(&p_data))
    success = false;
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCacheEntry::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_data), 
std::move(p_result));
  return true;
}

void SimpleCacheEntry_ReadData_ProxyToResponder::Run(
    const WTF::Vector<uint8_t>& in_data, int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCacheEntry::ReadData", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type const WTF::Vector<uint8_t>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_ReadData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_ReadData_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType>
      data_fragment(params.message());
  const mojo::internal::ContainerValidateParams data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_data, data_fragment, &data_validate_params);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in ");
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("ReadData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCacheEntry_WriteSparseData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCacheEntry::WriteSparseDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCacheEntry_WriteSparseData_ProxyToResponder> proxy(
        new SimpleCacheEntry_WriteSparseData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCacheEntry_WriteSparseData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCacheEntry_WriteSparseData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCacheEntry_WriteSparseData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCacheEntry::WriteSparseDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result);
};

bool SimpleCacheEntry_WriteSparseData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCacheEntry_WriteSparseData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCacheEntry_WriteSparseData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  SimpleCacheEntry_WriteSparseData_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCacheEntry::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void SimpleCacheEntry_WriteSparseData_ProxyToResponder::Run(
    int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCacheEntry::WriteSparseData", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_WriteSparseData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_WriteSparseData_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("WriteSparseData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCacheEntry_ReadSparseData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCacheEntry::ReadSparseDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCacheEntry_ReadSparseData_ProxyToResponder> proxy(
        new SimpleCacheEntry_ReadSparseData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCacheEntry_ReadSparseData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCacheEntry_ReadSparseData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCacheEntry_ReadSparseData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCacheEntry::ReadSparseDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const WTF::Vector<uint8_t>& in_data, int32_t in_result);
};

bool SimpleCacheEntry_ReadSparseData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCacheEntry_ReadSparseData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCacheEntry_ReadSparseData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  WTF::Vector<uint8_t> p_data{};
  int32_t p_result{};
  SimpleCacheEntry_ReadSparseData_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadData(&p_data))
    success = false;
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCacheEntry::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_data), 
std::move(p_result));
  return true;
}

void SimpleCacheEntry_ReadSparseData_ProxyToResponder::Run(
    const WTF::Vector<uint8_t>& in_data, int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCacheEntry::ReadSparseData", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type const WTF::Vector<uint8_t>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_ReadSparseData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_ReadSparseData_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType>
      data_fragment(params.message());
  const mojo::internal::ContainerValidateParams data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_data, data_fragment, &data_validate_params);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in ");
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("ReadSparseData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCacheEntry_Close_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCacheEntry::CloseCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCacheEntry_Close_ProxyToResponder> proxy(
        new SimpleCacheEntry_Close_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCacheEntry_Close_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCacheEntry_Close_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCacheEntry_Close_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCacheEntry::CloseCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool SimpleCacheEntry_Close_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCacheEntry_Close_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCacheEntry_Close_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SimpleCacheEntry_Close_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCacheEntry::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void SimpleCacheEntry_Close_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::SimpleCacheEntry::Close");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntry_Close_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntry_Close_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntry::Name_);
  message.set_method_name("Close");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool SimpleCacheEntryStubDispatch::Accept(
    SimpleCacheEntry* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSimpleCacheEntry_WriteData_Name: {
      break;
    }
    case internal::kSimpleCacheEntry_ReadData_Name: {
      break;
    }
    case internal::kSimpleCacheEntry_WriteSparseData_Name: {
      break;
    }
    case internal::kSimpleCacheEntry_ReadSparseData_Name: {
      break;
    }
    case internal::kSimpleCacheEntry_Close_Name: {
      break;
    }
  }
  return false;
}

// static
bool SimpleCacheEntryStubDispatch::AcceptWithResponder(
    SimpleCacheEntry* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSimpleCacheEntry_WriteData_Name: {

      internal::SimpleCacheEntry_WriteData_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCacheEntry_WriteData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_index{};
      int32_t p_offset{};
      WTF::Vector<uint8_t> p_data{};
      bool p_truncate{};
      SimpleCacheEntry_WriteData_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_index = input_data_view.index();
      if (success)
        p_offset = input_data_view.offset();
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (success)
        p_truncate = input_data_view.truncate();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCacheEntry::Name_, 0, false);
        return false;
      }
      SimpleCacheEntry::WriteDataCallback callback =
          SimpleCacheEntry_WriteData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WriteData(
std::move(p_index), 
std::move(p_offset), 
std::move(p_data), 
std::move(p_truncate), std::move(callback));
      return true;
    }
    case internal::kSimpleCacheEntry_ReadData_Name: {

      internal::SimpleCacheEntry_ReadData_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCacheEntry_ReadData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_index{};
      int32_t p_offset{};
      uint32_t p_length{};
      SimpleCacheEntry_ReadData_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_index = input_data_view.index();
      if (success)
        p_offset = input_data_view.offset();
      if (success)
        p_length = input_data_view.length();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCacheEntry::Name_, 1, false);
        return false;
      }
      SimpleCacheEntry::ReadDataCallback callback =
          SimpleCacheEntry_ReadData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReadData(
std::move(p_index), 
std::move(p_offset), 
std::move(p_length), std::move(callback));
      return true;
    }
    case internal::kSimpleCacheEntry_WriteSparseData_Name: {

      internal::SimpleCacheEntry_WriteSparseData_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCacheEntry_WriteSparseData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_offset{};
      WTF::Vector<uint8_t> p_data{};
      SimpleCacheEntry_WriteSparseData_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_offset = input_data_view.offset();
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCacheEntry::Name_, 2, false);
        return false;
      }
      SimpleCacheEntry::WriteSparseDataCallback callback =
          SimpleCacheEntry_WriteSparseData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WriteSparseData(
std::move(p_offset), 
std::move(p_data), std::move(callback));
      return true;
    }
    case internal::kSimpleCacheEntry_ReadSparseData_Name: {

      internal::SimpleCacheEntry_ReadSparseData_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCacheEntry_ReadSparseData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_offset{};
      uint32_t p_length{};
      SimpleCacheEntry_ReadSparseData_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_offset = input_data_view.offset();
      if (success)
        p_length = input_data_view.length();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCacheEntry::Name_, 3, false);
        return false;
      }
      SimpleCacheEntry::ReadSparseDataCallback callback =
          SimpleCacheEntry_ReadSparseData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReadSparseData(
std::move(p_offset), 
std::move(p_length), std::move(callback));
      return true;
    }
    case internal::kSimpleCacheEntry_Close_Name: {

      internal::SimpleCacheEntry_Close_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCacheEntry_Close_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleCacheEntry_Close_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCacheEntry::Name_, 4, false);
        return false;
      }
      SimpleCacheEntry::CloseCallback callback =
          SimpleCacheEntry_Close_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Close(std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSimpleCacheEntryValidationInfo[] = {
    {&internal::SimpleCacheEntry_WriteData_Params_Data::Validate,
     &internal::SimpleCacheEntry_WriteData_ResponseParams_Data::Validate},
    {&internal::SimpleCacheEntry_ReadData_Params_Data::Validate,
     &internal::SimpleCacheEntry_ReadData_ResponseParams_Data::Validate},
    {&internal::SimpleCacheEntry_WriteSparseData_Params_Data::Validate,
     &internal::SimpleCacheEntry_WriteSparseData_ResponseParams_Data::Validate},
    {&internal::SimpleCacheEntry_ReadSparseData_Params_Data::Validate,
     &internal::SimpleCacheEntry_ReadSparseData_ResponseParams_Data::Validate},
    {&internal::SimpleCacheEntry_Close_Params_Data::Validate,
     &internal::SimpleCacheEntry_Close_ResponseParams_Data::Validate},
};

bool SimpleCacheEntryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::SimpleCacheEntry::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSimpleCacheEntryValidationInfo);
}

bool SimpleCacheEntryResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::SimpleCacheEntry::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kSimpleCacheEntryValidationInfo);
}
const char SimpleCacheEntryEnumerator::Name_[] = "network.mojom.SimpleCacheEntryEnumerator";

SimpleCacheEntryEnumerator::IPCStableHashFunction SimpleCacheEntryEnumerator::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSimpleCacheEntryEnumerator_GetNext_Name: {
      return &SimpleCacheEntryEnumerator::GetNext_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SimpleCacheEntryEnumerator::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSimpleCacheEntryEnumerator_GetNext_Name:
            return "Receive network::mojom::SimpleCacheEntryEnumerator::GetNext";
    }
  } else {
    switch (message.name()) {
      case internal::kSimpleCacheEntryEnumerator_GetNext_Name:
            return "Receive reply network::mojom::SimpleCacheEntryEnumerator::GetNext";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SimpleCacheEntryEnumerator::GetNext_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCacheEntryEnumerator::GetNext");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class SimpleCacheEntryEnumerator_GetNext_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCacheEntryEnumerator_GetNext_ForwardToCallback(
      SimpleCacheEntryEnumerator::GetNextCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCacheEntryEnumerator_GetNext_ForwardToCallback(const SimpleCacheEntryEnumerator_GetNext_ForwardToCallback&) = delete;
  SimpleCacheEntryEnumerator_GetNext_ForwardToCallback& operator=(const SimpleCacheEntryEnumerator_GetNext_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCacheEntryEnumerator::GetNextCallback callback_;
};

SimpleCacheEntryEnumeratorProxy::SimpleCacheEntryEnumeratorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SimpleCacheEntryEnumeratorProxy::GetNext(
    GetNextCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::SimpleCacheEntryEnumerator::GetNext");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntryEnumerator_GetNext_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntryEnumerator_GetNext_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntryEnumerator::Name_);
  message.set_method_name("GetNext");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCacheEntryEnumerator_GetNext_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class SimpleCacheEntryEnumerator_GetNext_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCacheEntryEnumerator::GetNextCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCacheEntryEnumerator_GetNext_ProxyToResponder> proxy(
        new SimpleCacheEntryEnumerator_GetNext_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCacheEntryEnumerator_GetNext_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCacheEntryEnumerator_GetNext_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCacheEntryEnumerator_GetNext_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCacheEntryEnumerator::GetNextCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      SimpleCacheOpenEntryResultPtr in_result);
};

bool SimpleCacheEntryEnumerator_GetNext_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCacheEntryEnumerator_GetNext_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCacheEntryEnumerator_GetNext_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SimpleCacheOpenEntryResultPtr p_result{};
  SimpleCacheEntryEnumerator_GetNext_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCacheEntryEnumerator::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void SimpleCacheEntryEnumerator_GetNext_ProxyToResponder::Run(
    SimpleCacheOpenEntryResultPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCacheEntryEnumerator::GetNext", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type SimpleCacheOpenEntryResultPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCacheEntryEnumerator_GetNext_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCacheEntryEnumerator_GetNext_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::SimpleCacheOpenEntryResultDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCacheEntryEnumerator::Name_);
  message.set_method_name("GetNext");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool SimpleCacheEntryEnumeratorStubDispatch::Accept(
    SimpleCacheEntryEnumerator* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSimpleCacheEntryEnumerator_GetNext_Name: {
      break;
    }
  }
  return false;
}

// static
bool SimpleCacheEntryEnumeratorStubDispatch::AcceptWithResponder(
    SimpleCacheEntryEnumerator* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSimpleCacheEntryEnumerator_GetNext_Name: {

      internal::SimpleCacheEntryEnumerator_GetNext_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCacheEntryEnumerator_GetNext_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleCacheEntryEnumerator_GetNext_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCacheEntryEnumerator::Name_, 0, false);
        return false;
      }
      SimpleCacheEntryEnumerator::GetNextCallback callback =
          SimpleCacheEntryEnumerator_GetNext_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetNext(std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSimpleCacheEntryEnumeratorValidationInfo[] = {
    {&internal::SimpleCacheEntryEnumerator_GetNext_Params_Data::Validate,
     &internal::SimpleCacheEntryEnumerator_GetNext_ResponseParams_Data::Validate},
};

bool SimpleCacheEntryEnumeratorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::SimpleCacheEntryEnumerator::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSimpleCacheEntryEnumeratorValidationInfo);
}

bool SimpleCacheEntryEnumeratorResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::SimpleCacheEntryEnumerator::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kSimpleCacheEntryEnumeratorValidationInfo);
}
const char SimpleCache::Name_[] = "network.mojom.SimpleCache";

SimpleCache::IPCStableHashFunction SimpleCache::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSimpleCache_CreateEntry_Name: {
      return &SimpleCache::CreateEntry_Sym::IPCStableHash;
    }
    case internal::kSimpleCache_OpenEntry_Name: {
      return &SimpleCache::OpenEntry_Sym::IPCStableHash;
    }
    case internal::kSimpleCache_DoomEntry_Name: {
      return &SimpleCache::DoomEntry_Sym::IPCStableHash;
    }
    case internal::kSimpleCache_DoomAllEntries_Name: {
      return &SimpleCache::DoomAllEntries_Sym::IPCStableHash;
    }
    case internal::kSimpleCache_EnumerateEntries_Name: {
      return &SimpleCache::EnumerateEntries_Sym::IPCStableHash;
    }
    case internal::kSimpleCache_Detach_Name: {
      return &SimpleCache::Detach_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SimpleCache::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSimpleCache_CreateEntry_Name:
            return "Receive network::mojom::SimpleCache::CreateEntry";
      case internal::kSimpleCache_OpenEntry_Name:
            return "Receive network::mojom::SimpleCache::OpenEntry";
      case internal::kSimpleCache_DoomEntry_Name:
            return "Receive network::mojom::SimpleCache::DoomEntry";
      case internal::kSimpleCache_DoomAllEntries_Name:
            return "Receive network::mojom::SimpleCache::DoomAllEntries";
      case internal::kSimpleCache_EnumerateEntries_Name:
            return "Receive network::mojom::SimpleCache::EnumerateEntries";
      case internal::kSimpleCache_Detach_Name:
            return "Receive network::mojom::SimpleCache::Detach";
    }
  } else {
    switch (message.name()) {
      case internal::kSimpleCache_CreateEntry_Name:
            return "Receive reply network::mojom::SimpleCache::CreateEntry";
      case internal::kSimpleCache_OpenEntry_Name:
            return "Receive reply network::mojom::SimpleCache::OpenEntry";
      case internal::kSimpleCache_DoomEntry_Name:
            return "Receive reply network::mojom::SimpleCache::DoomEntry";
      case internal::kSimpleCache_DoomAllEntries_Name:
            return "Receive reply network::mojom::SimpleCache::DoomAllEntries";
      case internal::kSimpleCache_EnumerateEntries_Name:
            return "Receive reply network::mojom::SimpleCache::EnumerateEntries";
      case internal::kSimpleCache_Detach_Name:
            return "Receive reply network::mojom::SimpleCache::Detach";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SimpleCache::CreateEntry_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCache::CreateEntry");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCache::OpenEntry_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCache::OpenEntry");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCache::DoomEntry_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCache::DoomEntry");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCache::DoomAllEntries_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCache::DoomAllEntries");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCache::EnumerateEntries_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCache::EnumerateEntries");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SimpleCache::Detach_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::SimpleCache::Detach");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class SimpleCache_CreateEntry_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCache_CreateEntry_ForwardToCallback(
      SimpleCache::CreateEntryCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCache_CreateEntry_ForwardToCallback(const SimpleCache_CreateEntry_ForwardToCallback&) = delete;
  SimpleCache_CreateEntry_ForwardToCallback& operator=(const SimpleCache_CreateEntry_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCache::CreateEntryCallback callback_;
};

class SimpleCache_OpenEntry_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCache_OpenEntry_ForwardToCallback(
      SimpleCache::OpenEntryCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCache_OpenEntry_ForwardToCallback(const SimpleCache_OpenEntry_ForwardToCallback&) = delete;
  SimpleCache_OpenEntry_ForwardToCallback& operator=(const SimpleCache_OpenEntry_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCache::OpenEntryCallback callback_;
};

class SimpleCache_DoomEntry_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCache_DoomEntry_ForwardToCallback(
      SimpleCache::DoomEntryCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCache_DoomEntry_ForwardToCallback(const SimpleCache_DoomEntry_ForwardToCallback&) = delete;
  SimpleCache_DoomEntry_ForwardToCallback& operator=(const SimpleCache_DoomEntry_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCache::DoomEntryCallback callback_;
};

class SimpleCache_DoomAllEntries_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCache_DoomAllEntries_ForwardToCallback(
      SimpleCache::DoomAllEntriesCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCache_DoomAllEntries_ForwardToCallback(const SimpleCache_DoomAllEntries_ForwardToCallback&) = delete;
  SimpleCache_DoomAllEntries_ForwardToCallback& operator=(const SimpleCache_DoomAllEntries_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCache::DoomAllEntriesCallback callback_;
};

class SimpleCache_Detach_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SimpleCache_Detach_ForwardToCallback(
      SimpleCache::DetachCallback callback
      ) : callback_(std::move(callback)) {
  }

  SimpleCache_Detach_ForwardToCallback(const SimpleCache_Detach_ForwardToCallback&) = delete;
  SimpleCache_Detach_ForwardToCallback& operator=(const SimpleCache_Detach_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SimpleCache::DetachCallback callback_;
};

SimpleCacheProxy::SimpleCacheProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SimpleCacheProxy::CreateEntry(
    const WTF::String& in_key, CreateEntryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCache::CreateEntry", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_CreateEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_CreateEntry_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in SimpleCache.CreateEntry request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("CreateEntry");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCache_CreateEntry_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheProxy::OpenEntry(
    const WTF::String& in_key, OpenEntryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCache::OpenEntry", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_OpenEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_OpenEntry_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in SimpleCache.OpenEntry request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("OpenEntry");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCache_OpenEntry_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheProxy::DoomEntry(
    const WTF::String& in_key, DoomEntryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCache::DoomEntry", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_DoomEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_DoomEntry_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in SimpleCache.DoomEntry request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("DoomEntry");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCache_DoomEntry_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheProxy::DoomAllEntries(
    DoomAllEntriesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::SimpleCache::DoomAllEntries");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_DoomAllEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_DoomAllEntries_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("DoomAllEntries");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCache_DoomAllEntries_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SimpleCacheProxy::EnumerateEntries(
    ::mojo::PendingReceiver<SimpleCacheEntryEnumerator> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::SimpleCache::EnumerateEntries", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<SimpleCacheEntryEnumerator>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_EnumerateEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_EnumerateEntries_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::SimpleCacheEntryEnumeratorInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in SimpleCache.EnumerateEntries request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("EnumerateEntries");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SimpleCacheProxy::Detach(
    DetachCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::SimpleCache::Detach");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_Detach_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_Detach_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("Detach");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SimpleCache_Detach_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class SimpleCache_CreateEntry_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCache::CreateEntryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCache_CreateEntry_ProxyToResponder> proxy(
        new SimpleCache_CreateEntry_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCache_CreateEntry_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCache_CreateEntry_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCache_CreateEntry_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCache::CreateEntryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingRemote<SimpleCacheEntry> in_entry, int32_t in_error);
};

bool SimpleCache_CreateEntry_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCache_CreateEntry_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCache_CreateEntry_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::PendingRemote<SimpleCacheEntry> p_entry{};
  int32_t p_error{};
  SimpleCache_CreateEntry_ResponseParamsDataView input_data_view(params, message);
  
  if (success) {
    p_entry =
        input_data_view.TakeEntry<decltype(p_entry)>();
  }
  if (success)
    p_error = input_data_view.error();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCache::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_entry), 
std::move(p_error));
  return true;
}

void SimpleCache_CreateEntry_ProxyToResponder::Run(
    ::mojo::PendingRemote<SimpleCacheEntry> in_entry, int32_t in_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCache::CreateEntry", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("entry"), in_entry,
                        "<value of type ::mojo::PendingRemote<SimpleCacheEntry>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error"), in_error,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_CreateEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_CreateEntry_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::SimpleCacheEntryInterfaceBase>>(
      in_entry, &params->entry, &params.message());
  params->error = in_error;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("CreateEntry");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCache_OpenEntry_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCache::OpenEntryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCache_OpenEntry_ProxyToResponder> proxy(
        new SimpleCache_OpenEntry_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCache_OpenEntry_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCache_OpenEntry_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCache_OpenEntry_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCache::OpenEntryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingRemote<SimpleCacheEntry> in_entry, int32_t in_error);
};

bool SimpleCache_OpenEntry_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCache_OpenEntry_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCache_OpenEntry_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::PendingRemote<SimpleCacheEntry> p_entry{};
  int32_t p_error{};
  SimpleCache_OpenEntry_ResponseParamsDataView input_data_view(params, message);
  
  if (success) {
    p_entry =
        input_data_view.TakeEntry<decltype(p_entry)>();
  }
  if (success)
    p_error = input_data_view.error();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCache::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_entry), 
std::move(p_error));
  return true;
}

void SimpleCache_OpenEntry_ProxyToResponder::Run(
    ::mojo::PendingRemote<SimpleCacheEntry> in_entry, int32_t in_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCache::OpenEntry", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("entry"), in_entry,
                        "<value of type ::mojo::PendingRemote<SimpleCacheEntry>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error"), in_error,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_OpenEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_OpenEntry_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::SimpleCacheEntryInterfaceBase>>(
      in_entry, &params->entry, &params.message());
  params->error = in_error;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("OpenEntry");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCache_DoomEntry_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCache::DoomEntryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCache_DoomEntry_ProxyToResponder> proxy(
        new SimpleCache_DoomEntry_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCache_DoomEntry_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCache_DoomEntry_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCache_DoomEntry_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCache::DoomEntryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result);
};

bool SimpleCache_DoomEntry_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCache_DoomEntry_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCache_DoomEntry_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  SimpleCache_DoomEntry_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCache::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void SimpleCache_DoomEntry_ProxyToResponder::Run(
    int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCache::DoomEntry", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_DoomEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_DoomEntry_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("DoomEntry");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCache_DoomAllEntries_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCache::DoomAllEntriesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCache_DoomAllEntries_ProxyToResponder> proxy(
        new SimpleCache_DoomAllEntries_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCache_DoomAllEntries_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCache_DoomAllEntries_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCache_DoomAllEntries_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCache::DoomAllEntriesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result);
};

bool SimpleCache_DoomAllEntries_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCache_DoomAllEntries_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCache_DoomAllEntries_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  SimpleCache_DoomAllEntries_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCache::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void SimpleCache_DoomAllEntries_ProxyToResponder::Run(
    int32_t in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::SimpleCache::DoomAllEntries", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_DoomAllEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_DoomAllEntries_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("DoomAllEntries");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SimpleCache_Detach_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SimpleCache::DetachCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SimpleCache_Detach_ProxyToResponder> proxy(
        new SimpleCache_Detach_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SimpleCache_Detach_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SimpleCache_Detach_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SimpleCache_Detach_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SimpleCache::DetachCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool SimpleCache_Detach_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SimpleCache_Detach_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SimpleCache_Detach_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SimpleCache_Detach_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SimpleCache::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void SimpleCache_Detach_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::SimpleCache::Detach");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSimpleCache_Detach_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::SimpleCache_Detach_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SimpleCache::Name_);
  message.set_method_name("Detach");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool SimpleCacheStubDispatch::Accept(
    SimpleCache* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSimpleCache_CreateEntry_Name: {
      break;
    }
    case internal::kSimpleCache_OpenEntry_Name: {
      break;
    }
    case internal::kSimpleCache_DoomEntry_Name: {
      break;
    }
    case internal::kSimpleCache_DoomAllEntries_Name: {
      break;
    }
    case internal::kSimpleCache_EnumerateEntries_Name: {

      DCHECK(message->is_serialized());
      internal::SimpleCache_EnumerateEntries_Params_Data* params =
          reinterpret_cast<internal::SimpleCache_EnumerateEntries_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<SimpleCacheEntryEnumerator> p_receiver{};
      SimpleCache_EnumerateEntries_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCache::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnumerateEntries(
std::move(p_receiver));
      return true;
    }
    case internal::kSimpleCache_Detach_Name: {
      break;
    }
  }
  return false;
}

// static
bool SimpleCacheStubDispatch::AcceptWithResponder(
    SimpleCache* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSimpleCache_CreateEntry_Name: {

      internal::SimpleCache_CreateEntry_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCache_CreateEntry_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_key{};
      SimpleCache_CreateEntry_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCache::Name_, 0, false);
        return false;
      }
      SimpleCache::CreateEntryCallback callback =
          SimpleCache_CreateEntry_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateEntry(
std::move(p_key), std::move(callback));
      return true;
    }
    case internal::kSimpleCache_OpenEntry_Name: {

      internal::SimpleCache_OpenEntry_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCache_OpenEntry_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_key{};
      SimpleCache_OpenEntry_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCache::Name_, 1, false);
        return false;
      }
      SimpleCache::OpenEntryCallback callback =
          SimpleCache_OpenEntry_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenEntry(
std::move(p_key), std::move(callback));
      return true;
    }
    case internal::kSimpleCache_DoomEntry_Name: {

      internal::SimpleCache_DoomEntry_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCache_DoomEntry_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_key{};
      SimpleCache_DoomEntry_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCache::Name_, 2, false);
        return false;
      }
      SimpleCache::DoomEntryCallback callback =
          SimpleCache_DoomEntry_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DoomEntry(
std::move(p_key), std::move(callback));
      return true;
    }
    case internal::kSimpleCache_DoomAllEntries_Name: {

      internal::SimpleCache_DoomAllEntries_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCache_DoomAllEntries_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleCache_DoomAllEntries_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCache::Name_, 3, false);
        return false;
      }
      SimpleCache::DoomAllEntriesCallback callback =
          SimpleCache_DoomAllEntries_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DoomAllEntries(std::move(callback));
      return true;
    }
    case internal::kSimpleCache_EnumerateEntries_Name: {
      break;
    }
    case internal::kSimpleCache_Detach_Name: {

      internal::SimpleCache_Detach_Params_Data* params =
          reinterpret_cast<
              internal::SimpleCache_Detach_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SimpleCache_Detach_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SimpleCache::Name_, 5, false);
        return false;
      }
      SimpleCache::DetachCallback callback =
          SimpleCache_Detach_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Detach(std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSimpleCacheValidationInfo[] = {
    {&internal::SimpleCache_CreateEntry_Params_Data::Validate,
     &internal::SimpleCache_CreateEntry_ResponseParams_Data::Validate},
    {&internal::SimpleCache_OpenEntry_Params_Data::Validate,
     &internal::SimpleCache_OpenEntry_ResponseParams_Data::Validate},
    {&internal::SimpleCache_DoomEntry_Params_Data::Validate,
     &internal::SimpleCache_DoomEntry_ResponseParams_Data::Validate},
    {&internal::SimpleCache_DoomAllEntries_Params_Data::Validate,
     &internal::SimpleCache_DoomAllEntries_ResponseParams_Data::Validate},
    {&internal::SimpleCache_EnumerateEntries_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SimpleCache_Detach_Params_Data::Validate,
     &internal::SimpleCache_Detach_ResponseParams_Data::Validate},
};

bool SimpleCacheRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::SimpleCache::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSimpleCacheValidationInfo);
}

bool SimpleCacheResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::SimpleCache::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kSimpleCacheValidationInfo);
}
const char NetworkServiceTest::Name_[] = "network.mojom.NetworkServiceTest";

NetworkServiceTest::IPCStableHashFunction NetworkServiceTest::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kNetworkServiceTest_AddRules_Name: {
      return &NetworkServiceTest::AddRules_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SimulateNetworkChange_Name: {
      return &NetworkServiceTest::SimulateNetworkChange_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name: {
      return &NetworkServiceTest::SimulateNetworkQualityChange_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name: {
      return &NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SimulateCrash_Name: {
      return &NetworkServiceTest::SimulateCrash_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name: {
      return &NetworkServiceTest::MockCertVerifierSetDefaultResult_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name: {
      return &NetworkServiceTest::MockCertVerifierAddResultForCertAndHost_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SetRequireCT_Name: {
      return &NetworkServiceTest::SetRequireCT_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name: {
      return &NetworkServiceTest::SetTransportSecurityStateSource_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name: {
      return &NetworkServiceTest::SetAllowNetworkAccessToHostResolutions_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name: {
      return &NetworkServiceTest::ReplaceSystemDnsConfig_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SetTestDohConfig_Name: {
      return &NetworkServiceTest::SetTestDohConfig_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_CrashOnResolveHost_Name: {
      return &NetworkServiceTest::CrashOnResolveHost_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_CrashOnGetCookieList_Name: {
      return &NetworkServiceTest::CrashOnGetCookieList_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name: {
      return &NetworkServiceTest::GetLatestMemoryPressureLevel_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name: {
      return &NetworkServiceTest::GetPeerToPeerConnectionsCountChange_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name: {
      return &NetworkServiceTest::GetEnvironmentVariableValue_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_Log_Name: {
      return &NetworkServiceTest::Log_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_ActivateFieldTrial_Name: {
      return &NetworkServiceTest::ActivateFieldTrial_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name: {
      return &NetworkServiceTest::SetSCTAuditingRetryDelay_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_OpenFile_Name: {
      return &NetworkServiceTest::OpenFile_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_EnumerateFiles_Name: {
      return &NetworkServiceTest::EnumerateFiles_Sym::IPCStableHash;
    }
    case internal::kNetworkServiceTest_CreateSimpleCache_Name: {
      return &NetworkServiceTest::CreateSimpleCache_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* NetworkServiceTest::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kNetworkServiceTest_AddRules_Name:
            return "Receive network::mojom::NetworkServiceTest::AddRules";
      case internal::kNetworkServiceTest_SimulateNetworkChange_Name:
            return "Receive network::mojom::NetworkServiceTest::SimulateNetworkChange";
      case internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name:
            return "Receive network::mojom::NetworkServiceTest::SimulateNetworkQualityChange";
      case internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name:
            return "Receive network::mojom::NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G";
      case internal::kNetworkServiceTest_SimulateCrash_Name:
            return "Receive network::mojom::NetworkServiceTest::SimulateCrash";
      case internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name:
            return "Receive network::mojom::NetworkServiceTest::MockCertVerifierSetDefaultResult";
      case internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name:
            return "Receive network::mojom::NetworkServiceTest::MockCertVerifierAddResultForCertAndHost";
      case internal::kNetworkServiceTest_SetRequireCT_Name:
            return "Receive network::mojom::NetworkServiceTest::SetRequireCT";
      case internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name:
            return "Receive network::mojom::NetworkServiceTest::SetTransportSecurityStateSource";
      case internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name:
            return "Receive network::mojom::NetworkServiceTest::SetAllowNetworkAccessToHostResolutions";
      case internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name:
            return "Receive network::mojom::NetworkServiceTest::ReplaceSystemDnsConfig";
      case internal::kNetworkServiceTest_SetTestDohConfig_Name:
            return "Receive network::mojom::NetworkServiceTest::SetTestDohConfig";
      case internal::kNetworkServiceTest_CrashOnResolveHost_Name:
            return "Receive network::mojom::NetworkServiceTest::CrashOnResolveHost";
      case internal::kNetworkServiceTest_CrashOnGetCookieList_Name:
            return "Receive network::mojom::NetworkServiceTest::CrashOnGetCookieList";
      case internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name:
            return "Receive network::mojom::NetworkServiceTest::GetLatestMemoryPressureLevel";
      case internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name:
            return "Receive network::mojom::NetworkServiceTest::GetPeerToPeerConnectionsCountChange";
      case internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name:
            return "Receive network::mojom::NetworkServiceTest::GetEnvironmentVariableValue";
      case internal::kNetworkServiceTest_Log_Name:
            return "Receive network::mojom::NetworkServiceTest::Log";
      case internal::kNetworkServiceTest_ActivateFieldTrial_Name:
            return "Receive network::mojom::NetworkServiceTest::ActivateFieldTrial";
      case internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name:
            return "Receive network::mojom::NetworkServiceTest::SetSCTAuditingRetryDelay";
      case internal::kNetworkServiceTest_OpenFile_Name:
            return "Receive network::mojom::NetworkServiceTest::OpenFile";
      case internal::kNetworkServiceTest_EnumerateFiles_Name:
            return "Receive network::mojom::NetworkServiceTest::EnumerateFiles";
      case internal::kNetworkServiceTest_CreateSimpleCache_Name:
            return "Receive network::mojom::NetworkServiceTest::CreateSimpleCache";
    }
  } else {
    switch (message.name()) {
      case internal::kNetworkServiceTest_AddRules_Name:
            return "Receive reply network::mojom::NetworkServiceTest::AddRules";
      case internal::kNetworkServiceTest_SimulateNetworkChange_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SimulateNetworkChange";
      case internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SimulateNetworkQualityChange";
      case internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name:
            return "Receive reply network::mojom::NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G";
      case internal::kNetworkServiceTest_SimulateCrash_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SimulateCrash";
      case internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name:
            return "Receive reply network::mojom::NetworkServiceTest::MockCertVerifierSetDefaultResult";
      case internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name:
            return "Receive reply network::mojom::NetworkServiceTest::MockCertVerifierAddResultForCertAndHost";
      case internal::kNetworkServiceTest_SetRequireCT_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SetRequireCT";
      case internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SetTransportSecurityStateSource";
      case internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SetAllowNetworkAccessToHostResolutions";
      case internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name:
            return "Receive reply network::mojom::NetworkServiceTest::ReplaceSystemDnsConfig";
      case internal::kNetworkServiceTest_SetTestDohConfig_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SetTestDohConfig";
      case internal::kNetworkServiceTest_CrashOnResolveHost_Name:
            return "Receive reply network::mojom::NetworkServiceTest::CrashOnResolveHost";
      case internal::kNetworkServiceTest_CrashOnGetCookieList_Name:
            return "Receive reply network::mojom::NetworkServiceTest::CrashOnGetCookieList";
      case internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name:
            return "Receive reply network::mojom::NetworkServiceTest::GetLatestMemoryPressureLevel";
      case internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name:
            return "Receive reply network::mojom::NetworkServiceTest::GetPeerToPeerConnectionsCountChange";
      case internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name:
            return "Receive reply network::mojom::NetworkServiceTest::GetEnvironmentVariableValue";
      case internal::kNetworkServiceTest_Log_Name:
            return "Receive reply network::mojom::NetworkServiceTest::Log";
      case internal::kNetworkServiceTest_ActivateFieldTrial_Name:
            return "Receive reply network::mojom::NetworkServiceTest::ActivateFieldTrial";
      case internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name:
            return "Receive reply network::mojom::NetworkServiceTest::SetSCTAuditingRetryDelay";
      case internal::kNetworkServiceTest_OpenFile_Name:
            return "Receive reply network::mojom::NetworkServiceTest::OpenFile";
      case internal::kNetworkServiceTest_EnumerateFiles_Name:
            return "Receive reply network::mojom::NetworkServiceTest::EnumerateFiles";
      case internal::kNetworkServiceTest_CreateSimpleCache_Name:
            return "Receive reply network::mojom::NetworkServiceTest::CreateSimpleCache";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t NetworkServiceTest::AddRules_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::AddRules");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SimulateNetworkChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SimulateNetworkChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SimulateNetworkQualityChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SimulateNetworkQualityChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SimulateCrash_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SimulateCrash");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::MockCertVerifierSetDefaultResult_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::MockCertVerifierSetDefaultResult");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::MockCertVerifierAddResultForCertAndHost_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::MockCertVerifierAddResultForCertAndHost");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SetRequireCT_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SetRequireCT");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SetTransportSecurityStateSource_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SetTransportSecurityStateSource");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SetAllowNetworkAccessToHostResolutions_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SetAllowNetworkAccessToHostResolutions");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::ReplaceSystemDnsConfig_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::ReplaceSystemDnsConfig");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SetTestDohConfig_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SetTestDohConfig");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::CrashOnResolveHost_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::CrashOnResolveHost");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::CrashOnGetCookieList_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::CrashOnGetCookieList");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::GetLatestMemoryPressureLevel_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::GetLatestMemoryPressureLevel");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::GetPeerToPeerConnectionsCountChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::GetPeerToPeerConnectionsCountChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::GetEnvironmentVariableValue_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::GetEnvironmentVariableValue");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::Log_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::Log");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::ActivateFieldTrial_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::ActivateFieldTrial");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::SetSCTAuditingRetryDelay_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::SetSCTAuditingRetryDelay");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::OpenFile_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::OpenFile");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::EnumerateFiles_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::EnumerateFiles");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkServiceTest::CreateSimpleCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkServiceTest::CreateSimpleCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)
bool NetworkServiceTest::AddRules(WTF::Vector<RulePtr> rules) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::MockCertVerifierSetDefaultResult(int32_t default_result) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::MockCertVerifierAddResultForCertAndHost(::network::mojom::blink::X509CertificatePtr cert, const WTF::String& host_pattern, ::network::mojom::blink::CertVerifyResultPtr verify_result, int32_t rv) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::SetRequireCT(NetworkServiceTest::RequireCT required) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::SetTransportSecurityStateSource(uint16_t reporting_port) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::SetAllowNetworkAccessToHostResolutions() {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::ReplaceSystemDnsConfig() {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::SetTestDohConfig(::network::mojom::blink::SecureDnsMode secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr doh_config) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::GetLatestMemoryPressureLevel(::mojo_base::mojom::blink::MemoryPressureLevel* out_memory_pressure_level) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::GetPeerToPeerConnectionsCountChange(uint32_t* out_connection_count) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::GetEnvironmentVariableValue(const WTF::String& name, WTF::String* out_value) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::Log(const WTF::String& message) {
  NOTREACHED();
  return false;
}
bool NetworkServiceTest::SetSCTAuditingRetryDelay(absl::optional<::base::TimeDelta> delay) {
  NOTREACHED();
  return false;
}
class NetworkServiceTest_AddRules_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_AddRules_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_AddRules_HandleSyncResponse(const NetworkServiceTest_AddRules_HandleSyncResponse&) = delete;
  NetworkServiceTest_AddRules_HandleSyncResponse& operator=(const NetworkServiceTest_AddRules_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_AddRules_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_AddRules_ForwardToCallback(
      NetworkServiceTest::AddRulesCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_AddRules_ForwardToCallback(const NetworkServiceTest_AddRules_ForwardToCallback&) = delete;
  NetworkServiceTest_AddRules_ForwardToCallback& operator=(const NetworkServiceTest_AddRules_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::AddRulesCallback callback_;
};

class NetworkServiceTest_SimulateNetworkChange_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SimulateNetworkChange_ForwardToCallback(
      NetworkServiceTest::SimulateNetworkChangeCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SimulateNetworkChange_ForwardToCallback(const NetworkServiceTest_SimulateNetworkChange_ForwardToCallback&) = delete;
  NetworkServiceTest_SimulateNetworkChange_ForwardToCallback& operator=(const NetworkServiceTest_SimulateNetworkChange_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SimulateNetworkChangeCallback callback_;
};

class NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback(
      NetworkServiceTest::SimulateNetworkQualityChangeCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback(const NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback&) = delete;
  NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback& operator=(const NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SimulateNetworkQualityChangeCallback callback_;
};

class NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback(
      NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback(const NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback&) = delete;
  NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback& operator=(const NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback callback_;
};
class NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse(const NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse&) = delete;
  NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse& operator=(const NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback(
      NetworkServiceTest::MockCertVerifierSetDefaultResultCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback(const NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback&) = delete;
  NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback& operator=(const NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::MockCertVerifierSetDefaultResultCallback callback_;
};
class NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse(const NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse&) = delete;
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse& operator=(const NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback(
      NetworkServiceTest::MockCertVerifierAddResultForCertAndHostCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback(const NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback&) = delete;
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback& operator=(const NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::MockCertVerifierAddResultForCertAndHostCallback callback_;
};
class NetworkServiceTest_SetRequireCT_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetRequireCT_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_SetRequireCT_HandleSyncResponse(const NetworkServiceTest_SetRequireCT_HandleSyncResponse&) = delete;
  NetworkServiceTest_SetRequireCT_HandleSyncResponse& operator=(const NetworkServiceTest_SetRequireCT_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_SetRequireCT_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetRequireCT_ForwardToCallback(
      NetworkServiceTest::SetRequireCTCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SetRequireCT_ForwardToCallback(const NetworkServiceTest_SetRequireCT_ForwardToCallback&) = delete;
  NetworkServiceTest_SetRequireCT_ForwardToCallback& operator=(const NetworkServiceTest_SetRequireCT_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SetRequireCTCallback callback_;
};
class NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse(const NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse&) = delete;
  NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse& operator=(const NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback(
      NetworkServiceTest::SetTransportSecurityStateSourceCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback(const NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback&) = delete;
  NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback& operator=(const NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SetTransportSecurityStateSourceCallback callback_;
};
class NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse(const NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse&) = delete;
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse& operator=(const NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback(
      NetworkServiceTest::SetAllowNetworkAccessToHostResolutionsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback(const NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback&) = delete;
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback& operator=(const NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SetAllowNetworkAccessToHostResolutionsCallback callback_;
};
class NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse(const NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse&) = delete;
  NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse& operator=(const NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback(
      NetworkServiceTest::ReplaceSystemDnsConfigCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback(const NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback&) = delete;
  NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback& operator=(const NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::ReplaceSystemDnsConfigCallback callback_;
};
class NetworkServiceTest_SetTestDohConfig_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetTestDohConfig_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_SetTestDohConfig_HandleSyncResponse(const NetworkServiceTest_SetTestDohConfig_HandleSyncResponse&) = delete;
  NetworkServiceTest_SetTestDohConfig_HandleSyncResponse& operator=(const NetworkServiceTest_SetTestDohConfig_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_SetTestDohConfig_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetTestDohConfig_ForwardToCallback(
      NetworkServiceTest::SetTestDohConfigCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SetTestDohConfig_ForwardToCallback(const NetworkServiceTest_SetTestDohConfig_ForwardToCallback&) = delete;
  NetworkServiceTest_SetTestDohConfig_ForwardToCallback& operator=(const NetworkServiceTest_SetTestDohConfig_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SetTestDohConfigCallback callback_;
};
class NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse(
      bool* result, ::mojo_base::mojom::blink::MemoryPressureLevel* out_memory_pressure_level)
      : result_(result), out_memory_pressure_level_(out_memory_pressure_level) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse(const NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse&) = delete;
  NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse& operator=(const NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  ::mojo_base::mojom::blink::MemoryPressureLevel* out_memory_pressure_level_;};

class NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback(
      NetworkServiceTest::GetLatestMemoryPressureLevelCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback(const NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback&) = delete;
  NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback& operator=(const NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::GetLatestMemoryPressureLevelCallback callback_;
};
class NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse(
      bool* result, uint32_t* out_connection_count)
      : result_(result), out_connection_count_(out_connection_count) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse(const NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse&) = delete;
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse& operator=(const NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  uint32_t* out_connection_count_;};

class NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback(
      NetworkServiceTest::GetPeerToPeerConnectionsCountChangeCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback(const NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback&) = delete;
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback& operator=(const NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::GetPeerToPeerConnectionsCountChangeCallback callback_;
};
class NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse(
      bool* result, WTF::String* out_value)
      : result_(result), out_value_(out_value) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse(const NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse&) = delete;
  NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse& operator=(const NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  WTF::String* out_value_;};

class NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback(
      NetworkServiceTest::GetEnvironmentVariableValueCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback(const NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback&) = delete;
  NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback& operator=(const NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::GetEnvironmentVariableValueCallback callback_;
};
class NetworkServiceTest_Log_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_Log_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_Log_HandleSyncResponse(const NetworkServiceTest_Log_HandleSyncResponse&) = delete;
  NetworkServiceTest_Log_HandleSyncResponse& operator=(const NetworkServiceTest_Log_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_Log_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_Log_ForwardToCallback(
      NetworkServiceTest::LogCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_Log_ForwardToCallback(const NetworkServiceTest_Log_ForwardToCallback&) = delete;
  NetworkServiceTest_Log_ForwardToCallback& operator=(const NetworkServiceTest_Log_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::LogCallback callback_;
};
class NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse(const NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse&) = delete;
  NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse& operator=(const NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback(
      NetworkServiceTest::SetSCTAuditingRetryDelayCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback(const NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback&) = delete;
  NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback& operator=(const NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::SetSCTAuditingRetryDelayCallback callback_;
};

class NetworkServiceTest_OpenFile_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_OpenFile_ForwardToCallback(
      NetworkServiceTest::OpenFileCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_OpenFile_ForwardToCallback(const NetworkServiceTest_OpenFile_ForwardToCallback&) = delete;
  NetworkServiceTest_OpenFile_ForwardToCallback& operator=(const NetworkServiceTest_OpenFile_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::OpenFileCallback callback_;
};

class NetworkServiceTest_EnumerateFiles_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_EnumerateFiles_ForwardToCallback(
      NetworkServiceTest::EnumerateFilesCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_EnumerateFiles_ForwardToCallback(const NetworkServiceTest_EnumerateFiles_ForwardToCallback&) = delete;
  NetworkServiceTest_EnumerateFiles_ForwardToCallback& operator=(const NetworkServiceTest_EnumerateFiles_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::EnumerateFilesCallback callback_;
};

class NetworkServiceTest_CreateSimpleCache_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkServiceTest_CreateSimpleCache_ForwardToCallback(
      NetworkServiceTest::CreateSimpleCacheCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkServiceTest_CreateSimpleCache_ForwardToCallback(const NetworkServiceTest_CreateSimpleCache_ForwardToCallback&) = delete;
  NetworkServiceTest_CreateSimpleCache_ForwardToCallback& operator=(const NetworkServiceTest_CreateSimpleCache_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkServiceTest::CreateSimpleCacheCallback callback_;
};

NetworkServiceTestProxy::NetworkServiceTestProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}
bool NetworkServiceTestProxy::AddRules(
    WTF::Vector<RulePtr> param_rules) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::AddRules (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rules"), param_rules,
                        "<value of type WTF::Vector<RulePtr>>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::AddRules");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_AddRules_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_AddRules_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rules)::BaseType>
      rules_fragment(params.message());
  const mojo::internal::ContainerValidateParams rules_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::RuleDataView>>(
      param_rules, rules_fragment, &rules_validate_params);
  params->rules.Set(
      rules_fragment.is_null() ? nullptr : rules_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rules.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rules in NetworkServiceTest.AddRules request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("AddRules");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_AddRules_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::AddRules");
#endif
  return result;
}

void NetworkServiceTestProxy::AddRules(
    WTF::Vector<RulePtr> in_rules, AddRulesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::AddRules", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rules"), in_rules,
                        "<value of type WTF::Vector<RulePtr>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_AddRules_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_AddRules_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rules)::BaseType>
      rules_fragment(params.message());
  const mojo::internal::ContainerValidateParams rules_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::RuleDataView>>(
      in_rules, rules_fragment, &rules_validate_params);
  params->rules.Set(
      rules_fragment.is_null() ? nullptr : rules_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rules.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rules in NetworkServiceTest.AddRules request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("AddRules");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_AddRules_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::SimulateNetworkChange(
    ::network::mojom::blink::ConnectionType in_type, SimulateNetworkChangeCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::SimulateNetworkChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("type"), in_type,
                        "<value of type ::network::mojom::blink::ConnectionType>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SimulateNetworkChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SimulateNetworkChange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::ConnectionType>(
      in_type, &params->type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SimulateNetworkChange");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SimulateNetworkChange_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::SimulateNetworkQualityChange(
    ::network::mojom::blink::EffectiveConnectionType in_type, SimulateNetworkQualityChangeCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::SimulateNetworkQualityChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("type"), in_type,
                        "<value of type ::network::mojom::blink::EffectiveConnectionType>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SimulateNetworkQualityChange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::EffectiveConnectionType>(
      in_type, &params->type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SimulateNetworkQualityChange");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::ForceNetworkQualityEstimatorReportWifiAsSlow2G(
    ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("ForceNetworkQualityEstimatorReportWifiAsSlow2G");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::SimulateCrash(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::SimulateCrash");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SimulateCrash_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SimulateCrash_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SimulateCrash");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool NetworkServiceTestProxy::MockCertVerifierSetDefaultResult(
    int32_t param_default_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::MockCertVerifierSetDefaultResult (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("default_result"), param_default_result,
                        "<value of type int32_t>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::MockCertVerifierSetDefaultResult");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_Params_Data> params(
          message);
  params.Allocate();
  params->default_result = param_default_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("MockCertVerifierSetDefaultResult");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::MockCertVerifierSetDefaultResult");
#endif
  return result;
}

void NetworkServiceTestProxy::MockCertVerifierSetDefaultResult(
    int32_t in_default_result, MockCertVerifierSetDefaultResultCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::MockCertVerifierSetDefaultResult", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("default_result"), in_default_result,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_Params_Data> params(
          message);
  params.Allocate();
  params->default_result = in_default_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("MockCertVerifierSetDefaultResult");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::MockCertVerifierAddResultForCertAndHost(
    ::network::mojom::blink::X509CertificatePtr param_cert, const WTF::String& param_host_pattern, ::network::mojom::blink::CertVerifyResultPtr param_verify_result, int32_t param_rv) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::MockCertVerifierAddResultForCertAndHost (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cert"), param_cert,
                        "<value of type ::network::mojom::blink::X509CertificatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host_pattern"), param_host_pattern,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("verify_result"), param_verify_result,
                        "<value of type ::network::mojom::blink::CertVerifyResultPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rv"), param_rv,
                        "<value of type int32_t>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::MockCertVerifierAddResultForCertAndHost");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cert)::BaseType> cert_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::X509CertificateDataView>(
      param_cert, cert_fragment);
  params->cert.Set(
      cert_fragment.is_null() ? nullptr : cert_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cert.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cert in NetworkServiceTest.MockCertVerifierAddResultForCertAndHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->host_pattern)::BaseType> host_pattern_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_host_pattern, host_pattern_fragment);
  params->host_pattern.Set(
      host_pattern_fragment.is_null() ? nullptr : host_pattern_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host_pattern.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host_pattern in NetworkServiceTest.MockCertVerifierAddResultForCertAndHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->verify_result)::BaseType> verify_result_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CertVerifyResultDataView>(
      param_verify_result, verify_result_fragment);
  params->verify_result.Set(
      verify_result_fragment.is_null() ? nullptr : verify_result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->verify_result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null verify_result in NetworkServiceTest.MockCertVerifierAddResultForCertAndHost request");
  params->rv = param_rv;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("MockCertVerifierAddResultForCertAndHost");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::MockCertVerifierAddResultForCertAndHost");
#endif
  return result;
}

void NetworkServiceTestProxy::MockCertVerifierAddResultForCertAndHost(
    ::network::mojom::blink::X509CertificatePtr in_cert, const WTF::String& in_host_pattern, ::network::mojom::blink::CertVerifyResultPtr in_verify_result, int32_t in_rv, MockCertVerifierAddResultForCertAndHostCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::MockCertVerifierAddResultForCertAndHost", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cert"), in_cert,
                        "<value of type ::network::mojom::blink::X509CertificatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host_pattern"), in_host_pattern,
                        "<value of type const WTF::String&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("verify_result"), in_verify_result,
                        "<value of type ::network::mojom::blink::CertVerifyResultPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rv"), in_rv,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cert)::BaseType> cert_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::X509CertificateDataView>(
      in_cert, cert_fragment);
  params->cert.Set(
      cert_fragment.is_null() ? nullptr : cert_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cert.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cert in NetworkServiceTest.MockCertVerifierAddResultForCertAndHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->host_pattern)::BaseType> host_pattern_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_host_pattern, host_pattern_fragment);
  params->host_pattern.Set(
      host_pattern_fragment.is_null() ? nullptr : host_pattern_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host_pattern.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host_pattern in NetworkServiceTest.MockCertVerifierAddResultForCertAndHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->verify_result)::BaseType> verify_result_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CertVerifyResultDataView>(
      in_verify_result, verify_result_fragment);
  params->verify_result.Set(
      verify_result_fragment.is_null() ? nullptr : verify_result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->verify_result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null verify_result in NetworkServiceTest.MockCertVerifierAddResultForCertAndHost request");
  params->rv = in_rv;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("MockCertVerifierAddResultForCertAndHost");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::SetRequireCT(
    NetworkServiceTest::RequireCT param_required) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::SetRequireCT (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("required"), param_required,
                        "<value of type NetworkServiceTest::RequireCT>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::SetRequireCT");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetRequireCT_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetRequireCT_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::NetworkServiceTest_RequireCT>(
      param_required, &params->required);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetRequireCT");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetRequireCT_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::SetRequireCT");
#endif
  return result;
}

void NetworkServiceTestProxy::SetRequireCT(
    NetworkServiceTest::RequireCT in_required, SetRequireCTCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::SetRequireCT", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("required"), in_required,
                        "<value of type NetworkServiceTest::RequireCT>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetRequireCT_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetRequireCT_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::NetworkServiceTest_RequireCT>(
      in_required, &params->required);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetRequireCT");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetRequireCT_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::SetTransportSecurityStateSource(
    uint16_t param_reporting_port) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::SetTransportSecurityStateSource (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reporting_port"), param_reporting_port,
                        "<value of type uint16_t>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::SetTransportSecurityStateSource");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetTransportSecurityStateSource_Params_Data> params(
          message);
  params.Allocate();
  params->reporting_port = param_reporting_port;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetTransportSecurityStateSource");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::SetTransportSecurityStateSource");
#endif
  return result;
}

void NetworkServiceTestProxy::SetTransportSecurityStateSource(
    uint16_t in_reporting_port, SetTransportSecurityStateSourceCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::SetTransportSecurityStateSource", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reporting_port"), in_reporting_port,
                        "<value of type uint16_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetTransportSecurityStateSource_Params_Data> params(
          message);
  params.Allocate();
  params->reporting_port = in_reporting_port;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetTransportSecurityStateSource");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::SetAllowNetworkAccessToHostResolutions(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call network::mojom::NetworkServiceTest::SetAllowNetworkAccessToHostResolutions (sync)");
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::SetAllowNetworkAccessToHostResolutions");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetAllowNetworkAccessToHostResolutions");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::SetAllowNetworkAccessToHostResolutions");
#endif
  return result;
}

void NetworkServiceTestProxy::SetAllowNetworkAccessToHostResolutions(
    SetAllowNetworkAccessToHostResolutionsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::SetAllowNetworkAccessToHostResolutions");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetAllowNetworkAccessToHostResolutions");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::ReplaceSystemDnsConfig(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call network::mojom::NetworkServiceTest::ReplaceSystemDnsConfig (sync)");
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::ReplaceSystemDnsConfig");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_ReplaceSystemDnsConfig_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("ReplaceSystemDnsConfig");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::ReplaceSystemDnsConfig");
#endif
  return result;
}

void NetworkServiceTestProxy::ReplaceSystemDnsConfig(
    ReplaceSystemDnsConfigCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::ReplaceSystemDnsConfig");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_ReplaceSystemDnsConfig_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("ReplaceSystemDnsConfig");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::SetTestDohConfig(
    ::network::mojom::blink::SecureDnsMode param_secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr param_doh_config) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::SetTestDohConfig (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("secure_dns_mode"), param_secure_dns_mode,
                        "<value of type ::network::mojom::blink::SecureDnsMode>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("doh_config"), param_doh_config,
                        "<value of type ::network::mojom::blink::DnsOverHttpsConfigPtr>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::SetTestDohConfig");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetTestDohConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetTestDohConfig_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::SecureDnsMode>(
      param_secure_dns_mode, &params->secure_dns_mode);
  mojo::internal::MessageFragment<
      typename decltype(params->doh_config)::BaseType> doh_config_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::DnsOverHttpsConfigDataView>(
      param_doh_config, doh_config_fragment);
  params->doh_config.Set(
      doh_config_fragment.is_null() ? nullptr : doh_config_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->doh_config.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null doh_config in NetworkServiceTest.SetTestDohConfig request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetTestDohConfig");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetTestDohConfig_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::SetTestDohConfig");
#endif
  return result;
}

void NetworkServiceTestProxy::SetTestDohConfig(
    ::network::mojom::blink::SecureDnsMode in_secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr in_doh_config, SetTestDohConfigCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::SetTestDohConfig", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("secure_dns_mode"), in_secure_dns_mode,
                        "<value of type ::network::mojom::blink::SecureDnsMode>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("doh_config"), in_doh_config,
                        "<value of type ::network::mojom::blink::DnsOverHttpsConfigPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetTestDohConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetTestDohConfig_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::SecureDnsMode>(
      in_secure_dns_mode, &params->secure_dns_mode);
  mojo::internal::MessageFragment<
      typename decltype(params->doh_config)::BaseType> doh_config_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::DnsOverHttpsConfigDataView>(
      in_doh_config, doh_config_fragment);
  params->doh_config.Set(
      doh_config_fragment.is_null() ? nullptr : doh_config_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->doh_config.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null doh_config in NetworkServiceTest.SetTestDohConfig request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetTestDohConfig");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetTestDohConfig_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::CrashOnResolveHost(
    const WTF::String& in_host) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::CrashOnResolveHost", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_CrashOnResolveHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_CrashOnResolveHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->host)::BaseType> host_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_host, host_fragment);
  params->host.Set(
      host_fragment.is_null() ? nullptr : host_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host in NetworkServiceTest.CrashOnResolveHost request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("CrashOnResolveHost");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkServiceTestProxy::CrashOnGetCookieList(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::CrashOnGetCookieList");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_CrashOnGetCookieList_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_CrashOnGetCookieList_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("CrashOnGetCookieList");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool NetworkServiceTestProxy::GetLatestMemoryPressureLevel(
    ::mojo_base::mojom::blink::MemoryPressureLevel* out_param_memory_pressure_level) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call network::mojom::NetworkServiceTest::GetLatestMemoryPressureLevel (sync)");
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::GetLatestMemoryPressureLevel");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetLatestMemoryPressureLevel_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetLatestMemoryPressureLevel");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse(
          &result, out_param_memory_pressure_level));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "NetworkServiceTest::GetLatestMemoryPressureLevel", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("memory_pressure_level"), out_param_memory_pressure_level,
                        "<value of type ::mojo_base::mojom::blink::MemoryPressureLevel>");
   });
#endif
  return result;
}

void NetworkServiceTestProxy::GetLatestMemoryPressureLevel(
    GetLatestMemoryPressureLevelCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::GetLatestMemoryPressureLevel");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetLatestMemoryPressureLevel_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetLatestMemoryPressureLevel");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::GetPeerToPeerConnectionsCountChange(
    uint32_t* out_param_connection_count) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call network::mojom::NetworkServiceTest::GetPeerToPeerConnectionsCountChange (sync)");
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::GetPeerToPeerConnectionsCountChange");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetPeerToPeerConnectionsCountChange");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse(
          &result, out_param_connection_count));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "NetworkServiceTest::GetPeerToPeerConnectionsCountChange", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("connection_count"), out_param_connection_count,
                        "<value of type uint32_t>");
   });
#endif
  return result;
}

void NetworkServiceTestProxy::GetPeerToPeerConnectionsCountChange(
    GetPeerToPeerConnectionsCountChangeCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkServiceTest::GetPeerToPeerConnectionsCountChange");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetPeerToPeerConnectionsCountChange");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::GetEnvironmentVariableValue(
    const WTF::String& param_name, WTF::String* out_param_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::GetEnvironmentVariableValue (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), param_name,
                        "<value of type const WTF::String&>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::GetEnvironmentVariableValue");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetEnvironmentVariableValue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in NetworkServiceTest.GetEnvironmentVariableValue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetEnvironmentVariableValue");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse(
          &result, out_param_value));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "NetworkServiceTest::GetEnvironmentVariableValue", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), out_param_value,
                        "<value of type const WTF::String&>");
   });
#endif
  return result;
}

void NetworkServiceTestProxy::GetEnvironmentVariableValue(
    const WTF::String& in_name, GetEnvironmentVariableValueCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::GetEnvironmentVariableValue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetEnvironmentVariableValue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in NetworkServiceTest.GetEnvironmentVariableValue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetEnvironmentVariableValue");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkServiceTestProxy::Log(
    const WTF::String& param_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::Log (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), param_message,
                        "<value of type const WTF::String&>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::Log");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_Log_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_Log_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      param_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in NetworkServiceTest.Log request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("Log");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_Log_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::Log");
#endif
  return result;
}

void NetworkServiceTestProxy::Log(
    const WTF::String& in_message, LogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::Log", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_Log_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_Log_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in NetworkServiceTest.Log request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("Log");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_Log_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::ActivateFieldTrial(
    const WTF::String& in_field_trial_name) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::ActivateFieldTrial", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("field_trial_name"), in_field_trial_name,
                        "<value of type const WTF::String&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_ActivateFieldTrial_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_ActivateFieldTrial_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->field_trial_name)::BaseType> field_trial_name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_field_trial_name, field_trial_name_fragment);
  params->field_trial_name.Set(
      field_trial_name_fragment.is_null() ? nullptr : field_trial_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->field_trial_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null field_trial_name in NetworkServiceTest.ActivateFieldTrial request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("ActivateFieldTrial");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool NetworkServiceTestProxy::SetSCTAuditingRetryDelay(
    absl::optional<::base::TimeDelta> param_delay) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkServiceTest::SetSCTAuditingRetryDelay (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("delay"), param_delay,
                        "<value of type absl::optional<::base::TimeDelta>>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkServiceTest::SetSCTAuditingRetryDelay");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetSCTAuditingRetryDelay_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->delay)::BaseType> delay_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      param_delay, delay_fragment);
  params->delay.Set(
      delay_fragment.is_null() ? nullptr : delay_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetSCTAuditingRetryDelay");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkServiceTest::SetSCTAuditingRetryDelay");
#endif
  return result;
}

void NetworkServiceTestProxy::SetSCTAuditingRetryDelay(
    absl::optional<::base::TimeDelta> in_delay, SetSCTAuditingRetryDelayCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::SetSCTAuditingRetryDelay", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("delay"), in_delay,
                        "<value of type absl::optional<::base::TimeDelta>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetSCTAuditingRetryDelay_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->delay)::BaseType> delay_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_delay, delay_fragment);
  params->delay.Set(
      delay_fragment.is_null() ? nullptr : delay_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetSCTAuditingRetryDelay");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::OpenFile(
    const ::base::FilePath& in_path, OpenFileCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::OpenFile", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("path"), in_path,
                        "<value of type const ::base::FilePath&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_OpenFile_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_OpenFile_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->path)::BaseType> path_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(
      in_path, path_fragment);
  params->path.Set(
      path_fragment.is_null() ? nullptr : path_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->path.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null path in NetworkServiceTest.OpenFile request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("OpenFile");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_OpenFile_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::EnumerateFiles(
    const ::base::FilePath& in_path, ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> in_factory, EnumerateFilesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::EnumerateFiles", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("path"), in_path,
                        "<value of type const ::base::FilePath&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("factory"), in_factory,
                        "<value of type ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_EnumerateFiles_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_EnumerateFiles_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->path)::BaseType> path_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(
      in_path, path_fragment);
  params->path.Set(
      path_fragment.is_null() ? nullptr : path_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->path.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null path in NetworkServiceTest.EnumerateFiles request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::HttpCacheBackendFileOperationsFactoryInterfaceBase>>(
      in_factory, &params->factory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->factory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid factory in NetworkServiceTest.EnumerateFiles request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("EnumerateFiles");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_EnumerateFiles_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkServiceTestProxy::CreateSimpleCache(
    ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> in_factory, const ::base::FilePath& in_path, bool in_reset, CreateSimpleCacheCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkServiceTest::CreateSimpleCache", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("factory"), in_factory,
                        "<value of type ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("path"), in_path,
                        "<value of type const ::base::FilePath&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reset"), in_reset,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_CreateSimpleCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_CreateSimpleCache_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::HttpCacheBackendFileOperationsFactoryInterfaceBase>>(
      in_factory, &params->factory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->factory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid factory in NetworkServiceTest.CreateSimpleCache request");
  mojo::internal::MessageFragment<
      typename decltype(params->path)::BaseType> path_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::FilePathDataView>(
      in_path, path_fragment);
  params->path.Set(
      path_fragment.is_null() ? nullptr : path_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->path.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null path in NetworkServiceTest.CreateSimpleCache request");
  params->reset = in_reset;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("CreateSimpleCache");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkServiceTest_CreateSimpleCache_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class NetworkServiceTest_AddRules_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::AddRulesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_AddRules_ProxyToResponder> proxy(
        new NetworkServiceTest_AddRules_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_AddRules_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_AddRules_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_AddRules_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::AddRulesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_AddRules_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_AddRules_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_AddRules_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_AddRules_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_AddRules_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::AddRules");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_AddRules_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_AddRules_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("AddRules");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_AddRules_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_AddRules_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_AddRules_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_AddRules_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 0, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_SimulateNetworkChange_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SimulateNetworkChangeCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SimulateNetworkChange_ProxyToResponder> proxy(
        new NetworkServiceTest_SimulateNetworkChange_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SimulateNetworkChange_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SimulateNetworkChange_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SimulateNetworkChange_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SimulateNetworkChangeCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SimulateNetworkChange_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SimulateNetworkChange_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SimulateNetworkChange_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SimulateNetworkChange_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SimulateNetworkChange_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SimulateNetworkChange");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SimulateNetworkChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SimulateNetworkChange_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SimulateNetworkChange");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SimulateNetworkQualityChangeCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder> proxy(
        new NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SimulateNetworkQualityChangeCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SimulateNetworkQualityChange_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SimulateNetworkQualityChange_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SimulateNetworkQualityChange_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SimulateNetworkQualityChange_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SimulateNetworkQualityChange");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SimulateNetworkQualityChange_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SimulateNetworkQualityChange");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder> proxy(
        new NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2G");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("ForceNetworkQualityEstimatorReportWifiAsSlow2G");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::MockCertVerifierSetDefaultResultCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder> proxy(
        new NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::MockCertVerifierSetDefaultResultCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_MockCertVerifierSetDefaultResult_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::MockCertVerifierSetDefaultResult");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("MockCertVerifierSetDefaultResult");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_MockCertVerifierSetDefaultResult_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 5, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::MockCertVerifierAddResultForCertAndHostCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder> proxy(
        new NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::MockCertVerifierAddResultForCertAndHostCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::MockCertVerifierAddResultForCertAndHost");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("MockCertVerifierAddResultForCertAndHost");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 6, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_SetRequireCT_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SetRequireCTCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SetRequireCT_ProxyToResponder> proxy(
        new NetworkServiceTest_SetRequireCT_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SetRequireCT_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SetRequireCT_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SetRequireCT_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SetRequireCTCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SetRequireCT_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetRequireCT_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SetRequireCT_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetRequireCT_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SetRequireCT_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SetRequireCT");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetRequireCT_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetRequireCT_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetRequireCT");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_SetRequireCT_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetRequireCT_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_SetRequireCT_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetRequireCT_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 7, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SetTransportSecurityStateSourceCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder> proxy(
        new NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SetTransportSecurityStateSourceCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SetTransportSecurityStateSource_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetTransportSecurityStateSource_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SetTransportSecurityStateSource_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetTransportSecurityStateSource_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 8, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SetTransportSecurityStateSource");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetTransportSecurityStateSource_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetTransportSecurityStateSource");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_SetTransportSecurityStateSource_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetTransportSecurityStateSource_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_SetTransportSecurityStateSource_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetTransportSecurityStateSource_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 8, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SetAllowNetworkAccessToHostResolutionsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder> proxy(
        new NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SetAllowNetworkAccessToHostResolutionsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 9, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SetAllowNetworkAccessToHostResolutions");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetAllowNetworkAccessToHostResolutions");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 9, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::ReplaceSystemDnsConfigCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder> proxy(
        new NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::ReplaceSystemDnsConfigCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_ReplaceSystemDnsConfig_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 10, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::ReplaceSystemDnsConfig");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("ReplaceSystemDnsConfig");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_ReplaceSystemDnsConfig_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 10, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_SetTestDohConfig_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SetTestDohConfigCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SetTestDohConfig_ProxyToResponder> proxy(
        new NetworkServiceTest_SetTestDohConfig_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SetTestDohConfig_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SetTestDohConfig_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SetTestDohConfig_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SetTestDohConfigCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SetTestDohConfig_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetTestDohConfig_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SetTestDohConfig_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetTestDohConfig_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 11, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SetTestDohConfig_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SetTestDohConfig");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetTestDohConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetTestDohConfig_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetTestDohConfig");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_SetTestDohConfig_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetTestDohConfig_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_SetTestDohConfig_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetTestDohConfig_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 11, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::GetLatestMemoryPressureLevelCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder> proxy(
        new NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::GetLatestMemoryPressureLevelCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo_base::mojom::blink::MemoryPressureLevel in_memory_pressure_level);
};

bool NetworkServiceTest_GetLatestMemoryPressureLevel_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo_base::mojom::blink::MemoryPressureLevel p_memory_pressure_level{};
  NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadMemoryPressureLevel(&p_memory_pressure_level))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 14, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_memory_pressure_level));
  return true;
}

void NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder::Run(
    ::mojo_base::mojom::blink::MemoryPressureLevel in_memory_pressure_level) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkServiceTest::GetLatestMemoryPressureLevel", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("memory_pressure_level"), in_memory_pressure_level,
                        "<value of type ::mojo_base::mojom::blink::MemoryPressureLevel>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::mojo_base::mojom::MemoryPressureLevel>(
      in_memory_pressure_level, &params->memory_pressure_level);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetLatestMemoryPressureLevel");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_GetLatestMemoryPressureLevel_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  ::mojo_base::mojom::blink::MemoryPressureLevel p_memory_pressure_level{};
  NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadMemoryPressureLevel(&p_memory_pressure_level))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 14, true);
    return false;
  }
  *out_memory_pressure_level_ = std::move(p_memory_pressure_level);
  *result_ = true;
  return true;
}
class NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::GetPeerToPeerConnectionsCountChangeCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder> proxy(
        new NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::GetPeerToPeerConnectionsCountChangeCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      uint32_t in_connection_count);
};

bool NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  uint32_t p_connection_count{};
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_connection_count = input_data_view.connection_count();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 15, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_connection_count));
  return true;
}

void NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder::Run(
    uint32_t in_connection_count) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkServiceTest::GetPeerToPeerConnectionsCountChange", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("connection_count"), in_connection_count,
                        "<value of type uint32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->connection_count = in_connection_count;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetPeerToPeerConnectionsCountChange");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_GetPeerToPeerConnectionsCountChange_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  uint32_t p_connection_count{};
  NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_connection_count = input_data_view.connection_count();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 15, true);
    return false;
  }
  *out_connection_count_ = std::move(p_connection_count);
  *result_ = true;
  return true;
}
class NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::GetEnvironmentVariableValueCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder> proxy(
        new NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::GetEnvironmentVariableValueCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const WTF::String& in_value);
};

bool NetworkServiceTest_GetEnvironmentVariableValue_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_GetEnvironmentVariableValue_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_GetEnvironmentVariableValue_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  WTF::String p_value{};
  NetworkServiceTest_GetEnvironmentVariableValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadValue(&p_value))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 16, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_value));
  return true;
}

void NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder::Run(
    const WTF::String& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkServiceTest::GetEnvironmentVariableValue", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const WTF::String&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_GetEnvironmentVariableValue_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("GetEnvironmentVariableValue");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_GetEnvironmentVariableValue_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_GetEnvironmentVariableValue_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_GetEnvironmentVariableValue_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  WTF::String p_value{};
  NetworkServiceTest_GetEnvironmentVariableValue_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadValue(&p_value))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 16, true);
    return false;
  }
  *out_value_ = std::move(p_value);
  *result_ = true;
  return true;
}
class NetworkServiceTest_Log_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::LogCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_Log_ProxyToResponder> proxy(
        new NetworkServiceTest_Log_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_Log_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_Log_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_Log_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::LogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_Log_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_Log_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_Log_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_Log_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 17, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_Log_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::Log");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_Log_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_Log_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("Log");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_Log_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_Log_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_Log_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_Log_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 17, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::SetSCTAuditingRetryDelayCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder> proxy(
        new NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::SetSCTAuditingRetryDelayCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkServiceTest_SetSCTAuditingRetryDelay_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 19, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkServiceTest::SetSCTAuditingRetryDelay");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("SetSCTAuditingRetryDelay");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkServiceTest_SetSCTAuditingRetryDelay_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 19, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkServiceTest_OpenFile_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::OpenFileCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_OpenFile_ProxyToResponder> proxy(
        new NetworkServiceTest_OpenFile_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_OpenFile_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_OpenFile_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_OpenFile_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::OpenFileCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_result);
};

bool NetworkServiceTest_OpenFile_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_OpenFile_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_OpenFile_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_result{};
  NetworkServiceTest_OpenFile_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 20, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void NetworkServiceTest_OpenFile_ProxyToResponder::Run(
    bool in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkServiceTest::OpenFile", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_OpenFile_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_OpenFile_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("OpenFile");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkServiceTest_EnumerateFiles_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::EnumerateFilesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_EnumerateFiles_ProxyToResponder> proxy(
        new NetworkServiceTest_EnumerateFiles_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_EnumerateFiles_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_EnumerateFiles_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_EnumerateFiles_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::EnumerateFilesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr> in_entries, bool in_error);
};

bool NetworkServiceTest_EnumerateFiles_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_EnumerateFiles_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_EnumerateFiles_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr> p_entries{};
  bool p_error{};
  NetworkServiceTest_EnumerateFiles_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadEntries(&p_entries))
    success = false;
  if (success)
    p_error = input_data_view.error();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 21, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_entries), 
std::move(p_error));
  return true;
}

void NetworkServiceTest_EnumerateFiles_ProxyToResponder::Run(
    WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr> in_entries, bool in_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkServiceTest::EnumerateFiles", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("entries"), in_entries,
                        "<value of type WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error"), in_error,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_EnumerateFiles_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_EnumerateFiles_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->entries)::BaseType>
      entries_fragment(params.message());
  const mojo::internal::ContainerValidateParams entries_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::FileEnumerationEntryDataView>>(
      in_entries, entries_fragment, &entries_validate_params);
  params->entries.Set(
      entries_fragment.is_null() ? nullptr : entries_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->entries.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null entries in ");
  params->error = in_error;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("EnumerateFiles");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkServiceTest_CreateSimpleCache_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkServiceTest::CreateSimpleCacheCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkServiceTest_CreateSimpleCache_ProxyToResponder> proxy(
        new NetworkServiceTest_CreateSimpleCache_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkServiceTest_CreateSimpleCache_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkServiceTest_CreateSimpleCache_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkServiceTest_CreateSimpleCache_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkServiceTest::CreateSimpleCacheCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingRemote<SimpleCache> in_backend);
};

bool NetworkServiceTest_CreateSimpleCache_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkServiceTest_CreateSimpleCache_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkServiceTest_CreateSimpleCache_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::PendingRemote<SimpleCache> p_backend{};
  NetworkServiceTest_CreateSimpleCache_ResponseParamsDataView input_data_view(params, message);
  
  if (success) {
    p_backend =
        input_data_view.TakeBackend<decltype(p_backend)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkServiceTest::Name_, 22, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_backend));
  return true;
}

void NetworkServiceTest_CreateSimpleCache_ProxyToResponder::Run(
    ::mojo::PendingRemote<SimpleCache> in_backend) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkServiceTest::CreateSimpleCache", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("backend"), in_backend,
                        "<value of type ::mojo::PendingRemote<SimpleCache>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkServiceTest_CreateSimpleCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkServiceTest_CreateSimpleCache_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::SimpleCacheInterfaceBase>>(
      in_backend, &params->backend, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkServiceTest::Name_);
  message.set_method_name("CreateSimpleCache");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool NetworkServiceTestStubDispatch::Accept(
    NetworkServiceTest* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kNetworkServiceTest_AddRules_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SimulateNetworkChange_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name: {
      break;
    }
    case internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SimulateCrash_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkServiceTest_SimulateCrash_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceTest_SimulateCrash_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_SimulateCrash_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SimulateCrash();
      return true;
    }
    case internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name: {
      break;
    }
    case internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SetRequireCT_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name: {
      break;
    }
    case internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SetTestDohConfig_Name: {
      break;
    }
    case internal::kNetworkServiceTest_CrashOnResolveHost_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkServiceTest_CrashOnResolveHost_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceTest_CrashOnResolveHost_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::String p_host{};
      NetworkServiceTest_CrashOnResolveHost_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHost(&p_host))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CrashOnResolveHost(
std::move(p_host));
      return true;
    }
    case internal::kNetworkServiceTest_CrashOnGetCookieList_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkServiceTest_CrashOnGetCookieList_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceTest_CrashOnGetCookieList_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_CrashOnGetCookieList_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CrashOnGetCookieList();
      return true;
    }
    case internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name: {
      break;
    }
    case internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name: {
      break;
    }
    case internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name: {
      break;
    }
    case internal::kNetworkServiceTest_Log_Name: {
      break;
    }
    case internal::kNetworkServiceTest_ActivateFieldTrial_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkServiceTest_ActivateFieldTrial_Params_Data* params =
          reinterpret_cast<internal::NetworkServiceTest_ActivateFieldTrial_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      WTF::String p_field_trial_name{};
      NetworkServiceTest_ActivateFieldTrial_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFieldTrialName(&p_field_trial_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ActivateFieldTrial(
std::move(p_field_trial_name));
      return true;
    }
    case internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name: {
      break;
    }
    case internal::kNetworkServiceTest_OpenFile_Name: {
      break;
    }
    case internal::kNetworkServiceTest_EnumerateFiles_Name: {
      break;
    }
    case internal::kNetworkServiceTest_CreateSimpleCache_Name: {
      break;
    }
  }
  return false;
}

// static
bool NetworkServiceTestStubDispatch::AcceptWithResponder(
    NetworkServiceTest* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kNetworkServiceTest_AddRules_Name: {

      internal::NetworkServiceTest_AddRules_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_AddRules_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::Vector<RulePtr> p_rules{};
      NetworkServiceTest_AddRules_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRules(&p_rules))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 0, false);
        return false;
      }
      NetworkServiceTest::AddRulesCallback callback =
          NetworkServiceTest_AddRules_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddRules(
std::move(p_rules), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SimulateNetworkChange_Name: {

      internal::NetworkServiceTest_SimulateNetworkChange_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SimulateNetworkChange_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::network::mojom::blink::ConnectionType p_type{};
      NetworkServiceTest_SimulateNetworkChange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 1, false);
        return false;
      }
      NetworkServiceTest::SimulateNetworkChangeCallback callback =
          NetworkServiceTest_SimulateNetworkChange_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SimulateNetworkChange(
std::move(p_type), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SimulateNetworkQualityChange_Name: {

      internal::NetworkServiceTest_SimulateNetworkQualityChange_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SimulateNetworkQualityChange_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::network::mojom::blink::EffectiveConnectionType p_type{};
      NetworkServiceTest_SimulateNetworkQualityChange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 2, false);
        return false;
      }
      NetworkServiceTest::SimulateNetworkQualityChangeCallback callback =
          NetworkServiceTest_SimulateNetworkQualityChange_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SimulateNetworkQualityChange(
std::move(p_type), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Name: {

      internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 3, false);
        return false;
      }
      NetworkServiceTest::ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback callback =
          NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForceNetworkQualityEstimatorReportWifiAsSlow2G(std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SimulateCrash_Name: {
      break;
    }
    case internal::kNetworkServiceTest_MockCertVerifierSetDefaultResult_Name: {

      internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_default_result{};
      NetworkServiceTest_MockCertVerifierSetDefaultResult_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_default_result = input_data_view.default_result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 5, false);
        return false;
      }
      NetworkServiceTest::MockCertVerifierSetDefaultResultCallback callback =
          NetworkServiceTest_MockCertVerifierSetDefaultResult_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MockCertVerifierSetDefaultResult(
std::move(p_default_result), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Name: {

      internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::network::mojom::blink::X509CertificatePtr p_cert{};
      WTF::String p_host_pattern{};
      ::network::mojom::blink::CertVerifyResultPtr p_verify_result{};
      int32_t p_rv{};
      NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCert(&p_cert))
        success = false;
      if (success && !input_data_view.ReadHostPattern(&p_host_pattern))
        success = false;
      if (success && !input_data_view.ReadVerifyResult(&p_verify_result))
        success = false;
      if (success)
        p_rv = input_data_view.rv();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 6, false);
        return false;
      }
      NetworkServiceTest::MockCertVerifierAddResultForCertAndHostCallback callback =
          NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MockCertVerifierAddResultForCertAndHost(
std::move(p_cert), 
std::move(p_host_pattern), 
std::move(p_verify_result), 
std::move(p_rv), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SetRequireCT_Name: {

      internal::NetworkServiceTest_SetRequireCT_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SetRequireCT_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest::RequireCT p_required{};
      NetworkServiceTest_SetRequireCT_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequired(&p_required))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 7, false);
        return false;
      }
      NetworkServiceTest::SetRequireCTCallback callback =
          NetworkServiceTest_SetRequireCT_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetRequireCT(
std::move(p_required), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SetTransportSecurityStateSource_Name: {

      internal::NetworkServiceTest_SetTransportSecurityStateSource_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SetTransportSecurityStateSource_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      uint16_t p_reporting_port{};
      NetworkServiceTest_SetTransportSecurityStateSource_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_reporting_port = input_data_view.reporting_port();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 8, false);
        return false;
      }
      NetworkServiceTest::SetTransportSecurityStateSourceCallback callback =
          NetworkServiceTest_SetTransportSecurityStateSource_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTransportSecurityStateSource(
std::move(p_reporting_port), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Name: {

      internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 9, false);
        return false;
      }
      NetworkServiceTest::SetAllowNetworkAccessToHostResolutionsCallback callback =
          NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetAllowNetworkAccessToHostResolutions(std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_ReplaceSystemDnsConfig_Name: {

      internal::NetworkServiceTest_ReplaceSystemDnsConfig_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_ReplaceSystemDnsConfig_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_ReplaceSystemDnsConfig_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 10, false);
        return false;
      }
      NetworkServiceTest::ReplaceSystemDnsConfigCallback callback =
          NetworkServiceTest_ReplaceSystemDnsConfig_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReplaceSystemDnsConfig(std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_SetTestDohConfig_Name: {

      internal::NetworkServiceTest_SetTestDohConfig_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SetTestDohConfig_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::network::mojom::blink::SecureDnsMode p_secure_dns_mode{};
      ::network::mojom::blink::DnsOverHttpsConfigPtr p_doh_config{};
      NetworkServiceTest_SetTestDohConfig_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSecureDnsMode(&p_secure_dns_mode))
        success = false;
      if (success && !input_data_view.ReadDohConfig(&p_doh_config))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 11, false);
        return false;
      }
      NetworkServiceTest::SetTestDohConfigCallback callback =
          NetworkServiceTest_SetTestDohConfig_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetTestDohConfig(
std::move(p_secure_dns_mode), 
std::move(p_doh_config), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_CrashOnResolveHost_Name: {
      break;
    }
    case internal::kNetworkServiceTest_CrashOnGetCookieList_Name: {
      break;
    }
    case internal::kNetworkServiceTest_GetLatestMemoryPressureLevel_Name: {

      internal::NetworkServiceTest_GetLatestMemoryPressureLevel_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_GetLatestMemoryPressureLevel_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_GetLatestMemoryPressureLevel_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 14, false);
        return false;
      }
      NetworkServiceTest::GetLatestMemoryPressureLevelCallback callback =
          NetworkServiceTest_GetLatestMemoryPressureLevel_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetLatestMemoryPressureLevel(std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_GetPeerToPeerConnectionsCountChange_Name: {

      internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 15, false);
        return false;
      }
      NetworkServiceTest::GetPeerToPeerConnectionsCountChangeCallback callback =
          NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetPeerToPeerConnectionsCountChange(std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_GetEnvironmentVariableValue_Name: {

      internal::NetworkServiceTest_GetEnvironmentVariableValue_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_GetEnvironmentVariableValue_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_name{};
      NetworkServiceTest_GetEnvironmentVariableValue_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 16, false);
        return false;
      }
      NetworkServiceTest::GetEnvironmentVariableValueCallback callback =
          NetworkServiceTest_GetEnvironmentVariableValue_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetEnvironmentVariableValue(
std::move(p_name), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_Log_Name: {

      internal::NetworkServiceTest_Log_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_Log_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      WTF::String p_message{};
      NetworkServiceTest_Log_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 17, false);
        return false;
      }
      NetworkServiceTest::LogCallback callback =
          NetworkServiceTest_Log_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Log(
std::move(p_message), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_ActivateFieldTrial_Name: {
      break;
    }
    case internal::kNetworkServiceTest_SetSCTAuditingRetryDelay_Name: {

      internal::NetworkServiceTest_SetSCTAuditingRetryDelay_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_SetSCTAuditingRetryDelay_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      absl::optional<::base::TimeDelta> p_delay{};
      NetworkServiceTest_SetSCTAuditingRetryDelay_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDelay(&p_delay))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 19, false);
        return false;
      }
      NetworkServiceTest::SetSCTAuditingRetryDelayCallback callback =
          NetworkServiceTest_SetSCTAuditingRetryDelay_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSCTAuditingRetryDelay(
std::move(p_delay), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_OpenFile_Name: {

      internal::NetworkServiceTest_OpenFile_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_OpenFile_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::FilePath p_path{};
      NetworkServiceTest_OpenFile_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPath(&p_path))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 20, false);
        return false;
      }
      NetworkServiceTest::OpenFileCallback callback =
          NetworkServiceTest_OpenFile_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenFile(
std::move(p_path), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_EnumerateFiles_Name: {

      internal::NetworkServiceTest_EnumerateFiles_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_EnumerateFiles_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::FilePath p_path{};
      ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> p_factory{};
      NetworkServiceTest_EnumerateFiles_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPath(&p_path))
        success = false;
      if (success) {
        p_factory =
            input_data_view.TakeFactory<decltype(p_factory)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 21, false);
        return false;
      }
      NetworkServiceTest::EnumerateFilesCallback callback =
          NetworkServiceTest_EnumerateFiles_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnumerateFiles(
std::move(p_path), 
std::move(p_factory), std::move(callback));
      return true;
    }
    case internal::kNetworkServiceTest_CreateSimpleCache_Name: {

      internal::NetworkServiceTest_CreateSimpleCache_Params_Data* params =
          reinterpret_cast<
              internal::NetworkServiceTest_CreateSimpleCache_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> p_factory{};
      ::base::FilePath p_path{};
      bool p_reset{};
      NetworkServiceTest_CreateSimpleCache_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_factory =
            input_data_view.TakeFactory<decltype(p_factory)>();
      }
      if (success && !input_data_view.ReadPath(&p_path))
        success = false;
      if (success)
        p_reset = input_data_view.reset();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkServiceTest::Name_, 22, false);
        return false;
      }
      NetworkServiceTest::CreateSimpleCacheCallback callback =
          NetworkServiceTest_CreateSimpleCache_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateSimpleCache(
std::move(p_factory), 
std::move(p_path), 
std::move(p_reset), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kNetworkServiceTestValidationInfo[] = {
    {&internal::NetworkServiceTest_AddRules_Params_Data::Validate,
     &internal::NetworkServiceTest_AddRules_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SimulateNetworkChange_Params_Data::Validate,
     &internal::NetworkServiceTest_SimulateNetworkChange_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SimulateNetworkQualityChange_Params_Data::Validate,
     &internal::NetworkServiceTest_SimulateNetworkQualityChange_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_Params_Data::Validate,
     &internal::NetworkServiceTest_ForceNetworkQualityEstimatorReportWifiAsSlow2G_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SimulateCrash_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_Params_Data::Validate,
     &internal::NetworkServiceTest_MockCertVerifierSetDefaultResult_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_Params_Data::Validate,
     &internal::NetworkServiceTest_MockCertVerifierAddResultForCertAndHost_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SetRequireCT_Params_Data::Validate,
     &internal::NetworkServiceTest_SetRequireCT_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SetTransportSecurityStateSource_Params_Data::Validate,
     &internal::NetworkServiceTest_SetTransportSecurityStateSource_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_Params_Data::Validate,
     &internal::NetworkServiceTest_SetAllowNetworkAccessToHostResolutions_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_ReplaceSystemDnsConfig_Params_Data::Validate,
     &internal::NetworkServiceTest_ReplaceSystemDnsConfig_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_SetTestDohConfig_Params_Data::Validate,
     &internal::NetworkServiceTest_SetTestDohConfig_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_CrashOnResolveHost_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkServiceTest_CrashOnGetCookieList_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkServiceTest_GetLatestMemoryPressureLevel_Params_Data::Validate,
     &internal::NetworkServiceTest_GetLatestMemoryPressureLevel_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_Params_Data::Validate,
     &internal::NetworkServiceTest_GetPeerToPeerConnectionsCountChange_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_GetEnvironmentVariableValue_Params_Data::Validate,
     &internal::NetworkServiceTest_GetEnvironmentVariableValue_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_Log_Params_Data::Validate,
     &internal::NetworkServiceTest_Log_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_ActivateFieldTrial_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkServiceTest_SetSCTAuditingRetryDelay_Params_Data::Validate,
     &internal::NetworkServiceTest_SetSCTAuditingRetryDelay_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_OpenFile_Params_Data::Validate,
     &internal::NetworkServiceTest_OpenFile_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_EnumerateFiles_Params_Data::Validate,
     &internal::NetworkServiceTest_EnumerateFiles_ResponseParams_Data::Validate},
    {&internal::NetworkServiceTest_CreateSimpleCache_Params_Data::Validate,
     &internal::NetworkServiceTest_CreateSimpleCache_ResponseParams_Data::Validate},
};

bool NetworkServiceTestRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::NetworkServiceTest::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kNetworkServiceTestValidationInfo);
}

bool NetworkServiceTestResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::blink::NetworkServiceTest::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kNetworkServiceTestValidationInfo);
}


}  // namespace blink
}  // namespace mojom
}  // namespace network


namespace mojo {


// static
bool StructTraits<::network::mojom::blink::Rule::DataView, ::network::mojom::blink::RulePtr>::Read(
    ::network::mojom::blink::Rule::DataView input,
    ::network::mojom::blink::RulePtr* output) {
  bool success = true;
  ::network::mojom::blink::RulePtr result(::network::mojom::blink::Rule::New());
  
      if (success && !input.ReadResolverType(&result->resolver_type))
        success = false;
      if (success && !input.ReadHostPattern(&result->host_pattern))
        success = false;
      if (success && !input.ReadReplacement(&result->replacement))
        success = false;
      if (success)
        result->host_resolver_flags = input.host_resolver_flags();
      if (success && !input.ReadDnsAliases(&result->dns_aliases))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::blink::SimpleCacheOpenEntryResult::DataView, ::network::mojom::blink::SimpleCacheOpenEntryResultPtr>::Read(
    ::network::mojom::blink::SimpleCacheOpenEntryResult::DataView input,
    ::network::mojom::blink::SimpleCacheOpenEntryResultPtr* output) {
  bool success = true;
  ::network::mojom::blink::SimpleCacheOpenEntryResultPtr result(::network::mojom::blink::SimpleCacheOpenEntryResult::New());
  
      if (success)
        result->error = input.error();
      if (success && !input.ReadKey(&result->key))
        success = false;
      if (success) {
        result->entry =
            input.TakeEntry<decltype(result->entry)>();
      }
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace network {
namespace mojom {
namespace blink {


void SimpleCacheEntryInterceptorForTesting::WriteData(int32_t index, int32_t offset, const WTF::Vector<uint8_t>& data, bool truncate, WriteDataCallback callback) {
  GetForwardingInterface()->WriteData(std::move(index), std::move(offset), std::move(data), std::move(truncate), std::move(callback));
}
void SimpleCacheEntryInterceptorForTesting::ReadData(int32_t index, int32_t offset, uint32_t length, ReadDataCallback callback) {
  GetForwardingInterface()->ReadData(std::move(index), std::move(offset), std::move(length), std::move(callback));
}
void SimpleCacheEntryInterceptorForTesting::WriteSparseData(int32_t offset, const WTF::Vector<uint8_t>& data, WriteSparseDataCallback callback) {
  GetForwardingInterface()->WriteSparseData(std::move(offset), std::move(data), std::move(callback));
}
void SimpleCacheEntryInterceptorForTesting::ReadSparseData(int32_t offset, uint32_t length, ReadSparseDataCallback callback) {
  GetForwardingInterface()->ReadSparseData(std::move(offset), std::move(length), std::move(callback));
}
void SimpleCacheEntryInterceptorForTesting::Close(CloseCallback callback) {
  GetForwardingInterface()->Close(std::move(callback));
}
SimpleCacheEntryAsyncWaiter::SimpleCacheEntryAsyncWaiter(
    SimpleCacheEntry* proxy) : proxy_(proxy) {}

SimpleCacheEntryAsyncWaiter::~SimpleCacheEntryAsyncWaiter() = default;

void SimpleCacheEntryAsyncWaiter::WriteData(
    int32_t index, int32_t offset, const WTF::Vector<uint8_t>& data, bool truncate, int32_t* out_result) {
  base::RunLoop loop;
  proxy_->WriteData(std::move(index),std::move(offset),std::move(data),std::move(truncate),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             int32_t result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void SimpleCacheEntryAsyncWaiter::ReadData(
    int32_t index, int32_t offset, uint32_t length, WTF::Vector<uint8_t>* out_data, int32_t* out_result) {
  base::RunLoop loop;
  proxy_->ReadData(std::move(index),std::move(offset),std::move(length),
      base::BindOnce(
          [](base::RunLoop* loop,
             WTF::Vector<uint8_t>* out_data
,
             int32_t* out_result
,
             const WTF::Vector<uint8_t>& data,
             int32_t result) {*out_data = std::move(data);*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_data,
          out_result));
  loop.Run();
}
void SimpleCacheEntryAsyncWaiter::WriteSparseData(
    int32_t offset, const WTF::Vector<uint8_t>& data, int32_t* out_result) {
  base::RunLoop loop;
  proxy_->WriteSparseData(std::move(offset),std::move(data),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             int32_t result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void SimpleCacheEntryAsyncWaiter::ReadSparseData(
    int32_t offset, uint32_t length, WTF::Vector<uint8_t>* out_data, int32_t* out_result) {
  base::RunLoop loop;
  proxy_->ReadSparseData(std::move(offset),std::move(length),
      base::BindOnce(
          [](base::RunLoop* loop,
             WTF::Vector<uint8_t>* out_data
,
             int32_t* out_result
,
             const WTF::Vector<uint8_t>& data,
             int32_t result) {*out_data = std::move(data);*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_data,
          out_result));
  loop.Run();
}
void SimpleCacheEntryAsyncWaiter::Close(
    ) {
  base::RunLoop loop;
  proxy_->Close(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}



void SimpleCacheEntryEnumeratorInterceptorForTesting::GetNext(GetNextCallback callback) {
  GetForwardingInterface()->GetNext(std::move(callback));
}
SimpleCacheEntryEnumeratorAsyncWaiter::SimpleCacheEntryEnumeratorAsyncWaiter(
    SimpleCacheEntryEnumerator* proxy) : proxy_(proxy) {}

SimpleCacheEntryEnumeratorAsyncWaiter::~SimpleCacheEntryEnumeratorAsyncWaiter() = default;

void SimpleCacheEntryEnumeratorAsyncWaiter::GetNext(
    SimpleCacheOpenEntryResultPtr* out_result) {
  base::RunLoop loop;
  proxy_->GetNext(
      base::BindOnce(
          [](base::RunLoop* loop,
             SimpleCacheOpenEntryResultPtr* out_result
,
             SimpleCacheOpenEntryResultPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void SimpleCacheInterceptorForTesting::CreateEntry(const WTF::String& key, CreateEntryCallback callback) {
  GetForwardingInterface()->CreateEntry(std::move(key), std::move(callback));
}
void SimpleCacheInterceptorForTesting::OpenEntry(const WTF::String& key, OpenEntryCallback callback) {
  GetForwardingInterface()->OpenEntry(std::move(key), std::move(callback));
}
void SimpleCacheInterceptorForTesting::DoomEntry(const WTF::String& key, DoomEntryCallback callback) {
  GetForwardingInterface()->DoomEntry(std::move(key), std::move(callback));
}
void SimpleCacheInterceptorForTesting::DoomAllEntries(DoomAllEntriesCallback callback) {
  GetForwardingInterface()->DoomAllEntries(std::move(callback));
}
void SimpleCacheInterceptorForTesting::EnumerateEntries(::mojo::PendingReceiver<SimpleCacheEntryEnumerator> receiver) {
  GetForwardingInterface()->EnumerateEntries(std::move(receiver));
}
void SimpleCacheInterceptorForTesting::Detach(DetachCallback callback) {
  GetForwardingInterface()->Detach(std::move(callback));
}
SimpleCacheAsyncWaiter::SimpleCacheAsyncWaiter(
    SimpleCache* proxy) : proxy_(proxy) {}

SimpleCacheAsyncWaiter::~SimpleCacheAsyncWaiter() = default;

void SimpleCacheAsyncWaiter::CreateEntry(
    const WTF::String& key, ::mojo::PendingRemote<SimpleCacheEntry>* out_entry, int32_t* out_error) {
  base::RunLoop loop;
  proxy_->CreateEntry(std::move(key),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingRemote<SimpleCacheEntry>* out_entry
,
             int32_t* out_error
,
             ::mojo::PendingRemote<SimpleCacheEntry> entry,
             int32_t error) {*out_entry = std::move(entry);*out_error = std::move(error);
            loop->Quit();
          },
          &loop,
          out_entry,
          out_error));
  loop.Run();
}
void SimpleCacheAsyncWaiter::OpenEntry(
    const WTF::String& key, ::mojo::PendingRemote<SimpleCacheEntry>* out_entry, int32_t* out_error) {
  base::RunLoop loop;
  proxy_->OpenEntry(std::move(key),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingRemote<SimpleCacheEntry>* out_entry
,
             int32_t* out_error
,
             ::mojo::PendingRemote<SimpleCacheEntry> entry,
             int32_t error) {*out_entry = std::move(entry);*out_error = std::move(error);
            loop->Quit();
          },
          &loop,
          out_entry,
          out_error));
  loop.Run();
}
void SimpleCacheAsyncWaiter::DoomEntry(
    const WTF::String& key, int32_t* out_result) {
  base::RunLoop loop;
  proxy_->DoomEntry(std::move(key),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             int32_t result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void SimpleCacheAsyncWaiter::DoomAllEntries(
    int32_t* out_result) {
  base::RunLoop loop;
  proxy_->DoomAllEntries(
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             int32_t result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void SimpleCacheAsyncWaiter::Detach(
    ) {
  base::RunLoop loop;
  proxy_->Detach(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}



void NetworkServiceTestInterceptorForTesting::AddRules(WTF::Vector<RulePtr> rules, AddRulesCallback callback) {
  GetForwardingInterface()->AddRules(std::move(rules), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SimulateNetworkChange(::network::mojom::blink::ConnectionType type, SimulateNetworkChangeCallback callback) {
  GetForwardingInterface()->SimulateNetworkChange(std::move(type), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SimulateNetworkQualityChange(::network::mojom::blink::EffectiveConnectionType type, SimulateNetworkQualityChangeCallback callback) {
  GetForwardingInterface()->SimulateNetworkQualityChange(std::move(type), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::ForceNetworkQualityEstimatorReportWifiAsSlow2G(ForceNetworkQualityEstimatorReportWifiAsSlow2GCallback callback) {
  GetForwardingInterface()->ForceNetworkQualityEstimatorReportWifiAsSlow2G(std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SimulateCrash() {
  GetForwardingInterface()->SimulateCrash();
}
void NetworkServiceTestInterceptorForTesting::MockCertVerifierSetDefaultResult(int32_t default_result, MockCertVerifierSetDefaultResultCallback callback) {
  GetForwardingInterface()->MockCertVerifierSetDefaultResult(std::move(default_result), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::MockCertVerifierAddResultForCertAndHost(::network::mojom::blink::X509CertificatePtr cert, const WTF::String& host_pattern, ::network::mojom::blink::CertVerifyResultPtr verify_result, int32_t rv, MockCertVerifierAddResultForCertAndHostCallback callback) {
  GetForwardingInterface()->MockCertVerifierAddResultForCertAndHost(std::move(cert), std::move(host_pattern), std::move(verify_result), std::move(rv), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SetRequireCT(NetworkServiceTest::RequireCT required, SetRequireCTCallback callback) {
  GetForwardingInterface()->SetRequireCT(std::move(required), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SetTransportSecurityStateSource(uint16_t reporting_port, SetTransportSecurityStateSourceCallback callback) {
  GetForwardingInterface()->SetTransportSecurityStateSource(std::move(reporting_port), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SetAllowNetworkAccessToHostResolutions(SetAllowNetworkAccessToHostResolutionsCallback callback) {
  GetForwardingInterface()->SetAllowNetworkAccessToHostResolutions(std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::ReplaceSystemDnsConfig(ReplaceSystemDnsConfigCallback callback) {
  GetForwardingInterface()->ReplaceSystemDnsConfig(std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::SetTestDohConfig(::network::mojom::blink::SecureDnsMode secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr doh_config, SetTestDohConfigCallback callback) {
  GetForwardingInterface()->SetTestDohConfig(std::move(secure_dns_mode), std::move(doh_config), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::CrashOnResolveHost(const WTF::String& host) {
  GetForwardingInterface()->CrashOnResolveHost(std::move(host));
}
void NetworkServiceTestInterceptorForTesting::CrashOnGetCookieList() {
  GetForwardingInterface()->CrashOnGetCookieList();
}
void NetworkServiceTestInterceptorForTesting::GetLatestMemoryPressureLevel(GetLatestMemoryPressureLevelCallback callback) {
  GetForwardingInterface()->GetLatestMemoryPressureLevel(std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::GetPeerToPeerConnectionsCountChange(GetPeerToPeerConnectionsCountChangeCallback callback) {
  GetForwardingInterface()->GetPeerToPeerConnectionsCountChange(std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::GetEnvironmentVariableValue(const WTF::String& name, GetEnvironmentVariableValueCallback callback) {
  GetForwardingInterface()->GetEnvironmentVariableValue(std::move(name), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::Log(const WTF::String& message, LogCallback callback) {
  GetForwardingInterface()->Log(std::move(message), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::ActivateFieldTrial(const WTF::String& field_trial_name) {
  GetForwardingInterface()->ActivateFieldTrial(std::move(field_trial_name));
}
void NetworkServiceTestInterceptorForTesting::SetSCTAuditingRetryDelay(absl::optional<::base::TimeDelta> delay, SetSCTAuditingRetryDelayCallback callback) {
  GetForwardingInterface()->SetSCTAuditingRetryDelay(std::move(delay), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::OpenFile(const ::base::FilePath& path, OpenFileCallback callback) {
  GetForwardingInterface()->OpenFile(std::move(path), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::EnumerateFiles(const ::base::FilePath& path, ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> factory, EnumerateFilesCallback callback) {
  GetForwardingInterface()->EnumerateFiles(std::move(path), std::move(factory), std::move(callback));
}
void NetworkServiceTestInterceptorForTesting::CreateSimpleCache(::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> factory, const ::base::FilePath& path, bool reset, CreateSimpleCacheCallback callback) {
  GetForwardingInterface()->CreateSimpleCache(std::move(factory), std::move(path), std::move(reset), std::move(callback));
}
NetworkServiceTestAsyncWaiter::NetworkServiceTestAsyncWaiter(
    NetworkServiceTest* proxy) : proxy_(proxy) {}

NetworkServiceTestAsyncWaiter::~NetworkServiceTestAsyncWaiter() = default;

void NetworkServiceTestAsyncWaiter::AddRules(
    WTF::Vector<RulePtr> rules) {
  base::RunLoop loop;
  proxy_->AddRules(std::move(rules),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SimulateNetworkChange(
    ::network::mojom::blink::ConnectionType type) {
  base::RunLoop loop;
  proxy_->SimulateNetworkChange(std::move(type),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SimulateNetworkQualityChange(
    ::network::mojom::blink::EffectiveConnectionType type) {
  base::RunLoop loop;
  proxy_->SimulateNetworkQualityChange(std::move(type),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::ForceNetworkQualityEstimatorReportWifiAsSlow2G(
    ) {
  base::RunLoop loop;
  proxy_->ForceNetworkQualityEstimatorReportWifiAsSlow2G(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::MockCertVerifierSetDefaultResult(
    int32_t default_result) {
  base::RunLoop loop;
  proxy_->MockCertVerifierSetDefaultResult(std::move(default_result),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::MockCertVerifierAddResultForCertAndHost(
    ::network::mojom::blink::X509CertificatePtr cert, const WTF::String& host_pattern, ::network::mojom::blink::CertVerifyResultPtr verify_result, int32_t rv) {
  base::RunLoop loop;
  proxy_->MockCertVerifierAddResultForCertAndHost(std::move(cert),std::move(host_pattern),std::move(verify_result),std::move(rv),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SetRequireCT(
    NetworkServiceTest::RequireCT required) {
  base::RunLoop loop;
  proxy_->SetRequireCT(std::move(required),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SetTransportSecurityStateSource(
    uint16_t reporting_port) {
  base::RunLoop loop;
  proxy_->SetTransportSecurityStateSource(std::move(reporting_port),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SetAllowNetworkAccessToHostResolutions(
    ) {
  base::RunLoop loop;
  proxy_->SetAllowNetworkAccessToHostResolutions(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::ReplaceSystemDnsConfig(
    ) {
  base::RunLoop loop;
  proxy_->ReplaceSystemDnsConfig(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SetTestDohConfig(
    ::network::mojom::blink::SecureDnsMode secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr doh_config) {
  base::RunLoop loop;
  proxy_->SetTestDohConfig(std::move(secure_dns_mode),std::move(doh_config),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::GetLatestMemoryPressureLevel(
    ::mojo_base::mojom::blink::MemoryPressureLevel* out_memory_pressure_level) {
  base::RunLoop loop;
  proxy_->GetLatestMemoryPressureLevel(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo_base::mojom::blink::MemoryPressureLevel* out_memory_pressure_level
,
             ::mojo_base::mojom::blink::MemoryPressureLevel memory_pressure_level) {*out_memory_pressure_level = std::move(memory_pressure_level);
            loop->Quit();
          },
          &loop,
          out_memory_pressure_level));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::GetPeerToPeerConnectionsCountChange(
    uint32_t* out_connection_count) {
  base::RunLoop loop;
  proxy_->GetPeerToPeerConnectionsCountChange(
      base::BindOnce(
          [](base::RunLoop* loop,
             uint32_t* out_connection_count
,
             uint32_t connection_count) {*out_connection_count = std::move(connection_count);
            loop->Quit();
          },
          &loop,
          out_connection_count));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::GetEnvironmentVariableValue(
    const WTF::String& name, WTF::String* out_value) {
  base::RunLoop loop;
  proxy_->GetEnvironmentVariableValue(std::move(name),
      base::BindOnce(
          [](base::RunLoop* loop,
             WTF::String* out_value
,
             const WTF::String& value) {*out_value = std::move(value);
            loop->Quit();
          },
          &loop,
          out_value));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::Log(
    const WTF::String& message) {
  base::RunLoop loop;
  proxy_->Log(std::move(message),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::SetSCTAuditingRetryDelay(
    absl::optional<::base::TimeDelta> delay) {
  base::RunLoop loop;
  proxy_->SetSCTAuditingRetryDelay(std::move(delay),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::OpenFile(
    const ::base::FilePath& path, bool* out_result) {
  base::RunLoop loop;
  proxy_->OpenFile(std::move(path),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_result
,
             bool result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::EnumerateFiles(
    const ::base::FilePath& path, ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> factory, WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr>* out_entries, bool* out_error) {
  base::RunLoop loop;
  proxy_->EnumerateFiles(std::move(path),std::move(factory),
      base::BindOnce(
          [](base::RunLoop* loop,
             WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr>* out_entries
,
             bool* out_error
,
             WTF::Vector<::network::mojom::blink::FileEnumerationEntryPtr> entries,
             bool error) {*out_entries = std::move(entries);*out_error = std::move(error);
            loop->Quit();
          },
          &loop,
          out_entries,
          out_error));
  loop.Run();
}
void NetworkServiceTestAsyncWaiter::CreateSimpleCache(
    ::mojo::PendingRemote<::network::mojom::blink::HttpCacheBackendFileOperationsFactory> factory, const ::base::FilePath& path, bool reset, ::mojo::PendingRemote<SimpleCache>* out_backend) {
  base::RunLoop loop;
  proxy_->CreateSimpleCache(std::move(factory),std::move(path),std::move(reset),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingRemote<SimpleCache>* out_backend
,
             ::mojo::PendingRemote<SimpleCache> backend) {*out_backend = std::move(backend);
            loop->Quit();
          },
          &loop,
          out_backend));
  loop.Run();
}





}  // namespace blink
}  // namespace mojom
}  // namespace network


#if defined(__clang__)
#pragma clang diagnostic pop
#endif