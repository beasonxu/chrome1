// services/network/public/mojom/network_context.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "services/network/public/mojom/network_context.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "services/network/public/mojom/network_context.mojom-params-data.h"
#include "services/network/public/mojom/network_context.mojom-shared-message-ids.h"

#include "services/network/public/mojom/network_context.mojom-import-headers.h"
#include "services/network/public/mojom/network_context.mojom-test-utils.h"


#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_JUMBO_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_CONTEXT_MOJOM_JUMBO_H_
#include "components/content_settings/core/common/content_settings_param_traits.h"
#include "services/network/public/mojom/cookie_access_observer.mojom.h"
#include "services/network/public/mojom/devtools_observer.mojom.h"
#endif



namespace network {
namespace mojom {
CustomProxyConfig::CustomProxyConfig()
    : rules(),
      should_override_existing_config(false),
      allow_non_idempotent_methods(false),
      connect_tunnel_headers() {}

CustomProxyConfig::CustomProxyConfig(
    const ::net::ProxyConfig::ProxyRules& rules_in,
    bool should_override_existing_config_in,
    bool allow_non_idempotent_methods_in,
    const ::net::HttpRequestHeaders& connect_tunnel_headers_in)
    : rules(std::move(rules_in)),
      should_override_existing_config(std::move(should_override_existing_config_in)),
      allow_non_idempotent_methods(std::move(allow_non_idempotent_methods_in)),
      connect_tunnel_headers(std::move(connect_tunnel_headers_in)) {}

CustomProxyConfig::~CustomProxyConfig() = default;

void CustomProxyConfig::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "rules"), this->rules,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::net::ProxyConfig::ProxyRules&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "should_override_existing_config"), this->should_override_existing_config,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "allow_non_idempotent_methods"), this->allow_non_idempotent_methods,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "connect_tunnel_headers"), this->connect_tunnel_headers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::net::HttpRequestHeaders&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CustomProxyConfig::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CertVerifierServiceRemoteParams::CertVerifierServiceRemoteParams()
    : cert_verifier_service() {}

CertVerifierServiceRemoteParams::CertVerifierServiceRemoteParams(
    ::mojo::PendingRemote<::cert_verifier::mojom::CertVerifierService> cert_verifier_service_in)
    : cert_verifier_service(std::move(cert_verifier_service_in)) {}

CertVerifierServiceRemoteParams::~CertVerifierServiceRemoteParams() = default;

void CertVerifierServiceRemoteParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cert_verifier_service"), this->cert_verifier_service,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::cert_verifier::mojom::CertVerifierService>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CertVerifierServiceRemoteParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
HttpAuthStaticNetworkContextParams::HttpAuthStaticNetworkContextParams()
    : allow_default_credentials(mojo::internal::ConvertEnumValue<::network::mojom::DefaultCredentials, ::net::HttpAuthPreferences::DefaultCredentials>(::network::mojom::DefaultCredentials::ALLOW_DEFAULT_CREDENTIALS)) {}

HttpAuthStaticNetworkContextParams::HttpAuthStaticNetworkContextParams(
    ::net::HttpAuthPreferences::DefaultCredentials allow_default_credentials_in)
    : allow_default_credentials(std::move(allow_default_credentials_in)) {}

HttpAuthStaticNetworkContextParams::~HttpAuthStaticNetworkContextParams() = default;

void HttpAuthStaticNetworkContextParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "allow_default_credentials"), this->allow_default_credentials,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::net::HttpAuthPreferences::DefaultCredentials>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool HttpAuthStaticNetworkContextParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
CTPolicy::CTPolicy()
    : required_hosts(),
      excluded_hosts(),
      excluded_spkis(),
      excluded_legacy_spkis() {}

CTPolicy::CTPolicy(
    std::vector<std::string> required_hosts_in,
    std::vector<std::string> excluded_hosts_in,
    std::vector<std::string> excluded_spkis_in,
    std::vector<std::string> excluded_legacy_spkis_in)
    : required_hosts(std::move(required_hosts_in)),
      excluded_hosts(std::move(excluded_hosts_in)),
      excluded_spkis(std::move(excluded_spkis_in)),
      excluded_legacy_spkis(std::move(excluded_legacy_spkis_in)) {}

CTPolicy::~CTPolicy() = default;

void CTPolicy::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "required_hosts"), this->required_hosts,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "excluded_hosts"), this->excluded_hosts,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "excluded_spkis"), this->excluded_spkis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "excluded_legacy_spkis"), this->excluded_legacy_spkis,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool CTPolicy::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
NetworkContextFilePaths::NetworkContextFilePaths()
    : data_directory(),
      unsandboxed_data_path(),
      cookie_database_name(),
      trust_token_database_name(),
      http_server_properties_file_name(),
      transport_security_persister_file_name(),
      reporting_and_nel_store_database_name(),
      sct_auditing_pending_reports_file_name(),
      trigger_migration(false) {}

NetworkContextFilePaths::NetworkContextFilePaths(
    ::network::TransferableDirectory data_directory_in,
    const absl::optional<::base::FilePath>& unsandboxed_data_path_in,
    const absl::optional<::base::FilePath>& cookie_database_name_in,
    const absl::optional<::base::FilePath>& trust_token_database_name_in,
    const absl::optional<::base::FilePath>& http_server_properties_file_name_in,
    const absl::optional<::base::FilePath>& transport_security_persister_file_name_in,
    const absl::optional<::base::FilePath>& reporting_and_nel_store_database_name_in,
    const absl::optional<::base::FilePath>& sct_auditing_pending_reports_file_name_in,
    bool trigger_migration_in)
    : data_directory(std::move(data_directory_in)),
      unsandboxed_data_path(std::move(unsandboxed_data_path_in)),
      cookie_database_name(std::move(cookie_database_name_in)),
      trust_token_database_name(std::move(trust_token_database_name_in)),
      http_server_properties_file_name(std::move(http_server_properties_file_name_in)),
      transport_security_persister_file_name(std::move(transport_security_persister_file_name_in)),
      reporting_and_nel_store_database_name(std::move(reporting_and_nel_store_database_name_in)),
      sct_auditing_pending_reports_file_name(std::move(sct_auditing_pending_reports_file_name_in)),
      trigger_migration(std::move(trigger_migration_in)) {}

NetworkContextFilePaths::~NetworkContextFilePaths() = default;

void NetworkContextFilePaths::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data_directory"), this->data_directory,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::TransferableDirectory>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "unsandboxed_data_path"), this->unsandboxed_data_path,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cookie_database_name"), this->cookie_database_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "trust_token_database_name"), this->trust_token_database_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "http_server_properties_file_name"), this->http_server_properties_file_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "transport_security_persister_file_name"), this->transport_security_persister_file_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_and_nel_store_database_name"), this->reporting_and_nel_store_database_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "sct_auditing_pending_reports_file_name"), this->sct_auditing_pending_reports_file_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::FilePath>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "trigger_migration"), this->trigger_migration,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool NetworkContextFilePaths::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
NetworkContextParams::NetworkContextParams()
    : user_agent(),
      accept_language(),
      enable_brotli(true),
      quic_user_agent_id(),
      enable_referrers(true),
      validate_referrer_policy_on_initial_request(true),
      proxy_resolver_factory(),
      enable_encrypted_cookies(true),
      restore_old_session_cookies(false),
      persist_session_cookies(false),
      http_cache_enabled(true),
      http_cache_max_size(0),
      http_cache_directory(),
      http_cache_file_operations_factory(),
      check_clear_text_permitted(false),
      disable_idle_sockets_close_on_memory_pressure(false),
      initial_ssl_config(),
      ssl_config_client_receiver(),
      initial_proxy_config(),
      proxy_config_client_receiver(),
      initial_custom_proxy_config(),
      custom_proxy_config_client_receiver(),
      custom_proxy_connection_observer_remote(),
      proxy_config_poller_client(),
      proxy_error_client(),
      socket_broker(),
      pac_quick_check_enabled(true),
      enable_certificate_reporting(false),
      enforce_chrome_ct_policy(false),
      enable_expect_ct_reporting(false),
      sct_auditing_mode(SCTAuditingMode::kDisabled),
      ct_policy(),
      cert_verifier_params(),
      cookie_manager_params(),
      cookie_manager(),
      enable_domain_reliability(false),
      domain_reliability_upload_reporter(),
      discard_domain_reliablity_uploads(false),
      reporting_delivery_interval(),
      skip_reporting_send_permission_check(false),
      cors_origin_access_list(),
      cors_exempt_header_list(),
      allow_any_cors_exempt_header_for_browser(false),
      hsts_policy_bypass_list(),
      http_auth_static_network_context_params(),
      reset_http_cache_backend(false),
      split_auth_cache_by_network_isolation_key(false),
      require_network_isolation_key(false),
      file_paths(),
      block_trust_tokens(),
      first_party_sets_access_delegate_params(),
      first_party_sets_access_delegate_receiver() {}

NetworkContextParams::NetworkContextParams(
    const std::string& user_agent_in,
    const std::string& accept_language_in,
    bool enable_brotli_in,
    const std::string& quic_user_agent_id_in,
    bool enable_referrers_in,
    bool validate_referrer_policy_on_initial_request_in,
    ::mojo::PendingRemote<::proxy_resolver::mojom::ProxyResolverFactory> proxy_resolver_factory_in,
    bool enable_encrypted_cookies_in,
    bool restore_old_session_cookies_in,
    bool persist_session_cookies_in,
    bool http_cache_enabled_in,
    int32_t http_cache_max_size_in,
    absl::optional<::network::TransferableDirectory> http_cache_directory_in,
    ::mojo::PendingRemote<::network::mojom::HttpCacheBackendFileOperationsFactory> http_cache_file_operations_factory_in,
    bool check_clear_text_permitted_in,
    bool disable_idle_sockets_close_on_memory_pressure_in,
    ::network::mojom::SSLConfigPtr initial_ssl_config_in,
    ::mojo::PendingReceiver<::network::mojom::SSLConfigClient> ssl_config_client_receiver_in,
    const absl::optional<::net::ProxyConfigWithAnnotation>& initial_proxy_config_in,
    ::mojo::PendingReceiver<::network::mojom::ProxyConfigClient> proxy_config_client_receiver_in,
    CustomProxyConfigPtr initial_custom_proxy_config_in,
    ::mojo::PendingReceiver<CustomProxyConfigClient> custom_proxy_config_client_receiver_in,
    ::mojo::PendingRemote<CustomProxyConnectionObserver> custom_proxy_connection_observer_remote_in,
    ::mojo::PendingRemote<::network::mojom::ProxyConfigPollerClient> proxy_config_poller_client_in,
    ::mojo::PendingRemote<::network::mojom::ProxyErrorClient> proxy_error_client_in,
    ::mojo::PendingRemote<::network::mojom::SocketBroker> socket_broker_in,
    bool pac_quick_check_enabled_in,
    bool enable_certificate_reporting_in,
    bool enforce_chrome_ct_policy_in,
    bool enable_expect_ct_reporting_in,
    SCTAuditingMode sct_auditing_mode_in,
    CTPolicyPtr ct_policy_in,
    CertVerifierServiceRemoteParamsPtr cert_verifier_params_in,
    ::network::mojom::CookieManagerParamsPtr cookie_manager_params_in,
    ::mojo::PendingReceiver<::network::mojom::CookieManager> cookie_manager_in,
    bool enable_domain_reliability_in,
    const std::string& domain_reliability_upload_reporter_in,
    bool discard_domain_reliablity_uploads_in,
    absl::optional<::base::TimeDelta> reporting_delivery_interval_in,
    bool skip_reporting_send_permission_check_in,
    std::vector<::network::mojom::CorsOriginAccessPatternsPtr> cors_origin_access_list_in,
    std::vector<std::string> cors_exempt_header_list_in,
    bool allow_any_cors_exempt_header_for_browser_in,
    std::vector<std::string> hsts_policy_bypass_list_in,
    HttpAuthStaticNetworkContextParamsPtr http_auth_static_network_context_params_in,
    bool reset_http_cache_backend_in,
    bool split_auth_cache_by_network_isolation_key_in,
    bool require_network_isolation_key_in,
    NetworkContextFilePathsPtr file_paths_in,
    bool block_trust_tokens_in,
    ::network::mojom::FirstPartySetsAccessDelegateParamsPtr first_party_sets_access_delegate_params_in,
    ::mojo::PendingReceiver<::network::mojom::FirstPartySetsAccessDelegate> first_party_sets_access_delegate_receiver_in)
    : user_agent(std::move(user_agent_in)),
      accept_language(std::move(accept_language_in)),
      enable_brotli(std::move(enable_brotli_in)),
      quic_user_agent_id(std::move(quic_user_agent_id_in)),
      enable_referrers(std::move(enable_referrers_in)),
      validate_referrer_policy_on_initial_request(std::move(validate_referrer_policy_on_initial_request_in)),
      proxy_resolver_factory(std::move(proxy_resolver_factory_in)),
      enable_encrypted_cookies(std::move(enable_encrypted_cookies_in)),
      restore_old_session_cookies(std::move(restore_old_session_cookies_in)),
      persist_session_cookies(std::move(persist_session_cookies_in)),
      http_cache_enabled(std::move(http_cache_enabled_in)),
      http_cache_max_size(std::move(http_cache_max_size_in)),
      http_cache_directory(std::move(http_cache_directory_in)),
      http_cache_file_operations_factory(std::move(http_cache_file_operations_factory_in)),
      check_clear_text_permitted(std::move(check_clear_text_permitted_in)),
      disable_idle_sockets_close_on_memory_pressure(std::move(disable_idle_sockets_close_on_memory_pressure_in)),
      initial_ssl_config(std::move(initial_ssl_config_in)),
      ssl_config_client_receiver(std::move(ssl_config_client_receiver_in)),
      initial_proxy_config(std::move(initial_proxy_config_in)),
      proxy_config_client_receiver(std::move(proxy_config_client_receiver_in)),
      initial_custom_proxy_config(std::move(initial_custom_proxy_config_in)),
      custom_proxy_config_client_receiver(std::move(custom_proxy_config_client_receiver_in)),
      custom_proxy_connection_observer_remote(std::move(custom_proxy_connection_observer_remote_in)),
      proxy_config_poller_client(std::move(proxy_config_poller_client_in)),
      proxy_error_client(std::move(proxy_error_client_in)),
      socket_broker(std::move(socket_broker_in)),
      pac_quick_check_enabled(std::move(pac_quick_check_enabled_in)),
      enable_certificate_reporting(std::move(enable_certificate_reporting_in)),
      enforce_chrome_ct_policy(std::move(enforce_chrome_ct_policy_in)),
      enable_expect_ct_reporting(std::move(enable_expect_ct_reporting_in)),
      sct_auditing_mode(std::move(sct_auditing_mode_in)),
      ct_policy(std::move(ct_policy_in)),
      cert_verifier_params(std::move(cert_verifier_params_in)),
      cookie_manager_params(std::move(cookie_manager_params_in)),
      cookie_manager(std::move(cookie_manager_in)),
      enable_domain_reliability(std::move(enable_domain_reliability_in)),
      domain_reliability_upload_reporter(std::move(domain_reliability_upload_reporter_in)),
      discard_domain_reliablity_uploads(std::move(discard_domain_reliablity_uploads_in)),
      reporting_delivery_interval(std::move(reporting_delivery_interval_in)),
      skip_reporting_send_permission_check(std::move(skip_reporting_send_permission_check_in)),
      cors_origin_access_list(std::move(cors_origin_access_list_in)),
      cors_exempt_header_list(std::move(cors_exempt_header_list_in)),
      allow_any_cors_exempt_header_for_browser(std::move(allow_any_cors_exempt_header_for_browser_in)),
      hsts_policy_bypass_list(std::move(hsts_policy_bypass_list_in)),
      http_auth_static_network_context_params(std::move(http_auth_static_network_context_params_in)),
      reset_http_cache_backend(std::move(reset_http_cache_backend_in)),
      split_auth_cache_by_network_isolation_key(std::move(split_auth_cache_by_network_isolation_key_in)),
      require_network_isolation_key(std::move(require_network_isolation_key_in)),
      file_paths(std::move(file_paths_in)),
      block_trust_tokens(std::move(block_trust_tokens_in)),
      first_party_sets_access_delegate_params(std::move(first_party_sets_access_delegate_params_in)),
      first_party_sets_access_delegate_receiver(std::move(first_party_sets_access_delegate_receiver_in)) {}

NetworkContextParams::~NetworkContextParams() = default;

void NetworkContextParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "user_agent"), this->user_agent,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "accept_language"), this->accept_language,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enable_brotli"), this->enable_brotli,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "quic_user_agent_id"), this->quic_user_agent_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enable_referrers"), this->enable_referrers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "validate_referrer_policy_on_initial_request"), this->validate_referrer_policy_on_initial_request,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "proxy_resolver_factory"), this->proxy_resolver_factory,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::proxy_resolver::mojom::ProxyResolverFactory>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enable_encrypted_cookies"), this->enable_encrypted_cookies,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "restore_old_session_cookies"), this->restore_old_session_cookies,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "persist_session_cookies"), this->persist_session_cookies,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "http_cache_enabled"), this->http_cache_enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "http_cache_max_size"), this->http_cache_max_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "http_cache_directory"), this->http_cache_directory,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type absl::optional<::network::TransferableDirectory>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "http_cache_file_operations_factory"), this->http_cache_file_operations_factory,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::HttpCacheBackendFileOperationsFactory>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "check_clear_text_permitted"), this->check_clear_text_permitted,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "disable_idle_sockets_close_on_memory_pressure"), this->disable_idle_sockets_close_on_memory_pressure,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initial_ssl_config"), this->initial_ssl_config,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::SSLConfigPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ssl_config_client_receiver"), this->ssl_config_client_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<::network::mojom::SSLConfigClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initial_proxy_config"), this->initial_proxy_config,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::net::ProxyConfigWithAnnotation>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "proxy_config_client_receiver"), this->proxy_config_client_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<::network::mojom::ProxyConfigClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initial_custom_proxy_config"), this->initial_custom_proxy_config,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CustomProxyConfigPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "custom_proxy_config_client_receiver"), this->custom_proxy_config_client_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<CustomProxyConfigClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "custom_proxy_connection_observer_remote"), this->custom_proxy_connection_observer_remote,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<CustomProxyConnectionObserver>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "proxy_config_poller_client"), this->proxy_config_poller_client,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::ProxyConfigPollerClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "proxy_error_client"), this->proxy_error_client,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::ProxyErrorClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "socket_broker"), this->socket_broker,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::SocketBroker>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "pac_quick_check_enabled"), this->pac_quick_check_enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enable_certificate_reporting"), this->enable_certificate_reporting,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enforce_chrome_ct_policy"), this->enforce_chrome_ct_policy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enable_expect_ct_reporting"), this->enable_expect_ct_reporting,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "sct_auditing_mode"), this->sct_auditing_mode,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type SCTAuditingMode>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ct_policy"), this->ct_policy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CTPolicyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cert_verifier_params"), this->cert_verifier_params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type CertVerifierServiceRemoteParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cookie_manager_params"), this->cookie_manager_params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::CookieManagerParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cookie_manager"), this->cookie_manager,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<::network::mojom::CookieManager>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "enable_domain_reliability"), this->enable_domain_reliability,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "domain_reliability_upload_reporter"), this->domain_reliability_upload_reporter,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "discard_domain_reliablity_uploads"), this->discard_domain_reliablity_uploads,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_delivery_interval"), this->reporting_delivery_interval,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type absl::optional<::base::TimeDelta>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "skip_reporting_send_permission_check"), this->skip_reporting_send_permission_check,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cors_origin_access_list"), this->cors_origin_access_list,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<::network::mojom::CorsOriginAccessPatternsPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cors_exempt_header_list"), this->cors_exempt_header_list,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "allow_any_cors_exempt_header_for_browser"), this->allow_any_cors_exempt_header_for_browser,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "hsts_policy_bypass_list"), this->hsts_policy_bypass_list,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "http_auth_static_network_context_params"), this->http_auth_static_network_context_params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type HttpAuthStaticNetworkContextParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reset_http_cache_backend"), this->reset_http_cache_backend,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "split_auth_cache_by_network_isolation_key"), this->split_auth_cache_by_network_isolation_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "require_network_isolation_key"), this->require_network_isolation_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "file_paths"), this->file_paths,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type NetworkContextFilePathsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "block_trust_tokens"), this->block_trust_tokens,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "first_party_sets_access_delegate_params"), this->first_party_sets_access_delegate_params,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::FirstPartySetsAccessDelegateParamsPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "first_party_sets_access_delegate_receiver"), this->first_party_sets_access_delegate_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<::network::mojom::FirstPartySetsAccessDelegate>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool NetworkContextParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
NetworkConditions::NetworkConditions()
    : offline(),
      latency(),
      download_throughput(),
      upload_throughput() {}

NetworkConditions::NetworkConditions(
    bool offline_in,
    ::base::TimeDelta latency_in,
    double download_throughput_in,
    double upload_throughput_in)
    : offline(std::move(offline_in)),
      latency(std::move(latency_in)),
      download_throughput(std::move(download_throughput_in)),
      upload_throughput(std::move(upload_throughput_in)) {}

NetworkConditions::~NetworkConditions() = default;

void NetworkConditions::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "offline"), this->offline,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "latency"), this->latency,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "download_throughput"), this->download_throughput,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "upload_throughput"), this->upload_throughput,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type double>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool NetworkConditions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ClearDataFilter::ClearDataFilter()
    : type(),
      domains(),
      origins() {}

ClearDataFilter::ClearDataFilter(
    ClearDataFilter::Type type_in,
    std::vector<std::string> domains_in,
    std::vector<::url::Origin> origins_in)
    : type(std::move(type_in)),
      domains(std::move(domains_in)),
      origins(std::move(origins_in)) {}

ClearDataFilter::~ClearDataFilter() = default;

void ClearDataFilter::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ClearDataFilter::Type>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "domains"), this->domains,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "origins"), this->origins,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::url::Origin>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ClearDataFilter::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SignedExchangeReport::SignedExchangeReport()
    : success(),
      type(),
      outer_url(),
      inner_url(),
      cert_url(),
      referrer(),
      server_ip_address(),
      protocol(),
      method(),
      status_code(),
      elapsed_time() {}

SignedExchangeReport::SignedExchangeReport(
    bool success_in,
    const std::string& type_in,
    const ::GURL& outer_url_in,
    const ::GURL& inner_url_in,
    const ::GURL& cert_url_in,
    const std::string& referrer_in,
    const ::net::IPAddress& server_ip_address_in,
    const std::string& protocol_in,
    const std::string& method_in,
    int32_t status_code_in,
    ::base::TimeDelta elapsed_time_in)
    : success(std::move(success_in)),
      type(std::move(type_in)),
      outer_url(std::move(outer_url_in)),
      inner_url(std::move(inner_url_in)),
      cert_url(std::move(cert_url_in)),
      referrer(std::move(referrer_in)),
      server_ip_address(std::move(server_ip_address_in)),
      protocol(std::move(protocol_in)),
      method(std::move(method_in)),
      status_code(std::move(status_code_in)),
      elapsed_time(std::move(elapsed_time_in)) {}

SignedExchangeReport::~SignedExchangeReport() = default;

void SignedExchangeReport::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "success"), this->success,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "type"), this->type,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "outer_url"), this->outer_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "inner_url"), this->inner_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cert_url"), this->cert_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "referrer"), this->referrer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "server_ip_address"), this->server_ip_address,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::net::IPAddress&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "protocol"), this->protocol,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "method"), this->method,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "status_code"), this->status_code,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "elapsed_time"), this->elapsed_time,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::base::TimeDelta>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SignedExchangeReport::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
URLLoaderFactoryOverride::URLLoaderFactoryOverride()
    : overriding_factory(),
      overridden_factory_receiver(),
      skip_cors_enabled_scheme_check(false) {}

URLLoaderFactoryOverride::URLLoaderFactoryOverride(
    ::mojo::PendingRemote<::network::mojom::URLLoaderFactory> overriding_factory_in,
    ::mojo::PendingReceiver<::network::mojom::URLLoaderFactory> overridden_factory_receiver_in,
    bool skip_cors_enabled_scheme_check_in)
    : overriding_factory(std::move(overriding_factory_in)),
      overridden_factory_receiver(std::move(overridden_factory_receiver_in)),
      skip_cors_enabled_scheme_check(std::move(skip_cors_enabled_scheme_check_in)) {}

URLLoaderFactoryOverride::~URLLoaderFactoryOverride() = default;

void URLLoaderFactoryOverride::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "overriding_factory"), this->overriding_factory,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::URLLoaderFactory>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "overridden_factory_receiver"), this->overridden_factory_receiver,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingReceiver<::network::mojom::URLLoaderFactory>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "skip_cors_enabled_scheme_check"), this->skip_cors_enabled_scheme_check,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool URLLoaderFactoryOverride::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
URLLoaderFactoryParams::URLLoaderFactoryParams()
    : process_id(kInvalidProcessId),
      request_initiator_origin_lock(),
      is_corb_enabled(true),
      ignore_isolated_world_origin(true),
      unsafe_non_webby_initiator(false),
      disable_web_security(false),
      header_client(),
      isolation_info(),
      disable_secure_dns(false),
      is_trusted(false),
      automatically_assign_isolation_info(false),
      provide_loading_state_updates(false),
      top_frame_id(),
      factory_override(),
      client_security_state(),
      coep_reporter(),
      cookie_observer(),
      url_loader_network_observer(),
      devtools_observer(),
      trust_token_redemption_policy(TrustTokenRedemptionPolicy::kPotentiallyPermit),
      debug_tag("") {}

URLLoaderFactoryParams::URLLoaderFactoryParams(
    int32_t process_id_in,
    const absl::optional<::url::Origin>& request_initiator_origin_lock_in,
    bool is_corb_enabled_in,
    bool ignore_isolated_world_origin_in,
    bool unsafe_non_webby_initiator_in,
    bool disable_web_security_in,
    ::mojo::PendingRemote<TrustedURLLoaderHeaderClient> header_client_in,
    const ::net::IsolationInfo& isolation_info_in,
    bool disable_secure_dns_in,
    bool is_trusted_in,
    bool automatically_assign_isolation_info_in,
    bool provide_loading_state_updates_in,
    const absl::optional<::base::UnguessableToken>& top_frame_id_in,
    URLLoaderFactoryOverridePtr factory_override_in,
    ::network::mojom::ClientSecurityStatePtr client_security_state_in,
    ::mojo::PendingRemote<::network::mojom::CrossOriginEmbedderPolicyReporter> coep_reporter_in,
    ::mojo::PendingRemote<::network::mojom::CookieAccessObserver> cookie_observer_in,
    ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver> url_loader_network_observer_in,
    ::mojo::PendingRemote<::network::mojom::DevToolsObserver> devtools_observer_in,
    TrustTokenRedemptionPolicy trust_token_redemption_policy_in,
    const std::string& debug_tag_in)
    : process_id(std::move(process_id_in)),
      request_initiator_origin_lock(std::move(request_initiator_origin_lock_in)),
      is_corb_enabled(std::move(is_corb_enabled_in)),
      ignore_isolated_world_origin(std::move(ignore_isolated_world_origin_in)),
      unsafe_non_webby_initiator(std::move(unsafe_non_webby_initiator_in)),
      disable_web_security(std::move(disable_web_security_in)),
      header_client(std::move(header_client_in)),
      isolation_info(std::move(isolation_info_in)),
      disable_secure_dns(std::move(disable_secure_dns_in)),
      is_trusted(std::move(is_trusted_in)),
      automatically_assign_isolation_info(std::move(automatically_assign_isolation_info_in)),
      provide_loading_state_updates(std::move(provide_loading_state_updates_in)),
      top_frame_id(std::move(top_frame_id_in)),
      factory_override(std::move(factory_override_in)),
      client_security_state(std::move(client_security_state_in)),
      coep_reporter(std::move(coep_reporter_in)),
      cookie_observer(std::move(cookie_observer_in)),
      url_loader_network_observer(std::move(url_loader_network_observer_in)),
      devtools_observer(std::move(devtools_observer_in)),
      trust_token_redemption_policy(std::move(trust_token_redemption_policy_in)),
      debug_tag(std::move(debug_tag_in)) {}

URLLoaderFactoryParams::~URLLoaderFactoryParams() = default;

void URLLoaderFactoryParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "process_id"), this->process_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "request_initiator_origin_lock"), this->request_initiator_origin_lock,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::url::Origin>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_corb_enabled"), this->is_corb_enabled,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ignore_isolated_world_origin"), this->ignore_isolated_world_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "unsafe_non_webby_initiator"), this->unsafe_non_webby_initiator,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "disable_web_security"), this->disable_web_security,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "header_client"), this->header_client,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<TrustedURLLoaderHeaderClient>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "isolation_info"), this->isolation_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::net::IsolationInfo&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "disable_secure_dns"), this->disable_secure_dns,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_trusted"), this->is_trusted,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "automatically_assign_isolation_info"), this->automatically_assign_isolation_info,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "provide_loading_state_updates"), this->provide_loading_state_updates,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "top_frame_id"), this->top_frame_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::base::UnguessableToken>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "factory_override"), this->factory_override,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type URLLoaderFactoryOverridePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "client_security_state"), this->client_security_state,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::ClientSecurityStatePtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "coep_reporter"), this->coep_reporter,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::CrossOriginEmbedderPolicyReporter>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cookie_observer"), this->cookie_observer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::CookieAccessObserver>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url_loader_network_observer"), this->url_loader_network_observer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "devtools_observer"), this->devtools_observer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::network::mojom::DevToolsObserver>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "trust_token_redemption_policy"), this->trust_token_redemption_policy,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type TrustTokenRedemptionPolicy>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "debug_tag"), this->debug_tag,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool URLLoaderFactoryParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char CustomProxyConnectionObserver::Name_[] = "network.mojom.CustomProxyConnectionObserver";

CustomProxyConnectionObserver::IPCStableHashFunction CustomProxyConnectionObserver::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kCustomProxyConnectionObserver_OnFallback_Name: {
      return &CustomProxyConnectionObserver::OnFallback_Sym::IPCStableHash;
    }
    case internal::kCustomProxyConnectionObserver_OnTunnelHeadersReceived_Name: {
      return &CustomProxyConnectionObserver::OnTunnelHeadersReceived_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* CustomProxyConnectionObserver::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kCustomProxyConnectionObserver_OnFallback_Name:
            return "Receive network::mojom::CustomProxyConnectionObserver::OnFallback";
      case internal::kCustomProxyConnectionObserver_OnTunnelHeadersReceived_Name:
            return "Receive network::mojom::CustomProxyConnectionObserver::OnTunnelHeadersReceived";
    }
  } else {
    switch (message.name()) {
      case internal::kCustomProxyConnectionObserver_OnFallback_Name:
            return "Receive reply network::mojom::CustomProxyConnectionObserver::OnFallback";
      case internal::kCustomProxyConnectionObserver_OnTunnelHeadersReceived_Name:
            return "Receive reply network::mojom::CustomProxyConnectionObserver::OnTunnelHeadersReceived";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t CustomProxyConnectionObserver::OnFallback_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::CustomProxyConnectionObserver::OnFallback");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CustomProxyConnectionObserver::OnTunnelHeadersReceived_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::CustomProxyConnectionObserver::OnTunnelHeadersReceived");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

CustomProxyConnectionObserverProxy::CustomProxyConnectionObserverProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void CustomProxyConnectionObserverProxy::OnFallback(
    const ::net::ProxyServer& in_bad_proxy, int32_t in_net_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::CustomProxyConnectionObserver::OnFallback", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bad_proxy"), in_bad_proxy,
                        "<value of type const ::net::ProxyServer&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("net_error"), in_net_error,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConnectionObserver_OnFallback_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConnectionObserver_OnFallback_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bad_proxy)::BaseType> bad_proxy_fragment(
          params.message());
  mojo::internal::Serialize<::proxy_resolver::mojom::ProxyServerDataView>(
      in_bad_proxy, bad_proxy_fragment);
  params->bad_proxy.Set(
      bad_proxy_fragment.is_null() ? nullptr : bad_proxy_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bad_proxy.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bad_proxy in CustomProxyConnectionObserver.OnFallback request");
  params->net_error = in_net_error;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConnectionObserver::Name_);
  message.set_method_name("OnFallback");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void CustomProxyConnectionObserverProxy::OnTunnelHeadersReceived(
    const ::net::ProxyServer& in_proxy_server, const ::scoped_refptr<::net::HttpResponseHeaders>& in_response_headers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::CustomProxyConnectionObserver::OnTunnelHeadersReceived", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("proxy_server"), in_proxy_server,
                        "<value of type const ::net::ProxyServer&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("response_headers"), in_response_headers,
                        "<value of type const ::scoped_refptr<::net::HttpResponseHeaders>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConnectionObserver_OnTunnelHeadersReceived_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConnectionObserver_OnTunnelHeadersReceived_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->proxy_server)::BaseType> proxy_server_fragment(
          params.message());
  mojo::internal::Serialize<::proxy_resolver::mojom::ProxyServerDataView>(
      in_proxy_server, proxy_server_fragment);
  params->proxy_server.Set(
      proxy_server_fragment.is_null() ? nullptr : proxy_server_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->proxy_server.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null proxy_server in CustomProxyConnectionObserver.OnTunnelHeadersReceived request");
  mojo::internal::MessageFragment<
      typename decltype(params->response_headers)::BaseType> response_headers_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::HttpResponseHeadersDataView>(
      in_response_headers, response_headers_fragment);
  params->response_headers.Set(
      response_headers_fragment.is_null() ? nullptr : response_headers_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->response_headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null response_headers in CustomProxyConnectionObserver.OnTunnelHeadersReceived request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConnectionObserver::Name_);
  message.set_method_name("OnTunnelHeadersReceived");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool CustomProxyConnectionObserverStubDispatch::Accept(
    CustomProxyConnectionObserver* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kCustomProxyConnectionObserver_OnFallback_Name: {

      DCHECK(message->is_serialized());
      internal::CustomProxyConnectionObserver_OnFallback_Params_Data* params =
          reinterpret_cast<internal::CustomProxyConnectionObserver_OnFallback_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::net::ProxyServer p_bad_proxy{};
      int32_t p_net_error{};
      CustomProxyConnectionObserver_OnFallback_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBadProxy(&p_bad_proxy))
        success = false;
      if (success)
        p_net_error = input_data_view.net_error();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CustomProxyConnectionObserver::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnFallback(
std::move(p_bad_proxy), 
std::move(p_net_error));
      return true;
    }
    case internal::kCustomProxyConnectionObserver_OnTunnelHeadersReceived_Name: {

      DCHECK(message->is_serialized());
      internal::CustomProxyConnectionObserver_OnTunnelHeadersReceived_Params_Data* params =
          reinterpret_cast<internal::CustomProxyConnectionObserver_OnTunnelHeadersReceived_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::net::ProxyServer p_proxy_server{};
      ::scoped_refptr<::net::HttpResponseHeaders> p_response_headers{};
      CustomProxyConnectionObserver_OnTunnelHeadersReceived_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadProxyServer(&p_proxy_server))
        success = false;
      if (success && !input_data_view.ReadResponseHeaders(&p_response_headers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CustomProxyConnectionObserver::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnTunnelHeadersReceived(
std::move(p_proxy_server), 
std::move(p_response_headers));
      return true;
    }
  }
  return false;
}

// static
bool CustomProxyConnectionObserverStubDispatch::AcceptWithResponder(
    CustomProxyConnectionObserver* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kCustomProxyConnectionObserver_OnFallback_Name: {
      break;
    }
    case internal::kCustomProxyConnectionObserver_OnTunnelHeadersReceived_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kCustomProxyConnectionObserverValidationInfo[] = {
    {&internal::CustomProxyConnectionObserver_OnFallback_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::CustomProxyConnectionObserver_OnTunnelHeadersReceived_Params_Data::Validate,
     nullptr /* no response */},
};

bool CustomProxyConnectionObserverRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::CustomProxyConnectionObserver::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kCustomProxyConnectionObserverValidationInfo);
}

const char CustomProxyConfigClient::Name_[] = "network.mojom.CustomProxyConfigClient";

CustomProxyConfigClient::IPCStableHashFunction CustomProxyConfigClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name: {
      return &CustomProxyConfigClient::OnCustomProxyConfigUpdated_Sym::IPCStableHash;
    }
    case internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name: {
      return &CustomProxyConfigClient::MarkProxiesAsBad_Sym::IPCStableHash;
    }
    case internal::kCustomProxyConfigClient_ClearBadProxiesCache_Name: {
      return &CustomProxyConfigClient::ClearBadProxiesCache_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* CustomProxyConfigClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name:
            return "Receive network::mojom::CustomProxyConfigClient::OnCustomProxyConfigUpdated";
      case internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name:
            return "Receive network::mojom::CustomProxyConfigClient::MarkProxiesAsBad";
      case internal::kCustomProxyConfigClient_ClearBadProxiesCache_Name:
            return "Receive network::mojom::CustomProxyConfigClient::ClearBadProxiesCache";
    }
  } else {
    switch (message.name()) {
      case internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name:
            return "Receive reply network::mojom::CustomProxyConfigClient::OnCustomProxyConfigUpdated";
      case internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name:
            return "Receive reply network::mojom::CustomProxyConfigClient::MarkProxiesAsBad";
      case internal::kCustomProxyConfigClient_ClearBadProxiesCache_Name:
            return "Receive reply network::mojom::CustomProxyConfigClient::ClearBadProxiesCache";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t CustomProxyConfigClient::OnCustomProxyConfigUpdated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::CustomProxyConfigClient::OnCustomProxyConfigUpdated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CustomProxyConfigClient::MarkProxiesAsBad_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::CustomProxyConfigClient::MarkProxiesAsBad");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t CustomProxyConfigClient::ClearBadProxiesCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::CustomProxyConfigClient::ClearBadProxiesCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback(
      CustomProxyConfigClient::OnCustomProxyConfigUpdatedCallback callback
      ) : callback_(std::move(callback)) {
  }

  CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback(const CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback&) = delete;
  CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback& operator=(const CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CustomProxyConfigClient::OnCustomProxyConfigUpdatedCallback callback_;
};

class CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback(
      CustomProxyConfigClient::MarkProxiesAsBadCallback callback
      ) : callback_(std::move(callback)) {
  }

  CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback(const CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback&) = delete;
  CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback& operator=(const CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  CustomProxyConfigClient::MarkProxiesAsBadCallback callback_;
};

CustomProxyConfigClientProxy::CustomProxyConfigClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void CustomProxyConfigClientProxy::OnCustomProxyConfigUpdated(
    CustomProxyConfigPtr in_proxy_config, OnCustomProxyConfigUpdatedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::CustomProxyConfigClient::OnCustomProxyConfigUpdated", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("proxy_config"), in_proxy_config,
                        "<value of type CustomProxyConfigPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->proxy_config)::BaseType> proxy_config_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CustomProxyConfigDataView>(
      in_proxy_config, proxy_config_fragment);
  params->proxy_config.Set(
      proxy_config_fragment.is_null() ? nullptr : proxy_config_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->proxy_config.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null proxy_config in CustomProxyConfigClient.OnCustomProxyConfigUpdated request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConfigClient::Name_);
  message.set_method_name("OnCustomProxyConfigUpdated");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CustomProxyConfigClientProxy::MarkProxiesAsBad(
    ::base::TimeDelta in_bypass_duration, const ::net::ProxyList& in_bad_proxies, MarkProxiesAsBadCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::CustomProxyConfigClient::MarkProxiesAsBad", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bypass_duration"), in_bypass_duration,
                        "<value of type ::base::TimeDelta>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bad_proxies"), in_bad_proxies,
                        "<value of type const ::net::ProxyList&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConfigClient_MarkProxiesAsBad_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bypass_duration)::BaseType> bypass_duration_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
      in_bypass_duration, bypass_duration_fragment);
  params->bypass_duration.Set(
      bypass_duration_fragment.is_null() ? nullptr : bypass_duration_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bypass_duration.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bypass_duration in CustomProxyConfigClient.MarkProxiesAsBad request");
  mojo::internal::MessageFragment<
      typename decltype(params->bad_proxies)::BaseType> bad_proxies_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ProxyListDataView>(
      in_bad_proxies, bad_proxies_fragment);
  params->bad_proxies.Set(
      bad_proxies_fragment.is_null() ? nullptr : bad_proxies_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bad_proxies.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bad_proxies in CustomProxyConfigClient.MarkProxiesAsBad request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConfigClient::Name_);
  message.set_method_name("MarkProxiesAsBad");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void CustomProxyConfigClientProxy::ClearBadProxiesCache(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::CustomProxyConfigClient::ClearBadProxiesCache");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConfigClient_ClearBadProxiesCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConfigClient_ClearBadProxiesCache_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConfigClient::Name_);
  message.set_method_name("ClearBadProxiesCache");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CustomProxyConfigClient::OnCustomProxyConfigUpdatedCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder> proxy(
        new CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CustomProxyConfigClient::OnCustomProxyConfigUpdatedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool CustomProxyConfigClient_OnCustomProxyConfigUpdated_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CustomProxyConfigClient_OnCustomProxyConfigUpdated_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CustomProxyConfigClient::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::CustomProxyConfigClient::OnCustomProxyConfigUpdated");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConfigClient::Name_);
  message.set_method_name("OnCustomProxyConfigUpdated");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static CustomProxyConfigClient::MarkProxiesAsBadCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder> proxy(
        new CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "CustomProxyConfigClient::MarkProxiesAsBadCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool CustomProxyConfigClient_MarkProxiesAsBad_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::CustomProxyConfigClient_MarkProxiesAsBad_ResponseParams_Data* params =
      reinterpret_cast<
          internal::CustomProxyConfigClient_MarkProxiesAsBad_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  CustomProxyConfigClient_MarkProxiesAsBad_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        CustomProxyConfigClient::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::CustomProxyConfigClient::MarkProxiesAsBad");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::CustomProxyConfigClient_MarkProxiesAsBad_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(CustomProxyConfigClient::Name_);
  message.set_method_name("MarkProxiesAsBad");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool CustomProxyConfigClientStubDispatch::Accept(
    CustomProxyConfigClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name: {
      break;
    }
    case internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name: {
      break;
    }
    case internal::kCustomProxyConfigClient_ClearBadProxiesCache_Name: {

      DCHECK(message->is_serialized());
      internal::CustomProxyConfigClient_ClearBadProxiesCache_Params_Data* params =
          reinterpret_cast<internal::CustomProxyConfigClient_ClearBadProxiesCache_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      CustomProxyConfigClient_ClearBadProxiesCache_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CustomProxyConfigClient::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearBadProxiesCache();
      return true;
    }
  }
  return false;
}

// static
bool CustomProxyConfigClientStubDispatch::AcceptWithResponder(
    CustomProxyConfigClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kCustomProxyConfigClient_OnCustomProxyConfigUpdated_Name: {

      internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_Params_Data* params =
          reinterpret_cast<
              internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      CustomProxyConfigPtr p_proxy_config{};
      CustomProxyConfigClient_OnCustomProxyConfigUpdated_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadProxyConfig(&p_proxy_config))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CustomProxyConfigClient::Name_, 0, false);
        return false;
      }
      CustomProxyConfigClient::OnCustomProxyConfigUpdatedCallback callback =
          CustomProxyConfigClient_OnCustomProxyConfigUpdated_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCustomProxyConfigUpdated(
std::move(p_proxy_config), std::move(callback));
      return true;
    }
    case internal::kCustomProxyConfigClient_MarkProxiesAsBad_Name: {

      internal::CustomProxyConfigClient_MarkProxiesAsBad_Params_Data* params =
          reinterpret_cast<
              internal::CustomProxyConfigClient_MarkProxiesAsBad_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::TimeDelta p_bypass_duration{};
      ::net::ProxyList p_bad_proxies{};
      CustomProxyConfigClient_MarkProxiesAsBad_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBypassDuration(&p_bypass_duration))
        success = false;
      if (success && !input_data_view.ReadBadProxies(&p_bad_proxies))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            CustomProxyConfigClient::Name_, 1, false);
        return false;
      }
      CustomProxyConfigClient::MarkProxiesAsBadCallback callback =
          CustomProxyConfigClient_MarkProxiesAsBad_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MarkProxiesAsBad(
std::move(p_bypass_duration), 
std::move(p_bad_proxies), std::move(callback));
      return true;
    }
    case internal::kCustomProxyConfigClient_ClearBadProxiesCache_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kCustomProxyConfigClientValidationInfo[] = {
    {&internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_Params_Data::Validate,
     &internal::CustomProxyConfigClient_OnCustomProxyConfigUpdated_ResponseParams_Data::Validate},
    {&internal::CustomProxyConfigClient_MarkProxiesAsBad_Params_Data::Validate,
     &internal::CustomProxyConfigClient_MarkProxiesAsBad_ResponseParams_Data::Validate},
    {&internal::CustomProxyConfigClient_ClearBadProxiesCache_Params_Data::Validate,
     nullptr /* no response */},
};

bool CustomProxyConfigClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::CustomProxyConfigClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kCustomProxyConfigClientValidationInfo);
}

bool CustomProxyConfigClientResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::CustomProxyConfigClient::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kCustomProxyConfigClientValidationInfo);
}
const char TrustedHeaderClient::Name_[] = "network.mojom.TrustedHeaderClient";

TrustedHeaderClient::IPCStableHashFunction TrustedHeaderClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name: {
      return &TrustedHeaderClient::OnBeforeSendHeaders_Sym::IPCStableHash;
    }
    case internal::kTrustedHeaderClient_OnHeadersReceived_Name: {
      return &TrustedHeaderClient::OnHeadersReceived_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* TrustedHeaderClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name:
            return "Receive network::mojom::TrustedHeaderClient::OnBeforeSendHeaders";
      case internal::kTrustedHeaderClient_OnHeadersReceived_Name:
            return "Receive network::mojom::TrustedHeaderClient::OnHeadersReceived";
    }
  } else {
    switch (message.name()) {
      case internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name:
            return "Receive reply network::mojom::TrustedHeaderClient::OnBeforeSendHeaders";
      case internal::kTrustedHeaderClient_OnHeadersReceived_Name:
            return "Receive reply network::mojom::TrustedHeaderClient::OnHeadersReceived";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t TrustedHeaderClient::OnBeforeSendHeaders_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::TrustedHeaderClient::OnBeforeSendHeaders");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t TrustedHeaderClient::OnHeadersReceived_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::TrustedHeaderClient::OnHeadersReceived");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback(
      TrustedHeaderClient::OnBeforeSendHeadersCallback callback
      ) : callback_(std::move(callback)) {
  }

  TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback(const TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback&) = delete;
  TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback& operator=(const TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  TrustedHeaderClient::OnBeforeSendHeadersCallback callback_;
};

class TrustedHeaderClient_OnHeadersReceived_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  TrustedHeaderClient_OnHeadersReceived_ForwardToCallback(
      TrustedHeaderClient::OnHeadersReceivedCallback callback
      ) : callback_(std::move(callback)) {
  }

  TrustedHeaderClient_OnHeadersReceived_ForwardToCallback(const TrustedHeaderClient_OnHeadersReceived_ForwardToCallback&) = delete;
  TrustedHeaderClient_OnHeadersReceived_ForwardToCallback& operator=(const TrustedHeaderClient_OnHeadersReceived_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  TrustedHeaderClient::OnHeadersReceivedCallback callback_;
};

TrustedHeaderClientProxy::TrustedHeaderClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void TrustedHeaderClientProxy::OnBeforeSendHeaders(
    const ::net::HttpRequestHeaders& in_headers, OnBeforeSendHeadersCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::TrustedHeaderClient::OnBeforeSendHeaders", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("headers"), in_headers,
                        "<value of type const ::net::HttpRequestHeaders&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::TrustedHeaderClient_OnBeforeSendHeaders_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->headers)::BaseType> headers_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::HttpRequestHeadersDataView>(
      in_headers, headers_fragment);
  params->headers.Set(
      headers_fragment.is_null() ? nullptr : headers_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null headers in TrustedHeaderClient.OnBeforeSendHeaders request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TrustedHeaderClient::Name_);
  message.set_method_name("OnBeforeSendHeaders");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void TrustedHeaderClientProxy::OnHeadersReceived(
    const std::string& in_headers, const ::net::IPEndPoint& in_remote_endpoint, OnHeadersReceivedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::TrustedHeaderClient::OnHeadersReceived", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("headers"), in_headers,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_endpoint"), in_remote_endpoint,
                        "<value of type const ::net::IPEndPoint&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kTrustedHeaderClient_OnHeadersReceived_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::TrustedHeaderClient_OnHeadersReceived_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->headers)::BaseType> headers_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_headers, headers_fragment);
  params->headers.Set(
      headers_fragment.is_null() ? nullptr : headers_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null headers in TrustedHeaderClient.OnHeadersReceived request");
  mojo::internal::MessageFragment<
      typename decltype(params->remote_endpoint)::BaseType> remote_endpoint_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_remote_endpoint, remote_endpoint_fragment);
  params->remote_endpoint.Set(
      remote_endpoint_fragment.is_null() ? nullptr : remote_endpoint_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_endpoint.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_endpoint in TrustedHeaderClient.OnHeadersReceived request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TrustedHeaderClient::Name_);
  message.set_method_name("OnHeadersReceived");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new TrustedHeaderClient_OnHeadersReceived_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static TrustedHeaderClient::OnBeforeSendHeadersCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder> proxy(
        new TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TrustedHeaderClient::OnBeforeSendHeadersCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result, const absl::optional<::net::HttpRequestHeaders>& in_headers);
};

bool TrustedHeaderClient_OnBeforeSendHeaders_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::TrustedHeaderClient_OnBeforeSendHeaders_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TrustedHeaderClient_OnBeforeSendHeaders_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  absl::optional<::net::HttpRequestHeaders> p_headers{};
  TrustedHeaderClient_OnBeforeSendHeaders_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (success && !input_data_view.ReadHeaders(&p_headers))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TrustedHeaderClient::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_headers));
  return true;
}

void TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder::Run(
    int32_t in_result, const absl::optional<::net::HttpRequestHeaders>& in_headers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::TrustedHeaderClient::OnBeforeSendHeaders", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("headers"), in_headers,
                        "<value of type const absl::optional<::net::HttpRequestHeaders>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::TrustedHeaderClient_OnBeforeSendHeaders_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;
  mojo::internal::MessageFragment<
      typename decltype(params->headers)::BaseType> headers_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::HttpRequestHeadersDataView>(
      in_headers, headers_fragment);
  params->headers.Set(
      headers_fragment.is_null() ? nullptr : headers_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TrustedHeaderClient::Name_);
  message.set_method_name("OnBeforeSendHeaders");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class TrustedHeaderClient_OnHeadersReceived_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static TrustedHeaderClient::OnHeadersReceivedCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<TrustedHeaderClient_OnHeadersReceived_ProxyToResponder> proxy(
        new TrustedHeaderClient_OnHeadersReceived_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&TrustedHeaderClient_OnHeadersReceived_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~TrustedHeaderClient_OnHeadersReceived_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  TrustedHeaderClient_OnHeadersReceived_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "TrustedHeaderClient::OnHeadersReceivedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result, const absl::optional<std::string>& in_headers, const absl::optional<::GURL>& in_preserve_fragment_on_redirect_url);
};

bool TrustedHeaderClient_OnHeadersReceived_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::TrustedHeaderClient_OnHeadersReceived_ResponseParams_Data* params =
      reinterpret_cast<
          internal::TrustedHeaderClient_OnHeadersReceived_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  absl::optional<std::string> p_headers{};
  absl::optional<::GURL> p_preserve_fragment_on_redirect_url{};
  TrustedHeaderClient_OnHeadersReceived_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (success && !input_data_view.ReadHeaders(&p_headers))
    success = false;
  if (success && !input_data_view.ReadPreserveFragmentOnRedirectUrl(&p_preserve_fragment_on_redirect_url))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        TrustedHeaderClient::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_headers), 
std::move(p_preserve_fragment_on_redirect_url));
  return true;
}

void TrustedHeaderClient_OnHeadersReceived_ProxyToResponder::Run(
    int32_t in_result, const absl::optional<std::string>& in_headers, const absl::optional<::GURL>& in_preserve_fragment_on_redirect_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::TrustedHeaderClient::OnHeadersReceived", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("headers"), in_headers,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("preserve_fragment_on_redirect_url"), in_preserve_fragment_on_redirect_url,
                        "<value of type const absl::optional<::GURL>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kTrustedHeaderClient_OnHeadersReceived_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::TrustedHeaderClient_OnHeadersReceived_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;
  mojo::internal::MessageFragment<
      typename decltype(params->headers)::BaseType> headers_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_headers, headers_fragment);
  params->headers.Set(
      headers_fragment.is_null() ? nullptr : headers_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->preserve_fragment_on_redirect_url)::BaseType> preserve_fragment_on_redirect_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_preserve_fragment_on_redirect_url, preserve_fragment_on_redirect_url_fragment);
  params->preserve_fragment_on_redirect_url.Set(
      preserve_fragment_on_redirect_url_fragment.is_null() ? nullptr : preserve_fragment_on_redirect_url_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TrustedHeaderClient::Name_);
  message.set_method_name("OnHeadersReceived");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool TrustedHeaderClientStubDispatch::Accept(
    TrustedHeaderClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name: {
      break;
    }
    case internal::kTrustedHeaderClient_OnHeadersReceived_Name: {
      break;
    }
  }
  return false;
}

// static
bool TrustedHeaderClientStubDispatch::AcceptWithResponder(
    TrustedHeaderClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kTrustedHeaderClient_OnBeforeSendHeaders_Name: {

      internal::TrustedHeaderClient_OnBeforeSendHeaders_Params_Data* params =
          reinterpret_cast<
              internal::TrustedHeaderClient_OnBeforeSendHeaders_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::net::HttpRequestHeaders p_headers{};
      TrustedHeaderClient_OnBeforeSendHeaders_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHeaders(&p_headers))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TrustedHeaderClient::Name_, 0, false);
        return false;
      }
      TrustedHeaderClient::OnBeforeSendHeadersCallback callback =
          TrustedHeaderClient_OnBeforeSendHeaders_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnBeforeSendHeaders(
std::move(p_headers), std::move(callback));
      return true;
    }
    case internal::kTrustedHeaderClient_OnHeadersReceived_Name: {

      internal::TrustedHeaderClient_OnHeadersReceived_Params_Data* params =
          reinterpret_cast<
              internal::TrustedHeaderClient_OnHeadersReceived_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_headers{};
      ::net::IPEndPoint p_remote_endpoint{};
      TrustedHeaderClient_OnHeadersReceived_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHeaders(&p_headers))
        success = false;
      if (success && !input_data_view.ReadRemoteEndpoint(&p_remote_endpoint))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TrustedHeaderClient::Name_, 1, false);
        return false;
      }
      TrustedHeaderClient::OnHeadersReceivedCallback callback =
          TrustedHeaderClient_OnHeadersReceived_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnHeadersReceived(
std::move(p_headers), 
std::move(p_remote_endpoint), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kTrustedHeaderClientValidationInfo[] = {
    {&internal::TrustedHeaderClient_OnBeforeSendHeaders_Params_Data::Validate,
     &internal::TrustedHeaderClient_OnBeforeSendHeaders_ResponseParams_Data::Validate},
    {&internal::TrustedHeaderClient_OnHeadersReceived_Params_Data::Validate,
     &internal::TrustedHeaderClient_OnHeadersReceived_ResponseParams_Data::Validate},
};

bool TrustedHeaderClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::TrustedHeaderClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kTrustedHeaderClientValidationInfo);
}

bool TrustedHeaderClientResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::TrustedHeaderClient::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kTrustedHeaderClientValidationInfo);
}
const char TrustedURLLoaderHeaderClient::Name_[] = "network.mojom.TrustedURLLoaderHeaderClient";

TrustedURLLoaderHeaderClient::IPCStableHashFunction TrustedURLLoaderHeaderClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kTrustedURLLoaderHeaderClient_OnLoaderCreated_Name: {
      return &TrustedURLLoaderHeaderClient::OnLoaderCreated_Sym::IPCStableHash;
    }
    case internal::kTrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Name: {
      return &TrustedURLLoaderHeaderClient::OnLoaderForCorsPreflightCreated_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* TrustedURLLoaderHeaderClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kTrustedURLLoaderHeaderClient_OnLoaderCreated_Name:
            return "Receive network::mojom::TrustedURLLoaderHeaderClient::OnLoaderCreated";
      case internal::kTrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Name:
            return "Receive network::mojom::TrustedURLLoaderHeaderClient::OnLoaderForCorsPreflightCreated";
    }
  } else {
    switch (message.name()) {
      case internal::kTrustedURLLoaderHeaderClient_OnLoaderCreated_Name:
            return "Receive reply network::mojom::TrustedURLLoaderHeaderClient::OnLoaderCreated";
      case internal::kTrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Name:
            return "Receive reply network::mojom::TrustedURLLoaderHeaderClient::OnLoaderForCorsPreflightCreated";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t TrustedURLLoaderHeaderClient::OnLoaderCreated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::TrustedURLLoaderHeaderClient::OnLoaderCreated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t TrustedURLLoaderHeaderClient::OnLoaderForCorsPreflightCreated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::TrustedURLLoaderHeaderClient::OnLoaderForCorsPreflightCreated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

TrustedURLLoaderHeaderClientProxy::TrustedURLLoaderHeaderClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void TrustedURLLoaderHeaderClientProxy::OnLoaderCreated(
    int32_t in_request_id, ::mojo::PendingReceiver<TrustedHeaderClient> in_header_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::TrustedURLLoaderHeaderClient::OnLoaderCreated", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request_id"), in_request_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("header_client"), in_header_client,
                        "<value of type ::mojo::PendingReceiver<TrustedHeaderClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kTrustedURLLoaderHeaderClient_OnLoaderCreated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::TrustedURLLoaderHeaderClient_OnLoaderCreated_Params_Data> params(
          message);
  params.Allocate();
  params->request_id = in_request_id;
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::TrustedHeaderClientInterfaceBase>>(
      in_header_client, &params->header_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->header_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid header_client in TrustedURLLoaderHeaderClient.OnLoaderCreated request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TrustedURLLoaderHeaderClient::Name_);
  message.set_method_name("OnLoaderCreated");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void TrustedURLLoaderHeaderClientProxy::OnLoaderForCorsPreflightCreated(
    const ::network::ResourceRequest& in_request, ::mojo::PendingReceiver<TrustedHeaderClient> in_header_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::TrustedURLLoaderHeaderClient::OnLoaderForCorsPreflightCreated", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type const ::network::ResourceRequest&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("header_client"), in_header_client,
                        "<value of type ::mojo::PendingReceiver<TrustedHeaderClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kTrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::TrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::URLRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->request.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null request in TrustedURLLoaderHeaderClient.OnLoaderForCorsPreflightCreated request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::TrustedHeaderClientInterfaceBase>>(
      in_header_client, &params->header_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->header_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid header_client in TrustedURLLoaderHeaderClient.OnLoaderForCorsPreflightCreated request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(TrustedURLLoaderHeaderClient::Name_);
  message.set_method_name("OnLoaderForCorsPreflightCreated");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool TrustedURLLoaderHeaderClientStubDispatch::Accept(
    TrustedURLLoaderHeaderClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kTrustedURLLoaderHeaderClient_OnLoaderCreated_Name: {

      DCHECK(message->is_serialized());
      internal::TrustedURLLoaderHeaderClient_OnLoaderCreated_Params_Data* params =
          reinterpret_cast<internal::TrustedURLLoaderHeaderClient_OnLoaderCreated_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_request_id{};
      ::mojo::PendingReceiver<TrustedHeaderClient> p_header_client{};
      TrustedURLLoaderHeaderClient_OnLoaderCreated_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_request_id = input_data_view.request_id();
      if (success) {
        p_header_client =
            input_data_view.TakeHeaderClient<decltype(p_header_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TrustedURLLoaderHeaderClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnLoaderCreated(
std::move(p_request_id), 
std::move(p_header_client));
      return true;
    }
    case internal::kTrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Name: {

      DCHECK(message->is_serialized());
      internal::TrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Params_Data* params =
          reinterpret_cast<internal::TrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::network::ResourceRequest p_request{};
      ::mojo::PendingReceiver<TrustedHeaderClient> p_header_client{};
      TrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (success) {
        p_header_client =
            input_data_view.TakeHeaderClient<decltype(p_header_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            TrustedURLLoaderHeaderClient::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnLoaderForCorsPreflightCreated(
std::move(p_request), 
std::move(p_header_client));
      return true;
    }
  }
  return false;
}

// static
bool TrustedURLLoaderHeaderClientStubDispatch::AcceptWithResponder(
    TrustedURLLoaderHeaderClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kTrustedURLLoaderHeaderClient_OnLoaderCreated_Name: {
      break;
    }
    case internal::kTrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kTrustedURLLoaderHeaderClientValidationInfo[] = {
    {&internal::TrustedURLLoaderHeaderClient_OnLoaderCreated_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::TrustedURLLoaderHeaderClient_OnLoaderForCorsPreflightCreated_Params_Data::Validate,
     nullptr /* no response */},
};

bool TrustedURLLoaderHeaderClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::TrustedURLLoaderHeaderClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kTrustedURLLoaderHeaderClientValidationInfo);
}

const char NetworkContextClient::Name_[] = "network.mojom.NetworkContextClient";

NetworkContextClient::IPCStableHashFunction NetworkContextClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kNetworkContextClient_OnFileUploadRequested_Name: {
      return &NetworkContextClient::OnFileUploadRequested_Sym::IPCStableHash;
    }
    case internal::kNetworkContextClient_OnCanSendReportingReports_Name: {
      return &NetworkContextClient::OnCanSendReportingReports_Sym::IPCStableHash;
    }
    case internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name: {
      return &NetworkContextClient::OnCanSendDomainReliabilityUpload_Sym::IPCStableHash;
    }
    case internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name: {
      return &NetworkContextClient::OnGenerateHttpNegotiateAuthToken_Sym::IPCStableHash;
    }
    case internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name: {
      return &NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem_Sym::IPCStableHash;
    }
    case internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name: {
      return &NetworkContextClient::OnCanSendSCTAuditingReport_Sym::IPCStableHash;
    }
    case internal::kNetworkContextClient_OnNewSCTAuditingReportSent_Name: {
      return &NetworkContextClient::OnNewSCTAuditingReportSent_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* NetworkContextClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kNetworkContextClient_OnFileUploadRequested_Name:
            return "Receive network::mojom::NetworkContextClient::OnFileUploadRequested";
      case internal::kNetworkContextClient_OnCanSendReportingReports_Name:
            return "Receive network::mojom::NetworkContextClient::OnCanSendReportingReports";
      case internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name:
            return "Receive network::mojom::NetworkContextClient::OnCanSendDomainReliabilityUpload";
      case internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name:
            return "Receive network::mojom::NetworkContextClient::OnGenerateHttpNegotiateAuthToken";
      case internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name:
            return "Receive network::mojom::NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem";
      case internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name:
            return "Receive network::mojom::NetworkContextClient::OnCanSendSCTAuditingReport";
      case internal::kNetworkContextClient_OnNewSCTAuditingReportSent_Name:
            return "Receive network::mojom::NetworkContextClient::OnNewSCTAuditingReportSent";
    }
  } else {
    switch (message.name()) {
      case internal::kNetworkContextClient_OnFileUploadRequested_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnFileUploadRequested";
      case internal::kNetworkContextClient_OnCanSendReportingReports_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnCanSendReportingReports";
      case internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnCanSendDomainReliabilityUpload";
      case internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnGenerateHttpNegotiateAuthToken";
      case internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem";
      case internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnCanSendSCTAuditingReport";
      case internal::kNetworkContextClient_OnNewSCTAuditingReportSent_Name:
            return "Receive reply network::mojom::NetworkContextClient::OnNewSCTAuditingReportSent";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t NetworkContextClient::OnFileUploadRequested_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnFileUploadRequested");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContextClient::OnCanSendReportingReports_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnCanSendReportingReports");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContextClient::OnCanSendDomainReliabilityUpload_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnCanSendDomainReliabilityUpload");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContextClient::OnGenerateHttpNegotiateAuthToken_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnGenerateHttpNegotiateAuthToken");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContextClient::OnCanSendSCTAuditingReport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnCanSendSCTAuditingReport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContextClient::OnNewSCTAuditingReportSent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContextClient::OnNewSCTAuditingReportSent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class NetworkContextClient_OnFileUploadRequested_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContextClient_OnFileUploadRequested_ForwardToCallback(
      NetworkContextClient::OnFileUploadRequestedCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContextClient_OnFileUploadRequested_ForwardToCallback(const NetworkContextClient_OnFileUploadRequested_ForwardToCallback&) = delete;
  NetworkContextClient_OnFileUploadRequested_ForwardToCallback& operator=(const NetworkContextClient_OnFileUploadRequested_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContextClient::OnFileUploadRequestedCallback callback_;
};

class NetworkContextClient_OnCanSendReportingReports_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContextClient_OnCanSendReportingReports_ForwardToCallback(
      NetworkContextClient::OnCanSendReportingReportsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContextClient_OnCanSendReportingReports_ForwardToCallback(const NetworkContextClient_OnCanSendReportingReports_ForwardToCallback&) = delete;
  NetworkContextClient_OnCanSendReportingReports_ForwardToCallback& operator=(const NetworkContextClient_OnCanSendReportingReports_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContextClient::OnCanSendReportingReportsCallback callback_;
};

class NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback(
      NetworkContextClient::OnCanSendDomainReliabilityUploadCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback(const NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback&) = delete;
  NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback& operator=(const NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContextClient::OnCanSendDomainReliabilityUploadCallback callback_;
};

class NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback(
      NetworkContextClient::OnGenerateHttpNegotiateAuthTokenCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback(const NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback&) = delete;
  NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback& operator=(const NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContextClient::OnGenerateHttpNegotiateAuthTokenCallback callback_;
};

class NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback(
      NetworkContextClient::OnTrustTokenIssuanceDivertedToSystemCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback(const NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback&) = delete;
  NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback& operator=(const NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContextClient::OnTrustTokenIssuanceDivertedToSystemCallback callback_;
};

class NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback(
      NetworkContextClient::OnCanSendSCTAuditingReportCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback(const NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback&) = delete;
  NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback& operator=(const NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContextClient::OnCanSendSCTAuditingReportCallback callback_;
};

NetworkContextClientProxy::NetworkContextClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void NetworkContextClientProxy::OnFileUploadRequested(
    int32_t in_process_id, bool in_async, const std::vector<::base::FilePath>& in_file_paths, const ::GURL& in_destination_url, OnFileUploadRequestedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContextClient::OnFileUploadRequested", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("process_id"), in_process_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("async"), in_async,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("file_paths"), in_file_paths,
                        "<value of type const std::vector<::base::FilePath>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("destination_url"), in_destination_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnFileUploadRequested_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnFileUploadRequested_Params_Data> params(
          message);
  params.Allocate();
  params->process_id = in_process_id;
  params->async = in_async;
  mojo::internal::MessageFragment<
      typename decltype(params->file_paths)::BaseType>
      file_paths_fragment(params.message());
  const mojo::internal::ContainerValidateParams file_paths_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::FilePathDataView>>(
      in_file_paths, file_paths_fragment, &file_paths_validate_params);
  params->file_paths.Set(
      file_paths_fragment.is_null() ? nullptr : file_paths_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->file_paths.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null file_paths in NetworkContextClient.OnFileUploadRequested request");
  mojo::internal::MessageFragment<
      typename decltype(params->destination_url)::BaseType> destination_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_destination_url, destination_url_fragment);
  params->destination_url.Set(
      destination_url_fragment.is_null() ? nullptr : destination_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->destination_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null destination_url in NetworkContextClient.OnFileUploadRequested request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnFileUploadRequested");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContextClient_OnFileUploadRequested_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextClientProxy::OnCanSendReportingReports(
    const std::vector<::url::Origin>& in_origins, OnCanSendReportingReportsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContextClient::OnCanSendReportingReports", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origins"), in_origins,
                        "<value of type const std::vector<::url::Origin>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnCanSendReportingReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnCanSendReportingReports_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->origins)::BaseType>
      origins_fragment(params.message());
  const mojo::internal::ContainerValidateParams origins_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
      in_origins, origins_fragment, &origins_validate_params);
  params->origins.Set(
      origins_fragment.is_null() ? nullptr : origins_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origins.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origins in NetworkContextClient.OnCanSendReportingReports request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnCanSendReportingReports");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContextClient_OnCanSendReportingReports_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextClientProxy::OnCanSendDomainReliabilityUpload(
    const ::url::Origin& in_origin, OnCanSendDomainReliabilityUploadCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContextClient::OnCanSendDomainReliabilityUpload", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContextClient.OnCanSendDomainReliabilityUpload request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnCanSendDomainReliabilityUpload");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextClientProxy::OnGenerateHttpNegotiateAuthToken(
    const std::string& in_server_auth_token, bool in_can_delegate, const std::string& in_auth_negotiate_android_account_type, const std::string& in_spn, OnGenerateHttpNegotiateAuthTokenCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContextClient::OnGenerateHttpNegotiateAuthToken", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("server_auth_token"), in_server_auth_token,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("can_delegate"), in_can_delegate,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auth_negotiate_android_account_type"), in_auth_negotiate_android_account_type,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("spn"), in_spn,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->server_auth_token)::BaseType> server_auth_token_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_server_auth_token, server_auth_token_fragment);
  params->server_auth_token.Set(
      server_auth_token_fragment.is_null() ? nullptr : server_auth_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->server_auth_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null server_auth_token in NetworkContextClient.OnGenerateHttpNegotiateAuthToken request");
  params->can_delegate = in_can_delegate;
  mojo::internal::MessageFragment<
      typename decltype(params->auth_negotiate_android_account_type)::BaseType> auth_negotiate_android_account_type_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_auth_negotiate_android_account_type, auth_negotiate_android_account_type_fragment);
  params->auth_negotiate_android_account_type.Set(
      auth_negotiate_android_account_type_fragment.is_null() ? nullptr : auth_negotiate_android_account_type_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->auth_negotiate_android_account_type.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null auth_negotiate_android_account_type in NetworkContextClient.OnGenerateHttpNegotiateAuthToken request");
  mojo::internal::MessageFragment<
      typename decltype(params->spn)::BaseType> spn_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_spn, spn_fragment);
  params->spn.Set(
      spn_fragment.is_null() ? nullptr : spn_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->spn.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null spn in NetworkContextClient.OnGenerateHttpNegotiateAuthToken request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnGenerateHttpNegotiateAuthToken");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextClientProxy::OnTrustTokenIssuanceDivertedToSystem(
    ::network::mojom::FulfillTrustTokenIssuanceRequestPtr in_request, OnTrustTokenIssuanceDivertedToSystemCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request"), in_request,
                        "<value of type ::network::mojom::FulfillTrustTokenIssuanceRequestPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->request)::BaseType> request_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::FulfillTrustTokenIssuanceRequestDataView>(
      in_request, request_fragment);
  params->request.Set(
      request_fragment.is_null() ? nullptr : request_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->request.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null request in NetworkContextClient.OnTrustTokenIssuanceDivertedToSystem request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnTrustTokenIssuanceDivertedToSystem");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextClientProxy::OnCanSendSCTAuditingReport(
    OnCanSendSCTAuditingReportCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContextClient::OnCanSendSCTAuditingReport");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnCanSendSCTAuditingReport_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnCanSendSCTAuditingReport");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextClientProxy::OnNewSCTAuditingReportSent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContextClient::OnNewSCTAuditingReportSent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnNewSCTAuditingReportSent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnNewSCTAuditingReportSent_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnNewSCTAuditingReportSent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class NetworkContextClient_OnFileUploadRequested_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContextClient::OnFileUploadRequestedCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContextClient_OnFileUploadRequested_ProxyToResponder> proxy(
        new NetworkContextClient_OnFileUploadRequested_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContextClient_OnFileUploadRequested_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContextClient_OnFileUploadRequested_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContextClient_OnFileUploadRequested_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContextClient::OnFileUploadRequestedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_net_error, std::vector<::base::File> in_files);
};

bool NetworkContextClient_OnFileUploadRequested_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContextClient_OnFileUploadRequested_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContextClient_OnFileUploadRequested_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_net_error{};
  std::vector<::base::File> p_files{};
  NetworkContextClient_OnFileUploadRequested_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_net_error = input_data_view.net_error();
  if (success && !input_data_view.ReadFiles(&p_files))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContextClient::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_net_error), 
std::move(p_files));
  return true;
}

void NetworkContextClient_OnFileUploadRequested_ProxyToResponder::Run(
    int32_t in_net_error, std::vector<::base::File> in_files) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContextClient::OnFileUploadRequested", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("net_error"), in_net_error,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("files"), in_files,
                        "<value of type std::vector<::base::File>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnFileUploadRequested_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnFileUploadRequested_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->net_error = in_net_error;
  mojo::internal::MessageFragment<
      typename decltype(params->files)::BaseType>
      files_fragment(params.message());
  const mojo::internal::ContainerValidateParams files_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::ReadOnlyFileDataView>>(
      in_files, files_fragment, &files_validate_params);
  params->files.Set(
      files_fragment.is_null() ? nullptr : files_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->files.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null files in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnFileUploadRequested");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContextClient_OnCanSendReportingReports_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContextClient::OnCanSendReportingReportsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContextClient_OnCanSendReportingReports_ProxyToResponder> proxy(
        new NetworkContextClient_OnCanSendReportingReports_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContextClient_OnCanSendReportingReports_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContextClient_OnCanSendReportingReports_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContextClient_OnCanSendReportingReports_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContextClient::OnCanSendReportingReportsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const std::vector<::url::Origin>& in_origins);
};

bool NetworkContextClient_OnCanSendReportingReports_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContextClient_OnCanSendReportingReports_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContextClient_OnCanSendReportingReports_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<::url::Origin> p_origins{};
  NetworkContextClient_OnCanSendReportingReports_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadOrigins(&p_origins))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContextClient::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_origins));
  return true;
}

void NetworkContextClient_OnCanSendReportingReports_ProxyToResponder::Run(
    const std::vector<::url::Origin>& in_origins) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContextClient::OnCanSendReportingReports", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origins"), in_origins,
                        "<value of type const std::vector<::url::Origin>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnCanSendReportingReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnCanSendReportingReports_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->origins)::BaseType>
      origins_fragment(params.message());
  const mojo::internal::ContainerValidateParams origins_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::url::mojom::OriginDataView>>(
      in_origins, origins_fragment, &origins_validate_params);
  params->origins.Set(
      origins_fragment.is_null() ? nullptr : origins_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origins.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origins in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnCanSendReportingReports");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContextClient::OnCanSendDomainReliabilityUploadCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder> proxy(
        new NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContextClient::OnCanSendDomainReliabilityUploadCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_allowed);
};

bool NetworkContextClient_OnCanSendDomainReliabilityUpload_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_allowed{};
  NetworkContextClient_OnCanSendDomainReliabilityUpload_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_allowed = input_data_view.allowed();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContextClient::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_allowed));
  return true;
}

void NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder::Run(
    bool in_allowed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContextClient::OnCanSendDomainReliabilityUpload", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("allowed"), in_allowed,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->allowed = in_allowed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnCanSendDomainReliabilityUpload");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContextClient::OnGenerateHttpNegotiateAuthTokenCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder> proxy(
        new NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContextClient::OnGenerateHttpNegotiateAuthTokenCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result, const std::string& in_auth_token);
};

bool NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  std::string p_auth_token{};
  NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (success && !input_data_view.ReadAuthToken(&p_auth_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContextClient::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_auth_token));
  return true;
}

void NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder::Run(
    int32_t in_result, const std::string& in_auth_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContextClient::OnGenerateHttpNegotiateAuthToken", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auth_token"), in_auth_token,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;
  mojo::internal::MessageFragment<
      typename decltype(params->auth_token)::BaseType> auth_token_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_auth_token, auth_token_fragment);
  params->auth_token.Set(
      auth_token_fragment.is_null() ? nullptr : auth_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->auth_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null auth_token in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnGenerateHttpNegotiateAuthToken");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContextClient::OnTrustTokenIssuanceDivertedToSystemCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder> proxy(
        new NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContextClient::OnTrustTokenIssuanceDivertedToSystemCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr in_response);
};

bool NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr p_response{};
  NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResponse(&p_response))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContextClient::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_response));
  return true;
}

void NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder::Run(
    ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr in_response) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContextClient::OnTrustTokenIssuanceDivertedToSystem", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("response"), in_response,
                        "<value of type ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->response)::BaseType> response_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::FulfillTrustTokenIssuanceAnswerDataView>(
      in_response, response_fragment);
  params->response.Set(
      response_fragment.is_null() ? nullptr : response_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->response.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null response in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnTrustTokenIssuanceDivertedToSystem");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContextClient::OnCanSendSCTAuditingReportCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder> proxy(
        new NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContextClient::OnCanSendSCTAuditingReportCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_allowed);
};

bool NetworkContextClient_OnCanSendSCTAuditingReport_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContextClient_OnCanSendSCTAuditingReport_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContextClient_OnCanSendSCTAuditingReport_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_allowed{};
  NetworkContextClient_OnCanSendSCTAuditingReport_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_allowed = input_data_view.allowed();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContextClient::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_allowed));
  return true;
}

void NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder::Run(
    bool in_allowed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContextClient::OnCanSendSCTAuditingReport", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("allowed"), in_allowed,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContextClient_OnCanSendSCTAuditingReport_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->allowed = in_allowed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContextClient::Name_);
  message.set_method_name("OnCanSendSCTAuditingReport");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool NetworkContextClientStubDispatch::Accept(
    NetworkContextClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kNetworkContextClient_OnFileUploadRequested_Name: {
      break;
    }
    case internal::kNetworkContextClient_OnCanSendReportingReports_Name: {
      break;
    }
    case internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name: {
      break;
    }
    case internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name: {
      break;
    }
    case internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name: {
      break;
    }
    case internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name: {
      break;
    }
    case internal::kNetworkContextClient_OnNewSCTAuditingReportSent_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContextClient_OnNewSCTAuditingReportSent_Params_Data* params =
          reinterpret_cast<internal::NetworkContextClient_OnNewSCTAuditingReportSent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      NetworkContextClient_OnNewSCTAuditingReportSent_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnNewSCTAuditingReportSent();
      return true;
    }
  }
  return false;
}

// static
bool NetworkContextClientStubDispatch::AcceptWithResponder(
    NetworkContextClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kNetworkContextClient_OnFileUploadRequested_Name: {

      internal::NetworkContextClient_OnFileUploadRequested_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContextClient_OnFileUploadRequested_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      int32_t p_process_id{};
      bool p_async{};
      std::vector<::base::FilePath> p_file_paths{};
      ::GURL p_destination_url{};
      NetworkContextClient_OnFileUploadRequested_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_process_id = input_data_view.process_id();
      if (success)
        p_async = input_data_view.async();
      if (success && !input_data_view.ReadFilePaths(&p_file_paths))
        success = false;
      if (success && !input_data_view.ReadDestinationUrl(&p_destination_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 0, false);
        return false;
      }
      NetworkContextClient::OnFileUploadRequestedCallback callback =
          NetworkContextClient_OnFileUploadRequested_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnFileUploadRequested(
std::move(p_process_id), 
std::move(p_async), 
std::move(p_file_paths), 
std::move(p_destination_url), std::move(callback));
      return true;
    }
    case internal::kNetworkContextClient_OnCanSendReportingReports_Name: {

      internal::NetworkContextClient_OnCanSendReportingReports_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContextClient_OnCanSendReportingReports_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<::url::Origin> p_origins{};
      NetworkContextClient_OnCanSendReportingReports_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOrigins(&p_origins))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 1, false);
        return false;
      }
      NetworkContextClient::OnCanSendReportingReportsCallback callback =
          NetworkContextClient_OnCanSendReportingReports_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCanSendReportingReports(
std::move(p_origins), std::move(callback));
      return true;
    }
    case internal::kNetworkContextClient_OnCanSendDomainReliabilityUpload_Name: {

      internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::url::Origin p_origin{};
      NetworkContextClient_OnCanSendDomainReliabilityUpload_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 2, false);
        return false;
      }
      NetworkContextClient::OnCanSendDomainReliabilityUploadCallback callback =
          NetworkContextClient_OnCanSendDomainReliabilityUpload_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCanSendDomainReliabilityUpload(
std::move(p_origin), std::move(callback));
      return true;
    }
    case internal::kNetworkContextClient_OnGenerateHttpNegotiateAuthToken_Name: {

      internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_server_auth_token{};
      bool p_can_delegate{};
      std::string p_auth_negotiate_android_account_type{};
      std::string p_spn{};
      NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadServerAuthToken(&p_server_auth_token))
        success = false;
      if (success)
        p_can_delegate = input_data_view.can_delegate();
      if (success && !input_data_view.ReadAuthNegotiateAndroidAccountType(&p_auth_negotiate_android_account_type))
        success = false;
      if (success && !input_data_view.ReadSpn(&p_spn))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 3, false);
        return false;
      }
      NetworkContextClient::OnGenerateHttpNegotiateAuthTokenCallback callback =
          NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnGenerateHttpNegotiateAuthToken(
std::move(p_server_auth_token), 
std::move(p_can_delegate), 
std::move(p_auth_negotiate_android_account_type), 
std::move(p_spn), std::move(callback));
      return true;
    }
    case internal::kNetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Name: {

      internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::network::mojom::FulfillTrustTokenIssuanceRequestPtr p_request{};
      NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRequest(&p_request))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 4, false);
        return false;
      }
      NetworkContextClient::OnTrustTokenIssuanceDivertedToSystemCallback callback =
          NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnTrustTokenIssuanceDivertedToSystem(
std::move(p_request), std::move(callback));
      return true;
    }
    case internal::kNetworkContextClient_OnCanSendSCTAuditingReport_Name: {

      internal::NetworkContextClient_OnCanSendSCTAuditingReport_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContextClient_OnCanSendSCTAuditingReport_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContextClient_OnCanSendSCTAuditingReport_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContextClient::Name_, 5, false);
        return false;
      }
      NetworkContextClient::OnCanSendSCTAuditingReportCallback callback =
          NetworkContextClient_OnCanSendSCTAuditingReport_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCanSendSCTAuditingReport(std::move(callback));
      return true;
    }
    case internal::kNetworkContextClient_OnNewSCTAuditingReportSent_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kNetworkContextClientValidationInfo[] = {
    {&internal::NetworkContextClient_OnFileUploadRequested_Params_Data::Validate,
     &internal::NetworkContextClient_OnFileUploadRequested_ResponseParams_Data::Validate},
    {&internal::NetworkContextClient_OnCanSendReportingReports_Params_Data::Validate,
     &internal::NetworkContextClient_OnCanSendReportingReports_ResponseParams_Data::Validate},
    {&internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_Params_Data::Validate,
     &internal::NetworkContextClient_OnCanSendDomainReliabilityUpload_ResponseParams_Data::Validate},
    {&internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_Params_Data::Validate,
     &internal::NetworkContextClient_OnGenerateHttpNegotiateAuthToken_ResponseParams_Data::Validate},
    {&internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_Params_Data::Validate,
     &internal::NetworkContextClient_OnTrustTokenIssuanceDivertedToSystem_ResponseParams_Data::Validate},
    {&internal::NetworkContextClient_OnCanSendSCTAuditingReport_Params_Data::Validate,
     &internal::NetworkContextClient_OnCanSendSCTAuditingReport_ResponseParams_Data::Validate},
    {&internal::NetworkContextClient_OnNewSCTAuditingReportSent_Params_Data::Validate,
     nullptr /* no response */},
};

bool NetworkContextClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkContextClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kNetworkContextClientValidationInfo);
}

bool NetworkContextClientResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkContextClient::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kNetworkContextClientValidationInfo);
}
const char NetworkContext::Name_[] = "network.mojom.NetworkContext";

NetworkContext::IPCStableHashFunction NetworkContext::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kNetworkContext_SetClient_Name: {
      return &NetworkContext::SetClient_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateURLLoaderFactory_Name: {
      return &NetworkContext::CreateURLLoaderFactory_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ResetURLLoaderFactories_Name: {
      return &NetworkContext::ResetURLLoaderFactories_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_GetCookieManager_Name: {
      return &NetworkContext::GetCookieManager_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_GetRestrictedCookieManager_Name: {
      return &NetworkContext::GetRestrictedCookieManager_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_GetTrustTokenQueryAnswerer_Name: {
      return &NetworkContext::GetTrustTokenQueryAnswerer_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearTrustTokenData_Name: {
      return &NetworkContext::ClearTrustTokenData_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_GetStoredTrustTokenCounts_Name: {
      return &NetworkContext::GetStoredTrustTokenCounts_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_DeleteStoredTrustTokens_Name: {
      return &NetworkContext::DeleteStoredTrustTokens_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetBlockTrustTokens_Name: {
      return &NetworkContext::SetBlockTrustTokens_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearNetworkingHistoryBetween_Name: {
      return &NetworkContext::ClearNetworkingHistoryBetween_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearHttpCache_Name: {
      return &NetworkContext::ClearHttpCache_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ComputeHttpCacheSize_Name: {
      return &NetworkContext::ComputeHttpCacheSize_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_NotifyExternalCacheHit_Name: {
      return &NetworkContext::NotifyExternalCacheHit_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearHostCache_Name: {
      return &NetworkContext::ClearHostCache_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearHttpAuthCache_Name: {
      return &NetworkContext::ClearHttpAuthCache_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearReportingCacheReports_Name: {
      return &NetworkContext::ClearReportingCacheReports_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearReportingCacheClients_Name: {
      return &NetworkContext::ClearReportingCacheClients_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearNetworkErrorLogging_Name: {
      return &NetworkContext::ClearNetworkErrorLogging_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearDomainReliability_Name: {
      return &NetworkContext::ClearDomainReliability_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetDocumentReportingEndpoints_Name: {
      return &NetworkContext::SetDocumentReportingEndpoints_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SendReportsAndRemoveSource_Name: {
      return &NetworkContext::SendReportsAndRemoveSource_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_QueueReport_Name: {
      return &NetworkContext::QueueReport_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_QueueSignedExchangeReport_Name: {
      return &NetworkContext::QueueSignedExchangeReport_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CloseAllConnections_Name: {
      return &NetworkContext::CloseAllConnections_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CloseIdleConnections_Name: {
      return &NetworkContext::CloseIdleConnections_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetNetworkConditions_Name: {
      return &NetworkContext::SetNetworkConditions_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetAcceptLanguage_Name: {
      return &NetworkContext::SetAcceptLanguage_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetEnableReferrers_Name: {
      return &NetworkContext::SetEnableReferrers_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetCTPolicy_Name: {
      return &NetworkContext::SetCTPolicy_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_AddExpectCT_Name: {
      return &NetworkContext::AddExpectCT_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetExpectCTTestReport_Name: {
      return &NetworkContext::SetExpectCTTestReport_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_GetExpectCTState_Name: {
      return &NetworkContext::GetExpectCTState_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateUDPSocket_Name: {
      return &NetworkContext::CreateUDPSocket_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateTCPServerSocket_Name: {
      return &NetworkContext::CreateTCPServerSocket_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateTCPConnectedSocket_Name: {
      return &NetworkContext::CreateTCPConnectedSocket_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateTCPBoundSocket_Name: {
      return &NetworkContext::CreateTCPBoundSocket_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateProxyResolvingSocketFactory_Name: {
      return &NetworkContext::CreateProxyResolvingSocketFactory_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_LookUpProxyForURL_Name: {
      return &NetworkContext::LookUpProxyForURL_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ForceReloadProxyConfig_Name: {
      return &NetworkContext::ForceReloadProxyConfig_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ClearBadProxiesCache_Name: {
      return &NetworkContext::ClearBadProxiesCache_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateWebSocket_Name: {
      return &NetworkContext::CreateWebSocket_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateWebTransport_Name: {
      return &NetworkContext::CreateWebTransport_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateNetLogExporter_Name: {
      return &NetworkContext::CreateNetLogExporter_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_PreconnectSockets_Name: {
      return &NetworkContext::PreconnectSockets_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateP2PSocketManager_Name: {
      return &NetworkContext::CreateP2PSocketManager_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateMdnsResponder_Name: {
      return &NetworkContext::CreateMdnsResponder_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ResolveHost_Name: {
      return &NetworkContext::ResolveHost_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_CreateHostResolver_Name: {
      return &NetworkContext::CreateHostResolver_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_VerifyCertForSignedExchange_Name: {
      return &NetworkContext::VerifyCertForSignedExchange_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_AddHSTS_Name: {
      return &NetworkContext::AddHSTS_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_IsHSTSActiveForHost_Name: {
      return &NetworkContext::IsHSTSActiveForHost_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_GetHSTSState_Name: {
      return &NetworkContext::GetHSTSState_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name: {
      return &NetworkContext::SetCorsOriginAccessListsForOrigin_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_DeleteDynamicDataForHost_Name: {
      return &NetworkContext::DeleteDynamicDataForHost_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Name: {
      return &NetworkContext::SetSplitAuthCacheByNetworkIsolationKey_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name: {
      return &NetworkContext::SaveHttpAuthCacheProxyEntries_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name: {
      return &NetworkContext::LoadHttpAuthCacheProxyEntries_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_AddAuthCacheEntry_Name: {
      return &NetworkContext::AddAuthCacheEntry_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetCorsNonWildcardRequestHeadersSupport_Name: {
      return &NetworkContext::SetCorsNonWildcardRequestHeadersSupport_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_LookupServerBasicAuthCredentials_Name: {
      return &NetworkContext::LookupServerBasicAuthCredentials_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name: {
      return &NetworkContext::EnableStaticKeyPinningForTesting_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_VerifyCertificateForTesting_Name: {
      return &NetworkContext::VerifyCertificateForTesting_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name: {
      return &NetworkContext::AddDomainReliabilityContextForTesting_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name: {
      return &NetworkContext::ForceDomainReliabilityUploadsForTesting_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetCTLogListAlwaysTimelyForTesting_Name: {
      return &NetworkContext::SetCTLogListAlwaysTimelyForTesting_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_SetSCTAuditingMode_Name: {
      return &NetworkContext::SetSCTAuditingMode_Sym::IPCStableHash;
    }
    case internal::kNetworkContext_AddReportingApiObserver_Name: {
      return &NetworkContext::AddReportingApiObserver_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* NetworkContext::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kNetworkContext_SetClient_Name:
            return "Receive network::mojom::NetworkContext::SetClient";
      case internal::kNetworkContext_CreateURLLoaderFactory_Name:
            return "Receive network::mojom::NetworkContext::CreateURLLoaderFactory";
      case internal::kNetworkContext_ResetURLLoaderFactories_Name:
            return "Receive network::mojom::NetworkContext::ResetURLLoaderFactories";
      case internal::kNetworkContext_GetCookieManager_Name:
            return "Receive network::mojom::NetworkContext::GetCookieManager";
      case internal::kNetworkContext_GetRestrictedCookieManager_Name:
            return "Receive network::mojom::NetworkContext::GetRestrictedCookieManager";
      case internal::kNetworkContext_GetTrustTokenQueryAnswerer_Name:
            return "Receive network::mojom::NetworkContext::GetTrustTokenQueryAnswerer";
      case internal::kNetworkContext_ClearTrustTokenData_Name:
            return "Receive network::mojom::NetworkContext::ClearTrustTokenData";
      case internal::kNetworkContext_GetStoredTrustTokenCounts_Name:
            return "Receive network::mojom::NetworkContext::GetStoredTrustTokenCounts";
      case internal::kNetworkContext_DeleteStoredTrustTokens_Name:
            return "Receive network::mojom::NetworkContext::DeleteStoredTrustTokens";
      case internal::kNetworkContext_SetBlockTrustTokens_Name:
            return "Receive network::mojom::NetworkContext::SetBlockTrustTokens";
      case internal::kNetworkContext_ClearNetworkingHistoryBetween_Name:
            return "Receive network::mojom::NetworkContext::ClearNetworkingHistoryBetween";
      case internal::kNetworkContext_ClearHttpCache_Name:
            return "Receive network::mojom::NetworkContext::ClearHttpCache";
      case internal::kNetworkContext_ComputeHttpCacheSize_Name:
            return "Receive network::mojom::NetworkContext::ComputeHttpCacheSize";
      case internal::kNetworkContext_NotifyExternalCacheHit_Name:
            return "Receive network::mojom::NetworkContext::NotifyExternalCacheHit";
      case internal::kNetworkContext_ClearHostCache_Name:
            return "Receive network::mojom::NetworkContext::ClearHostCache";
      case internal::kNetworkContext_ClearHttpAuthCache_Name:
            return "Receive network::mojom::NetworkContext::ClearHttpAuthCache";
      case internal::kNetworkContext_ClearReportingCacheReports_Name:
            return "Receive network::mojom::NetworkContext::ClearReportingCacheReports";
      case internal::kNetworkContext_ClearReportingCacheClients_Name:
            return "Receive network::mojom::NetworkContext::ClearReportingCacheClients";
      case internal::kNetworkContext_ClearNetworkErrorLogging_Name:
            return "Receive network::mojom::NetworkContext::ClearNetworkErrorLogging";
      case internal::kNetworkContext_ClearDomainReliability_Name:
            return "Receive network::mojom::NetworkContext::ClearDomainReliability";
      case internal::kNetworkContext_SetDocumentReportingEndpoints_Name:
            return "Receive network::mojom::NetworkContext::SetDocumentReportingEndpoints";
      case internal::kNetworkContext_SendReportsAndRemoveSource_Name:
            return "Receive network::mojom::NetworkContext::SendReportsAndRemoveSource";
      case internal::kNetworkContext_QueueReport_Name:
            return "Receive network::mojom::NetworkContext::QueueReport";
      case internal::kNetworkContext_QueueSignedExchangeReport_Name:
            return "Receive network::mojom::NetworkContext::QueueSignedExchangeReport";
      case internal::kNetworkContext_CloseAllConnections_Name:
            return "Receive network::mojom::NetworkContext::CloseAllConnections";
      case internal::kNetworkContext_CloseIdleConnections_Name:
            return "Receive network::mojom::NetworkContext::CloseIdleConnections";
      case internal::kNetworkContext_SetNetworkConditions_Name:
            return "Receive network::mojom::NetworkContext::SetNetworkConditions";
      case internal::kNetworkContext_SetAcceptLanguage_Name:
            return "Receive network::mojom::NetworkContext::SetAcceptLanguage";
      case internal::kNetworkContext_SetEnableReferrers_Name:
            return "Receive network::mojom::NetworkContext::SetEnableReferrers";
      case internal::kNetworkContext_SetCTPolicy_Name:
            return "Receive network::mojom::NetworkContext::SetCTPolicy";
      case internal::kNetworkContext_AddExpectCT_Name:
            return "Receive network::mojom::NetworkContext::AddExpectCT";
      case internal::kNetworkContext_SetExpectCTTestReport_Name:
            return "Receive network::mojom::NetworkContext::SetExpectCTTestReport";
      case internal::kNetworkContext_GetExpectCTState_Name:
            return "Receive network::mojom::NetworkContext::GetExpectCTState";
      case internal::kNetworkContext_CreateUDPSocket_Name:
            return "Receive network::mojom::NetworkContext::CreateUDPSocket";
      case internal::kNetworkContext_CreateTCPServerSocket_Name:
            return "Receive network::mojom::NetworkContext::CreateTCPServerSocket";
      case internal::kNetworkContext_CreateTCPConnectedSocket_Name:
            return "Receive network::mojom::NetworkContext::CreateTCPConnectedSocket";
      case internal::kNetworkContext_CreateTCPBoundSocket_Name:
            return "Receive network::mojom::NetworkContext::CreateTCPBoundSocket";
      case internal::kNetworkContext_CreateProxyResolvingSocketFactory_Name:
            return "Receive network::mojom::NetworkContext::CreateProxyResolvingSocketFactory";
      case internal::kNetworkContext_LookUpProxyForURL_Name:
            return "Receive network::mojom::NetworkContext::LookUpProxyForURL";
      case internal::kNetworkContext_ForceReloadProxyConfig_Name:
            return "Receive network::mojom::NetworkContext::ForceReloadProxyConfig";
      case internal::kNetworkContext_ClearBadProxiesCache_Name:
            return "Receive network::mojom::NetworkContext::ClearBadProxiesCache";
      case internal::kNetworkContext_CreateWebSocket_Name:
            return "Receive network::mojom::NetworkContext::CreateWebSocket";
      case internal::kNetworkContext_CreateWebTransport_Name:
            return "Receive network::mojom::NetworkContext::CreateWebTransport";
      case internal::kNetworkContext_CreateNetLogExporter_Name:
            return "Receive network::mojom::NetworkContext::CreateNetLogExporter";
      case internal::kNetworkContext_PreconnectSockets_Name:
            return "Receive network::mojom::NetworkContext::PreconnectSockets";
      case internal::kNetworkContext_CreateP2PSocketManager_Name:
            return "Receive network::mojom::NetworkContext::CreateP2PSocketManager";
      case internal::kNetworkContext_CreateMdnsResponder_Name:
            return "Receive network::mojom::NetworkContext::CreateMdnsResponder";
      case internal::kNetworkContext_ResolveHost_Name:
            return "Receive network::mojom::NetworkContext::ResolveHost";
      case internal::kNetworkContext_CreateHostResolver_Name:
            return "Receive network::mojom::NetworkContext::CreateHostResolver";
      case internal::kNetworkContext_VerifyCertForSignedExchange_Name:
            return "Receive network::mojom::NetworkContext::VerifyCertForSignedExchange";
      case internal::kNetworkContext_AddHSTS_Name:
            return "Receive network::mojom::NetworkContext::AddHSTS";
      case internal::kNetworkContext_IsHSTSActiveForHost_Name:
            return "Receive network::mojom::NetworkContext::IsHSTSActiveForHost";
      case internal::kNetworkContext_GetHSTSState_Name:
            return "Receive network::mojom::NetworkContext::GetHSTSState";
      case internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name:
            return "Receive network::mojom::NetworkContext::SetCorsOriginAccessListsForOrigin";
      case internal::kNetworkContext_DeleteDynamicDataForHost_Name:
            return "Receive network::mojom::NetworkContext::DeleteDynamicDataForHost";
      case internal::kNetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Name:
            return "Receive network::mojom::NetworkContext::SetSplitAuthCacheByNetworkIsolationKey";
      case internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name:
            return "Receive network::mojom::NetworkContext::SaveHttpAuthCacheProxyEntries";
      case internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name:
            return "Receive network::mojom::NetworkContext::LoadHttpAuthCacheProxyEntries";
      case internal::kNetworkContext_AddAuthCacheEntry_Name:
            return "Receive network::mojom::NetworkContext::AddAuthCacheEntry";
      case internal::kNetworkContext_SetCorsNonWildcardRequestHeadersSupport_Name:
            return "Receive network::mojom::NetworkContext::SetCorsNonWildcardRequestHeadersSupport";
      case internal::kNetworkContext_LookupServerBasicAuthCredentials_Name:
            return "Receive network::mojom::NetworkContext::LookupServerBasicAuthCredentials";
      case internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name:
            return "Receive network::mojom::NetworkContext::EnableStaticKeyPinningForTesting";
      case internal::kNetworkContext_VerifyCertificateForTesting_Name:
            return "Receive network::mojom::NetworkContext::VerifyCertificateForTesting";
      case internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name:
            return "Receive network::mojom::NetworkContext::AddDomainReliabilityContextForTesting";
      case internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name:
            return "Receive network::mojom::NetworkContext::ForceDomainReliabilityUploadsForTesting";
      case internal::kNetworkContext_SetCTLogListAlwaysTimelyForTesting_Name:
            return "Receive network::mojom::NetworkContext::SetCTLogListAlwaysTimelyForTesting";
      case internal::kNetworkContext_SetSCTAuditingMode_Name:
            return "Receive network::mojom::NetworkContext::SetSCTAuditingMode";
      case internal::kNetworkContext_AddReportingApiObserver_Name:
            return "Receive network::mojom::NetworkContext::AddReportingApiObserver";
    }
  } else {
    switch (message.name()) {
      case internal::kNetworkContext_SetClient_Name:
            return "Receive reply network::mojom::NetworkContext::SetClient";
      case internal::kNetworkContext_CreateURLLoaderFactory_Name:
            return "Receive reply network::mojom::NetworkContext::CreateURLLoaderFactory";
      case internal::kNetworkContext_ResetURLLoaderFactories_Name:
            return "Receive reply network::mojom::NetworkContext::ResetURLLoaderFactories";
      case internal::kNetworkContext_GetCookieManager_Name:
            return "Receive reply network::mojom::NetworkContext::GetCookieManager";
      case internal::kNetworkContext_GetRestrictedCookieManager_Name:
            return "Receive reply network::mojom::NetworkContext::GetRestrictedCookieManager";
      case internal::kNetworkContext_GetTrustTokenQueryAnswerer_Name:
            return "Receive reply network::mojom::NetworkContext::GetTrustTokenQueryAnswerer";
      case internal::kNetworkContext_ClearTrustTokenData_Name:
            return "Receive reply network::mojom::NetworkContext::ClearTrustTokenData";
      case internal::kNetworkContext_GetStoredTrustTokenCounts_Name:
            return "Receive reply network::mojom::NetworkContext::GetStoredTrustTokenCounts";
      case internal::kNetworkContext_DeleteStoredTrustTokens_Name:
            return "Receive reply network::mojom::NetworkContext::DeleteStoredTrustTokens";
      case internal::kNetworkContext_SetBlockTrustTokens_Name:
            return "Receive reply network::mojom::NetworkContext::SetBlockTrustTokens";
      case internal::kNetworkContext_ClearNetworkingHistoryBetween_Name:
            return "Receive reply network::mojom::NetworkContext::ClearNetworkingHistoryBetween";
      case internal::kNetworkContext_ClearHttpCache_Name:
            return "Receive reply network::mojom::NetworkContext::ClearHttpCache";
      case internal::kNetworkContext_ComputeHttpCacheSize_Name:
            return "Receive reply network::mojom::NetworkContext::ComputeHttpCacheSize";
      case internal::kNetworkContext_NotifyExternalCacheHit_Name:
            return "Receive reply network::mojom::NetworkContext::NotifyExternalCacheHit";
      case internal::kNetworkContext_ClearHostCache_Name:
            return "Receive reply network::mojom::NetworkContext::ClearHostCache";
      case internal::kNetworkContext_ClearHttpAuthCache_Name:
            return "Receive reply network::mojom::NetworkContext::ClearHttpAuthCache";
      case internal::kNetworkContext_ClearReportingCacheReports_Name:
            return "Receive reply network::mojom::NetworkContext::ClearReportingCacheReports";
      case internal::kNetworkContext_ClearReportingCacheClients_Name:
            return "Receive reply network::mojom::NetworkContext::ClearReportingCacheClients";
      case internal::kNetworkContext_ClearNetworkErrorLogging_Name:
            return "Receive reply network::mojom::NetworkContext::ClearNetworkErrorLogging";
      case internal::kNetworkContext_ClearDomainReliability_Name:
            return "Receive reply network::mojom::NetworkContext::ClearDomainReliability";
      case internal::kNetworkContext_SetDocumentReportingEndpoints_Name:
            return "Receive reply network::mojom::NetworkContext::SetDocumentReportingEndpoints";
      case internal::kNetworkContext_SendReportsAndRemoveSource_Name:
            return "Receive reply network::mojom::NetworkContext::SendReportsAndRemoveSource";
      case internal::kNetworkContext_QueueReport_Name:
            return "Receive reply network::mojom::NetworkContext::QueueReport";
      case internal::kNetworkContext_QueueSignedExchangeReport_Name:
            return "Receive reply network::mojom::NetworkContext::QueueSignedExchangeReport";
      case internal::kNetworkContext_CloseAllConnections_Name:
            return "Receive reply network::mojom::NetworkContext::CloseAllConnections";
      case internal::kNetworkContext_CloseIdleConnections_Name:
            return "Receive reply network::mojom::NetworkContext::CloseIdleConnections";
      case internal::kNetworkContext_SetNetworkConditions_Name:
            return "Receive reply network::mojom::NetworkContext::SetNetworkConditions";
      case internal::kNetworkContext_SetAcceptLanguage_Name:
            return "Receive reply network::mojom::NetworkContext::SetAcceptLanguage";
      case internal::kNetworkContext_SetEnableReferrers_Name:
            return "Receive reply network::mojom::NetworkContext::SetEnableReferrers";
      case internal::kNetworkContext_SetCTPolicy_Name:
            return "Receive reply network::mojom::NetworkContext::SetCTPolicy";
      case internal::kNetworkContext_AddExpectCT_Name:
            return "Receive reply network::mojom::NetworkContext::AddExpectCT";
      case internal::kNetworkContext_SetExpectCTTestReport_Name:
            return "Receive reply network::mojom::NetworkContext::SetExpectCTTestReport";
      case internal::kNetworkContext_GetExpectCTState_Name:
            return "Receive reply network::mojom::NetworkContext::GetExpectCTState";
      case internal::kNetworkContext_CreateUDPSocket_Name:
            return "Receive reply network::mojom::NetworkContext::CreateUDPSocket";
      case internal::kNetworkContext_CreateTCPServerSocket_Name:
            return "Receive reply network::mojom::NetworkContext::CreateTCPServerSocket";
      case internal::kNetworkContext_CreateTCPConnectedSocket_Name:
            return "Receive reply network::mojom::NetworkContext::CreateTCPConnectedSocket";
      case internal::kNetworkContext_CreateTCPBoundSocket_Name:
            return "Receive reply network::mojom::NetworkContext::CreateTCPBoundSocket";
      case internal::kNetworkContext_CreateProxyResolvingSocketFactory_Name:
            return "Receive reply network::mojom::NetworkContext::CreateProxyResolvingSocketFactory";
      case internal::kNetworkContext_LookUpProxyForURL_Name:
            return "Receive reply network::mojom::NetworkContext::LookUpProxyForURL";
      case internal::kNetworkContext_ForceReloadProxyConfig_Name:
            return "Receive reply network::mojom::NetworkContext::ForceReloadProxyConfig";
      case internal::kNetworkContext_ClearBadProxiesCache_Name:
            return "Receive reply network::mojom::NetworkContext::ClearBadProxiesCache";
      case internal::kNetworkContext_CreateWebSocket_Name:
            return "Receive reply network::mojom::NetworkContext::CreateWebSocket";
      case internal::kNetworkContext_CreateWebTransport_Name:
            return "Receive reply network::mojom::NetworkContext::CreateWebTransport";
      case internal::kNetworkContext_CreateNetLogExporter_Name:
            return "Receive reply network::mojom::NetworkContext::CreateNetLogExporter";
      case internal::kNetworkContext_PreconnectSockets_Name:
            return "Receive reply network::mojom::NetworkContext::PreconnectSockets";
      case internal::kNetworkContext_CreateP2PSocketManager_Name:
            return "Receive reply network::mojom::NetworkContext::CreateP2PSocketManager";
      case internal::kNetworkContext_CreateMdnsResponder_Name:
            return "Receive reply network::mojom::NetworkContext::CreateMdnsResponder";
      case internal::kNetworkContext_ResolveHost_Name:
            return "Receive reply network::mojom::NetworkContext::ResolveHost";
      case internal::kNetworkContext_CreateHostResolver_Name:
            return "Receive reply network::mojom::NetworkContext::CreateHostResolver";
      case internal::kNetworkContext_VerifyCertForSignedExchange_Name:
            return "Receive reply network::mojom::NetworkContext::VerifyCertForSignedExchange";
      case internal::kNetworkContext_AddHSTS_Name:
            return "Receive reply network::mojom::NetworkContext::AddHSTS";
      case internal::kNetworkContext_IsHSTSActiveForHost_Name:
            return "Receive reply network::mojom::NetworkContext::IsHSTSActiveForHost";
      case internal::kNetworkContext_GetHSTSState_Name:
            return "Receive reply network::mojom::NetworkContext::GetHSTSState";
      case internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name:
            return "Receive reply network::mojom::NetworkContext::SetCorsOriginAccessListsForOrigin";
      case internal::kNetworkContext_DeleteDynamicDataForHost_Name:
            return "Receive reply network::mojom::NetworkContext::DeleteDynamicDataForHost";
      case internal::kNetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Name:
            return "Receive reply network::mojom::NetworkContext::SetSplitAuthCacheByNetworkIsolationKey";
      case internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name:
            return "Receive reply network::mojom::NetworkContext::SaveHttpAuthCacheProxyEntries";
      case internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name:
            return "Receive reply network::mojom::NetworkContext::LoadHttpAuthCacheProxyEntries";
      case internal::kNetworkContext_AddAuthCacheEntry_Name:
            return "Receive reply network::mojom::NetworkContext::AddAuthCacheEntry";
      case internal::kNetworkContext_SetCorsNonWildcardRequestHeadersSupport_Name:
            return "Receive reply network::mojom::NetworkContext::SetCorsNonWildcardRequestHeadersSupport";
      case internal::kNetworkContext_LookupServerBasicAuthCredentials_Name:
            return "Receive reply network::mojom::NetworkContext::LookupServerBasicAuthCredentials";
      case internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name:
            return "Receive reply network::mojom::NetworkContext::EnableStaticKeyPinningForTesting";
      case internal::kNetworkContext_VerifyCertificateForTesting_Name:
            return "Receive reply network::mojom::NetworkContext::VerifyCertificateForTesting";
      case internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name:
            return "Receive reply network::mojom::NetworkContext::AddDomainReliabilityContextForTesting";
      case internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name:
            return "Receive reply network::mojom::NetworkContext::ForceDomainReliabilityUploadsForTesting";
      case internal::kNetworkContext_SetCTLogListAlwaysTimelyForTesting_Name:
            return "Receive reply network::mojom::NetworkContext::SetCTLogListAlwaysTimelyForTesting";
      case internal::kNetworkContext_SetSCTAuditingMode_Name:
            return "Receive reply network::mojom::NetworkContext::SetSCTAuditingMode";
      case internal::kNetworkContext_AddReportingApiObserver_Name:
            return "Receive reply network::mojom::NetworkContext::AddReportingApiObserver";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t NetworkContext::SetClient_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetClient");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateURLLoaderFactory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateURLLoaderFactory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ResetURLLoaderFactories_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ResetURLLoaderFactories");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::GetCookieManager_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::GetCookieManager");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::GetRestrictedCookieManager_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::GetRestrictedCookieManager");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::GetTrustTokenQueryAnswerer_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::GetTrustTokenQueryAnswerer");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearTrustTokenData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearTrustTokenData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::GetStoredTrustTokenCounts_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::GetStoredTrustTokenCounts");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::DeleteStoredTrustTokens_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::DeleteStoredTrustTokens");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetBlockTrustTokens_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetBlockTrustTokens");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearNetworkingHistoryBetween_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearNetworkingHistoryBetween");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearHttpCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearHttpCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ComputeHttpCacheSize_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ComputeHttpCacheSize");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::NotifyExternalCacheHit_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::NotifyExternalCacheHit");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearHostCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearHostCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearHttpAuthCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearHttpAuthCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearReportingCacheReports_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearReportingCacheReports");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearReportingCacheClients_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearReportingCacheClients");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearNetworkErrorLogging_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearNetworkErrorLogging");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearDomainReliability_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearDomainReliability");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetDocumentReportingEndpoints_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetDocumentReportingEndpoints");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SendReportsAndRemoveSource_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SendReportsAndRemoveSource");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::QueueReport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::QueueReport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::QueueSignedExchangeReport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::QueueSignedExchangeReport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CloseAllConnections_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CloseAllConnections");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CloseIdleConnections_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CloseIdleConnections");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetNetworkConditions_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetNetworkConditions");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetAcceptLanguage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetAcceptLanguage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetEnableReferrers_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetEnableReferrers");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetCTPolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetCTPolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::AddExpectCT_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::AddExpectCT");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetExpectCTTestReport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetExpectCTTestReport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::GetExpectCTState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::GetExpectCTState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateUDPSocket_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateUDPSocket");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateTCPServerSocket_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateTCPServerSocket");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateTCPConnectedSocket_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateTCPConnectedSocket");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateTCPBoundSocket_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateTCPBoundSocket");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateProxyResolvingSocketFactory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateProxyResolvingSocketFactory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::LookUpProxyForURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::LookUpProxyForURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ForceReloadProxyConfig_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ForceReloadProxyConfig");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ClearBadProxiesCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ClearBadProxiesCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateWebSocket_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateWebSocket");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateWebTransport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateWebTransport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateNetLogExporter_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateNetLogExporter");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::PreconnectSockets_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::PreconnectSockets");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateP2PSocketManager_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateP2PSocketManager");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateMdnsResponder_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateMdnsResponder");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ResolveHost_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ResolveHost");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::CreateHostResolver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::CreateHostResolver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::VerifyCertForSignedExchange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::VerifyCertForSignedExchange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::AddHSTS_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::AddHSTS");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::IsHSTSActiveForHost_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::IsHSTSActiveForHost");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::GetHSTSState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::GetHSTSState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetCorsOriginAccessListsForOrigin_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetCorsOriginAccessListsForOrigin");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::DeleteDynamicDataForHost_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::DeleteDynamicDataForHost");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetSplitAuthCacheByNetworkIsolationKey_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetSplitAuthCacheByNetworkIsolationKey");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SaveHttpAuthCacheProxyEntries_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SaveHttpAuthCacheProxyEntries");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::LoadHttpAuthCacheProxyEntries_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::LoadHttpAuthCacheProxyEntries");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::AddAuthCacheEntry_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::AddAuthCacheEntry");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetCorsNonWildcardRequestHeadersSupport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetCorsNonWildcardRequestHeadersSupport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::LookupServerBasicAuthCredentials_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::LookupServerBasicAuthCredentials");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::EnableStaticKeyPinningForTesting_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::EnableStaticKeyPinningForTesting");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::VerifyCertificateForTesting_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::VerifyCertificateForTesting");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::AddDomainReliabilityContextForTesting_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::AddDomainReliabilityContextForTesting");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::ForceDomainReliabilityUploadsForTesting_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::ForceDomainReliabilityUploadsForTesting");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetCTLogListAlwaysTimelyForTesting_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetCTLogListAlwaysTimelyForTesting");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::SetSCTAuditingMode_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::SetSCTAuditingMode");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t NetworkContext::AddReportingApiObserver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)network::mojom::NetworkContext::AddReportingApiObserver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)
bool NetworkContext::EnableStaticKeyPinningForTesting() {
  NOTREACHED();
  return false;
}
bool NetworkContext::AddDomainReliabilityContextForTesting(const ::url::Origin& origin, const ::GURL& upload_url) {
  NOTREACHED();
  return false;
}
bool NetworkContext::ForceDomainReliabilityUploadsForTesting() {
  NOTREACHED();
  return false;
}

class NetworkContext_ClearTrustTokenData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearTrustTokenData_ForwardToCallback(
      NetworkContext::ClearTrustTokenDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearTrustTokenData_ForwardToCallback(const NetworkContext_ClearTrustTokenData_ForwardToCallback&) = delete;
  NetworkContext_ClearTrustTokenData_ForwardToCallback& operator=(const NetworkContext_ClearTrustTokenData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearTrustTokenDataCallback callback_;
};

class NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback(
      NetworkContext::GetStoredTrustTokenCountsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback(const NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback&) = delete;
  NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback& operator=(const NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::GetStoredTrustTokenCountsCallback callback_;
};

class NetworkContext_DeleteStoredTrustTokens_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_DeleteStoredTrustTokens_ForwardToCallback(
      NetworkContext::DeleteStoredTrustTokensCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_DeleteStoredTrustTokens_ForwardToCallback(const NetworkContext_DeleteStoredTrustTokens_ForwardToCallback&) = delete;
  NetworkContext_DeleteStoredTrustTokens_ForwardToCallback& operator=(const NetworkContext_DeleteStoredTrustTokens_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::DeleteStoredTrustTokensCallback callback_;
};

class NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback(
      NetworkContext::ClearNetworkingHistoryBetweenCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback(const NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback&) = delete;
  NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback& operator=(const NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearNetworkingHistoryBetweenCallback callback_;
};

class NetworkContext_ClearHttpCache_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearHttpCache_ForwardToCallback(
      NetworkContext::ClearHttpCacheCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearHttpCache_ForwardToCallback(const NetworkContext_ClearHttpCache_ForwardToCallback&) = delete;
  NetworkContext_ClearHttpCache_ForwardToCallback& operator=(const NetworkContext_ClearHttpCache_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearHttpCacheCallback callback_;
};

class NetworkContext_ComputeHttpCacheSize_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ComputeHttpCacheSize_ForwardToCallback(
      NetworkContext::ComputeHttpCacheSizeCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ComputeHttpCacheSize_ForwardToCallback(const NetworkContext_ComputeHttpCacheSize_ForwardToCallback&) = delete;
  NetworkContext_ComputeHttpCacheSize_ForwardToCallback& operator=(const NetworkContext_ComputeHttpCacheSize_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ComputeHttpCacheSizeCallback callback_;
};

class NetworkContext_ClearHostCache_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearHostCache_ForwardToCallback(
      NetworkContext::ClearHostCacheCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearHostCache_ForwardToCallback(const NetworkContext_ClearHostCache_ForwardToCallback&) = delete;
  NetworkContext_ClearHostCache_ForwardToCallback& operator=(const NetworkContext_ClearHostCache_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearHostCacheCallback callback_;
};

class NetworkContext_ClearHttpAuthCache_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearHttpAuthCache_ForwardToCallback(
      NetworkContext::ClearHttpAuthCacheCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearHttpAuthCache_ForwardToCallback(const NetworkContext_ClearHttpAuthCache_ForwardToCallback&) = delete;
  NetworkContext_ClearHttpAuthCache_ForwardToCallback& operator=(const NetworkContext_ClearHttpAuthCache_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearHttpAuthCacheCallback callback_;
};

class NetworkContext_ClearReportingCacheReports_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearReportingCacheReports_ForwardToCallback(
      NetworkContext::ClearReportingCacheReportsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearReportingCacheReports_ForwardToCallback(const NetworkContext_ClearReportingCacheReports_ForwardToCallback&) = delete;
  NetworkContext_ClearReportingCacheReports_ForwardToCallback& operator=(const NetworkContext_ClearReportingCacheReports_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearReportingCacheReportsCallback callback_;
};

class NetworkContext_ClearReportingCacheClients_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearReportingCacheClients_ForwardToCallback(
      NetworkContext::ClearReportingCacheClientsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearReportingCacheClients_ForwardToCallback(const NetworkContext_ClearReportingCacheClients_ForwardToCallback&) = delete;
  NetworkContext_ClearReportingCacheClients_ForwardToCallback& operator=(const NetworkContext_ClearReportingCacheClients_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearReportingCacheClientsCallback callback_;
};

class NetworkContext_ClearNetworkErrorLogging_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearNetworkErrorLogging_ForwardToCallback(
      NetworkContext::ClearNetworkErrorLoggingCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearNetworkErrorLogging_ForwardToCallback(const NetworkContext_ClearNetworkErrorLogging_ForwardToCallback&) = delete;
  NetworkContext_ClearNetworkErrorLogging_ForwardToCallback& operator=(const NetworkContext_ClearNetworkErrorLogging_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearNetworkErrorLoggingCallback callback_;
};

class NetworkContext_ClearDomainReliability_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearDomainReliability_ForwardToCallback(
      NetworkContext::ClearDomainReliabilityCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearDomainReliability_ForwardToCallback(const NetworkContext_ClearDomainReliability_ForwardToCallback&) = delete;
  NetworkContext_ClearDomainReliability_ForwardToCallback& operator=(const NetworkContext_ClearDomainReliability_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearDomainReliabilityCallback callback_;
};

class NetworkContext_CloseAllConnections_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_CloseAllConnections_ForwardToCallback(
      NetworkContext::CloseAllConnectionsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_CloseAllConnections_ForwardToCallback(const NetworkContext_CloseAllConnections_ForwardToCallback&) = delete;
  NetworkContext_CloseAllConnections_ForwardToCallback& operator=(const NetworkContext_CloseAllConnections_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::CloseAllConnectionsCallback callback_;
};

class NetworkContext_CloseIdleConnections_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_CloseIdleConnections_ForwardToCallback(
      NetworkContext::CloseIdleConnectionsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_CloseIdleConnections_ForwardToCallback(const NetworkContext_CloseIdleConnections_ForwardToCallback&) = delete;
  NetworkContext_CloseIdleConnections_ForwardToCallback& operator=(const NetworkContext_CloseIdleConnections_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::CloseIdleConnectionsCallback callback_;
};

class NetworkContext_AddExpectCT_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_AddExpectCT_ForwardToCallback(
      NetworkContext::AddExpectCTCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_AddExpectCT_ForwardToCallback(const NetworkContext_AddExpectCT_ForwardToCallback&) = delete;
  NetworkContext_AddExpectCT_ForwardToCallback& operator=(const NetworkContext_AddExpectCT_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::AddExpectCTCallback callback_;
};

class NetworkContext_SetExpectCTTestReport_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_SetExpectCTTestReport_ForwardToCallback(
      NetworkContext::SetExpectCTTestReportCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_SetExpectCTTestReport_ForwardToCallback(const NetworkContext_SetExpectCTTestReport_ForwardToCallback&) = delete;
  NetworkContext_SetExpectCTTestReport_ForwardToCallback& operator=(const NetworkContext_SetExpectCTTestReport_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::SetExpectCTTestReportCallback callback_;
};

class NetworkContext_GetExpectCTState_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_GetExpectCTState_ForwardToCallback(
      NetworkContext::GetExpectCTStateCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_GetExpectCTState_ForwardToCallback(const NetworkContext_GetExpectCTState_ForwardToCallback&) = delete;
  NetworkContext_GetExpectCTState_ForwardToCallback& operator=(const NetworkContext_GetExpectCTState_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::GetExpectCTStateCallback callback_;
};

class NetworkContext_CreateTCPServerSocket_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_CreateTCPServerSocket_ForwardToCallback(
      NetworkContext::CreateTCPServerSocketCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_CreateTCPServerSocket_ForwardToCallback(const NetworkContext_CreateTCPServerSocket_ForwardToCallback&) = delete;
  NetworkContext_CreateTCPServerSocket_ForwardToCallback& operator=(const NetworkContext_CreateTCPServerSocket_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::CreateTCPServerSocketCallback callback_;
};

class NetworkContext_CreateTCPConnectedSocket_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_CreateTCPConnectedSocket_ForwardToCallback(
      NetworkContext::CreateTCPConnectedSocketCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_CreateTCPConnectedSocket_ForwardToCallback(const NetworkContext_CreateTCPConnectedSocket_ForwardToCallback&) = delete;
  NetworkContext_CreateTCPConnectedSocket_ForwardToCallback& operator=(const NetworkContext_CreateTCPConnectedSocket_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::CreateTCPConnectedSocketCallback callback_;
};

class NetworkContext_CreateTCPBoundSocket_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_CreateTCPBoundSocket_ForwardToCallback(
      NetworkContext::CreateTCPBoundSocketCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_CreateTCPBoundSocket_ForwardToCallback(const NetworkContext_CreateTCPBoundSocket_ForwardToCallback&) = delete;
  NetworkContext_CreateTCPBoundSocket_ForwardToCallback& operator=(const NetworkContext_CreateTCPBoundSocket_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::CreateTCPBoundSocketCallback callback_;
};

class NetworkContext_ForceReloadProxyConfig_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ForceReloadProxyConfig_ForwardToCallback(
      NetworkContext::ForceReloadProxyConfigCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ForceReloadProxyConfig_ForwardToCallback(const NetworkContext_ForceReloadProxyConfig_ForwardToCallback&) = delete;
  NetworkContext_ForceReloadProxyConfig_ForwardToCallback& operator=(const NetworkContext_ForceReloadProxyConfig_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ForceReloadProxyConfigCallback callback_;
};

class NetworkContext_ClearBadProxiesCache_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ClearBadProxiesCache_ForwardToCallback(
      NetworkContext::ClearBadProxiesCacheCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ClearBadProxiesCache_ForwardToCallback(const NetworkContext_ClearBadProxiesCache_ForwardToCallback&) = delete;
  NetworkContext_ClearBadProxiesCache_ForwardToCallback& operator=(const NetworkContext_ClearBadProxiesCache_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ClearBadProxiesCacheCallback callback_;
};

class NetworkContext_VerifyCertForSignedExchange_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_VerifyCertForSignedExchange_ForwardToCallback(
      NetworkContext::VerifyCertForSignedExchangeCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_VerifyCertForSignedExchange_ForwardToCallback(const NetworkContext_VerifyCertForSignedExchange_ForwardToCallback&) = delete;
  NetworkContext_VerifyCertForSignedExchange_ForwardToCallback& operator=(const NetworkContext_VerifyCertForSignedExchange_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::VerifyCertForSignedExchangeCallback callback_;
};

class NetworkContext_AddHSTS_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_AddHSTS_ForwardToCallback(
      NetworkContext::AddHSTSCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_AddHSTS_ForwardToCallback(const NetworkContext_AddHSTS_ForwardToCallback&) = delete;
  NetworkContext_AddHSTS_ForwardToCallback& operator=(const NetworkContext_AddHSTS_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::AddHSTSCallback callback_;
};

class NetworkContext_IsHSTSActiveForHost_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_IsHSTSActiveForHost_ForwardToCallback(
      NetworkContext::IsHSTSActiveForHostCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_IsHSTSActiveForHost_ForwardToCallback(const NetworkContext_IsHSTSActiveForHost_ForwardToCallback&) = delete;
  NetworkContext_IsHSTSActiveForHost_ForwardToCallback& operator=(const NetworkContext_IsHSTSActiveForHost_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::IsHSTSActiveForHostCallback callback_;
};

class NetworkContext_GetHSTSState_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_GetHSTSState_ForwardToCallback(
      NetworkContext::GetHSTSStateCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_GetHSTSState_ForwardToCallback(const NetworkContext_GetHSTSState_ForwardToCallback&) = delete;
  NetworkContext_GetHSTSState_ForwardToCallback& operator=(const NetworkContext_GetHSTSState_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::GetHSTSStateCallback callback_;
};

class NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback(
      NetworkContext::SetCorsOriginAccessListsForOriginCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback(const NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback&) = delete;
  NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback& operator=(const NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::SetCorsOriginAccessListsForOriginCallback callback_;
};

class NetworkContext_DeleteDynamicDataForHost_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_DeleteDynamicDataForHost_ForwardToCallback(
      NetworkContext::DeleteDynamicDataForHostCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_DeleteDynamicDataForHost_ForwardToCallback(const NetworkContext_DeleteDynamicDataForHost_ForwardToCallback&) = delete;
  NetworkContext_DeleteDynamicDataForHost_ForwardToCallback& operator=(const NetworkContext_DeleteDynamicDataForHost_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::DeleteDynamicDataForHostCallback callback_;
};

class NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback(
      NetworkContext::SaveHttpAuthCacheProxyEntriesCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback(const NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback&) = delete;
  NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback& operator=(const NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::SaveHttpAuthCacheProxyEntriesCallback callback_;
};

class NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback(
      NetworkContext::LoadHttpAuthCacheProxyEntriesCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback(const NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback&) = delete;
  NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback& operator=(const NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::LoadHttpAuthCacheProxyEntriesCallback callback_;
};

class NetworkContext_AddAuthCacheEntry_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_AddAuthCacheEntry_ForwardToCallback(
      NetworkContext::AddAuthCacheEntryCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_AddAuthCacheEntry_ForwardToCallback(const NetworkContext_AddAuthCacheEntry_ForwardToCallback&) = delete;
  NetworkContext_AddAuthCacheEntry_ForwardToCallback& operator=(const NetworkContext_AddAuthCacheEntry_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::AddAuthCacheEntryCallback callback_;
};

class NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback(
      NetworkContext::LookupServerBasicAuthCredentialsCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback(const NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback&) = delete;
  NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback& operator=(const NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::LookupServerBasicAuthCredentialsCallback callback_;
};
class NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse(const NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse&) = delete;
  NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse& operator=(const NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback(
      NetworkContext::EnableStaticKeyPinningForTestingCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback(const NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback&) = delete;
  NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback& operator=(const NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::EnableStaticKeyPinningForTestingCallback callback_;
};

class NetworkContext_VerifyCertificateForTesting_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_VerifyCertificateForTesting_ForwardToCallback(
      NetworkContext::VerifyCertificateForTestingCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_VerifyCertificateForTesting_ForwardToCallback(const NetworkContext_VerifyCertificateForTesting_ForwardToCallback&) = delete;
  NetworkContext_VerifyCertificateForTesting_ForwardToCallback& operator=(const NetworkContext_VerifyCertificateForTesting_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::VerifyCertificateForTestingCallback callback_;
};
class NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse(const NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse&) = delete;
  NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse& operator=(const NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback(
      NetworkContext::AddDomainReliabilityContextForTestingCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback(const NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback&) = delete;
  NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback& operator=(const NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::AddDomainReliabilityContextForTestingCallback callback_;
};
class NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse(const NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse&) = delete;
  NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse& operator=(const NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback(
      NetworkContext::ForceDomainReliabilityUploadsForTestingCallback callback
      ) : callback_(std::move(callback)) {
  }

  NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback(const NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback&) = delete;
  NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback& operator=(const NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  NetworkContext::ForceDomainReliabilityUploadsForTestingCallback callback_;
};

NetworkContextProxy::NetworkContextProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void NetworkContextProxy::SetClient(
    ::mojo::PendingRemote<NetworkContextClient> in_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetClient", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("client"), in_client,
                        "<value of type ::mojo::PendingRemote<NetworkContextClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetClient_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetClient_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::NetworkContextClientInterfaceBase>>(
      in_client, &params->client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid client in NetworkContext.SetClient request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetClient");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateURLLoaderFactory(
    ::mojo::PendingReceiver<::network::mojom::URLLoaderFactory> in_url_loader_factory, URLLoaderFactoryParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateURLLoaderFactory", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url_loader_factory"), in_url_loader_factory,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::URLLoaderFactory>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type URLLoaderFactoryParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateURLLoaderFactory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateURLLoaderFactory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::URLLoaderFactoryInterfaceBase>>(
      in_url_loader_factory, &params->url_loader_factory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->url_loader_factory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid url_loader_factory in NetworkContext.CreateURLLoaderFactory request");
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::URLLoaderFactoryParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in NetworkContext.CreateURLLoaderFactory request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateURLLoaderFactory");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::ResetURLLoaderFactories(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::ResetURLLoaderFactories");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ResetURLLoaderFactories_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ResetURLLoaderFactories_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ResetURLLoaderFactories");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::GetCookieManager(
    ::mojo::PendingReceiver<::network::mojom::CookieManager> in_cookie_manager) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::GetCookieManager", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cookie_manager"), in_cookie_manager,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::CookieManager>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetCookieManager_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetCookieManager_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::CookieManagerInterfaceBase>>(
      in_cookie_manager, &params->cookie_manager, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->cookie_manager),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid cookie_manager in NetworkContext.GetCookieManager request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetCookieManager");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::GetRestrictedCookieManager(
    ::mojo::PendingReceiver<::network::mojom::RestrictedCookieManager> in_restricted_cookie_manager, ::network::mojom::RestrictedCookieManagerRole in_role, const ::url::Origin& in_origin, const ::net::IsolationInfo& in_isolation_info, ::mojo::PendingRemote<::network::mojom::CookieAccessObserver> in_cookie_observer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::GetRestrictedCookieManager", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("restricted_cookie_manager"), in_restricted_cookie_manager,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::RestrictedCookieManager>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("role"), in_role,
                        "<value of type ::network::mojom::RestrictedCookieManagerRole>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("isolation_info"), in_isolation_info,
                        "<value of type const ::net::IsolationInfo&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cookie_observer"), in_cookie_observer,
                        "<value of type ::mojo::PendingRemote<::network::mojom::CookieAccessObserver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetRestrictedCookieManager_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetRestrictedCookieManager_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::RestrictedCookieManagerInterfaceBase>>(
      in_restricted_cookie_manager, &params->restricted_cookie_manager, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->restricted_cookie_manager),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid restricted_cookie_manager in NetworkContext.GetRestrictedCookieManager request");
  mojo::internal::Serialize<::network::mojom::RestrictedCookieManagerRole>(
      in_role, &params->role);
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContext.GetRestrictedCookieManager request");
  mojo::internal::MessageFragment<
      typename decltype(params->isolation_info)::BaseType> isolation_info_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IsolationInfoDataView>(
      in_isolation_info, isolation_info_fragment);
  params->isolation_info.Set(
      isolation_info_fragment.is_null() ? nullptr : isolation_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->isolation_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null isolation_info in NetworkContext.GetRestrictedCookieManager request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::CookieAccessObserverInterfaceBase>>(
      in_cookie_observer, &params->cookie_observer, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetRestrictedCookieManager");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::GetTrustTokenQueryAnswerer(
    ::mojo::PendingReceiver<::network::mojom::TrustTokenQueryAnswerer> in_trust_token_query_answerer, const ::url::Origin& in_top_frame_origin) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::GetTrustTokenQueryAnswerer", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trust_token_query_answerer"), in_trust_token_query_answerer,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::TrustTokenQueryAnswerer>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("top_frame_origin"), in_top_frame_origin,
                        "<value of type const ::url::Origin&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetTrustTokenQueryAnswerer_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetTrustTokenQueryAnswerer_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::TrustTokenQueryAnswererInterfaceBase>>(
      in_trust_token_query_answerer, &params->trust_token_query_answerer, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->trust_token_query_answerer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid trust_token_query_answerer in NetworkContext.GetTrustTokenQueryAnswerer request");
  mojo::internal::MessageFragment<
      typename decltype(params->top_frame_origin)::BaseType> top_frame_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_top_frame_origin, top_frame_origin_fragment);
  params->top_frame_origin.Set(
      top_frame_origin_fragment.is_null() ? nullptr : top_frame_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->top_frame_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null top_frame_origin in NetworkContext.GetTrustTokenQueryAnswerer request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetTrustTokenQueryAnswerer");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::ClearTrustTokenData(
    ClearDataFilterPtr in_filter, ClearTrustTokenDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearTrustTokenData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearTrustTokenData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearTrustTokenData_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearTrustTokenData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearTrustTokenData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::GetStoredTrustTokenCounts(
    GetStoredTrustTokenCountsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::GetStoredTrustTokenCounts");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetStoredTrustTokenCounts_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetStoredTrustTokenCounts_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetStoredTrustTokenCounts");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::DeleteStoredTrustTokens(
    const ::url::Origin& in_issuer, DeleteStoredTrustTokensCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::DeleteStoredTrustTokens", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("issuer"), in_issuer,
                        "<value of type const ::url::Origin&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_DeleteStoredTrustTokens_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_DeleteStoredTrustTokens_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->issuer)::BaseType> issuer_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_issuer, issuer_fragment);
  params->issuer.Set(
      issuer_fragment.is_null() ? nullptr : issuer_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->issuer.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null issuer in NetworkContext.DeleteStoredTrustTokens request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("DeleteStoredTrustTokens");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_DeleteStoredTrustTokens_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetBlockTrustTokens(
    bool in_block) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetBlockTrustTokens", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("block"), in_block,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetBlockTrustTokens_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetBlockTrustTokens_Params_Data> params(
          message);
  params.Allocate();
  params->block = in_block;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetBlockTrustTokens");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::ClearNetworkingHistoryBetween(
    ::base::Time in_start_time, ::base::Time in_end_time, ClearNetworkingHistoryBetweenCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearNetworkingHistoryBetween", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("start_time"), in_start_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("end_time"), in_end_time,
                        "<value of type ::base::Time>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearNetworkingHistoryBetween_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearNetworkingHistoryBetween_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->start_time)::BaseType> start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_start_time, start_time_fragment);
  params->start_time.Set(
      start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null start_time in NetworkContext.ClearNetworkingHistoryBetween request");
  mojo::internal::MessageFragment<
      typename decltype(params->end_time)::BaseType> end_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_end_time, end_time_fragment);
  params->end_time.Set(
      end_time_fragment.is_null() ? nullptr : end_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null end_time in NetworkContext.ClearNetworkingHistoryBetween request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearNetworkingHistoryBetween");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearHttpCache(
    ::base::Time in_start_time, ::base::Time in_end_time, ClearDataFilterPtr in_filter, ClearHttpCacheCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearHttpCache", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("start_time"), in_start_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("end_time"), in_end_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearHttpCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearHttpCache_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->start_time)::BaseType> start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_start_time, start_time_fragment);
  params->start_time.Set(
      start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null start_time in NetworkContext.ClearHttpCache request");
  mojo::internal::MessageFragment<
      typename decltype(params->end_time)::BaseType> end_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_end_time, end_time_fragment);
  params->end_time.Set(
      end_time_fragment.is_null() ? nullptr : end_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null end_time in NetworkContext.ClearHttpCache request");
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearHttpCache");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearHttpCache_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ComputeHttpCacheSize(
    ::base::Time in_start_time, ::base::Time in_end_time, ComputeHttpCacheSizeCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ComputeHttpCacheSize", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("start_time"), in_start_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("end_time"), in_end_time,
                        "<value of type ::base::Time>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ComputeHttpCacheSize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ComputeHttpCacheSize_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->start_time)::BaseType> start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_start_time, start_time_fragment);
  params->start_time.Set(
      start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null start_time in NetworkContext.ComputeHttpCacheSize request");
  mojo::internal::MessageFragment<
      typename decltype(params->end_time)::BaseType> end_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_end_time, end_time_fragment);
  params->end_time.Set(
      end_time_fragment.is_null() ? nullptr : end_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null end_time in NetworkContext.ComputeHttpCacheSize request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ComputeHttpCacheSize");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ComputeHttpCacheSize_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::NotifyExternalCacheHit(
    const ::GURL& in_url, const std::string& in_http_method, const ::net::NetworkIsolationKey& in_key, bool in_is_subframe_document_resource, bool in_include_credentials) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::NotifyExternalCacheHit", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("http_method"), in_http_method,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_subframe_document_resource"), in_is_subframe_document_resource,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("include_credentials"), in_include_credentials,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_NotifyExternalCacheHit_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_NotifyExternalCacheHit_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.NotifyExternalCacheHit request");
  mojo::internal::MessageFragment<
      typename decltype(params->http_method)::BaseType> http_method_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_http_method, http_method_fragment);
  params->http_method.Set(
      http_method_fragment.is_null() ? nullptr : http_method_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->http_method.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null http_method in NetworkContext.NotifyExternalCacheHit request");
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in NetworkContext.NotifyExternalCacheHit request");
  params->is_subframe_document_resource = in_is_subframe_document_resource;
  params->include_credentials = in_include_credentials;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("NotifyExternalCacheHit");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::ClearHostCache(
    ClearDataFilterPtr in_filter, ClearHostCacheCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearHostCache", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearHostCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearHostCache_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearHostCache");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearHostCache_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearHttpAuthCache(
    ::base::Time in_start_time, ::base::Time in_end_time, ClearHttpAuthCacheCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearHttpAuthCache", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("start_time"), in_start_time,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("end_time"), in_end_time,
                        "<value of type ::base::Time>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearHttpAuthCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearHttpAuthCache_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->start_time)::BaseType> start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_start_time, start_time_fragment);
  params->start_time.Set(
      start_time_fragment.is_null() ? nullptr : start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null start_time in NetworkContext.ClearHttpAuthCache request");
  mojo::internal::MessageFragment<
      typename decltype(params->end_time)::BaseType> end_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_end_time, end_time_fragment);
  params->end_time.Set(
      end_time_fragment.is_null() ? nullptr : end_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null end_time in NetworkContext.ClearHttpAuthCache request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearHttpAuthCache");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearHttpAuthCache_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearReportingCacheReports(
    ClearDataFilterPtr in_filter, ClearReportingCacheReportsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearReportingCacheReports", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearReportingCacheReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearReportingCacheReports_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearReportingCacheReports");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearReportingCacheReports_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearReportingCacheClients(
    ClearDataFilterPtr in_filter, ClearReportingCacheClientsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearReportingCacheClients", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearReportingCacheClients_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearReportingCacheClients_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearReportingCacheClients");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearReportingCacheClients_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearNetworkErrorLogging(
    ClearDataFilterPtr in_filter, ClearNetworkErrorLoggingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearNetworkErrorLogging", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearNetworkErrorLogging_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearNetworkErrorLogging_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearNetworkErrorLogging");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearNetworkErrorLogging_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearDomainReliability(
    ClearDataFilterPtr in_filter, NetworkContext::DomainReliabilityClearMode in_mode, ClearDomainReliabilityCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ClearDomainReliability", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("filter"), in_filter,
                        "<value of type ClearDataFilterPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mode"), in_mode,
                        "<value of type NetworkContext::DomainReliabilityClearMode>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearDomainReliability_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearDomainReliability_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->filter)::BaseType> filter_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ClearDataFilterDataView>(
      in_filter, filter_fragment);
  params->filter.Set(
      filter_fragment.is_null() ? nullptr : filter_fragment.data());
  mojo::internal::Serialize<::network::mojom::NetworkContext_DomainReliabilityClearMode>(
      in_mode, &params->mode);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearDomainReliability");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearDomainReliability_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetDocumentReportingEndpoints(
    const ::base::UnguessableToken& in_reporting_source, const ::url::Origin& in_origin, const ::net::IsolationInfo& in_isolation_info, const base::flat_map<std::string, std::string>& in_endpoints) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetDocumentReportingEndpoints", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reporting_source"), in_reporting_source,
                        "<value of type const ::base::UnguessableToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("isolation_info"), in_isolation_info,
                        "<value of type const ::net::IsolationInfo&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("endpoints"), in_endpoints,
                        "<value of type const base::flat_map<std::string, std::string>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetDocumentReportingEndpoints_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetDocumentReportingEndpoints_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->reporting_source)::BaseType> reporting_source_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_reporting_source, reporting_source_fragment);
  params->reporting_source.Set(
      reporting_source_fragment.is_null() ? nullptr : reporting_source_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->reporting_source.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null reporting_source in NetworkContext.SetDocumentReportingEndpoints request");
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContext.SetDocumentReportingEndpoints request");
  mojo::internal::MessageFragment<
      typename decltype(params->isolation_info)::BaseType> isolation_info_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IsolationInfoDataView>(
      in_isolation_info, isolation_info_fragment);
  params->isolation_info.Set(
      isolation_info_fragment.is_null() ? nullptr : isolation_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->isolation_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null isolation_info in NetworkContext.SetDocumentReportingEndpoints request");
  mojo::internal::MessageFragment<
      typename decltype(params->endpoints)::BaseType>
      endpoints_fragment(params.message());
  const mojo::internal::ContainerValidateParams endpoints_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)), new mojo::internal::ContainerValidateParams(0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr)));
  mojo::internal::Serialize<mojo::MapDataView<mojo::StringDataView, mojo::StringDataView>>(
      in_endpoints, endpoints_fragment, &endpoints_validate_params);
  params->endpoints.Set(
      endpoints_fragment.is_null() ? nullptr : endpoints_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->endpoints.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null endpoints in NetworkContext.SetDocumentReportingEndpoints request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetDocumentReportingEndpoints");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::SendReportsAndRemoveSource(
    const ::base::UnguessableToken& in_reporting_source) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SendReportsAndRemoveSource", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reporting_source"), in_reporting_source,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SendReportsAndRemoveSource_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SendReportsAndRemoveSource_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->reporting_source)::BaseType> reporting_source_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_reporting_source, reporting_source_fragment);
  params->reporting_source.Set(
      reporting_source_fragment.is_null() ? nullptr : reporting_source_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->reporting_source.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null reporting_source in NetworkContext.SendReportsAndRemoveSource request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SendReportsAndRemoveSource");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::QueueReport(
    const std::string& in_type, const std::string& in_group, const ::GURL& in_url, const absl::optional<::base::UnguessableToken>& in_reporting_source, const ::net::NetworkIsolationKey& in_network_isolation_key, const absl::optional<std::string>& in_user_agent, ::base::Value::Dict in_body) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::QueueReport", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("type"), in_type,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("group"), in_group,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reporting_source"), in_reporting_source,
                        "<value of type const absl::optional<::base::UnguessableToken>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("user_agent"), in_user_agent,
                        "<value of type const absl::optional<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("body"), in_body,
                        "<value of type ::base::Value::Dict>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_QueueReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_QueueReport_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->type)::BaseType> type_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_type, type_fragment);
  params->type.Set(
      type_fragment.is_null() ? nullptr : type_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->type.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null type in NetworkContext.QueueReport request");
  mojo::internal::MessageFragment<
      typename decltype(params->group)::BaseType> group_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_group, group_fragment);
  params->group.Set(
      group_fragment.is_null() ? nullptr : group_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->group.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null group in NetworkContext.QueueReport request");
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.QueueReport request");
  mojo::internal::MessageFragment<
      typename decltype(params->reporting_source)::BaseType> reporting_source_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_reporting_source, reporting_source_fragment);
  params->reporting_source.Set(
      reporting_source_fragment.is_null() ? nullptr : reporting_source_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.QueueReport request");
  mojo::internal::MessageFragment<
      typename decltype(params->user_agent)::BaseType> user_agent_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_user_agent, user_agent_fragment);
  params->user_agent.Set(
      user_agent_fragment.is_null() ? nullptr : user_agent_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->body)::BaseType> body_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::DictionaryValueDataView>(
      in_body, body_fragment);
  params->body.Set(
      body_fragment.is_null() ? nullptr : body_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->body.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null body in NetworkContext.QueueReport request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("QueueReport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::QueueSignedExchangeReport(
    SignedExchangeReportPtr in_report, const ::net::NetworkIsolationKey& in_network_isolation_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::QueueSignedExchangeReport", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report"), in_report,
                        "<value of type SignedExchangeReportPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_QueueSignedExchangeReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_QueueSignedExchangeReport_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->report)::BaseType> report_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::SignedExchangeReportDataView>(
      in_report, report_fragment);
  params->report.Set(
      report_fragment.is_null() ? nullptr : report_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->report.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null report in NetworkContext.QueueSignedExchangeReport request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.QueueSignedExchangeReport request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("QueueSignedExchangeReport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CloseAllConnections(
    CloseAllConnectionsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::CloseAllConnections");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CloseAllConnections_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CloseAllConnections_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CloseAllConnections");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_CloseAllConnections_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::CloseIdleConnections(
    CloseIdleConnectionsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::CloseIdleConnections");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CloseIdleConnections_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CloseIdleConnections_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CloseIdleConnections");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_CloseIdleConnections_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetNetworkConditions(
    const ::base::UnguessableToken& in_throttling_profile_id, NetworkConditionsPtr in_conditions) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetNetworkConditions", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("throttling_profile_id"), in_throttling_profile_id,
                        "<value of type const ::base::UnguessableToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("conditions"), in_conditions,
                        "<value of type NetworkConditionsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetNetworkConditions_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetNetworkConditions_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->throttling_profile_id)::BaseType> throttling_profile_id_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_throttling_profile_id, throttling_profile_id_fragment);
  params->throttling_profile_id.Set(
      throttling_profile_id_fragment.is_null() ? nullptr : throttling_profile_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->throttling_profile_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null throttling_profile_id in NetworkContext.SetNetworkConditions request");
  mojo::internal::MessageFragment<
      typename decltype(params->conditions)::BaseType> conditions_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkConditionsDataView>(
      in_conditions, conditions_fragment);
  params->conditions.Set(
      conditions_fragment.is_null() ? nullptr : conditions_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetNetworkConditions");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::SetAcceptLanguage(
    const std::string& in_new_accept_language) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetAcceptLanguage", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("new_accept_language"), in_new_accept_language,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetAcceptLanguage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetAcceptLanguage_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->new_accept_language)::BaseType> new_accept_language_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_new_accept_language, new_accept_language_fragment);
  params->new_accept_language.Set(
      new_accept_language_fragment.is_null() ? nullptr : new_accept_language_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->new_accept_language.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null new_accept_language in NetworkContext.SetAcceptLanguage request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetAcceptLanguage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::SetEnableReferrers(
    bool in_enable_referrers) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetEnableReferrers", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("enable_referrers"), in_enable_referrers,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetEnableReferrers_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetEnableReferrers_Params_Data> params(
          message);
  params.Allocate();
  params->enable_referrers = in_enable_referrers;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetEnableReferrers");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::SetCTPolicy(
    CTPolicyPtr in_ct_policy) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetCTPolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ct_policy"), in_ct_policy,
                        "<value of type CTPolicyPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetCTPolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetCTPolicy_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->ct_policy)::BaseType> ct_policy_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CTPolicyDataView>(
      in_ct_policy, ct_policy_fragment);
  params->ct_policy.Set(
      ct_policy_fragment.is_null() ? nullptr : ct_policy_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ct_policy.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ct_policy in NetworkContext.SetCTPolicy request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetCTPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::AddExpectCT(
    const std::string& in_host, ::base::Time in_expiry, bool in_enforce, const ::GURL& in_report_uri, const ::net::NetworkIsolationKey& in_network_isolation_key, AddExpectCTCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::AddExpectCT", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("expiry"), in_expiry,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("enforce"), in_enforce,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report_uri"), in_report_uri,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddExpectCT_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddExpectCT_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->host)::BaseType> host_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_host, host_fragment);
  params->host.Set(
      host_fragment.is_null() ? nullptr : host_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host in NetworkContext.AddExpectCT request");
  mojo::internal::MessageFragment<
      typename decltype(params->expiry)::BaseType> expiry_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_expiry, expiry_fragment);
  params->expiry.Set(
      expiry_fragment.is_null() ? nullptr : expiry_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->expiry.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null expiry in NetworkContext.AddExpectCT request");
  params->enforce = in_enforce;
  mojo::internal::MessageFragment<
      typename decltype(params->report_uri)::BaseType> report_uri_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_report_uri, report_uri_fragment);
  params->report_uri.Set(
      report_uri_fragment.is_null() ? nullptr : report_uri_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->report_uri.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null report_uri in NetworkContext.AddExpectCT request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.AddExpectCT request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddExpectCT");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_AddExpectCT_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetExpectCTTestReport(
    const ::GURL& in_report_uri, SetExpectCTTestReportCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetExpectCTTestReport", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("report_uri"), in_report_uri,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetExpectCTTestReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetExpectCTTestReport_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->report_uri)::BaseType> report_uri_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_report_uri, report_uri_fragment);
  params->report_uri.Set(
      report_uri_fragment.is_null() ? nullptr : report_uri_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->report_uri.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null report_uri in NetworkContext.SetExpectCTTestReport request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetExpectCTTestReport");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_SetExpectCTTestReport_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::GetExpectCTState(
    const std::string& in_domain, const ::net::NetworkIsolationKey& in_network_isolation_key, GetExpectCTStateCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::GetExpectCTState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("domain"), in_domain,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetExpectCTState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetExpectCTState_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->domain)::BaseType> domain_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_domain, domain_fragment);
  params->domain.Set(
      domain_fragment.is_null() ? nullptr : domain_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->domain.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null domain in NetworkContext.GetExpectCTState request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.GetExpectCTState request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetExpectCTState");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_GetExpectCTState_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::CreateUDPSocket(
    ::mojo::PendingReceiver<::network::mojom::UDPSocket> in_receiver, ::mojo::PendingRemote<::network::mojom::UDPSocketListener> in_listener) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateUDPSocket", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::UDPSocket>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("listener"), in_listener,
                        "<value of type ::mojo::PendingRemote<::network::mojom::UDPSocketListener>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateUDPSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateUDPSocket_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::UDPSocketInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in NetworkContext.CreateUDPSocket request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::UDPSocketListenerInterfaceBase>>(
      in_listener, &params->listener, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateUDPSocket");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateTCPServerSocket(
    const ::net::IPEndPoint& in_local_addr, uint32_t in_backlog, const ::net::MutableNetworkTrafficAnnotationTag& in_traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPServerSocket> in_socket, CreateTCPServerSocketCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateTCPServerSocket", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_addr"), in_local_addr,
                        "<value of type const ::net::IPEndPoint&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("backlog"), in_backlog,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("traffic_annotation"), in_traffic_annotation,
                        "<value of type const ::net::MutableNetworkTrafficAnnotationTag&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("socket"), in_socket,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::TCPServerSocket>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateTCPServerSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateTCPServerSocket_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->local_addr)::BaseType> local_addr_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_local_addr, local_addr_fragment);
  params->local_addr.Set(
      local_addr_fragment.is_null() ? nullptr : local_addr_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->local_addr.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null local_addr in NetworkContext.CreateTCPServerSocket request");
  params->backlog = in_backlog;
  mojo::internal::MessageFragment<
      typename decltype(params->traffic_annotation)::BaseType> traffic_annotation_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::MutableNetworkTrafficAnnotationTagDataView>(
      in_traffic_annotation, traffic_annotation_fragment);
  params->traffic_annotation.Set(
      traffic_annotation_fragment.is_null() ? nullptr : traffic_annotation_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->traffic_annotation.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null traffic_annotation in NetworkContext.CreateTCPServerSocket request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::TCPServerSocketInterfaceBase>>(
      in_socket, &params->socket, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->socket),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid socket in NetworkContext.CreateTCPServerSocket request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateTCPServerSocket");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_CreateTCPServerSocket_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::CreateTCPConnectedSocket(
    const absl::optional<::net::IPEndPoint>& in_local_addr, const ::net::AddressList& in_remote_addr_list, ::network::mojom::TCPConnectedSocketOptionsPtr in_tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& in_traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket> in_socket, ::mojo::PendingRemote<::network::mojom::SocketObserver> in_observer, CreateTCPConnectedSocketCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateTCPConnectedSocket", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_addr"), in_local_addr,
                        "<value of type const absl::optional<::net::IPEndPoint>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_addr_list"), in_remote_addr_list,
                        "<value of type const ::net::AddressList&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("tcp_connected_socket_options"), in_tcp_connected_socket_options,
                        "<value of type ::network::mojom::TCPConnectedSocketOptionsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("traffic_annotation"), in_traffic_annotation,
                        "<value of type const ::net::MutableNetworkTrafficAnnotationTag&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("socket"), in_socket,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("observer"), in_observer,
                        "<value of type ::mojo::PendingRemote<::network::mojom::SocketObserver>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateTCPConnectedSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateTCPConnectedSocket_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->local_addr)::BaseType> local_addr_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_local_addr, local_addr_fragment);
  params->local_addr.Set(
      local_addr_fragment.is_null() ? nullptr : local_addr_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->remote_addr_list)::BaseType> remote_addr_list_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::AddressListDataView>(
      in_remote_addr_list, remote_addr_list_fragment);
  params->remote_addr_list.Set(
      remote_addr_list_fragment.is_null() ? nullptr : remote_addr_list_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_addr_list.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_addr_list in NetworkContext.CreateTCPConnectedSocket request");
  mojo::internal::MessageFragment<
      typename decltype(params->tcp_connected_socket_options)::BaseType> tcp_connected_socket_options_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::TCPConnectedSocketOptionsDataView>(
      in_tcp_connected_socket_options, tcp_connected_socket_options_fragment);
  params->tcp_connected_socket_options.Set(
      tcp_connected_socket_options_fragment.is_null() ? nullptr : tcp_connected_socket_options_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->traffic_annotation)::BaseType> traffic_annotation_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::MutableNetworkTrafficAnnotationTagDataView>(
      in_traffic_annotation, traffic_annotation_fragment);
  params->traffic_annotation.Set(
      traffic_annotation_fragment.is_null() ? nullptr : traffic_annotation_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->traffic_annotation.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null traffic_annotation in NetworkContext.CreateTCPConnectedSocket request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::TCPConnectedSocketInterfaceBase>>(
      in_socket, &params->socket, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->socket),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid socket in NetworkContext.CreateTCPConnectedSocket request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::SocketObserverInterfaceBase>>(
      in_observer, &params->observer, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateTCPConnectedSocket");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_CreateTCPConnectedSocket_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::CreateTCPBoundSocket(
    const ::net::IPEndPoint& in_local_addr, const ::net::MutableNetworkTrafficAnnotationTag& in_traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket> in_socket, CreateTCPBoundSocketCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateTCPBoundSocket", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_addr"), in_local_addr,
                        "<value of type const ::net::IPEndPoint&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("traffic_annotation"), in_traffic_annotation,
                        "<value of type const ::net::MutableNetworkTrafficAnnotationTag&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("socket"), in_socket,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateTCPBoundSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateTCPBoundSocket_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->local_addr)::BaseType> local_addr_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_local_addr, local_addr_fragment);
  params->local_addr.Set(
      local_addr_fragment.is_null() ? nullptr : local_addr_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->local_addr.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null local_addr in NetworkContext.CreateTCPBoundSocket request");
  mojo::internal::MessageFragment<
      typename decltype(params->traffic_annotation)::BaseType> traffic_annotation_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::MutableNetworkTrafficAnnotationTagDataView>(
      in_traffic_annotation, traffic_annotation_fragment);
  params->traffic_annotation.Set(
      traffic_annotation_fragment.is_null() ? nullptr : traffic_annotation_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->traffic_annotation.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null traffic_annotation in NetworkContext.CreateTCPBoundSocket request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::TCPBoundSocketInterfaceBase>>(
      in_socket, &params->socket, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->socket),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid socket in NetworkContext.CreateTCPBoundSocket request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateTCPBoundSocket");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_CreateTCPBoundSocket_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::CreateProxyResolvingSocketFactory(
    ::mojo::PendingReceiver<::network::mojom::ProxyResolvingSocketFactory> in_factory) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateProxyResolvingSocketFactory", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("factory"), in_factory,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::ProxyResolvingSocketFactory>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateProxyResolvingSocketFactory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateProxyResolvingSocketFactory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::ProxyResolvingSocketFactoryInterfaceBase>>(
      in_factory, &params->factory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->factory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid factory in NetworkContext.CreateProxyResolvingSocketFactory request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateProxyResolvingSocketFactory");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::LookUpProxyForURL(
    const ::GURL& in_url, const ::net::NetworkIsolationKey& in_network_isolation_key, ::mojo::PendingRemote<::network::mojom::ProxyLookupClient> in_proxy_lookup_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::LookUpProxyForURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("proxy_lookup_client"), in_proxy_lookup_client,
                        "<value of type ::mojo::PendingRemote<::network::mojom::ProxyLookupClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_LookUpProxyForURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_LookUpProxyForURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.LookUpProxyForURL request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.LookUpProxyForURL request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::ProxyLookupClientInterfaceBase>>(
      in_proxy_lookup_client, &params->proxy_lookup_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->proxy_lookup_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid proxy_lookup_client in NetworkContext.LookUpProxyForURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("LookUpProxyForURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::ForceReloadProxyConfig(
    ForceReloadProxyConfigCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::ForceReloadProxyConfig");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ForceReloadProxyConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ForceReloadProxyConfig_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ForceReloadProxyConfig");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ForceReloadProxyConfig_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::ClearBadProxiesCache(
    ClearBadProxiesCacheCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::ClearBadProxiesCache");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearBadProxiesCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearBadProxiesCache_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearBadProxiesCache");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ClearBadProxiesCache_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::CreateWebSocket(
    const ::GURL& in_url, const std::vector<std::string>& in_requested_protocols, const ::net::SiteForCookies& in_site_for_cookies, const ::net::IsolationInfo& in_isolation_info, std::vector<::network::mojom::HttpHeaderPtr> in_additional_headers, int32_t in_process_id, const ::url::Origin& in_origin, uint32_t in_options, const ::net::MutableNetworkTrafficAnnotationTag& in_traffic_annotation, ::mojo::PendingRemote<::network::mojom::WebSocketHandshakeClient> in_handshake_client, ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver> in_url_loader_network_observer, ::mojo::PendingRemote<::network::mojom::WebSocketAuthenticationHandler> in_auth_handler, ::mojo::PendingRemote<TrustedHeaderClient> in_header_client, const absl::optional<::base::UnguessableToken>& in_throttling_profile_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateWebSocket", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("requested_protocols"), in_requested_protocols,
                        "<value of type const std::vector<std::string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("site_for_cookies"), in_site_for_cookies,
                        "<value of type const ::net::SiteForCookies&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("isolation_info"), in_isolation_info,
                        "<value of type const ::net::IsolationInfo&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("additional_headers"), in_additional_headers,
                        "<value of type std::vector<::network::mojom::HttpHeaderPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("process_id"), in_process_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("options"), in_options,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("traffic_annotation"), in_traffic_annotation,
                        "<value of type const ::net::MutableNetworkTrafficAnnotationTag&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("handshake_client"), in_handshake_client,
                        "<value of type ::mojo::PendingRemote<::network::mojom::WebSocketHandshakeClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url_loader_network_observer"), in_url_loader_network_observer,
                        "<value of type ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("auth_handler"), in_auth_handler,
                        "<value of type ::mojo::PendingRemote<::network::mojom::WebSocketAuthenticationHandler>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("header_client"), in_header_client,
                        "<value of type ::mojo::PendingRemote<TrustedHeaderClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("throttling_profile_id"), in_throttling_profile_id,
                        "<value of type const absl::optional<::base::UnguessableToken>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateWebSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateWebSocket_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.CreateWebSocket request");
  mojo::internal::MessageFragment<
      typename decltype(params->requested_protocols)::BaseType>
      requested_protocols_fragment(params.message());
  const mojo::internal::ContainerValidateParams requested_protocols_validate_params(
      0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::StringDataView>>(
      in_requested_protocols, requested_protocols_fragment, &requested_protocols_validate_params);
  params->requested_protocols.Set(
      requested_protocols_fragment.is_null() ? nullptr : requested_protocols_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->requested_protocols.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null requested_protocols in NetworkContext.CreateWebSocket request");
  mojo::internal::MessageFragment<
      typename decltype(params->site_for_cookies)::BaseType> site_for_cookies_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::SiteForCookiesDataView>(
      in_site_for_cookies, site_for_cookies_fragment);
  params->site_for_cookies.Set(
      site_for_cookies_fragment.is_null() ? nullptr : site_for_cookies_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->site_for_cookies.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null site_for_cookies in NetworkContext.CreateWebSocket request");
  mojo::internal::MessageFragment<
      typename decltype(params->isolation_info)::BaseType> isolation_info_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IsolationInfoDataView>(
      in_isolation_info, isolation_info_fragment);
  params->isolation_info.Set(
      isolation_info_fragment.is_null() ? nullptr : isolation_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->isolation_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null isolation_info in NetworkContext.CreateWebSocket request");
  mojo::internal::MessageFragment<
      typename decltype(params->additional_headers)::BaseType>
      additional_headers_fragment(params.message());
  const mojo::internal::ContainerValidateParams additional_headers_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::HttpHeaderDataView>>(
      in_additional_headers, additional_headers_fragment, &additional_headers_validate_params);
  params->additional_headers.Set(
      additional_headers_fragment.is_null() ? nullptr : additional_headers_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->additional_headers.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null additional_headers in NetworkContext.CreateWebSocket request");
  params->process_id = in_process_id;
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContext.CreateWebSocket request");
  params->options = in_options;
  mojo::internal::MessageFragment<
      typename decltype(params->traffic_annotation)::BaseType> traffic_annotation_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::MutableNetworkTrafficAnnotationTagDataView>(
      in_traffic_annotation, traffic_annotation_fragment);
  params->traffic_annotation.Set(
      traffic_annotation_fragment.is_null() ? nullptr : traffic_annotation_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->traffic_annotation.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null traffic_annotation in NetworkContext.CreateWebSocket request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::WebSocketHandshakeClientInterfaceBase>>(
      in_handshake_client, &params->handshake_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->handshake_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid handshake_client in NetworkContext.CreateWebSocket request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::URLLoaderNetworkServiceObserverInterfaceBase>>(
      in_url_loader_network_observer, &params->url_loader_network_observer, &params.message());
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::WebSocketAuthenticationHandlerInterfaceBase>>(
      in_auth_handler, &params->auth_handler, &params.message());
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::TrustedHeaderClientInterfaceBase>>(
      in_header_client, &params->header_client, &params.message());
  mojo::internal::MessageFragment<
      typename decltype(params->throttling_profile_id)::BaseType> throttling_profile_id_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_throttling_profile_id, throttling_profile_id_fragment);
  params->throttling_profile_id.Set(
      throttling_profile_id_fragment.is_null() ? nullptr : throttling_profile_id_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateWebSocket");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateWebTransport(
    const ::GURL& in_url, const ::url::Origin& in_origin, const ::net::NetworkIsolationKey& in_network_isolation_key, std::vector<::network::mojom::WebTransportCertificateFingerprintPtr> in_fingerprints, ::mojo::PendingRemote<::network::mojom::WebTransportHandshakeClient> in_handshake_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateWebTransport", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("fingerprints"), in_fingerprints,
                        "<value of type std::vector<::network::mojom::WebTransportCertificateFingerprintPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("handshake_client"), in_handshake_client,
                        "<value of type ::mojo::PendingRemote<::network::mojom::WebTransportHandshakeClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateWebTransport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateWebTransport_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.CreateWebTransport request");
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContext.CreateWebTransport request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.CreateWebTransport request");
  mojo::internal::MessageFragment<
      typename decltype(params->fingerprints)::BaseType>
      fingerprints_fragment(params.message());
  const mojo::internal::ContainerValidateParams fingerprints_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::WebTransportCertificateFingerprintDataView>>(
      in_fingerprints, fingerprints_fragment, &fingerprints_validate_params);
  params->fingerprints.Set(
      fingerprints_fragment.is_null() ? nullptr : fingerprints_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->fingerprints.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null fingerprints in NetworkContext.CreateWebTransport request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::WebTransportHandshakeClientInterfaceBase>>(
      in_handshake_client, &params->handshake_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->handshake_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid handshake_client in NetworkContext.CreateWebTransport request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateWebTransport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateNetLogExporter(
    ::mojo::PendingReceiver<::network::mojom::NetLogExporter> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateNetLogExporter", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::NetLogExporter>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateNetLogExporter_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateNetLogExporter_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::NetLogExporterInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in NetworkContext.CreateNetLogExporter request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateNetLogExporter");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::PreconnectSockets(
    uint32_t in_num_streams, const ::GURL& in_url, bool in_allow_credentials, const ::net::NetworkIsolationKey& in_network_isolation_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::PreconnectSockets", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("num_streams"), in_num_streams,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("allow_credentials"), in_allow_credentials,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_PreconnectSockets_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_PreconnectSockets_Params_Data> params(
          message);
  params.Allocate();
  params->num_streams = in_num_streams;
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.PreconnectSockets request");
  params->allow_credentials = in_allow_credentials;
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.PreconnectSockets request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("PreconnectSockets");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateP2PSocketManager(
    const ::net::NetworkIsolationKey& in_network_isolation_key, ::mojo::PendingRemote<::network::mojom::P2PTrustedSocketManagerClient> in_client, ::mojo::PendingReceiver<::network::mojom::P2PTrustedSocketManager> in_trusted_socket_manager, ::mojo::PendingReceiver<::network::mojom::P2PSocketManager> in_socket_manager) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateP2PSocketManager", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("client"), in_client,
                        "<value of type ::mojo::PendingRemote<::network::mojom::P2PTrustedSocketManagerClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trusted_socket_manager"), in_trusted_socket_manager,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::P2PTrustedSocketManager>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("socket_manager"), in_socket_manager,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::P2PSocketManager>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateP2PSocketManager_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateP2PSocketManager_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.CreateP2PSocketManager request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::P2PTrustedSocketManagerClientInterfaceBase>>(
      in_client, &params->client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid client in NetworkContext.CreateP2PSocketManager request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::P2PTrustedSocketManagerInterfaceBase>>(
      in_trusted_socket_manager, &params->trusted_socket_manager, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->trusted_socket_manager),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid trusted_socket_manager in NetworkContext.CreateP2PSocketManager request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::P2PSocketManagerInterfaceBase>>(
      in_socket_manager, &params->socket_manager, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->socket_manager),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid socket_manager in NetworkContext.CreateP2PSocketManager request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateP2PSocketManager");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateMdnsResponder(
    ::mojo::PendingReceiver<::network::mojom::MdnsResponder> in_responder_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateMdnsResponder", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("responder_receiver"), in_responder_receiver,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::MdnsResponder>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateMdnsResponder_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateMdnsResponder_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::MdnsResponderInterfaceBase>>(
      in_responder_receiver, &params->responder_receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->responder_receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid responder_receiver in NetworkContext.CreateMdnsResponder request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateMdnsResponder");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::ResolveHost(
    const ::net::HostPortPair& in_host, const ::net::NetworkIsolationKey& in_network_isolation_key, ::network::mojom::ResolveHostParametersPtr in_optional_parameters, ::mojo::PendingRemote<::network::mojom::ResolveHostClient> in_response_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::ResolveHost", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type const ::net::HostPortPair&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("optional_parameters"), in_optional_parameters,
                        "<value of type ::network::mojom::ResolveHostParametersPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("response_client"), in_response_client,
                        "<value of type ::mojo::PendingRemote<::network::mojom::ResolveHostClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ResolveHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ResolveHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->host)::BaseType> host_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::HostPortPairDataView>(
      in_host, host_fragment);
  params->host.Set(
      host_fragment.is_null() ? nullptr : host_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host in NetworkContext.ResolveHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.ResolveHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->optional_parameters)::BaseType> optional_parameters_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::ResolveHostParametersDataView>(
      in_optional_parameters, optional_parameters_fragment);
  params->optional_parameters.Set(
      optional_parameters_fragment.is_null() ? nullptr : optional_parameters_fragment.data());
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::ResolveHostClientInterfaceBase>>(
      in_response_client, &params->response_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->response_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid response_client in NetworkContext.ResolveHost request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ResolveHost");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::CreateHostResolver(
    const absl::optional<::net::DnsConfigOverrides>& in_config_overrides, ::mojo::PendingReceiver<::network::mojom::HostResolver> in_host_resolver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::CreateHostResolver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("config_overrides"), in_config_overrides,
                        "<value of type const absl::optional<::net::DnsConfigOverrides>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host_resolver"), in_host_resolver,
                        "<value of type ::mojo::PendingReceiver<::network::mojom::HostResolver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateHostResolver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateHostResolver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->config_overrides)::BaseType> config_overrides_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::DnsConfigOverridesDataView>(
      in_config_overrides, config_overrides_fragment);
  params->config_overrides.Set(
      config_overrides_fragment.is_null() ? nullptr : config_overrides_fragment.data());
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::network::mojom::HostResolverInterfaceBase>>(
      in_host_resolver, &params->host_resolver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->host_resolver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid host_resolver in NetworkContext.CreateHostResolver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateHostResolver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::VerifyCertForSignedExchange(
    const ::scoped_refptr<::net::X509Certificate>& in_certificate, const ::GURL& in_url, const ::net::NetworkIsolationKey& in_network_isolation_key, const std::string& in_ocsp_response, const std::string& in_sct_list, VerifyCertForSignedExchangeCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::VerifyCertForSignedExchange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("certificate"), in_certificate,
                        "<value of type const ::scoped_refptr<::net::X509Certificate>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ocsp_response"), in_ocsp_response,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sct_list"), in_sct_list,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_VerifyCertForSignedExchange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_VerifyCertForSignedExchange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->certificate)::BaseType> certificate_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::X509CertificateDataView>(
      in_certificate, certificate_fragment);
  params->certificate.Set(
      certificate_fragment.is_null() ? nullptr : certificate_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->certificate.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null certificate in NetworkContext.VerifyCertForSignedExchange request");
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.VerifyCertForSignedExchange request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.VerifyCertForSignedExchange request");
  mojo::internal::MessageFragment<
      typename decltype(params->ocsp_response)::BaseType> ocsp_response_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_ocsp_response, ocsp_response_fragment);
  params->ocsp_response.Set(
      ocsp_response_fragment.is_null() ? nullptr : ocsp_response_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ocsp_response.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ocsp_response in NetworkContext.VerifyCertForSignedExchange request");
  mojo::internal::MessageFragment<
      typename decltype(params->sct_list)::BaseType> sct_list_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_sct_list, sct_list_fragment);
  params->sct_list.Set(
      sct_list_fragment.is_null() ? nullptr : sct_list_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sct_list.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sct_list in NetworkContext.VerifyCertForSignedExchange request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("VerifyCertForSignedExchange");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_VerifyCertForSignedExchange_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::AddHSTS(
    const std::string& in_host, ::base::Time in_expiry, bool in_include_subdomains, AddHSTSCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::AddHSTS", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("expiry"), in_expiry,
                        "<value of type ::base::Time>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("include_subdomains"), in_include_subdomains,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddHSTS_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddHSTS_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->host)::BaseType> host_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_host, host_fragment);
  params->host.Set(
      host_fragment.is_null() ? nullptr : host_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host in NetworkContext.AddHSTS request");
  mojo::internal::MessageFragment<
      typename decltype(params->expiry)::BaseType> expiry_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
      in_expiry, expiry_fragment);
  params->expiry.Set(
      expiry_fragment.is_null() ? nullptr : expiry_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->expiry.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null expiry in NetworkContext.AddHSTS request");
  params->include_subdomains = in_include_subdomains;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddHSTS");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_AddHSTS_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::IsHSTSActiveForHost(
    const std::string& in_host, IsHSTSActiveForHostCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::IsHSTSActiveForHost", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_IsHSTSActiveForHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_IsHSTSActiveForHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->host)::BaseType> host_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_host, host_fragment);
  params->host.Set(
      host_fragment.is_null() ? nullptr : host_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host in NetworkContext.IsHSTSActiveForHost request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("IsHSTSActiveForHost");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_IsHSTSActiveForHost_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::GetHSTSState(
    const std::string& in_domain, GetHSTSStateCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::GetHSTSState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("domain"), in_domain,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetHSTSState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetHSTSState_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->domain)::BaseType> domain_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_domain, domain_fragment);
  params->domain.Set(
      domain_fragment.is_null() ? nullptr : domain_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->domain.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null domain in NetworkContext.GetHSTSState request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetHSTSState");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_GetHSTSState_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetCorsOriginAccessListsForOrigin(
    const ::url::Origin& in_source_origin, std::vector<::network::mojom::CorsOriginPatternPtr> in_allow_patterns, std::vector<::network::mojom::CorsOriginPatternPtr> in_block_patterns, SetCorsOriginAccessListsForOriginCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetCorsOriginAccessListsForOrigin", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_origin"), in_source_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("allow_patterns"), in_allow_patterns,
                        "<value of type std::vector<::network::mojom::CorsOriginPatternPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("block_patterns"), in_block_patterns,
                        "<value of type std::vector<::network::mojom::CorsOriginPatternPtr>>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetCorsOriginAccessListsForOrigin_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->source_origin)::BaseType> source_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_source_origin, source_origin_fragment);
  params->source_origin.Set(
      source_origin_fragment.is_null() ? nullptr : source_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_origin in NetworkContext.SetCorsOriginAccessListsForOrigin request");
  mojo::internal::MessageFragment<
      typename decltype(params->allow_patterns)::BaseType>
      allow_patterns_fragment(params.message());
  const mojo::internal::ContainerValidateParams allow_patterns_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::CorsOriginPatternDataView>>(
      in_allow_patterns, allow_patterns_fragment, &allow_patterns_validate_params);
  params->allow_patterns.Set(
      allow_patterns_fragment.is_null() ? nullptr : allow_patterns_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->allow_patterns.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null allow_patterns in NetworkContext.SetCorsOriginAccessListsForOrigin request");
  mojo::internal::MessageFragment<
      typename decltype(params->block_patterns)::BaseType>
      block_patterns_fragment(params.message());
  const mojo::internal::ContainerValidateParams block_patterns_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::CorsOriginPatternDataView>>(
      in_block_patterns, block_patterns_fragment, &block_patterns_validate_params);
  params->block_patterns.Set(
      block_patterns_fragment.is_null() ? nullptr : block_patterns_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->block_patterns.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null block_patterns in NetworkContext.SetCorsOriginAccessListsForOrigin request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetCorsOriginAccessListsForOrigin");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::DeleteDynamicDataForHost(
    const std::string& in_host, DeleteDynamicDataForHostCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::DeleteDynamicDataForHost", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("host"), in_host,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_DeleteDynamicDataForHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_DeleteDynamicDataForHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->host)::BaseType> host_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_host, host_fragment);
  params->host.Set(
      host_fragment.is_null() ? nullptr : host_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->host.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null host in NetworkContext.DeleteDynamicDataForHost request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("DeleteDynamicDataForHost");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_DeleteDynamicDataForHost_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetSplitAuthCacheByNetworkIsolationKey(
    bool in_split_auth_cache_by_network_isolation_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetSplitAuthCacheByNetworkIsolationKey", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("split_auth_cache_by_network_isolation_key"), in_split_auth_cache_by_network_isolation_key,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Params_Data> params(
          message);
  params.Allocate();
  params->split_auth_cache_by_network_isolation_key = in_split_auth_cache_by_network_isolation_key;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetSplitAuthCacheByNetworkIsolationKey");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::SaveHttpAuthCacheProxyEntries(
    SaveHttpAuthCacheProxyEntriesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::SaveHttpAuthCacheProxyEntries");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SaveHttpAuthCacheProxyEntries_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SaveHttpAuthCacheProxyEntries");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::LoadHttpAuthCacheProxyEntries(
    const ::base::UnguessableToken& in_cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::LoadHttpAuthCacheProxyEntries", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cache_key"), in_cache_key,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_LoadHttpAuthCacheProxyEntries_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cache_key)::BaseType> cache_key_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_cache_key, cache_key_fragment);
  params->cache_key.Set(
      cache_key_fragment.is_null() ? nullptr : cache_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cache_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cache_key in NetworkContext.LoadHttpAuthCacheProxyEntries request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("LoadHttpAuthCacheProxyEntries");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::AddAuthCacheEntry(
    const ::net::AuthChallengeInfo& in_challenge, const ::net::NetworkIsolationKey& in_network_isolation_key, const ::net::AuthCredentials& in_credentials, AddAuthCacheEntryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::AddAuthCacheEntry", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("challenge"), in_challenge,
                        "<value of type const ::net::AuthChallengeInfo&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("credentials"), in_credentials,
                        "<value of type const ::net::AuthCredentials&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddAuthCacheEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddAuthCacheEntry_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->challenge)::BaseType> challenge_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::AuthChallengeInfoDataView>(
      in_challenge, challenge_fragment);
  params->challenge.Set(
      challenge_fragment.is_null() ? nullptr : challenge_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->challenge.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null challenge in NetworkContext.AddAuthCacheEntry request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.AddAuthCacheEntry request");
  mojo::internal::MessageFragment<
      typename decltype(params->credentials)::BaseType> credentials_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::AuthCredentialsDataView>(
      in_credentials, credentials_fragment);
  params->credentials.Set(
      credentials_fragment.is_null() ? nullptr : credentials_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->credentials.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null credentials in NetworkContext.AddAuthCacheEntry request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddAuthCacheEntry");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_AddAuthCacheEntry_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetCorsNonWildcardRequestHeadersSupport(
    bool in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetCorsNonWildcardRequestHeadersSupport", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetCorsNonWildcardRequestHeadersSupport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetCorsNonWildcardRequestHeadersSupport_Params_Data> params(
          message);
  params.Allocate();
  params->value = in_value;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetCorsNonWildcardRequestHeadersSupport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::LookupServerBasicAuthCredentials(
    const ::GURL& in_url, const ::net::NetworkIsolationKey& in_network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::LookupServerBasicAuthCredentials", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("network_isolation_key"), in_network_isolation_key,
                        "<value of type const ::net::NetworkIsolationKey&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_LookupServerBasicAuthCredentials_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_LookupServerBasicAuthCredentials_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in NetworkContext.LookupServerBasicAuthCredentials request");
  mojo::internal::MessageFragment<
      typename decltype(params->network_isolation_key)::BaseType> network_isolation_key_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::NetworkIsolationKeyDataView>(
      in_network_isolation_key, network_isolation_key_fragment);
  params->network_isolation_key.Set(
      network_isolation_key_fragment.is_null() ? nullptr : network_isolation_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->network_isolation_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null network_isolation_key in NetworkContext.LookupServerBasicAuthCredentials request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("LookupServerBasicAuthCredentials");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkContextProxy::EnableStaticKeyPinningForTesting(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call network::mojom::NetworkContext::EnableStaticKeyPinningForTesting (sync)");
#else
  TRACE_EVENT0("mojom", "NetworkContext::EnableStaticKeyPinningForTesting");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_EnableStaticKeyPinningForTesting_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("EnableStaticKeyPinningForTesting");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkContext::EnableStaticKeyPinningForTesting");
#endif
  return result;
}

void NetworkContextProxy::EnableStaticKeyPinningForTesting(
    EnableStaticKeyPinningForTestingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::EnableStaticKeyPinningForTesting");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_EnableStaticKeyPinningForTesting_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("EnableStaticKeyPinningForTesting");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::VerifyCertificateForTesting(
    const ::scoped_refptr<::net::X509Certificate>& in_certificate, const std::string& in_hostname, const std::string& in_ocsp_response, const std::string& in_sct_list, VerifyCertificateForTestingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::VerifyCertificateForTesting", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("certificate"), in_certificate,
                        "<value of type const ::scoped_refptr<::net::X509Certificate>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("hostname"), in_hostname,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ocsp_response"), in_ocsp_response,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sct_list"), in_sct_list,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_VerifyCertificateForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_VerifyCertificateForTesting_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->certificate)::BaseType> certificate_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::X509CertificateDataView>(
      in_certificate, certificate_fragment);
  params->certificate.Set(
      certificate_fragment.is_null() ? nullptr : certificate_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->certificate.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null certificate in NetworkContext.VerifyCertificateForTesting request");
  mojo::internal::MessageFragment<
      typename decltype(params->hostname)::BaseType> hostname_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_hostname, hostname_fragment);
  params->hostname.Set(
      hostname_fragment.is_null() ? nullptr : hostname_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->hostname.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null hostname in NetworkContext.VerifyCertificateForTesting request");
  mojo::internal::MessageFragment<
      typename decltype(params->ocsp_response)::BaseType> ocsp_response_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_ocsp_response, ocsp_response_fragment);
  params->ocsp_response.Set(
      ocsp_response_fragment.is_null() ? nullptr : ocsp_response_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->ocsp_response.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null ocsp_response in NetworkContext.VerifyCertificateForTesting request");
  mojo::internal::MessageFragment<
      typename decltype(params->sct_list)::BaseType> sct_list_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_sct_list, sct_list_fragment);
  params->sct_list.Set(
      sct_list_fragment.is_null() ? nullptr : sct_list_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->sct_list.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null sct_list in NetworkContext.VerifyCertificateForTesting request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("VerifyCertificateForTesting");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_VerifyCertificateForTesting_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkContextProxy::AddDomainReliabilityContextForTesting(
    const ::url::Origin& param_origin, const ::GURL& param_upload_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call network::mojom::NetworkContext::AddDomainReliabilityContextForTesting (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), param_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("upload_url"), param_upload_url,
                        "<value of type const ::GURL&>");
   });
#else
  TRACE_EVENT0("mojom", "NetworkContext::AddDomainReliabilityContextForTesting");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddDomainReliabilityContextForTesting_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      param_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContext.AddDomainReliabilityContextForTesting request");
  mojo::internal::MessageFragment<
      typename decltype(params->upload_url)::BaseType> upload_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      param_upload_url, upload_url_fragment);
  params->upload_url.Set(
      upload_url_fragment.is_null() ? nullptr : upload_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->upload_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null upload_url in NetworkContext.AddDomainReliabilityContextForTesting request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddDomainReliabilityContextForTesting");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkContext::AddDomainReliabilityContextForTesting");
#endif
  return result;
}

void NetworkContextProxy::AddDomainReliabilityContextForTesting(
    const ::url::Origin& in_origin, const ::GURL& in_upload_url, AddDomainReliabilityContextForTestingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::AddDomainReliabilityContextForTesting", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("origin"), in_origin,
                        "<value of type const ::url::Origin&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("upload_url"), in_upload_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddDomainReliabilityContextForTesting_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->origin)::BaseType> origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_origin, origin_fragment);
  params->origin.Set(
      origin_fragment.is_null() ? nullptr : origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null origin in NetworkContext.AddDomainReliabilityContextForTesting request");
  mojo::internal::MessageFragment<
      typename decltype(params->upload_url)::BaseType> upload_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_upload_url, upload_url_fragment);
  params->upload_url.Set(
      upload_url_fragment.is_null() ? nullptr : upload_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->upload_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null upload_url in NetworkContext.AddDomainReliabilityContextForTesting request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddDomainReliabilityContextForTesting");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool NetworkContextProxy::ForceDomainReliabilityUploadsForTesting(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN0("mojom", "Call network::mojom::NetworkContext::ForceDomainReliabilityUploadsForTesting (sync)");
#else
  TRACE_EVENT0("mojom", "NetworkContext::ForceDomainReliabilityUploadsForTesting");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ForceDomainReliabilityUploadsForTesting");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "NetworkContext::ForceDomainReliabilityUploadsForTesting");
#endif
  return result;
}

void NetworkContextProxy::ForceDomainReliabilityUploadsForTesting(
    ForceDomainReliabilityUploadsForTestingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::ForceDomainReliabilityUploadsForTesting");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ForceDomainReliabilityUploadsForTesting");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void NetworkContextProxy::SetCTLogListAlwaysTimelyForTesting(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send network::mojom::NetworkContext::SetCTLogListAlwaysTimelyForTesting");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetCTLogListAlwaysTimelyForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetCTLogListAlwaysTimelyForTesting_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetCTLogListAlwaysTimelyForTesting");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::SetSCTAuditingMode(
    SCTAuditingMode in_mode) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::SetSCTAuditingMode", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mode"), in_mode,
                        "<value of type SCTAuditingMode>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetSCTAuditingMode_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetSCTAuditingMode_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::SCTAuditingMode>(
      in_mode, &params->mode);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetSCTAuditingMode");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void NetworkContextProxy::AddReportingApiObserver(
    ::mojo::PendingRemote<::network::mojom::ReportingApiObserver> in_observer) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send network::mojom::NetworkContext::AddReportingApiObserver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("observer"), in_observer,
                        "<value of type ::mojo::PendingRemote<::network::mojom::ReportingApiObserver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddReportingApiObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddReportingApiObserver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::network::mojom::ReportingApiObserverInterfaceBase>>(
      in_observer, &params->observer, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->observer),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid observer in NetworkContext.AddReportingApiObserver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddReportingApiObserver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class NetworkContext_ClearTrustTokenData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearTrustTokenDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearTrustTokenData_ProxyToResponder> proxy(
        new NetworkContext_ClearTrustTokenData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearTrustTokenData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearTrustTokenData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearTrustTokenData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearTrustTokenDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearTrustTokenData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearTrustTokenData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearTrustTokenData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearTrustTokenData_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearTrustTokenData_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearTrustTokenData");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearTrustTokenData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearTrustTokenData_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearTrustTokenData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::GetStoredTrustTokenCountsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder> proxy(
        new NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::GetStoredTrustTokenCountsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<::network::mojom::StoredTrustTokensForIssuerPtr> in_tokens);
};

bool NetworkContext_GetStoredTrustTokenCounts_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_GetStoredTrustTokenCounts_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_GetStoredTrustTokenCounts_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<::network::mojom::StoredTrustTokensForIssuerPtr> p_tokens{};
  NetworkContext_GetStoredTrustTokenCounts_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadTokens(&p_tokens))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_tokens));
  return true;
}

void NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder::Run(
    std::vector<::network::mojom::StoredTrustTokensForIssuerPtr> in_tokens) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::GetStoredTrustTokenCounts", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("tokens"), in_tokens,
                        "<value of type std::vector<::network::mojom::StoredTrustTokensForIssuerPtr>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetStoredTrustTokenCounts_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetStoredTrustTokenCounts_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->tokens)::BaseType>
      tokens_fragment(params.message());
  const mojo::internal::ContainerValidateParams tokens_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::network::mojom::StoredTrustTokensForIssuerDataView>>(
      in_tokens, tokens_fragment, &tokens_validate_params);
  params->tokens.Set(
      tokens_fragment.is_null() ? nullptr : tokens_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->tokens.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null tokens in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetStoredTrustTokenCounts");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_DeleteStoredTrustTokens_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::DeleteStoredTrustTokensCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_DeleteStoredTrustTokens_ProxyToResponder> proxy(
        new NetworkContext_DeleteStoredTrustTokens_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_DeleteStoredTrustTokens_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_DeleteStoredTrustTokens_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_DeleteStoredTrustTokens_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::DeleteStoredTrustTokensCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::network::mojom::DeleteStoredTrustTokensStatus in_status);
};

bool NetworkContext_DeleteStoredTrustTokens_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_DeleteStoredTrustTokens_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_DeleteStoredTrustTokens_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::network::mojom::DeleteStoredTrustTokensStatus p_status{};
  NetworkContext_DeleteStoredTrustTokens_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadStatus(&p_status))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 8, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_status));
  return true;
}

void NetworkContext_DeleteStoredTrustTokens_ProxyToResponder::Run(
    ::network::mojom::DeleteStoredTrustTokensStatus in_status) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::DeleteStoredTrustTokens", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("status"), in_status,
                        "<value of type ::network::mojom::DeleteStoredTrustTokensStatus>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_DeleteStoredTrustTokens_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_DeleteStoredTrustTokens_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::network::mojom::DeleteStoredTrustTokensStatus>(
      in_status, &params->status);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("DeleteStoredTrustTokens");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearNetworkingHistoryBetweenCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder> proxy(
        new NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearNetworkingHistoryBetweenCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearNetworkingHistoryBetween_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearNetworkingHistoryBetween_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearNetworkingHistoryBetween_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearNetworkingHistoryBetween_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 10, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearNetworkingHistoryBetween");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearNetworkingHistoryBetween_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearNetworkingHistoryBetween_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearNetworkingHistoryBetween");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearHttpCache_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearHttpCacheCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearHttpCache_ProxyToResponder> proxy(
        new NetworkContext_ClearHttpCache_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearHttpCache_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearHttpCache_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearHttpCache_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearHttpCacheCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearHttpCache_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearHttpCache_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearHttpCache_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearHttpCache_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 11, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearHttpCache_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearHttpCache");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearHttpCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearHttpCache_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearHttpCache");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ComputeHttpCacheSize_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ComputeHttpCacheSizeCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ComputeHttpCacheSize_ProxyToResponder> proxy(
        new NetworkContext_ComputeHttpCacheSize_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ComputeHttpCacheSize_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ComputeHttpCacheSize_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ComputeHttpCacheSize_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ComputeHttpCacheSizeCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_is_upper_bound, int64_t in_size_or_error);
};

bool NetworkContext_ComputeHttpCacheSize_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ComputeHttpCacheSize_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ComputeHttpCacheSize_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_is_upper_bound{};
  int64_t p_size_or_error{};
  NetworkContext_ComputeHttpCacheSize_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_is_upper_bound = input_data_view.is_upper_bound();
  if (success)
    p_size_or_error = input_data_view.size_or_error();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 12, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_is_upper_bound), 
std::move(p_size_or_error));
  return true;
}

void NetworkContext_ComputeHttpCacheSize_ProxyToResponder::Run(
    bool in_is_upper_bound, int64_t in_size_or_error) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::ComputeHttpCacheSize", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_upper_bound"), in_is_upper_bound,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("size_or_error"), in_size_or_error,
                        "<value of type int64_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ComputeHttpCacheSize_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ComputeHttpCacheSize_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->is_upper_bound = in_is_upper_bound;
  params->size_or_error = in_size_or_error;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ComputeHttpCacheSize");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearHostCache_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearHostCacheCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearHostCache_ProxyToResponder> proxy(
        new NetworkContext_ClearHostCache_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearHostCache_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearHostCache_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearHostCache_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearHostCacheCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearHostCache_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearHostCache_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearHostCache_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearHostCache_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 14, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearHostCache_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearHostCache");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearHostCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearHostCache_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearHostCache");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearHttpAuthCache_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearHttpAuthCacheCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearHttpAuthCache_ProxyToResponder> proxy(
        new NetworkContext_ClearHttpAuthCache_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearHttpAuthCache_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearHttpAuthCache_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearHttpAuthCache_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearHttpAuthCacheCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearHttpAuthCache_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearHttpAuthCache_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearHttpAuthCache_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearHttpAuthCache_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 15, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearHttpAuthCache_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearHttpAuthCache");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearHttpAuthCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearHttpAuthCache_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearHttpAuthCache");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearReportingCacheReports_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearReportingCacheReportsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearReportingCacheReports_ProxyToResponder> proxy(
        new NetworkContext_ClearReportingCacheReports_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearReportingCacheReports_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearReportingCacheReports_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearReportingCacheReports_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearReportingCacheReportsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearReportingCacheReports_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearReportingCacheReports_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearReportingCacheReports_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearReportingCacheReports_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 16, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearReportingCacheReports_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearReportingCacheReports");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearReportingCacheReports_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearReportingCacheReports_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearReportingCacheReports");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearReportingCacheClients_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearReportingCacheClientsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearReportingCacheClients_ProxyToResponder> proxy(
        new NetworkContext_ClearReportingCacheClients_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearReportingCacheClients_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearReportingCacheClients_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearReportingCacheClients_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearReportingCacheClientsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearReportingCacheClients_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearReportingCacheClients_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearReportingCacheClients_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearReportingCacheClients_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 17, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearReportingCacheClients_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearReportingCacheClients");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearReportingCacheClients_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearReportingCacheClients_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearReportingCacheClients");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearNetworkErrorLogging_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearNetworkErrorLoggingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearNetworkErrorLogging_ProxyToResponder> proxy(
        new NetworkContext_ClearNetworkErrorLogging_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearNetworkErrorLogging_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearNetworkErrorLogging_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearNetworkErrorLogging_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearNetworkErrorLoggingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearNetworkErrorLogging_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearNetworkErrorLogging_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearNetworkErrorLogging_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearNetworkErrorLogging_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 18, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearNetworkErrorLogging_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearNetworkErrorLogging");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearNetworkErrorLogging_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearNetworkErrorLogging_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearNetworkErrorLogging");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearDomainReliability_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearDomainReliabilityCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearDomainReliability_ProxyToResponder> proxy(
        new NetworkContext_ClearDomainReliability_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearDomainReliability_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearDomainReliability_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearDomainReliability_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearDomainReliabilityCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearDomainReliability_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearDomainReliability_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearDomainReliability_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearDomainReliability_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 19, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearDomainReliability_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearDomainReliability");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearDomainReliability_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearDomainReliability_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearDomainReliability");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_CloseAllConnections_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::CloseAllConnectionsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_CloseAllConnections_ProxyToResponder> proxy(
        new NetworkContext_CloseAllConnections_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_CloseAllConnections_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_CloseAllConnections_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_CloseAllConnections_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::CloseAllConnectionsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_CloseAllConnections_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_CloseAllConnections_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_CloseAllConnections_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_CloseAllConnections_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 24, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_CloseAllConnections_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::CloseAllConnections");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CloseAllConnections_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CloseAllConnections_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CloseAllConnections");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_CloseIdleConnections_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::CloseIdleConnectionsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_CloseIdleConnections_ProxyToResponder> proxy(
        new NetworkContext_CloseIdleConnections_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_CloseIdleConnections_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_CloseIdleConnections_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_CloseIdleConnections_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::CloseIdleConnectionsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_CloseIdleConnections_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_CloseIdleConnections_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_CloseIdleConnections_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_CloseIdleConnections_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 25, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_CloseIdleConnections_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::CloseIdleConnections");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CloseIdleConnections_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CloseIdleConnections_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CloseIdleConnections");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_AddExpectCT_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::AddExpectCTCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_AddExpectCT_ProxyToResponder> proxy(
        new NetworkContext_AddExpectCT_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_AddExpectCT_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_AddExpectCT_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_AddExpectCT_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::AddExpectCTCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);
};

bool NetworkContext_AddExpectCT_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_AddExpectCT_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_AddExpectCT_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  NetworkContext_AddExpectCT_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 30, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void NetworkContext_AddExpectCT_ProxyToResponder::Run(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::AddExpectCT", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddExpectCT_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddExpectCT_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddExpectCT");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_SetExpectCTTestReport_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::SetExpectCTTestReportCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_SetExpectCTTestReport_ProxyToResponder> proxy(
        new NetworkContext_SetExpectCTTestReport_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_SetExpectCTTestReport_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_SetExpectCTTestReport_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_SetExpectCTTestReport_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::SetExpectCTTestReportCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);
};

bool NetworkContext_SetExpectCTTestReport_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_SetExpectCTTestReport_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_SetExpectCTTestReport_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  NetworkContext_SetExpectCTTestReport_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 31, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void NetworkContext_SetExpectCTTestReport_ProxyToResponder::Run(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::SetExpectCTTestReport", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetExpectCTTestReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetExpectCTTestReport_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetExpectCTTestReport");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_GetExpectCTState_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::GetExpectCTStateCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_GetExpectCTState_ProxyToResponder> proxy(
        new NetworkContext_GetExpectCTState_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_GetExpectCTState_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_GetExpectCTState_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_GetExpectCTState_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::GetExpectCTStateCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value::Dict in_state);
};

bool NetworkContext_GetExpectCTState_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_GetExpectCTState_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_GetExpectCTState_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::Value::Dict p_state{};
  NetworkContext_GetExpectCTState_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadState(&p_state))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 32, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_state));
  return true;
}

void NetworkContext_GetExpectCTState_ProxyToResponder::Run(
    ::base::Value::Dict in_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::GetExpectCTState", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("state"), in_state,
                        "<value of type ::base::Value::Dict>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetExpectCTState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetExpectCTState_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->state)::BaseType> state_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::DictionaryValueDataView>(
      in_state, state_fragment);
  params->state.Set(
      state_fragment.is_null() ? nullptr : state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null state in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetExpectCTState");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_CreateTCPServerSocket_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::CreateTCPServerSocketCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_CreateTCPServerSocket_ProxyToResponder> proxy(
        new NetworkContext_CreateTCPServerSocket_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_CreateTCPServerSocket_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_CreateTCPServerSocket_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_CreateTCPServerSocket_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::CreateTCPServerSocketCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result, const absl::optional<::net::IPEndPoint>& in_local_addr_out);
};

bool NetworkContext_CreateTCPServerSocket_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_CreateTCPServerSocket_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_CreateTCPServerSocket_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  absl::optional<::net::IPEndPoint> p_local_addr_out{};
  NetworkContext_CreateTCPServerSocket_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (success && !input_data_view.ReadLocalAddrOut(&p_local_addr_out))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 34, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_local_addr_out));
  return true;
}

void NetworkContext_CreateTCPServerSocket_ProxyToResponder::Run(
    int32_t in_result, const absl::optional<::net::IPEndPoint>& in_local_addr_out) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::CreateTCPServerSocket", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_addr_out"), in_local_addr_out,
                        "<value of type const absl::optional<::net::IPEndPoint>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateTCPServerSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateTCPServerSocket_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;
  mojo::internal::MessageFragment<
      typename decltype(params->local_addr_out)::BaseType> local_addr_out_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_local_addr_out, local_addr_out_fragment);
  params->local_addr_out.Set(
      local_addr_out_fragment.is_null() ? nullptr : local_addr_out_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateTCPServerSocket");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_CreateTCPConnectedSocket_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::CreateTCPConnectedSocketCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_CreateTCPConnectedSocket_ProxyToResponder> proxy(
        new NetworkContext_CreateTCPConnectedSocket_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_CreateTCPConnectedSocket_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_CreateTCPConnectedSocket_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_CreateTCPConnectedSocket_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::CreateTCPConnectedSocketCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result, const absl::optional<::net::IPEndPoint>& in_local_addr, const absl::optional<::net::IPEndPoint>& in_peer_addr, ::mojo::ScopedDataPipeConsumerHandle in_receive_stream, ::mojo::ScopedDataPipeProducerHandle in_send_stream);
};

bool NetworkContext_CreateTCPConnectedSocket_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_CreateTCPConnectedSocket_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_CreateTCPConnectedSocket_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  absl::optional<::net::IPEndPoint> p_local_addr{};
  absl::optional<::net::IPEndPoint> p_peer_addr{};
  ::mojo::ScopedDataPipeConsumerHandle p_receive_stream{};
  ::mojo::ScopedDataPipeProducerHandle p_send_stream{};
  NetworkContext_CreateTCPConnectedSocket_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (success && !input_data_view.ReadLocalAddr(&p_local_addr))
    success = false;
  if (success && !input_data_view.ReadPeerAddr(&p_peer_addr))
    success = false;
  if (success)
    p_receive_stream = input_data_view.TakeReceiveStream();
  if (success)
    p_send_stream = input_data_view.TakeSendStream();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 35, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_local_addr), 
std::move(p_peer_addr), 
std::move(p_receive_stream), 
std::move(p_send_stream));
  return true;
}

void NetworkContext_CreateTCPConnectedSocket_ProxyToResponder::Run(
    int32_t in_result, const absl::optional<::net::IPEndPoint>& in_local_addr, const absl::optional<::net::IPEndPoint>& in_peer_addr, ::mojo::ScopedDataPipeConsumerHandle in_receive_stream, ::mojo::ScopedDataPipeProducerHandle in_send_stream) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::CreateTCPConnectedSocket", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_addr"), in_local_addr,
                        "<value of type const absl::optional<::net::IPEndPoint>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("peer_addr"), in_peer_addr,
                        "<value of type const absl::optional<::net::IPEndPoint>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receive_stream"), in_receive_stream,
                        "<value of type ::mojo::ScopedDataPipeConsumerHandle>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("send_stream"), in_send_stream,
                        "<value of type ::mojo::ScopedDataPipeProducerHandle>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateTCPConnectedSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateTCPConnectedSocket_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;
  mojo::internal::MessageFragment<
      typename decltype(params->local_addr)::BaseType> local_addr_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_local_addr, local_addr_fragment);
  params->local_addr.Set(
      local_addr_fragment.is_null() ? nullptr : local_addr_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->peer_addr)::BaseType> peer_addr_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_peer_addr, peer_addr_fragment);
  params->peer_addr.Set(
      peer_addr_fragment.is_null() ? nullptr : peer_addr_fragment.data());
  mojo::internal::Serialize<mojo::ScopedDataPipeConsumerHandle>(
      in_receive_stream, &params->receive_stream, &params.message());
  mojo::internal::Serialize<mojo::ScopedDataPipeProducerHandle>(
      in_send_stream, &params->send_stream, &params.message());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateTCPConnectedSocket");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_CreateTCPBoundSocket_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::CreateTCPBoundSocketCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_CreateTCPBoundSocket_ProxyToResponder> proxy(
        new NetworkContext_CreateTCPBoundSocket_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_CreateTCPBoundSocket_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_CreateTCPBoundSocket_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_CreateTCPBoundSocket_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::CreateTCPBoundSocketCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_result, const absl::optional<::net::IPEndPoint>& in_local_addr);
};

bool NetworkContext_CreateTCPBoundSocket_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_CreateTCPBoundSocket_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_CreateTCPBoundSocket_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_result{};
  absl::optional<::net::IPEndPoint> p_local_addr{};
  NetworkContext_CreateTCPBoundSocket_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (success && !input_data_view.ReadLocalAddr(&p_local_addr))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 36, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_local_addr));
  return true;
}

void NetworkContext_CreateTCPBoundSocket_ProxyToResponder::Run(
    int32_t in_result, const absl::optional<::net::IPEndPoint>& in_local_addr) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::CreateTCPBoundSocket", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_addr"), in_local_addr,
                        "<value of type const absl::optional<::net::IPEndPoint>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_CreateTCPBoundSocket_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_CreateTCPBoundSocket_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;
  mojo::internal::MessageFragment<
      typename decltype(params->local_addr)::BaseType> local_addr_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::IPEndPointDataView>(
      in_local_addr, local_addr_fragment);
  params->local_addr.Set(
      local_addr_fragment.is_null() ? nullptr : local_addr_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("CreateTCPBoundSocket");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ForceReloadProxyConfig_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ForceReloadProxyConfigCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ForceReloadProxyConfig_ProxyToResponder> proxy(
        new NetworkContext_ForceReloadProxyConfig_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ForceReloadProxyConfig_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ForceReloadProxyConfig_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ForceReloadProxyConfig_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ForceReloadProxyConfigCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ForceReloadProxyConfig_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ForceReloadProxyConfig_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ForceReloadProxyConfig_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ForceReloadProxyConfig_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 39, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ForceReloadProxyConfig_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ForceReloadProxyConfig");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ForceReloadProxyConfig_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ForceReloadProxyConfig_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ForceReloadProxyConfig");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_ClearBadProxiesCache_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ClearBadProxiesCacheCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ClearBadProxiesCache_ProxyToResponder> proxy(
        new NetworkContext_ClearBadProxiesCache_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ClearBadProxiesCache_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ClearBadProxiesCache_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ClearBadProxiesCache_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ClearBadProxiesCacheCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ClearBadProxiesCache_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ClearBadProxiesCache_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ClearBadProxiesCache_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ClearBadProxiesCache_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 40, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ClearBadProxiesCache_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ClearBadProxiesCache");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ClearBadProxiesCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ClearBadProxiesCache_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ClearBadProxiesCache");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_VerifyCertForSignedExchange_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::VerifyCertForSignedExchangeCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_VerifyCertForSignedExchange_ProxyToResponder> proxy(
        new NetworkContext_VerifyCertForSignedExchange_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_VerifyCertForSignedExchange_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_VerifyCertForSignedExchange_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_VerifyCertForSignedExchange_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::VerifyCertForSignedExchangeCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_error_code, const ::net::CertVerifyResult& in_cv_result, bool in_pkp_bypassed, const std::string& in_pinning_failure_log);
};

bool NetworkContext_VerifyCertForSignedExchange_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_VerifyCertForSignedExchange_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_VerifyCertForSignedExchange_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_error_code{};
  ::net::CertVerifyResult p_cv_result{};
  bool p_pkp_bypassed{};
  std::string p_pinning_failure_log{};
  NetworkContext_VerifyCertForSignedExchange_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_error_code = input_data_view.error_code();
  if (success && !input_data_view.ReadCvResult(&p_cv_result))
    success = false;
  if (success)
    p_pkp_bypassed = input_data_view.pkp_bypassed();
  if (success && !input_data_view.ReadPinningFailureLog(&p_pinning_failure_log))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 49, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_error_code), 
std::move(p_cv_result), 
std::move(p_pkp_bypassed), 
std::move(p_pinning_failure_log));
  return true;
}

void NetworkContext_VerifyCertForSignedExchange_ProxyToResponder::Run(
    int32_t in_error_code, const ::net::CertVerifyResult& in_cv_result, bool in_pkp_bypassed, const std::string& in_pinning_failure_log) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::VerifyCertForSignedExchange", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_code"), in_error_code,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cv_result"), in_cv_result,
                        "<value of type const ::net::CertVerifyResult&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pkp_bypassed"), in_pkp_bypassed,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pinning_failure_log"), in_pinning_failure_log,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_VerifyCertForSignedExchange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_VerifyCertForSignedExchange_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->error_code = in_error_code;
  mojo::internal::MessageFragment<
      typename decltype(params->cv_result)::BaseType> cv_result_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CertVerifyResultDataView>(
      in_cv_result, cv_result_fragment);
  params->cv_result.Set(
      cv_result_fragment.is_null() ? nullptr : cv_result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cv_result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cv_result in ");
  params->pkp_bypassed = in_pkp_bypassed;
  mojo::internal::MessageFragment<
      typename decltype(params->pinning_failure_log)::BaseType> pinning_failure_log_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_pinning_failure_log, pinning_failure_log_fragment);
  params->pinning_failure_log.Set(
      pinning_failure_log_fragment.is_null() ? nullptr : pinning_failure_log_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pinning_failure_log.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pinning_failure_log in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("VerifyCertForSignedExchange");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_AddHSTS_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::AddHSTSCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_AddHSTS_ProxyToResponder> proxy(
        new NetworkContext_AddHSTS_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_AddHSTS_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_AddHSTS_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_AddHSTS_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::AddHSTSCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_AddHSTS_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_AddHSTS_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_AddHSTS_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_AddHSTS_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 50, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_AddHSTS_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::AddHSTS");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddHSTS_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddHSTS_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddHSTS");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_IsHSTSActiveForHost_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::IsHSTSActiveForHostCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_IsHSTSActiveForHost_ProxyToResponder> proxy(
        new NetworkContext_IsHSTSActiveForHost_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_IsHSTSActiveForHost_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_IsHSTSActiveForHost_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_IsHSTSActiveForHost_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::IsHSTSActiveForHostCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_result);
};

bool NetworkContext_IsHSTSActiveForHost_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_IsHSTSActiveForHost_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_IsHSTSActiveForHost_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_result{};
  NetworkContext_IsHSTSActiveForHost_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 51, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void NetworkContext_IsHSTSActiveForHost_ProxyToResponder::Run(
    bool in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::IsHSTSActiveForHost", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_IsHSTSActiveForHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_IsHSTSActiveForHost_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("IsHSTSActiveForHost");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_GetHSTSState_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::GetHSTSStateCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_GetHSTSState_ProxyToResponder> proxy(
        new NetworkContext_GetHSTSState_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_GetHSTSState_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_GetHSTSState_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_GetHSTSState_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::GetHSTSStateCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value::Dict in_state);
};

bool NetworkContext_GetHSTSState_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_GetHSTSState_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_GetHSTSState_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::Value::Dict p_state{};
  NetworkContext_GetHSTSState_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadState(&p_state))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 52, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_state));
  return true;
}

void NetworkContext_GetHSTSState_ProxyToResponder::Run(
    ::base::Value::Dict in_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::GetHSTSState", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("state"), in_state,
                        "<value of type ::base::Value::Dict>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_GetHSTSState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_GetHSTSState_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->state)::BaseType> state_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::DictionaryValueDataView>(
      in_state, state_fragment);
  params->state.Set(
      state_fragment.is_null() ? nullptr : state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null state in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("GetHSTSState");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::SetCorsOriginAccessListsForOriginCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder> proxy(
        new NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::SetCorsOriginAccessListsForOriginCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_SetCorsOriginAccessListsForOrigin_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_SetCorsOriginAccessListsForOrigin_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_SetCorsOriginAccessListsForOrigin_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_SetCorsOriginAccessListsForOrigin_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 53, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::SetCorsOriginAccessListsForOrigin");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SetCorsOriginAccessListsForOrigin_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SetCorsOriginAccessListsForOrigin");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_DeleteDynamicDataForHost_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::DeleteDynamicDataForHostCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_DeleteDynamicDataForHost_ProxyToResponder> proxy(
        new NetworkContext_DeleteDynamicDataForHost_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_DeleteDynamicDataForHost_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_DeleteDynamicDataForHost_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_DeleteDynamicDataForHost_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::DeleteDynamicDataForHostCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_result);
};

bool NetworkContext_DeleteDynamicDataForHost_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_DeleteDynamicDataForHost_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_DeleteDynamicDataForHost_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_result{};
  NetworkContext_DeleteDynamicDataForHost_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_result = input_data_view.result();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 54, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void NetworkContext_DeleteDynamicDataForHost_ProxyToResponder::Run(
    bool in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::DeleteDynamicDataForHost", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_DeleteDynamicDataForHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_DeleteDynamicDataForHost_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->result = in_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("DeleteDynamicDataForHost");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::SaveHttpAuthCacheProxyEntriesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder> proxy(
        new NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::SaveHttpAuthCacheProxyEntriesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::base::UnguessableToken& in_cache_key);
};

bool NetworkContext_SaveHttpAuthCacheProxyEntries_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_SaveHttpAuthCacheProxyEntries_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_SaveHttpAuthCacheProxyEntries_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::UnguessableToken p_cache_key{};
  NetworkContext_SaveHttpAuthCacheProxyEntries_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadCacheKey(&p_cache_key))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 56, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_cache_key));
  return true;
}

void NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder::Run(
    const ::base::UnguessableToken& in_cache_key) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::SaveHttpAuthCacheProxyEntries", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("cache_key"), in_cache_key,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_SaveHttpAuthCacheProxyEntries_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->cache_key)::BaseType> cache_key_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_cache_key, cache_key_fragment);
  params->cache_key.Set(
      cache_key_fragment.is_null() ? nullptr : cache_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->cache_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null cache_key in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("SaveHttpAuthCacheProxyEntries");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::LoadHttpAuthCacheProxyEntriesCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder> proxy(
        new NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::LoadHttpAuthCacheProxyEntriesCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_LoadHttpAuthCacheProxyEntries_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_LoadHttpAuthCacheProxyEntries_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_LoadHttpAuthCacheProxyEntries_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_LoadHttpAuthCacheProxyEntries_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 57, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::LoadHttpAuthCacheProxyEntries");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_LoadHttpAuthCacheProxyEntries_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("LoadHttpAuthCacheProxyEntries");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_AddAuthCacheEntry_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::AddAuthCacheEntryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_AddAuthCacheEntry_ProxyToResponder> proxy(
        new NetworkContext_AddAuthCacheEntry_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_AddAuthCacheEntry_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_AddAuthCacheEntry_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_AddAuthCacheEntry_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::AddAuthCacheEntryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_AddAuthCacheEntry_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_AddAuthCacheEntry_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_AddAuthCacheEntry_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_AddAuthCacheEntry_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 58, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_AddAuthCacheEntry_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::AddAuthCacheEntry");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddAuthCacheEntry_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddAuthCacheEntry_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddAuthCacheEntry");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::LookupServerBasicAuthCredentialsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder> proxy(
        new NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::LookupServerBasicAuthCredentialsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<::net::AuthCredentials>& in_credentials);
};

bool NetworkContext_LookupServerBasicAuthCredentials_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_LookupServerBasicAuthCredentials_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_LookupServerBasicAuthCredentials_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<::net::AuthCredentials> p_credentials{};
  NetworkContext_LookupServerBasicAuthCredentials_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadCredentials(&p_credentials))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 60, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_credentials));
  return true;
}

void NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder::Run(
    const absl::optional<::net::AuthCredentials>& in_credentials) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::LookupServerBasicAuthCredentials", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("credentials"), in_credentials,
                        "<value of type const absl::optional<::net::AuthCredentials>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_LookupServerBasicAuthCredentials_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_LookupServerBasicAuthCredentials_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->credentials)::BaseType> credentials_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::AuthCredentialsDataView>(
      in_credentials, credentials_fragment);
  params->credentials.Set(
      credentials_fragment.is_null() ? nullptr : credentials_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("LookupServerBasicAuthCredentials");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::EnableStaticKeyPinningForTestingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder> proxy(
        new NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::EnableStaticKeyPinningForTestingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_EnableStaticKeyPinningForTesting_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_EnableStaticKeyPinningForTesting_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_EnableStaticKeyPinningForTesting_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_EnableStaticKeyPinningForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 61, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::EnableStaticKeyPinningForTesting");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_EnableStaticKeyPinningForTesting_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("EnableStaticKeyPinningForTesting");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkContext_EnableStaticKeyPinningForTesting_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_EnableStaticKeyPinningForTesting_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkContext_EnableStaticKeyPinningForTesting_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkContext_EnableStaticKeyPinningForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 61, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkContext_VerifyCertificateForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::VerifyCertificateForTestingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_VerifyCertificateForTesting_ProxyToResponder> proxy(
        new NetworkContext_VerifyCertificateForTesting_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_VerifyCertificateForTesting_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_VerifyCertificateForTesting_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_VerifyCertificateForTesting_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::VerifyCertificateForTestingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      int32_t in_error_code);
};

bool NetworkContext_VerifyCertificateForTesting_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_VerifyCertificateForTesting_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_VerifyCertificateForTesting_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  int32_t p_error_code{};
  NetworkContext_VerifyCertificateForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_error_code = input_data_view.error_code();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 62, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_error_code));
  return true;
}

void NetworkContext_VerifyCertificateForTesting_ProxyToResponder::Run(
    int32_t in_error_code) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply network::mojom::NetworkContext::VerifyCertificateForTesting", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_code"), in_error_code,
                        "<value of type int32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_VerifyCertificateForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_VerifyCertificateForTesting_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->error_code = in_error_code;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("VerifyCertificateForTesting");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::AddDomainReliabilityContextForTestingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder> proxy(
        new NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::AddDomainReliabilityContextForTestingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_AddDomainReliabilityContextForTesting_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_AddDomainReliabilityContextForTesting_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_AddDomainReliabilityContextForTesting_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_AddDomainReliabilityContextForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 63, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::AddDomainReliabilityContextForTesting");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_AddDomainReliabilityContextForTesting_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("AddDomainReliabilityContextForTesting");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkContext_AddDomainReliabilityContextForTesting_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_AddDomainReliabilityContextForTesting_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkContext_AddDomainReliabilityContextForTesting_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkContext_AddDomainReliabilityContextForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 63, true);
    return false;
  }
  *result_ = true;
  return true;
}
class NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static NetworkContext::ForceDomainReliabilityUploadsForTestingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder> proxy(
        new NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "NetworkContext::ForceDomainReliabilityUploadsForTestingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool NetworkContext_ForceDomainReliabilityUploadsForTesting_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParams_Data* params =
      reinterpret_cast<
          internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 64, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply network::mojom::NetworkContext::ForceDomainReliabilityUploadsForTesting");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::network::mojom::internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(NetworkContext::Name_);
  message.set_method_name("ForceDomainReliabilityUploadsForTesting");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool NetworkContext_ForceDomainReliabilityUploadsForTesting_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParams_Data* params =
      reinterpret_cast<internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        NetworkContext::Name_, 64, true);
    return false;
  }
  *result_ = true;
  return true;
}

// static
bool NetworkContextStubDispatch::Accept(
    NetworkContext* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kNetworkContext_SetClient_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetClient_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetClient_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<NetworkContextClient> p_client{};
      NetworkContext_SetClient_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetClient(
std::move(p_client));
      return true;
    }
    case internal::kNetworkContext_CreateURLLoaderFactory_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateURLLoaderFactory_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateURLLoaderFactory_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::URLLoaderFactory> p_url_loader_factory{};
      URLLoaderFactoryParamsPtr p_params{};
      NetworkContext_CreateURLLoaderFactory_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_url_loader_factory =
            input_data_view.TakeUrlLoaderFactory<decltype(p_url_loader_factory)>();
      }
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateURLLoaderFactory(
std::move(p_url_loader_factory), 
std::move(p_params));
      return true;
    }
    case internal::kNetworkContext_ResetURLLoaderFactories_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_ResetURLLoaderFactories_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_ResetURLLoaderFactories_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      NetworkContext_ResetURLLoaderFactories_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResetURLLoaderFactories();
      return true;
    }
    case internal::kNetworkContext_GetCookieManager_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_GetCookieManager_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_GetCookieManager_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::CookieManager> p_cookie_manager{};
      NetworkContext_GetCookieManager_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_cookie_manager =
            input_data_view.TakeCookieManager<decltype(p_cookie_manager)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetCookieManager(
std::move(p_cookie_manager));
      return true;
    }
    case internal::kNetworkContext_GetRestrictedCookieManager_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_GetRestrictedCookieManager_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_GetRestrictedCookieManager_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::RestrictedCookieManager> p_restricted_cookie_manager{};
      ::network::mojom::RestrictedCookieManagerRole p_role{};
      ::url::Origin p_origin{};
      ::net::IsolationInfo p_isolation_info{};
      ::mojo::PendingRemote<::network::mojom::CookieAccessObserver> p_cookie_observer{};
      NetworkContext_GetRestrictedCookieManager_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_restricted_cookie_manager =
            input_data_view.TakeRestrictedCookieManager<decltype(p_restricted_cookie_manager)>();
      }
      if (success && !input_data_view.ReadRole(&p_role))
        success = false;
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success && !input_data_view.ReadIsolationInfo(&p_isolation_info))
        success = false;
      if (success) {
        p_cookie_observer =
            input_data_view.TakeCookieObserver<decltype(p_cookie_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetRestrictedCookieManager(
std::move(p_restricted_cookie_manager), 
std::move(p_role), 
std::move(p_origin), 
std::move(p_isolation_info), 
std::move(p_cookie_observer));
      return true;
    }
    case internal::kNetworkContext_GetTrustTokenQueryAnswerer_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_GetTrustTokenQueryAnswerer_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_GetTrustTokenQueryAnswerer_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::TrustTokenQueryAnswerer> p_trust_token_query_answerer{};
      ::url::Origin p_top_frame_origin{};
      NetworkContext_GetTrustTokenQueryAnswerer_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_trust_token_query_answerer =
            input_data_view.TakeTrustTokenQueryAnswerer<decltype(p_trust_token_query_answerer)>();
      }
      if (success && !input_data_view.ReadTopFrameOrigin(&p_top_frame_origin))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetTrustTokenQueryAnswerer(
std::move(p_trust_token_query_answerer), 
std::move(p_top_frame_origin));
      return true;
    }
    case internal::kNetworkContext_ClearTrustTokenData_Name: {
      break;
    }
    case internal::kNetworkContext_GetStoredTrustTokenCounts_Name: {
      break;
    }
    case internal::kNetworkContext_DeleteStoredTrustTokens_Name: {
      break;
    }
    case internal::kNetworkContext_SetBlockTrustTokens_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetBlockTrustTokens_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetBlockTrustTokens_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_block{};
      NetworkContext_SetBlockTrustTokens_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_block = input_data_view.block();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetBlockTrustTokens(
std::move(p_block));
      return true;
    }
    case internal::kNetworkContext_ClearNetworkingHistoryBetween_Name: {
      break;
    }
    case internal::kNetworkContext_ClearHttpCache_Name: {
      break;
    }
    case internal::kNetworkContext_ComputeHttpCacheSize_Name: {
      break;
    }
    case internal::kNetworkContext_NotifyExternalCacheHit_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_NotifyExternalCacheHit_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_NotifyExternalCacheHit_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      std::string p_http_method{};
      ::net::NetworkIsolationKey p_key{};
      bool p_is_subframe_document_resource{};
      bool p_include_credentials{};
      NetworkContext_NotifyExternalCacheHit_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadHttpMethod(&p_http_method))
        success = false;
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (success)
        p_is_subframe_document_resource = input_data_view.is_subframe_document_resource();
      if (success)
        p_include_credentials = input_data_view.include_credentials();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->NotifyExternalCacheHit(
std::move(p_url), 
std::move(p_http_method), 
std::move(p_key), 
std::move(p_is_subframe_document_resource), 
std::move(p_include_credentials));
      return true;
    }
    case internal::kNetworkContext_ClearHostCache_Name: {
      break;
    }
    case internal::kNetworkContext_ClearHttpAuthCache_Name: {
      break;
    }
    case internal::kNetworkContext_ClearReportingCacheReports_Name: {
      break;
    }
    case internal::kNetworkContext_ClearReportingCacheClients_Name: {
      break;
    }
    case internal::kNetworkContext_ClearNetworkErrorLogging_Name: {
      break;
    }
    case internal::kNetworkContext_ClearDomainReliability_Name: {
      break;
    }
    case internal::kNetworkContext_SetDocumentReportingEndpoints_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetDocumentReportingEndpoints_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetDocumentReportingEndpoints_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::UnguessableToken p_reporting_source{};
      ::url::Origin p_origin{};
      ::net::IsolationInfo p_isolation_info{};
      base::flat_map<std::string, std::string> p_endpoints{};
      NetworkContext_SetDocumentReportingEndpoints_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReportingSource(&p_reporting_source))
        success = false;
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success && !input_data_view.ReadIsolationInfo(&p_isolation_info))
        success = false;
      if (success && !input_data_view.ReadEndpoints(&p_endpoints))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetDocumentReportingEndpoints(
std::move(p_reporting_source), 
std::move(p_origin), 
std::move(p_isolation_info), 
std::move(p_endpoints));
      return true;
    }
    case internal::kNetworkContext_SendReportsAndRemoveSource_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SendReportsAndRemoveSource_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SendReportsAndRemoveSource_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::UnguessableToken p_reporting_source{};
      NetworkContext_SendReportsAndRemoveSource_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReportingSource(&p_reporting_source))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendReportsAndRemoveSource(
std::move(p_reporting_source));
      return true;
    }
    case internal::kNetworkContext_QueueReport_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_QueueReport_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_QueueReport_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_type{};
      std::string p_group{};
      ::GURL p_url{};
      absl::optional<::base::UnguessableToken> p_reporting_source{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      absl::optional<std::string> p_user_agent{};
      ::base::Value::Dict p_body{};
      NetworkContext_QueueReport_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (success && !input_data_view.ReadGroup(&p_group))
        success = false;
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadReportingSource(&p_reporting_source))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success && !input_data_view.ReadUserAgent(&p_user_agent))
        success = false;
      if (success && !input_data_view.ReadBody(&p_body))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->QueueReport(
std::move(p_type), 
std::move(p_group), 
std::move(p_url), 
std::move(p_reporting_source), 
std::move(p_network_isolation_key), 
std::move(p_user_agent), 
std::move(p_body));
      return true;
    }
    case internal::kNetworkContext_QueueSignedExchangeReport_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_QueueSignedExchangeReport_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_QueueSignedExchangeReport_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SignedExchangeReportPtr p_report{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      NetworkContext_QueueSignedExchangeReport_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReport(&p_report))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->QueueSignedExchangeReport(
std::move(p_report), 
std::move(p_network_isolation_key));
      return true;
    }
    case internal::kNetworkContext_CloseAllConnections_Name: {
      break;
    }
    case internal::kNetworkContext_CloseIdleConnections_Name: {
      break;
    }
    case internal::kNetworkContext_SetNetworkConditions_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetNetworkConditions_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetNetworkConditions_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::base::UnguessableToken p_throttling_profile_id{};
      NetworkConditionsPtr p_conditions{};
      NetworkContext_SetNetworkConditions_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadThrottlingProfileId(&p_throttling_profile_id))
        success = false;
      if (success && !input_data_view.ReadConditions(&p_conditions))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNetworkConditions(
std::move(p_throttling_profile_id), 
std::move(p_conditions));
      return true;
    }
    case internal::kNetworkContext_SetAcceptLanguage_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetAcceptLanguage_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetAcceptLanguage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_new_accept_language{};
      NetworkContext_SetAcceptLanguage_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadNewAcceptLanguage(&p_new_accept_language))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetAcceptLanguage(
std::move(p_new_accept_language));
      return true;
    }
    case internal::kNetworkContext_SetEnableReferrers_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetEnableReferrers_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetEnableReferrers_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_enable_referrers{};
      NetworkContext_SetEnableReferrers_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_enable_referrers = input_data_view.enable_referrers();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 28, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetEnableReferrers(
std::move(p_enable_referrers));
      return true;
    }
    case internal::kNetworkContext_SetCTPolicy_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetCTPolicy_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetCTPolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      CTPolicyPtr p_ct_policy{};
      NetworkContext_SetCTPolicy_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCtPolicy(&p_ct_policy))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 29, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCTPolicy(
std::move(p_ct_policy));
      return true;
    }
    case internal::kNetworkContext_AddExpectCT_Name: {
      break;
    }
    case internal::kNetworkContext_SetExpectCTTestReport_Name: {
      break;
    }
    case internal::kNetworkContext_GetExpectCTState_Name: {
      break;
    }
    case internal::kNetworkContext_CreateUDPSocket_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateUDPSocket_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateUDPSocket_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::UDPSocket> p_receiver{};
      ::mojo::PendingRemote<::network::mojom::UDPSocketListener> p_listener{};
      NetworkContext_CreateUDPSocket_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (success) {
        p_listener =
            input_data_view.TakeListener<decltype(p_listener)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 33, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateUDPSocket(
std::move(p_receiver), 
std::move(p_listener));
      return true;
    }
    case internal::kNetworkContext_CreateTCPServerSocket_Name: {
      break;
    }
    case internal::kNetworkContext_CreateTCPConnectedSocket_Name: {
      break;
    }
    case internal::kNetworkContext_CreateTCPBoundSocket_Name: {
      break;
    }
    case internal::kNetworkContext_CreateProxyResolvingSocketFactory_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateProxyResolvingSocketFactory_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateProxyResolvingSocketFactory_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::ProxyResolvingSocketFactory> p_factory{};
      NetworkContext_CreateProxyResolvingSocketFactory_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_factory =
            input_data_view.TakeFactory<decltype(p_factory)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 37, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateProxyResolvingSocketFactory(
std::move(p_factory));
      return true;
    }
    case internal::kNetworkContext_LookUpProxyForURL_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_LookUpProxyForURL_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_LookUpProxyForURL_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      ::mojo::PendingRemote<::network::mojom::ProxyLookupClient> p_proxy_lookup_client{};
      NetworkContext_LookUpProxyForURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success) {
        p_proxy_lookup_client =
            input_data_view.TakeProxyLookupClient<decltype(p_proxy_lookup_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 38, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LookUpProxyForURL(
std::move(p_url), 
std::move(p_network_isolation_key), 
std::move(p_proxy_lookup_client));
      return true;
    }
    case internal::kNetworkContext_ForceReloadProxyConfig_Name: {
      break;
    }
    case internal::kNetworkContext_ClearBadProxiesCache_Name: {
      break;
    }
    case internal::kNetworkContext_CreateWebSocket_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateWebSocket_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateWebSocket_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      std::vector<std::string> p_requested_protocols{};
      ::net::SiteForCookies p_site_for_cookies{};
      ::net::IsolationInfo p_isolation_info{};
      std::vector<::network::mojom::HttpHeaderPtr> p_additional_headers{};
      int32_t p_process_id{};
      ::url::Origin p_origin{};
      uint32_t p_options{};
      ::net::MutableNetworkTrafficAnnotationTag p_traffic_annotation{};
      ::mojo::PendingRemote<::network::mojom::WebSocketHandshakeClient> p_handshake_client{};
      ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver> p_url_loader_network_observer{};
      ::mojo::PendingRemote<::network::mojom::WebSocketAuthenticationHandler> p_auth_handler{};
      ::mojo::PendingRemote<TrustedHeaderClient> p_header_client{};
      absl::optional<::base::UnguessableToken> p_throttling_profile_id{};
      NetworkContext_CreateWebSocket_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadRequestedProtocols(&p_requested_protocols))
        success = false;
      if (success && !input_data_view.ReadSiteForCookies(&p_site_for_cookies))
        success = false;
      if (success && !input_data_view.ReadIsolationInfo(&p_isolation_info))
        success = false;
      if (success && !input_data_view.ReadAdditionalHeaders(&p_additional_headers))
        success = false;
      if (success)
        p_process_id = input_data_view.process_id();
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success)
        p_options = input_data_view.options();
      if (success && !input_data_view.ReadTrafficAnnotation(&p_traffic_annotation))
        success = false;
      if (success) {
        p_handshake_client =
            input_data_view.TakeHandshakeClient<decltype(p_handshake_client)>();
      }
      if (success) {
        p_url_loader_network_observer =
            input_data_view.TakeUrlLoaderNetworkObserver<decltype(p_url_loader_network_observer)>();
      }
      if (success) {
        p_auth_handler =
            input_data_view.TakeAuthHandler<decltype(p_auth_handler)>();
      }
      if (success) {
        p_header_client =
            input_data_view.TakeHeaderClient<decltype(p_header_client)>();
      }
      if (success && !input_data_view.ReadThrottlingProfileId(&p_throttling_profile_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 41, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateWebSocket(
std::move(p_url), 
std::move(p_requested_protocols), 
std::move(p_site_for_cookies), 
std::move(p_isolation_info), 
std::move(p_additional_headers), 
std::move(p_process_id), 
std::move(p_origin), 
std::move(p_options), 
std::move(p_traffic_annotation), 
std::move(p_handshake_client), 
std::move(p_url_loader_network_observer), 
std::move(p_auth_handler), 
std::move(p_header_client), 
std::move(p_throttling_profile_id));
      return true;
    }
    case internal::kNetworkContext_CreateWebTransport_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateWebTransport_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateWebTransport_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      ::url::Origin p_origin{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      std::vector<::network::mojom::WebTransportCertificateFingerprintPtr> p_fingerprints{};
      ::mojo::PendingRemote<::network::mojom::WebTransportHandshakeClient> p_handshake_client{};
      NetworkContext_CreateWebTransport_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success && !input_data_view.ReadFingerprints(&p_fingerprints))
        success = false;
      if (success) {
        p_handshake_client =
            input_data_view.TakeHandshakeClient<decltype(p_handshake_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 42, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateWebTransport(
std::move(p_url), 
std::move(p_origin), 
std::move(p_network_isolation_key), 
std::move(p_fingerprints), 
std::move(p_handshake_client));
      return true;
    }
    case internal::kNetworkContext_CreateNetLogExporter_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateNetLogExporter_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateNetLogExporter_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::NetLogExporter> p_receiver{};
      NetworkContext_CreateNetLogExporter_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 43, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateNetLogExporter(
std::move(p_receiver));
      return true;
    }
    case internal::kNetworkContext_PreconnectSockets_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_PreconnectSockets_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_PreconnectSockets_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_num_streams{};
      ::GURL p_url{};
      bool p_allow_credentials{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      NetworkContext_PreconnectSockets_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_num_streams = input_data_view.num_streams();
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_allow_credentials = input_data_view.allow_credentials();
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 44, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PreconnectSockets(
std::move(p_num_streams), 
std::move(p_url), 
std::move(p_allow_credentials), 
std::move(p_network_isolation_key));
      return true;
    }
    case internal::kNetworkContext_CreateP2PSocketManager_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateP2PSocketManager_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateP2PSocketManager_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::net::NetworkIsolationKey p_network_isolation_key{};
      ::mojo::PendingRemote<::network::mojom::P2PTrustedSocketManagerClient> p_client{};
      ::mojo::PendingReceiver<::network::mojom::P2PTrustedSocketManager> p_trusted_socket_manager{};
      ::mojo::PendingReceiver<::network::mojom::P2PSocketManager> p_socket_manager{};
      NetworkContext_CreateP2PSocketManager_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (success) {
        p_trusted_socket_manager =
            input_data_view.TakeTrustedSocketManager<decltype(p_trusted_socket_manager)>();
      }
      if (success) {
        p_socket_manager =
            input_data_view.TakeSocketManager<decltype(p_socket_manager)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 45, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateP2PSocketManager(
std::move(p_network_isolation_key), 
std::move(p_client), 
std::move(p_trusted_socket_manager), 
std::move(p_socket_manager));
      return true;
    }
    case internal::kNetworkContext_CreateMdnsResponder_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateMdnsResponder_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateMdnsResponder_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::network::mojom::MdnsResponder> p_responder_receiver{};
      NetworkContext_CreateMdnsResponder_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_responder_receiver =
            input_data_view.TakeResponderReceiver<decltype(p_responder_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 46, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateMdnsResponder(
std::move(p_responder_receiver));
      return true;
    }
    case internal::kNetworkContext_ResolveHost_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_ResolveHost_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_ResolveHost_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::net::HostPortPair p_host{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      ::network::mojom::ResolveHostParametersPtr p_optional_parameters{};
      ::mojo::PendingRemote<::network::mojom::ResolveHostClient> p_response_client{};
      NetworkContext_ResolveHost_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHost(&p_host))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success && !input_data_view.ReadOptionalParameters(&p_optional_parameters))
        success = false;
      if (success) {
        p_response_client =
            input_data_view.TakeResponseClient<decltype(p_response_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 47, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResolveHost(
std::move(p_host), 
std::move(p_network_isolation_key), 
std::move(p_optional_parameters), 
std::move(p_response_client));
      return true;
    }
    case internal::kNetworkContext_CreateHostResolver_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_CreateHostResolver_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_CreateHostResolver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::net::DnsConfigOverrides> p_config_overrides{};
      ::mojo::PendingReceiver<::network::mojom::HostResolver> p_host_resolver{};
      NetworkContext_CreateHostResolver_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadConfigOverrides(&p_config_overrides))
        success = false;
      if (success) {
        p_host_resolver =
            input_data_view.TakeHostResolver<decltype(p_host_resolver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 48, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateHostResolver(
std::move(p_config_overrides), 
std::move(p_host_resolver));
      return true;
    }
    case internal::kNetworkContext_VerifyCertForSignedExchange_Name: {
      break;
    }
    case internal::kNetworkContext_AddHSTS_Name: {
      break;
    }
    case internal::kNetworkContext_IsHSTSActiveForHost_Name: {
      break;
    }
    case internal::kNetworkContext_GetHSTSState_Name: {
      break;
    }
    case internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name: {
      break;
    }
    case internal::kNetworkContext_DeleteDynamicDataForHost_Name: {
      break;
    }
    case internal::kNetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_split_auth_cache_by_network_isolation_key{};
      NetworkContext_SetSplitAuthCacheByNetworkIsolationKey_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_split_auth_cache_by_network_isolation_key = input_data_view.split_auth_cache_by_network_isolation_key();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 55, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSplitAuthCacheByNetworkIsolationKey(
std::move(p_split_auth_cache_by_network_isolation_key));
      return true;
    }
    case internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name: {
      break;
    }
    case internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name: {
      break;
    }
    case internal::kNetworkContext_AddAuthCacheEntry_Name: {
      break;
    }
    case internal::kNetworkContext_SetCorsNonWildcardRequestHeadersSupport_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetCorsNonWildcardRequestHeadersSupport_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetCorsNonWildcardRequestHeadersSupport_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_value{};
      NetworkContext_SetCorsNonWildcardRequestHeadersSupport_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_value = input_data_view.value();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 59, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCorsNonWildcardRequestHeadersSupport(
std::move(p_value));
      return true;
    }
    case internal::kNetworkContext_LookupServerBasicAuthCredentials_Name: {
      break;
    }
    case internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name: {
      break;
    }
    case internal::kNetworkContext_VerifyCertificateForTesting_Name: {
      break;
    }
    case internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name: {
      break;
    }
    case internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name: {
      break;
    }
    case internal::kNetworkContext_SetCTLogListAlwaysTimelyForTesting_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetCTLogListAlwaysTimelyForTesting_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetCTLogListAlwaysTimelyForTesting_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      NetworkContext_SetCTLogListAlwaysTimelyForTesting_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 65, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCTLogListAlwaysTimelyForTesting();
      return true;
    }
    case internal::kNetworkContext_SetSCTAuditingMode_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_SetSCTAuditingMode_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_SetSCTAuditingMode_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SCTAuditingMode p_mode{};
      NetworkContext_SetSCTAuditingMode_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMode(&p_mode))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 66, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSCTAuditingMode(
std::move(p_mode));
      return true;
    }
    case internal::kNetworkContext_AddReportingApiObserver_Name: {

      DCHECK(message->is_serialized());
      internal::NetworkContext_AddReportingApiObserver_Params_Data* params =
          reinterpret_cast<internal::NetworkContext_AddReportingApiObserver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::network::mojom::ReportingApiObserver> p_observer{};
      NetworkContext_AddReportingApiObserver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_observer =
            input_data_view.TakeObserver<decltype(p_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 67, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddReportingApiObserver(
std::move(p_observer));
      return true;
    }
  }
  return false;
}

// static
bool NetworkContextStubDispatch::AcceptWithResponder(
    NetworkContext* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kNetworkContext_SetClient_Name: {
      break;
    }
    case internal::kNetworkContext_CreateURLLoaderFactory_Name: {
      break;
    }
    case internal::kNetworkContext_ResetURLLoaderFactories_Name: {
      break;
    }
    case internal::kNetworkContext_GetCookieManager_Name: {
      break;
    }
    case internal::kNetworkContext_GetRestrictedCookieManager_Name: {
      break;
    }
    case internal::kNetworkContext_GetTrustTokenQueryAnswerer_Name: {
      break;
    }
    case internal::kNetworkContext_ClearTrustTokenData_Name: {

      internal::NetworkContext_ClearTrustTokenData_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearTrustTokenData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ClearDataFilterPtr p_filter{};
      NetworkContext_ClearTrustTokenData_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 6, false);
        return false;
      }
      NetworkContext::ClearTrustTokenDataCallback callback =
          NetworkContext_ClearTrustTokenData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearTrustTokenData(
std::move(p_filter), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_GetStoredTrustTokenCounts_Name: {

      internal::NetworkContext_GetStoredTrustTokenCounts_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_GetStoredTrustTokenCounts_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_GetStoredTrustTokenCounts_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 7, false);
        return false;
      }
      NetworkContext::GetStoredTrustTokenCountsCallback callback =
          NetworkContext_GetStoredTrustTokenCounts_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetStoredTrustTokenCounts(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_DeleteStoredTrustTokens_Name: {

      internal::NetworkContext_DeleteStoredTrustTokens_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_DeleteStoredTrustTokens_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::url::Origin p_issuer{};
      NetworkContext_DeleteStoredTrustTokens_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadIssuer(&p_issuer))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 8, false);
        return false;
      }
      NetworkContext::DeleteStoredTrustTokensCallback callback =
          NetworkContext_DeleteStoredTrustTokens_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteStoredTrustTokens(
std::move(p_issuer), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetBlockTrustTokens_Name: {
      break;
    }
    case internal::kNetworkContext_ClearNetworkingHistoryBetween_Name: {

      internal::NetworkContext_ClearNetworkingHistoryBetween_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearNetworkingHistoryBetween_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::Time p_start_time{};
      ::base::Time p_end_time{};
      NetworkContext_ClearNetworkingHistoryBetween_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStartTime(&p_start_time))
        success = false;
      if (success && !input_data_view.ReadEndTime(&p_end_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 10, false);
        return false;
      }
      NetworkContext::ClearNetworkingHistoryBetweenCallback callback =
          NetworkContext_ClearNetworkingHistoryBetween_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearNetworkingHistoryBetween(
std::move(p_start_time), 
std::move(p_end_time), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearHttpCache_Name: {

      internal::NetworkContext_ClearHttpCache_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearHttpCache_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::Time p_start_time{};
      ::base::Time p_end_time{};
      ClearDataFilterPtr p_filter{};
      NetworkContext_ClearHttpCache_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStartTime(&p_start_time))
        success = false;
      if (success && !input_data_view.ReadEndTime(&p_end_time))
        success = false;
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 11, false);
        return false;
      }
      NetworkContext::ClearHttpCacheCallback callback =
          NetworkContext_ClearHttpCache_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearHttpCache(
std::move(p_start_time), 
std::move(p_end_time), 
std::move(p_filter), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ComputeHttpCacheSize_Name: {

      internal::NetworkContext_ComputeHttpCacheSize_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ComputeHttpCacheSize_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::Time p_start_time{};
      ::base::Time p_end_time{};
      NetworkContext_ComputeHttpCacheSize_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStartTime(&p_start_time))
        success = false;
      if (success && !input_data_view.ReadEndTime(&p_end_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 12, false);
        return false;
      }
      NetworkContext::ComputeHttpCacheSizeCallback callback =
          NetworkContext_ComputeHttpCacheSize_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ComputeHttpCacheSize(
std::move(p_start_time), 
std::move(p_end_time), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_NotifyExternalCacheHit_Name: {
      break;
    }
    case internal::kNetworkContext_ClearHostCache_Name: {

      internal::NetworkContext_ClearHostCache_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearHostCache_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ClearDataFilterPtr p_filter{};
      NetworkContext_ClearHostCache_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 14, false);
        return false;
      }
      NetworkContext::ClearHostCacheCallback callback =
          NetworkContext_ClearHostCache_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearHostCache(
std::move(p_filter), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearHttpAuthCache_Name: {

      internal::NetworkContext_ClearHttpAuthCache_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearHttpAuthCache_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::Time p_start_time{};
      ::base::Time p_end_time{};
      NetworkContext_ClearHttpAuthCache_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStartTime(&p_start_time))
        success = false;
      if (success && !input_data_view.ReadEndTime(&p_end_time))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 15, false);
        return false;
      }
      NetworkContext::ClearHttpAuthCacheCallback callback =
          NetworkContext_ClearHttpAuthCache_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearHttpAuthCache(
std::move(p_start_time), 
std::move(p_end_time), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearReportingCacheReports_Name: {

      internal::NetworkContext_ClearReportingCacheReports_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearReportingCacheReports_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ClearDataFilterPtr p_filter{};
      NetworkContext_ClearReportingCacheReports_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 16, false);
        return false;
      }
      NetworkContext::ClearReportingCacheReportsCallback callback =
          NetworkContext_ClearReportingCacheReports_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearReportingCacheReports(
std::move(p_filter), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearReportingCacheClients_Name: {

      internal::NetworkContext_ClearReportingCacheClients_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearReportingCacheClients_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ClearDataFilterPtr p_filter{};
      NetworkContext_ClearReportingCacheClients_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 17, false);
        return false;
      }
      NetworkContext::ClearReportingCacheClientsCallback callback =
          NetworkContext_ClearReportingCacheClients_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearReportingCacheClients(
std::move(p_filter), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearNetworkErrorLogging_Name: {

      internal::NetworkContext_ClearNetworkErrorLogging_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearNetworkErrorLogging_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ClearDataFilterPtr p_filter{};
      NetworkContext_ClearNetworkErrorLogging_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 18, false);
        return false;
      }
      NetworkContext::ClearNetworkErrorLoggingCallback callback =
          NetworkContext_ClearNetworkErrorLogging_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearNetworkErrorLogging(
std::move(p_filter), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearDomainReliability_Name: {

      internal::NetworkContext_ClearDomainReliability_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearDomainReliability_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ClearDataFilterPtr p_filter{};
      NetworkContext::DomainReliabilityClearMode p_mode{};
      NetworkContext_ClearDomainReliability_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFilter(&p_filter))
        success = false;
      if (success && !input_data_view.ReadMode(&p_mode))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 19, false);
        return false;
      }
      NetworkContext::ClearDomainReliabilityCallback callback =
          NetworkContext_ClearDomainReliability_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearDomainReliability(
std::move(p_filter), 
std::move(p_mode), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetDocumentReportingEndpoints_Name: {
      break;
    }
    case internal::kNetworkContext_SendReportsAndRemoveSource_Name: {
      break;
    }
    case internal::kNetworkContext_QueueReport_Name: {
      break;
    }
    case internal::kNetworkContext_QueueSignedExchangeReport_Name: {
      break;
    }
    case internal::kNetworkContext_CloseAllConnections_Name: {

      internal::NetworkContext_CloseAllConnections_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_CloseAllConnections_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_CloseAllConnections_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 24, false);
        return false;
      }
      NetworkContext::CloseAllConnectionsCallback callback =
          NetworkContext_CloseAllConnections_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CloseAllConnections(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_CloseIdleConnections_Name: {

      internal::NetworkContext_CloseIdleConnections_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_CloseIdleConnections_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_CloseIdleConnections_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 25, false);
        return false;
      }
      NetworkContext::CloseIdleConnectionsCallback callback =
          NetworkContext_CloseIdleConnections_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CloseIdleConnections(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetNetworkConditions_Name: {
      break;
    }
    case internal::kNetworkContext_SetAcceptLanguage_Name: {
      break;
    }
    case internal::kNetworkContext_SetEnableReferrers_Name: {
      break;
    }
    case internal::kNetworkContext_SetCTPolicy_Name: {
      break;
    }
    case internal::kNetworkContext_AddExpectCT_Name: {

      internal::NetworkContext_AddExpectCT_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_AddExpectCT_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_host{};
      ::base::Time p_expiry{};
      bool p_enforce{};
      ::GURL p_report_uri{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      NetworkContext_AddExpectCT_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHost(&p_host))
        success = false;
      if (success && !input_data_view.ReadExpiry(&p_expiry))
        success = false;
      if (success)
        p_enforce = input_data_view.enforce();
      if (success && !input_data_view.ReadReportUri(&p_report_uri))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 30, false);
        return false;
      }
      NetworkContext::AddExpectCTCallback callback =
          NetworkContext_AddExpectCT_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddExpectCT(
std::move(p_host), 
std::move(p_expiry), 
std::move(p_enforce), 
std::move(p_report_uri), 
std::move(p_network_isolation_key), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetExpectCTTestReport_Name: {

      internal::NetworkContext_SetExpectCTTestReport_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_SetExpectCTTestReport_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_report_uri{};
      NetworkContext_SetExpectCTTestReport_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadReportUri(&p_report_uri))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 31, false);
        return false;
      }
      NetworkContext::SetExpectCTTestReportCallback callback =
          NetworkContext_SetExpectCTTestReport_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetExpectCTTestReport(
std::move(p_report_uri), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_GetExpectCTState_Name: {

      internal::NetworkContext_GetExpectCTState_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_GetExpectCTState_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_domain{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      NetworkContext_GetExpectCTState_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDomain(&p_domain))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 32, false);
        return false;
      }
      NetworkContext::GetExpectCTStateCallback callback =
          NetworkContext_GetExpectCTState_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetExpectCTState(
std::move(p_domain), 
std::move(p_network_isolation_key), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_CreateUDPSocket_Name: {
      break;
    }
    case internal::kNetworkContext_CreateTCPServerSocket_Name: {

      internal::NetworkContext_CreateTCPServerSocket_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_CreateTCPServerSocket_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::net::IPEndPoint p_local_addr{};
      uint32_t p_backlog{};
      ::net::MutableNetworkTrafficAnnotationTag p_traffic_annotation{};
      ::mojo::PendingReceiver<::network::mojom::TCPServerSocket> p_socket{};
      NetworkContext_CreateTCPServerSocket_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLocalAddr(&p_local_addr))
        success = false;
      if (success)
        p_backlog = input_data_view.backlog();
      if (success && !input_data_view.ReadTrafficAnnotation(&p_traffic_annotation))
        success = false;
      if (success) {
        p_socket =
            input_data_view.TakeSocket<decltype(p_socket)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 34, false);
        return false;
      }
      NetworkContext::CreateTCPServerSocketCallback callback =
          NetworkContext_CreateTCPServerSocket_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateTCPServerSocket(
std::move(p_local_addr), 
std::move(p_backlog), 
std::move(p_traffic_annotation), 
std::move(p_socket), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_CreateTCPConnectedSocket_Name: {

      internal::NetworkContext_CreateTCPConnectedSocket_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_CreateTCPConnectedSocket_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      absl::optional<::net::IPEndPoint> p_local_addr{};
      ::net::AddressList p_remote_addr_list{};
      ::network::mojom::TCPConnectedSocketOptionsPtr p_tcp_connected_socket_options{};
      ::net::MutableNetworkTrafficAnnotationTag p_traffic_annotation{};
      ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket> p_socket{};
      ::mojo::PendingRemote<::network::mojom::SocketObserver> p_observer{};
      NetworkContext_CreateTCPConnectedSocket_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLocalAddr(&p_local_addr))
        success = false;
      if (success && !input_data_view.ReadRemoteAddrList(&p_remote_addr_list))
        success = false;
      if (success && !input_data_view.ReadTcpConnectedSocketOptions(&p_tcp_connected_socket_options))
        success = false;
      if (success && !input_data_view.ReadTrafficAnnotation(&p_traffic_annotation))
        success = false;
      if (success) {
        p_socket =
            input_data_view.TakeSocket<decltype(p_socket)>();
      }
      if (success) {
        p_observer =
            input_data_view.TakeObserver<decltype(p_observer)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 35, false);
        return false;
      }
      NetworkContext::CreateTCPConnectedSocketCallback callback =
          NetworkContext_CreateTCPConnectedSocket_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateTCPConnectedSocket(
std::move(p_local_addr), 
std::move(p_remote_addr_list), 
std::move(p_tcp_connected_socket_options), 
std::move(p_traffic_annotation), 
std::move(p_socket), 
std::move(p_observer), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_CreateTCPBoundSocket_Name: {

      internal::NetworkContext_CreateTCPBoundSocket_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_CreateTCPBoundSocket_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::net::IPEndPoint p_local_addr{};
      ::net::MutableNetworkTrafficAnnotationTag p_traffic_annotation{};
      ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket> p_socket{};
      NetworkContext_CreateTCPBoundSocket_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLocalAddr(&p_local_addr))
        success = false;
      if (success && !input_data_view.ReadTrafficAnnotation(&p_traffic_annotation))
        success = false;
      if (success) {
        p_socket =
            input_data_view.TakeSocket<decltype(p_socket)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 36, false);
        return false;
      }
      NetworkContext::CreateTCPBoundSocketCallback callback =
          NetworkContext_CreateTCPBoundSocket_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateTCPBoundSocket(
std::move(p_local_addr), 
std::move(p_traffic_annotation), 
std::move(p_socket), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_CreateProxyResolvingSocketFactory_Name: {
      break;
    }
    case internal::kNetworkContext_LookUpProxyForURL_Name: {
      break;
    }
    case internal::kNetworkContext_ForceReloadProxyConfig_Name: {

      internal::NetworkContext_ForceReloadProxyConfig_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ForceReloadProxyConfig_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_ForceReloadProxyConfig_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 39, false);
        return false;
      }
      NetworkContext::ForceReloadProxyConfigCallback callback =
          NetworkContext_ForceReloadProxyConfig_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForceReloadProxyConfig(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ClearBadProxiesCache_Name: {

      internal::NetworkContext_ClearBadProxiesCache_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ClearBadProxiesCache_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_ClearBadProxiesCache_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 40, false);
        return false;
      }
      NetworkContext::ClearBadProxiesCacheCallback callback =
          NetworkContext_ClearBadProxiesCache_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearBadProxiesCache(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_CreateWebSocket_Name: {
      break;
    }
    case internal::kNetworkContext_CreateWebTransport_Name: {
      break;
    }
    case internal::kNetworkContext_CreateNetLogExporter_Name: {
      break;
    }
    case internal::kNetworkContext_PreconnectSockets_Name: {
      break;
    }
    case internal::kNetworkContext_CreateP2PSocketManager_Name: {
      break;
    }
    case internal::kNetworkContext_CreateMdnsResponder_Name: {
      break;
    }
    case internal::kNetworkContext_ResolveHost_Name: {
      break;
    }
    case internal::kNetworkContext_CreateHostResolver_Name: {
      break;
    }
    case internal::kNetworkContext_VerifyCertForSignedExchange_Name: {

      internal::NetworkContext_VerifyCertForSignedExchange_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_VerifyCertForSignedExchange_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::scoped_refptr<::net::X509Certificate> p_certificate{};
      ::GURL p_url{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      std::string p_ocsp_response{};
      std::string p_sct_list{};
      NetworkContext_VerifyCertForSignedExchange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCertificate(&p_certificate))
        success = false;
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success && !input_data_view.ReadOcspResponse(&p_ocsp_response))
        success = false;
      if (success && !input_data_view.ReadSctList(&p_sct_list))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 49, false);
        return false;
      }
      NetworkContext::VerifyCertForSignedExchangeCallback callback =
          NetworkContext_VerifyCertForSignedExchange_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VerifyCertForSignedExchange(
std::move(p_certificate), 
std::move(p_url), 
std::move(p_network_isolation_key), 
std::move(p_ocsp_response), 
std::move(p_sct_list), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_AddHSTS_Name: {

      internal::NetworkContext_AddHSTS_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_AddHSTS_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_host{};
      ::base::Time p_expiry{};
      bool p_include_subdomains{};
      NetworkContext_AddHSTS_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHost(&p_host))
        success = false;
      if (success && !input_data_view.ReadExpiry(&p_expiry))
        success = false;
      if (success)
        p_include_subdomains = input_data_view.include_subdomains();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 50, false);
        return false;
      }
      NetworkContext::AddHSTSCallback callback =
          NetworkContext_AddHSTS_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddHSTS(
std::move(p_host), 
std::move(p_expiry), 
std::move(p_include_subdomains), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_IsHSTSActiveForHost_Name: {

      internal::NetworkContext_IsHSTSActiveForHost_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_IsHSTSActiveForHost_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_host{};
      NetworkContext_IsHSTSActiveForHost_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHost(&p_host))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 51, false);
        return false;
      }
      NetworkContext::IsHSTSActiveForHostCallback callback =
          NetworkContext_IsHSTSActiveForHost_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IsHSTSActiveForHost(
std::move(p_host), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_GetHSTSState_Name: {

      internal::NetworkContext_GetHSTSState_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_GetHSTSState_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_domain{};
      NetworkContext_GetHSTSState_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDomain(&p_domain))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 52, false);
        return false;
      }
      NetworkContext::GetHSTSStateCallback callback =
          NetworkContext_GetHSTSState_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetHSTSState(
std::move(p_domain), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetCorsOriginAccessListsForOrigin_Name: {

      internal::NetworkContext_SetCorsOriginAccessListsForOrigin_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_SetCorsOriginAccessListsForOrigin_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::url::Origin p_source_origin{};
      std::vector<::network::mojom::CorsOriginPatternPtr> p_allow_patterns{};
      std::vector<::network::mojom::CorsOriginPatternPtr> p_block_patterns{};
      NetworkContext_SetCorsOriginAccessListsForOrigin_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
        success = false;
      if (success && !input_data_view.ReadAllowPatterns(&p_allow_patterns))
        success = false;
      if (success && !input_data_view.ReadBlockPatterns(&p_block_patterns))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 53, false);
        return false;
      }
      NetworkContext::SetCorsOriginAccessListsForOriginCallback callback =
          NetworkContext_SetCorsOriginAccessListsForOrigin_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCorsOriginAccessListsForOrigin(
std::move(p_source_origin), 
std::move(p_allow_patterns), 
std::move(p_block_patterns), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_DeleteDynamicDataForHost_Name: {

      internal::NetworkContext_DeleteDynamicDataForHost_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_DeleteDynamicDataForHost_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_host{};
      NetworkContext_DeleteDynamicDataForHost_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadHost(&p_host))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 54, false);
        return false;
      }
      NetworkContext::DeleteDynamicDataForHostCallback callback =
          NetworkContext_DeleteDynamicDataForHost_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DeleteDynamicDataForHost(
std::move(p_host), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Name: {
      break;
    }
    case internal::kNetworkContext_SaveHttpAuthCacheProxyEntries_Name: {

      internal::NetworkContext_SaveHttpAuthCacheProxyEntries_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_SaveHttpAuthCacheProxyEntries_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_SaveHttpAuthCacheProxyEntries_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 56, false);
        return false;
      }
      NetworkContext::SaveHttpAuthCacheProxyEntriesCallback callback =
          NetworkContext_SaveHttpAuthCacheProxyEntries_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SaveHttpAuthCacheProxyEntries(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_LoadHttpAuthCacheProxyEntries_Name: {

      internal::NetworkContext_LoadHttpAuthCacheProxyEntries_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_LoadHttpAuthCacheProxyEntries_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::UnguessableToken p_cache_key{};
      NetworkContext_LoadHttpAuthCacheProxyEntries_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCacheKey(&p_cache_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 57, false);
        return false;
      }
      NetworkContext::LoadHttpAuthCacheProxyEntriesCallback callback =
          NetworkContext_LoadHttpAuthCacheProxyEntries_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LoadHttpAuthCacheProxyEntries(
std::move(p_cache_key), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_AddAuthCacheEntry_Name: {

      internal::NetworkContext_AddAuthCacheEntry_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_AddAuthCacheEntry_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::net::AuthChallengeInfo p_challenge{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      ::net::AuthCredentials p_credentials{};
      NetworkContext_AddAuthCacheEntry_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadChallenge(&p_challenge))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (success && !input_data_view.ReadCredentials(&p_credentials))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 58, false);
        return false;
      }
      NetworkContext::AddAuthCacheEntryCallback callback =
          NetworkContext_AddAuthCacheEntry_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddAuthCacheEntry(
std::move(p_challenge), 
std::move(p_network_isolation_key), 
std::move(p_credentials), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetCorsNonWildcardRequestHeadersSupport_Name: {
      break;
    }
    case internal::kNetworkContext_LookupServerBasicAuthCredentials_Name: {

      internal::NetworkContext_LookupServerBasicAuthCredentials_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_LookupServerBasicAuthCredentials_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      ::net::NetworkIsolationKey p_network_isolation_key{};
      NetworkContext_LookupServerBasicAuthCredentials_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadNetworkIsolationKey(&p_network_isolation_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 60, false);
        return false;
      }
      NetworkContext::LookupServerBasicAuthCredentialsCallback callback =
          NetworkContext_LookupServerBasicAuthCredentials_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LookupServerBasicAuthCredentials(
std::move(p_url), 
std::move(p_network_isolation_key), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_EnableStaticKeyPinningForTesting_Name: {

      internal::NetworkContext_EnableStaticKeyPinningForTesting_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_EnableStaticKeyPinningForTesting_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_EnableStaticKeyPinningForTesting_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 61, false);
        return false;
      }
      NetworkContext::EnableStaticKeyPinningForTestingCallback callback =
          NetworkContext_EnableStaticKeyPinningForTesting_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableStaticKeyPinningForTesting(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_VerifyCertificateForTesting_Name: {

      internal::NetworkContext_VerifyCertificateForTesting_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_VerifyCertificateForTesting_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::scoped_refptr<::net::X509Certificate> p_certificate{};
      std::string p_hostname{};
      std::string p_ocsp_response{};
      std::string p_sct_list{};
      NetworkContext_VerifyCertificateForTesting_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadCertificate(&p_certificate))
        success = false;
      if (success && !input_data_view.ReadHostname(&p_hostname))
        success = false;
      if (success && !input_data_view.ReadOcspResponse(&p_ocsp_response))
        success = false;
      if (success && !input_data_view.ReadSctList(&p_sct_list))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 62, false);
        return false;
      }
      NetworkContext::VerifyCertificateForTestingCallback callback =
          NetworkContext_VerifyCertificateForTesting_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VerifyCertificateForTesting(
std::move(p_certificate), 
std::move(p_hostname), 
std::move(p_ocsp_response), 
std::move(p_sct_list), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_AddDomainReliabilityContextForTesting_Name: {

      internal::NetworkContext_AddDomainReliabilityContextForTesting_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_AddDomainReliabilityContextForTesting_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::url::Origin p_origin{};
      ::GURL p_upload_url{};
      NetworkContext_AddDomainReliabilityContextForTesting_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOrigin(&p_origin))
        success = false;
      if (success && !input_data_view.ReadUploadUrl(&p_upload_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 63, false);
        return false;
      }
      NetworkContext::AddDomainReliabilityContextForTestingCallback callback =
          NetworkContext_AddDomainReliabilityContextForTesting_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddDomainReliabilityContextForTesting(
std::move(p_origin), 
std::move(p_upload_url), std::move(callback));
      return true;
    }
    case internal::kNetworkContext_ForceDomainReliabilityUploadsForTesting_Name: {

      internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_Params_Data* params =
          reinterpret_cast<
              internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      NetworkContext_ForceDomainReliabilityUploadsForTesting_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            NetworkContext::Name_, 64, false);
        return false;
      }
      NetworkContext::ForceDomainReliabilityUploadsForTestingCallback callback =
          NetworkContext_ForceDomainReliabilityUploadsForTesting_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForceDomainReliabilityUploadsForTesting(std::move(callback));
      return true;
    }
    case internal::kNetworkContext_SetCTLogListAlwaysTimelyForTesting_Name: {
      break;
    }
    case internal::kNetworkContext_SetSCTAuditingMode_Name: {
      break;
    }
    case internal::kNetworkContext_AddReportingApiObserver_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kNetworkContextValidationInfo[] = {
    {&internal::NetworkContext_SetClient_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateURLLoaderFactory_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_ResetURLLoaderFactories_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_GetCookieManager_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_GetRestrictedCookieManager_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_GetTrustTokenQueryAnswerer_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_ClearTrustTokenData_Params_Data::Validate,
     &internal::NetworkContext_ClearTrustTokenData_ResponseParams_Data::Validate},
    {&internal::NetworkContext_GetStoredTrustTokenCounts_Params_Data::Validate,
     &internal::NetworkContext_GetStoredTrustTokenCounts_ResponseParams_Data::Validate},
    {&internal::NetworkContext_DeleteStoredTrustTokens_Params_Data::Validate,
     &internal::NetworkContext_DeleteStoredTrustTokens_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetBlockTrustTokens_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_ClearNetworkingHistoryBetween_Params_Data::Validate,
     &internal::NetworkContext_ClearNetworkingHistoryBetween_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearHttpCache_Params_Data::Validate,
     &internal::NetworkContext_ClearHttpCache_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ComputeHttpCacheSize_Params_Data::Validate,
     &internal::NetworkContext_ComputeHttpCacheSize_ResponseParams_Data::Validate},
    {&internal::NetworkContext_NotifyExternalCacheHit_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_ClearHostCache_Params_Data::Validate,
     &internal::NetworkContext_ClearHostCache_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearHttpAuthCache_Params_Data::Validate,
     &internal::NetworkContext_ClearHttpAuthCache_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearReportingCacheReports_Params_Data::Validate,
     &internal::NetworkContext_ClearReportingCacheReports_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearReportingCacheClients_Params_Data::Validate,
     &internal::NetworkContext_ClearReportingCacheClients_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearNetworkErrorLogging_Params_Data::Validate,
     &internal::NetworkContext_ClearNetworkErrorLogging_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearDomainReliability_Params_Data::Validate,
     &internal::NetworkContext_ClearDomainReliability_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetDocumentReportingEndpoints_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_SendReportsAndRemoveSource_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_QueueReport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_QueueSignedExchangeReport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CloseAllConnections_Params_Data::Validate,
     &internal::NetworkContext_CloseAllConnections_ResponseParams_Data::Validate},
    {&internal::NetworkContext_CloseIdleConnections_Params_Data::Validate,
     &internal::NetworkContext_CloseIdleConnections_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetNetworkConditions_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_SetAcceptLanguage_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_SetEnableReferrers_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_SetCTPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_AddExpectCT_Params_Data::Validate,
     &internal::NetworkContext_AddExpectCT_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetExpectCTTestReport_Params_Data::Validate,
     &internal::NetworkContext_SetExpectCTTestReport_ResponseParams_Data::Validate},
    {&internal::NetworkContext_GetExpectCTState_Params_Data::Validate,
     &internal::NetworkContext_GetExpectCTState_ResponseParams_Data::Validate},
    {&internal::NetworkContext_CreateUDPSocket_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateTCPServerSocket_Params_Data::Validate,
     &internal::NetworkContext_CreateTCPServerSocket_ResponseParams_Data::Validate},
    {&internal::NetworkContext_CreateTCPConnectedSocket_Params_Data::Validate,
     &internal::NetworkContext_CreateTCPConnectedSocket_ResponseParams_Data::Validate},
    {&internal::NetworkContext_CreateTCPBoundSocket_Params_Data::Validate,
     &internal::NetworkContext_CreateTCPBoundSocket_ResponseParams_Data::Validate},
    {&internal::NetworkContext_CreateProxyResolvingSocketFactory_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_LookUpProxyForURL_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_ForceReloadProxyConfig_Params_Data::Validate,
     &internal::NetworkContext_ForceReloadProxyConfig_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ClearBadProxiesCache_Params_Data::Validate,
     &internal::NetworkContext_ClearBadProxiesCache_ResponseParams_Data::Validate},
    {&internal::NetworkContext_CreateWebSocket_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateWebTransport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateNetLogExporter_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_PreconnectSockets_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateP2PSocketManager_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateMdnsResponder_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_ResolveHost_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_CreateHostResolver_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_VerifyCertForSignedExchange_Params_Data::Validate,
     &internal::NetworkContext_VerifyCertForSignedExchange_ResponseParams_Data::Validate},
    {&internal::NetworkContext_AddHSTS_Params_Data::Validate,
     &internal::NetworkContext_AddHSTS_ResponseParams_Data::Validate},
    {&internal::NetworkContext_IsHSTSActiveForHost_Params_Data::Validate,
     &internal::NetworkContext_IsHSTSActiveForHost_ResponseParams_Data::Validate},
    {&internal::NetworkContext_GetHSTSState_Params_Data::Validate,
     &internal::NetworkContext_GetHSTSState_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetCorsOriginAccessListsForOrigin_Params_Data::Validate,
     &internal::NetworkContext_SetCorsOriginAccessListsForOrigin_ResponseParams_Data::Validate},
    {&internal::NetworkContext_DeleteDynamicDataForHost_Params_Data::Validate,
     &internal::NetworkContext_DeleteDynamicDataForHost_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetSplitAuthCacheByNetworkIsolationKey_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_SaveHttpAuthCacheProxyEntries_Params_Data::Validate,
     &internal::NetworkContext_SaveHttpAuthCacheProxyEntries_ResponseParams_Data::Validate},
    {&internal::NetworkContext_LoadHttpAuthCacheProxyEntries_Params_Data::Validate,
     &internal::NetworkContext_LoadHttpAuthCacheProxyEntries_ResponseParams_Data::Validate},
    {&internal::NetworkContext_AddAuthCacheEntry_Params_Data::Validate,
     &internal::NetworkContext_AddAuthCacheEntry_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetCorsNonWildcardRequestHeadersSupport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_LookupServerBasicAuthCredentials_Params_Data::Validate,
     &internal::NetworkContext_LookupServerBasicAuthCredentials_ResponseParams_Data::Validate},
    {&internal::NetworkContext_EnableStaticKeyPinningForTesting_Params_Data::Validate,
     &internal::NetworkContext_EnableStaticKeyPinningForTesting_ResponseParams_Data::Validate},
    {&internal::NetworkContext_VerifyCertificateForTesting_Params_Data::Validate,
     &internal::NetworkContext_VerifyCertificateForTesting_ResponseParams_Data::Validate},
    {&internal::NetworkContext_AddDomainReliabilityContextForTesting_Params_Data::Validate,
     &internal::NetworkContext_AddDomainReliabilityContextForTesting_ResponseParams_Data::Validate},
    {&internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_Params_Data::Validate,
     &internal::NetworkContext_ForceDomainReliabilityUploadsForTesting_ResponseParams_Data::Validate},
    {&internal::NetworkContext_SetCTLogListAlwaysTimelyForTesting_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_SetSCTAuditingMode_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::NetworkContext_AddReportingApiObserver_Params_Data::Validate,
     nullptr /* no response */},
};

bool NetworkContextRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkContext::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kNetworkContextValidationInfo);
}

bool NetworkContextResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::network::mojom::NetworkContext::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kNetworkContextValidationInfo);
}


}  // namespace mojom
}  // namespace network


namespace mojo {


// static
bool StructTraits<::network::mojom::CustomProxyConfig::DataView, ::network::mojom::CustomProxyConfigPtr>::Read(
    ::network::mojom::CustomProxyConfig::DataView input,
    ::network::mojom::CustomProxyConfigPtr* output) {
  bool success = true;
  ::network::mojom::CustomProxyConfigPtr result(::network::mojom::CustomProxyConfig::New());
  
      if (success && !input.ReadRules(&result->rules))
        success = false;
      if (success)
        result->should_override_existing_config = input.should_override_existing_config();
      if (success)
        result->allow_non_idempotent_methods = input.allow_non_idempotent_methods();
      if (success && !input.ReadConnectTunnelHeaders(&result->connect_tunnel_headers))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::CertVerifierServiceRemoteParams::DataView, ::network::mojom::CertVerifierServiceRemoteParamsPtr>::Read(
    ::network::mojom::CertVerifierServiceRemoteParams::DataView input,
    ::network::mojom::CertVerifierServiceRemoteParamsPtr* output) {
  bool success = true;
  ::network::mojom::CertVerifierServiceRemoteParamsPtr result(::network::mojom::CertVerifierServiceRemoteParams::New());
  
      if (success) {
        result->cert_verifier_service =
            input.TakeCertVerifierService<decltype(result->cert_verifier_service)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::HttpAuthStaticNetworkContextParams::DataView, ::network::mojom::HttpAuthStaticNetworkContextParamsPtr>::Read(
    ::network::mojom::HttpAuthStaticNetworkContextParams::DataView input,
    ::network::mojom::HttpAuthStaticNetworkContextParamsPtr* output) {
  bool success = true;
  ::network::mojom::HttpAuthStaticNetworkContextParamsPtr result(::network::mojom::HttpAuthStaticNetworkContextParams::New());
  
      if (success && !input.ReadAllowDefaultCredentials(&result->allow_default_credentials))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::CTPolicy::DataView, ::network::mojom::CTPolicyPtr>::Read(
    ::network::mojom::CTPolicy::DataView input,
    ::network::mojom::CTPolicyPtr* output) {
  bool success = true;
  ::network::mojom::CTPolicyPtr result(::network::mojom::CTPolicy::New());
  
      if (success && !input.ReadRequiredHosts(&result->required_hosts))
        success = false;
      if (success && !input.ReadExcludedHosts(&result->excluded_hosts))
        success = false;
      if (success && !input.ReadExcludedSpkis(&result->excluded_spkis))
        success = false;
      if (success && !input.ReadExcludedLegacySpkis(&result->excluded_legacy_spkis))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::NetworkContextFilePaths::DataView, ::network::mojom::NetworkContextFilePathsPtr>::Read(
    ::network::mojom::NetworkContextFilePaths::DataView input,
    ::network::mojom::NetworkContextFilePathsPtr* output) {
  bool success = true;
  ::network::mojom::NetworkContextFilePathsPtr result(::network::mojom::NetworkContextFilePaths::New());
  
      if (success && !input.ReadDataDirectory(&result->data_directory))
        success = false;
      if (success && !input.ReadUnsandboxedDataPath(&result->unsandboxed_data_path))
        success = false;
      if (success && !input.ReadCookieDatabaseName(&result->cookie_database_name))
        success = false;
      if (success && !input.ReadTrustTokenDatabaseName(&result->trust_token_database_name))
        success = false;
      if (success && !input.ReadHttpServerPropertiesFileName(&result->http_server_properties_file_name))
        success = false;
      if (success && !input.ReadTransportSecurityPersisterFileName(&result->transport_security_persister_file_name))
        success = false;
      if (success && !input.ReadReportingAndNelStoreDatabaseName(&result->reporting_and_nel_store_database_name))
        success = false;
      if (success && !input.ReadSctAuditingPendingReportsFileName(&result->sct_auditing_pending_reports_file_name))
        success = false;
      if (success)
        result->trigger_migration = input.trigger_migration();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::NetworkContextParams::DataView, ::network::mojom::NetworkContextParamsPtr>::Read(
    ::network::mojom::NetworkContextParams::DataView input,
    ::network::mojom::NetworkContextParamsPtr* output) {
  bool success = true;
  ::network::mojom::NetworkContextParamsPtr result(::network::mojom::NetworkContextParams::New());
  
      if (success && !input.ReadUserAgent(&result->user_agent))
        success = false;
      if (success && !input.ReadAcceptLanguage(&result->accept_language))
        success = false;
      if (success)
        result->enable_brotli = input.enable_brotli();
      if (success && !input.ReadQuicUserAgentId(&result->quic_user_agent_id))
        success = false;
      if (success)
        result->enable_referrers = input.enable_referrers();
      if (success)
        result->validate_referrer_policy_on_initial_request = input.validate_referrer_policy_on_initial_request();
      if (success) {
        result->proxy_resolver_factory =
            input.TakeProxyResolverFactory<decltype(result->proxy_resolver_factory)>();
      }
      if (success)
        result->enable_encrypted_cookies = input.enable_encrypted_cookies();
      if (success)
        result->restore_old_session_cookies = input.restore_old_session_cookies();
      if (success)
        result->persist_session_cookies = input.persist_session_cookies();
      if (success)
        result->http_cache_enabled = input.http_cache_enabled();
      if (success)
        result->http_cache_max_size = input.http_cache_max_size();
      if (success && !input.ReadHttpCacheDirectory(&result->http_cache_directory))
        success = false;
      if (success) {
        result->http_cache_file_operations_factory =
            input.TakeHttpCacheFileOperationsFactory<decltype(result->http_cache_file_operations_factory)>();
      }
      if (success)
        result->check_clear_text_permitted = input.check_clear_text_permitted();
      if (success)
        result->disable_idle_sockets_close_on_memory_pressure = input.disable_idle_sockets_close_on_memory_pressure();
      if (success && !input.ReadInitialSslConfig(&result->initial_ssl_config))
        success = false;
      if (success) {
        result->ssl_config_client_receiver =
            input.TakeSslConfigClientReceiver<decltype(result->ssl_config_client_receiver)>();
      }
      if (success && !input.ReadInitialProxyConfig(&result->initial_proxy_config))
        success = false;
      if (success) {
        result->proxy_config_client_receiver =
            input.TakeProxyConfigClientReceiver<decltype(result->proxy_config_client_receiver)>();
      }
      if (success && !input.ReadInitialCustomProxyConfig(&result->initial_custom_proxy_config))
        success = false;
      if (success) {
        result->custom_proxy_config_client_receiver =
            input.TakeCustomProxyConfigClientReceiver<decltype(result->custom_proxy_config_client_receiver)>();
      }
      if (success) {
        result->custom_proxy_connection_observer_remote =
            input.TakeCustomProxyConnectionObserverRemote<decltype(result->custom_proxy_connection_observer_remote)>();
      }
      if (success) {
        result->proxy_config_poller_client =
            input.TakeProxyConfigPollerClient<decltype(result->proxy_config_poller_client)>();
      }
      if (success) {
        result->proxy_error_client =
            input.TakeProxyErrorClient<decltype(result->proxy_error_client)>();
      }
      if (success) {
        result->socket_broker =
            input.TakeSocketBroker<decltype(result->socket_broker)>();
      }
      if (success)
        result->pac_quick_check_enabled = input.pac_quick_check_enabled();
      if (success)
        result->enable_certificate_reporting = input.enable_certificate_reporting();
      if (success)
        result->enforce_chrome_ct_policy = input.enforce_chrome_ct_policy();
      if (success)
        result->enable_expect_ct_reporting = input.enable_expect_ct_reporting();
      if (success && !input.ReadSctAuditingMode(&result->sct_auditing_mode))
        success = false;
      if (success && !input.ReadCtPolicy(&result->ct_policy))
        success = false;
      if (success && !input.ReadCertVerifierParams(&result->cert_verifier_params))
        success = false;
      if (success && !input.ReadCookieManagerParams(&result->cookie_manager_params))
        success = false;
      if (success) {
        result->cookie_manager =
            input.TakeCookieManager<decltype(result->cookie_manager)>();
      }
      if (success)
        result->enable_domain_reliability = input.enable_domain_reliability();
      if (success && !input.ReadDomainReliabilityUploadReporter(&result->domain_reliability_upload_reporter))
        success = false;
      if (success)
        result->discard_domain_reliablity_uploads = input.discard_domain_reliablity_uploads();
      if (success && !input.ReadReportingDeliveryInterval(&result->reporting_delivery_interval))
        success = false;
      if (success)
        result->skip_reporting_send_permission_check = input.skip_reporting_send_permission_check();
      if (success && !input.ReadCorsOriginAccessList(&result->cors_origin_access_list))
        success = false;
      if (success && !input.ReadCorsExemptHeaderList(&result->cors_exempt_header_list))
        success = false;
      if (success)
        result->allow_any_cors_exempt_header_for_browser = input.allow_any_cors_exempt_header_for_browser();
      if (success && !input.ReadHstsPolicyBypassList(&result->hsts_policy_bypass_list))
        success = false;
      if (success && !input.ReadHttpAuthStaticNetworkContextParams(&result->http_auth_static_network_context_params))
        success = false;
      if (success)
        result->reset_http_cache_backend = input.reset_http_cache_backend();
      if (success)
        result->split_auth_cache_by_network_isolation_key = input.split_auth_cache_by_network_isolation_key();
      if (success)
        result->require_network_isolation_key = input.require_network_isolation_key();
      if (success && !input.ReadFilePaths(&result->file_paths))
        success = false;
      if (success)
        result->block_trust_tokens = input.block_trust_tokens();
      if (success && !input.ReadFirstPartySetsAccessDelegateParams(&result->first_party_sets_access_delegate_params))
        success = false;
      if (success) {
        result->first_party_sets_access_delegate_receiver =
            input.TakeFirstPartySetsAccessDelegateReceiver<decltype(result->first_party_sets_access_delegate_receiver)>();
      }
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::NetworkConditions::DataView, ::network::mojom::NetworkConditionsPtr>::Read(
    ::network::mojom::NetworkConditions::DataView input,
    ::network::mojom::NetworkConditionsPtr* output) {
  bool success = true;
  ::network::mojom::NetworkConditionsPtr result(::network::mojom::NetworkConditions::New());
  
      if (success)
        result->offline = input.offline();
      if (success && !input.ReadLatency(&result->latency))
        success = false;
      if (success)
        result->download_throughput = input.download_throughput();
      if (success)
        result->upload_throughput = input.upload_throughput();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::ClearDataFilter::DataView, ::network::mojom::ClearDataFilterPtr>::Read(
    ::network::mojom::ClearDataFilter::DataView input,
    ::network::mojom::ClearDataFilterPtr* output) {
  bool success = true;
  ::network::mojom::ClearDataFilterPtr result(::network::mojom::ClearDataFilter::New());
  
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success && !input.ReadDomains(&result->domains))
        success = false;
      if (success && !input.ReadOrigins(&result->origins))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::SignedExchangeReport::DataView, ::network::mojom::SignedExchangeReportPtr>::Read(
    ::network::mojom::SignedExchangeReport::DataView input,
    ::network::mojom::SignedExchangeReportPtr* output) {
  bool success = true;
  ::network::mojom::SignedExchangeReportPtr result(::network::mojom::SignedExchangeReport::New());
  
      if (success)
        result->success = input.success();
      if (success && !input.ReadType(&result->type))
        success = false;
      if (success && !input.ReadOuterUrl(&result->outer_url))
        success = false;
      if (success && !input.ReadInnerUrl(&result->inner_url))
        success = false;
      if (success && !input.ReadCertUrl(&result->cert_url))
        success = false;
      if (success && !input.ReadReferrer(&result->referrer))
        success = false;
      if (success && !input.ReadServerIpAddress(&result->server_ip_address))
        success = false;
      if (success && !input.ReadProtocol(&result->protocol))
        success = false;
      if (success && !input.ReadMethod(&result->method))
        success = false;
      if (success)
        result->status_code = input.status_code();
      if (success && !input.ReadElapsedTime(&result->elapsed_time))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::URLLoaderFactoryOverride::DataView, ::network::mojom::URLLoaderFactoryOverridePtr>::Read(
    ::network::mojom::URLLoaderFactoryOverride::DataView input,
    ::network::mojom::URLLoaderFactoryOverridePtr* output) {
  bool success = true;
  ::network::mojom::URLLoaderFactoryOverridePtr result(::network::mojom::URLLoaderFactoryOverride::New());
  
      if (success) {
        result->overriding_factory =
            input.TakeOverridingFactory<decltype(result->overriding_factory)>();
      }
      if (success) {
        result->overridden_factory_receiver =
            input.TakeOverriddenFactoryReceiver<decltype(result->overridden_factory_receiver)>();
      }
      if (success)
        result->skip_cors_enabled_scheme_check = input.skip_cors_enabled_scheme_check();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::network::mojom::URLLoaderFactoryParams::DataView, ::network::mojom::URLLoaderFactoryParamsPtr>::Read(
    ::network::mojom::URLLoaderFactoryParams::DataView input,
    ::network::mojom::URLLoaderFactoryParamsPtr* output) {
  bool success = true;
  ::network::mojom::URLLoaderFactoryParamsPtr result(::network::mojom::URLLoaderFactoryParams::New());
  
      if (success)
        result->process_id = input.process_id();
      if (success && !input.ReadRequestInitiatorOriginLock(&result->request_initiator_origin_lock))
        success = false;
      if (success)
        result->is_corb_enabled = input.is_corb_enabled();
      if (success)
        result->ignore_isolated_world_origin = input.ignore_isolated_world_origin();
      if (success)
        result->unsafe_non_webby_initiator = input.unsafe_non_webby_initiator();
      if (success)
        result->disable_web_security = input.disable_web_security();
      if (success) {
        result->header_client =
            input.TakeHeaderClient<decltype(result->header_client)>();
      }
      if (success && !input.ReadIsolationInfo(&result->isolation_info))
        success = false;
      if (success)
        result->disable_secure_dns = input.disable_secure_dns();
      if (success)
        result->is_trusted = input.is_trusted();
      if (success)
        result->automatically_assign_isolation_info = input.automatically_assign_isolation_info();
      if (success)
        result->provide_loading_state_updates = input.provide_loading_state_updates();
      if (success && !input.ReadTopFrameId(&result->top_frame_id))
        success = false;
      if (success && !input.ReadFactoryOverride(&result->factory_override))
        success = false;
      if (success && !input.ReadClientSecurityState(&result->client_security_state))
        success = false;
      if (success) {
        result->coep_reporter =
            input.TakeCoepReporter<decltype(result->coep_reporter)>();
      }
      if (success) {
        result->cookie_observer =
            input.TakeCookieObserver<decltype(result->cookie_observer)>();
      }
      if (success) {
        result->url_loader_network_observer =
            input.TakeUrlLoaderNetworkObserver<decltype(result->url_loader_network_observer)>();
      }
      if (success) {
        result->devtools_observer =
            input.TakeDevtoolsObserver<decltype(result->devtools_observer)>();
      }
      if (success && !input.ReadTrustTokenRedemptionPolicy(&result->trust_token_redemption_policy))
        success = false;
      if (success && !input.ReadDebugTag(&result->debug_tag))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace network {
namespace mojom {


void CustomProxyConnectionObserverInterceptorForTesting::OnFallback(const ::net::ProxyServer& bad_proxy, int32_t net_error) {
  GetForwardingInterface()->OnFallback(std::move(bad_proxy), std::move(net_error));
}
void CustomProxyConnectionObserverInterceptorForTesting::OnTunnelHeadersReceived(const ::net::ProxyServer& proxy_server, const ::scoped_refptr<::net::HttpResponseHeaders>& response_headers) {
  GetForwardingInterface()->OnTunnelHeadersReceived(std::move(proxy_server), std::move(response_headers));
}
CustomProxyConnectionObserverAsyncWaiter::CustomProxyConnectionObserverAsyncWaiter(
    CustomProxyConnectionObserver* proxy) : proxy_(proxy) {}

CustomProxyConnectionObserverAsyncWaiter::~CustomProxyConnectionObserverAsyncWaiter() = default;




void CustomProxyConfigClientInterceptorForTesting::OnCustomProxyConfigUpdated(CustomProxyConfigPtr proxy_config, OnCustomProxyConfigUpdatedCallback callback) {
  GetForwardingInterface()->OnCustomProxyConfigUpdated(std::move(proxy_config), std::move(callback));
}
void CustomProxyConfigClientInterceptorForTesting::MarkProxiesAsBad(::base::TimeDelta bypass_duration, const ::net::ProxyList& bad_proxies, MarkProxiesAsBadCallback callback) {
  GetForwardingInterface()->MarkProxiesAsBad(std::move(bypass_duration), std::move(bad_proxies), std::move(callback));
}
void CustomProxyConfigClientInterceptorForTesting::ClearBadProxiesCache() {
  GetForwardingInterface()->ClearBadProxiesCache();
}
CustomProxyConfigClientAsyncWaiter::CustomProxyConfigClientAsyncWaiter(
    CustomProxyConfigClient* proxy) : proxy_(proxy) {}

CustomProxyConfigClientAsyncWaiter::~CustomProxyConfigClientAsyncWaiter() = default;

void CustomProxyConfigClientAsyncWaiter::OnCustomProxyConfigUpdated(
    CustomProxyConfigPtr proxy_config) {
  base::RunLoop loop;
  proxy_->OnCustomProxyConfigUpdated(std::move(proxy_config),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void CustomProxyConfigClientAsyncWaiter::MarkProxiesAsBad(
    ::base::TimeDelta bypass_duration, const ::net::ProxyList& bad_proxies) {
  base::RunLoop loop;
  proxy_->MarkProxiesAsBad(std::move(bypass_duration),std::move(bad_proxies),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}



void TrustedHeaderClientInterceptorForTesting::OnBeforeSendHeaders(const ::net::HttpRequestHeaders& headers, OnBeforeSendHeadersCallback callback) {
  GetForwardingInterface()->OnBeforeSendHeaders(std::move(headers), std::move(callback));
}
void TrustedHeaderClientInterceptorForTesting::OnHeadersReceived(const std::string& headers, const ::net::IPEndPoint& remote_endpoint, OnHeadersReceivedCallback callback) {
  GetForwardingInterface()->OnHeadersReceived(std::move(headers), std::move(remote_endpoint), std::move(callback));
}
TrustedHeaderClientAsyncWaiter::TrustedHeaderClientAsyncWaiter(
    TrustedHeaderClient* proxy) : proxy_(proxy) {}

TrustedHeaderClientAsyncWaiter::~TrustedHeaderClientAsyncWaiter() = default;

void TrustedHeaderClientAsyncWaiter::OnBeforeSendHeaders(
    const ::net::HttpRequestHeaders& headers, int32_t* out_result, absl::optional<::net::HttpRequestHeaders>* out_headers) {
  base::RunLoop loop;
  proxy_->OnBeforeSendHeaders(std::move(headers),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             absl::optional<::net::HttpRequestHeaders>* out_headers
,
             int32_t result,
             const absl::optional<::net::HttpRequestHeaders>& headers) {*out_result = std::move(result);*out_headers = std::move(headers);
            loop->Quit();
          },
          &loop,
          out_result,
          out_headers));
  loop.Run();
}
void TrustedHeaderClientAsyncWaiter::OnHeadersReceived(
    const std::string& headers, const ::net::IPEndPoint& remote_endpoint, int32_t* out_result, absl::optional<std::string>* out_headers, absl::optional<::GURL>* out_preserve_fragment_on_redirect_url) {
  base::RunLoop loop;
  proxy_->OnHeadersReceived(std::move(headers),std::move(remote_endpoint),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             absl::optional<std::string>* out_headers
,
             absl::optional<::GURL>* out_preserve_fragment_on_redirect_url
,
             int32_t result,
             const absl::optional<std::string>& headers,
             const absl::optional<::GURL>& preserve_fragment_on_redirect_url) {*out_result = std::move(result);*out_headers = std::move(headers);*out_preserve_fragment_on_redirect_url = std::move(preserve_fragment_on_redirect_url);
            loop->Quit();
          },
          &loop,
          out_result,
          out_headers,
          out_preserve_fragment_on_redirect_url));
  loop.Run();
}



void TrustedURLLoaderHeaderClientInterceptorForTesting::OnLoaderCreated(int32_t request_id, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) {
  GetForwardingInterface()->OnLoaderCreated(std::move(request_id), std::move(header_client));
}
void TrustedURLLoaderHeaderClientInterceptorForTesting::OnLoaderForCorsPreflightCreated(const ::network::ResourceRequest& request, ::mojo::PendingReceiver<TrustedHeaderClient> header_client) {
  GetForwardingInterface()->OnLoaderForCorsPreflightCreated(std::move(request), std::move(header_client));
}
TrustedURLLoaderHeaderClientAsyncWaiter::TrustedURLLoaderHeaderClientAsyncWaiter(
    TrustedURLLoaderHeaderClient* proxy) : proxy_(proxy) {}

TrustedURLLoaderHeaderClientAsyncWaiter::~TrustedURLLoaderHeaderClientAsyncWaiter() = default;




void NetworkContextClientInterceptorForTesting::OnFileUploadRequested(int32_t process_id, bool async, const std::vector<::base::FilePath>& file_paths, const ::GURL& destination_url, OnFileUploadRequestedCallback callback) {
  GetForwardingInterface()->OnFileUploadRequested(std::move(process_id), std::move(async), std::move(file_paths), std::move(destination_url), std::move(callback));
}
void NetworkContextClientInterceptorForTesting::OnCanSendReportingReports(const std::vector<::url::Origin>& origins, OnCanSendReportingReportsCallback callback) {
  GetForwardingInterface()->OnCanSendReportingReports(std::move(origins), std::move(callback));
}
void NetworkContextClientInterceptorForTesting::OnCanSendDomainReliabilityUpload(const ::url::Origin& origin, OnCanSendDomainReliabilityUploadCallback callback) {
  GetForwardingInterface()->OnCanSendDomainReliabilityUpload(std::move(origin), std::move(callback));
}
void NetworkContextClientInterceptorForTesting::OnGenerateHttpNegotiateAuthToken(const std::string& server_auth_token, bool can_delegate, const std::string& auth_negotiate_android_account_type, const std::string& spn, OnGenerateHttpNegotiateAuthTokenCallback callback) {
  GetForwardingInterface()->OnGenerateHttpNegotiateAuthToken(std::move(server_auth_token), std::move(can_delegate), std::move(auth_negotiate_android_account_type), std::move(spn), std::move(callback));
}
void NetworkContextClientInterceptorForTesting::OnTrustTokenIssuanceDivertedToSystem(::network::mojom::FulfillTrustTokenIssuanceRequestPtr request, OnTrustTokenIssuanceDivertedToSystemCallback callback) {
  GetForwardingInterface()->OnTrustTokenIssuanceDivertedToSystem(std::move(request), std::move(callback));
}
void NetworkContextClientInterceptorForTesting::OnCanSendSCTAuditingReport(OnCanSendSCTAuditingReportCallback callback) {
  GetForwardingInterface()->OnCanSendSCTAuditingReport(std::move(callback));
}
void NetworkContextClientInterceptorForTesting::OnNewSCTAuditingReportSent() {
  GetForwardingInterface()->OnNewSCTAuditingReportSent();
}
NetworkContextClientAsyncWaiter::NetworkContextClientAsyncWaiter(
    NetworkContextClient* proxy) : proxy_(proxy) {}

NetworkContextClientAsyncWaiter::~NetworkContextClientAsyncWaiter() = default;

void NetworkContextClientAsyncWaiter::OnFileUploadRequested(
    int32_t process_id, bool async, const std::vector<::base::FilePath>& file_paths, const ::GURL& destination_url, int32_t* out_net_error, std::vector<::base::File>* out_files) {
  base::RunLoop loop;
  proxy_->OnFileUploadRequested(std::move(process_id),std::move(async),std::move(file_paths),std::move(destination_url),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_net_error
,
             std::vector<::base::File>* out_files
,
             int32_t net_error,
             std::vector<::base::File> files) {*out_net_error = std::move(net_error);*out_files = std::move(files);
            loop->Quit();
          },
          &loop,
          out_net_error,
          out_files));
  loop.Run();
}
void NetworkContextClientAsyncWaiter::OnCanSendReportingReports(
    const std::vector<::url::Origin>& origins, std::vector<::url::Origin>* out_origins) {
  base::RunLoop loop;
  proxy_->OnCanSendReportingReports(std::move(origins),
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<::url::Origin>* out_origins
,
             const std::vector<::url::Origin>& origins) {*out_origins = std::move(origins);
            loop->Quit();
          },
          &loop,
          out_origins));
  loop.Run();
}
void NetworkContextClientAsyncWaiter::OnCanSendDomainReliabilityUpload(
    const ::url::Origin& origin, bool* out_allowed) {
  base::RunLoop loop;
  proxy_->OnCanSendDomainReliabilityUpload(std::move(origin),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_allowed
,
             bool allowed) {*out_allowed = std::move(allowed);
            loop->Quit();
          },
          &loop,
          out_allowed));
  loop.Run();
}
void NetworkContextClientAsyncWaiter::OnGenerateHttpNegotiateAuthToken(
    const std::string& server_auth_token, bool can_delegate, const std::string& auth_negotiate_android_account_type, const std::string& spn, int32_t* out_result, std::string* out_auth_token) {
  base::RunLoop loop;
  proxy_->OnGenerateHttpNegotiateAuthToken(std::move(server_auth_token),std::move(can_delegate),std::move(auth_negotiate_android_account_type),std::move(spn),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             std::string* out_auth_token
,
             int32_t result,
             const std::string& auth_token) {*out_result = std::move(result);*out_auth_token = std::move(auth_token);
            loop->Quit();
          },
          &loop,
          out_result,
          out_auth_token));
  loop.Run();
}
void NetworkContextClientAsyncWaiter::OnTrustTokenIssuanceDivertedToSystem(
    ::network::mojom::FulfillTrustTokenIssuanceRequestPtr request, ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr* out_response) {
  base::RunLoop loop;
  proxy_->OnTrustTokenIssuanceDivertedToSystem(std::move(request),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr* out_response
,
             ::network::mojom::FulfillTrustTokenIssuanceAnswerPtr response) {*out_response = std::move(response);
            loop->Quit();
          },
          &loop,
          out_response));
  loop.Run();
}
void NetworkContextClientAsyncWaiter::OnCanSendSCTAuditingReport(
    bool* out_allowed) {
  base::RunLoop loop;
  proxy_->OnCanSendSCTAuditingReport(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_allowed
,
             bool allowed) {*out_allowed = std::move(allowed);
            loop->Quit();
          },
          &loop,
          out_allowed));
  loop.Run();
}



void NetworkContextInterceptorForTesting::SetClient(::mojo::PendingRemote<NetworkContextClient> client) {
  GetForwardingInterface()->SetClient(std::move(client));
}
void NetworkContextInterceptorForTesting::CreateURLLoaderFactory(::mojo::PendingReceiver<::network::mojom::URLLoaderFactory> url_loader_factory, URLLoaderFactoryParamsPtr params) {
  GetForwardingInterface()->CreateURLLoaderFactory(std::move(url_loader_factory), std::move(params));
}
void NetworkContextInterceptorForTesting::ResetURLLoaderFactories() {
  GetForwardingInterface()->ResetURLLoaderFactories();
}
void NetworkContextInterceptorForTesting::GetCookieManager(::mojo::PendingReceiver<::network::mojom::CookieManager> cookie_manager) {
  GetForwardingInterface()->GetCookieManager(std::move(cookie_manager));
}
void NetworkContextInterceptorForTesting::GetRestrictedCookieManager(::mojo::PendingReceiver<::network::mojom::RestrictedCookieManager> restricted_cookie_manager, ::network::mojom::RestrictedCookieManagerRole role, const ::url::Origin& origin, const ::net::IsolationInfo& isolation_info, ::mojo::PendingRemote<::network::mojom::CookieAccessObserver> cookie_observer) {
  GetForwardingInterface()->GetRestrictedCookieManager(std::move(restricted_cookie_manager), std::move(role), std::move(origin), std::move(isolation_info), std::move(cookie_observer));
}
void NetworkContextInterceptorForTesting::GetTrustTokenQueryAnswerer(::mojo::PendingReceiver<::network::mojom::TrustTokenQueryAnswerer> trust_token_query_answerer, const ::url::Origin& top_frame_origin) {
  GetForwardingInterface()->GetTrustTokenQueryAnswerer(std::move(trust_token_query_answerer), std::move(top_frame_origin));
}
void NetworkContextInterceptorForTesting::ClearTrustTokenData(ClearDataFilterPtr filter, ClearTrustTokenDataCallback callback) {
  GetForwardingInterface()->ClearTrustTokenData(std::move(filter), std::move(callback));
}
void NetworkContextInterceptorForTesting::GetStoredTrustTokenCounts(GetStoredTrustTokenCountsCallback callback) {
  GetForwardingInterface()->GetStoredTrustTokenCounts(std::move(callback));
}
void NetworkContextInterceptorForTesting::DeleteStoredTrustTokens(const ::url::Origin& issuer, DeleteStoredTrustTokensCallback callback) {
  GetForwardingInterface()->DeleteStoredTrustTokens(std::move(issuer), std::move(callback));
}
void NetworkContextInterceptorForTesting::SetBlockTrustTokens(bool block) {
  GetForwardingInterface()->SetBlockTrustTokens(std::move(block));
}
void NetworkContextInterceptorForTesting::ClearNetworkingHistoryBetween(::base::Time start_time, ::base::Time end_time, ClearNetworkingHistoryBetweenCallback callback) {
  GetForwardingInterface()->ClearNetworkingHistoryBetween(std::move(start_time), std::move(end_time), std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearHttpCache(::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter, ClearHttpCacheCallback callback) {
  GetForwardingInterface()->ClearHttpCache(std::move(start_time), std::move(end_time), std::move(filter), std::move(callback));
}
void NetworkContextInterceptorForTesting::ComputeHttpCacheSize(::base::Time start_time, ::base::Time end_time, ComputeHttpCacheSizeCallback callback) {
  GetForwardingInterface()->ComputeHttpCacheSize(std::move(start_time), std::move(end_time), std::move(callback));
}
void NetworkContextInterceptorForTesting::NotifyExternalCacheHit(const ::GURL& url, const std::string& http_method, const ::net::NetworkIsolationKey& key, bool is_subframe_document_resource, bool include_credentials) {
  GetForwardingInterface()->NotifyExternalCacheHit(std::move(url), std::move(http_method), std::move(key), std::move(is_subframe_document_resource), std::move(include_credentials));
}
void NetworkContextInterceptorForTesting::ClearHostCache(ClearDataFilterPtr filter, ClearHostCacheCallback callback) {
  GetForwardingInterface()->ClearHostCache(std::move(filter), std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearHttpAuthCache(::base::Time start_time, ::base::Time end_time, ClearHttpAuthCacheCallback callback) {
  GetForwardingInterface()->ClearHttpAuthCache(std::move(start_time), std::move(end_time), std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearReportingCacheReports(ClearDataFilterPtr filter, ClearReportingCacheReportsCallback callback) {
  GetForwardingInterface()->ClearReportingCacheReports(std::move(filter), std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearReportingCacheClients(ClearDataFilterPtr filter, ClearReportingCacheClientsCallback callback) {
  GetForwardingInterface()->ClearReportingCacheClients(std::move(filter), std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearNetworkErrorLogging(ClearDataFilterPtr filter, ClearNetworkErrorLoggingCallback callback) {
  GetForwardingInterface()->ClearNetworkErrorLogging(std::move(filter), std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearDomainReliability(ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode, ClearDomainReliabilityCallback callback) {
  GetForwardingInterface()->ClearDomainReliability(std::move(filter), std::move(mode), std::move(callback));
}
void NetworkContextInterceptorForTesting::SetDocumentReportingEndpoints(const ::base::UnguessableToken& reporting_source, const ::url::Origin& origin, const ::net::IsolationInfo& isolation_info, const base::flat_map<std::string, std::string>& endpoints) {
  GetForwardingInterface()->SetDocumentReportingEndpoints(std::move(reporting_source), std::move(origin), std::move(isolation_info), std::move(endpoints));
}
void NetworkContextInterceptorForTesting::SendReportsAndRemoveSource(const ::base::UnguessableToken& reporting_source) {
  GetForwardingInterface()->SendReportsAndRemoveSource(std::move(reporting_source));
}
void NetworkContextInterceptorForTesting::QueueReport(const std::string& type, const std::string& group, const ::GURL& url, const absl::optional<::base::UnguessableToken>& reporting_source, const ::net::NetworkIsolationKey& network_isolation_key, const absl::optional<std::string>& user_agent, ::base::Value::Dict body) {
  GetForwardingInterface()->QueueReport(std::move(type), std::move(group), std::move(url), std::move(reporting_source), std::move(network_isolation_key), std::move(user_agent), std::move(body));
}
void NetworkContextInterceptorForTesting::QueueSignedExchangeReport(SignedExchangeReportPtr report, const ::net::NetworkIsolationKey& network_isolation_key) {
  GetForwardingInterface()->QueueSignedExchangeReport(std::move(report), std::move(network_isolation_key));
}
void NetworkContextInterceptorForTesting::CloseAllConnections(CloseAllConnectionsCallback callback) {
  GetForwardingInterface()->CloseAllConnections(std::move(callback));
}
void NetworkContextInterceptorForTesting::CloseIdleConnections(CloseIdleConnectionsCallback callback) {
  GetForwardingInterface()->CloseIdleConnections(std::move(callback));
}
void NetworkContextInterceptorForTesting::SetNetworkConditions(const ::base::UnguessableToken& throttling_profile_id, NetworkConditionsPtr conditions) {
  GetForwardingInterface()->SetNetworkConditions(std::move(throttling_profile_id), std::move(conditions));
}
void NetworkContextInterceptorForTesting::SetAcceptLanguage(const std::string& new_accept_language) {
  GetForwardingInterface()->SetAcceptLanguage(std::move(new_accept_language));
}
void NetworkContextInterceptorForTesting::SetEnableReferrers(bool enable_referrers) {
  GetForwardingInterface()->SetEnableReferrers(std::move(enable_referrers));
}
void NetworkContextInterceptorForTesting::SetCTPolicy(CTPolicyPtr ct_policy) {
  GetForwardingInterface()->SetCTPolicy(std::move(ct_policy));
}
void NetworkContextInterceptorForTesting::AddExpectCT(const std::string& host, ::base::Time expiry, bool enforce, const ::GURL& report_uri, const ::net::NetworkIsolationKey& network_isolation_key, AddExpectCTCallback callback) {
  GetForwardingInterface()->AddExpectCT(std::move(host), std::move(expiry), std::move(enforce), std::move(report_uri), std::move(network_isolation_key), std::move(callback));
}
void NetworkContextInterceptorForTesting::SetExpectCTTestReport(const ::GURL& report_uri, SetExpectCTTestReportCallback callback) {
  GetForwardingInterface()->SetExpectCTTestReport(std::move(report_uri), std::move(callback));
}
void NetworkContextInterceptorForTesting::GetExpectCTState(const std::string& domain, const ::net::NetworkIsolationKey& network_isolation_key, GetExpectCTStateCallback callback) {
  GetForwardingInterface()->GetExpectCTState(std::move(domain), std::move(network_isolation_key), std::move(callback));
}
void NetworkContextInterceptorForTesting::CreateUDPSocket(::mojo::PendingReceiver<::network::mojom::UDPSocket> receiver, ::mojo::PendingRemote<::network::mojom::UDPSocketListener> listener) {
  GetForwardingInterface()->CreateUDPSocket(std::move(receiver), std::move(listener));
}
void NetworkContextInterceptorForTesting::CreateTCPServerSocket(const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPServerSocket> socket, CreateTCPServerSocketCallback callback) {
  GetForwardingInterface()->CreateTCPServerSocket(std::move(local_addr), std::move(backlog), std::move(traffic_annotation), std::move(socket), std::move(callback));
}
void NetworkContextInterceptorForTesting::CreateTCPConnectedSocket(const absl::optional<::net::IPEndPoint>& local_addr, const ::net::AddressList& remote_addr_list, ::network::mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket> socket, ::mojo::PendingRemote<::network::mojom::SocketObserver> observer, CreateTCPConnectedSocketCallback callback) {
  GetForwardingInterface()->CreateTCPConnectedSocket(std::move(local_addr), std::move(remote_addr_list), std::move(tcp_connected_socket_options), std::move(traffic_annotation), std::move(socket), std::move(observer), std::move(callback));
}
void NetworkContextInterceptorForTesting::CreateTCPBoundSocket(const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket> socket, CreateTCPBoundSocketCallback callback) {
  GetForwardingInterface()->CreateTCPBoundSocket(std::move(local_addr), std::move(traffic_annotation), std::move(socket), std::move(callback));
}
void NetworkContextInterceptorForTesting::CreateProxyResolvingSocketFactory(::mojo::PendingReceiver<::network::mojom::ProxyResolvingSocketFactory> factory) {
  GetForwardingInterface()->CreateProxyResolvingSocketFactory(std::move(factory));
}
void NetworkContextInterceptorForTesting::LookUpProxyForURL(const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, ::mojo::PendingRemote<::network::mojom::ProxyLookupClient> proxy_lookup_client) {
  GetForwardingInterface()->LookUpProxyForURL(std::move(url), std::move(network_isolation_key), std::move(proxy_lookup_client));
}
void NetworkContextInterceptorForTesting::ForceReloadProxyConfig(ForceReloadProxyConfigCallback callback) {
  GetForwardingInterface()->ForceReloadProxyConfig(std::move(callback));
}
void NetworkContextInterceptorForTesting::ClearBadProxiesCache(ClearBadProxiesCacheCallback callback) {
  GetForwardingInterface()->ClearBadProxiesCache(std::move(callback));
}
void NetworkContextInterceptorForTesting::CreateWebSocket(const ::GURL& url, const std::vector<std::string>& requested_protocols, const ::net::SiteForCookies& site_for_cookies, const ::net::IsolationInfo& isolation_info, std::vector<::network::mojom::HttpHeaderPtr> additional_headers, int32_t process_id, const ::url::Origin& origin, uint32_t options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingRemote<::network::mojom::WebSocketHandshakeClient> handshake_client, ::mojo::PendingRemote<::network::mojom::URLLoaderNetworkServiceObserver> url_loader_network_observer, ::mojo::PendingRemote<::network::mojom::WebSocketAuthenticationHandler> auth_handler, ::mojo::PendingRemote<TrustedHeaderClient> header_client, const absl::optional<::base::UnguessableToken>& throttling_profile_id) {
  GetForwardingInterface()->CreateWebSocket(std::move(url), std::move(requested_protocols), std::move(site_for_cookies), std::move(isolation_info), std::move(additional_headers), std::move(process_id), std::move(origin), std::move(options), std::move(traffic_annotation), std::move(handshake_client), std::move(url_loader_network_observer), std::move(auth_handler), std::move(header_client), std::move(throttling_profile_id));
}
void NetworkContextInterceptorForTesting::CreateWebTransport(const ::GURL& url, const ::url::Origin& origin, const ::net::NetworkIsolationKey& network_isolation_key, std::vector<::network::mojom::WebTransportCertificateFingerprintPtr> fingerprints, ::mojo::PendingRemote<::network::mojom::WebTransportHandshakeClient> handshake_client) {
  GetForwardingInterface()->CreateWebTransport(std::move(url), std::move(origin), std::move(network_isolation_key), std::move(fingerprints), std::move(handshake_client));
}
void NetworkContextInterceptorForTesting::CreateNetLogExporter(::mojo::PendingReceiver<::network::mojom::NetLogExporter> receiver) {
  GetForwardingInterface()->CreateNetLogExporter(std::move(receiver));
}
void NetworkContextInterceptorForTesting::PreconnectSockets(uint32_t num_streams, const ::GURL& url, bool allow_credentials, const ::net::NetworkIsolationKey& network_isolation_key) {
  GetForwardingInterface()->PreconnectSockets(std::move(num_streams), std::move(url), std::move(allow_credentials), std::move(network_isolation_key));
}
void NetworkContextInterceptorForTesting::CreateP2PSocketManager(const ::net::NetworkIsolationKey& network_isolation_key, ::mojo::PendingRemote<::network::mojom::P2PTrustedSocketManagerClient> client, ::mojo::PendingReceiver<::network::mojom::P2PTrustedSocketManager> trusted_socket_manager, ::mojo::PendingReceiver<::network::mojom::P2PSocketManager> socket_manager) {
  GetForwardingInterface()->CreateP2PSocketManager(std::move(network_isolation_key), std::move(client), std::move(trusted_socket_manager), std::move(socket_manager));
}
void NetworkContextInterceptorForTesting::CreateMdnsResponder(::mojo::PendingReceiver<::network::mojom::MdnsResponder> responder_receiver) {
  GetForwardingInterface()->CreateMdnsResponder(std::move(responder_receiver));
}
void NetworkContextInterceptorForTesting::ResolveHost(const ::net::HostPortPair& host, const ::net::NetworkIsolationKey& network_isolation_key, ::network::mojom::ResolveHostParametersPtr optional_parameters, ::mojo::PendingRemote<::network::mojom::ResolveHostClient> response_client) {
  GetForwardingInterface()->ResolveHost(std::move(host), std::move(network_isolation_key), std::move(optional_parameters), std::move(response_client));
}
void NetworkContextInterceptorForTesting::CreateHostResolver(const absl::optional<::net::DnsConfigOverrides>& config_overrides, ::mojo::PendingReceiver<::network::mojom::HostResolver> host_resolver) {
  GetForwardingInterface()->CreateHostResolver(std::move(config_overrides), std::move(host_resolver));
}
void NetworkContextInterceptorForTesting::VerifyCertForSignedExchange(const ::scoped_refptr<::net::X509Certificate>& certificate, const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, const std::string& ocsp_response, const std::string& sct_list, VerifyCertForSignedExchangeCallback callback) {
  GetForwardingInterface()->VerifyCertForSignedExchange(std::move(certificate), std::move(url), std::move(network_isolation_key), std::move(ocsp_response), std::move(sct_list), std::move(callback));
}
void NetworkContextInterceptorForTesting::AddHSTS(const std::string& host, ::base::Time expiry, bool include_subdomains, AddHSTSCallback callback) {
  GetForwardingInterface()->AddHSTS(std::move(host), std::move(expiry), std::move(include_subdomains), std::move(callback));
}
void NetworkContextInterceptorForTesting::IsHSTSActiveForHost(const std::string& host, IsHSTSActiveForHostCallback callback) {
  GetForwardingInterface()->IsHSTSActiveForHost(std::move(host), std::move(callback));
}
void NetworkContextInterceptorForTesting::GetHSTSState(const std::string& domain, GetHSTSStateCallback callback) {
  GetForwardingInterface()->GetHSTSState(std::move(domain), std::move(callback));
}
void NetworkContextInterceptorForTesting::SetCorsOriginAccessListsForOrigin(const ::url::Origin& source_origin, std::vector<::network::mojom::CorsOriginPatternPtr> allow_patterns, std::vector<::network::mojom::CorsOriginPatternPtr> block_patterns, SetCorsOriginAccessListsForOriginCallback callback) {
  GetForwardingInterface()->SetCorsOriginAccessListsForOrigin(std::move(source_origin), std::move(allow_patterns), std::move(block_patterns), std::move(callback));
}
void NetworkContextInterceptorForTesting::DeleteDynamicDataForHost(const std::string& host, DeleteDynamicDataForHostCallback callback) {
  GetForwardingInterface()->DeleteDynamicDataForHost(std::move(host), std::move(callback));
}
void NetworkContextInterceptorForTesting::SetSplitAuthCacheByNetworkIsolationKey(bool split_auth_cache_by_network_isolation_key) {
  GetForwardingInterface()->SetSplitAuthCacheByNetworkIsolationKey(std::move(split_auth_cache_by_network_isolation_key));
}
void NetworkContextInterceptorForTesting::SaveHttpAuthCacheProxyEntries(SaveHttpAuthCacheProxyEntriesCallback callback) {
  GetForwardingInterface()->SaveHttpAuthCacheProxyEntries(std::move(callback));
}
void NetworkContextInterceptorForTesting::LoadHttpAuthCacheProxyEntries(const ::base::UnguessableToken& cache_key, LoadHttpAuthCacheProxyEntriesCallback callback) {
  GetForwardingInterface()->LoadHttpAuthCacheProxyEntries(std::move(cache_key), std::move(callback));
}
void NetworkContextInterceptorForTesting::AddAuthCacheEntry(const ::net::AuthChallengeInfo& challenge, const ::net::NetworkIsolationKey& network_isolation_key, const ::net::AuthCredentials& credentials, AddAuthCacheEntryCallback callback) {
  GetForwardingInterface()->AddAuthCacheEntry(std::move(challenge), std::move(network_isolation_key), std::move(credentials), std::move(callback));
}
void NetworkContextInterceptorForTesting::SetCorsNonWildcardRequestHeadersSupport(bool value) {
  GetForwardingInterface()->SetCorsNonWildcardRequestHeadersSupport(std::move(value));
}
void NetworkContextInterceptorForTesting::LookupServerBasicAuthCredentials(const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, LookupServerBasicAuthCredentialsCallback callback) {
  GetForwardingInterface()->LookupServerBasicAuthCredentials(std::move(url), std::move(network_isolation_key), std::move(callback));
}
void NetworkContextInterceptorForTesting::EnableStaticKeyPinningForTesting(EnableStaticKeyPinningForTestingCallback callback) {
  GetForwardingInterface()->EnableStaticKeyPinningForTesting(std::move(callback));
}
void NetworkContextInterceptorForTesting::VerifyCertificateForTesting(const ::scoped_refptr<::net::X509Certificate>& certificate, const std::string& hostname, const std::string& ocsp_response, const std::string& sct_list, VerifyCertificateForTestingCallback callback) {
  GetForwardingInterface()->VerifyCertificateForTesting(std::move(certificate), std::move(hostname), std::move(ocsp_response), std::move(sct_list), std::move(callback));
}
void NetworkContextInterceptorForTesting::AddDomainReliabilityContextForTesting(const ::url::Origin& origin, const ::GURL& upload_url, AddDomainReliabilityContextForTestingCallback callback) {
  GetForwardingInterface()->AddDomainReliabilityContextForTesting(std::move(origin), std::move(upload_url), std::move(callback));
}
void NetworkContextInterceptorForTesting::ForceDomainReliabilityUploadsForTesting(ForceDomainReliabilityUploadsForTestingCallback callback) {
  GetForwardingInterface()->ForceDomainReliabilityUploadsForTesting(std::move(callback));
}
void NetworkContextInterceptorForTesting::SetCTLogListAlwaysTimelyForTesting() {
  GetForwardingInterface()->SetCTLogListAlwaysTimelyForTesting();
}
void NetworkContextInterceptorForTesting::SetSCTAuditingMode(SCTAuditingMode mode) {
  GetForwardingInterface()->SetSCTAuditingMode(std::move(mode));
}
void NetworkContextInterceptorForTesting::AddReportingApiObserver(::mojo::PendingRemote<::network::mojom::ReportingApiObserver> observer) {
  GetForwardingInterface()->AddReportingApiObserver(std::move(observer));
}
NetworkContextAsyncWaiter::NetworkContextAsyncWaiter(
    NetworkContext* proxy) : proxy_(proxy) {}

NetworkContextAsyncWaiter::~NetworkContextAsyncWaiter() = default;

void NetworkContextAsyncWaiter::ClearTrustTokenData(
    ClearDataFilterPtr filter) {
  base::RunLoop loop;
  proxy_->ClearTrustTokenData(std::move(filter),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::GetStoredTrustTokenCounts(
    std::vector<::network::mojom::StoredTrustTokensForIssuerPtr>* out_tokens) {
  base::RunLoop loop;
  proxy_->GetStoredTrustTokenCounts(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<::network::mojom::StoredTrustTokensForIssuerPtr>* out_tokens
,
             std::vector<::network::mojom::StoredTrustTokensForIssuerPtr> tokens) {*out_tokens = std::move(tokens);
            loop->Quit();
          },
          &loop,
          out_tokens));
  loop.Run();
}
void NetworkContextAsyncWaiter::DeleteStoredTrustTokens(
    const ::url::Origin& issuer, ::network::mojom::DeleteStoredTrustTokensStatus* out_status) {
  base::RunLoop loop;
  proxy_->DeleteStoredTrustTokens(std::move(issuer),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::network::mojom::DeleteStoredTrustTokensStatus* out_status
,
             ::network::mojom::DeleteStoredTrustTokensStatus status) {*out_status = std::move(status);
            loop->Quit();
          },
          &loop,
          out_status));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearNetworkingHistoryBetween(
    ::base::Time start_time, ::base::Time end_time) {
  base::RunLoop loop;
  proxy_->ClearNetworkingHistoryBetween(std::move(start_time),std::move(end_time),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearHttpCache(
    ::base::Time start_time, ::base::Time end_time, ClearDataFilterPtr filter) {
  base::RunLoop loop;
  proxy_->ClearHttpCache(std::move(start_time),std::move(end_time),std::move(filter),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ComputeHttpCacheSize(
    ::base::Time start_time, ::base::Time end_time, bool* out_is_upper_bound, int64_t* out_size_or_error) {
  base::RunLoop loop;
  proxy_->ComputeHttpCacheSize(std::move(start_time),std::move(end_time),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_is_upper_bound
,
             int64_t* out_size_or_error
,
             bool is_upper_bound,
             int64_t size_or_error) {*out_is_upper_bound = std::move(is_upper_bound);*out_size_or_error = std::move(size_or_error);
            loop->Quit();
          },
          &loop,
          out_is_upper_bound,
          out_size_or_error));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearHostCache(
    ClearDataFilterPtr filter) {
  base::RunLoop loop;
  proxy_->ClearHostCache(std::move(filter),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearHttpAuthCache(
    ::base::Time start_time, ::base::Time end_time) {
  base::RunLoop loop;
  proxy_->ClearHttpAuthCache(std::move(start_time),std::move(end_time),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearReportingCacheReports(
    ClearDataFilterPtr filter) {
  base::RunLoop loop;
  proxy_->ClearReportingCacheReports(std::move(filter),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearReportingCacheClients(
    ClearDataFilterPtr filter) {
  base::RunLoop loop;
  proxy_->ClearReportingCacheClients(std::move(filter),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearNetworkErrorLogging(
    ClearDataFilterPtr filter) {
  base::RunLoop loop;
  proxy_->ClearNetworkErrorLogging(std::move(filter),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearDomainReliability(
    ClearDataFilterPtr filter, NetworkContext::DomainReliabilityClearMode mode) {
  base::RunLoop loop;
  proxy_->ClearDomainReliability(std::move(filter),std::move(mode),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::CloseAllConnections(
    ) {
  base::RunLoop loop;
  proxy_->CloseAllConnections(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::CloseIdleConnections(
    ) {
  base::RunLoop loop;
  proxy_->CloseIdleConnections(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::AddExpectCT(
    const std::string& host, ::base::Time expiry, bool enforce, const ::GURL& report_uri, const ::net::NetworkIsolationKey& network_isolation_key, bool* out_success) {
  base::RunLoop loop;
  proxy_->AddExpectCT(std::move(host),std::move(expiry),std::move(enforce),std::move(report_uri),std::move(network_isolation_key),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void NetworkContextAsyncWaiter::SetExpectCTTestReport(
    const ::GURL& report_uri, bool* out_success) {
  base::RunLoop loop;
  proxy_->SetExpectCTTestReport(std::move(report_uri),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void NetworkContextAsyncWaiter::GetExpectCTState(
    const std::string& domain, const ::net::NetworkIsolationKey& network_isolation_key, ::base::Value::Dict* out_state) {
  base::RunLoop loop;
  proxy_->GetExpectCTState(std::move(domain),std::move(network_isolation_key),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::Value::Dict* out_state
,
             ::base::Value::Dict state) {*out_state = std::move(state);
            loop->Quit();
          },
          &loop,
          out_state));
  loop.Run();
}
void NetworkContextAsyncWaiter::CreateTCPServerSocket(
    const ::net::IPEndPoint& local_addr, uint32_t backlog, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPServerSocket> socket, int32_t* out_result, absl::optional<::net::IPEndPoint>* out_local_addr_out) {
  base::RunLoop loop;
  proxy_->CreateTCPServerSocket(std::move(local_addr),std::move(backlog),std::move(traffic_annotation),std::move(socket),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             absl::optional<::net::IPEndPoint>* out_local_addr_out
,
             int32_t result,
             const absl::optional<::net::IPEndPoint>& local_addr_out) {*out_result = std::move(result);*out_local_addr_out = std::move(local_addr_out);
            loop->Quit();
          },
          &loop,
          out_result,
          out_local_addr_out));
  loop.Run();
}
void NetworkContextAsyncWaiter::CreateTCPConnectedSocket(
    const absl::optional<::net::IPEndPoint>& local_addr, const ::net::AddressList& remote_addr_list, ::network::mojom::TCPConnectedSocketOptionsPtr tcp_connected_socket_options, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPConnectedSocket> socket, ::mojo::PendingRemote<::network::mojom::SocketObserver> observer, int32_t* out_result, absl::optional<::net::IPEndPoint>* out_local_addr, absl::optional<::net::IPEndPoint>* out_peer_addr, ::mojo::ScopedDataPipeConsumerHandle* out_receive_stream, ::mojo::ScopedDataPipeProducerHandle* out_send_stream) {
  base::RunLoop loop;
  proxy_->CreateTCPConnectedSocket(std::move(local_addr),std::move(remote_addr_list),std::move(tcp_connected_socket_options),std::move(traffic_annotation),std::move(socket),std::move(observer),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             absl::optional<::net::IPEndPoint>* out_local_addr
,
             absl::optional<::net::IPEndPoint>* out_peer_addr
,
             ::mojo::ScopedDataPipeConsumerHandle* out_receive_stream
,
             ::mojo::ScopedDataPipeProducerHandle* out_send_stream
,
             int32_t result,
             const absl::optional<::net::IPEndPoint>& local_addr,
             const absl::optional<::net::IPEndPoint>& peer_addr,
             ::mojo::ScopedDataPipeConsumerHandle receive_stream,
             ::mojo::ScopedDataPipeProducerHandle send_stream) {*out_result = std::move(result);*out_local_addr = std::move(local_addr);*out_peer_addr = std::move(peer_addr);*out_receive_stream = std::move(receive_stream);*out_send_stream = std::move(send_stream);
            loop->Quit();
          },
          &loop,
          out_result,
          out_local_addr,
          out_peer_addr,
          out_receive_stream,
          out_send_stream));
  loop.Run();
}
void NetworkContextAsyncWaiter::CreateTCPBoundSocket(
    const ::net::IPEndPoint& local_addr, const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation, ::mojo::PendingReceiver<::network::mojom::TCPBoundSocket> socket, int32_t* out_result, absl::optional<::net::IPEndPoint>* out_local_addr) {
  base::RunLoop loop;
  proxy_->CreateTCPBoundSocket(std::move(local_addr),std::move(traffic_annotation),std::move(socket),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_result
,
             absl::optional<::net::IPEndPoint>* out_local_addr
,
             int32_t result,
             const absl::optional<::net::IPEndPoint>& local_addr) {*out_result = std::move(result);*out_local_addr = std::move(local_addr);
            loop->Quit();
          },
          &loop,
          out_result,
          out_local_addr));
  loop.Run();
}
void NetworkContextAsyncWaiter::ForceReloadProxyConfig(
    ) {
  base::RunLoop loop;
  proxy_->ForceReloadProxyConfig(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ClearBadProxiesCache(
    ) {
  base::RunLoop loop;
  proxy_->ClearBadProxiesCache(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::VerifyCertForSignedExchange(
    const ::scoped_refptr<::net::X509Certificate>& certificate, const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, const std::string& ocsp_response, const std::string& sct_list, int32_t* out_error_code, ::net::CertVerifyResult* out_cv_result, bool* out_pkp_bypassed, std::string* out_pinning_failure_log) {
  base::RunLoop loop;
  proxy_->VerifyCertForSignedExchange(std::move(certificate),std::move(url),std::move(network_isolation_key),std::move(ocsp_response),std::move(sct_list),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_error_code
,
             ::net::CertVerifyResult* out_cv_result
,
             bool* out_pkp_bypassed
,
             std::string* out_pinning_failure_log
,
             int32_t error_code,
             const ::net::CertVerifyResult& cv_result,
             bool pkp_bypassed,
             const std::string& pinning_failure_log) {*out_error_code = std::move(error_code);*out_cv_result = std::move(cv_result);*out_pkp_bypassed = std::move(pkp_bypassed);*out_pinning_failure_log = std::move(pinning_failure_log);
            loop->Quit();
          },
          &loop,
          out_error_code,
          out_cv_result,
          out_pkp_bypassed,
          out_pinning_failure_log));
  loop.Run();
}
void NetworkContextAsyncWaiter::AddHSTS(
    const std::string& host, ::base::Time expiry, bool include_subdomains) {
  base::RunLoop loop;
  proxy_->AddHSTS(std::move(host),std::move(expiry),std::move(include_subdomains),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::IsHSTSActiveForHost(
    const std::string& host, bool* out_result) {
  base::RunLoop loop;
  proxy_->IsHSTSActiveForHost(std::move(host),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_result
,
             bool result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void NetworkContextAsyncWaiter::GetHSTSState(
    const std::string& domain, ::base::Value::Dict* out_state) {
  base::RunLoop loop;
  proxy_->GetHSTSState(std::move(domain),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::Value::Dict* out_state
,
             ::base::Value::Dict state) {*out_state = std::move(state);
            loop->Quit();
          },
          &loop,
          out_state));
  loop.Run();
}
void NetworkContextAsyncWaiter::SetCorsOriginAccessListsForOrigin(
    const ::url::Origin& source_origin, std::vector<::network::mojom::CorsOriginPatternPtr> allow_patterns, std::vector<::network::mojom::CorsOriginPatternPtr> block_patterns) {
  base::RunLoop loop;
  proxy_->SetCorsOriginAccessListsForOrigin(std::move(source_origin),std::move(allow_patterns),std::move(block_patterns),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::DeleteDynamicDataForHost(
    const std::string& host, bool* out_result) {
  base::RunLoop loop;
  proxy_->DeleteDynamicDataForHost(std::move(host),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_result
,
             bool result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void NetworkContextAsyncWaiter::SaveHttpAuthCacheProxyEntries(
    ::base::UnguessableToken* out_cache_key) {
  base::RunLoop loop;
  proxy_->SaveHttpAuthCacheProxyEntries(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::UnguessableToken* out_cache_key
,
             const ::base::UnguessableToken& cache_key) {*out_cache_key = std::move(cache_key);
            loop->Quit();
          },
          &loop,
          out_cache_key));
  loop.Run();
}
void NetworkContextAsyncWaiter::LoadHttpAuthCacheProxyEntries(
    const ::base::UnguessableToken& cache_key) {
  base::RunLoop loop;
  proxy_->LoadHttpAuthCacheProxyEntries(std::move(cache_key),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::AddAuthCacheEntry(
    const ::net::AuthChallengeInfo& challenge, const ::net::NetworkIsolationKey& network_isolation_key, const ::net::AuthCredentials& credentials) {
  base::RunLoop loop;
  proxy_->AddAuthCacheEntry(std::move(challenge),std::move(network_isolation_key),std::move(credentials),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::LookupServerBasicAuthCredentials(
    const ::GURL& url, const ::net::NetworkIsolationKey& network_isolation_key, absl::optional<::net::AuthCredentials>* out_credentials) {
  base::RunLoop loop;
  proxy_->LookupServerBasicAuthCredentials(std::move(url),std::move(network_isolation_key),
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<::net::AuthCredentials>* out_credentials
,
             const absl::optional<::net::AuthCredentials>& credentials) {*out_credentials = std::move(credentials);
            loop->Quit();
          },
          &loop,
          out_credentials));
  loop.Run();
}
void NetworkContextAsyncWaiter::EnableStaticKeyPinningForTesting(
    ) {
  base::RunLoop loop;
  proxy_->EnableStaticKeyPinningForTesting(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::VerifyCertificateForTesting(
    const ::scoped_refptr<::net::X509Certificate>& certificate, const std::string& hostname, const std::string& ocsp_response, const std::string& sct_list, int32_t* out_error_code) {
  base::RunLoop loop;
  proxy_->VerifyCertificateForTesting(std::move(certificate),std::move(hostname),std::move(ocsp_response),std::move(sct_list),
      base::BindOnce(
          [](base::RunLoop* loop,
             int32_t* out_error_code
,
             int32_t error_code) {*out_error_code = std::move(error_code);
            loop->Quit();
          },
          &loop,
          out_error_code));
  loop.Run();
}
void NetworkContextAsyncWaiter::AddDomainReliabilityContextForTesting(
    const ::url::Origin& origin, const ::GURL& upload_url) {
  base::RunLoop loop;
  proxy_->AddDomainReliabilityContextForTesting(std::move(origin),std::move(upload_url),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void NetworkContextAsyncWaiter::ForceDomainReliabilityUploadsForTesting(
    ) {
  base::RunLoop loop;
  proxy_->ForceDomainReliabilityUploadsForTesting(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace network


#if defined(__clang__)
#pragma clang diagnostic pop
#endif