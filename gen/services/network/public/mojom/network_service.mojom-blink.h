// services/network/public/mojom/network_service.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_BLINK_H_
#define SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "services/network/public/mojom/network_service.mojom-shared.h"
#include "services/network/public/mojom/network_service.mojom-blink-forward.h"
#include "mojo/public/mojom/base/byte_string.mojom-blink.h"
#include "mojo/public/mojom/base/file.mojom-blink.h"
#include "mojo/public/mojom/base/file_path.mojom-blink-forward.h"
#include "mojo/public/mojom/base/memory_pressure_level.mojom-blink-forward.h"
#include "mojo/public/mojom/base/read_only_buffer.mojom-blink.h"
#include "mojo/public/mojom/base/read_only_file.mojom-blink-forward.h"
#include "mojo/public/mojom/base/string16.mojom-blink-forward.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-blink-forward.h"
#include "mojo/public/mojom/base/values.mojom-blink.h"
#include "sandbox/policy/mojom/context.mojom-blink-forward.h"
#include "sandbox/policy/mojom/sandbox.mojom-blink-forward.h"
#include "services/network/public/mojom/first_party_sets.mojom-blink.h"
#include "services/network/public/mojom/host_resolver.mojom-blink-forward.h"
#include "services/network/public/mojom/http_raw_headers.mojom-blink-forward.h"
#include "services/network/public/mojom/key_pinning.mojom-blink-forward.h"
#include "services/network/public/mojom/mutable_network_traffic_annotation_tag.mojom-blink.h"
#include "services/network/public/mojom/net_log.mojom-blink-forward.h"
#include "services/network/public/mojom/network_change_manager.mojom-blink-forward.h"
#include "services/network/public/mojom/network_context.mojom-blink-forward.h"
#include "services/network/public/mojom/ip_address_space.mojom-blink-forward.h"
#include "services/network/public/mojom/network_interface.mojom-blink.h"
#include "services/network/public/mojom/network_param.mojom-blink-forward.h"
#include "services/network/public/mojom/network_quality_estimator_manager.mojom-blink-forward.h"
#include "services/network/public/mojom/network_service_test.mojom-blink-forward.h"
#include "services/network/public/mojom/schemeful_site.mojom-blink.h"
#include "services/network/public/mojom/trust_tokens.mojom-blink-forward.h"
#include "services/network/public/mojom/parsed_headers.mojom-blink-forward.h"
#include "services/network/public/mojom/url_loader_network_service_observer.mojom-blink-forward.h"
#include "services/network/public/mojom/url_request.mojom-blink-forward.h"
#include "services/network/public/mojom/url_response_head.mojom-blink-forward.h"
#include "services/network/public/mojom/client_security_state.mojom-blink-forward.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"
#include "mojo/public/mojom/base/application_state.mojom-blink-forward.h"
#include "services/network/public/mojom/ct_log_info.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/public/platform/web_common.h"




namespace network {
namespace mojom {
namespace blink {

class NetworkServiceProxy;

template <typename ImplRefTraits>
class NetworkServiceStub;

class NetworkServiceRequestValidator;
class NetworkServiceResponseValidator;


class BLINK_PLATFORM_EXPORT NetworkService
    : public NetworkServiceInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr auto kServiceSandbox = sandbox::mojom::Sandbox::kNetwork;
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = NetworkServiceInterfaceBase;
  using Proxy_ = NetworkServiceProxy;

  template <typename ImplRefTraits>
  using Stub_ = NetworkServiceStub<ImplRefTraits>;

  using RequestValidator_ = NetworkServiceRequestValidator;
  using ResponseValidator_ = NetworkServiceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kSetParamsMinVersion = 0,
    kStartNetLogMinVersion = 0,
    kAttachNetLogProxyMinVersion = 0,
    kSetSSLKeyLogFileMinVersion = 0,
    kCreateNetworkContextMinVersion = 0,
    kConfigureStubHostResolverMinVersion = 0,
    kDisableQuicMinVersion = 0,
    kSetUpHttpAuthMinVersion = 0,
    kConfigureHttpAuthPrefsMinVersion = 0,
    kSetRawHeadersAccessMinVersion = 0,
    kSetMaxConnectionsPerProxyMinVersion = 0,
    kGetNetworkChangeManagerMinVersion = 0,
    kGetNetworkQualityEstimatorManagerMinVersion = 0,
    kGetDnsConfigChangeManagerMinVersion = 0,
    kGetNetworkListMinVersion = 0,
    kUpdateCRLSetMinVersion = 0,
    kOnCertDBChangedMinVersion = 0,
    kSetEncryptionKeyMinVersion = 0,
    kOnMemoryPressureMinVersion = 0,
    kOnPeerToPeerConnectionsCountChangeMinVersion = 0,
    kOnApplicationStateChangeMinVersion = 0,
    kSetEnvironmentMinVersion = 0,
    kSetTrustTokenKeyCommitmentsMinVersion = 0,
    kClearSCTAuditingCacheMinVersion = 0,
    kConfigureSCTAuditingMinVersion = 0,
    kUpdateCtLogListMinVersion = 0,
    kUpdateCtKnownPopularSCTsMinVersion = 0,
    kSetCtEnforcementEnabledMinVersion = 0,
    kUpdateKeyPinsListMinVersion = 0,
    kDumpWithoutCrashingMinVersion = 0,
    kBindTestInterfaceMinVersion = 0,
    kSetFirstPartySetsMinVersion = 0,
    kSetExplicitlyAllowedPortsMinVersion = 0,
    kParseHeadersMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct SetParams_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct StartNetLog_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct AttachNetLogProxy_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetSSLKeyLogFile_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateNetworkContext_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ConfigureStubHostResolver_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct DisableQuic_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetUpHttpAuth_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ConfigureHttpAuthPrefs_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetRawHeadersAccess_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetMaxConnectionsPerProxy_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetNetworkChangeManager_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetNetworkQualityEstimatorManager_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetDnsConfigChangeManager_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetNetworkList_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateCRLSet_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnCertDBChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetEncryptionKey_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnMemoryPressure_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnPeerToPeerConnectionsCountChange_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnApplicationStateChange_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetEnvironment_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetTrustTokenKeyCommitments_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearSCTAuditingCache_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ConfigureSCTAuditing_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateCtLogList_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateCtKnownPopularSCTs_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetCtEnforcementEnabled_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateKeyPinsList_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct DumpWithoutCrashing_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct BindTestInterface_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetFirstPartySets_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetExplicitlyAllowedPorts_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ParseHeaders_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~NetworkService() = default;

  
  virtual void SetParams(NetworkServiceParamsPtr params) = 0;

  
  virtual void StartNetLog(::base::File file, ::network::mojom::blink::NetLogCaptureMode capture_mode, ::base::Value::Dict constants) = 0;

  
  virtual void AttachNetLogProxy(::mojo::PendingRemote<::network::mojom::blink::NetLogProxySource> proxy_source, ::mojo::PendingReceiver<::network::mojom::blink::NetLogProxySink> proxy_sink) = 0;

  
  virtual void SetSSLKeyLogFile(::base::File file) = 0;

  
  virtual void CreateNetworkContext(::mojo::PendingReceiver<::network::mojom::blink::NetworkContext> context, ::network::mojom::blink::NetworkContextParamsPtr params) = 0;

  
  virtual void ConfigureStubHostResolver(bool insecure_dns_client_enabled, ::network::mojom::blink::SecureDnsMode secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr dns_over_https_config, bool additional_dns_types_enabled) = 0;

  
  virtual void DisableQuic() = 0;

  
  virtual void SetUpHttpAuth(HttpAuthStaticParamsPtr http_auth_static_params) = 0;

  
  virtual void ConfigureHttpAuthPrefs(HttpAuthDynamicParamsPtr http_auth_dynamic_params) = 0;

  
  virtual void SetRawHeadersAccess(int32_t process_id, const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins) = 0;

  
  virtual void SetMaxConnectionsPerProxy(int32_t max_connections) = 0;

  
  virtual void GetNetworkChangeManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkChangeManager> network_change_manager) = 0;

  
  virtual void GetNetworkQualityEstimatorManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkQualityEstimatorManager> receiver) = 0;

  
  virtual void GetDnsConfigChangeManager(::mojo::PendingReceiver<::network::mojom::blink::DnsConfigChangeManager> receiver) = 0;


  using GetNetworkListCallback = base::OnceCallback<void(const absl::optional<WTF::Vector<::net::NetworkInterface>>&)>;
  
  virtual void GetNetworkList(uint32_t policy, GetNetworkListCallback callback) = 0;


  using UpdateCRLSetCallback = base::OnceCallback<void()>;
  
  virtual void UpdateCRLSet(::base::span<const ::uint8_t> crl_set, UpdateCRLSetCallback callback) = 0;

  
  virtual void OnCertDBChanged() = 0;

  
  virtual void SetEncryptionKey(const std::string& encryption_key) = 0;

  
  virtual void OnMemoryPressure(::mojo_base::mojom::blink::MemoryPressureLevel memory_pressure_level) = 0;

  
  virtual void OnPeerToPeerConnectionsCountChange(uint32_t count) = 0;

  
  virtual void OnApplicationStateChange(::mojo_base::mojom::blink::ApplicationState state) = 0;

  
  virtual void SetEnvironment(WTF::Vector<EnvironmentVariablePtr> environment) = 0;


  using SetTrustTokenKeyCommitmentsCallback = base::OnceCallback<void()>;
  
  virtual void SetTrustTokenKeyCommitments(const WTF::String& raw_commitments, SetTrustTokenKeyCommitmentsCallback callback) = 0;

  
  virtual void ClearSCTAuditingCache() = 0;

  
  virtual void ConfigureSCTAuditing(SCTAuditingConfigurationPtr configuration) = 0;


  using UpdateCtLogListCallback = base::OnceCallback<void()>;
  
  virtual void UpdateCtLogList(WTF::Vector<::network::mojom::blink::CTLogInfoPtr> log_list, ::base::Time update_time, UpdateCtLogListCallback callback) = 0;


  using UpdateCtKnownPopularSCTsCallback = base::OnceCallback<void()>;
  
  virtual void UpdateCtKnownPopularSCTs(const WTF::Vector<WTF::Vector<uint8_t>>& sct_hashes, UpdateCtKnownPopularSCTsCallback callback) = 0;


  using SetCtEnforcementEnabledCallback = base::OnceCallback<void()>;
  
  virtual void SetCtEnforcementEnabled(bool enabled, SetCtEnforcementEnabledCallback callback) = 0;

  
  virtual void UpdateKeyPinsList(::network::mojom::blink::PinListPtr pin_list, ::base::Time update_time) = 0;

  
  virtual void DumpWithoutCrashing(::base::Time dump_request_time) = 0;

  
  virtual void BindTestInterface(::mojo::PendingReceiver<::network::mojom::blink::NetworkServiceTest> receiver) = 0;

  
  virtual void SetFirstPartySets(WTF::HashMap<::blink::BlinkSchemefulSite, ::network::mojom::blink::FirstPartySetEntryPtr> sets) = 0;

  
  virtual void SetExplicitlyAllowedPorts(const WTF::Vector<uint16_t>& ports) = 0;


  using ParseHeadersCallback = base::OnceCallback<void(::network::mojom::blink::ParsedHeadersPtr)>;
  
  virtual void ParseHeaders(const ::blink::KURL& url, ::network::mojom::blink::HttpResponseHeadersPtr headers, ParseHeadersCallback callback) = 0;
};



class BLINK_PLATFORM_EXPORT NetworkServiceProxy
    : public NetworkService {
 public:
  using InterfaceType = NetworkService;

  explicit NetworkServiceProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetParams(NetworkServiceParamsPtr params) final;
  
  void StartNetLog(::base::File file, ::network::mojom::blink::NetLogCaptureMode capture_mode, ::base::Value::Dict constants) final;
  
  void AttachNetLogProxy(::mojo::PendingRemote<::network::mojom::blink::NetLogProxySource> proxy_source, ::mojo::PendingReceiver<::network::mojom::blink::NetLogProxySink> proxy_sink) final;
  
  void SetSSLKeyLogFile(::base::File file) final;
  
  void CreateNetworkContext(::mojo::PendingReceiver<::network::mojom::blink::NetworkContext> context, ::network::mojom::blink::NetworkContextParamsPtr params) final;
  
  void ConfigureStubHostResolver(bool insecure_dns_client_enabled, ::network::mojom::blink::SecureDnsMode secure_dns_mode, ::network::mojom::blink::DnsOverHttpsConfigPtr dns_over_https_config, bool additional_dns_types_enabled) final;
  
  void DisableQuic() final;
  
  void SetUpHttpAuth(HttpAuthStaticParamsPtr http_auth_static_params) final;
  
  void ConfigureHttpAuthPrefs(HttpAuthDynamicParamsPtr http_auth_dynamic_params) final;
  
  void SetRawHeadersAccess(int32_t process_id, const WTF::Vector<::scoped_refptr<const ::blink::SecurityOrigin>>& origins) final;
  
  void SetMaxConnectionsPerProxy(int32_t max_connections) final;
  
  void GetNetworkChangeManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkChangeManager> network_change_manager) final;
  
  void GetNetworkQualityEstimatorManager(::mojo::PendingReceiver<::network::mojom::blink::NetworkQualityEstimatorManager> receiver) final;
  
  void GetDnsConfigChangeManager(::mojo::PendingReceiver<::network::mojom::blink::DnsConfigChangeManager> receiver) final;
  
  void GetNetworkList(uint32_t policy, GetNetworkListCallback callback) final;
  
  void UpdateCRLSet(::base::span<const ::uint8_t> crl_set, UpdateCRLSetCallback callback) final;
  
  void OnCertDBChanged() final;
  
  void SetEncryptionKey(const std::string& encryption_key) final;
  
  void OnMemoryPressure(::mojo_base::mojom::blink::MemoryPressureLevel memory_pressure_level) final;
  
  void OnPeerToPeerConnectionsCountChange(uint32_t count) final;
  
  void OnApplicationStateChange(::mojo_base::mojom::blink::ApplicationState state) final;
  
  void SetEnvironment(WTF::Vector<EnvironmentVariablePtr> environment) final;
  
  void SetTrustTokenKeyCommitments(const WTF::String& raw_commitments, SetTrustTokenKeyCommitmentsCallback callback) final;
  
  void ClearSCTAuditingCache() final;
  
  void ConfigureSCTAuditing(SCTAuditingConfigurationPtr configuration) final;
  
  void UpdateCtLogList(WTF::Vector<::network::mojom::blink::CTLogInfoPtr> log_list, ::base::Time update_time, UpdateCtLogListCallback callback) final;
  
  void UpdateCtKnownPopularSCTs(const WTF::Vector<WTF::Vector<uint8_t>>& sct_hashes, UpdateCtKnownPopularSCTsCallback callback) final;
  
  void SetCtEnforcementEnabled(bool enabled, SetCtEnforcementEnabledCallback callback) final;
  
  void UpdateKeyPinsList(::network::mojom::blink::PinListPtr pin_list, ::base::Time update_time) final;
  
  void DumpWithoutCrashing(::base::Time dump_request_time) final;
  
  void BindTestInterface(::mojo::PendingReceiver<::network::mojom::blink::NetworkServiceTest> receiver) final;
  
  void SetFirstPartySets(WTF::HashMap<::blink::BlinkSchemefulSite, ::network::mojom::blink::FirstPartySetEntryPtr> sets) final;
  
  void SetExplicitlyAllowedPorts(const WTF::Vector<uint16_t>& ports) final;
  
  void ParseHeaders(const ::blink::KURL& url, ::network::mojom::blink::HttpResponseHeadersPtr headers, ParseHeadersCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class BLINK_PLATFORM_EXPORT NetworkServiceStubDispatch {
 public:
  static bool Accept(NetworkService* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      NetworkService* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<NetworkService>>
class NetworkServiceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  NetworkServiceStub() = default;
  ~NetworkServiceStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkServiceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return NetworkServiceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_PLATFORM_EXPORT NetworkServiceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class BLINK_PLATFORM_EXPORT NetworkServiceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





class BLINK_PLATFORM_EXPORT HttpAuthStaticParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<HttpAuthStaticParams, T>::value>;
  using DataView = HttpAuthStaticParamsDataView;
  using Data_ = internal::HttpAuthStaticParams_Data;

  template <typename... Args>
  static HttpAuthStaticParamsPtr New(Args&&... args) {
    return HttpAuthStaticParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static HttpAuthStaticParamsPtr From(const U& u) {
    return mojo::TypeConverter<HttpAuthStaticParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HttpAuthStaticParams>::Convert(*this);
  }


  HttpAuthStaticParams();

  explicit HttpAuthStaticParams(
      const WTF::String& gssapi_library_name);


  ~HttpAuthStaticParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = HttpAuthStaticParamsPtr>
  HttpAuthStaticParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        HttpAuthStaticParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HttpAuthStaticParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::HttpAuthStaticParams_UnserializedMessageContext<
            UserType, HttpAuthStaticParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<HttpAuthStaticParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return HttpAuthStaticParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::HttpAuthStaticParams_UnserializedMessageContext<
            UserType, HttpAuthStaticParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<HttpAuthStaticParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String gssapi_library_name;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class BLINK_PLATFORM_EXPORT EnvironmentVariable {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EnvironmentVariable, T>::value>;
  using DataView = EnvironmentVariableDataView;
  using Data_ = internal::EnvironmentVariable_Data;

  template <typename... Args>
  static EnvironmentVariablePtr New(Args&&... args) {
    return EnvironmentVariablePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EnvironmentVariablePtr From(const U& u) {
    return mojo::TypeConverter<EnvironmentVariablePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EnvironmentVariable>::Convert(*this);
  }


  EnvironmentVariable();

  EnvironmentVariable(
      const WTF::String& name,
      const WTF::String& value);


  ~EnvironmentVariable();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EnvironmentVariablePtr>
  EnvironmentVariablePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EnvironmentVariable::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EnvironmentVariable::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EnvironmentVariable_UnserializedMessageContext<
            UserType, EnvironmentVariable::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EnvironmentVariable::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return EnvironmentVariable::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EnvironmentVariable_UnserializedMessageContext<
            UserType, EnvironmentVariable::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EnvironmentVariable::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String name;
  
  WTF::String value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EnvironmentVariable::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










class BLINK_PLATFORM_EXPORT HttpAuthDynamicParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<HttpAuthDynamicParams, T>::value>;
  using DataView = HttpAuthDynamicParamsDataView;
  using Data_ = internal::HttpAuthDynamicParams_Data;

  template <typename... Args>
  static HttpAuthDynamicParamsPtr New(Args&&... args) {
    return HttpAuthDynamicParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static HttpAuthDynamicParamsPtr From(const U& u) {
    return mojo::TypeConverter<HttpAuthDynamicParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, HttpAuthDynamicParams>::Convert(*this);
  }


  HttpAuthDynamicParams();

  HttpAuthDynamicParams(
      absl::optional<WTF::Vector<WTF::String>> allowed_schemes,
      WTF::Vector<WTF::String> patterns_allowed_to_use_all_schemes,
      const WTF::String& server_allowlist,
      const WTF::String& delegate_allowlist,
      bool delegate_by_kdc_policy,
      bool negotiate_disable_cname_lookup,
      bool enable_negotiate_port,
      bool ntlm_v2_enabled,
      const WTF::String& android_negotiate_account_type,
      bool allow_gssapi_library_load,
      bool basic_over_http_enabled);


  ~HttpAuthDynamicParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = HttpAuthDynamicParamsPtr>
  HttpAuthDynamicParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        HttpAuthDynamicParams::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        HttpAuthDynamicParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::HttpAuthDynamicParams_UnserializedMessageContext<
            UserType, HttpAuthDynamicParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<HttpAuthDynamicParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return HttpAuthDynamicParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::HttpAuthDynamicParams_UnserializedMessageContext<
            UserType, HttpAuthDynamicParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<HttpAuthDynamicParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  absl::optional<WTF::Vector<WTF::String>> allowed_schemes;
  
  WTF::Vector<WTF::String> patterns_allowed_to_use_all_schemes;
  
  WTF::String server_allowlist;
  
  WTF::String delegate_allowlist;
  
  bool delegate_by_kdc_policy;
  
  bool negotiate_disable_cname_lookup;
  
  bool enable_negotiate_port;
  
  bool ntlm_v2_enabled;
  
  WTF::String android_negotiate_account_type;
  
  bool allow_gssapi_library_load;
  
  bool basic_over_http_enabled;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class BLINK_PLATFORM_EXPORT NetworkServiceParams {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<NetworkServiceParams, T>::value>;
  using DataView = NetworkServiceParamsDataView;
  using Data_ = internal::NetworkServiceParams_Data;

  template <typename... Args>
  static NetworkServiceParamsPtr New(Args&&... args) {
    return NetworkServiceParamsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static NetworkServiceParamsPtr From(const U& u) {
    return mojo::TypeConverter<NetworkServiceParamsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, NetworkServiceParams>::Convert(*this);
  }


  NetworkServiceParams();

  NetworkServiceParams(
      ::network::mojom::blink::ConnectionType initial_connection_type,
      ::network::mojom::blink::ConnectionSubtype initial_connection_subtype,
      WTF::Vector<EnvironmentVariablePtr> environment,
      ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> default_observer,
      bool first_party_sets_enabled);

NetworkServiceParams(const NetworkServiceParams&) = delete;
NetworkServiceParams& operator=(const NetworkServiceParams&) = delete;

  ~NetworkServiceParams();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = NetworkServiceParamsPtr>
  NetworkServiceParamsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        NetworkServiceParams::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::NetworkServiceParams_UnserializedMessageContext<
            UserType, NetworkServiceParams::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<NetworkServiceParams::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return NetworkServiceParams::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::NetworkServiceParams_UnserializedMessageContext<
            UserType, NetworkServiceParams::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<NetworkServiceParams::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::network::mojom::blink::ConnectionType initial_connection_type;
  
  ::network::mojom::blink::ConnectionSubtype initial_connection_subtype;
  
  WTF::Vector<EnvironmentVariablePtr> environment;
  
  ::mojo::PendingRemote<::network::mojom::blink::URLLoaderNetworkServiceObserver> default_observer;
  
  bool first_party_sets_enabled;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, NetworkServiceParams::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_PLATFORM_EXPORT SCTAuditingConfiguration {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SCTAuditingConfiguration, T>::value>;
  using DataView = SCTAuditingConfigurationDataView;
  using Data_ = internal::SCTAuditingConfiguration_Data;

  template <typename... Args>
  static SCTAuditingConfigurationPtr New(Args&&... args) {
    return SCTAuditingConfigurationPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SCTAuditingConfigurationPtr From(const U& u) {
    return mojo::TypeConverter<SCTAuditingConfigurationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SCTAuditingConfiguration>::Convert(*this);
  }


  SCTAuditingConfiguration();

  SCTAuditingConfiguration(
      double sampling_rate,
      ::base::TimeDelta log_expected_ingestion_delay,
      ::base::TimeDelta log_max_ingestion_random_delay,
      const ::blink::KURL& report_uri,
      const ::blink::KURL& hashdance_lookup_uri,
      const ::net::MutableNetworkTrafficAnnotationTag& traffic_annotation,
      const ::net::MutableNetworkTrafficAnnotationTag& hashdance_traffic_annotation);


  ~SCTAuditingConfiguration();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SCTAuditingConfigurationPtr>
  SCTAuditingConfigurationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SCTAuditingConfiguration::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SCTAuditingConfiguration::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SCTAuditingConfiguration_UnserializedMessageContext<
            UserType, SCTAuditingConfiguration::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SCTAuditingConfiguration::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return SCTAuditingConfiguration::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SCTAuditingConfiguration_UnserializedMessageContext<
            UserType, SCTAuditingConfiguration::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SCTAuditingConfiguration::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  double sampling_rate;
  
  ::base::TimeDelta log_expected_ingestion_delay;
  
  ::base::TimeDelta log_max_ingestion_random_delay;
  
  ::blink::KURL report_uri;
  
  ::blink::KURL hashdance_lookup_uri;
  
  ::net::MutableNetworkTrafficAnnotationTag traffic_annotation;
  
  ::net::MutableNetworkTrafficAnnotationTag hashdance_traffic_annotation;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
HttpAuthStaticParamsPtr HttpAuthStaticParams::Clone() const {
  return New(
      mojo::Clone(gssapi_library_name)
  );
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>*>
bool HttpAuthStaticParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->gssapi_library_name, other_struct.gssapi_library_name))
    return false;
  return true;
}

template <typename T, HttpAuthStaticParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.gssapi_library_name < rhs.gssapi_library_name)
    return true;
  if (rhs.gssapi_library_name < lhs.gssapi_library_name)
    return false;
  return false;
}
template <typename StructPtrType>
HttpAuthDynamicParamsPtr HttpAuthDynamicParams::Clone() const {
  return New(
      mojo::Clone(allowed_schemes),
      mojo::Clone(patterns_allowed_to_use_all_schemes),
      mojo::Clone(server_allowlist),
      mojo::Clone(delegate_allowlist),
      mojo::Clone(delegate_by_kdc_policy),
      mojo::Clone(negotiate_disable_cname_lookup),
      mojo::Clone(enable_negotiate_port),
      mojo::Clone(ntlm_v2_enabled),
      mojo::Clone(android_negotiate_account_type),
      mojo::Clone(allow_gssapi_library_load),
      mojo::Clone(basic_over_http_enabled)
  );
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>*>
bool HttpAuthDynamicParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->allowed_schemes, other_struct.allowed_schemes))
    return false;
  if (!mojo::Equals(this->patterns_allowed_to_use_all_schemes, other_struct.patterns_allowed_to_use_all_schemes))
    return false;
  if (!mojo::Equals(this->server_allowlist, other_struct.server_allowlist))
    return false;
  if (!mojo::Equals(this->delegate_allowlist, other_struct.delegate_allowlist))
    return false;
  if (!mojo::Equals(this->delegate_by_kdc_policy, other_struct.delegate_by_kdc_policy))
    return false;
  if (!mojo::Equals(this->negotiate_disable_cname_lookup, other_struct.negotiate_disable_cname_lookup))
    return false;
  if (!mojo::Equals(this->enable_negotiate_port, other_struct.enable_negotiate_port))
    return false;
  if (!mojo::Equals(this->ntlm_v2_enabled, other_struct.ntlm_v2_enabled))
    return false;
  if (!mojo::Equals(this->android_negotiate_account_type, other_struct.android_negotiate_account_type))
    return false;
  if (!mojo::Equals(this->allow_gssapi_library_load, other_struct.allow_gssapi_library_load))
    return false;
  if (!mojo::Equals(this->basic_over_http_enabled, other_struct.basic_over_http_enabled))
    return false;
  return true;
}

template <typename T, HttpAuthDynamicParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.allowed_schemes < rhs.allowed_schemes)
    return true;
  if (rhs.allowed_schemes < lhs.allowed_schemes)
    return false;
  if (lhs.patterns_allowed_to_use_all_schemes < rhs.patterns_allowed_to_use_all_schemes)
    return true;
  if (rhs.patterns_allowed_to_use_all_schemes < lhs.patterns_allowed_to_use_all_schemes)
    return false;
  if (lhs.server_allowlist < rhs.server_allowlist)
    return true;
  if (rhs.server_allowlist < lhs.server_allowlist)
    return false;
  if (lhs.delegate_allowlist < rhs.delegate_allowlist)
    return true;
  if (rhs.delegate_allowlist < lhs.delegate_allowlist)
    return false;
  if (lhs.delegate_by_kdc_policy < rhs.delegate_by_kdc_policy)
    return true;
  if (rhs.delegate_by_kdc_policy < lhs.delegate_by_kdc_policy)
    return false;
  if (lhs.negotiate_disable_cname_lookup < rhs.negotiate_disable_cname_lookup)
    return true;
  if (rhs.negotiate_disable_cname_lookup < lhs.negotiate_disable_cname_lookup)
    return false;
  if (lhs.enable_negotiate_port < rhs.enable_negotiate_port)
    return true;
  if (rhs.enable_negotiate_port < lhs.enable_negotiate_port)
    return false;
  if (lhs.ntlm_v2_enabled < rhs.ntlm_v2_enabled)
    return true;
  if (rhs.ntlm_v2_enabled < lhs.ntlm_v2_enabled)
    return false;
  if (lhs.android_negotiate_account_type < rhs.android_negotiate_account_type)
    return true;
  if (rhs.android_negotiate_account_type < lhs.android_negotiate_account_type)
    return false;
  if (lhs.allow_gssapi_library_load < rhs.allow_gssapi_library_load)
    return true;
  if (rhs.allow_gssapi_library_load < lhs.allow_gssapi_library_load)
    return false;
  if (lhs.basic_over_http_enabled < rhs.basic_over_http_enabled)
    return true;
  if (rhs.basic_over_http_enabled < lhs.basic_over_http_enabled)
    return false;
  return false;
}
template <typename StructPtrType>
EnvironmentVariablePtr EnvironmentVariable::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(value)
  );
}

template <typename T, EnvironmentVariable::EnableIfSame<T>*>
bool EnvironmentVariable::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, EnvironmentVariable::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
NetworkServiceParamsPtr NetworkServiceParams::Clone() const {
  return New(
      mojo::Clone(initial_connection_type),
      mojo::Clone(initial_connection_subtype),
      mojo::Clone(environment),
      mojo::Clone(default_observer),
      mojo::Clone(first_party_sets_enabled)
  );
}

template <typename T, NetworkServiceParams::EnableIfSame<T>*>
bool NetworkServiceParams::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->initial_connection_type, other_struct.initial_connection_type))
    return false;
  if (!mojo::Equals(this->initial_connection_subtype, other_struct.initial_connection_subtype))
    return false;
  if (!mojo::Equals(this->environment, other_struct.environment))
    return false;
  if (!mojo::Equals(this->default_observer, other_struct.default_observer))
    return false;
  if (!mojo::Equals(this->first_party_sets_enabled, other_struct.first_party_sets_enabled))
    return false;
  return true;
}

template <typename T, NetworkServiceParams::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.initial_connection_type < rhs.initial_connection_type)
    return true;
  if (rhs.initial_connection_type < lhs.initial_connection_type)
    return false;
  if (lhs.initial_connection_subtype < rhs.initial_connection_subtype)
    return true;
  if (rhs.initial_connection_subtype < lhs.initial_connection_subtype)
    return false;
  if (lhs.environment < rhs.environment)
    return true;
  if (rhs.environment < lhs.environment)
    return false;
  if (lhs.default_observer < rhs.default_observer)
    return true;
  if (rhs.default_observer < lhs.default_observer)
    return false;
  if (lhs.first_party_sets_enabled < rhs.first_party_sets_enabled)
    return true;
  if (rhs.first_party_sets_enabled < lhs.first_party_sets_enabled)
    return false;
  return false;
}
template <typename StructPtrType>
SCTAuditingConfigurationPtr SCTAuditingConfiguration::Clone() const {
  return New(
      mojo::Clone(sampling_rate),
      mojo::Clone(log_expected_ingestion_delay),
      mojo::Clone(log_max_ingestion_random_delay),
      mojo::Clone(report_uri),
      mojo::Clone(hashdance_lookup_uri),
      mojo::Clone(traffic_annotation),
      mojo::Clone(hashdance_traffic_annotation)
  );
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>*>
bool SCTAuditingConfiguration::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sampling_rate, other_struct.sampling_rate))
    return false;
  if (!mojo::Equals(this->log_expected_ingestion_delay, other_struct.log_expected_ingestion_delay))
    return false;
  if (!mojo::Equals(this->log_max_ingestion_random_delay, other_struct.log_max_ingestion_random_delay))
    return false;
  if (!mojo::Equals(this->report_uri, other_struct.report_uri))
    return false;
  if (!mojo::Equals(this->hashdance_lookup_uri, other_struct.hashdance_lookup_uri))
    return false;
  if (!mojo::Equals(this->traffic_annotation, other_struct.traffic_annotation))
    return false;
  if (!mojo::Equals(this->hashdance_traffic_annotation, other_struct.hashdance_traffic_annotation))
    return false;
  return true;
}

template <typename T, SCTAuditingConfiguration::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sampling_rate < rhs.sampling_rate)
    return true;
  if (rhs.sampling_rate < lhs.sampling_rate)
    return false;
  if (lhs.log_expected_ingestion_delay < rhs.log_expected_ingestion_delay)
    return true;
  if (rhs.log_expected_ingestion_delay < lhs.log_expected_ingestion_delay)
    return false;
  if (lhs.log_max_ingestion_random_delay < rhs.log_max_ingestion_random_delay)
    return true;
  if (rhs.log_max_ingestion_random_delay < lhs.log_max_ingestion_random_delay)
    return false;
  if (lhs.report_uri < rhs.report_uri)
    return true;
  if (rhs.report_uri < lhs.report_uri)
    return false;
  if (lhs.hashdance_lookup_uri < rhs.hashdance_lookup_uri)
    return true;
  if (rhs.hashdance_lookup_uri < lhs.hashdance_lookup_uri)
    return false;
  if (lhs.traffic_annotation < rhs.traffic_annotation)
    return true;
  if (rhs.traffic_annotation < lhs.traffic_annotation)
    return false;
  if (lhs.hashdance_traffic_annotation < rhs.hashdance_traffic_annotation)
    return true;
  if (rhs.hashdance_traffic_annotation < lhs.hashdance_traffic_annotation)
    return false;
  return false;
}


}  // namespace blink
}  // namespace mojom
}  // namespace network

namespace mojo {


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::HttpAuthStaticParams::DataView,
                                         ::network::mojom::blink::HttpAuthStaticParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::HttpAuthStaticParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::HttpAuthStaticParamsPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::HttpAuthStaticParams::gssapi_library_name)& gssapi_library_name(
      const ::network::mojom::blink::HttpAuthStaticParamsPtr& input) {
    return input->gssapi_library_name;
  }

  static bool Read(::network::mojom::blink::HttpAuthStaticParams::DataView input, ::network::mojom::blink::HttpAuthStaticParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::HttpAuthDynamicParams::DataView,
                                         ::network::mojom::blink::HttpAuthDynamicParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::HttpAuthDynamicParamsPtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::HttpAuthDynamicParams::allowed_schemes)& allowed_schemes(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->allowed_schemes;
  }

  static const decltype(::network::mojom::blink::HttpAuthDynamicParams::patterns_allowed_to_use_all_schemes)& patterns_allowed_to_use_all_schemes(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->patterns_allowed_to_use_all_schemes;
  }

  static const decltype(::network::mojom::blink::HttpAuthDynamicParams::server_allowlist)& server_allowlist(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->server_allowlist;
  }

  static const decltype(::network::mojom::blink::HttpAuthDynamicParams::delegate_allowlist)& delegate_allowlist(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->delegate_allowlist;
  }

  static decltype(::network::mojom::blink::HttpAuthDynamicParams::delegate_by_kdc_policy) delegate_by_kdc_policy(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->delegate_by_kdc_policy;
  }

  static decltype(::network::mojom::blink::HttpAuthDynamicParams::negotiate_disable_cname_lookup) negotiate_disable_cname_lookup(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->negotiate_disable_cname_lookup;
  }

  static decltype(::network::mojom::blink::HttpAuthDynamicParams::enable_negotiate_port) enable_negotiate_port(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->enable_negotiate_port;
  }

  static decltype(::network::mojom::blink::HttpAuthDynamicParams::ntlm_v2_enabled) ntlm_v2_enabled(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->ntlm_v2_enabled;
  }

  static const decltype(::network::mojom::blink::HttpAuthDynamicParams::android_negotiate_account_type)& android_negotiate_account_type(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->android_negotiate_account_type;
  }

  static decltype(::network::mojom::blink::HttpAuthDynamicParams::allow_gssapi_library_load) allow_gssapi_library_load(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->allow_gssapi_library_load;
  }

  static decltype(::network::mojom::blink::HttpAuthDynamicParams::basic_over_http_enabled) basic_over_http_enabled(
      const ::network::mojom::blink::HttpAuthDynamicParamsPtr& input) {
    return input->basic_over_http_enabled;
  }

  static bool Read(::network::mojom::blink::HttpAuthDynamicParams::DataView input, ::network::mojom::blink::HttpAuthDynamicParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::EnvironmentVariable::DataView,
                                         ::network::mojom::blink::EnvironmentVariablePtr> {
  static bool IsNull(const ::network::mojom::blink::EnvironmentVariablePtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::EnvironmentVariablePtr* output) { output->reset(); }

  static const decltype(::network::mojom::blink::EnvironmentVariable::name)& name(
      const ::network::mojom::blink::EnvironmentVariablePtr& input) {
    return input->name;
  }

  static const decltype(::network::mojom::blink::EnvironmentVariable::value)& value(
      const ::network::mojom::blink::EnvironmentVariablePtr& input) {
    return input->value;
  }

  static bool Read(::network::mojom::blink::EnvironmentVariable::DataView input, ::network::mojom::blink::EnvironmentVariablePtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::NetworkServiceParams::DataView,
                                         ::network::mojom::blink::NetworkServiceParamsPtr> {
  static bool IsNull(const ::network::mojom::blink::NetworkServiceParamsPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::NetworkServiceParamsPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::NetworkServiceParams::initial_connection_type) initial_connection_type(
      const ::network::mojom::blink::NetworkServiceParamsPtr& input) {
    return input->initial_connection_type;
  }

  static decltype(::network::mojom::blink::NetworkServiceParams::initial_connection_subtype) initial_connection_subtype(
      const ::network::mojom::blink::NetworkServiceParamsPtr& input) {
    return input->initial_connection_subtype;
  }

  static const decltype(::network::mojom::blink::NetworkServiceParams::environment)& environment(
      const ::network::mojom::blink::NetworkServiceParamsPtr& input) {
    return input->environment;
  }

  static  decltype(::network::mojom::blink::NetworkServiceParams::default_observer)& default_observer(
       ::network::mojom::blink::NetworkServiceParamsPtr& input) {
    return input->default_observer;
  }

  static decltype(::network::mojom::blink::NetworkServiceParams::first_party_sets_enabled) first_party_sets_enabled(
      const ::network::mojom::blink::NetworkServiceParamsPtr& input) {
    return input->first_party_sets_enabled;
  }

  static bool Read(::network::mojom::blink::NetworkServiceParams::DataView input, ::network::mojom::blink::NetworkServiceParamsPtr* output);
};


template <>
struct BLINK_PLATFORM_EXPORT StructTraits<::network::mojom::blink::SCTAuditingConfiguration::DataView,
                                         ::network::mojom::blink::SCTAuditingConfigurationPtr> {
  static bool IsNull(const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) { return !input; }
  static void SetToNull(::network::mojom::blink::SCTAuditingConfigurationPtr* output) { output->reset(); }

  static decltype(::network::mojom::blink::SCTAuditingConfiguration::sampling_rate) sampling_rate(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->sampling_rate;
  }

  static const decltype(::network::mojom::blink::SCTAuditingConfiguration::log_expected_ingestion_delay)& log_expected_ingestion_delay(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->log_expected_ingestion_delay;
  }

  static const decltype(::network::mojom::blink::SCTAuditingConfiguration::log_max_ingestion_random_delay)& log_max_ingestion_random_delay(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->log_max_ingestion_random_delay;
  }

  static const decltype(::network::mojom::blink::SCTAuditingConfiguration::report_uri)& report_uri(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->report_uri;
  }

  static const decltype(::network::mojom::blink::SCTAuditingConfiguration::hashdance_lookup_uri)& hashdance_lookup_uri(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->hashdance_lookup_uri;
  }

  static const decltype(::network::mojom::blink::SCTAuditingConfiguration::traffic_annotation)& traffic_annotation(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->traffic_annotation;
  }

  static const decltype(::network::mojom::blink::SCTAuditingConfiguration::hashdance_traffic_annotation)& hashdance_traffic_annotation(
      const ::network::mojom::blink::SCTAuditingConfigurationPtr& input) {
    return input->hashdance_traffic_annotation;
  }

  static bool Read(::network::mojom::blink::SCTAuditingConfiguration::DataView input, ::network::mojom::blink::SCTAuditingConfigurationPtr* output);
};

}  // namespace mojo

#endif  // SERVICES_NETWORK_PUBLIC_MOJOM_NETWORK_SERVICE_MOJOM_BLINK_H_