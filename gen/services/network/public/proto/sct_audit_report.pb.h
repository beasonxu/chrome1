// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sct_audit_report.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sct_5faudit_5freport_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sct_5faudit_5freport_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sct_5faudit_5freport_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sct_5faudit_5freport_2eproto {
  static const uint32_t offsets[];
};
namespace sct_auditing {
class SCTClientReport;
struct SCTClientReportDefaultTypeInternal;
extern SCTClientReportDefaultTypeInternal _SCTClientReport_default_instance_;
class SCTWithVerifyStatus;
struct SCTWithVerifyStatusDefaultTypeInternal;
extern SCTWithVerifyStatusDefaultTypeInternal _SCTWithVerifyStatus_default_instance_;
class TLSConnectionContext;
struct TLSConnectionContextDefaultTypeInternal;
extern TLSConnectionContextDefaultTypeInternal _TLSConnectionContext_default_instance_;
class TLSConnectionContext_Origin;
struct TLSConnectionContext_OriginDefaultTypeInternal;
extern TLSConnectionContext_OriginDefaultTypeInternal _TLSConnectionContext_Origin_default_instance_;
class TLSConnectionReport;
struct TLSConnectionReportDefaultTypeInternal;
extern TLSConnectionReportDefaultTypeInternal _TLSConnectionReport_default_instance_;
}  // namespace sct_auditing
PROTOBUF_NAMESPACE_OPEN
template<> ::sct_auditing::SCTClientReport* Arena::CreateMaybeMessage<::sct_auditing::SCTClientReport>(Arena*);
template<> ::sct_auditing::SCTWithVerifyStatus* Arena::CreateMaybeMessage<::sct_auditing::SCTWithVerifyStatus>(Arena*);
template<> ::sct_auditing::TLSConnectionContext* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionContext>(Arena*);
template<> ::sct_auditing::TLSConnectionContext_Origin* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionContext_Origin>(Arena*);
template<> ::sct_auditing::TLSConnectionReport* Arena::CreateMaybeMessage<::sct_auditing::TLSConnectionReport>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sct_auditing {

enum SCTWithVerifyStatus_SctVerifyStatus : int {
  SCTWithVerifyStatus_SctVerifyStatus_NONE = 0,
  SCTWithVerifyStatus_SctVerifyStatus_LOG_UNKNOWN = 1,
  SCTWithVerifyStatus_SctVerifyStatus_OK = 3,
  SCTWithVerifyStatus_SctVerifyStatus_INVALID_SIGNATURE = 4,
  SCTWithVerifyStatus_SctVerifyStatus_INVALID_TIMESTAMP = 5,
  SCTWithVerifyStatus_SctVerifyStatus_SCTWithVerifyStatus_SctVerifyStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SCTWithVerifyStatus_SctVerifyStatus_SCTWithVerifyStatus_SctVerifyStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SCTWithVerifyStatus_SctVerifyStatus_IsValid(int value);
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MIN = SCTWithVerifyStatus_SctVerifyStatus_NONE;
constexpr SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MAX = SCTWithVerifyStatus_SctVerifyStatus_INVALID_TIMESTAMP;
constexpr int SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_ARRAYSIZE = SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MAX + 1;

const std::string& SCTWithVerifyStatus_SctVerifyStatus_Name(SCTWithVerifyStatus_SctVerifyStatus value);
template<typename T>
inline const std::string& SCTWithVerifyStatus_SctVerifyStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SCTWithVerifyStatus_SctVerifyStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SCTWithVerifyStatus_SctVerifyStatus_Name.");
  return SCTWithVerifyStatus_SctVerifyStatus_Name(static_cast<SCTWithVerifyStatus_SctVerifyStatus>(enum_t_value));
}
bool SCTWithVerifyStatus_SctVerifyStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SCTWithVerifyStatus_SctVerifyStatus* value);
// ===================================================================

class SCTClientReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.SCTClientReport) */ {
 public:
  inline SCTClientReport() : SCTClientReport(nullptr) {}
  ~SCTClientReport() override;
  explicit PROTOBUF_CONSTEXPR SCTClientReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCTClientReport(const SCTClientReport& from);
  SCTClientReport(SCTClientReport&& from) noexcept
    : SCTClientReport() {
    *this = ::std::move(from);
  }

  inline SCTClientReport& operator=(const SCTClientReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCTClientReport& operator=(SCTClientReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SCTClientReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCTClientReport* internal_default_instance() {
    return reinterpret_cast<const SCTClientReport*>(
               &_SCTClientReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SCTClientReport& a, SCTClientReport& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SCTClientReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCTClientReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCTClientReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCTClientReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SCTClientReport& from);
  void MergeFrom(const SCTClientReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SCTClientReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sct_auditing.SCTClientReport";
  }
  protected:
  explicit SCTClientReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateReportFieldNumber = 2,
    kUserAgentFieldNumber = 1,
  };
  // repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
  int certificate_report_size() const;
  private:
  int _internal_certificate_report_size() const;
  public:
  void clear_certificate_report();
  ::sct_auditing::TLSConnectionReport* mutable_certificate_report(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::TLSConnectionReport >*
      mutable_certificate_report();
  private:
  const ::sct_auditing::TLSConnectionReport& _internal_certificate_report(int index) const;
  ::sct_auditing::TLSConnectionReport* _internal_add_certificate_report();
  public:
  const ::sct_auditing::TLSConnectionReport& certificate_report(int index) const;
  ::sct_auditing::TLSConnectionReport* add_certificate_report();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::TLSConnectionReport >&
      certificate_report() const;

  // string user_agent = 1;
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // @@protoc_insertion_point(class_scope:sct_auditing.SCTClientReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::TLSConnectionReport > certificate_report_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class TLSConnectionReport final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.TLSConnectionReport) */ {
 public:
  inline TLSConnectionReport() : TLSConnectionReport(nullptr) {}
  ~TLSConnectionReport() override;
  explicit PROTOBUF_CONSTEXPR TLSConnectionReport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TLSConnectionReport(const TLSConnectionReport& from);
  TLSConnectionReport(TLSConnectionReport&& from) noexcept
    : TLSConnectionReport() {
    *this = ::std::move(from);
  }

  inline TLSConnectionReport& operator=(const TLSConnectionReport& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLSConnectionReport& operator=(TLSConnectionReport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TLSConnectionReport& default_instance() {
    return *internal_default_instance();
  }
  static inline const TLSConnectionReport* internal_default_instance() {
    return reinterpret_cast<const TLSConnectionReport*>(
               &_TLSConnectionReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TLSConnectionReport& a, TLSConnectionReport& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TLSConnectionReport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TLSConnectionReport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TLSConnectionReport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TLSConnectionReport>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TLSConnectionReport& from);
  void MergeFrom(const TLSConnectionReport& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLSConnectionReport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sct_auditing.TLSConnectionReport";
  }
  protected:
  explicit TLSConnectionReport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludedSctFieldNumber = 2,
    kContextFieldNumber = 1,
  };
  // repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
  int included_sct_size() const;
  private:
  int _internal_included_sct_size() const;
  public:
  void clear_included_sct();
  ::sct_auditing::SCTWithVerifyStatus* mutable_included_sct(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::SCTWithVerifyStatus >*
      mutable_included_sct();
  private:
  const ::sct_auditing::SCTWithVerifyStatus& _internal_included_sct(int index) const;
  ::sct_auditing::SCTWithVerifyStatus* _internal_add_included_sct();
  public:
  const ::sct_auditing::SCTWithVerifyStatus& included_sct(int index) const;
  ::sct_auditing::SCTWithVerifyStatus* add_included_sct();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::SCTWithVerifyStatus >&
      included_sct() const;

  // .sct_auditing.TLSConnectionContext context = 1;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::sct_auditing::TLSConnectionContext& context() const;
  PROTOBUF_NODISCARD ::sct_auditing::TLSConnectionContext* release_context();
  ::sct_auditing::TLSConnectionContext* mutable_context();
  void set_allocated_context(::sct_auditing::TLSConnectionContext* context);
  private:
  const ::sct_auditing::TLSConnectionContext& _internal_context() const;
  ::sct_auditing::TLSConnectionContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::sct_auditing::TLSConnectionContext* context);
  ::sct_auditing::TLSConnectionContext* unsafe_arena_release_context();

  // @@protoc_insertion_point(class_scope:sct_auditing.TLSConnectionReport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::SCTWithVerifyStatus > included_sct_;
  ::sct_auditing::TLSConnectionContext* context_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class TLSConnectionContext_Origin final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.TLSConnectionContext.Origin) */ {
 public:
  inline TLSConnectionContext_Origin() : TLSConnectionContext_Origin(nullptr) {}
  ~TLSConnectionContext_Origin() override;
  explicit PROTOBUF_CONSTEXPR TLSConnectionContext_Origin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TLSConnectionContext_Origin(const TLSConnectionContext_Origin& from);
  TLSConnectionContext_Origin(TLSConnectionContext_Origin&& from) noexcept
    : TLSConnectionContext_Origin() {
    *this = ::std::move(from);
  }

  inline TLSConnectionContext_Origin& operator=(const TLSConnectionContext_Origin& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLSConnectionContext_Origin& operator=(TLSConnectionContext_Origin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TLSConnectionContext_Origin& default_instance() {
    return *internal_default_instance();
  }
  static inline const TLSConnectionContext_Origin* internal_default_instance() {
    return reinterpret_cast<const TLSConnectionContext_Origin*>(
               &_TLSConnectionContext_Origin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TLSConnectionContext_Origin& a, TLSConnectionContext_Origin& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TLSConnectionContext_Origin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TLSConnectionContext_Origin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TLSConnectionContext_Origin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TLSConnectionContext_Origin>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TLSConnectionContext_Origin& from);
  void MergeFrom(const TLSConnectionContext_Origin& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLSConnectionContext_Origin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sct_auditing.TLSConnectionContext.Origin";
  }
  protected:
  explicit TLSConnectionContext_Origin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
    kPortFieldNumber = 2,
  };
  // string hostname = 1;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sct_auditing.TLSConnectionContext.Origin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  int32_t port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class TLSConnectionContext final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.TLSConnectionContext) */ {
 public:
  inline TLSConnectionContext() : TLSConnectionContext(nullptr) {}
  ~TLSConnectionContext() override;
  explicit PROTOBUF_CONSTEXPR TLSConnectionContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TLSConnectionContext(const TLSConnectionContext& from);
  TLSConnectionContext(TLSConnectionContext&& from) noexcept
    : TLSConnectionContext() {
    *this = ::std::move(from);
  }

  inline TLSConnectionContext& operator=(const TLSConnectionContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline TLSConnectionContext& operator=(TLSConnectionContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TLSConnectionContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const TLSConnectionContext* internal_default_instance() {
    return reinterpret_cast<const TLSConnectionContext*>(
               &_TLSConnectionContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(TLSConnectionContext& a, TLSConnectionContext& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TLSConnectionContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TLSConnectionContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TLSConnectionContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TLSConnectionContext>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TLSConnectionContext& from);
  void MergeFrom(const TLSConnectionContext& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TLSConnectionContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sct_auditing.TLSConnectionContext";
  }
  protected:
  explicit TLSConnectionContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TLSConnectionContext_Origin Origin;

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateChainFieldNumber = 3,
    kOriginFieldNumber = 2,
    kTimeSeenFieldNumber = 1,
  };
  // repeated bytes certificate_chain = 3;
  int certificate_chain_size() const;
  private:
  int _internal_certificate_chain_size() const;
  public:
  void clear_certificate_chain();
  const std::string& certificate_chain(int index) const;
  std::string* mutable_certificate_chain(int index);
  void set_certificate_chain(int index, const std::string& value);
  void set_certificate_chain(int index, std::string&& value);
  void set_certificate_chain(int index, const char* value);
  void set_certificate_chain(int index, const void* value, size_t size);
  std::string* add_certificate_chain();
  void add_certificate_chain(const std::string& value);
  void add_certificate_chain(std::string&& value);
  void add_certificate_chain(const char* value);
  void add_certificate_chain(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificate_chain() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificate_chain();
  private:
  const std::string& _internal_certificate_chain(int index) const;
  std::string* _internal_add_certificate_chain();
  public:

  // .sct_auditing.TLSConnectionContext.Origin origin = 2;
  bool has_origin() const;
  private:
  bool _internal_has_origin() const;
  public:
  void clear_origin();
  const ::sct_auditing::TLSConnectionContext_Origin& origin() const;
  PROTOBUF_NODISCARD ::sct_auditing::TLSConnectionContext_Origin* release_origin();
  ::sct_auditing::TLSConnectionContext_Origin* mutable_origin();
  void set_allocated_origin(::sct_auditing::TLSConnectionContext_Origin* origin);
  private:
  const ::sct_auditing::TLSConnectionContext_Origin& _internal_origin() const;
  ::sct_auditing::TLSConnectionContext_Origin* _internal_mutable_origin();
  public:
  void unsafe_arena_set_allocated_origin(
      ::sct_auditing::TLSConnectionContext_Origin* origin);
  ::sct_auditing::TLSConnectionContext_Origin* unsafe_arena_release_origin();

  // int64 time_seen = 1;
  void clear_time_seen();
  int64_t time_seen() const;
  void set_time_seen(int64_t value);
  private:
  int64_t _internal_time_seen() const;
  void _internal_set_time_seen(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sct_auditing.TLSConnectionContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificate_chain_;
  ::sct_auditing::TLSConnectionContext_Origin* origin_;
  int64_t time_seen_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// -------------------------------------------------------------------

class SCTWithVerifyStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sct_auditing.SCTWithVerifyStatus) */ {
 public:
  inline SCTWithVerifyStatus() : SCTWithVerifyStatus(nullptr) {}
  ~SCTWithVerifyStatus() override;
  explicit PROTOBUF_CONSTEXPR SCTWithVerifyStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SCTWithVerifyStatus(const SCTWithVerifyStatus& from);
  SCTWithVerifyStatus(SCTWithVerifyStatus&& from) noexcept
    : SCTWithVerifyStatus() {
    *this = ::std::move(from);
  }

  inline SCTWithVerifyStatus& operator=(const SCTWithVerifyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SCTWithVerifyStatus& operator=(SCTWithVerifyStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SCTWithVerifyStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SCTWithVerifyStatus* internal_default_instance() {
    return reinterpret_cast<const SCTWithVerifyStatus*>(
               &_SCTWithVerifyStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SCTWithVerifyStatus& a, SCTWithVerifyStatus& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SCTWithVerifyStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SCTWithVerifyStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SCTWithVerifyStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SCTWithVerifyStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SCTWithVerifyStatus& from);
  void MergeFrom(const SCTWithVerifyStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SCTWithVerifyStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sct_auditing.SCTWithVerifyStatus";
  }
  protected:
  explicit SCTWithVerifyStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SCTWithVerifyStatus_SctVerifyStatus SctVerifyStatus;
  static constexpr SctVerifyStatus NONE =
    SCTWithVerifyStatus_SctVerifyStatus_NONE;
  static constexpr SctVerifyStatus LOG_UNKNOWN =
    SCTWithVerifyStatus_SctVerifyStatus_LOG_UNKNOWN;
  static constexpr SctVerifyStatus OK =
    SCTWithVerifyStatus_SctVerifyStatus_OK;
  static constexpr SctVerifyStatus INVALID_SIGNATURE =
    SCTWithVerifyStatus_SctVerifyStatus_INVALID_SIGNATURE;
  static constexpr SctVerifyStatus INVALID_TIMESTAMP =
    SCTWithVerifyStatus_SctVerifyStatus_INVALID_TIMESTAMP;
  static inline bool SctVerifyStatus_IsValid(int value) {
    return SCTWithVerifyStatus_SctVerifyStatus_IsValid(value);
  }
  static constexpr SctVerifyStatus SctVerifyStatus_MIN =
    SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MIN;
  static constexpr SctVerifyStatus SctVerifyStatus_MAX =
    SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_MAX;
  static constexpr int SctVerifyStatus_ARRAYSIZE =
    SCTWithVerifyStatus_SctVerifyStatus_SctVerifyStatus_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SctVerifyStatus_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SctVerifyStatus>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SctVerifyStatus_Name.");
    return SCTWithVerifyStatus_SctVerifyStatus_Name(enum_t_value);
  }
  static inline bool SctVerifyStatus_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SctVerifyStatus* value) {
    return SCTWithVerifyStatus_SctVerifyStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedSctFieldNumber = 2,
    kStatusFieldNumber = 1,
  };
  // bytes serialized_sct = 2;
  void clear_serialized_sct();
  const std::string& serialized_sct() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_sct(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_sct();
  PROTOBUF_NODISCARD std::string* release_serialized_sct();
  void set_allocated_serialized_sct(std::string* serialized_sct);
  private:
  const std::string& _internal_serialized_sct() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_sct(const std::string& value);
  std::string* _internal_mutable_serialized_sct();
  public:

  // .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
  void clear_status();
  ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus status() const;
  void set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value);
  private:
  ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus _internal_status() const;
  void _internal_set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value);
  public:

  // @@protoc_insertion_point(class_scope:sct_auditing.SCTWithVerifyStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_sct_;
  int status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sct_5faudit_5freport_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SCTClientReport

// string user_agent = 1;
inline void SCTClientReport::clear_user_agent() {
  user_agent_.ClearToEmpty();
}
inline const std::string& SCTClientReport::user_agent() const {
  // @@protoc_insertion_point(field_get:sct_auditing.SCTClientReport.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCTClientReport::set_user_agent(ArgT0&& arg0, ArgT... args) {
 
 user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sct_auditing.SCTClientReport.user_agent)
}
inline std::string* SCTClientReport::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:sct_auditing.SCTClientReport.user_agent)
  return _s;
}
inline const std::string& SCTClientReport::_internal_user_agent() const {
  return user_agent_.Get();
}
inline void SCTClientReport::_internal_set_user_agent(const std::string& value) {
  
  user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* SCTClientReport::_internal_mutable_user_agent() {
  
  return user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* SCTClientReport::release_user_agent() {
  // @@protoc_insertion_point(field_release:sct_auditing.SCTClientReport.user_agent)
  return user_agent_.Release();
}
inline void SCTClientReport::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    
  } else {
    
  }
  user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_agent_.IsDefault()) {
    user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sct_auditing.SCTClientReport.user_agent)
}

// repeated .sct_auditing.TLSConnectionReport certificate_report = 2;
inline int SCTClientReport::_internal_certificate_report_size() const {
  return certificate_report_.size();
}
inline int SCTClientReport::certificate_report_size() const {
  return _internal_certificate_report_size();
}
inline void SCTClientReport::clear_certificate_report() {
  certificate_report_.Clear();
}
inline ::sct_auditing::TLSConnectionReport* SCTClientReport::mutable_certificate_report(int index) {
  // @@protoc_insertion_point(field_mutable:sct_auditing.SCTClientReport.certificate_report)
  return certificate_report_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::TLSConnectionReport >*
SCTClientReport::mutable_certificate_report() {
  // @@protoc_insertion_point(field_mutable_list:sct_auditing.SCTClientReport.certificate_report)
  return &certificate_report_;
}
inline const ::sct_auditing::TLSConnectionReport& SCTClientReport::_internal_certificate_report(int index) const {
  return certificate_report_.Get(index);
}
inline const ::sct_auditing::TLSConnectionReport& SCTClientReport::certificate_report(int index) const {
  // @@protoc_insertion_point(field_get:sct_auditing.SCTClientReport.certificate_report)
  return _internal_certificate_report(index);
}
inline ::sct_auditing::TLSConnectionReport* SCTClientReport::_internal_add_certificate_report() {
  return certificate_report_.Add();
}
inline ::sct_auditing::TLSConnectionReport* SCTClientReport::add_certificate_report() {
  ::sct_auditing::TLSConnectionReport* _add = _internal_add_certificate_report();
  // @@protoc_insertion_point(field_add:sct_auditing.SCTClientReport.certificate_report)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::TLSConnectionReport >&
SCTClientReport::certificate_report() const {
  // @@protoc_insertion_point(field_list:sct_auditing.SCTClientReport.certificate_report)
  return certificate_report_;
}

// -------------------------------------------------------------------

// TLSConnectionReport

// .sct_auditing.TLSConnectionContext context = 1;
inline bool TLSConnectionReport::_internal_has_context() const {
  return this != internal_default_instance() && context_ != nullptr;
}
inline bool TLSConnectionReport::has_context() const {
  return _internal_has_context();
}
inline void TLSConnectionReport::clear_context() {
  if (GetArenaForAllocation() == nullptr && context_ != nullptr) {
    delete context_;
  }
  context_ = nullptr;
}
inline const ::sct_auditing::TLSConnectionContext& TLSConnectionReport::_internal_context() const {
  const ::sct_auditing::TLSConnectionContext* p = context_;
  return p != nullptr ? *p : reinterpret_cast<const ::sct_auditing::TLSConnectionContext&>(
      ::sct_auditing::_TLSConnectionContext_default_instance_);
}
inline const ::sct_auditing::TLSConnectionContext& TLSConnectionReport::context() const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionReport.context)
  return _internal_context();
}
inline void TLSConnectionReport::unsafe_arena_set_allocated_context(
    ::sct_auditing::TLSConnectionContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context_);
  }
  context_ = context;
  if (context) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sct_auditing.TLSConnectionReport.context)
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::release_context() {
  
  ::sct_auditing::TLSConnectionContext* temp = context_;
  context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:sct_auditing.TLSConnectionReport.context)
  
  ::sct_auditing::TLSConnectionContext* temp = context_;
  context_ = nullptr;
  return temp;
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::_internal_mutable_context() {
  
  if (context_ == nullptr) {
    auto* p = CreateMaybeMessage<::sct_auditing::TLSConnectionContext>(GetArenaForAllocation());
    context_ = p;
  }
  return context_;
}
inline ::sct_auditing::TLSConnectionContext* TLSConnectionReport::mutable_context() {
  ::sct_auditing::TLSConnectionContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionReport.context)
  return _msg;
}
inline void TLSConnectionReport::set_allocated_context(::sct_auditing::TLSConnectionContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    
  } else {
    
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:sct_auditing.TLSConnectionReport.context)
}

// repeated .sct_auditing.SCTWithVerifyStatus included_sct = 2;
inline int TLSConnectionReport::_internal_included_sct_size() const {
  return included_sct_.size();
}
inline int TLSConnectionReport::included_sct_size() const {
  return _internal_included_sct_size();
}
inline void TLSConnectionReport::clear_included_sct() {
  included_sct_.Clear();
}
inline ::sct_auditing::SCTWithVerifyStatus* TLSConnectionReport::mutable_included_sct(int index) {
  // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionReport.included_sct)
  return included_sct_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::SCTWithVerifyStatus >*
TLSConnectionReport::mutable_included_sct() {
  // @@protoc_insertion_point(field_mutable_list:sct_auditing.TLSConnectionReport.included_sct)
  return &included_sct_;
}
inline const ::sct_auditing::SCTWithVerifyStatus& TLSConnectionReport::_internal_included_sct(int index) const {
  return included_sct_.Get(index);
}
inline const ::sct_auditing::SCTWithVerifyStatus& TLSConnectionReport::included_sct(int index) const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionReport.included_sct)
  return _internal_included_sct(index);
}
inline ::sct_auditing::SCTWithVerifyStatus* TLSConnectionReport::_internal_add_included_sct() {
  return included_sct_.Add();
}
inline ::sct_auditing::SCTWithVerifyStatus* TLSConnectionReport::add_included_sct() {
  ::sct_auditing::SCTWithVerifyStatus* _add = _internal_add_included_sct();
  // @@protoc_insertion_point(field_add:sct_auditing.TLSConnectionReport.included_sct)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sct_auditing::SCTWithVerifyStatus >&
TLSConnectionReport::included_sct() const {
  // @@protoc_insertion_point(field_list:sct_auditing.TLSConnectionReport.included_sct)
  return included_sct_;
}

// -------------------------------------------------------------------

// TLSConnectionContext_Origin

// string hostname = 1;
inline void TLSConnectionContext_Origin::clear_hostname() {
  hostname_.ClearToEmpty();
}
inline const std::string& TLSConnectionContext_Origin::hostname() const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.Origin.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TLSConnectionContext_Origin::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.Origin.hostname)
}
inline std::string* TLSConnectionContext_Origin::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionContext.Origin.hostname)
  return _s;
}
inline const std::string& TLSConnectionContext_Origin::_internal_hostname() const {
  return hostname_.Get();
}
inline void TLSConnectionContext_Origin::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* TLSConnectionContext_Origin::_internal_mutable_hostname() {
  
  return hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* TLSConnectionContext_Origin::release_hostname() {
  // @@protoc_insertion_point(field_release:sct_auditing.TLSConnectionContext.Origin.hostname)
  return hostname_.Release();
}
inline void TLSConnectionContext_Origin::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault()) {
    hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sct_auditing.TLSConnectionContext.Origin.hostname)
}

// int32 port = 2;
inline void TLSConnectionContext_Origin::clear_port() {
  port_ = 0;
}
inline int32_t TLSConnectionContext_Origin::_internal_port() const {
  return port_;
}
inline int32_t TLSConnectionContext_Origin::port() const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.Origin.port)
  return _internal_port();
}
inline void TLSConnectionContext_Origin::_internal_set_port(int32_t value) {
  
  port_ = value;
}
inline void TLSConnectionContext_Origin::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.Origin.port)
}

// -------------------------------------------------------------------

// TLSConnectionContext

// int64 time_seen = 1;
inline void TLSConnectionContext::clear_time_seen() {
  time_seen_ = int64_t{0};
}
inline int64_t TLSConnectionContext::_internal_time_seen() const {
  return time_seen_;
}
inline int64_t TLSConnectionContext::time_seen() const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.time_seen)
  return _internal_time_seen();
}
inline void TLSConnectionContext::_internal_set_time_seen(int64_t value) {
  
  time_seen_ = value;
}
inline void TLSConnectionContext::set_time_seen(int64_t value) {
  _internal_set_time_seen(value);
  // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.time_seen)
}

// .sct_auditing.TLSConnectionContext.Origin origin = 2;
inline bool TLSConnectionContext::_internal_has_origin() const {
  return this != internal_default_instance() && origin_ != nullptr;
}
inline bool TLSConnectionContext::has_origin() const {
  return _internal_has_origin();
}
inline void TLSConnectionContext::clear_origin() {
  if (GetArenaForAllocation() == nullptr && origin_ != nullptr) {
    delete origin_;
  }
  origin_ = nullptr;
}
inline const ::sct_auditing::TLSConnectionContext_Origin& TLSConnectionContext::_internal_origin() const {
  const ::sct_auditing::TLSConnectionContext_Origin* p = origin_;
  return p != nullptr ? *p : reinterpret_cast<const ::sct_auditing::TLSConnectionContext_Origin&>(
      ::sct_auditing::_TLSConnectionContext_Origin_default_instance_);
}
inline const ::sct_auditing::TLSConnectionContext_Origin& TLSConnectionContext::origin() const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.origin)
  return _internal_origin();
}
inline void TLSConnectionContext::unsafe_arena_set_allocated_origin(
    ::sct_auditing::TLSConnectionContext_Origin* origin) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(origin_);
  }
  origin_ = origin;
  if (origin) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sct_auditing.TLSConnectionContext.origin)
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::release_origin() {
  
  ::sct_auditing::TLSConnectionContext_Origin* temp = origin_;
  origin_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::unsafe_arena_release_origin() {
  // @@protoc_insertion_point(field_release:sct_auditing.TLSConnectionContext.origin)
  
  ::sct_auditing::TLSConnectionContext_Origin* temp = origin_;
  origin_ = nullptr;
  return temp;
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::_internal_mutable_origin() {
  
  if (origin_ == nullptr) {
    auto* p = CreateMaybeMessage<::sct_auditing::TLSConnectionContext_Origin>(GetArenaForAllocation());
    origin_ = p;
  }
  return origin_;
}
inline ::sct_auditing::TLSConnectionContext_Origin* TLSConnectionContext::mutable_origin() {
  ::sct_auditing::TLSConnectionContext_Origin* _msg = _internal_mutable_origin();
  // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionContext.origin)
  return _msg;
}
inline void TLSConnectionContext::set_allocated_origin(::sct_auditing::TLSConnectionContext_Origin* origin) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete origin_;
  }
  if (origin) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(origin);
    if (message_arena != submessage_arena) {
      origin = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, origin, submessage_arena);
    }
    
  } else {
    
  }
  origin_ = origin;
  // @@protoc_insertion_point(field_set_allocated:sct_auditing.TLSConnectionContext.origin)
}

// repeated bytes certificate_chain = 3;
inline int TLSConnectionContext::_internal_certificate_chain_size() const {
  return certificate_chain_.size();
}
inline int TLSConnectionContext::certificate_chain_size() const {
  return _internal_certificate_chain_size();
}
inline void TLSConnectionContext::clear_certificate_chain() {
  certificate_chain_.Clear();
}
inline std::string* TLSConnectionContext::add_certificate_chain() {
  std::string* _s = _internal_add_certificate_chain();
  // @@protoc_insertion_point(field_add_mutable:sct_auditing.TLSConnectionContext.certificate_chain)
  return _s;
}
inline const std::string& TLSConnectionContext::_internal_certificate_chain(int index) const {
  return certificate_chain_.Get(index);
}
inline const std::string& TLSConnectionContext::certificate_chain(int index) const {
  // @@protoc_insertion_point(field_get:sct_auditing.TLSConnectionContext.certificate_chain)
  return _internal_certificate_chain(index);
}
inline std::string* TLSConnectionContext::mutable_certificate_chain(int index) {
  // @@protoc_insertion_point(field_mutable:sct_auditing.TLSConnectionContext.certificate_chain)
  return certificate_chain_.Mutable(index);
}
inline void TLSConnectionContext::set_certificate_chain(int index, const std::string& value) {
  certificate_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::set_certificate_chain(int index, std::string&& value) {
  certificate_chain_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::set_certificate_chain(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificate_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::set_certificate_chain(int index, const void* value, size_t size) {
  certificate_chain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline std::string* TLSConnectionContext::_internal_add_certificate_chain() {
  return certificate_chain_.Add();
}
inline void TLSConnectionContext::add_certificate_chain(const std::string& value) {
  certificate_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::add_certificate_chain(std::string&& value) {
  certificate_chain_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::add_certificate_chain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificate_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline void TLSConnectionContext::add_certificate_chain(const void* value, size_t size) {
  certificate_chain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sct_auditing.TLSConnectionContext.certificate_chain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TLSConnectionContext::certificate_chain() const {
  // @@protoc_insertion_point(field_list:sct_auditing.TLSConnectionContext.certificate_chain)
  return certificate_chain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TLSConnectionContext::mutable_certificate_chain() {
  // @@protoc_insertion_point(field_mutable_list:sct_auditing.TLSConnectionContext.certificate_chain)
  return &certificate_chain_;
}

// -------------------------------------------------------------------

// SCTWithVerifyStatus

// .sct_auditing.SCTWithVerifyStatus.SctVerifyStatus status = 1;
inline void SCTWithVerifyStatus::clear_status() {
  status_ = 0;
}
inline ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::_internal_status() const {
  return static_cast< ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus >(status_);
}
inline ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus SCTWithVerifyStatus::status() const {
  // @@protoc_insertion_point(field_get:sct_auditing.SCTWithVerifyStatus.status)
  return _internal_status();
}
inline void SCTWithVerifyStatus::_internal_set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value) {
  
  status_ = value;
}
inline void SCTWithVerifyStatus::set_status(::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:sct_auditing.SCTWithVerifyStatus.status)
}

// bytes serialized_sct = 2;
inline void SCTWithVerifyStatus::clear_serialized_sct() {
  serialized_sct_.ClearToEmpty();
}
inline const std::string& SCTWithVerifyStatus::serialized_sct() const {
  // @@protoc_insertion_point(field_get:sct_auditing.SCTWithVerifyStatus.serialized_sct)
  return _internal_serialized_sct();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SCTWithVerifyStatus::set_serialized_sct(ArgT0&& arg0, ArgT... args) {
 
 serialized_sct_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sct_auditing.SCTWithVerifyStatus.serialized_sct)
}
inline std::string* SCTWithVerifyStatus::mutable_serialized_sct() {
  std::string* _s = _internal_mutable_serialized_sct();
  // @@protoc_insertion_point(field_mutable:sct_auditing.SCTWithVerifyStatus.serialized_sct)
  return _s;
}
inline const std::string& SCTWithVerifyStatus::_internal_serialized_sct() const {
  return serialized_sct_.Get();
}
inline void SCTWithVerifyStatus::_internal_set_serialized_sct(const std::string& value) {
  
  serialized_sct_.Set(value, GetArenaForAllocation());
}
inline std::string* SCTWithVerifyStatus::_internal_mutable_serialized_sct() {
  
  return serialized_sct_.Mutable(GetArenaForAllocation());
}
inline std::string* SCTWithVerifyStatus::release_serialized_sct() {
  // @@protoc_insertion_point(field_release:sct_auditing.SCTWithVerifyStatus.serialized_sct)
  return serialized_sct_.Release();
}
inline void SCTWithVerifyStatus::set_allocated_serialized_sct(std::string* serialized_sct) {
  if (serialized_sct != nullptr) {
    
  } else {
    
  }
  serialized_sct_.SetAllocated(serialized_sct, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_sct_.IsDefault()) {
    serialized_sct_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sct_auditing.SCTWithVerifyStatus.serialized_sct)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sct_auditing

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sct_auditing::SCTWithVerifyStatus_SctVerifyStatus> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sct_5faudit_5freport_2eproto
