// chrome/browser/ui/webui/feed_internals/feed_internals.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_WEBUI_FEED_INTERNALS_FEED_INTERNALS_MOJOM_H_
#define CHROME_BROWSER_UI_WEBUI_FEED_INTERNALS_FEED_INTERNALS_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "chrome/browser/ui/webui/feed_internals/feed_internals.mojom-shared.h"
#include "chrome/browser/ui/webui/feed_internals/feed_internals.mojom-forward.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"






namespace feed_internals {
namespace mojom {

class PageHandlerProxy;

template <typename ImplRefTraits>
class PageHandlerStub;

class PageHandlerRequestValidator;
class PageHandlerResponseValidator;


class  PageHandler
    : public PageHandlerInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = PageHandlerInterfaceBase;
  using Proxy_ = PageHandlerProxy;

  template <typename ImplRefTraits>
  using Stub_ = PageHandlerStub<ImplRefTraits>;

  using RequestValidator_ = PageHandlerRequestValidator;
  using ResponseValidator_ = PageHandlerResponseValidator;
  enum MethodMinVersions : uint32_t {
    kGetGeneralPropertiesMinVersion = 0,
    kGetLastFetchPropertiesMinVersion = 0,
    kRefreshForYouFeedMinVersion = 0,
    kRefreshFollowingFeedMinVersion = 0,
    kRefreshWebFeedSuggestionsMinVersion = 0,
    kGetFeedProcessScopeDumpMinVersion = 0,
    kGetFeedHistogramsMinVersion = 0,
    kOverrideFeedHostMinVersion = 0,
    kOverrideDiscoverApiEndpointMinVersion = 0,
    kOverrideFeedStreamDataMinVersion = 0,
    kSetWebFeedFollowIntroDebugEnabledMinVersion = 0,
    kSetUseFeedQueryRequestsMinVersion = 0,
    kSetFollowingFeedOrderMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct GetGeneralProperties_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetLastFetchProperties_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct RefreshForYouFeed_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct RefreshFollowingFeed_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct RefreshWebFeedSuggestions_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetFeedProcessScopeDump_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetFeedHistograms_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OverrideFeedHost_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OverrideDiscoverApiEndpoint_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OverrideFeedStreamData_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetWebFeedFollowIntroDebugEnabled_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetUseFeedQueryRequests_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SetFollowingFeedOrder_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~PageHandler() = default;


  using GetGeneralPropertiesCallback = base::OnceCallback<void(PropertiesPtr)>;
  
  virtual void GetGeneralProperties(GetGeneralPropertiesCallback callback) = 0;


  using GetLastFetchPropertiesCallback = base::OnceCallback<void(LastFetchPropertiesPtr)>;
  
  virtual void GetLastFetchProperties(GetLastFetchPropertiesCallback callback) = 0;

  
  virtual void RefreshForYouFeed() = 0;

  
  virtual void RefreshFollowingFeed() = 0;

  
  virtual void RefreshWebFeedSuggestions() = 0;


  using GetFeedProcessScopeDumpCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetFeedProcessScopeDump(GetFeedProcessScopeDumpCallback callback) = 0;


  using GetFeedHistogramsCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetFeedHistograms(GetFeedHistogramsCallback callback) = 0;

  
  virtual void OverrideFeedHost(const ::GURL& host) = 0;

  
  virtual void OverrideDiscoverApiEndpoint(const ::GURL& endpoint_url) = 0;

  
  virtual void OverrideFeedStreamData(const std::vector<uint8_t>& data) = 0;

  
  virtual void SetWebFeedFollowIntroDebugEnabled(bool enabled) = 0;

  
  virtual void SetUseFeedQueryRequests(bool use_legacy) = 0;

  
  virtual void SetFollowingFeedOrder(FeedOrder order) = 0;
};



class  PageHandlerProxy
    : public PageHandler {
 public:
  using InterfaceType = PageHandler;

  explicit PageHandlerProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetGeneralProperties(GetGeneralPropertiesCallback callback) final;
  
  void GetLastFetchProperties(GetLastFetchPropertiesCallback callback) final;
  
  void RefreshForYouFeed() final;
  
  void RefreshFollowingFeed() final;
  
  void RefreshWebFeedSuggestions() final;
  
  void GetFeedProcessScopeDump(GetFeedProcessScopeDumpCallback callback) final;
  
  void GetFeedHistograms(GetFeedHistogramsCallback callback) final;
  
  void OverrideFeedHost(const ::GURL& host) final;
  
  void OverrideDiscoverApiEndpoint(const ::GURL& endpoint_url) final;
  
  void OverrideFeedStreamData(const std::vector<uint8_t>& data) final;
  
  void SetWebFeedFollowIntroDebugEnabled(bool enabled) final;
  
  void SetUseFeedQueryRequests(bool use_legacy) final;
  
  void SetFollowingFeedOrder(FeedOrder order) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  PageHandlerStubDispatch {
 public:
  static bool Accept(PageHandler* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      PageHandler* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<PageHandler>>
class PageHandlerStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  PageHandlerStub() = default;
  ~PageHandlerStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return PageHandlerStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  PageHandlerRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  PageHandlerResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};









class  Properties {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Properties, T>::value>;
  using DataView = PropertiesDataView;
  using Data_ = internal::Properties_Data;

  template <typename... Args>
  static PropertiesPtr New(Args&&... args) {
    return PropertiesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PropertiesPtr From(const U& u) {
    return mojo::TypeConverter<PropertiesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Properties>::Convert(*this);
  }


  Properties();

  Properties(
      bool is_feed_enabled,
      bool is_feed_visible,
      bool is_feed_allowed,
      bool is_prefetching_enabled,
      bool is_web_feed_follow_intro_debug_enabled,
      bool use_feed_query_requests,
      const std::string& load_stream_status,
      const ::GURL& feed_fetch_url,
      const ::GURL& feed_actions_url,
      FeedOrder following_feed_order);


  ~Properties();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PropertiesPtr>
  PropertiesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Properties::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Properties::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Properties::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Properties::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Properties_UnserializedMessageContext<
            UserType, Properties::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Properties::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Properties::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Properties_UnserializedMessageContext<
            UserType, Properties::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Properties::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool is_feed_enabled;
  
  bool is_feed_visible;
  
  bool is_feed_allowed;
  
  bool is_prefetching_enabled;
  
  bool is_web_feed_follow_intro_debug_enabled;
  
  bool use_feed_query_requests;
  
  std::string load_stream_status;
  
  ::GURL feed_fetch_url;
  
  ::GURL feed_actions_url;
  
  FeedOrder following_feed_order;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Properties::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  LastFetchProperties {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<LastFetchProperties, T>::value>;
  using DataView = LastFetchPropertiesDataView;
  using Data_ = internal::LastFetchProperties_Data;

  template <typename... Args>
  static LastFetchPropertiesPtr New(Args&&... args) {
    return LastFetchPropertiesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static LastFetchPropertiesPtr From(const U& u) {
    return mojo::TypeConverter<LastFetchPropertiesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, LastFetchProperties>::Convert(*this);
  }


  LastFetchProperties();

  LastFetchProperties(
      int32_t last_fetch_status,
      const std::string& last_fetch_trigger,
      ::base::TimeDelta last_fetch_time,
      ::base::TimeDelta refresh_suppress_time,
      const std::string& last_bless_nonce,
      int32_t last_action_upload_status,
      ::base::TimeDelta last_action_upload_time);


  ~LastFetchProperties();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = LastFetchPropertiesPtr>
  LastFetchPropertiesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        LastFetchProperties::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        LastFetchProperties::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::LastFetchProperties_UnserializedMessageContext<
            UserType, LastFetchProperties::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<LastFetchProperties::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return LastFetchProperties::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::LastFetchProperties_UnserializedMessageContext<
            UserType, LastFetchProperties::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<LastFetchProperties::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int32_t last_fetch_status;
  
  std::string last_fetch_trigger;
  
  ::base::TimeDelta last_fetch_time;
  
  ::base::TimeDelta refresh_suppress_time;
  
  std::string last_bless_nonce;
  
  int32_t last_action_upload_status;
  
  ::base::TimeDelta last_action_upload_time;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, LastFetchProperties::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
PropertiesPtr Properties::Clone() const {
  return New(
      mojo::Clone(is_feed_enabled),
      mojo::Clone(is_feed_visible),
      mojo::Clone(is_feed_allowed),
      mojo::Clone(is_prefetching_enabled),
      mojo::Clone(is_web_feed_follow_intro_debug_enabled),
      mojo::Clone(use_feed_query_requests),
      mojo::Clone(load_stream_status),
      mojo::Clone(feed_fetch_url),
      mojo::Clone(feed_actions_url),
      mojo::Clone(following_feed_order)
  );
}

template <typename T, Properties::EnableIfSame<T>*>
bool Properties::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->is_feed_enabled, other_struct.is_feed_enabled))
    return false;
  if (!mojo::Equals(this->is_feed_visible, other_struct.is_feed_visible))
    return false;
  if (!mojo::Equals(this->is_feed_allowed, other_struct.is_feed_allowed))
    return false;
  if (!mojo::Equals(this->is_prefetching_enabled, other_struct.is_prefetching_enabled))
    return false;
  if (!mojo::Equals(this->is_web_feed_follow_intro_debug_enabled, other_struct.is_web_feed_follow_intro_debug_enabled))
    return false;
  if (!mojo::Equals(this->use_feed_query_requests, other_struct.use_feed_query_requests))
    return false;
  if (!mojo::Equals(this->load_stream_status, other_struct.load_stream_status))
    return false;
  if (!mojo::Equals(this->feed_fetch_url, other_struct.feed_fetch_url))
    return false;
  if (!mojo::Equals(this->feed_actions_url, other_struct.feed_actions_url))
    return false;
  if (!mojo::Equals(this->following_feed_order, other_struct.following_feed_order))
    return false;
  return true;
}

template <typename T, Properties::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.is_feed_enabled < rhs.is_feed_enabled)
    return true;
  if (rhs.is_feed_enabled < lhs.is_feed_enabled)
    return false;
  if (lhs.is_feed_visible < rhs.is_feed_visible)
    return true;
  if (rhs.is_feed_visible < lhs.is_feed_visible)
    return false;
  if (lhs.is_feed_allowed < rhs.is_feed_allowed)
    return true;
  if (rhs.is_feed_allowed < lhs.is_feed_allowed)
    return false;
  if (lhs.is_prefetching_enabled < rhs.is_prefetching_enabled)
    return true;
  if (rhs.is_prefetching_enabled < lhs.is_prefetching_enabled)
    return false;
  if (lhs.is_web_feed_follow_intro_debug_enabled < rhs.is_web_feed_follow_intro_debug_enabled)
    return true;
  if (rhs.is_web_feed_follow_intro_debug_enabled < lhs.is_web_feed_follow_intro_debug_enabled)
    return false;
  if (lhs.use_feed_query_requests < rhs.use_feed_query_requests)
    return true;
  if (rhs.use_feed_query_requests < lhs.use_feed_query_requests)
    return false;
  if (lhs.load_stream_status < rhs.load_stream_status)
    return true;
  if (rhs.load_stream_status < lhs.load_stream_status)
    return false;
  if (lhs.feed_fetch_url < rhs.feed_fetch_url)
    return true;
  if (rhs.feed_fetch_url < lhs.feed_fetch_url)
    return false;
  if (lhs.feed_actions_url < rhs.feed_actions_url)
    return true;
  if (rhs.feed_actions_url < lhs.feed_actions_url)
    return false;
  if (lhs.following_feed_order < rhs.following_feed_order)
    return true;
  if (rhs.following_feed_order < lhs.following_feed_order)
    return false;
  return false;
}
template <typename StructPtrType>
LastFetchPropertiesPtr LastFetchProperties::Clone() const {
  return New(
      mojo::Clone(last_fetch_status),
      mojo::Clone(last_fetch_trigger),
      mojo::Clone(last_fetch_time),
      mojo::Clone(refresh_suppress_time),
      mojo::Clone(last_bless_nonce),
      mojo::Clone(last_action_upload_status),
      mojo::Clone(last_action_upload_time)
  );
}

template <typename T, LastFetchProperties::EnableIfSame<T>*>
bool LastFetchProperties::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->last_fetch_status, other_struct.last_fetch_status))
    return false;
  if (!mojo::Equals(this->last_fetch_trigger, other_struct.last_fetch_trigger))
    return false;
  if (!mojo::Equals(this->last_fetch_time, other_struct.last_fetch_time))
    return false;
  if (!mojo::Equals(this->refresh_suppress_time, other_struct.refresh_suppress_time))
    return false;
  if (!mojo::Equals(this->last_bless_nonce, other_struct.last_bless_nonce))
    return false;
  if (!mojo::Equals(this->last_action_upload_status, other_struct.last_action_upload_status))
    return false;
  if (!mojo::Equals(this->last_action_upload_time, other_struct.last_action_upload_time))
    return false;
  return true;
}

template <typename T, LastFetchProperties::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.last_fetch_status < rhs.last_fetch_status)
    return true;
  if (rhs.last_fetch_status < lhs.last_fetch_status)
    return false;
  if (lhs.last_fetch_trigger < rhs.last_fetch_trigger)
    return true;
  if (rhs.last_fetch_trigger < lhs.last_fetch_trigger)
    return false;
  if (lhs.last_fetch_time < rhs.last_fetch_time)
    return true;
  if (rhs.last_fetch_time < lhs.last_fetch_time)
    return false;
  if (lhs.refresh_suppress_time < rhs.refresh_suppress_time)
    return true;
  if (rhs.refresh_suppress_time < lhs.refresh_suppress_time)
    return false;
  if (lhs.last_bless_nonce < rhs.last_bless_nonce)
    return true;
  if (rhs.last_bless_nonce < lhs.last_bless_nonce)
    return false;
  if (lhs.last_action_upload_status < rhs.last_action_upload_status)
    return true;
  if (rhs.last_action_upload_status < lhs.last_action_upload_status)
    return false;
  if (lhs.last_action_upload_time < rhs.last_action_upload_time)
    return true;
  if (rhs.last_action_upload_time < lhs.last_action_upload_time)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace feed_internals

namespace mojo {


template <>
struct  StructTraits<::feed_internals::mojom::Properties::DataView,
                                         ::feed_internals::mojom::PropertiesPtr> {
  static bool IsNull(const ::feed_internals::mojom::PropertiesPtr& input) { return !input; }
  static void SetToNull(::feed_internals::mojom::PropertiesPtr* output) { output->reset(); }

  static decltype(::feed_internals::mojom::Properties::is_feed_enabled) is_feed_enabled(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_feed_enabled;
  }

  static decltype(::feed_internals::mojom::Properties::is_feed_visible) is_feed_visible(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_feed_visible;
  }

  static decltype(::feed_internals::mojom::Properties::is_feed_allowed) is_feed_allowed(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_feed_allowed;
  }

  static decltype(::feed_internals::mojom::Properties::is_prefetching_enabled) is_prefetching_enabled(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_prefetching_enabled;
  }

  static decltype(::feed_internals::mojom::Properties::is_web_feed_follow_intro_debug_enabled) is_web_feed_follow_intro_debug_enabled(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->is_web_feed_follow_intro_debug_enabled;
  }

  static decltype(::feed_internals::mojom::Properties::use_feed_query_requests) use_feed_query_requests(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->use_feed_query_requests;
  }

  static const decltype(::feed_internals::mojom::Properties::load_stream_status)& load_stream_status(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->load_stream_status;
  }

  static const decltype(::feed_internals::mojom::Properties::feed_fetch_url)& feed_fetch_url(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->feed_fetch_url;
  }

  static const decltype(::feed_internals::mojom::Properties::feed_actions_url)& feed_actions_url(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->feed_actions_url;
  }

  static decltype(::feed_internals::mojom::Properties::following_feed_order) following_feed_order(
      const ::feed_internals::mojom::PropertiesPtr& input) {
    return input->following_feed_order;
  }

  static bool Read(::feed_internals::mojom::Properties::DataView input, ::feed_internals::mojom::PropertiesPtr* output);
};


template <>
struct  StructTraits<::feed_internals::mojom::LastFetchProperties::DataView,
                                         ::feed_internals::mojom::LastFetchPropertiesPtr> {
  static bool IsNull(const ::feed_internals::mojom::LastFetchPropertiesPtr& input) { return !input; }
  static void SetToNull(::feed_internals::mojom::LastFetchPropertiesPtr* output) { output->reset(); }

  static decltype(::feed_internals::mojom::LastFetchProperties::last_fetch_status) last_fetch_status(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_fetch_status;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_fetch_trigger)& last_fetch_trigger(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_fetch_trigger;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_fetch_time)& last_fetch_time(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_fetch_time;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::refresh_suppress_time)& refresh_suppress_time(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->refresh_suppress_time;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_bless_nonce)& last_bless_nonce(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_bless_nonce;
  }

  static decltype(::feed_internals::mojom::LastFetchProperties::last_action_upload_status) last_action_upload_status(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_action_upload_status;
  }

  static const decltype(::feed_internals::mojom::LastFetchProperties::last_action_upload_time)& last_action_upload_time(
      const ::feed_internals::mojom::LastFetchPropertiesPtr& input) {
    return input->last_action_upload_time;
  }

  static bool Read(::feed_internals::mojom::LastFetchProperties::DataView input, ::feed_internals::mojom::LastFetchPropertiesPtr* output);
};

}  // namespace mojo

#endif  // CHROME_BROWSER_UI_WEBUI_FEED_INTERNALS_FEED_INTERNALS_MOJOM_H_