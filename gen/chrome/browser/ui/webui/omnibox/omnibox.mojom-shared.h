// chrome/browser/ui/webui/omnibox/omnibox.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_BROWSER_UI_WEBUI_OMNIBOX_OMNIBOX_MOJOM_SHARED_H_
#define CHROME_BROWSER_UI_WEBUI_OMNIBOX_OMNIBOX_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "chrome/browser/ui/webui/omnibox/omnibox.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace mojom {
class ACMatchClassificationDataView;

class AutocompleteAdditionalInfoDataView;

class AutocompleteMatchDataView;

class AutocompleteResultsForProviderDataView;

class OmniboxResponseDataView;



}  // namespace mojom

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::mojom::ACMatchClassificationDataView> {
  using Data = ::mojom::internal::ACMatchClassification_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojom::AutocompleteAdditionalInfoDataView> {
  using Data = ::mojom::internal::AutocompleteAdditionalInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojom::AutocompleteMatchDataView> {
  using Data = ::mojom::internal::AutocompleteMatch_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojom::AutocompleteResultsForProviderDataView> {
  using Data = ::mojom::internal::AutocompleteResultsForProvider_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::mojom::OmniboxResponseDataView> {
  using Data = ::mojom::internal::OmniboxResponse_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace mojom {
// Interface base classes. They are used for type safety check.
class OmniboxPageHandlerInterfaceBase {};

using OmniboxPageHandlerPtrDataView =
    mojo::InterfacePtrDataView<OmniboxPageHandlerInterfaceBase>;
using OmniboxPageHandlerRequestDataView =
    mojo::InterfaceRequestDataView<OmniboxPageHandlerInterfaceBase>;
using OmniboxPageHandlerAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<OmniboxPageHandlerInterfaceBase>;
using OmniboxPageHandlerAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<OmniboxPageHandlerInterfaceBase>;
class OmniboxPageInterfaceBase {};

using OmniboxPagePtrDataView =
    mojo::InterfacePtrDataView<OmniboxPageInterfaceBase>;
using OmniboxPageRequestDataView =
    mojo::InterfaceRequestDataView<OmniboxPageInterfaceBase>;
using OmniboxPageAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<OmniboxPageInterfaceBase>;
using OmniboxPageAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<OmniboxPageInterfaceBase>;


class ACMatchClassificationDataView {
 public:
  ACMatchClassificationDataView() = default;

  ACMatchClassificationDataView(
      internal::ACMatchClassification_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t offset() const {
    return data_->offset;
  }
  int32_t style() const {
    return data_->style;
  }
 private:
  internal::ACMatchClassification_Data* data_ = nullptr;
};



class AutocompleteAdditionalInfoDataView {
 public:
  AutocompleteAdditionalInfoDataView() = default;

  AutocompleteAdditionalInfoDataView(
      internal::AutocompleteAdditionalInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetKeyDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKey(UserType* output) {
    
    auto* pointer = data_->key.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetValueDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
    auto* pointer = data_->value.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::AutocompleteAdditionalInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AutocompleteMatchDataView {
 public:
  AutocompleteMatchDataView() = default;

  AutocompleteMatchDataView(
      internal::AutocompleteMatch_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetProviderNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadProviderName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `provider_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadProviderName` instead "
    "of `ReadProviderName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->provider_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool provider_done() const {
    return data_->provider_done;
  }
  int32_t relevance() const {
    return data_->relevance;
  }
  bool deletable() const {
    return data_->deletable;
  }
  inline void GetFillIntoEditDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFillIntoEdit(UserType* output) {
    
    auto* pointer = data_->fill_into_edit.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetInlineAutocompletionDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInlineAutocompletion(UserType* output) {
    
    auto* pointer = data_->inline_autocompletion.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetDestinationUrlDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDestinationUrl(UserType* output) {
    
    auto* pointer = data_->destination_url.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetStrippedDestinationUrlDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStrippedDestinationUrl(UserType* output) {
    
    auto* pointer = data_->stripped_destination_url.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetImageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadImage(UserType* output) {
    
    auto* pointer = data_->image.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetContentsDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadContents(UserType* output) {
    
    auto* pointer = data_->contents.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetContentsClassDataView(
      mojo::ArrayDataView<ACMatchClassificationDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadContentsClass(UserType* output) {
    
    auto* pointer = data_->contents_class.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojom::ACMatchClassificationDataView>>(
        pointer, output, message_);
  }
  inline void GetDescriptionDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDescription(UserType* output) {
    
    auto* pointer = data_->description.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetDescriptionClassDataView(
      mojo::ArrayDataView<ACMatchClassificationDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDescriptionClass(UserType* output) {
    
    auto* pointer = data_->description_class.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojom::ACMatchClassificationDataView>>(
        pointer, output, message_);
  }
  bool swap_contents_and_description() const {
    return data_->swap_contents_and_description;
  }
  inline void GetAnswerDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAnswer(UserType* output) {
    
    auto* pointer = data_->answer.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetTransitionDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransition(UserType* output) {
    
    auto* pointer = data_->transition.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool allowed_to_be_default_match() const {
    return data_->allowed_to_be_default_match;
  }
  inline void GetTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) {
    
    auto* pointer = data_->type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool is_search_type() const {
    return data_->is_search_type;
  }
  inline void GetAqsTypeSubtypesDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAqsTypeSubtypes(UserType* output) {
    
    auto* pointer = data_->aqs_type_subtypes.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool has_tab_match() const {
    return data_->has_tab_match;
  }
  inline void GetAssociatedKeywordDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAssociatedKeyword(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `associated_keyword` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAssociatedKeyword` instead "
    "of `ReadAssociatedKeyword if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->associated_keyword.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetKeywordDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyword(UserType* output) {
    
    auto* pointer = data_->keyword.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool starred() const {
    return data_->starred;
  }
  int32_t duplicates() const {
    return data_->duplicates;
  }
  bool from_previous() const {
    return data_->from_previous;
  }
  int32_t pedal_id() const {
    return data_->pedal_id;
  }
  inline void GetAdditionalInfoDataView(
      mojo::ArrayDataView<AutocompleteAdditionalInfoDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAdditionalInfo(UserType* output) {
    
    auto* pointer = data_->additional_info.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojom::AutocompleteAdditionalInfoDataView>>(
        pointer, output, message_);
  }
 private:
  internal::AutocompleteMatch_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AutocompleteResultsForProviderDataView {
 public:
  AutocompleteResultsForProviderDataView() = default;

  AutocompleteResultsForProviderDataView(
      internal::AutocompleteResultsForProvider_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetProviderNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadProviderName(UserType* output) {
    
    auto* pointer = data_->provider_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetResultsDataView(
      mojo::ArrayDataView<AutocompleteMatchDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadResults(UserType* output) {
    
    auto* pointer = data_->results.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojom::AutocompleteMatchDataView>>(
        pointer, output, message_);
  }
 private:
  internal::AutocompleteResultsForProvider_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class OmniboxResponseDataView {
 public:
  OmniboxResponseDataView() = default;

  OmniboxResponseDataView(
      internal::OmniboxResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t cursor_position() const {
    return data_->cursor_position;
  }
  int32_t time_since_omnibox_started_ms() const {
    return data_->time_since_omnibox_started_ms;
  }
  bool done() const {
    return data_->done;
  }
  inline void GetTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) {
    
    auto* pointer = data_->type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetHostDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadHost(UserType* output) {
    
    auto* pointer = data_->host.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool is_typed_host() const {
    return data_->is_typed_host;
  }
  inline void GetInputTextDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInputText(UserType* output) {
    
    auto* pointer = data_->input_text.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetCombinedResultsDataView(
      mojo::ArrayDataView<AutocompleteMatchDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCombinedResults(UserType* output) {
    
    auto* pointer = data_->combined_results.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojom::AutocompleteMatchDataView>>(
        pointer, output, message_);
  }
  inline void GetResultsByProviderDataView(
      mojo::ArrayDataView<AutocompleteResultsForProviderDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadResultsByProvider(UserType* output) {
    
    auto* pointer = data_->results_by_provider.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojom::AutocompleteResultsForProviderDataView>>(
        pointer, output, message_);
  }
 private:
  internal::OmniboxResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom

namespace std {

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojom::ACMatchClassificationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojom::ACMatchClassificationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojom::internal::ACMatchClassification_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->offset = Traits::offset(input);
    fragment->style = Traits::style(input);
  }

  static bool Deserialize(::mojom::internal::ACMatchClassification_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojom::ACMatchClassificationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojom::AutocompleteAdditionalInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojom::AutocompleteAdditionalInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojom::internal::AutocompleteAdditionalInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::key(input)) in_key = Traits::key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key)::BaseType> key_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_key, key_fragment);
    fragment->key.Set(
        key_fragment.is_null() ? nullptr : key_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key in AutocompleteAdditionalInfo struct");
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->value)::BaseType> value_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_value, value_fragment);
    fragment->value.Set(
        value_fragment.is_null() ? nullptr : value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null value in AutocompleteAdditionalInfo struct");
  }

  static bool Deserialize(::mojom::internal::AutocompleteAdditionalInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojom::AutocompleteAdditionalInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojom::AutocompleteMatchDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojom::AutocompleteMatchDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojom::internal::AutocompleteMatch_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::provider_name(input)) in_provider_name = Traits::provider_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->provider_name)::BaseType> provider_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_provider_name, provider_name_fragment);
    fragment->provider_name.Set(
        provider_name_fragment.is_null() ? nullptr : provider_name_fragment.data());
    fragment->provider_done = Traits::provider_done(input);
    fragment->relevance = Traits::relevance(input);
    fragment->deletable = Traits::deletable(input);
    decltype(Traits::fill_into_edit(input)) in_fill_into_edit = Traits::fill_into_edit(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->fill_into_edit)::BaseType> fill_into_edit_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_fill_into_edit, fill_into_edit_fragment);
    fragment->fill_into_edit.Set(
        fill_into_edit_fragment.is_null() ? nullptr : fill_into_edit_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->fill_into_edit.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null fill_into_edit in AutocompleteMatch struct");
    decltype(Traits::inline_autocompletion(input)) in_inline_autocompletion = Traits::inline_autocompletion(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->inline_autocompletion)::BaseType> inline_autocompletion_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_inline_autocompletion, inline_autocompletion_fragment);
    fragment->inline_autocompletion.Set(
        inline_autocompletion_fragment.is_null() ? nullptr : inline_autocompletion_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->inline_autocompletion.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null inline_autocompletion in AutocompleteMatch struct");
    decltype(Traits::destination_url(input)) in_destination_url = Traits::destination_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->destination_url)::BaseType> destination_url_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_destination_url, destination_url_fragment);
    fragment->destination_url.Set(
        destination_url_fragment.is_null() ? nullptr : destination_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->destination_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null destination_url in AutocompleteMatch struct");
    decltype(Traits::stripped_destination_url(input)) in_stripped_destination_url = Traits::stripped_destination_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->stripped_destination_url)::BaseType> stripped_destination_url_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_stripped_destination_url, stripped_destination_url_fragment);
    fragment->stripped_destination_url.Set(
        stripped_destination_url_fragment.is_null() ? nullptr : stripped_destination_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->stripped_destination_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null stripped_destination_url in AutocompleteMatch struct");
    decltype(Traits::image(input)) in_image = Traits::image(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->image)::BaseType> image_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_image, image_fragment);
    fragment->image.Set(
        image_fragment.is_null() ? nullptr : image_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->image.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null image in AutocompleteMatch struct");
    decltype(Traits::contents(input)) in_contents = Traits::contents(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->contents)::BaseType> contents_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_contents, contents_fragment);
    fragment->contents.Set(
        contents_fragment.is_null() ? nullptr : contents_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->contents.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null contents in AutocompleteMatch struct");
    decltype(Traits::contents_class(input)) in_contents_class = Traits::contents_class(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->contents_class)::BaseType>
        contents_class_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams contents_class_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojom::ACMatchClassificationDataView>>(
        in_contents_class, contents_class_fragment, &contents_class_validate_params);
    fragment->contents_class.Set(
        contents_class_fragment.is_null() ? nullptr : contents_class_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->contents_class.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null contents_class in AutocompleteMatch struct");
    decltype(Traits::description(input)) in_description = Traits::description(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->description)::BaseType> description_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_description, description_fragment);
    fragment->description.Set(
        description_fragment.is_null() ? nullptr : description_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->description.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null description in AutocompleteMatch struct");
    decltype(Traits::description_class(input)) in_description_class = Traits::description_class(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->description_class)::BaseType>
        description_class_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams description_class_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojom::ACMatchClassificationDataView>>(
        in_description_class, description_class_fragment, &description_class_validate_params);
    fragment->description_class.Set(
        description_class_fragment.is_null() ? nullptr : description_class_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->description_class.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null description_class in AutocompleteMatch struct");
    fragment->swap_contents_and_description = Traits::swap_contents_and_description(input);
    decltype(Traits::answer(input)) in_answer = Traits::answer(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->answer)::BaseType> answer_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_answer, answer_fragment);
    fragment->answer.Set(
        answer_fragment.is_null() ? nullptr : answer_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->answer.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null answer in AutocompleteMatch struct");
    decltype(Traits::transition(input)) in_transition = Traits::transition(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transition)::BaseType> transition_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_transition, transition_fragment);
    fragment->transition.Set(
        transition_fragment.is_null() ? nullptr : transition_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->transition.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transition in AutocompleteMatch struct");
    fragment->allowed_to_be_default_match = Traits::allowed_to_be_default_match(input);
    decltype(Traits::type(input)) in_type = Traits::type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->type)::BaseType> type_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_type, type_fragment);
    fragment->type.Set(
        type_fragment.is_null() ? nullptr : type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->type.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null type in AutocompleteMatch struct");
    fragment->is_search_type = Traits::is_search_type(input);
    decltype(Traits::aqs_type_subtypes(input)) in_aqs_type_subtypes = Traits::aqs_type_subtypes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->aqs_type_subtypes)::BaseType> aqs_type_subtypes_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_aqs_type_subtypes, aqs_type_subtypes_fragment);
    fragment->aqs_type_subtypes.Set(
        aqs_type_subtypes_fragment.is_null() ? nullptr : aqs_type_subtypes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->aqs_type_subtypes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null aqs_type_subtypes in AutocompleteMatch struct");
    fragment->has_tab_match = Traits::has_tab_match(input);
    decltype(Traits::associated_keyword(input)) in_associated_keyword = Traits::associated_keyword(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->associated_keyword)::BaseType> associated_keyword_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_associated_keyword, associated_keyword_fragment);
    fragment->associated_keyword.Set(
        associated_keyword_fragment.is_null() ? nullptr : associated_keyword_fragment.data());
    decltype(Traits::keyword(input)) in_keyword = Traits::keyword(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->keyword)::BaseType> keyword_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_keyword, keyword_fragment);
    fragment->keyword.Set(
        keyword_fragment.is_null() ? nullptr : keyword_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->keyword.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null keyword in AutocompleteMatch struct");
    fragment->starred = Traits::starred(input);
    fragment->duplicates = Traits::duplicates(input);
    fragment->from_previous = Traits::from_previous(input);
    fragment->pedal_id = Traits::pedal_id(input);
    decltype(Traits::additional_info(input)) in_additional_info = Traits::additional_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->additional_info)::BaseType>
        additional_info_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams additional_info_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojom::AutocompleteAdditionalInfoDataView>>(
        in_additional_info, additional_info_fragment, &additional_info_validate_params);
    fragment->additional_info.Set(
        additional_info_fragment.is_null() ? nullptr : additional_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->additional_info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null additional_info in AutocompleteMatch struct");
  }

  static bool Deserialize(::mojom::internal::AutocompleteMatch_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojom::AutocompleteMatchDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojom::AutocompleteResultsForProviderDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojom::AutocompleteResultsForProviderDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojom::internal::AutocompleteResultsForProvider_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::provider_name(input)) in_provider_name = Traits::provider_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->provider_name)::BaseType> provider_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_provider_name, provider_name_fragment);
    fragment->provider_name.Set(
        provider_name_fragment.is_null() ? nullptr : provider_name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->provider_name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null provider_name in AutocompleteResultsForProvider struct");
    decltype(Traits::results(input)) in_results = Traits::results(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->results)::BaseType>
        results_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams results_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojom::AutocompleteMatchDataView>>(
        in_results, results_fragment, &results_validate_params);
    fragment->results.Set(
        results_fragment.is_null() ? nullptr : results_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->results.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null results in AutocompleteResultsForProvider struct");
  }

  static bool Deserialize(::mojom::internal::AutocompleteResultsForProvider_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojom::AutocompleteResultsForProviderDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::mojom::OmniboxResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::mojom::OmniboxResponseDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::mojom::internal::OmniboxResponse_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->cursor_position = Traits::cursor_position(input);
    fragment->time_since_omnibox_started_ms = Traits::time_since_omnibox_started_ms(input);
    fragment->done = Traits::done(input);
    decltype(Traits::type(input)) in_type = Traits::type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->type)::BaseType> type_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_type, type_fragment);
    fragment->type.Set(
        type_fragment.is_null() ? nullptr : type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->type.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null type in OmniboxResponse struct");
    decltype(Traits::host(input)) in_host = Traits::host(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->host)::BaseType> host_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_host, host_fragment);
    fragment->host.Set(
        host_fragment.is_null() ? nullptr : host_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->host.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null host in OmniboxResponse struct");
    fragment->is_typed_host = Traits::is_typed_host(input);
    decltype(Traits::input_text(input)) in_input_text = Traits::input_text(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->input_text)::BaseType> input_text_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_input_text, input_text_fragment);
    fragment->input_text.Set(
        input_text_fragment.is_null() ? nullptr : input_text_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->input_text.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null input_text in OmniboxResponse struct");
    decltype(Traits::combined_results(input)) in_combined_results = Traits::combined_results(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->combined_results)::BaseType>
        combined_results_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams combined_results_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojom::AutocompleteMatchDataView>>(
        in_combined_results, combined_results_fragment, &combined_results_validate_params);
    fragment->combined_results.Set(
        combined_results_fragment.is_null() ? nullptr : combined_results_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->combined_results.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null combined_results in OmniboxResponse struct");
    decltype(Traits::results_by_provider(input)) in_results_by_provider = Traits::results_by_provider(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->results_by_provider)::BaseType>
        results_by_provider_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams results_by_provider_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojom::AutocompleteResultsForProviderDataView>>(
        in_results_by_provider, results_by_provider_fragment, &results_by_provider_validate_params);
    fragment->results_by_provider.Set(
        results_by_provider_fragment.is_null() ? nullptr : results_by_provider_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->results_by_provider.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null results_by_provider in OmniboxResponse struct");
  }

  static bool Deserialize(::mojom::internal::OmniboxResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::mojom::OmniboxResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace mojom {



inline void AutocompleteAdditionalInfoDataView::GetKeyDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->key.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteAdditionalInfoDataView::GetValueDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->value.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void AutocompleteMatchDataView::GetProviderNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->provider_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetFillIntoEditDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->fill_into_edit.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetInlineAutocompletionDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->inline_autocompletion.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetDestinationUrlDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->destination_url.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetStrippedDestinationUrlDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->stripped_destination_url.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetImageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->image.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetContentsDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->contents.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetContentsClassDataView(
    mojo::ArrayDataView<ACMatchClassificationDataView>* output) {
  auto pointer = data_->contents_class.Get();
  *output = mojo::ArrayDataView<ACMatchClassificationDataView>(pointer, message_);
}
inline void AutocompleteMatchDataView::GetDescriptionDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->description.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetDescriptionClassDataView(
    mojo::ArrayDataView<ACMatchClassificationDataView>* output) {
  auto pointer = data_->description_class.Get();
  *output = mojo::ArrayDataView<ACMatchClassificationDataView>(pointer, message_);
}
inline void AutocompleteMatchDataView::GetAnswerDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->answer.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetTransitionDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->transition.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->type.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetAqsTypeSubtypesDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->aqs_type_subtypes.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetAssociatedKeywordDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->associated_keyword.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetKeywordDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->keyword.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteMatchDataView::GetAdditionalInfoDataView(
    mojo::ArrayDataView<AutocompleteAdditionalInfoDataView>* output) {
  auto pointer = data_->additional_info.Get();
  *output = mojo::ArrayDataView<AutocompleteAdditionalInfoDataView>(pointer, message_);
}


inline void AutocompleteResultsForProviderDataView::GetProviderNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->provider_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void AutocompleteResultsForProviderDataView::GetResultsDataView(
    mojo::ArrayDataView<AutocompleteMatchDataView>* output) {
  auto pointer = data_->results.Get();
  *output = mojo::ArrayDataView<AutocompleteMatchDataView>(pointer, message_);
}


inline void OmniboxResponseDataView::GetTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->type.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void OmniboxResponseDataView::GetHostDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->host.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void OmniboxResponseDataView::GetInputTextDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->input_text.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void OmniboxResponseDataView::GetCombinedResultsDataView(
    mojo::ArrayDataView<AutocompleteMatchDataView>* output) {
  auto pointer = data_->combined_results.Get();
  *output = mojo::ArrayDataView<AutocompleteMatchDataView>(pointer, message_);
}
inline void OmniboxResponseDataView::GetResultsByProviderDataView(
    mojo::ArrayDataView<AutocompleteResultsForProviderDataView>* output) {
  auto pointer = data_->results_by_provider.Get();
  *output = mojo::ArrayDataView<AutocompleteResultsForProviderDataView>(pointer, message_);
}



}  // namespace mojom

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif  // CHROME_BROWSER_UI_WEBUI_OMNIBOX_OMNIBOX_MOJOM_SHARED_H_