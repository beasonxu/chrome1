// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: share_target.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_share_5ftarget_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_share_5ftarget_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry_lite.h>
#include <google/protobuf/map_field_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_share_5ftarget_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_share_5ftarget_2eproto {
  static const uint32_t offsets[];
};
namespace sharing {
namespace mojom {
class MapLocaleTargets;
struct MapLocaleTargetsDefaultTypeInternal;
extern MapLocaleTargetsDefaultTypeInternal _MapLocaleTargets_default_instance_;
class MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse;
struct MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUseDefaultTypeInternal;
extern MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUseDefaultTypeInternal _MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse_default_instance_;
class ShareTarget;
struct ShareTargetDefaultTypeInternal;
extern ShareTargetDefaultTypeInternal _ShareTarget_default_instance_;
class ShareTargetLocalesForParsing;
struct ShareTargetLocalesForParsingDefaultTypeInternal;
extern ShareTargetLocalesForParsingDefaultTypeInternal _ShareTargetLocalesForParsing_default_instance_;
class ShareTargets;
struct ShareTargetsDefaultTypeInternal;
extern ShareTargetsDefaultTypeInternal _ShareTargets_default_instance_;
class TargetLocalesForParsing;
struct TargetLocalesForParsingDefaultTypeInternal;
extern TargetLocalesForParsingDefaultTypeInternal _TargetLocalesForParsing_default_instance_;
class TmpShareTargetMap;
struct TmpShareTargetMapDefaultTypeInternal;
extern TmpShareTargetMapDefaultTypeInternal _TmpShareTargetMap_default_instance_;
class TmpShareTargetMap_AllTargetsEntry_DoNotUse;
struct TmpShareTargetMap_AllTargetsEntry_DoNotUseDefaultTypeInternal;
extern TmpShareTargetMap_AllTargetsEntry_DoNotUseDefaultTypeInternal _TmpShareTargetMap_AllTargetsEntry_DoNotUse_default_instance_;
}  // namespace mojom
}  // namespace sharing
PROTOBUF_NAMESPACE_OPEN
template<> ::sharing::mojom::MapLocaleTargets* Arena::CreateMaybeMessage<::sharing::mojom::MapLocaleTargets>(Arena*);
template<> ::sharing::mojom::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse* Arena::CreateMaybeMessage<::sharing::mojom::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse>(Arena*);
template<> ::sharing::mojom::ShareTarget* Arena::CreateMaybeMessage<::sharing::mojom::ShareTarget>(Arena*);
template<> ::sharing::mojom::ShareTargetLocalesForParsing* Arena::CreateMaybeMessage<::sharing::mojom::ShareTargetLocalesForParsing>(Arena*);
template<> ::sharing::mojom::ShareTargets* Arena::CreateMaybeMessage<::sharing::mojom::ShareTargets>(Arena*);
template<> ::sharing::mojom::TargetLocalesForParsing* Arena::CreateMaybeMessage<::sharing::mojom::TargetLocalesForParsing>(Arena*);
template<> ::sharing::mojom::TmpShareTargetMap* Arena::CreateMaybeMessage<::sharing::mojom::TmpShareTargetMap>(Arena*);
template<> ::sharing::mojom::TmpShareTargetMap_AllTargetsEntry_DoNotUse* Arena::CreateMaybeMessage<::sharing::mojom::TmpShareTargetMap_AllTargetsEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sharing {
namespace mojom {

// ===================================================================

class ShareTarget final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.mojom.ShareTarget) */ {
 public:
  inline ShareTarget() : ShareTarget(nullptr) {}
  ~ShareTarget() override;
  explicit PROTOBUF_CONSTEXPR ShareTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareTarget(const ShareTarget& from);
  ShareTarget(ShareTarget&& from) noexcept
    : ShareTarget() {
    *this = ::std::move(from);
  }

  inline ShareTarget& operator=(const ShareTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareTarget& operator=(ShareTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ShareTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareTarget* internal_default_instance() {
    return reinterpret_cast<const ShareTarget*>(
               &_ShareTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ShareTarget& a, ShareTarget& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShareTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareTarget>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShareTarget& from);
  void MergeFrom(const ShareTarget& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShareTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.mojom.ShareTarget";
  }
  protected:
  explicit ShareTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNicknameFieldNumber = 1,
    kUrlFieldNumber = 2,
    kIconFieldNumber = 3,
    kIcon2XFieldNumber = 4,
    kIcon3XFieldNumber = 5,
  };
  // string nickname = 1;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string url = 2;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // string icon = 3;
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // string icon_2x = 4;
  void clear_icon_2x();
  const std::string& icon_2x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon_2x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon_2x();
  PROTOBUF_NODISCARD std::string* release_icon_2x();
  void set_allocated_icon_2x(std::string* icon_2x);
  private:
  const std::string& _internal_icon_2x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_2x(const std::string& value);
  std::string* _internal_mutable_icon_2x();
  public:

  // string icon_3x = 5;
  void clear_icon_3x();
  const std::string& icon_3x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon_3x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon_3x();
  PROTOBUF_NODISCARD std::string* release_icon_3x();
  void set_allocated_icon_3x(std::string* icon_3x);
  private:
  const std::string& _internal_icon_3x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon_3x(const std::string& value);
  std::string* _internal_mutable_icon_3x();
  public:

  // @@protoc_insertion_point(class_scope:sharing.mojom.ShareTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_2x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_3x_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_share_5ftarget_2eproto;
};
// -------------------------------------------------------------------

class ShareTargets final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.mojom.ShareTargets) */ {
 public:
  inline ShareTargets() : ShareTargets(nullptr) {}
  ~ShareTargets() override;
  explicit PROTOBUF_CONSTEXPR ShareTargets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareTargets(const ShareTargets& from);
  ShareTargets(ShareTargets&& from) noexcept
    : ShareTargets() {
    *this = ::std::move(from);
  }

  inline ShareTargets& operator=(const ShareTargets& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareTargets& operator=(ShareTargets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ShareTargets& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareTargets* internal_default_instance() {
    return reinterpret_cast<const ShareTargets*>(
               &_ShareTargets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ShareTargets& a, ShareTargets& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShareTargets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareTargets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareTargets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareTargets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShareTargets& from);
  void MergeFrom(const ShareTargets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShareTargets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.mojom.ShareTargets";
  }
  protected:
  explicit ShareTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .sharing.mojom.ShareTarget targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::sharing::mojom::ShareTarget* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >*
      mutable_targets();
  private:
  const ::sharing::mojom::ShareTarget& _internal_targets(int index) const;
  ::sharing::mojom::ShareTarget* _internal_add_targets();
  public:
  const ::sharing::mojom::ShareTarget& targets(int index) const;
  ::sharing::mojom::ShareTarget* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >&
      targets() const;

  // @@protoc_insertion_point(class_scope:sharing.mojom.ShareTargets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget > targets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_share_5ftarget_2eproto;
};
// -------------------------------------------------------------------

class MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse, 
    std::string, ::sharing::mojom::ShareTargets,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse, 
    std::string, ::sharing::mojom::ShareTargets,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse& other);
  static const MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse*>(&_MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sharing.mojom.MapLocaleTargets.MapTargetLocaleMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_share_5ftarget_2eproto;
};

// -------------------------------------------------------------------

class MapLocaleTargets final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.mojom.MapLocaleTargets) */ {
 public:
  inline MapLocaleTargets() : MapLocaleTargets(nullptr) {}
  ~MapLocaleTargets() override;
  explicit PROTOBUF_CONSTEXPR MapLocaleTargets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MapLocaleTargets(const MapLocaleTargets& from);
  MapLocaleTargets(MapLocaleTargets&& from) noexcept
    : MapLocaleTargets() {
    *this = ::std::move(from);
  }

  inline MapLocaleTargets& operator=(const MapLocaleTargets& from) {
    CopyFrom(from);
    return *this;
  }
  inline MapLocaleTargets& operator=(MapLocaleTargets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const MapLocaleTargets& default_instance() {
    return *internal_default_instance();
  }
  static inline const MapLocaleTargets* internal_default_instance() {
    return reinterpret_cast<const MapLocaleTargets*>(
               &_MapLocaleTargets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MapLocaleTargets& a, MapLocaleTargets& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MapLocaleTargets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MapLocaleTargets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MapLocaleTargets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MapLocaleTargets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MapLocaleTargets& from);
  void MergeFrom(const MapLocaleTargets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MapLocaleTargets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.mojom.MapLocaleTargets";
  }
  protected:
  explicit MapLocaleTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMapTargetLocaleMapFieldNumber = 1,
    kVersionIdFieldNumber = 2,
  };
  // map<string, .sharing.mojom.ShareTargets> map_target_locale_map = 1;
  int map_target_locale_map_size() const;
  private:
  int _internal_map_target_locale_map_size() const;
  public:
  void clear_map_target_locale_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >&
      _internal_map_target_locale_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >*
      _internal_mutable_map_target_locale_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >&
      map_target_locale_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >*
      mutable_map_target_locale_map();

  // uint32 version_id = 2;
  void clear_version_id();
  uint32_t version_id() const;
  void set_version_id(uint32_t value);
  private:
  uint32_t _internal_version_id() const;
  void _internal_set_version_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sharing.mojom.MapLocaleTargets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse,
      std::string, ::sharing::mojom::ShareTargets,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> map_target_locale_map_;
  uint32_t version_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_share_5ftarget_2eproto;
};
// -------------------------------------------------------------------

class TmpShareTargetMap_AllTargetsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<TmpShareTargetMap_AllTargetsEntry_DoNotUse, 
    std::string, ::sharing::mojom::ShareTarget,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntryLite<TmpShareTargetMap_AllTargetsEntry_DoNotUse, 
    std::string, ::sharing::mojom::ShareTarget,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  TmpShareTargetMap_AllTargetsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR TmpShareTargetMap_AllTargetsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit TmpShareTargetMap_AllTargetsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const TmpShareTargetMap_AllTargetsEntry_DoNotUse& other);
  static const TmpShareTargetMap_AllTargetsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TmpShareTargetMap_AllTargetsEntry_DoNotUse*>(&_TmpShareTargetMap_AllTargetsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "sharing.mojom.TmpShareTargetMap.AllTargetsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  friend struct ::TableStruct_share_5ftarget_2eproto;
};

// -------------------------------------------------------------------

class TmpShareTargetMap final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.mojom.TmpShareTargetMap) */ {
 public:
  inline TmpShareTargetMap() : TmpShareTargetMap(nullptr) {}
  ~TmpShareTargetMap() override;
  explicit PROTOBUF_CONSTEXPR TmpShareTargetMap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TmpShareTargetMap(const TmpShareTargetMap& from);
  TmpShareTargetMap(TmpShareTargetMap&& from) noexcept
    : TmpShareTargetMap() {
    *this = ::std::move(from);
  }

  inline TmpShareTargetMap& operator=(const TmpShareTargetMap& from) {
    CopyFrom(from);
    return *this;
  }
  inline TmpShareTargetMap& operator=(TmpShareTargetMap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TmpShareTargetMap& default_instance() {
    return *internal_default_instance();
  }
  static inline const TmpShareTargetMap* internal_default_instance() {
    return reinterpret_cast<const TmpShareTargetMap*>(
               &_TmpShareTargetMap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TmpShareTargetMap& a, TmpShareTargetMap& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TmpShareTargetMap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TmpShareTargetMap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TmpShareTargetMap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TmpShareTargetMap>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TmpShareTargetMap& from);
  void MergeFrom(const TmpShareTargetMap& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TmpShareTargetMap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.mojom.TmpShareTargetMap";
  }
  protected:
  explicit TmpShareTargetMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kAllTargetsFieldNumber = 1,
  };
  // map<string, .sharing.mojom.ShareTarget> all_targets = 1;
  int all_targets_size() const;
  private:
  int _internal_all_targets_size() const;
  public:
  void clear_all_targets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >&
      _internal_all_targets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >*
      _internal_mutable_all_targets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >&
      all_targets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >*
      mutable_all_targets();

  // @@protoc_insertion_point(class_scope:sharing.mojom.TmpShareTargetMap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapFieldLite<
      TmpShareTargetMap_AllTargetsEntry_DoNotUse,
      std::string, ::sharing::mojom::ShareTarget,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> all_targets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_share_5ftarget_2eproto;
};
// -------------------------------------------------------------------

class ShareTargetLocalesForParsing final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.mojom.ShareTargetLocalesForParsing) */ {
 public:
  inline ShareTargetLocalesForParsing() : ShareTargetLocalesForParsing(nullptr) {}
  ~ShareTargetLocalesForParsing() override;
  explicit PROTOBUF_CONSTEXPR ShareTargetLocalesForParsing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShareTargetLocalesForParsing(const ShareTargetLocalesForParsing& from);
  ShareTargetLocalesForParsing(ShareTargetLocalesForParsing&& from) noexcept
    : ShareTargetLocalesForParsing() {
    *this = ::std::move(from);
  }

  inline ShareTargetLocalesForParsing& operator=(const ShareTargetLocalesForParsing& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShareTargetLocalesForParsing& operator=(ShareTargetLocalesForParsing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ShareTargetLocalesForParsing& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShareTargetLocalesForParsing* internal_default_instance() {
    return reinterpret_cast<const ShareTargetLocalesForParsing*>(
               &_ShareTargetLocalesForParsing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ShareTargetLocalesForParsing& a, ShareTargetLocalesForParsing& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ShareTargetLocalesForParsing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShareTargetLocalesForParsing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShareTargetLocalesForParsing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShareTargetLocalesForParsing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ShareTargetLocalesForParsing& from);
  void MergeFrom(const ShareTargetLocalesForParsing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ShareTargetLocalesForParsing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.mojom.ShareTargetLocalesForParsing";
  }
  protected:
  explicit ShareTargetLocalesForParsing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
    kLocaleKeysFieldNumber = 2,
  };
  // repeated string targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  const std::string& targets(int index) const;
  std::string* mutable_targets(int index);
  void set_targets(int index, const std::string& value);
  void set_targets(int index, std::string&& value);
  void set_targets(int index, const char* value);
  void set_targets(int index, const char* value, size_t size);
  std::string* add_targets();
  void add_targets(const std::string& value);
  void add_targets(std::string&& value);
  void add_targets(const char* value);
  void add_targets(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& targets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_targets();
  private:
  const std::string& _internal_targets(int index) const;
  std::string* _internal_add_targets();
  public:

  // repeated string locale_keys = 2;
  int locale_keys_size() const;
  private:
  int _internal_locale_keys_size() const;
  public:
  void clear_locale_keys();
  const std::string& locale_keys(int index) const;
  std::string* mutable_locale_keys(int index);
  void set_locale_keys(int index, const std::string& value);
  void set_locale_keys(int index, std::string&& value);
  void set_locale_keys(int index, const char* value);
  void set_locale_keys(int index, const char* value, size_t size);
  std::string* add_locale_keys();
  void add_locale_keys(const std::string& value);
  void add_locale_keys(std::string&& value);
  void add_locale_keys(const char* value);
  void add_locale_keys(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& locale_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_locale_keys();
  private:
  const std::string& _internal_locale_keys(int index) const;
  std::string* _internal_add_locale_keys();
  public:

  // @@protoc_insertion_point(class_scope:sharing.mojom.ShareTargetLocalesForParsing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> targets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> locale_keys_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_share_5ftarget_2eproto;
};
// -------------------------------------------------------------------

class TargetLocalesForParsing final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sharing.mojom.TargetLocalesForParsing) */ {
 public:
  inline TargetLocalesForParsing() : TargetLocalesForParsing(nullptr) {}
  ~TargetLocalesForParsing() override;
  explicit PROTOBUF_CONSTEXPR TargetLocalesForParsing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TargetLocalesForParsing(const TargetLocalesForParsing& from);
  TargetLocalesForParsing(TargetLocalesForParsing&& from) noexcept
    : TargetLocalesForParsing() {
    *this = ::std::move(from);
  }

  inline TargetLocalesForParsing& operator=(const TargetLocalesForParsing& from) {
    CopyFrom(from);
    return *this;
  }
  inline TargetLocalesForParsing& operator=(TargetLocalesForParsing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TargetLocalesForParsing& default_instance() {
    return *internal_default_instance();
  }
  static inline const TargetLocalesForParsing* internal_default_instance() {
    return reinterpret_cast<const TargetLocalesForParsing*>(
               &_TargetLocalesForParsing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TargetLocalesForParsing& a, TargetLocalesForParsing& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TargetLocalesForParsing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TargetLocalesForParsing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TargetLocalesForParsing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TargetLocalesForParsing>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TargetLocalesForParsing& from);
  void MergeFrom(const TargetLocalesForParsing& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TargetLocalesForParsing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sharing.mojom.TargetLocalesForParsing";
  }
  protected:
  explicit TargetLocalesForParsing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
    kLocaleMappingFieldNumber = 2,
    kVersionIdFieldNumber = 3,
  };
  // repeated .sharing.mojom.ShareTarget targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::sharing::mojom::ShareTarget* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >*
      mutable_targets();
  private:
  const ::sharing::mojom::ShareTarget& _internal_targets(int index) const;
  ::sharing::mojom::ShareTarget* _internal_add_targets();
  public:
  const ::sharing::mojom::ShareTarget& targets(int index) const;
  ::sharing::mojom::ShareTarget* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >&
      targets() const;

  // repeated .sharing.mojom.ShareTargetLocalesForParsing locale_mapping = 2;
  int locale_mapping_size() const;
  private:
  int _internal_locale_mapping_size() const;
  public:
  void clear_locale_mapping();
  ::sharing::mojom::ShareTargetLocalesForParsing* mutable_locale_mapping(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTargetLocalesForParsing >*
      mutable_locale_mapping();
  private:
  const ::sharing::mojom::ShareTargetLocalesForParsing& _internal_locale_mapping(int index) const;
  ::sharing::mojom::ShareTargetLocalesForParsing* _internal_add_locale_mapping();
  public:
  const ::sharing::mojom::ShareTargetLocalesForParsing& locale_mapping(int index) const;
  ::sharing::mojom::ShareTargetLocalesForParsing* add_locale_mapping();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTargetLocalesForParsing >&
      locale_mapping() const;

  // uint32 version_id = 3;
  void clear_version_id();
  uint32_t version_id() const;
  void set_version_id(uint32_t value);
  private:
  uint32_t _internal_version_id() const;
  void _internal_set_version_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sharing.mojom.TargetLocalesForParsing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget > targets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTargetLocalesForParsing > locale_mapping_;
  uint32_t version_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_share_5ftarget_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShareTarget

// string nickname = 1;
inline void ShareTarget::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& ShareTarget::nickname() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTarget.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareTarget::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTarget.nickname)
}
inline std::string* ShareTarget::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTarget.nickname)
  return _s;
}
inline const std::string& ShareTarget::_internal_nickname() const {
  return nickname_.Get();
}
inline void ShareTarget::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareTarget::_internal_mutable_nickname() {
  
  return nickname_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareTarget::release_nickname() {
  // @@protoc_insertion_point(field_release:sharing.mojom.ShareTarget.nickname)
  return nickname_.Release();
}
inline void ShareTarget::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(nickname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault()) {
    nickname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sharing.mojom.ShareTarget.nickname)
}

// string url = 2;
inline void ShareTarget::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& ShareTarget::url() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTarget.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareTarget::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTarget.url)
}
inline std::string* ShareTarget::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTarget.url)
  return _s;
}
inline const std::string& ShareTarget::_internal_url() const {
  return url_.Get();
}
inline void ShareTarget::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareTarget::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareTarget::release_url() {
  // @@protoc_insertion_point(field_release:sharing.mojom.ShareTarget.url)
  return url_.Release();
}
inline void ShareTarget::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sharing.mojom.ShareTarget.url)
}

// string icon = 3;
inline void ShareTarget::clear_icon() {
  icon_.ClearToEmpty();
}
inline const std::string& ShareTarget::icon() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTarget.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareTarget::set_icon(ArgT0&& arg0, ArgT... args) {
 
 icon_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTarget.icon)
}
inline std::string* ShareTarget::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTarget.icon)
  return _s;
}
inline const std::string& ShareTarget::_internal_icon() const {
  return icon_.Get();
}
inline void ShareTarget::_internal_set_icon(const std::string& value) {
  
  icon_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareTarget::_internal_mutable_icon() {
  
  return icon_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareTarget::release_icon() {
  // @@protoc_insertion_point(field_release:sharing.mojom.ShareTarget.icon)
  return icon_.Release();
}
inline void ShareTarget::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    
  } else {
    
  }
  icon_.SetAllocated(icon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault()) {
    icon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sharing.mojom.ShareTarget.icon)
}

// string icon_2x = 4;
inline void ShareTarget::clear_icon_2x() {
  icon_2x_.ClearToEmpty();
}
inline const std::string& ShareTarget::icon_2x() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTarget.icon_2x)
  return _internal_icon_2x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareTarget::set_icon_2x(ArgT0&& arg0, ArgT... args) {
 
 icon_2x_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTarget.icon_2x)
}
inline std::string* ShareTarget::mutable_icon_2x() {
  std::string* _s = _internal_mutable_icon_2x();
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTarget.icon_2x)
  return _s;
}
inline const std::string& ShareTarget::_internal_icon_2x() const {
  return icon_2x_.Get();
}
inline void ShareTarget::_internal_set_icon_2x(const std::string& value) {
  
  icon_2x_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareTarget::_internal_mutable_icon_2x() {
  
  return icon_2x_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareTarget::release_icon_2x() {
  // @@protoc_insertion_point(field_release:sharing.mojom.ShareTarget.icon_2x)
  return icon_2x_.Release();
}
inline void ShareTarget::set_allocated_icon_2x(std::string* icon_2x) {
  if (icon_2x != nullptr) {
    
  } else {
    
  }
  icon_2x_.SetAllocated(icon_2x, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_2x_.IsDefault()) {
    icon_2x_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sharing.mojom.ShareTarget.icon_2x)
}

// string icon_3x = 5;
inline void ShareTarget::clear_icon_3x() {
  icon_3x_.ClearToEmpty();
}
inline const std::string& ShareTarget::icon_3x() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTarget.icon_3x)
  return _internal_icon_3x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ShareTarget::set_icon_3x(ArgT0&& arg0, ArgT... args) {
 
 icon_3x_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTarget.icon_3x)
}
inline std::string* ShareTarget::mutable_icon_3x() {
  std::string* _s = _internal_mutable_icon_3x();
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTarget.icon_3x)
  return _s;
}
inline const std::string& ShareTarget::_internal_icon_3x() const {
  return icon_3x_.Get();
}
inline void ShareTarget::_internal_set_icon_3x(const std::string& value) {
  
  icon_3x_.Set(value, GetArenaForAllocation());
}
inline std::string* ShareTarget::_internal_mutable_icon_3x() {
  
  return icon_3x_.Mutable(GetArenaForAllocation());
}
inline std::string* ShareTarget::release_icon_3x() {
  // @@protoc_insertion_point(field_release:sharing.mojom.ShareTarget.icon_3x)
  return icon_3x_.Release();
}
inline void ShareTarget::set_allocated_icon_3x(std::string* icon_3x) {
  if (icon_3x != nullptr) {
    
  } else {
    
  }
  icon_3x_.SetAllocated(icon_3x, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_3x_.IsDefault()) {
    icon_3x_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sharing.mojom.ShareTarget.icon_3x)
}

// -------------------------------------------------------------------

// ShareTargets

// repeated .sharing.mojom.ShareTarget targets = 1;
inline int ShareTargets::_internal_targets_size() const {
  return targets_.size();
}
inline int ShareTargets::targets_size() const {
  return _internal_targets_size();
}
inline void ShareTargets::clear_targets() {
  targets_.Clear();
}
inline ::sharing::mojom::ShareTarget* ShareTargets::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTargets.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >*
ShareTargets::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:sharing.mojom.ShareTargets.targets)
  return &targets_;
}
inline const ::sharing::mojom::ShareTarget& ShareTargets::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::sharing::mojom::ShareTarget& ShareTargets::targets(int index) const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTargets.targets)
  return _internal_targets(index);
}
inline ::sharing::mojom::ShareTarget* ShareTargets::_internal_add_targets() {
  return targets_.Add();
}
inline ::sharing::mojom::ShareTarget* ShareTargets::add_targets() {
  ::sharing::mojom::ShareTarget* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:sharing.mojom.ShareTargets.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >&
ShareTargets::targets() const {
  // @@protoc_insertion_point(field_list:sharing.mojom.ShareTargets.targets)
  return targets_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MapLocaleTargets

// map<string, .sharing.mojom.ShareTargets> map_target_locale_map = 1;
inline int MapLocaleTargets::_internal_map_target_locale_map_size() const {
  return map_target_locale_map_.size();
}
inline int MapLocaleTargets::map_target_locale_map_size() const {
  return _internal_map_target_locale_map_size();
}
inline void MapLocaleTargets::clear_map_target_locale_map() {
  map_target_locale_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >&
MapLocaleTargets::_internal_map_target_locale_map() const {
  return map_target_locale_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >&
MapLocaleTargets::map_target_locale_map() const {
  // @@protoc_insertion_point(field_map:sharing.mojom.MapLocaleTargets.map_target_locale_map)
  return _internal_map_target_locale_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >*
MapLocaleTargets::_internal_mutable_map_target_locale_map() {
  return map_target_locale_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >*
MapLocaleTargets::mutable_map_target_locale_map() {
  // @@protoc_insertion_point(field_mutable_map:sharing.mojom.MapLocaleTargets.map_target_locale_map)
  return _internal_mutable_map_target_locale_map();
}

// uint32 version_id = 2;
inline void MapLocaleTargets::clear_version_id() {
  version_id_ = 0u;
}
inline uint32_t MapLocaleTargets::_internal_version_id() const {
  return version_id_;
}
inline uint32_t MapLocaleTargets::version_id() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.MapLocaleTargets.version_id)
  return _internal_version_id();
}
inline void MapLocaleTargets::_internal_set_version_id(uint32_t value) {
  
  version_id_ = value;
}
inline void MapLocaleTargets::set_version_id(uint32_t value) {
  _internal_set_version_id(value);
  // @@protoc_insertion_point(field_set:sharing.mojom.MapLocaleTargets.version_id)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// TmpShareTargetMap

// map<string, .sharing.mojom.ShareTarget> all_targets = 1;
inline int TmpShareTargetMap::_internal_all_targets_size() const {
  return all_targets_.size();
}
inline int TmpShareTargetMap::all_targets_size() const {
  return _internal_all_targets_size();
}
inline void TmpShareTargetMap::clear_all_targets() {
  all_targets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >&
TmpShareTargetMap::_internal_all_targets() const {
  return all_targets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >&
TmpShareTargetMap::all_targets() const {
  // @@protoc_insertion_point(field_map:sharing.mojom.TmpShareTargetMap.all_targets)
  return _internal_all_targets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >*
TmpShareTargetMap::_internal_mutable_all_targets() {
  return all_targets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >*
TmpShareTargetMap::mutable_all_targets() {
  // @@protoc_insertion_point(field_mutable_map:sharing.mojom.TmpShareTargetMap.all_targets)
  return _internal_mutable_all_targets();
}

// -------------------------------------------------------------------

// ShareTargetLocalesForParsing

// repeated string targets = 1;
inline int ShareTargetLocalesForParsing::_internal_targets_size() const {
  return targets_.size();
}
inline int ShareTargetLocalesForParsing::targets_size() const {
  return _internal_targets_size();
}
inline void ShareTargetLocalesForParsing::clear_targets() {
  targets_.Clear();
}
inline std::string* ShareTargetLocalesForParsing::add_targets() {
  std::string* _s = _internal_add_targets();
  // @@protoc_insertion_point(field_add_mutable:sharing.mojom.ShareTargetLocalesForParsing.targets)
  return _s;
}
inline const std::string& ShareTargetLocalesForParsing::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const std::string& ShareTargetLocalesForParsing::targets(int index) const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTargetLocalesForParsing.targets)
  return _internal_targets(index);
}
inline std::string* ShareTargetLocalesForParsing::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTargetLocalesForParsing.targets)
  return targets_.Mutable(index);
}
inline void ShareTargetLocalesForParsing::set_targets(int index, const std::string& value) {
  targets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline void ShareTargetLocalesForParsing::set_targets(int index, std::string&& value) {
  targets_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline void ShareTargetLocalesForParsing::set_targets(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  targets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline void ShareTargetLocalesForParsing::set_targets(int index, const char* value, size_t size) {
  targets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline std::string* ShareTargetLocalesForParsing::_internal_add_targets() {
  return targets_.Add();
}
inline void ShareTargetLocalesForParsing::add_targets(const std::string& value) {
  targets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline void ShareTargetLocalesForParsing::add_targets(std::string&& value) {
  targets_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline void ShareTargetLocalesForParsing::add_targets(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  targets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline void ShareTargetLocalesForParsing::add_targets(const char* value, size_t size) {
  targets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sharing.mojom.ShareTargetLocalesForParsing.targets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShareTargetLocalesForParsing::targets() const {
  // @@protoc_insertion_point(field_list:sharing.mojom.ShareTargetLocalesForParsing.targets)
  return targets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShareTargetLocalesForParsing::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:sharing.mojom.ShareTargetLocalesForParsing.targets)
  return &targets_;
}

// repeated string locale_keys = 2;
inline int ShareTargetLocalesForParsing::_internal_locale_keys_size() const {
  return locale_keys_.size();
}
inline int ShareTargetLocalesForParsing::locale_keys_size() const {
  return _internal_locale_keys_size();
}
inline void ShareTargetLocalesForParsing::clear_locale_keys() {
  locale_keys_.Clear();
}
inline std::string* ShareTargetLocalesForParsing::add_locale_keys() {
  std::string* _s = _internal_add_locale_keys();
  // @@protoc_insertion_point(field_add_mutable:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
  return _s;
}
inline const std::string& ShareTargetLocalesForParsing::_internal_locale_keys(int index) const {
  return locale_keys_.Get(index);
}
inline const std::string& ShareTargetLocalesForParsing::locale_keys(int index) const {
  // @@protoc_insertion_point(field_get:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
  return _internal_locale_keys(index);
}
inline std::string* ShareTargetLocalesForParsing::mutable_locale_keys(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
  return locale_keys_.Mutable(index);
}
inline void ShareTargetLocalesForParsing::set_locale_keys(int index, const std::string& value) {
  locale_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline void ShareTargetLocalesForParsing::set_locale_keys(int index, std::string&& value) {
  locale_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline void ShareTargetLocalesForParsing::set_locale_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  locale_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline void ShareTargetLocalesForParsing::set_locale_keys(int index, const char* value, size_t size) {
  locale_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline std::string* ShareTargetLocalesForParsing::_internal_add_locale_keys() {
  return locale_keys_.Add();
}
inline void ShareTargetLocalesForParsing::add_locale_keys(const std::string& value) {
  locale_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline void ShareTargetLocalesForParsing::add_locale_keys(std::string&& value) {
  locale_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline void ShareTargetLocalesForParsing::add_locale_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  locale_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline void ShareTargetLocalesForParsing::add_locale_keys(const char* value, size_t size) {
  locale_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ShareTargetLocalesForParsing::locale_keys() const {
  // @@protoc_insertion_point(field_list:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
  return locale_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ShareTargetLocalesForParsing::mutable_locale_keys() {
  // @@protoc_insertion_point(field_mutable_list:sharing.mojom.ShareTargetLocalesForParsing.locale_keys)
  return &locale_keys_;
}

// -------------------------------------------------------------------

// TargetLocalesForParsing

// repeated .sharing.mojom.ShareTarget targets = 1;
inline int TargetLocalesForParsing::_internal_targets_size() const {
  return targets_.size();
}
inline int TargetLocalesForParsing::targets_size() const {
  return _internal_targets_size();
}
inline void TargetLocalesForParsing::clear_targets() {
  targets_.Clear();
}
inline ::sharing::mojom::ShareTarget* TargetLocalesForParsing::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.mojom.TargetLocalesForParsing.targets)
  return targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >*
TargetLocalesForParsing::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:sharing.mojom.TargetLocalesForParsing.targets)
  return &targets_;
}
inline const ::sharing::mojom::ShareTarget& TargetLocalesForParsing::_internal_targets(int index) const {
  return targets_.Get(index);
}
inline const ::sharing::mojom::ShareTarget& TargetLocalesForParsing::targets(int index) const {
  // @@protoc_insertion_point(field_get:sharing.mojom.TargetLocalesForParsing.targets)
  return _internal_targets(index);
}
inline ::sharing::mojom::ShareTarget* TargetLocalesForParsing::_internal_add_targets() {
  return targets_.Add();
}
inline ::sharing::mojom::ShareTarget* TargetLocalesForParsing::add_targets() {
  ::sharing::mojom::ShareTarget* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:sharing.mojom.TargetLocalesForParsing.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTarget >&
TargetLocalesForParsing::targets() const {
  // @@protoc_insertion_point(field_list:sharing.mojom.TargetLocalesForParsing.targets)
  return targets_;
}

// repeated .sharing.mojom.ShareTargetLocalesForParsing locale_mapping = 2;
inline int TargetLocalesForParsing::_internal_locale_mapping_size() const {
  return locale_mapping_.size();
}
inline int TargetLocalesForParsing::locale_mapping_size() const {
  return _internal_locale_mapping_size();
}
inline void TargetLocalesForParsing::clear_locale_mapping() {
  locale_mapping_.Clear();
}
inline ::sharing::mojom::ShareTargetLocalesForParsing* TargetLocalesForParsing::mutable_locale_mapping(int index) {
  // @@protoc_insertion_point(field_mutable:sharing.mojom.TargetLocalesForParsing.locale_mapping)
  return locale_mapping_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTargetLocalesForParsing >*
TargetLocalesForParsing::mutable_locale_mapping() {
  // @@protoc_insertion_point(field_mutable_list:sharing.mojom.TargetLocalesForParsing.locale_mapping)
  return &locale_mapping_;
}
inline const ::sharing::mojom::ShareTargetLocalesForParsing& TargetLocalesForParsing::_internal_locale_mapping(int index) const {
  return locale_mapping_.Get(index);
}
inline const ::sharing::mojom::ShareTargetLocalesForParsing& TargetLocalesForParsing::locale_mapping(int index) const {
  // @@protoc_insertion_point(field_get:sharing.mojom.TargetLocalesForParsing.locale_mapping)
  return _internal_locale_mapping(index);
}
inline ::sharing::mojom::ShareTargetLocalesForParsing* TargetLocalesForParsing::_internal_add_locale_mapping() {
  return locale_mapping_.Add();
}
inline ::sharing::mojom::ShareTargetLocalesForParsing* TargetLocalesForParsing::add_locale_mapping() {
  ::sharing::mojom::ShareTargetLocalesForParsing* _add = _internal_add_locale_mapping();
  // @@protoc_insertion_point(field_add:sharing.mojom.TargetLocalesForParsing.locale_mapping)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sharing::mojom::ShareTargetLocalesForParsing >&
TargetLocalesForParsing::locale_mapping() const {
  // @@protoc_insertion_point(field_list:sharing.mojom.TargetLocalesForParsing.locale_mapping)
  return locale_mapping_;
}

// uint32 version_id = 3;
inline void TargetLocalesForParsing::clear_version_id() {
  version_id_ = 0u;
}
inline uint32_t TargetLocalesForParsing::_internal_version_id() const {
  return version_id_;
}
inline uint32_t TargetLocalesForParsing::version_id() const {
  // @@protoc_insertion_point(field_get:sharing.mojom.TargetLocalesForParsing.version_id)
  return _internal_version_id();
}
inline void TargetLocalesForParsing::_internal_set_version_id(uint32_t value) {
  
  version_id_ = value;
}
inline void TargetLocalesForParsing::set_version_id(uint32_t value) {
  _internal_set_version_id(value);
  // @@protoc_insertion_point(field_set:sharing.mojom.TargetLocalesForParsing.version_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mojom
}  // namespace sharing

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_share_5ftarget_2eproto
