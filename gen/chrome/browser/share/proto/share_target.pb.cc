// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: share_target.proto

#include "share_target.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sharing {
namespace mojom {
PROTOBUF_CONSTEXPR ShareTarget::ShareTarget(
    ::_pbi::ConstantInitialized)
  : nickname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , icon_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , icon_2x_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , icon_3x_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ShareTargetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShareTargetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShareTargetDefaultTypeInternal() {}
  union {
    ShareTarget _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShareTargetDefaultTypeInternal _ShareTarget_default_instance_;
PROTOBUF_CONSTEXPR ShareTargets::ShareTargets(
    ::_pbi::ConstantInitialized)
  : targets_(){}
struct ShareTargetsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShareTargetsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShareTargetsDefaultTypeInternal() {}
  union {
    ShareTargets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShareTargetsDefaultTypeInternal _ShareTargets_default_instance_;
PROTOBUF_CONSTEXPR MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUseDefaultTypeInternal() {}
  union {
    MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUseDefaultTypeInternal _MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR MapLocaleTargets::MapLocaleTargets(
    ::_pbi::ConstantInitialized)
  : map_target_locale_map_()
  , version_id_(0u){}
struct MapLocaleTargetsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MapLocaleTargetsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MapLocaleTargetsDefaultTypeInternal() {}
  union {
    MapLocaleTargets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MapLocaleTargetsDefaultTypeInternal _MapLocaleTargets_default_instance_;
PROTOBUF_CONSTEXPR TmpShareTargetMap_AllTargetsEntry_DoNotUse::TmpShareTargetMap_AllTargetsEntry_DoNotUse(
    ::_pbi::ConstantInitialized){}
struct TmpShareTargetMap_AllTargetsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TmpShareTargetMap_AllTargetsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TmpShareTargetMap_AllTargetsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    TmpShareTargetMap_AllTargetsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TmpShareTargetMap_AllTargetsEntry_DoNotUseDefaultTypeInternal _TmpShareTargetMap_AllTargetsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR TmpShareTargetMap::TmpShareTargetMap(
    ::_pbi::ConstantInitialized)
  : all_targets_(){}
struct TmpShareTargetMapDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TmpShareTargetMapDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TmpShareTargetMapDefaultTypeInternal() {}
  union {
    TmpShareTargetMap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TmpShareTargetMapDefaultTypeInternal _TmpShareTargetMap_default_instance_;
PROTOBUF_CONSTEXPR ShareTargetLocalesForParsing::ShareTargetLocalesForParsing(
    ::_pbi::ConstantInitialized)
  : targets_()
  , locale_keys_(){}
struct ShareTargetLocalesForParsingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ShareTargetLocalesForParsingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ShareTargetLocalesForParsingDefaultTypeInternal() {}
  union {
    ShareTargetLocalesForParsing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ShareTargetLocalesForParsingDefaultTypeInternal _ShareTargetLocalesForParsing_default_instance_;
PROTOBUF_CONSTEXPR TargetLocalesForParsing::TargetLocalesForParsing(
    ::_pbi::ConstantInitialized)
  : targets_()
  , locale_mapping_()
  , version_id_(0u){}
struct TargetLocalesForParsingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TargetLocalesForParsingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TargetLocalesForParsingDefaultTypeInternal() {}
  union {
    TargetLocalesForParsing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TargetLocalesForParsingDefaultTypeInternal _TargetLocalesForParsing_default_instance_;
}  // namespace mojom
}  // namespace sharing
namespace sharing {
namespace mojom {

// ===================================================================

class ShareTarget::_Internal {
 public:
};

ShareTarget::ShareTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sharing.mojom.ShareTarget)
}
ShareTarget::ShareTarget(const ShareTarget& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  nickname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nickname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_nickname().empty()) {
    nickname_.Set(from._internal_nickname(), 
      GetArenaForAllocation());
  }
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  icon_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    icon_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_icon().empty()) {
    icon_.Set(from._internal_icon(), 
      GetArenaForAllocation());
  }
  icon_2x_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    icon_2x_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_icon_2x().empty()) {
    icon_2x_.Set(from._internal_icon_2x(), 
      GetArenaForAllocation());
  }
  icon_3x_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    icon_3x_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_icon_3x().empty()) {
    icon_3x_.Set(from._internal_icon_3x(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sharing.mojom.ShareTarget)
}

inline void ShareTarget::SharedCtor() {
nickname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nickname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
icon_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  icon_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
icon_2x_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  icon_2x_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
icon_3x_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  icon_3x_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ShareTarget::~ShareTarget() {
  // @@protoc_insertion_point(destructor:sharing.mojom.ShareTarget)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShareTarget::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nickname_.Destroy();
  url_.Destroy();
  icon_.Destroy();
  icon_2x_.Destroy();
  icon_3x_.Destroy();
}

void ShareTarget::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShareTarget::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.mojom.ShareTarget)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  nickname_.ClearToEmpty();
  url_.ClearToEmpty();
  icon_.ClearToEmpty();
  icon_2x_.ClearToEmpty();
  icon_3x_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* ShareTarget::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string nickname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nickname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string url = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string icon = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_icon();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string icon_2x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_icon_2x();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string icon_3x = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_icon_3x();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShareTarget::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sharing.mojom.ShareTarget)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string nickname = 1;
  if (!this->_internal_nickname().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_nickname().data(), static_cast<int>(this->_internal_nickname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTarget.nickname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nickname(), target);
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTarget.url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_url(), target);
  }

  // string icon = 3;
  if (!this->_internal_icon().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_icon().data(), static_cast<int>(this->_internal_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTarget.icon");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_icon(), target);
  }

  // string icon_2x = 4;
  if (!this->_internal_icon_2x().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_icon_2x().data(), static_cast<int>(this->_internal_icon_2x().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTarget.icon_2x");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_icon_2x(), target);
  }

  // string icon_3x = 5;
  if (!this->_internal_icon_3x().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_icon_3x().data(), static_cast<int>(this->_internal_icon_3x().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTarget.icon_3x");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_icon_3x(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sharing.mojom.ShareTarget)
  return target;
}

size_t ShareTarget::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.mojom.ShareTarget)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string nickname = 1;
  if (!this->_internal_nickname().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_nickname());
  }

  // string url = 2;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // string icon = 3;
  if (!this->_internal_icon().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_icon());
  }

  // string icon_2x = 4;
  if (!this->_internal_icon_2x().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_icon_2x());
  }

  // string icon_3x = 5;
  if (!this->_internal_icon_3x().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_icon_3x());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShareTarget::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShareTarget*>(
      &from));
}

void ShareTarget::MergeFrom(const ShareTarget& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.mojom.ShareTarget)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_nickname().empty()) {
    _internal_set_nickname(from._internal_nickname());
  }
  if (!from._internal_url().empty()) {
    _internal_set_url(from._internal_url());
  }
  if (!from._internal_icon().empty()) {
    _internal_set_icon(from._internal_icon());
  }
  if (!from._internal_icon_2x().empty()) {
    _internal_set_icon_2x(from._internal_icon_2x());
  }
  if (!from._internal_icon_3x().empty()) {
    _internal_set_icon_3x(from._internal_icon_3x());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShareTarget::CopyFrom(const ShareTarget& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.mojom.ShareTarget)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareTarget::IsInitialized() const {
  return true;
}

void ShareTarget::InternalSwap(ShareTarget* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &nickname_, lhs_arena,
      &other->nickname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &icon_, lhs_arena,
      &other->icon_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &icon_2x_, lhs_arena,
      &other->icon_2x_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &icon_3x_, lhs_arena,
      &other->icon_3x_, rhs_arena
  );
}

std::string ShareTarget::GetTypeName() const {
  return "sharing.mojom.ShareTarget";
}


// ===================================================================

class ShareTargets::_Internal {
 public:
};

ShareTargets::ShareTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targets_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sharing.mojom.ShareTargets)
}
ShareTargets::ShareTargets(const ShareTargets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targets_(from.targets_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sharing.mojom.ShareTargets)
}

inline void ShareTargets::SharedCtor() {
}

ShareTargets::~ShareTargets() {
  // @@protoc_insertion_point(destructor:sharing.mojom.ShareTargets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShareTargets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShareTargets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShareTargets::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.mojom.ShareTargets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShareTargets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sharing.mojom.ShareTarget targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShareTargets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sharing.mojom.ShareTargets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sharing.mojom.ShareTarget targets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_targets_size()); i < n; i++) {
    const auto& repfield = this->_internal_targets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sharing.mojom.ShareTargets)
  return target;
}

size_t ShareTargets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.mojom.ShareTargets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sharing.mojom.ShareTarget targets = 1;
  total_size += 1UL * this->_internal_targets_size();
  for (const auto& msg : this->targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShareTargets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShareTargets*>(
      &from));
}

void ShareTargets::MergeFrom(const ShareTargets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.mojom.ShareTargets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targets_.MergeFrom(from.targets_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShareTargets::CopyFrom(const ShareTargets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.mojom.ShareTargets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareTargets::IsInitialized() const {
  return true;
}

void ShareTargets::InternalSwap(ShareTargets* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targets_.InternalSwap(&other->targets_);
}

std::string ShareTargets::GetTypeName() const {
  return "sharing.mojom.ShareTargets";
}


// ===================================================================

MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse() {}
MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse::MergeFrom(const MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class MapLocaleTargets::_Internal {
 public:
};

MapLocaleTargets::MapLocaleTargets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  map_target_locale_map_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sharing.mojom.MapLocaleTargets)
}
MapLocaleTargets::MapLocaleTargets(const MapLocaleTargets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  map_target_locale_map_.MergeFrom(from.map_target_locale_map_);
  version_id_ = from.version_id_;
  // @@protoc_insertion_point(copy_constructor:sharing.mojom.MapLocaleTargets)
}

inline void MapLocaleTargets::SharedCtor() {
version_id_ = 0u;
}

MapLocaleTargets::~MapLocaleTargets() {
  // @@protoc_insertion_point(destructor:sharing.mojom.MapLocaleTargets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MapLocaleTargets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  map_target_locale_map_.Destruct();
}

void MapLocaleTargets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MapLocaleTargets::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.mojom.MapLocaleTargets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  map_target_locale_map_.Clear();
  version_id_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* MapLocaleTargets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .sharing.mojom.ShareTargets> map_target_locale_map = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&map_target_locale_map_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 version_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          version_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MapLocaleTargets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sharing.mojom.MapLocaleTargets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .sharing.mojom.ShareTargets> map_target_locale_map = 1;
  if (!this->_internal_map_target_locale_map().empty()) {
    using MapType = ::_pb::Map<std::string, ::sharing::mojom::ShareTargets>;
    using WireHelper = MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_map_target_locale_map();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "sharing.mojom.MapLocaleTargets.MapTargetLocaleMapEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  // uint32 version_id = 2;
  if (this->_internal_version_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_version_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sharing.mojom.MapLocaleTargets)
  return target;
}

size_t MapLocaleTargets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.mojom.MapLocaleTargets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .sharing.mojom.ShareTargets> map_target_locale_map = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_map_target_locale_map_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTargets >::const_iterator
      it = this->_internal_map_target_locale_map().begin();
      it != this->_internal_map_target_locale_map().end(); ++it) {
    total_size += MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // uint32 version_id = 2;
  if (this->_internal_version_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MapLocaleTargets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MapLocaleTargets*>(
      &from));
}

void MapLocaleTargets::MergeFrom(const MapLocaleTargets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.mojom.MapLocaleTargets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  map_target_locale_map_.MergeFrom(from.map_target_locale_map_);
  if (from._internal_version_id() != 0) {
    _internal_set_version_id(from._internal_version_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MapLocaleTargets::CopyFrom(const MapLocaleTargets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.mojom.MapLocaleTargets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapLocaleTargets::IsInitialized() const {
  return true;
}

void MapLocaleTargets::InternalSwap(MapLocaleTargets* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  map_target_locale_map_.InternalSwap(&other->map_target_locale_map_);
  swap(version_id_, other->version_id_);
}

std::string MapLocaleTargets::GetTypeName() const {
  return "sharing.mojom.MapLocaleTargets";
}


// ===================================================================

TmpShareTargetMap_AllTargetsEntry_DoNotUse::TmpShareTargetMap_AllTargetsEntry_DoNotUse() {}
TmpShareTargetMap_AllTargetsEntry_DoNotUse::TmpShareTargetMap_AllTargetsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void TmpShareTargetMap_AllTargetsEntry_DoNotUse::MergeFrom(const TmpShareTargetMap_AllTargetsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}

// ===================================================================

class TmpShareTargetMap::_Internal {
 public:
};

TmpShareTargetMap::TmpShareTargetMap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  all_targets_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sharing.mojom.TmpShareTargetMap)
}
TmpShareTargetMap::TmpShareTargetMap(const TmpShareTargetMap& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  all_targets_.MergeFrom(from.all_targets_);
  // @@protoc_insertion_point(copy_constructor:sharing.mojom.TmpShareTargetMap)
}

inline void TmpShareTargetMap::SharedCtor() {
}

TmpShareTargetMap::~TmpShareTargetMap() {
  // @@protoc_insertion_point(destructor:sharing.mojom.TmpShareTargetMap)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TmpShareTargetMap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  all_targets_.Destruct();
}

void TmpShareTargetMap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TmpShareTargetMap::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.mojom.TmpShareTargetMap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  all_targets_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TmpShareTargetMap::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .sharing.mojom.ShareTarget> all_targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&all_targets_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TmpShareTargetMap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sharing.mojom.TmpShareTargetMap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .sharing.mojom.ShareTarget> all_targets = 1;
  if (!this->_internal_all_targets().empty()) {
    using MapType = ::_pb::Map<std::string, ::sharing::mojom::ShareTarget>;
    using WireHelper = TmpShareTargetMap_AllTargetsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_all_targets();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "sharing.mojom.TmpShareTargetMap.AllTargetsEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sharing.mojom.TmpShareTargetMap)
  return target;
}

size_t TmpShareTargetMap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.mojom.TmpShareTargetMap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .sharing.mojom.ShareTarget> all_targets = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_all_targets_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::sharing::mojom::ShareTarget >::const_iterator
      it = this->_internal_all_targets().begin();
      it != this->_internal_all_targets().end(); ++it) {
    total_size += TmpShareTargetMap_AllTargetsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TmpShareTargetMap::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TmpShareTargetMap*>(
      &from));
}

void TmpShareTargetMap::MergeFrom(const TmpShareTargetMap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.mojom.TmpShareTargetMap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  all_targets_.MergeFrom(from.all_targets_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TmpShareTargetMap::CopyFrom(const TmpShareTargetMap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.mojom.TmpShareTargetMap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TmpShareTargetMap::IsInitialized() const {
  return true;
}

void TmpShareTargetMap::InternalSwap(TmpShareTargetMap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  all_targets_.InternalSwap(&other->all_targets_);
}

std::string TmpShareTargetMap::GetTypeName() const {
  return "sharing.mojom.TmpShareTargetMap";
}


// ===================================================================

class ShareTargetLocalesForParsing::_Internal {
 public:
};

ShareTargetLocalesForParsing::ShareTargetLocalesForParsing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targets_(arena),
  locale_keys_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sharing.mojom.ShareTargetLocalesForParsing)
}
ShareTargetLocalesForParsing::ShareTargetLocalesForParsing(const ShareTargetLocalesForParsing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targets_(from.targets_),
      locale_keys_(from.locale_keys_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sharing.mojom.ShareTargetLocalesForParsing)
}

inline void ShareTargetLocalesForParsing::SharedCtor() {
}

ShareTargetLocalesForParsing::~ShareTargetLocalesForParsing() {
  // @@protoc_insertion_point(destructor:sharing.mojom.ShareTargetLocalesForParsing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ShareTargetLocalesForParsing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ShareTargetLocalesForParsing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ShareTargetLocalesForParsing::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.mojom.ShareTargetLocalesForParsing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets_.Clear();
  locale_keys_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ShareTargetLocalesForParsing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_targets();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string locale_keys = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_locale_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ShareTargetLocalesForParsing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sharing.mojom.ShareTargetLocalesForParsing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string targets = 1;
  for (int i = 0, n = this->_internal_targets_size(); i < n; i++) {
    const auto& s = this->_internal_targets(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTargetLocalesForParsing.targets");
    target = stream->WriteString(1, s, target);
  }

  // repeated string locale_keys = 2;
  for (int i = 0, n = this->_internal_locale_keys_size(); i < n; i++) {
    const auto& s = this->_internal_locale_keys(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "sharing.mojom.ShareTargetLocalesForParsing.locale_keys");
    target = stream->WriteString(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sharing.mojom.ShareTargetLocalesForParsing)
  return target;
}

size_t ShareTargetLocalesForParsing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.mojom.ShareTargetLocalesForParsing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string targets = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(targets_.size());
  for (int i = 0, n = targets_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      targets_.Get(i));
  }

  // repeated string locale_keys = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(locale_keys_.size());
  for (int i = 0, n = locale_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      locale_keys_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ShareTargetLocalesForParsing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ShareTargetLocalesForParsing*>(
      &from));
}

void ShareTargetLocalesForParsing::MergeFrom(const ShareTargetLocalesForParsing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.mojom.ShareTargetLocalesForParsing)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targets_.MergeFrom(from.targets_);
  locale_keys_.MergeFrom(from.locale_keys_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ShareTargetLocalesForParsing::CopyFrom(const ShareTargetLocalesForParsing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.mojom.ShareTargetLocalesForParsing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ShareTargetLocalesForParsing::IsInitialized() const {
  return true;
}

void ShareTargetLocalesForParsing::InternalSwap(ShareTargetLocalesForParsing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targets_.InternalSwap(&other->targets_);
  locale_keys_.InternalSwap(&other->locale_keys_);
}

std::string ShareTargetLocalesForParsing::GetTypeName() const {
  return "sharing.mojom.ShareTargetLocalesForParsing";
}


// ===================================================================

class TargetLocalesForParsing::_Internal {
 public:
};

TargetLocalesForParsing::TargetLocalesForParsing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  targets_(arena),
  locale_mapping_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sharing.mojom.TargetLocalesForParsing)
}
TargetLocalesForParsing::TargetLocalesForParsing(const TargetLocalesForParsing& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      targets_(from.targets_),
      locale_mapping_(from.locale_mapping_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  version_id_ = from.version_id_;
  // @@protoc_insertion_point(copy_constructor:sharing.mojom.TargetLocalesForParsing)
}

inline void TargetLocalesForParsing::SharedCtor() {
version_id_ = 0u;
}

TargetLocalesForParsing::~TargetLocalesForParsing() {
  // @@protoc_insertion_point(destructor:sharing.mojom.TargetLocalesForParsing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TargetLocalesForParsing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TargetLocalesForParsing::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TargetLocalesForParsing::Clear() {
// @@protoc_insertion_point(message_clear_start:sharing.mojom.TargetLocalesForParsing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  targets_.Clear();
  locale_mapping_.Clear();
  version_id_ = 0u;
  _internal_metadata_.Clear<std::string>();
}

const char* TargetLocalesForParsing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sharing.mojom.ShareTarget targets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_targets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .sharing.mojom.ShareTargetLocalesForParsing locale_mapping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_locale_mapping(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // uint32 version_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          version_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TargetLocalesForParsing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sharing.mojom.TargetLocalesForParsing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sharing.mojom.ShareTarget targets = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_targets_size()); i < n; i++) {
    const auto& repfield = this->_internal_targets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .sharing.mojom.ShareTargetLocalesForParsing locale_mapping = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_locale_mapping_size()); i < n; i++) {
    const auto& repfield = this->_internal_locale_mapping(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // uint32 version_id = 3;
  if (this->_internal_version_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_version_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sharing.mojom.TargetLocalesForParsing)
  return target;
}

size_t TargetLocalesForParsing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sharing.mojom.TargetLocalesForParsing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sharing.mojom.ShareTarget targets = 1;
  total_size += 1UL * this->_internal_targets_size();
  for (const auto& msg : this->targets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .sharing.mojom.ShareTargetLocalesForParsing locale_mapping = 2;
  total_size += 1UL * this->_internal_locale_mapping_size();
  for (const auto& msg : this->locale_mapping_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // uint32 version_id = 3;
  if (this->_internal_version_id() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_version_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TargetLocalesForParsing::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TargetLocalesForParsing*>(
      &from));
}

void TargetLocalesForParsing::MergeFrom(const TargetLocalesForParsing& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sharing.mojom.TargetLocalesForParsing)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  targets_.MergeFrom(from.targets_);
  locale_mapping_.MergeFrom(from.locale_mapping_);
  if (from._internal_version_id() != 0) {
    _internal_set_version_id(from._internal_version_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TargetLocalesForParsing::CopyFrom(const TargetLocalesForParsing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sharing.mojom.TargetLocalesForParsing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TargetLocalesForParsing::IsInitialized() const {
  return true;
}

void TargetLocalesForParsing::InternalSwap(TargetLocalesForParsing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  targets_.InternalSwap(&other->targets_);
  locale_mapping_.InternalSwap(&other->locale_mapping_);
  swap(version_id_, other->version_id_);
}

std::string TargetLocalesForParsing::GetTypeName() const {
  return "sharing.mojom.TargetLocalesForParsing";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace mojom
}  // namespace sharing
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sharing::mojom::ShareTarget*
Arena::CreateMaybeMessage< ::sharing::mojom::ShareTarget >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::ShareTarget >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::ShareTargets*
Arena::CreateMaybeMessage< ::sharing::mojom::ShareTargets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::ShareTargets >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse*
Arena::CreateMaybeMessage< ::sharing::mojom::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::MapLocaleTargets_MapTargetLocaleMapEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::MapLocaleTargets*
Arena::CreateMaybeMessage< ::sharing::mojom::MapLocaleTargets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::MapLocaleTargets >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::TmpShareTargetMap_AllTargetsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::sharing::mojom::TmpShareTargetMap_AllTargetsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::TmpShareTargetMap_AllTargetsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::TmpShareTargetMap*
Arena::CreateMaybeMessage< ::sharing::mojom::TmpShareTargetMap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::TmpShareTargetMap >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::ShareTargetLocalesForParsing*
Arena::CreateMaybeMessage< ::sharing::mojom::ShareTargetLocalesForParsing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::ShareTargetLocalesForParsing >(arena);
}
template<> PROTOBUF_NOINLINE ::sharing::mojom::TargetLocalesForParsing*
Arena::CreateMaybeMessage< ::sharing::mojom::TargetLocalesForParsing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sharing::mojom::TargetLocalesForParsing >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
