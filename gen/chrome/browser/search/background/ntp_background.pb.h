// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ntp_background.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ntp_5fbackground_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ntp_5fbackground_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ntp_5fbackground_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ntp_5fbackground_2eproto {
  static const uint32_t offsets[];
};
namespace ntp {
namespace background {
class Attribution;
struct AttributionDefaultTypeInternal;
extern AttributionDefaultTypeInternal _Attribution_default_instance_;
class Collection;
struct CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class GetCollectionsRequest;
struct GetCollectionsRequestDefaultTypeInternal;
extern GetCollectionsRequestDefaultTypeInternal _GetCollectionsRequest_default_instance_;
class GetCollectionsResponse;
struct GetCollectionsResponseDefaultTypeInternal;
extern GetCollectionsResponseDefaultTypeInternal _GetCollectionsResponse_default_instance_;
class GetImageFromCollectionRequest;
struct GetImageFromCollectionRequestDefaultTypeInternal;
extern GetImageFromCollectionRequestDefaultTypeInternal _GetImageFromCollectionRequest_default_instance_;
class GetImageFromCollectionResponse;
struct GetImageFromCollectionResponseDefaultTypeInternal;
extern GetImageFromCollectionResponseDefaultTypeInternal _GetImageFromCollectionResponse_default_instance_;
class GetImagesInCollectionRequest;
struct GetImagesInCollectionRequestDefaultTypeInternal;
extern GetImagesInCollectionRequestDefaultTypeInternal _GetImagesInCollectionRequest_default_instance_;
class GetImagesInCollectionResponse;
struct GetImagesInCollectionResponseDefaultTypeInternal;
extern GetImagesInCollectionResponseDefaultTypeInternal _GetImagesInCollectionResponse_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
}  // namespace background
}  // namespace ntp
PROTOBUF_NAMESPACE_OPEN
template<> ::ntp::background::Attribution* Arena::CreateMaybeMessage<::ntp::background::Attribution>(Arena*);
template<> ::ntp::background::Collection* Arena::CreateMaybeMessage<::ntp::background::Collection>(Arena*);
template<> ::ntp::background::GetCollectionsRequest* Arena::CreateMaybeMessage<::ntp::background::GetCollectionsRequest>(Arena*);
template<> ::ntp::background::GetCollectionsResponse* Arena::CreateMaybeMessage<::ntp::background::GetCollectionsResponse>(Arena*);
template<> ::ntp::background::GetImageFromCollectionRequest* Arena::CreateMaybeMessage<::ntp::background::GetImageFromCollectionRequest>(Arena*);
template<> ::ntp::background::GetImageFromCollectionResponse* Arena::CreateMaybeMessage<::ntp::background::GetImageFromCollectionResponse>(Arena*);
template<> ::ntp::background::GetImagesInCollectionRequest* Arena::CreateMaybeMessage<::ntp::background::GetImagesInCollectionRequest>(Arena*);
template<> ::ntp::background::GetImagesInCollectionResponse* Arena::CreateMaybeMessage<::ntp::background::GetImagesInCollectionResponse>(Arena*);
template<> ::ntp::background::Image* Arena::CreateMaybeMessage<::ntp::background::Image>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ntp {
namespace background {

// ===================================================================

class Attribution final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.Attribution) */ {
 public:
  inline Attribution() : Attribution(nullptr) {}
  ~Attribution() override;
  explicit PROTOBUF_CONSTEXPR Attribution(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Attribution(const Attribution& from);
  Attribution(Attribution&& from) noexcept
    : Attribution() {
    *this = ::std::move(from);
  }

  inline Attribution& operator=(const Attribution& from) {
    CopyFrom(from);
    return *this;
  }
  inline Attribution& operator=(Attribution&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Attribution& default_instance() {
    return *internal_default_instance();
  }
  static inline const Attribution* internal_default_instance() {
    return reinterpret_cast<const Attribution*>(
               &_Attribution_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Attribution& a, Attribution& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Attribution* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Attribution* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Attribution* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Attribution>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Attribution& from);
  void MergeFrom(const Attribution& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Attribution* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.Attribution";
  }
  protected:
  explicit Attribution(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:ntp.background.Attribution)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributionFieldNumber = 4,
    kImageUrlFieldNumber = 2,
    kActionUrlFieldNumber = 3,
    kAssetIdFieldNumber = 1,
  };
  // repeated .ntp.background.Attribution attribution = 4;
  int attribution_size() const;
  private:
  int _internal_attribution_size() const;
  public:
  void clear_attribution();
  ::ntp::background::Attribution* mutable_attribution(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >*
      mutable_attribution();
  private:
  const ::ntp::background::Attribution& _internal_attribution(int index) const;
  ::ntp::background::Attribution* _internal_add_attribution();
  public:
  const ::ntp::background::Attribution& attribution(int index) const;
  ::ntp::background::Attribution* add_attribution();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >&
      attribution() const;

  // optional string image_url = 2;
  bool has_image_url() const;
  private:
  bool _internal_has_image_url() const;
  public:
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // optional string action_url = 3;
  bool has_action_url() const;
  private:
  bool _internal_has_action_url() const;
  public:
  void clear_action_url();
  const std::string& action_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_url();
  PROTOBUF_NODISCARD std::string* release_action_url();
  void set_allocated_action_url(std::string* action_url);
  private:
  const std::string& _internal_action_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_url(const std::string& value);
  std::string* _internal_mutable_action_url();
  public:

  // optional fixed64 asset_id = 1;
  bool has_asset_id() const;
  private:
  bool _internal_has_asset_id() const;
  public:
  void clear_asset_id();
  uint64_t asset_id() const;
  void set_asset_id(uint64_t value);
  private:
  uint64_t _internal_asset_id() const;
  void _internal_set_asset_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ntp.background.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution > attribution_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_url_;
  uint64_t asset_id_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class Collection final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.Collection) */ {
 public:
  inline Collection() : Collection(nullptr) {}
  ~Collection() override;
  explicit PROTOBUF_CONSTEXPR Collection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collection(const Collection& from);
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collection& operator=(Collection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Collection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Collection* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Collection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Collection& from);
  void MergeFrom(const Collection& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Collection* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.Collection";
  }
  protected:
  explicit Collection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPreviewFieldNumber = 3,
    kCollectionIdFieldNumber = 1,
    kCollectionNameFieldNumber = 2,
  };
  // repeated .ntp.background.Image preview = 3;
  int preview_size() const;
  private:
  int _internal_preview_size() const;
  public:
  void clear_preview();
  ::ntp::background::Image* mutable_preview(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
      mutable_preview();
  private:
  const ::ntp::background::Image& _internal_preview(int index) const;
  ::ntp::background::Image* _internal_add_preview();
  public:
  const ::ntp::background::Image& preview(int index) const;
  ::ntp::background::Image* add_preview();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
      preview() const;

  // optional string collection_id = 1;
  bool has_collection_id() const;
  private:
  bool _internal_has_collection_id() const;
  public:
  void clear_collection_id();
  const std::string& collection_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collection_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collection_id();
  PROTOBUF_NODISCARD std::string* release_collection_id();
  void set_allocated_collection_id(std::string* collection_id);
  private:
  const std::string& _internal_collection_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collection_id(const std::string& value);
  std::string* _internal_mutable_collection_id();
  public:

  // optional string collection_name = 2;
  bool has_collection_name() const;
  private:
  bool _internal_has_collection_name() const;
  public:
  void clear_collection_name();
  const std::string& collection_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collection_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collection_name();
  PROTOBUF_NODISCARD std::string* release_collection_name();
  void set_allocated_collection_name(std::string* collection_name);
  private:
  const std::string& _internal_collection_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collection_name(const std::string& value);
  std::string* _internal_mutable_collection_name();
  public:

  // @@protoc_insertion_point(class_scope:ntp.background.Collection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image > preview_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_name_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetCollectionsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetCollectionsRequest) */ {
 public:
  inline GetCollectionsRequest() : GetCollectionsRequest(nullptr) {}
  ~GetCollectionsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetCollectionsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCollectionsRequest(const GetCollectionsRequest& from);
  GetCollectionsRequest(GetCollectionsRequest&& from) noexcept
    : GetCollectionsRequest() {
    *this = ::std::move(from);
  }

  inline GetCollectionsRequest& operator=(const GetCollectionsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionsRequest& operator=(GetCollectionsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetCollectionsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCollectionsRequest* internal_default_instance() {
    return reinterpret_cast<const GetCollectionsRequest*>(
               &_GetCollectionsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetCollectionsRequest& a, GetCollectionsRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCollectionsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCollectionsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCollectionsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCollectionsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCollectionsRequest& from);
  void MergeFrom(const GetCollectionsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCollectionsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetCollectionsRequest";
  }
  protected:
  explicit GetCollectionsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilteringLabelFieldNumber = 3,
    kLanguageFieldNumber = 1,
    kRegionFieldNumber = 2,
  };
  // repeated string filtering_label = 3;
  int filtering_label_size() const;
  private:
  int _internal_filtering_label_size() const;
  public:
  void clear_filtering_label();
  const std::string& filtering_label(int index) const;
  std::string* mutable_filtering_label(int index);
  void set_filtering_label(int index, const std::string& value);
  void set_filtering_label(int index, std::string&& value);
  void set_filtering_label(int index, const char* value);
  void set_filtering_label(int index, const char* value, size_t size);
  std::string* add_filtering_label();
  void add_filtering_label(const std::string& value);
  void add_filtering_label(std::string&& value);
  void add_filtering_label(const char* value);
  void add_filtering_label(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& filtering_label() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_filtering_label();
  private:
  const std::string& _internal_filtering_label(int index) const;
  std::string* _internal_add_filtering_label();
  public:

  // optional string language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string region = 2;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:ntp.background.GetCollectionsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> filtering_label_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetCollectionsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetCollectionsResponse) */ {
 public:
  inline GetCollectionsResponse() : GetCollectionsResponse(nullptr) {}
  ~GetCollectionsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetCollectionsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCollectionsResponse(const GetCollectionsResponse& from);
  GetCollectionsResponse(GetCollectionsResponse&& from) noexcept
    : GetCollectionsResponse() {
    *this = ::std::move(from);
  }

  inline GetCollectionsResponse& operator=(const GetCollectionsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionsResponse& operator=(GetCollectionsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetCollectionsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCollectionsResponse* internal_default_instance() {
    return reinterpret_cast<const GetCollectionsResponse*>(
               &_GetCollectionsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetCollectionsResponse& a, GetCollectionsResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetCollectionsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCollectionsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetCollectionsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetCollectionsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetCollectionsResponse& from);
  void MergeFrom(const GetCollectionsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetCollectionsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetCollectionsResponse";
  }
  protected:
  explicit GetCollectionsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionsFieldNumber = 1,
  };
  // repeated .ntp.background.Collection collections = 1;
  int collections_size() const;
  private:
  int _internal_collections_size() const;
  public:
  void clear_collections();
  ::ntp::background::Collection* mutable_collections(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >*
      mutable_collections();
  private:
  const ::ntp::background::Collection& _internal_collections(int index) const;
  ::ntp::background::Collection* _internal_add_collections();
  public:
  const ::ntp::background::Collection& collections(int index) const;
  ::ntp::background::Collection* add_collections();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >&
      collections() const;

  // @@protoc_insertion_point(class_scope:ntp.background.GetCollectionsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection > collections_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImagesInCollectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImagesInCollectionRequest) */ {
 public:
  inline GetImagesInCollectionRequest() : GetImagesInCollectionRequest(nullptr) {}
  ~GetImagesInCollectionRequest() override;
  explicit PROTOBUF_CONSTEXPR GetImagesInCollectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetImagesInCollectionRequest(const GetImagesInCollectionRequest& from);
  GetImagesInCollectionRequest(GetImagesInCollectionRequest&& from) noexcept
    : GetImagesInCollectionRequest() {
    *this = ::std::move(from);
  }

  inline GetImagesInCollectionRequest& operator=(const GetImagesInCollectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImagesInCollectionRequest& operator=(GetImagesInCollectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetImagesInCollectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetImagesInCollectionRequest* internal_default_instance() {
    return reinterpret_cast<const GetImagesInCollectionRequest*>(
               &_GetImagesInCollectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetImagesInCollectionRequest& a, GetImagesInCollectionRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetImagesInCollectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImagesInCollectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetImagesInCollectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetImagesInCollectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetImagesInCollectionRequest& from);
  void MergeFrom(const GetImagesInCollectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImagesInCollectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImagesInCollectionRequest";
  }
  protected:
  explicit GetImagesInCollectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionIdFieldNumber = 1,
    kLanguageFieldNumber = 2,
    kRegionFieldNumber = 3,
  };
  // optional string collection_id = 1;
  bool has_collection_id() const;
  private:
  bool _internal_has_collection_id() const;
  public:
  void clear_collection_id();
  const std::string& collection_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collection_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collection_id();
  PROTOBUF_NODISCARD std::string* release_collection_id();
  void set_allocated_collection_id(std::string* collection_id);
  private:
  const std::string& _internal_collection_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collection_id(const std::string& value);
  std::string* _internal_mutable_collection_id();
  public:

  // optional string language = 2;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string region = 3;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // @@protoc_insertion_point(class_scope:ntp.background.GetImagesInCollectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImagesInCollectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImagesInCollectionResponse) */ {
 public:
  inline GetImagesInCollectionResponse() : GetImagesInCollectionResponse(nullptr) {}
  ~GetImagesInCollectionResponse() override;
  explicit PROTOBUF_CONSTEXPR GetImagesInCollectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetImagesInCollectionResponse(const GetImagesInCollectionResponse& from);
  GetImagesInCollectionResponse(GetImagesInCollectionResponse&& from) noexcept
    : GetImagesInCollectionResponse() {
    *this = ::std::move(from);
  }

  inline GetImagesInCollectionResponse& operator=(const GetImagesInCollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImagesInCollectionResponse& operator=(GetImagesInCollectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetImagesInCollectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetImagesInCollectionResponse* internal_default_instance() {
    return reinterpret_cast<const GetImagesInCollectionResponse*>(
               &_GetImagesInCollectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetImagesInCollectionResponse& a, GetImagesInCollectionResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetImagesInCollectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImagesInCollectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetImagesInCollectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetImagesInCollectionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetImagesInCollectionResponse& from);
  void MergeFrom(const GetImagesInCollectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImagesInCollectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImagesInCollectionResponse";
  }
  protected:
  explicit GetImagesInCollectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 1,
  };
  // repeated .ntp.background.Image images = 1;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::ntp::background::Image* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
      mutable_images();
  private:
  const ::ntp::background::Image& _internal_images(int index) const;
  ::ntp::background::Image* _internal_add_images();
  public:
  const ::ntp::background::Image& images(int index) const;
  ::ntp::background::Image* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
      images() const;

  // @@protoc_insertion_point(class_scope:ntp.background.GetImagesInCollectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image > images_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImageFromCollectionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImageFromCollectionRequest) */ {
 public:
  inline GetImageFromCollectionRequest() : GetImageFromCollectionRequest(nullptr) {}
  ~GetImageFromCollectionRequest() override;
  explicit PROTOBUF_CONSTEXPR GetImageFromCollectionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetImageFromCollectionRequest(const GetImageFromCollectionRequest& from);
  GetImageFromCollectionRequest(GetImageFromCollectionRequest&& from) noexcept
    : GetImageFromCollectionRequest() {
    *this = ::std::move(from);
  }

  inline GetImageFromCollectionRequest& operator=(const GetImageFromCollectionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageFromCollectionRequest& operator=(GetImageFromCollectionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetImageFromCollectionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetImageFromCollectionRequest* internal_default_instance() {
    return reinterpret_cast<const GetImageFromCollectionRequest*>(
               &_GetImageFromCollectionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetImageFromCollectionRequest& a, GetImageFromCollectionRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetImageFromCollectionRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImageFromCollectionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetImageFromCollectionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetImageFromCollectionRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetImageFromCollectionRequest& from);
  void MergeFrom(const GetImageFromCollectionRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImageFromCollectionRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImageFromCollectionRequest";
  }
  protected:
  explicit GetImageFromCollectionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionIdsFieldNumber = 1,
    kResumeTokenFieldNumber = 2,
    kLanguageFieldNumber = 3,
  };
  // repeated string collection_ids = 1;
  int collection_ids_size() const;
  private:
  int _internal_collection_ids_size() const;
  public:
  void clear_collection_ids();
  const std::string& collection_ids(int index) const;
  std::string* mutable_collection_ids(int index);
  void set_collection_ids(int index, const std::string& value);
  void set_collection_ids(int index, std::string&& value);
  void set_collection_ids(int index, const char* value);
  void set_collection_ids(int index, const char* value, size_t size);
  std::string* add_collection_ids();
  void add_collection_ids(const std::string& value);
  void add_collection_ids(std::string&& value);
  void add_collection_ids(const char* value);
  void add_collection_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& collection_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_collection_ids();
  private:
  const std::string& _internal_collection_ids(int index) const;
  std::string* _internal_add_collection_ids();
  public:

  // optional string resume_token = 2;
  bool has_resume_token() const;
  private:
  bool _internal_has_resume_token() const;
  public:
  void clear_resume_token();
  const std::string& resume_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resume_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resume_token();
  PROTOBUF_NODISCARD std::string* release_resume_token();
  void set_allocated_resume_token(std::string* resume_token);
  private:
  const std::string& _internal_resume_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_token(const std::string& value);
  std::string* _internal_mutable_resume_token();
  public:

  // optional string language = 3;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // @@protoc_insertion_point(class_scope:ntp.background.GetImageFromCollectionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> collection_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// -------------------------------------------------------------------

class GetImageFromCollectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:ntp.background.GetImageFromCollectionResponse) */ {
 public:
  inline GetImageFromCollectionResponse() : GetImageFromCollectionResponse(nullptr) {}
  ~GetImageFromCollectionResponse() override;
  explicit PROTOBUF_CONSTEXPR GetImageFromCollectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetImageFromCollectionResponse(const GetImageFromCollectionResponse& from);
  GetImageFromCollectionResponse(GetImageFromCollectionResponse&& from) noexcept
    : GetImageFromCollectionResponse() {
    *this = ::std::move(from);
  }

  inline GetImageFromCollectionResponse& operator=(const GetImageFromCollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetImageFromCollectionResponse& operator=(GetImageFromCollectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetImageFromCollectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetImageFromCollectionResponse* internal_default_instance() {
    return reinterpret_cast<const GetImageFromCollectionResponse*>(
               &_GetImageFromCollectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetImageFromCollectionResponse& a, GetImageFromCollectionResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetImageFromCollectionResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetImageFromCollectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetImageFromCollectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetImageFromCollectionResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetImageFromCollectionResponse& from);
  void MergeFrom(const GetImageFromCollectionResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetImageFromCollectionResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ntp.background.GetImageFromCollectionResponse";
  }
  protected:
  explicit GetImageFromCollectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResumeTokenFieldNumber = 2,
    kImageFieldNumber = 1,
  };
  // optional string resume_token = 2;
  bool has_resume_token() const;
  private:
  bool _internal_has_resume_token() const;
  public:
  void clear_resume_token();
  const std::string& resume_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_resume_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_resume_token();
  PROTOBUF_NODISCARD std::string* release_resume_token();
  void set_allocated_resume_token(std::string* resume_token);
  private:
  const std::string& _internal_resume_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_resume_token(const std::string& value);
  std::string* _internal_mutable_resume_token();
  public:

  // optional .ntp.background.Image image = 1;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::ntp::background::Image& image() const;
  PROTOBUF_NODISCARD ::ntp::background::Image* release_image();
  ::ntp::background::Image* mutable_image();
  void set_allocated_image(::ntp::background::Image* image);
  private:
  const ::ntp::background::Image& _internal_image() const;
  ::ntp::background::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::ntp::background::Image* image);
  ::ntp::background::Image* unsafe_arena_release_image();

  // @@protoc_insertion_point(class_scope:ntp.background.GetImageFromCollectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resume_token_;
  ::ntp::background::Image* image_;
  friend struct ::TableStruct_ntp_5fbackground_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Attribution

// optional string text = 1;
inline bool Attribution::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Attribution::has_text() const {
  return _internal_has_text();
}
inline void Attribution::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Attribution::text() const {
  // @@protoc_insertion_point(field_get:ntp.background.Attribution.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Attribution::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.Attribution.text)
}
inline std::string* Attribution::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:ntp.background.Attribution.text)
  return _s;
}
inline const std::string& Attribution::_internal_text() const {
  return text_.Get();
}
inline void Attribution::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(value, GetArenaForAllocation());
}
inline std::string* Attribution::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(GetArenaForAllocation());
}
inline std::string* Attribution::release_text() {
  // @@protoc_insertion_point(field_release:ntp.background.Attribution.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Attribution::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault()) {
    text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Attribution.text)
}

// -------------------------------------------------------------------

// Image

// optional fixed64 asset_id = 1;
inline bool Image::_internal_has_asset_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Image::has_asset_id() const {
  return _internal_has_asset_id();
}
inline void Image::clear_asset_id() {
  asset_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t Image::_internal_asset_id() const {
  return asset_id_;
}
inline uint64_t Image::asset_id() const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.asset_id)
  return _internal_asset_id();
}
inline void Image::_internal_set_asset_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  asset_id_ = value;
}
inline void Image::set_asset_id(uint64_t value) {
  _internal_set_asset_id(value);
  // @@protoc_insertion_point(field_set:ntp.background.Image.asset_id)
}

// optional string image_url = 2;
inline bool Image::_internal_has_image_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Image::has_image_url() const {
  return _internal_has_image_url();
}
inline void Image::clear_image_url() {
  image_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Image::image_url() const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_image_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 image_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.Image.image_url)
}
inline std::string* Image::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:ntp.background.Image.image_url)
  return _s;
}
inline const std::string& Image::_internal_image_url() const {
  return image_url_.Get();
}
inline void Image::_internal_set_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_image_url() {
  _has_bits_[0] |= 0x00000001u;
  return image_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_image_url() {
  // @@protoc_insertion_point(field_release:ntp.background.Image.image_url)
  if (!_internal_has_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = image_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault()) {
    image_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_url_.SetAllocated(image_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault()) {
    image_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Image.image_url)
}

// optional string action_url = 3;
inline bool Image::_internal_has_action_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Image::has_action_url() const {
  return _internal_has_action_url();
}
inline void Image::clear_action_url() {
  action_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Image::action_url() const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.action_url)
  return _internal_action_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_action_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 action_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.Image.action_url)
}
inline std::string* Image::mutable_action_url() {
  std::string* _s = _internal_mutable_action_url();
  // @@protoc_insertion_point(field_mutable:ntp.background.Image.action_url)
  return _s;
}
inline const std::string& Image::_internal_action_url() const {
  return action_url_.Get();
}
inline void Image::_internal_set_action_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  action_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_action_url() {
  _has_bits_[0] |= 0x00000002u;
  return action_url_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_action_url() {
  // @@protoc_insertion_point(field_release:ntp.background.Image.action_url)
  if (!_internal_has_action_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = action_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_url_.IsDefault()) {
    action_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Image::set_allocated_action_url(std::string* action_url) {
  if (action_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  action_url_.SetAllocated(action_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_url_.IsDefault()) {
    action_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Image.action_url)
}

// repeated .ntp.background.Attribution attribution = 4;
inline int Image::_internal_attribution_size() const {
  return attribution_.size();
}
inline int Image::attribution_size() const {
  return _internal_attribution_size();
}
inline void Image::clear_attribution() {
  attribution_.Clear();
}
inline ::ntp::background::Attribution* Image::mutable_attribution(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.Image.attribution)
  return attribution_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >*
Image::mutable_attribution() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.Image.attribution)
  return &attribution_;
}
inline const ::ntp::background::Attribution& Image::_internal_attribution(int index) const {
  return attribution_.Get(index);
}
inline const ::ntp::background::Attribution& Image::attribution(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.Image.attribution)
  return _internal_attribution(index);
}
inline ::ntp::background::Attribution* Image::_internal_add_attribution() {
  return attribution_.Add();
}
inline ::ntp::background::Attribution* Image::add_attribution() {
  ::ntp::background::Attribution* _add = _internal_add_attribution();
  // @@protoc_insertion_point(field_add:ntp.background.Image.attribution)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Attribution >&
Image::attribution() const {
  // @@protoc_insertion_point(field_list:ntp.background.Image.attribution)
  return attribution_;
}

// -------------------------------------------------------------------

// Collection

// optional string collection_id = 1;
inline bool Collection::_internal_has_collection_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Collection::has_collection_id() const {
  return _internal_has_collection_id();
}
inline void Collection::clear_collection_id() {
  collection_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Collection::collection_id() const {
  // @@protoc_insertion_point(field_get:ntp.background.Collection.collection_id)
  return _internal_collection_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collection::set_collection_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 collection_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.Collection.collection_id)
}
inline std::string* Collection::mutable_collection_id() {
  std::string* _s = _internal_mutable_collection_id();
  // @@protoc_insertion_point(field_mutable:ntp.background.Collection.collection_id)
  return _s;
}
inline const std::string& Collection::_internal_collection_id() const {
  return collection_id_.Get();
}
inline void Collection::_internal_set_collection_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Collection::_internal_mutable_collection_id() {
  _has_bits_[0] |= 0x00000001u;
  return collection_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Collection::release_collection_id() {
  // @@protoc_insertion_point(field_release:ntp.background.Collection.collection_id)
  if (!_internal_has_collection_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = collection_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collection_id_.IsDefault()) {
    collection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Collection::set_allocated_collection_id(std::string* collection_id) {
  if (collection_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_id_.SetAllocated(collection_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collection_id_.IsDefault()) {
    collection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Collection.collection_id)
}

// optional string collection_name = 2;
inline bool Collection::_internal_has_collection_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Collection::has_collection_name() const {
  return _internal_has_collection_name();
}
inline void Collection::clear_collection_name() {
  collection_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Collection::collection_name() const {
  // @@protoc_insertion_point(field_get:ntp.background.Collection.collection_name)
  return _internal_collection_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collection::set_collection_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 collection_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.Collection.collection_name)
}
inline std::string* Collection::mutable_collection_name() {
  std::string* _s = _internal_mutable_collection_name();
  // @@protoc_insertion_point(field_mutable:ntp.background.Collection.collection_name)
  return _s;
}
inline const std::string& Collection::_internal_collection_name() const {
  return collection_name_.Get();
}
inline void Collection::_internal_set_collection_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  collection_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Collection::_internal_mutable_collection_name() {
  _has_bits_[0] |= 0x00000002u;
  return collection_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Collection::release_collection_name() {
  // @@protoc_insertion_point(field_release:ntp.background.Collection.collection_name)
  if (!_internal_has_collection_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = collection_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collection_name_.IsDefault()) {
    collection_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Collection::set_allocated_collection_name(std::string* collection_name) {
  if (collection_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  collection_name_.SetAllocated(collection_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collection_name_.IsDefault()) {
    collection_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.Collection.collection_name)
}

// repeated .ntp.background.Image preview = 3;
inline int Collection::_internal_preview_size() const {
  return preview_.size();
}
inline int Collection::preview_size() const {
  return _internal_preview_size();
}
inline void Collection::clear_preview() {
  preview_.Clear();
}
inline ::ntp::background::Image* Collection::mutable_preview(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.Collection.preview)
  return preview_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
Collection::mutable_preview() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.Collection.preview)
  return &preview_;
}
inline const ::ntp::background::Image& Collection::_internal_preview(int index) const {
  return preview_.Get(index);
}
inline const ::ntp::background::Image& Collection::preview(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.Collection.preview)
  return _internal_preview(index);
}
inline ::ntp::background::Image* Collection::_internal_add_preview() {
  return preview_.Add();
}
inline ::ntp::background::Image* Collection::add_preview() {
  ::ntp::background::Image* _add = _internal_add_preview();
  // @@protoc_insertion_point(field_add:ntp.background.Collection.preview)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
Collection::preview() const {
  // @@protoc_insertion_point(field_list:ntp.background.Collection.preview)
  return preview_;
}

// -------------------------------------------------------------------

// GetCollectionsRequest

// optional string language = 1;
inline bool GetCollectionsRequest::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetCollectionsRequest::has_language() const {
  return _internal_has_language();
}
inline void GetCollectionsRequest::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetCollectionsRequest::language() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsRequest.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCollectionsRequest::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetCollectionsRequest.language)
}
inline std::string* GetCollectionsRequest::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsRequest.language)
  return _s;
}
inline const std::string& GetCollectionsRequest::_internal_language() const {
  return language_.Get();
}
inline void GetCollectionsRequest::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  language_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCollectionsRequest::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000001u;
  return language_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCollectionsRequest::release_language() {
  // @@protoc_insertion_point(field_release:ntp.background.GetCollectionsRequest.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetCollectionsRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetCollectionsRequest.language)
}

// optional string region = 2;
inline bool GetCollectionsRequest::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetCollectionsRequest::has_region() const {
  return _internal_has_region();
}
inline void GetCollectionsRequest::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetCollectionsRequest::region() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCollectionsRequest::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetCollectionsRequest.region)
}
inline std::string* GetCollectionsRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsRequest.region)
  return _s;
}
inline const std::string& GetCollectionsRequest::_internal_region() const {
  return region_.Get();
}
inline void GetCollectionsRequest::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* GetCollectionsRequest::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000002u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* GetCollectionsRequest::release_region() {
  // @@protoc_insertion_point(field_release:ntp.background.GetCollectionsRequest.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetCollectionsRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetCollectionsRequest.region)
}

// repeated string filtering_label = 3;
inline int GetCollectionsRequest::_internal_filtering_label_size() const {
  return filtering_label_.size();
}
inline int GetCollectionsRequest::filtering_label_size() const {
  return _internal_filtering_label_size();
}
inline void GetCollectionsRequest::clear_filtering_label() {
  filtering_label_.Clear();
}
inline std::string* GetCollectionsRequest::add_filtering_label() {
  std::string* _s = _internal_add_filtering_label();
  // @@protoc_insertion_point(field_add_mutable:ntp.background.GetCollectionsRequest.filtering_label)
  return _s;
}
inline const std::string& GetCollectionsRequest::_internal_filtering_label(int index) const {
  return filtering_label_.Get(index);
}
inline const std::string& GetCollectionsRequest::filtering_label(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsRequest.filtering_label)
  return _internal_filtering_label(index);
}
inline std::string* GetCollectionsRequest::mutable_filtering_label(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsRequest.filtering_label)
  return filtering_label_.Mutable(index);
}
inline void GetCollectionsRequest::set_filtering_label(int index, const std::string& value) {
  filtering_label_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ntp.background.GetCollectionsRequest.filtering_label)
}
inline void GetCollectionsRequest::set_filtering_label(int index, std::string&& value) {
  filtering_label_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ntp.background.GetCollectionsRequest.filtering_label)
}
inline void GetCollectionsRequest::set_filtering_label(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filtering_label_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ntp.background.GetCollectionsRequest.filtering_label)
}
inline void GetCollectionsRequest::set_filtering_label(int index, const char* value, size_t size) {
  filtering_label_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetCollectionsRequest.filtering_label)
}
inline std::string* GetCollectionsRequest::_internal_add_filtering_label() {
  return filtering_label_.Add();
}
inline void GetCollectionsRequest::add_filtering_label(const std::string& value) {
  filtering_label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ntp.background.GetCollectionsRequest.filtering_label)
}
inline void GetCollectionsRequest::add_filtering_label(std::string&& value) {
  filtering_label_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ntp.background.GetCollectionsRequest.filtering_label)
}
inline void GetCollectionsRequest::add_filtering_label(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  filtering_label_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ntp.background.GetCollectionsRequest.filtering_label)
}
inline void GetCollectionsRequest::add_filtering_label(const char* value, size_t size) {
  filtering_label_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ntp.background.GetCollectionsRequest.filtering_label)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetCollectionsRequest::filtering_label() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetCollectionsRequest.filtering_label)
  return filtering_label_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetCollectionsRequest::mutable_filtering_label() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetCollectionsRequest.filtering_label)
  return &filtering_label_;
}

// -------------------------------------------------------------------

// GetCollectionsResponse

// repeated .ntp.background.Collection collections = 1;
inline int GetCollectionsResponse::_internal_collections_size() const {
  return collections_.size();
}
inline int GetCollectionsResponse::collections_size() const {
  return _internal_collections_size();
}
inline void GetCollectionsResponse::clear_collections() {
  collections_.Clear();
}
inline ::ntp::background::Collection* GetCollectionsResponse::mutable_collections(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetCollectionsResponse.collections)
  return collections_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >*
GetCollectionsResponse::mutable_collections() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetCollectionsResponse.collections)
  return &collections_;
}
inline const ::ntp::background::Collection& GetCollectionsResponse::_internal_collections(int index) const {
  return collections_.Get(index);
}
inline const ::ntp::background::Collection& GetCollectionsResponse::collections(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetCollectionsResponse.collections)
  return _internal_collections(index);
}
inline ::ntp::background::Collection* GetCollectionsResponse::_internal_add_collections() {
  return collections_.Add();
}
inline ::ntp::background::Collection* GetCollectionsResponse::add_collections() {
  ::ntp::background::Collection* _add = _internal_add_collections();
  // @@protoc_insertion_point(field_add:ntp.background.GetCollectionsResponse.collections)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Collection >&
GetCollectionsResponse::collections() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetCollectionsResponse.collections)
  return collections_;
}

// -------------------------------------------------------------------

// GetImagesInCollectionRequest

// optional string collection_id = 1;
inline bool GetImagesInCollectionRequest::_internal_has_collection_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetImagesInCollectionRequest::has_collection_id() const {
  return _internal_has_collection_id();
}
inline void GetImagesInCollectionRequest::clear_collection_id() {
  collection_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetImagesInCollectionRequest::collection_id() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionRequest.collection_id)
  return _internal_collection_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetImagesInCollectionRequest::set_collection_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 collection_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetImagesInCollectionRequest.collection_id)
}
inline std::string* GetImagesInCollectionRequest::mutable_collection_id() {
  std::string* _s = _internal_mutable_collection_id();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionRequest.collection_id)
  return _s;
}
inline const std::string& GetImagesInCollectionRequest::_internal_collection_id() const {
  return collection_id_.Get();
}
inline void GetImagesInCollectionRequest::_internal_set_collection_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  collection_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GetImagesInCollectionRequest::_internal_mutable_collection_id() {
  _has_bits_[0] |= 0x00000001u;
  return collection_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GetImagesInCollectionRequest::release_collection_id() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImagesInCollectionRequest.collection_id)
  if (!_internal_has_collection_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = collection_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collection_id_.IsDefault()) {
    collection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetImagesInCollectionRequest::set_allocated_collection_id(std::string* collection_id) {
  if (collection_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  collection_id_.SetAllocated(collection_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (collection_id_.IsDefault()) {
    collection_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImagesInCollectionRequest.collection_id)
}

// optional string language = 2;
inline bool GetImagesInCollectionRequest::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetImagesInCollectionRequest::has_language() const {
  return _internal_has_language();
}
inline void GetImagesInCollectionRequest::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetImagesInCollectionRequest::language() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionRequest.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetImagesInCollectionRequest::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetImagesInCollectionRequest.language)
}
inline std::string* GetImagesInCollectionRequest::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionRequest.language)
  return _s;
}
inline const std::string& GetImagesInCollectionRequest::_internal_language() const {
  return language_.Get();
}
inline void GetImagesInCollectionRequest::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.Set(value, GetArenaForAllocation());
}
inline std::string* GetImagesInCollectionRequest::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  return language_.Mutable(GetArenaForAllocation());
}
inline std::string* GetImagesInCollectionRequest::release_language() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImagesInCollectionRequest.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetImagesInCollectionRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImagesInCollectionRequest.language)
}

// optional string region = 3;
inline bool GetImagesInCollectionRequest::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetImagesInCollectionRequest::has_region() const {
  return _internal_has_region();
}
inline void GetImagesInCollectionRequest::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetImagesInCollectionRequest::region() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionRequest.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetImagesInCollectionRequest::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 region_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetImagesInCollectionRequest.region)
}
inline std::string* GetImagesInCollectionRequest::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionRequest.region)
  return _s;
}
inline const std::string& GetImagesInCollectionRequest::_internal_region() const {
  return region_.Get();
}
inline void GetImagesInCollectionRequest::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  region_.Set(value, GetArenaForAllocation());
}
inline std::string* GetImagesInCollectionRequest::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000004u;
  return region_.Mutable(GetArenaForAllocation());
}
inline std::string* GetImagesInCollectionRequest::release_region() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImagesInCollectionRequest.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = region_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetImagesInCollectionRequest::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  region_.SetAllocated(region, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault()) {
    region_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImagesInCollectionRequest.region)
}

// -------------------------------------------------------------------

// GetImagesInCollectionResponse

// repeated .ntp.background.Image images = 1;
inline int GetImagesInCollectionResponse::_internal_images_size() const {
  return images_.size();
}
inline int GetImagesInCollectionResponse::images_size() const {
  return _internal_images_size();
}
inline void GetImagesInCollectionResponse::clear_images() {
  images_.Clear();
}
inline ::ntp::background::Image* GetImagesInCollectionResponse::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImagesInCollectionResponse.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >*
GetImagesInCollectionResponse::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetImagesInCollectionResponse.images)
  return &images_;
}
inline const ::ntp::background::Image& GetImagesInCollectionResponse::_internal_images(int index) const {
  return images_.Get(index);
}
inline const ::ntp::background::Image& GetImagesInCollectionResponse::images(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImagesInCollectionResponse.images)
  return _internal_images(index);
}
inline ::ntp::background::Image* GetImagesInCollectionResponse::_internal_add_images() {
  return images_.Add();
}
inline ::ntp::background::Image* GetImagesInCollectionResponse::add_images() {
  ::ntp::background::Image* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:ntp.background.GetImagesInCollectionResponse.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ntp::background::Image >&
GetImagesInCollectionResponse::images() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetImagesInCollectionResponse.images)
  return images_;
}

// -------------------------------------------------------------------

// GetImageFromCollectionRequest

// repeated string collection_ids = 1;
inline int GetImageFromCollectionRequest::_internal_collection_ids_size() const {
  return collection_ids_.size();
}
inline int GetImageFromCollectionRequest::collection_ids_size() const {
  return _internal_collection_ids_size();
}
inline void GetImageFromCollectionRequest::clear_collection_ids() {
  collection_ids_.Clear();
}
inline std::string* GetImageFromCollectionRequest::add_collection_ids() {
  std::string* _s = _internal_add_collection_ids();
  // @@protoc_insertion_point(field_add_mutable:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return _s;
}
inline const std::string& GetImageFromCollectionRequest::_internal_collection_ids(int index) const {
  return collection_ids_.Get(index);
}
inline const std::string& GetImageFromCollectionRequest::collection_ids(int index) const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return _internal_collection_ids(index);
}
inline std::string* GetImageFromCollectionRequest::mutable_collection_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return collection_ids_.Mutable(index);
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, const std::string& value) {
  collection_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, std::string&& value) {
  collection_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  collection_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::set_collection_ids(int index, const char* value, size_t size) {
  collection_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline std::string* GetImageFromCollectionRequest::_internal_add_collection_ids() {
  return collection_ids_.Add();
}
inline void GetImageFromCollectionRequest::add_collection_ids(const std::string& value) {
  collection_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::add_collection_ids(std::string&& value) {
  collection_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::add_collection_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  collection_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline void GetImageFromCollectionRequest::add_collection_ids(const char* value, size_t size) {
  collection_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ntp.background.GetImageFromCollectionRequest.collection_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetImageFromCollectionRequest::collection_ids() const {
  // @@protoc_insertion_point(field_list:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return collection_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetImageFromCollectionRequest::mutable_collection_ids() {
  // @@protoc_insertion_point(field_mutable_list:ntp.background.GetImageFromCollectionRequest.collection_ids)
  return &collection_ids_;
}

// optional string resume_token = 2;
inline bool GetImageFromCollectionRequest::_internal_has_resume_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetImageFromCollectionRequest::has_resume_token() const {
  return _internal_has_resume_token();
}
inline void GetImageFromCollectionRequest::clear_resume_token() {
  resume_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetImageFromCollectionRequest::resume_token() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionRequest.resume_token)
  return _internal_resume_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetImageFromCollectionRequest::set_resume_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 resume_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.resume_token)
}
inline std::string* GetImageFromCollectionRequest::mutable_resume_token() {
  std::string* _s = _internal_mutable_resume_token();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionRequest.resume_token)
  return _s;
}
inline const std::string& GetImageFromCollectionRequest::_internal_resume_token() const {
  return resume_token_.Get();
}
inline void GetImageFromCollectionRequest::_internal_set_resume_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetImageFromCollectionRequest::_internal_mutable_resume_token() {
  _has_bits_[0] |= 0x00000001u;
  return resume_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetImageFromCollectionRequest::release_resume_token() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionRequest.resume_token)
  if (!_internal_has_resume_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = resume_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resume_token_.IsDefault()) {
    resume_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetImageFromCollectionRequest::set_allocated_resume_token(std::string* resume_token) {
  if (resume_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resume_token_.SetAllocated(resume_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resume_token_.IsDefault()) {
    resume_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionRequest.resume_token)
}

// optional string language = 3;
inline bool GetImageFromCollectionRequest::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetImageFromCollectionRequest::has_language() const {
  return _internal_has_language();
}
inline void GetImageFromCollectionRequest::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetImageFromCollectionRequest::language() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionRequest.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetImageFromCollectionRequest::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionRequest.language)
}
inline std::string* GetImageFromCollectionRequest::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionRequest.language)
  return _s;
}
inline const std::string& GetImageFromCollectionRequest::_internal_language() const {
  return language_.Get();
}
inline void GetImageFromCollectionRequest::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.Set(value, GetArenaForAllocation());
}
inline std::string* GetImageFromCollectionRequest::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  return language_.Mutable(GetArenaForAllocation());
}
inline std::string* GetImageFromCollectionRequest::release_language() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionRequest.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetImageFromCollectionRequest::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocated(language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault()) {
    language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionRequest.language)
}

// -------------------------------------------------------------------

// GetImageFromCollectionResponse

// optional .ntp.background.Image image = 1;
inline bool GetImageFromCollectionResponse::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || image_ != nullptr);
  return value;
}
inline bool GetImageFromCollectionResponse::has_image() const {
  return _internal_has_image();
}
inline void GetImageFromCollectionResponse::clear_image() {
  if (image_ != nullptr) image_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ntp::background::Image& GetImageFromCollectionResponse::_internal_image() const {
  const ::ntp::background::Image* p = image_;
  return p != nullptr ? *p : reinterpret_cast<const ::ntp::background::Image&>(
      ::ntp::background::_Image_default_instance_);
}
inline const ::ntp::background::Image& GetImageFromCollectionResponse::image() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionResponse.image)
  return _internal_image();
}
inline void GetImageFromCollectionResponse::unsafe_arena_set_allocated_image(
    ::ntp::background::Image* image) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(image_);
  }
  image_ = image;
  if (image) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ntp.background.GetImageFromCollectionResponse.image)
}
inline ::ntp::background::Image* GetImageFromCollectionResponse::release_image() {
  _has_bits_[0] &= ~0x00000002u;
  ::ntp::background::Image* temp = image_;
  image_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ntp::background::Image* GetImageFromCollectionResponse::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionResponse.image)
  _has_bits_[0] &= ~0x00000002u;
  ::ntp::background::Image* temp = image_;
  image_ = nullptr;
  return temp;
}
inline ::ntp::background::Image* GetImageFromCollectionResponse::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000002u;
  if (image_ == nullptr) {
    auto* p = CreateMaybeMessage<::ntp::background::Image>(GetArenaForAllocation());
    image_ = p;
  }
  return image_;
}
inline ::ntp::background::Image* GetImageFromCollectionResponse::mutable_image() {
  ::ntp::background::Image* _msg = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionResponse.image)
  return _msg;
}
inline void GetImageFromCollectionResponse::set_allocated_image(::ntp::background::Image* image) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete image_;
  }
  if (image) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(image);
    if (message_arena != submessage_arena) {
      image = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, image, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_ = image;
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionResponse.image)
}

// optional string resume_token = 2;
inline bool GetImageFromCollectionResponse::_internal_has_resume_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetImageFromCollectionResponse::has_resume_token() const {
  return _internal_has_resume_token();
}
inline void GetImageFromCollectionResponse::clear_resume_token() {
  resume_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetImageFromCollectionResponse::resume_token() const {
  // @@protoc_insertion_point(field_get:ntp.background.GetImageFromCollectionResponse.resume_token)
  return _internal_resume_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetImageFromCollectionResponse::set_resume_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 resume_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ntp.background.GetImageFromCollectionResponse.resume_token)
}
inline std::string* GetImageFromCollectionResponse::mutable_resume_token() {
  std::string* _s = _internal_mutable_resume_token();
  // @@protoc_insertion_point(field_mutable:ntp.background.GetImageFromCollectionResponse.resume_token)
  return _s;
}
inline const std::string& GetImageFromCollectionResponse::_internal_resume_token() const {
  return resume_token_.Get();
}
inline void GetImageFromCollectionResponse::_internal_set_resume_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  resume_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GetImageFromCollectionResponse::_internal_mutable_resume_token() {
  _has_bits_[0] |= 0x00000001u;
  return resume_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GetImageFromCollectionResponse::release_resume_token() {
  // @@protoc_insertion_point(field_release:ntp.background.GetImageFromCollectionResponse.resume_token)
  if (!_internal_has_resume_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = resume_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resume_token_.IsDefault()) {
    resume_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetImageFromCollectionResponse::set_allocated_resume_token(std::string* resume_token) {
  if (resume_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  resume_token_.SetAllocated(resume_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (resume_token_.IsDefault()) {
    resume_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ntp.background.GetImageFromCollectionResponse.resume_token)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace background
}  // namespace ntp

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ntp_5fbackground_2eproto
