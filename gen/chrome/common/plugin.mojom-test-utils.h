// chrome/common/plugin.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef CHROME_COMMON_PLUGIN_MOJOM_TEST_UTILS_H_
#define CHROME_COMMON_PLUGIN_MOJOM_TEST_UTILS_H_

#include "chrome/common/plugin.mojom.h"


namespace chrome {
namespace mojom {


class  PluginHostInterceptorForTesting : public PluginHost {
  virtual PluginHost* GetForwardingInterface() = 0;
  void OpenPDF(const ::GURL& url) override;
};
class  PluginHostAsyncWaiter {
 public:
  explicit PluginHostAsyncWaiter(PluginHost* proxy);

  PluginHostAsyncWaiter(const PluginHostAsyncWaiter&) = delete;
  PluginHostAsyncWaiter& operator=(const PluginHostAsyncWaiter&) = delete;

  ~PluginHostAsyncWaiter();

 private:
  PluginHost* const proxy_;
};


class  PluginAuthHostInterceptorForTesting : public PluginAuthHost {
  virtual PluginAuthHost* GetForwardingInterface() = 0;
  void BlockedUnauthorizedPlugin(const ::std::u16string& name, const std::string& group_id) override;
};
class  PluginAuthHostAsyncWaiter {
 public:
  explicit PluginAuthHostAsyncWaiter(PluginAuthHost* proxy);

  PluginAuthHostAsyncWaiter(const PluginAuthHostAsyncWaiter&) = delete;
  PluginAuthHostAsyncWaiter& operator=(const PluginAuthHostAsyncWaiter&) = delete;

  ~PluginAuthHostAsyncWaiter();

 private:
  PluginAuthHost* const proxy_;
};


class  PluginInfoHostInterceptorForTesting : public PluginInfoHost {
  virtual PluginInfoHost* GetForwardingInterface() = 0;
  void GetPluginInfo(const ::GURL& url, const ::url::Origin& origin, const std::string& mime_type, GetPluginInfoCallback callback) override;
};
class  PluginInfoHostAsyncWaiter {
 public:
  explicit PluginInfoHostAsyncWaiter(PluginInfoHost* proxy);

  PluginInfoHostAsyncWaiter(const PluginInfoHostAsyncWaiter&) = delete;
  PluginInfoHostAsyncWaiter& operator=(const PluginInfoHostAsyncWaiter&) = delete;

  ~PluginInfoHostAsyncWaiter();
  void GetPluginInfo(
      const ::GURL& url, const ::url::Origin& origin, const std::string& mime_type, PluginInfoPtr* out_plugin_info);

 private:
  PluginInfoHost* const proxy_;
};


class  PluginRendererInterceptorForTesting : public PluginRenderer {
  virtual PluginRenderer* GetForwardingInterface() = 0;
  void FinishedDownloading() override;
  void UpdateSuccess() override;
  void UpdateFailure() override;
  void UpdateDownloading() override;
};
class  PluginRendererAsyncWaiter {
 public:
  explicit PluginRendererAsyncWaiter(PluginRenderer* proxy);

  PluginRendererAsyncWaiter(const PluginRendererAsyncWaiter&) = delete;
  PluginRendererAsyncWaiter& operator=(const PluginRendererAsyncWaiter&) = delete;

  ~PluginRendererAsyncWaiter();

 private:
  PluginRenderer* const proxy_;
};




}  // namespace mojom
}  // namespace chrome

#endif  // CHROME_COMMON_PLUGIN_MOJOM_TEST_UTILS_H_