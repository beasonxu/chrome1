// device/vr/public/mojom/browser_test_interfaces.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef DEVICE_VR_PUBLIC_MOJOM_BROWSER_TEST_INTERFACES_MOJOM_SHARED_H_
#define DEVICE_VR_PUBLIC_MOJOM_BROWSER_TEST_INTERFACES_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "device/vr/public/mojom/browser_test_interfaces.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/transform.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace device_test {
namespace mojom {
class ColorDataView;

class ViewDataDataView;

class PoseFrameDataDataView;

class ProjectionRawDataView;

class DeviceConfigDataView;

class ControllerAxisDataDataView;

class ControllerFrameDataDataView;

class EventDataDataView;



}  // namespace mojom
}  // namespace device_test

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::device_test::mojom::ColorDataView> {
  using Data = ::device_test::mojom::internal::Color_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::ViewDataDataView> {
  using Data = ::device_test::mojom::internal::ViewData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::PoseFrameDataDataView> {
  using Data = ::device_test::mojom::internal::PoseFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::ProjectionRawDataView> {
  using Data = ::device_test::mojom::internal::ProjectionRaw_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::DeviceConfigDataView> {
  using Data = ::device_test::mojom::internal::DeviceConfig_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::ControllerAxisDataDataView> {
  using Data = ::device_test::mojom::internal::ControllerAxisData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::ControllerFrameDataDataView> {
  using Data = ::device_test::mojom::internal::ControllerFrameData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::device_test::mojom::EventDataDataView> {
  using Data = ::device_test::mojom::internal::EventData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace device_test {
namespace mojom {


enum class Eye : int32_t {
  
  LEFT = 1,
  
  RIGHT = 2,
  
  NONE = 3,
  kMinValue = 1,
  kMaxValue = 3,
};

COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) std::ostream& operator<<(std::ostream& os, Eye value);
inline bool IsKnownEnumValue(Eye value) {
  return internal::Eye_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class TrackedDeviceClass : int32_t {
  
  kTrackedDeviceInvalid = 0,
  
  kTrackedDeviceHmd = 1,
  
  kTrackedDeviceController = 2,
  
  kTrackedDeviceGenericTracker = 3,
  
  kTrackedDeviceTrackingReference = 4,
  
  kTrackedDeviceDisplayRedirect = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) std::ostream& operator<<(std::ostream& os, TrackedDeviceClass value);
inline bool IsKnownEnumValue(TrackedDeviceClass value) {
  return internal::TrackedDeviceClass_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ControllerRole : int32_t {
  
  kControllerRoleInvalid = 0,
  
  kControllerRoleLeft = 1,
  
  kControllerRoleRight = 2,
  
  kControllerRoleVoice = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) std::ostream& operator<<(std::ostream& os, ControllerRole value);
inline bool IsKnownEnumValue(ControllerRole value) {
  return internal::ControllerRole_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class EventType : int32_t {
  
  kSessionLost = 0,
  
  kVisibilityVisibleBlurred = 1,
  
  kInstanceLost = 2,
  
  kInteractionProfileChanged = 3,
  
  kNoEvent = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) std::ostream& operator<<(std::ostream& os, EventType value);
inline bool IsKnownEnumValue(EventType value) {
  return internal::EventType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class InteractionProfileType : int32_t {
  
  kWMRMotion = 0,
  
  kKHRSimple = 1,
  
  kOculusTouch = 2,
  
  kValveIndex = 3,
  
  kHTCVive = 4,
  
  kSamsungOdyssey = 5,
  
  kHPReverbG2 = 6,
  
  kHandSelectGrasp = 7,
  
  kViveCosmos = 8,
  
  kInvalid = 9,
  kMinValue = 0,
  kMaxValue = 9,
};

COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) std::ostream& operator<<(std::ostream& os, InteractionProfileType value);
inline bool IsKnownEnumValue(InteractionProfileType value) {
  return internal::InteractionProfileType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class XRTestHookInterfaceBase {};

using XRTestHookPtrDataView =
    mojo::InterfacePtrDataView<XRTestHookInterfaceBase>;
using XRTestHookRequestDataView =
    mojo::InterfaceRequestDataView<XRTestHookInterfaceBase>;
using XRTestHookAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<XRTestHookInterfaceBase>;
using XRTestHookAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<XRTestHookInterfaceBase>;
class XRServiceTestHookInterfaceBase {};

using XRServiceTestHookPtrDataView =
    mojo::InterfacePtrDataView<XRServiceTestHookInterfaceBase>;
using XRServiceTestHookRequestDataView =
    mojo::InterfaceRequestDataView<XRServiceTestHookInterfaceBase>;
using XRServiceTestHookAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<XRServiceTestHookInterfaceBase>;
using XRServiceTestHookAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<XRServiceTestHookInterfaceBase>;


class ColorDataView {
 public:
  ColorDataView() = default;

  ColorDataView(
      internal::Color_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint8_t r() const {
    return data_->r;
  }
  uint8_t g() const {
    return data_->g;
  }
  uint8_t b() const {
    return data_->b;
  }
  uint8_t a() const {
    return data_->a;
  }
 private:
  internal::Color_Data* data_ = nullptr;
};



class ViewDataDataView {
 public:
  ViewDataDataView() = default;

  ViewDataDataView(
      internal::ViewData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetColorDataView(
      ColorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColor(UserType* output) {
    
    auto* pointer = data_->color.Get();
    return mojo::internal::Deserialize<::device_test::mojom::ColorDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadEye(UserType* output) const {
    auto data_value = data_->eye;
    return mojo::internal::Deserialize<::device_test::mojom::Eye>(
        data_value, output);
  }
  Eye eye() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device_test::mojom::Eye>(data_->eye));
  }
  inline void GetViewportDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadViewport(UserType* output) {
    
    auto* pointer = data_->viewport.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
 private:
  internal::ViewData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PoseFrameDataDataView {
 public:
  PoseFrameDataDataView() = default;

  PoseFrameDataDataView(
      internal::PoseFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDeviceToOriginDataView(
      ::gfx::mojom::TransformDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDeviceToOrigin(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::TransformDataView, UserType>(),
    "Attempting to read the optional `device_to_origin` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDeviceToOrigin` instead "
    "of `ReadDeviceToOrigin if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->device_to_origin.Get();
    return mojo::internal::Deserialize<::gfx::mojom::TransformDataView>(
        pointer, output, message_);
  }
 private:
  internal::PoseFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ProjectionRawDataView {
 public:
  ProjectionRawDataView() = default;

  ProjectionRawDataView(
      internal::ProjectionRaw_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float left() const {
    return data_->left;
  }
  float right() const {
    return data_->right;
  }
  float top() const {
    return data_->top;
  }
  float bottom() const {
    return data_->bottom;
  }
 private:
  internal::ProjectionRaw_Data* data_ = nullptr;
};



class DeviceConfigDataView {
 public:
  DeviceConfigDataView() = default;

  DeviceConfigDataView(
      internal::DeviceConfig_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  float interpupillary_distance() const {
    return data_->interpupillary_distance;
  }
  inline void GetProjectionLeftDataView(
      ProjectionRawDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadProjectionLeft(UserType* output) {
    
    auto* pointer = data_->projection_left.Get();
    return mojo::internal::Deserialize<::device_test::mojom::ProjectionRawDataView>(
        pointer, output, message_);
  }
  inline void GetProjectionRightDataView(
      ProjectionRawDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadProjectionRight(UserType* output) {
    
    auto* pointer = data_->projection_right.Get();
    return mojo::internal::Deserialize<::device_test::mojom::ProjectionRawDataView>(
        pointer, output, message_);
  }
 private:
  internal::DeviceConfig_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ControllerAxisDataDataView {
 public:
  ControllerAxisDataDataView() = default;

  ControllerAxisDataDataView(
      internal::ControllerAxisData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float x() const {
    return data_->x;
  }
  float y() const {
    return data_->y;
  }
  uint8_t axis_type() const {
    return data_->axis_type;
  }
 private:
  internal::ControllerAxisData_Data* data_ = nullptr;
};



class ControllerFrameDataDataView {
 public:
  ControllerFrameDataDataView() = default;

  ControllerFrameDataDataView(
      internal::ControllerFrameData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint32_t packet_number() const {
    return data_->packet_number;
  }
  uint64_t buttons_pressed() const {
    return data_->buttons_pressed;
  }
  uint64_t buttons_touched() const {
    return data_->buttons_touched;
  }
  uint64_t supported_buttons() const {
    return data_->supported_buttons;
  }
  inline void GetAxisDataDataView(
      mojo::ArrayDataView<ControllerAxisDataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAxisData(UserType* output) {
    
    auto* pointer = data_->axis_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::device_test::mojom::ControllerAxisDataDataView>>(
        pointer, output, message_);
  }
  inline void GetPoseDataDataView(
      PoseFrameDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPoseData(UserType* output) {
    
    auto* pointer = data_->pose_data.Get();
    return mojo::internal::Deserialize<::device_test::mojom::PoseFrameDataDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadRole(UserType* output) const {
    auto data_value = data_->role;
    return mojo::internal::Deserialize<::device_test::mojom::ControllerRole>(
        data_value, output);
  }
  ControllerRole role() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device_test::mojom::ControllerRole>(data_->role));
  }
  bool is_valid() const {
    return data_->is_valid;
  }
 private:
  internal::ControllerFrameData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EventDataDataView {
 public:
  EventDataDataView() = default;

  EventDataDataView(
      internal::EventData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::device_test::mojom::EventType>(
        data_value, output);
  }
  EventType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device_test::mojom::EventType>(data_->type));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadInteractionProfile(UserType* output) const {
    auto data_value = data_->interaction_profile;
    return mojo::internal::Deserialize<::device_test::mojom::InteractionProfileType>(
        data_value, output);
  }
  InteractionProfileType interaction_profile() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::device_test::mojom::InteractionProfileType>(data_->interaction_profile));
  }
 private:
  internal::EventData_Data* data_ = nullptr;
};



}  // namespace mojom
}  // namespace device_test

namespace std {

template <>
struct hash<::device_test::mojom::Eye>
    : public mojo::internal::EnumHashImpl<::device_test::mojom::Eye> {};

template <>
struct hash<::device_test::mojom::TrackedDeviceClass>
    : public mojo::internal::EnumHashImpl<::device_test::mojom::TrackedDeviceClass> {};

template <>
struct hash<::device_test::mojom::ControllerRole>
    : public mojo::internal::EnumHashImpl<::device_test::mojom::ControllerRole> {};

template <>
struct hash<::device_test::mojom::EventType>
    : public mojo::internal::EnumHashImpl<::device_test::mojom::EventType> {};

template <>
struct hash<::device_test::mojom::InteractionProfileType>
    : public mojo::internal::EnumHashImpl<::device_test::mojom::InteractionProfileType> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::Eye, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device_test::mojom::Eye, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device_test::mojom::Eye>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::TrackedDeviceClass, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device_test::mojom::TrackedDeviceClass, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device_test::mojom::TrackedDeviceClass>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::ControllerRole, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device_test::mojom::ControllerRole, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device_test::mojom::ControllerRole>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::EventType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device_test::mojom::EventType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device_test::mojom::EventType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::InteractionProfileType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::device_test::mojom::InteractionProfileType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::device_test::mojom::InteractionProfileType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::ColorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::ColorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::Color_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->r = Traits::r(input);
    fragment->g = Traits::g(input);
    fragment->b = Traits::b(input);
    fragment->a = Traits::a(input);
  }

  static bool Deserialize(::device_test::mojom::internal::Color_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::ColorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::ViewDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::ViewDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::ViewData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::color(input)) in_color = Traits::color(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color)::BaseType> color_fragment(
            fragment.message());
    mojo::internal::Serialize<::device_test::mojom::ColorDataView>(
        in_color, color_fragment);
    fragment->color.Set(
        color_fragment.is_null() ? nullptr : color_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color in ViewData struct");
    mojo::internal::Serialize<::device_test::mojom::Eye>(
        Traits::eye(input), &fragment->eye);
    decltype(Traits::viewport(input)) in_viewport = Traits::viewport(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->viewport)::BaseType> viewport_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_viewport, viewport_fragment);
    fragment->viewport.Set(
        viewport_fragment.is_null() ? nullptr : viewport_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->viewport.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null viewport in ViewData struct");
  }

  static bool Deserialize(::device_test::mojom::internal::ViewData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::ViewDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::PoseFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::PoseFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::PoseFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::device_to_origin(input)) in_device_to_origin = Traits::device_to_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->device_to_origin)::BaseType> device_to_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::TransformDataView>(
        in_device_to_origin, device_to_origin_fragment);
    fragment->device_to_origin.Set(
        device_to_origin_fragment.is_null() ? nullptr : device_to_origin_fragment.data());
  }

  static bool Deserialize(::device_test::mojom::internal::PoseFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::PoseFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::ProjectionRawDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::ProjectionRawDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::ProjectionRaw_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->left = Traits::left(input);
    fragment->right = Traits::right(input);
    fragment->top = Traits::top(input);
    fragment->bottom = Traits::bottom(input);
  }

  static bool Deserialize(::device_test::mojom::internal::ProjectionRaw_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::ProjectionRawDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::DeviceConfigDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::DeviceConfigDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::DeviceConfig_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->interpupillary_distance = Traits::interpupillary_distance(input);
    decltype(Traits::projection_left(input)) in_projection_left = Traits::projection_left(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->projection_left)::BaseType> projection_left_fragment(
            fragment.message());
    mojo::internal::Serialize<::device_test::mojom::ProjectionRawDataView>(
        in_projection_left, projection_left_fragment);
    fragment->projection_left.Set(
        projection_left_fragment.is_null() ? nullptr : projection_left_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->projection_left.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null projection_left in DeviceConfig struct");
    decltype(Traits::projection_right(input)) in_projection_right = Traits::projection_right(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->projection_right)::BaseType> projection_right_fragment(
            fragment.message());
    mojo::internal::Serialize<::device_test::mojom::ProjectionRawDataView>(
        in_projection_right, projection_right_fragment);
    fragment->projection_right.Set(
        projection_right_fragment.is_null() ? nullptr : projection_right_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->projection_right.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null projection_right in DeviceConfig struct");
  }

  static bool Deserialize(::device_test::mojom::internal::DeviceConfig_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::DeviceConfigDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::ControllerAxisDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::ControllerAxisDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::ControllerAxisData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->x = Traits::x(input);
    fragment->y = Traits::y(input);
    fragment->axis_type = Traits::axis_type(input);
  }

  static bool Deserialize(::device_test::mojom::internal::ControllerAxisData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::ControllerAxisDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::ControllerFrameDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::ControllerFrameDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::ControllerFrameData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->packet_number = Traits::packet_number(input);
    fragment->buttons_pressed = Traits::buttons_pressed(input);
    fragment->buttons_touched = Traits::buttons_touched(input);
    fragment->supported_buttons = Traits::supported_buttons(input);
    decltype(Traits::axis_data(input)) in_axis_data = Traits::axis_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->axis_data)::BaseType>
        axis_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams axis_data_validate_params(
        5, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::device_test::mojom::ControllerAxisDataDataView>>(
        in_axis_data, axis_data_fragment, &axis_data_validate_params);
    fragment->axis_data.Set(
        axis_data_fragment.is_null() ? nullptr : axis_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->axis_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null axis_data in ControllerFrameData struct");
    decltype(Traits::pose_data(input)) in_pose_data = Traits::pose_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pose_data)::BaseType> pose_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::device_test::mojom::PoseFrameDataDataView>(
        in_pose_data, pose_data_fragment);
    fragment->pose_data.Set(
        pose_data_fragment.is_null() ? nullptr : pose_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->pose_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null pose_data in ControllerFrameData struct");
    mojo::internal::Serialize<::device_test::mojom::ControllerRole>(
        Traits::role(input), &fragment->role);
    fragment->is_valid = Traits::is_valid(input);
  }

  static bool Deserialize(::device_test::mojom::internal::ControllerFrameData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::ControllerFrameDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::device_test::mojom::EventDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::device_test::mojom::EventDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::device_test::mojom::internal::EventData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::device_test::mojom::EventType>(
        Traits::type(input), &fragment->type);
    mojo::internal::Serialize<::device_test::mojom::InteractionProfileType>(
        Traits::interaction_profile(input), &fragment->interaction_profile);
  }

  static bool Deserialize(::device_test::mojom::internal::EventData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::device_test::mojom::EventDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace device_test {
namespace mojom {



inline void ViewDataDataView::GetColorDataView(
    ColorDataView* output) {
  auto pointer = data_->color.Get();
  *output = ColorDataView(pointer, message_);
}
inline void ViewDataDataView::GetViewportDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->viewport.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}


inline void PoseFrameDataDataView::GetDeviceToOriginDataView(
    ::gfx::mojom::TransformDataView* output) {
  auto pointer = data_->device_to_origin.Get();
  *output = ::gfx::mojom::TransformDataView(pointer, message_);
}




inline void DeviceConfigDataView::GetProjectionLeftDataView(
    ProjectionRawDataView* output) {
  auto pointer = data_->projection_left.Get();
  *output = ProjectionRawDataView(pointer, message_);
}
inline void DeviceConfigDataView::GetProjectionRightDataView(
    ProjectionRawDataView* output) {
  auto pointer = data_->projection_right.Get();
  *output = ProjectionRawDataView(pointer, message_);
}




inline void ControllerFrameDataDataView::GetAxisDataDataView(
    mojo::ArrayDataView<ControllerAxisDataDataView>* output) {
  auto pointer = data_->axis_data.Get();
  *output = mojo::ArrayDataView<ControllerAxisDataDataView>(pointer, message_);
}
inline void ControllerFrameDataDataView::GetPoseDataDataView(
    PoseFrameDataDataView* output) {
  auto pointer = data_->pose_data.Get();
  *output = PoseFrameDataDataView(pointer, message_);
}





}  // namespace mojom
}  // namespace device_test

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) TraceFormatTraits<::device_test::mojom::Eye> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device_test::mojom::Eye value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) TraceFormatTraits<::device_test::mojom::TrackedDeviceClass> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device_test::mojom::TrackedDeviceClass value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) TraceFormatTraits<::device_test::mojom::ControllerRole> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device_test::mojom::ControllerRole value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) TraceFormatTraits<::device_test::mojom::EventType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device_test::mojom::EventType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(DEVICE_VR_TEST_MOJO_BINDINGS_SHARED) TraceFormatTraits<::device_test::mojom::InteractionProfileType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::device_test::mojom::InteractionProfileType value);
};

} // namespace perfetto

#endif  // DEVICE_VR_PUBLIC_MOJOM_BROWSER_TEST_INTERFACES_MOJOM_SHARED_H_