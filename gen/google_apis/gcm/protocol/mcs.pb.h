// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcs.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include "google_apis/gcm/base/gcm_export.h"
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_mcs_2eproto GCM_EXPORT
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct GCM_EXPORT TableStruct_mcs_2eproto {
static const uint32_t offsets[];
};
namespace mcs_proto {
class AppData;
struct AppDataDefaultTypeInternal;
GCM_EXPORT extern AppDataDefaultTypeInternal _AppData_default_instance_;
class ClientEvent;
struct ClientEventDefaultTypeInternal;
GCM_EXPORT extern ClientEventDefaultTypeInternal _ClientEvent_default_instance_;
class Close;
struct CloseDefaultTypeInternal;
GCM_EXPORT extern CloseDefaultTypeInternal _Close_default_instance_;
class DataMessageStanza;
struct DataMessageStanzaDefaultTypeInternal;
GCM_EXPORT extern DataMessageStanzaDefaultTypeInternal _DataMessageStanza_default_instance_;
class ErrorInfo;
struct ErrorInfoDefaultTypeInternal;
GCM_EXPORT extern ErrorInfoDefaultTypeInternal _ErrorInfo_default_instance_;
class Extension;
struct ExtensionDefaultTypeInternal;
GCM_EXPORT extern ExtensionDefaultTypeInternal _Extension_default_instance_;
class HeartbeatAck;
struct HeartbeatAckDefaultTypeInternal;
GCM_EXPORT extern HeartbeatAckDefaultTypeInternal _HeartbeatAck_default_instance_;
class HeartbeatConfig;
struct HeartbeatConfigDefaultTypeInternal;
GCM_EXPORT extern HeartbeatConfigDefaultTypeInternal _HeartbeatConfig_default_instance_;
class HeartbeatPing;
struct HeartbeatPingDefaultTypeInternal;
GCM_EXPORT extern HeartbeatPingDefaultTypeInternal _HeartbeatPing_default_instance_;
class HeartbeatStat;
struct HeartbeatStatDefaultTypeInternal;
GCM_EXPORT extern HeartbeatStatDefaultTypeInternal _HeartbeatStat_default_instance_;
class IqStanza;
struct IqStanzaDefaultTypeInternal;
GCM_EXPORT extern IqStanzaDefaultTypeInternal _IqStanza_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
GCM_EXPORT extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
GCM_EXPORT extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class SelectiveAck;
struct SelectiveAckDefaultTypeInternal;
GCM_EXPORT extern SelectiveAckDefaultTypeInternal _SelectiveAck_default_instance_;
class Setting;
struct SettingDefaultTypeInternal;
GCM_EXPORT extern SettingDefaultTypeInternal _Setting_default_instance_;
class StreamAck;
struct StreamAckDefaultTypeInternal;
GCM_EXPORT extern StreamAckDefaultTypeInternal _StreamAck_default_instance_;
class StreamErrorStanza;
struct StreamErrorStanzaDefaultTypeInternal;
GCM_EXPORT extern StreamErrorStanzaDefaultTypeInternal _StreamErrorStanza_default_instance_;
}  // namespace mcs_proto
PROTOBUF_NAMESPACE_OPEN
template<> GCM_EXPORT ::mcs_proto::AppData* Arena::CreateMaybeMessage<::mcs_proto::AppData>(Arena*);
template<> GCM_EXPORT ::mcs_proto::ClientEvent* Arena::CreateMaybeMessage<::mcs_proto::ClientEvent>(Arena*);
template<> GCM_EXPORT ::mcs_proto::Close* Arena::CreateMaybeMessage<::mcs_proto::Close>(Arena*);
template<> GCM_EXPORT ::mcs_proto::DataMessageStanza* Arena::CreateMaybeMessage<::mcs_proto::DataMessageStanza>(Arena*);
template<> GCM_EXPORT ::mcs_proto::ErrorInfo* Arena::CreateMaybeMessage<::mcs_proto::ErrorInfo>(Arena*);
template<> GCM_EXPORT ::mcs_proto::Extension* Arena::CreateMaybeMessage<::mcs_proto::Extension>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatAck* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatAck>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatConfig* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatConfig>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatPing* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatPing>(Arena*);
template<> GCM_EXPORT ::mcs_proto::HeartbeatStat* Arena::CreateMaybeMessage<::mcs_proto::HeartbeatStat>(Arena*);
template<> GCM_EXPORT ::mcs_proto::IqStanza* Arena::CreateMaybeMessage<::mcs_proto::IqStanza>(Arena*);
template<> GCM_EXPORT ::mcs_proto::LoginRequest* Arena::CreateMaybeMessage<::mcs_proto::LoginRequest>(Arena*);
template<> GCM_EXPORT ::mcs_proto::LoginResponse* Arena::CreateMaybeMessage<::mcs_proto::LoginResponse>(Arena*);
template<> GCM_EXPORT ::mcs_proto::SelectiveAck* Arena::CreateMaybeMessage<::mcs_proto::SelectiveAck>(Arena*);
template<> GCM_EXPORT ::mcs_proto::Setting* Arena::CreateMaybeMessage<::mcs_proto::Setting>(Arena*);
template<> GCM_EXPORT ::mcs_proto::StreamAck* Arena::CreateMaybeMessage<::mcs_proto::StreamAck>(Arena*);
template<> GCM_EXPORT ::mcs_proto::StreamErrorStanza* Arena::CreateMaybeMessage<::mcs_proto::StreamErrorStanza>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace mcs_proto {

enum ClientEvent_Type : int {
ClientEvent_Type_UNKNOWN = 0,
ClientEvent_Type_DISCARDED_EVENTS = 1,
ClientEvent_Type_FAILED_CONNECTION = 2,
ClientEvent_Type_SUCCESSFUL_CONNECTION = 3
};
GCM_EXPORT bool ClientEvent_Type_IsValid(int value);
constexpr ClientEvent_Type ClientEvent_Type_Type_MIN = ClientEvent_Type_UNKNOWN;
constexpr ClientEvent_Type ClientEvent_Type_Type_MAX = ClientEvent_Type_SUCCESSFUL_CONNECTION;
constexpr int ClientEvent_Type_Type_ARRAYSIZE = ClientEvent_Type_Type_MAX + 1;

const std::string& ClientEvent_Type_Name(ClientEvent_Type value);
template<typename T>
inline const std::string& ClientEvent_Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, ClientEvent_Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function ClientEvent_Type_Name.");
return ClientEvent_Type_Name(static_cast<ClientEvent_Type>(enum_t_value));
}
bool ClientEvent_Type_Parse(
::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientEvent_Type* value);
enum LoginRequest_AuthService : int {
LoginRequest_AuthService_ANDROID_ID = 2
};
GCM_EXPORT bool LoginRequest_AuthService_IsValid(int value);
constexpr LoginRequest_AuthService LoginRequest_AuthService_AuthService_MIN = LoginRequest_AuthService_ANDROID_ID;
constexpr LoginRequest_AuthService LoginRequest_AuthService_AuthService_MAX = LoginRequest_AuthService_ANDROID_ID;
constexpr int LoginRequest_AuthService_AuthService_ARRAYSIZE = LoginRequest_AuthService_AuthService_MAX + 1;

const std::string& LoginRequest_AuthService_Name(LoginRequest_AuthService value);
template<typename T>
inline const std::string& LoginRequest_AuthService_Name(T enum_t_value) {
static_assert(::std::is_same<T, LoginRequest_AuthService>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function LoginRequest_AuthService_Name.");
return LoginRequest_AuthService_Name(static_cast<LoginRequest_AuthService>(enum_t_value));
}
bool LoginRequest_AuthService_Parse(
::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LoginRequest_AuthService* value);
enum IqStanza_IqType : int {
IqStanza_IqType_GET = 0,
IqStanza_IqType_SET = 1,
IqStanza_IqType_RESULT = 2,
IqStanza_IqType_IQ_ERROR = 3
};
GCM_EXPORT bool IqStanza_IqType_IsValid(int value);
constexpr IqStanza_IqType IqStanza_IqType_IqType_MIN = IqStanza_IqType_GET;
constexpr IqStanza_IqType IqStanza_IqType_IqType_MAX = IqStanza_IqType_IQ_ERROR;
constexpr int IqStanza_IqType_IqType_ARRAYSIZE = IqStanza_IqType_IqType_MAX + 1;

const std::string& IqStanza_IqType_Name(IqStanza_IqType value);
template<typename T>
inline const std::string& IqStanza_IqType_Name(T enum_t_value) {
static_assert(::std::is_same<T, IqStanza_IqType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function IqStanza_IqType_Name.");
return IqStanza_IqType_Name(static_cast<IqStanza_IqType>(enum_t_value));
}
bool IqStanza_IqType_Parse(
::PROTOBUF_NAMESPACE_ID::ConstStringParam name, IqStanza_IqType* value);
// ===================================================================

class GCM_EXPORT HeartbeatPing final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatPing) */ {
public:
inline HeartbeatPing() : HeartbeatPing(nullptr) {}
~HeartbeatPing() override;
explicit PROTOBUF_CONSTEXPR HeartbeatPing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

HeartbeatPing(const HeartbeatPing& from);
HeartbeatPing(HeartbeatPing&& from) noexcept
: HeartbeatPing() {
*this = ::std::move(from);
}

inline HeartbeatPing& operator=(const HeartbeatPing& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatPing& operator=(HeartbeatPing&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const HeartbeatPing& default_instance() {
return *internal_default_instance();
}
static inline const HeartbeatPing* internal_default_instance() {
return reinterpret_cast<const HeartbeatPing*>(
&_HeartbeatPing_default_instance_);
}
static constexpr int kIndexInFileMessages =
0;

friend void swap(HeartbeatPing& a, HeartbeatPing& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(HeartbeatPing* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(HeartbeatPing* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

HeartbeatPing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<HeartbeatPing>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const HeartbeatPing& from);
void MergeFrom(const HeartbeatPing& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatPing* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatPing";
}
protected:
explicit HeartbeatPing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStreamIdFieldNumber = 1,
kLastStreamIdReceivedFieldNumber = 2,
kStatusFieldNumber = 3,
};
// optional int32 stream_id = 1;
bool has_stream_id() const;
private:
bool _internal_has_stream_id() const;
public:
void clear_stream_id();
int32_t stream_id() const;
void set_stream_id(int32_t value);
private:
int32_t _internal_stream_id() const;
void _internal_set_stream_id(int32_t value);
public:

// optional int32 last_stream_id_received = 2;
bool has_last_stream_id_received() const;
private:
bool _internal_has_last_stream_id_received() const;
public:
void clear_last_stream_id_received();
int32_t last_stream_id_received() const;
void set_last_stream_id_received(int32_t value);
private:
int32_t _internal_last_stream_id_received() const;
void _internal_set_last_stream_id_received(int32_t value);
public:

// optional int64 status = 3;
bool has_status() const;
private:
bool _internal_has_status() const;
public:
void clear_status();
int64_t status() const;
void set_status(int64_t value);
private:
int64_t _internal_status() const;
void _internal_set_status(int64_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatPing)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int32_t stream_id_;
int32_t last_stream_id_received_;
int64_t status_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT HeartbeatAck final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatAck) */ {
public:
inline HeartbeatAck() : HeartbeatAck(nullptr) {}
~HeartbeatAck() override;
explicit PROTOBUF_CONSTEXPR HeartbeatAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

HeartbeatAck(const HeartbeatAck& from);
HeartbeatAck(HeartbeatAck&& from) noexcept
: HeartbeatAck() {
*this = ::std::move(from);
}

inline HeartbeatAck& operator=(const HeartbeatAck& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatAck& operator=(HeartbeatAck&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const HeartbeatAck& default_instance() {
return *internal_default_instance();
}
static inline const HeartbeatAck* internal_default_instance() {
return reinterpret_cast<const HeartbeatAck*>(
&_HeartbeatAck_default_instance_);
}
static constexpr int kIndexInFileMessages =
1;

friend void swap(HeartbeatAck& a, HeartbeatAck& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(HeartbeatAck* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(HeartbeatAck* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

HeartbeatAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<HeartbeatAck>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const HeartbeatAck& from);
void MergeFrom(const HeartbeatAck& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatAck* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatAck";
}
protected:
explicit HeartbeatAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kStreamIdFieldNumber = 1,
kLastStreamIdReceivedFieldNumber = 2,
kStatusFieldNumber = 3,
};
// optional int32 stream_id = 1;
bool has_stream_id() const;
private:
bool _internal_has_stream_id() const;
public:
void clear_stream_id();
int32_t stream_id() const;
void set_stream_id(int32_t value);
private:
int32_t _internal_stream_id() const;
void _internal_set_stream_id(int32_t value);
public:

// optional int32 last_stream_id_received = 2;
bool has_last_stream_id_received() const;
private:
bool _internal_has_last_stream_id_received() const;
public:
void clear_last_stream_id_received();
int32_t last_stream_id_received() const;
void set_last_stream_id_received(int32_t value);
private:
int32_t _internal_last_stream_id_received() const;
void _internal_set_last_stream_id_received(int32_t value);
public:

// optional int64 status = 3;
bool has_status() const;
private:
bool _internal_has_status() const;
public:
void clear_status();
int64_t status() const;
void set_status(int64_t value);
private:
int64_t _internal_status() const;
void _internal_set_status(int64_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatAck)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int32_t stream_id_;
int32_t last_stream_id_received_;
int64_t status_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT ErrorInfo final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ErrorInfo) */ {
public:
inline ErrorInfo() : ErrorInfo(nullptr) {}
~ErrorInfo() override;
explicit PROTOBUF_CONSTEXPR ErrorInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

ErrorInfo(const ErrorInfo& from);
ErrorInfo(ErrorInfo&& from) noexcept
: ErrorInfo() {
*this = ::std::move(from);
}

inline ErrorInfo& operator=(const ErrorInfo& from) {
CopyFrom(from);
return *this;
}
inline ErrorInfo& operator=(ErrorInfo&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const ErrorInfo& default_instance() {
return *internal_default_instance();
}
static inline const ErrorInfo* internal_default_instance() {
return reinterpret_cast<const ErrorInfo*>(
&_ErrorInfo_default_instance_);
}
static constexpr int kIndexInFileMessages =
2;

friend void swap(ErrorInfo& a, ErrorInfo& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(ErrorInfo* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(ErrorInfo* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

ErrorInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<ErrorInfo>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const ErrorInfo& from);
void MergeFrom(const ErrorInfo& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ErrorInfo* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.ErrorInfo";
}
protected:
explicit ErrorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kMessageFieldNumber = 2,
kTypeFieldNumber = 3,
kExtensionFieldNumber = 4,
kCodeFieldNumber = 1,
};
// optional string message = 2;
bool has_message() const;
private:
bool _internal_has_message() const;
public:
void clear_message();
const std::string& message() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_message(ArgT0&& arg0, ArgT... args);
std::string* mutable_message();
PROTOBUF_NODISCARD std::string* release_message();
void set_allocated_message(std::string* message);
private:
const std::string& _internal_message() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
std::string* _internal_mutable_message();
public:

// optional string type = 3;
bool has_type() const;
private:
bool _internal_has_type() const;
public:
void clear_type();
const std::string& type() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_type(ArgT0&& arg0, ArgT... args);
std::string* mutable_type();
PROTOBUF_NODISCARD std::string* release_type();
void set_allocated_type(std::string* type);
private:
const std::string& _internal_type() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
std::string* _internal_mutable_type();
public:

// optional .mcs_proto.Extension extension = 4;
bool has_extension() const;
private:
bool _internal_has_extension() const;
public:
void clear_extension();
const ::mcs_proto::Extension& extension() const;
PROTOBUF_NODISCARD ::mcs_proto::Extension* release_extension();
::mcs_proto::Extension* mutable_extension();
void set_allocated_extension(::mcs_proto::Extension* extension);
private:
const ::mcs_proto::Extension& _internal_extension() const;
::mcs_proto::Extension* _internal_mutable_extension();
public:
void unsafe_arena_set_allocated_extension(
::mcs_proto::Extension* extension);
::mcs_proto::Extension* unsafe_arena_release_extension();

// required int32 code = 1;
bool has_code() const;
private:
bool _internal_has_code() const;
public:
void clear_code();
int32_t code() const;
void set_code(int32_t value);
private:
int32_t _internal_code() const;
void _internal_set_code(int32_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.ErrorInfo)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
::mcs_proto::Extension* extension_;
int32_t code_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT Setting final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Setting) */ {
public:
inline Setting() : Setting(nullptr) {}
~Setting() override;
explicit PROTOBUF_CONSTEXPR Setting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

Setting(const Setting& from);
Setting(Setting&& from) noexcept
: Setting() {
*this = ::std::move(from);
}

inline Setting& operator=(const Setting& from) {
CopyFrom(from);
return *this;
}
inline Setting& operator=(Setting&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const Setting& default_instance() {
return *internal_default_instance();
}
static inline const Setting* internal_default_instance() {
return reinterpret_cast<const Setting*>(
&_Setting_default_instance_);
}
static constexpr int kIndexInFileMessages =
3;

friend void swap(Setting& a, Setting& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(Setting* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(Setting* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

Setting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<Setting>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const Setting& from);
void MergeFrom(const Setting& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Setting* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.Setting";
}
protected:
explicit Setting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kNameFieldNumber = 1,
kValueFieldNumber = 2,
};
// required string name = 1;
bool has_name() const;
private:
bool _internal_has_name() const;
public:
void clear_name();
const std::string& name() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_name(ArgT0&& arg0, ArgT... args);
std::string* mutable_name();
PROTOBUF_NODISCARD std::string* release_name();
void set_allocated_name(std::string* name);
private:
const std::string& _internal_name() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
std::string* _internal_mutable_name();
public:

// required string value = 2;
bool has_value() const;
private:
bool _internal_has_value() const;
public:
void clear_value();
const std::string& value() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_value(ArgT0&& arg0, ArgT... args);
std::string* mutable_value();
PROTOBUF_NODISCARD std::string* release_value();
void set_allocated_value(std::string* value);
private:
const std::string& _internal_value() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
std::string* _internal_mutable_value();
public:

// @@protoc_insertion_point(class_scope:mcs_proto.Setting)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT HeartbeatStat final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatStat) */ {
public:
inline HeartbeatStat() : HeartbeatStat(nullptr) {}
~HeartbeatStat() override;
explicit PROTOBUF_CONSTEXPR HeartbeatStat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

HeartbeatStat(const HeartbeatStat& from);
HeartbeatStat(HeartbeatStat&& from) noexcept
: HeartbeatStat() {
*this = ::std::move(from);
}

inline HeartbeatStat& operator=(const HeartbeatStat& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatStat& operator=(HeartbeatStat&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const HeartbeatStat& default_instance() {
return *internal_default_instance();
}
static inline const HeartbeatStat* internal_default_instance() {
return reinterpret_cast<const HeartbeatStat*>(
&_HeartbeatStat_default_instance_);
}
static constexpr int kIndexInFileMessages =
4;

friend void swap(HeartbeatStat& a, HeartbeatStat& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(HeartbeatStat* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(HeartbeatStat* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

HeartbeatStat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<HeartbeatStat>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const HeartbeatStat& from);
void MergeFrom(const HeartbeatStat& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatStat* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatStat";
}
protected:
explicit HeartbeatStat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIpFieldNumber = 1,
kTimeoutFieldNumber = 2,
kIntervalMsFieldNumber = 3,
};
// required string ip = 1;
bool has_ip() const;
private:
bool _internal_has_ip() const;
public:
void clear_ip();
const std::string& ip() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_ip(ArgT0&& arg0, ArgT... args);
std::string* mutable_ip();
PROTOBUF_NODISCARD std::string* release_ip();
void set_allocated_ip(std::string* ip);
private:
const std::string& _internal_ip() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
std::string* _internal_mutable_ip();
public:

// required bool timeout = 2;
bool has_timeout() const;
private:
bool _internal_has_timeout() const;
public:
void clear_timeout();
bool timeout() const;
void set_timeout(bool value);
private:
bool _internal_timeout() const;
void _internal_set_timeout(bool value);
public:

// required int32 interval_ms = 3;
bool has_interval_ms() const;
private:
bool _internal_has_interval_ms() const;
public:
void clear_interval_ms();
int32_t interval_ms() const;
void set_interval_ms(int32_t value);
private:
int32_t _internal_interval_ms() const;
void _internal_set_interval_ms(int32_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatStat)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
bool timeout_;
int32_t interval_ms_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT HeartbeatConfig final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.HeartbeatConfig) */ {
public:
inline HeartbeatConfig() : HeartbeatConfig(nullptr) {}
~HeartbeatConfig() override;
explicit PROTOBUF_CONSTEXPR HeartbeatConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

HeartbeatConfig(const HeartbeatConfig& from);
HeartbeatConfig(HeartbeatConfig&& from) noexcept
: HeartbeatConfig() {
*this = ::std::move(from);
}

inline HeartbeatConfig& operator=(const HeartbeatConfig& from) {
CopyFrom(from);
return *this;
}
inline HeartbeatConfig& operator=(HeartbeatConfig&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const HeartbeatConfig& default_instance() {
return *internal_default_instance();
}
static inline const HeartbeatConfig* internal_default_instance() {
return reinterpret_cast<const HeartbeatConfig*>(
&_HeartbeatConfig_default_instance_);
}
static constexpr int kIndexInFileMessages =
5;

friend void swap(HeartbeatConfig& a, HeartbeatConfig& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(HeartbeatConfig* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(HeartbeatConfig* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

HeartbeatConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<HeartbeatConfig>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const HeartbeatConfig& from);
void MergeFrom(const HeartbeatConfig& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(HeartbeatConfig* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.HeartbeatConfig";
}
protected:
explicit HeartbeatConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIpFieldNumber = 2,
kUploadStatFieldNumber = 1,
kIntervalMsFieldNumber = 3,
};
// optional string ip = 2;
bool has_ip() const;
private:
bool _internal_has_ip() const;
public:
void clear_ip();
const std::string& ip() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_ip(ArgT0&& arg0, ArgT... args);
std::string* mutable_ip();
PROTOBUF_NODISCARD std::string* release_ip();
void set_allocated_ip(std::string* ip);
private:
const std::string& _internal_ip() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
std::string* _internal_mutable_ip();
public:

// optional bool upload_stat = 1;
bool has_upload_stat() const;
private:
bool _internal_has_upload_stat() const;
public:
void clear_upload_stat();
bool upload_stat() const;
void set_upload_stat(bool value);
private:
bool _internal_upload_stat() const;
void _internal_set_upload_stat(bool value);
public:

// optional int32 interval_ms = 3;
bool has_interval_ms() const;
private:
bool _internal_has_interval_ms() const;
public:
void clear_interval_ms();
int32_t interval_ms() const;
void set_interval_ms(int32_t value);
private:
int32_t _internal_interval_ms() const;
void _internal_set_interval_ms(int32_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.HeartbeatConfig)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
bool upload_stat_;
int32_t interval_ms_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT ClientEvent final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.ClientEvent) */ {
public:
inline ClientEvent() : ClientEvent(nullptr) {}
~ClientEvent() override;
explicit PROTOBUF_CONSTEXPR ClientEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

ClientEvent(const ClientEvent& from);
ClientEvent(ClientEvent&& from) noexcept
: ClientEvent() {
*this = ::std::move(from);
}

inline ClientEvent& operator=(const ClientEvent& from) {
CopyFrom(from);
return *this;
}
inline ClientEvent& operator=(ClientEvent&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const ClientEvent& default_instance() {
return *internal_default_instance();
}
static inline const ClientEvent* internal_default_instance() {
return reinterpret_cast<const ClientEvent*>(
&_ClientEvent_default_instance_);
}
static constexpr int kIndexInFileMessages =
6;

friend void swap(ClientEvent& a, ClientEvent& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(ClientEvent* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(ClientEvent* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

ClientEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<ClientEvent>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const ClientEvent& from);
void MergeFrom(const ClientEvent& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(ClientEvent* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.ClientEvent";
}
protected:
explicit ClientEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef ClientEvent_Type Type;
static constexpr Type UNKNOWN =
ClientEvent_Type_UNKNOWN;
static constexpr Type DISCARDED_EVENTS =
ClientEvent_Type_DISCARDED_EVENTS;
static constexpr Type FAILED_CONNECTION =
ClientEvent_Type_FAILED_CONNECTION;
static constexpr Type SUCCESSFUL_CONNECTION =
ClientEvent_Type_SUCCESSFUL_CONNECTION;
static inline bool Type_IsValid(int value) {
return ClientEvent_Type_IsValid(value);
}
static constexpr Type Type_MIN =
ClientEvent_Type_Type_MIN;
static constexpr Type Type_MAX =
ClientEvent_Type_Type_MAX;
static constexpr int Type_ARRAYSIZE =
ClientEvent_Type_Type_ARRAYSIZE;
template<typename T>
static inline const std::string& Type_Name(T enum_t_value) {
static_assert(::std::is_same<T, Type>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function Type_Name.");
return ClientEvent_Type_Name(enum_t_value);
}
static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
Type* value) {
return ClientEvent_Type_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kTypeFieldNumber = 1,
kNumberDiscardedEventsFieldNumber = 100,
kTimeConnectionStartedMsFieldNumber = 202,
kNetworkTypeFieldNumber = 200,
kErrorCodeFieldNumber = 204,
kTimeConnectionEndedMsFieldNumber = 203,
kTimeConnectionEstablishedMsFieldNumber = 300,
};
// optional .mcs_proto.ClientEvent.Type type = 1;
bool has_type() const;
private:
bool _internal_has_type() const;
public:
void clear_type();
::mcs_proto::ClientEvent_Type type() const;
void set_type(::mcs_proto::ClientEvent_Type value);
private:
::mcs_proto::ClientEvent_Type _internal_type() const;
void _internal_set_type(::mcs_proto::ClientEvent_Type value);
public:

// optional uint32 number_discarded_events = 100;
bool has_number_discarded_events() const;
private:
bool _internal_has_number_discarded_events() const;
public:
void clear_number_discarded_events();
uint32_t number_discarded_events() const;
void set_number_discarded_events(uint32_t value);
private:
uint32_t _internal_number_discarded_events() const;
void _internal_set_number_discarded_events(uint32_t value);
public:

// optional uint64 time_connection_started_ms = 202;
bool has_time_connection_started_ms() const;
private:
bool _internal_has_time_connection_started_ms() const;
public:
void clear_time_connection_started_ms();
uint64_t time_connection_started_ms() const;
void set_time_connection_started_ms(uint64_t value);
private:
uint64_t _internal_time_connection_started_ms() const;
void _internal_set_time_connection_started_ms(uint64_t value);
public:

// optional int32 network_type = 200;
bool has_network_type() const;
private:
bool _internal_has_network_type() const;
public:
void clear_network_type();
int32_t network_type() const;
void set_network_type(int32_t value);
private:
int32_t _internal_network_type() const;
void _internal_set_network_type(int32_t value);
public:

// optional int32 error_code = 204;
bool has_error_code() const;
private:
bool _internal_has_error_code() const;
public:
void clear_error_code();
int32_t error_code() const;
void set_error_code(int32_t value);
private:
int32_t _internal_error_code() const;
void _internal_set_error_code(int32_t value);
public:

// optional uint64 time_connection_ended_ms = 203;
bool has_time_connection_ended_ms() const;
private:
bool _internal_has_time_connection_ended_ms() const;
public:
void clear_time_connection_ended_ms();
uint64_t time_connection_ended_ms() const;
void set_time_connection_ended_ms(uint64_t value);
private:
uint64_t _internal_time_connection_ended_ms() const;
void _internal_set_time_connection_ended_ms(uint64_t value);
public:

// optional uint64 time_connection_established_ms = 300;
bool has_time_connection_established_ms() const;
private:
bool _internal_has_time_connection_established_ms() const;
public:
void clear_time_connection_established_ms();
uint64_t time_connection_established_ms() const;
void set_time_connection_established_ms(uint64_t value);
private:
uint64_t _internal_time_connection_established_ms() const;
void _internal_set_time_connection_established_ms(uint64_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.ClientEvent)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
int type_;
uint32_t number_discarded_events_;
uint64_t time_connection_started_ms_;
int32_t network_type_;
int32_t error_code_;
uint64_t time_connection_ended_ms_;
uint64_t time_connection_established_ms_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT LoginRequest final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginRequest) */ {
public:
inline LoginRequest() : LoginRequest(nullptr) {}
~LoginRequest() override;
explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

LoginRequest(const LoginRequest& from);
LoginRequest(LoginRequest&& from) noexcept
: LoginRequest() {
*this = ::std::move(from);
}

inline LoginRequest& operator=(const LoginRequest& from) {
CopyFrom(from);
return *this;
}
inline LoginRequest& operator=(LoginRequest&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const LoginRequest& default_instance() {
return *internal_default_instance();
}
static inline const LoginRequest* internal_default_instance() {
return reinterpret_cast<const LoginRequest*>(
&_LoginRequest_default_instance_);
}
static constexpr int kIndexInFileMessages =
7;

friend void swap(LoginRequest& a, LoginRequest& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(LoginRequest* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(LoginRequest* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<LoginRequest>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const LoginRequest& from);
void MergeFrom(const LoginRequest& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LoginRequest* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.LoginRequest";
}
protected:
explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef LoginRequest_AuthService AuthService;
static constexpr AuthService ANDROID_ID =
LoginRequest_AuthService_ANDROID_ID;
static inline bool AuthService_IsValid(int value) {
return LoginRequest_AuthService_IsValid(value);
}
static constexpr AuthService AuthService_MIN =
LoginRequest_AuthService_AuthService_MIN;
static constexpr AuthService AuthService_MAX =
LoginRequest_AuthService_AuthService_MAX;
static constexpr int AuthService_ARRAYSIZE =
LoginRequest_AuthService_AuthService_ARRAYSIZE;
template<typename T>
static inline const std::string& AuthService_Name(T enum_t_value) {
static_assert(::std::is_same<T, AuthService>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function AuthService_Name.");
return LoginRequest_AuthService_Name(enum_t_value);
}
static inline bool AuthService_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
AuthService* value) {
return LoginRequest_AuthService_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kSettingFieldNumber = 8,
kReceivedPersistentIdFieldNumber = 10,
kClientEventFieldNumber = 22,
kIdFieldNumber = 1,
kDomainFieldNumber = 2,
kUserFieldNumber = 3,
kResourceFieldNumber = 4,
kAuthTokenFieldNumber = 5,
kDeviceIdFieldNumber = 6,
kHeartbeatStatFieldNumber = 13,
kLastRmqIdFieldNumber = 7,
kAdaptiveHeartbeatFieldNumber = 12,
kUseRmq2FieldNumber = 14,
kNetworkTypeFieldNumber = 17,
kAccountIdFieldNumber = 15,
kStatusFieldNumber = 18,
kAuthServiceFieldNumber = 16,
};
// repeated .mcs_proto.Setting setting = 8;
int setting_size() const;
private:
int _internal_setting_size() const;
public:
void clear_setting();
::mcs_proto::Setting* mutable_setting(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
mutable_setting();
private:
const ::mcs_proto::Setting& _internal_setting(int index) const;
::mcs_proto::Setting* _internal_add_setting();
public:
const ::mcs_proto::Setting& setting(int index) const;
::mcs_proto::Setting* add_setting();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
setting() const;

// repeated string received_persistent_id = 10;
int received_persistent_id_size() const;
private:
int _internal_received_persistent_id_size() const;
public:
void clear_received_persistent_id();
const std::string& received_persistent_id(int index) const;
std::string* mutable_received_persistent_id(int index);
void set_received_persistent_id(int index, const std::string& value);
void set_received_persistent_id(int index, std::string&& value);
void set_received_persistent_id(int index, const char* value);
void set_received_persistent_id(int index, const char* value, size_t size);
std::string* add_received_persistent_id();
void add_received_persistent_id(const std::string& value);
void add_received_persistent_id(std::string&& value);
void add_received_persistent_id(const char* value);
void add_received_persistent_id(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& received_persistent_id() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_received_persistent_id();
private:
const std::string& _internal_received_persistent_id(int index) const;
std::string* _internal_add_received_persistent_id();
public:

// repeated .mcs_proto.ClientEvent client_event = 22;
int client_event_size() const;
private:
int _internal_client_event_size() const;
public:
void clear_client_event();
::mcs_proto::ClientEvent* mutable_client_event(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >*
mutable_client_event();
private:
const ::mcs_proto::ClientEvent& _internal_client_event(int index) const;
::mcs_proto::ClientEvent* _internal_add_client_event();
public:
const ::mcs_proto::ClientEvent& client_event(int index) const;
::mcs_proto::ClientEvent* add_client_event();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >&
client_event() const;

// required string id = 1;
bool has_id() const;
private:
bool _internal_has_id() const;
public:
void clear_id();
const std::string& id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_id();
PROTOBUF_NODISCARD std::string* release_id();
void set_allocated_id(std::string* id);
private:
const std::string& _internal_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
std::string* _internal_mutable_id();
public:

// required string domain = 2;
bool has_domain() const;
private:
bool _internal_has_domain() const;
public:
void clear_domain();
const std::string& domain() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_domain(ArgT0&& arg0, ArgT... args);
std::string* mutable_domain();
PROTOBUF_NODISCARD std::string* release_domain();
void set_allocated_domain(std::string* domain);
private:
const std::string& _internal_domain() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_domain(const std::string& value);
std::string* _internal_mutable_domain();
public:

// required string user = 3;
bool has_user() const;
private:
bool _internal_has_user() const;
public:
void clear_user();
const std::string& user() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_user(ArgT0&& arg0, ArgT... args);
std::string* mutable_user();
PROTOBUF_NODISCARD std::string* release_user();
void set_allocated_user(std::string* user);
private:
const std::string& _internal_user() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_user(const std::string& value);
std::string* _internal_mutable_user();
public:

// required string resource = 4;
bool has_resource() const;
private:
bool _internal_has_resource() const;
public:
void clear_resource();
const std::string& resource() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_resource(ArgT0&& arg0, ArgT... args);
std::string* mutable_resource();
PROTOBUF_NODISCARD std::string* release_resource();
void set_allocated_resource(std::string* resource);
private:
const std::string& _internal_resource() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_resource(const std::string& value);
std::string* _internal_mutable_resource();
public:

// required string auth_token = 5;
bool has_auth_token() const;
private:
bool _internal_has_auth_token() const;
public:
void clear_auth_token();
const std::string& auth_token() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_auth_token(ArgT0&& arg0, ArgT... args);
std::string* mutable_auth_token();
PROTOBUF_NODISCARD std::string* release_auth_token();
void set_allocated_auth_token(std::string* auth_token);
private:
const std::string& _internal_auth_token() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_token(const std::string& value);
std::string* _internal_mutable_auth_token();
public:

// optional string device_id = 6;
bool has_device_id() const;
private:
bool _internal_has_device_id() const;
public:
void clear_device_id();
const std::string& device_id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_device_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_device_id();
PROTOBUF_NODISCARD std::string* release_device_id();
void set_allocated_device_id(std::string* device_id);
private:
const std::string& _internal_device_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
std::string* _internal_mutable_device_id();
public:

// optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
bool has_heartbeat_stat() const;
private:
bool _internal_has_heartbeat_stat() const;
public:
void clear_heartbeat_stat();
const ::mcs_proto::HeartbeatStat& heartbeat_stat() const;
PROTOBUF_NODISCARD ::mcs_proto::HeartbeatStat* release_heartbeat_stat();
::mcs_proto::HeartbeatStat* mutable_heartbeat_stat();
void set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat);
private:
const ::mcs_proto::HeartbeatStat& _internal_heartbeat_stat() const;
::mcs_proto::HeartbeatStat* _internal_mutable_heartbeat_stat();
public:
void unsafe_arena_set_allocated_heartbeat_stat(
::mcs_proto::HeartbeatStat* heartbeat_stat);
::mcs_proto::HeartbeatStat* unsafe_arena_release_heartbeat_stat();

// optional int64 last_rmq_id = 7;
bool has_last_rmq_id() const;
private:
bool _internal_has_last_rmq_id() const;
public:
void clear_last_rmq_id();
int64_t last_rmq_id() const;
void set_last_rmq_id(int64_t value);
private:
int64_t _internal_last_rmq_id() const;
void _internal_set_last_rmq_id(int64_t value);
public:

// optional bool adaptive_heartbeat = 12;
bool has_adaptive_heartbeat() const;
private:
bool _internal_has_adaptive_heartbeat() const;
public:
void clear_adaptive_heartbeat();
bool adaptive_heartbeat() const;
void set_adaptive_heartbeat(bool value);
private:
bool _internal_adaptive_heartbeat() const;
void _internal_set_adaptive_heartbeat(bool value);
public:

// optional bool use_rmq2 = 14;
bool has_use_rmq2() const;
private:
bool _internal_has_use_rmq2() const;
public:
void clear_use_rmq2();
bool use_rmq2() const;
void set_use_rmq2(bool value);
private:
bool _internal_use_rmq2() const;
void _internal_set_use_rmq2(bool value);
public:

// optional int32 network_type = 17;
bool has_network_type() const;
private:
bool _internal_has_network_type() const;
public:
void clear_network_type();
int32_t network_type() const;
void set_network_type(int32_t value);
private:
int32_t _internal_network_type() const;
void _internal_set_network_type(int32_t value);
public:

// optional int64 account_id = 15;
bool has_account_id() const;
private:
bool _internal_has_account_id() const;
public:
void clear_account_id();
int64_t account_id() const;
void set_account_id(int64_t value);
private:
int64_t _internal_account_id() const;
void _internal_set_account_id(int64_t value);
public:

// optional int64 status = 18;
bool has_status() const;
private:
bool _internal_has_status() const;
public:
void clear_status();
int64_t status() const;
void set_status(int64_t value);
private:
int64_t _internal_status() const;
void _internal_set_status(int64_t value);
public:

// optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
bool has_auth_service() const;
private:
bool _internal_has_auth_service() const;
public:
void clear_auth_service();
::mcs_proto::LoginRequest_AuthService auth_service() const;
void set_auth_service(::mcs_proto::LoginRequest_AuthService value);
private:
::mcs_proto::LoginRequest_AuthService _internal_auth_service() const;
void _internal_set_auth_service(::mcs_proto::LoginRequest_AuthService value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.LoginRequest)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting > setting_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> received_persistent_id_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent > client_event_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr resource_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
::mcs_proto::HeartbeatStat* heartbeat_stat_;
int64_t last_rmq_id_;
bool adaptive_heartbeat_;
bool use_rmq2_;
int32_t network_type_;
int64_t account_id_;
int64_t status_;
int auth_service_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT LoginResponse final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.LoginResponse) */ {
public:
inline LoginResponse() : LoginResponse(nullptr) {}
~LoginResponse() override;
explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

LoginResponse(const LoginResponse& from);
LoginResponse(LoginResponse&& from) noexcept
: LoginResponse() {
*this = ::std::move(from);
}

inline LoginResponse& operator=(const LoginResponse& from) {
CopyFrom(from);
return *this;
}
inline LoginResponse& operator=(LoginResponse&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const LoginResponse& default_instance() {
return *internal_default_instance();
}
static inline const LoginResponse* internal_default_instance() {
return reinterpret_cast<const LoginResponse*>(
&_LoginResponse_default_instance_);
}
static constexpr int kIndexInFileMessages =
8;

friend void swap(LoginResponse& a, LoginResponse& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(LoginResponse* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(LoginResponse* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<LoginResponse>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const LoginResponse& from);
void MergeFrom(const LoginResponse& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(LoginResponse* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.LoginResponse";
}
protected:
explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kSettingFieldNumber = 4,
kIdFieldNumber = 1,
kJidFieldNumber = 2,
kErrorFieldNumber = 3,
kHeartbeatConfigFieldNumber = 7,
kStreamIdFieldNumber = 5,
kLastStreamIdReceivedFieldNumber = 6,
kServerTimestampFieldNumber = 8,
};
// repeated .mcs_proto.Setting setting = 4;
int setting_size() const;
private:
int _internal_setting_size() const;
public:
void clear_setting();
::mcs_proto::Setting* mutable_setting(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
mutable_setting();
private:
const ::mcs_proto::Setting& _internal_setting(int index) const;
::mcs_proto::Setting* _internal_add_setting();
public:
const ::mcs_proto::Setting& setting(int index) const;
::mcs_proto::Setting* add_setting();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
setting() const;

// required string id = 1;
bool has_id() const;
private:
bool _internal_has_id() const;
public:
void clear_id();
const std::string& id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_id();
PROTOBUF_NODISCARD std::string* release_id();
void set_allocated_id(std::string* id);
private:
const std::string& _internal_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
std::string* _internal_mutable_id();
public:

// optional string jid = 2;
bool has_jid() const;
private:
bool _internal_has_jid() const;
public:
void clear_jid();
const std::string& jid() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_jid(ArgT0&& arg0, ArgT... args);
std::string* mutable_jid();
PROTOBUF_NODISCARD std::string* release_jid();
void set_allocated_jid(std::string* jid);
private:
const std::string& _internal_jid() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_jid(const std::string& value);
std::string* _internal_mutable_jid();
public:

// optional .mcs_proto.ErrorInfo error = 3;
bool has_error() const;
private:
bool _internal_has_error() const;
public:
void clear_error();
const ::mcs_proto::ErrorInfo& error() const;
PROTOBUF_NODISCARD ::mcs_proto::ErrorInfo* release_error();
::mcs_proto::ErrorInfo* mutable_error();
void set_allocated_error(::mcs_proto::ErrorInfo* error);
private:
const ::mcs_proto::ErrorInfo& _internal_error() const;
::mcs_proto::ErrorInfo* _internal_mutable_error();
public:
void unsafe_arena_set_allocated_error(
::mcs_proto::ErrorInfo* error);
::mcs_proto::ErrorInfo* unsafe_arena_release_error();

// optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
bool has_heartbeat_config() const;
private:
bool _internal_has_heartbeat_config() const;
public:
void clear_heartbeat_config();
const ::mcs_proto::HeartbeatConfig& heartbeat_config() const;
PROTOBUF_NODISCARD ::mcs_proto::HeartbeatConfig* release_heartbeat_config();
::mcs_proto::HeartbeatConfig* mutable_heartbeat_config();
void set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config);
private:
const ::mcs_proto::HeartbeatConfig& _internal_heartbeat_config() const;
::mcs_proto::HeartbeatConfig* _internal_mutable_heartbeat_config();
public:
void unsafe_arena_set_allocated_heartbeat_config(
::mcs_proto::HeartbeatConfig* heartbeat_config);
::mcs_proto::HeartbeatConfig* unsafe_arena_release_heartbeat_config();

// optional int32 stream_id = 5;
bool has_stream_id() const;
private:
bool _internal_has_stream_id() const;
public:
void clear_stream_id();
int32_t stream_id() const;
void set_stream_id(int32_t value);
private:
int32_t _internal_stream_id() const;
void _internal_set_stream_id(int32_t value);
public:

// optional int32 last_stream_id_received = 6;
bool has_last_stream_id_received() const;
private:
bool _internal_has_last_stream_id_received() const;
public:
void clear_last_stream_id_received();
int32_t last_stream_id_received() const;
void set_last_stream_id_received(int32_t value);
private:
int32_t _internal_last_stream_id_received() const;
void _internal_set_last_stream_id_received(int32_t value);
public:

// optional int64 server_timestamp = 8;
bool has_server_timestamp() const;
private:
bool _internal_has_server_timestamp() const;
public:
void clear_server_timestamp();
int64_t server_timestamp() const;
void set_server_timestamp(int64_t value);
private:
int64_t _internal_server_timestamp() const;
void _internal_set_server_timestamp(int64_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.LoginResponse)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting > setting_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr jid_;
::mcs_proto::ErrorInfo* error_;
::mcs_proto::HeartbeatConfig* heartbeat_config_;
int32_t stream_id_;
int32_t last_stream_id_received_;
int64_t server_timestamp_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT StreamErrorStanza final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamErrorStanza) */ {
public:
inline StreamErrorStanza() : StreamErrorStanza(nullptr) {}
~StreamErrorStanza() override;
explicit PROTOBUF_CONSTEXPR StreamErrorStanza(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

StreamErrorStanza(const StreamErrorStanza& from);
StreamErrorStanza(StreamErrorStanza&& from) noexcept
: StreamErrorStanza() {
*this = ::std::move(from);
}

inline StreamErrorStanza& operator=(const StreamErrorStanza& from) {
CopyFrom(from);
return *this;
}
inline StreamErrorStanza& operator=(StreamErrorStanza&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const StreamErrorStanza& default_instance() {
return *internal_default_instance();
}
static inline const StreamErrorStanza* internal_default_instance() {
return reinterpret_cast<const StreamErrorStanza*>(
&_StreamErrorStanza_default_instance_);
}
static constexpr int kIndexInFileMessages =
9;

friend void swap(StreamErrorStanza& a, StreamErrorStanza& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(StreamErrorStanza* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(StreamErrorStanza* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

StreamErrorStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<StreamErrorStanza>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const StreamErrorStanza& from);
void MergeFrom(const StreamErrorStanza& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StreamErrorStanza* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.StreamErrorStanza";
}
protected:
explicit StreamErrorStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kTypeFieldNumber = 1,
kTextFieldNumber = 2,
};
// required string type = 1;
bool has_type() const;
private:
bool _internal_has_type() const;
public:
void clear_type();
const std::string& type() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_type(ArgT0&& arg0, ArgT... args);
std::string* mutable_type();
PROTOBUF_NODISCARD std::string* release_type();
void set_allocated_type(std::string* type);
private:
const std::string& _internal_type() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
std::string* _internal_mutable_type();
public:

// optional string text = 2;
bool has_text() const;
private:
bool _internal_has_text() const;
public:
void clear_text();
const std::string& text() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_text(ArgT0&& arg0, ArgT... args);
std::string* mutable_text();
PROTOBUF_NODISCARD std::string* release_text();
void set_allocated_text(std::string* text);
private:
const std::string& _internal_text() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
std::string* _internal_mutable_text();
public:

// @@protoc_insertion_point(class_scope:mcs_proto.StreamErrorStanza)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT Close final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Close) */ {
public:
inline Close() : Close(nullptr) {}
~Close() override;
explicit PROTOBUF_CONSTEXPR Close(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

Close(const Close& from);
Close(Close&& from) noexcept
: Close() {
*this = ::std::move(from);
}

inline Close& operator=(const Close& from) {
CopyFrom(from);
return *this;
}
inline Close& operator=(Close&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const Close& default_instance() {
return *internal_default_instance();
}
static inline const Close* internal_default_instance() {
return reinterpret_cast<const Close*>(
&_Close_default_instance_);
}
static constexpr int kIndexInFileMessages =
10;

friend void swap(Close& a, Close& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(Close* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(Close* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

Close* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<Close>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const Close& from);
void MergeFrom(const Close& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Close* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.Close";
}
protected:
explicit Close(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:mcs_proto.Close)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT Extension final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.Extension) */ {
public:
inline Extension() : Extension(nullptr) {}
~Extension() override;
explicit PROTOBUF_CONSTEXPR Extension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

Extension(const Extension& from);
Extension(Extension&& from) noexcept
: Extension() {
*this = ::std::move(from);
}

inline Extension& operator=(const Extension& from) {
CopyFrom(from);
return *this;
}
inline Extension& operator=(Extension&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const Extension& default_instance() {
return *internal_default_instance();
}
static inline const Extension* internal_default_instance() {
return reinterpret_cast<const Extension*>(
&_Extension_default_instance_);
}
static constexpr int kIndexInFileMessages =
11;

friend void swap(Extension& a, Extension& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(Extension* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(Extension* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

Extension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<Extension>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const Extension& from);
void MergeFrom(const Extension& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(Extension* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.Extension";
}
protected:
explicit Extension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kDataFieldNumber = 2,
kIdFieldNumber = 1,
};
// required bytes data = 2;
bool has_data() const;
private:
bool _internal_has_data() const;
public:
void clear_data();
const std::string& data() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_data(ArgT0&& arg0, ArgT... args);
std::string* mutable_data();
PROTOBUF_NODISCARD std::string* release_data();
void set_allocated_data(std::string* data);
private:
const std::string& _internal_data() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
std::string* _internal_mutable_data();
public:

// required int32 id = 1;
bool has_id() const;
private:
bool _internal_has_id() const;
public:
void clear_id();
int32_t id() const;
void set_id(int32_t value);
private:
int32_t _internal_id() const;
void _internal_set_id(int32_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.Extension)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
int32_t id_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT IqStanza final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.IqStanza) */ {
public:
inline IqStanza() : IqStanza(nullptr) {}
~IqStanza() override;
explicit PROTOBUF_CONSTEXPR IqStanza(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

IqStanza(const IqStanza& from);
IqStanza(IqStanza&& from) noexcept
: IqStanza() {
*this = ::std::move(from);
}

inline IqStanza& operator=(const IqStanza& from) {
CopyFrom(from);
return *this;
}
inline IqStanza& operator=(IqStanza&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const IqStanza& default_instance() {
return *internal_default_instance();
}
static inline const IqStanza* internal_default_instance() {
return reinterpret_cast<const IqStanza*>(
&_IqStanza_default_instance_);
}
static constexpr int kIndexInFileMessages =
12;

friend void swap(IqStanza& a, IqStanza& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(IqStanza* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(IqStanza* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

IqStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<IqStanza>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const IqStanza& from);
void MergeFrom(const IqStanza& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(IqStanza* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.IqStanza";
}
protected:
explicit IqStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

typedef IqStanza_IqType IqType;
static constexpr IqType GET =
IqStanza_IqType_GET;
static constexpr IqType SET =
IqStanza_IqType_SET;
static constexpr IqType RESULT =
IqStanza_IqType_RESULT;
static constexpr IqType IQ_ERROR =
IqStanza_IqType_IQ_ERROR;
static inline bool IqType_IsValid(int value) {
return IqStanza_IqType_IsValid(value);
}
static constexpr IqType IqType_MIN =
IqStanza_IqType_IqType_MIN;
static constexpr IqType IqType_MAX =
IqStanza_IqType_IqType_MAX;
static constexpr int IqType_ARRAYSIZE =
IqStanza_IqType_IqType_ARRAYSIZE;
template<typename T>
static inline const std::string& IqType_Name(T enum_t_value) {
static_assert(::std::is_same<T, IqType>::value ||
::std::is_integral<T>::value,
"Incorrect type passed to function IqType_Name.");
return IqStanza_IqType_Name(enum_t_value);
}
static inline bool IqType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
IqType* value) {
return IqStanza_IqType_Parse(name, value);
}

// accessors -------------------------------------------------------

enum : int {
kIdFieldNumber = 3,
kFromFieldNumber = 4,
kToFieldNumber = 5,
kPersistentIdFieldNumber = 8,
kErrorFieldNumber = 6,
kExtensionFieldNumber = 7,
kRmqIdFieldNumber = 1,
kTypeFieldNumber = 2,
kStreamIdFieldNumber = 9,
kAccountIdFieldNumber = 11,
kStatusFieldNumber = 12,
kLastStreamIdReceivedFieldNumber = 10,
};
// required string id = 3;
bool has_id() const;
private:
bool _internal_has_id() const;
public:
void clear_id();
const std::string& id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_id();
PROTOBUF_NODISCARD std::string* release_id();
void set_allocated_id(std::string* id);
private:
const std::string& _internal_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
std::string* _internal_mutable_id();
public:

// optional string from = 4;
bool has_from() const;
private:
bool _internal_has_from() const;
public:
void clear_from();
const std::string& from() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_from(ArgT0&& arg0, ArgT... args);
std::string* mutable_from();
PROTOBUF_NODISCARD std::string* release_from();
void set_allocated_from(std::string* from);
private:
const std::string& _internal_from() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
std::string* _internal_mutable_from();
public:

// optional string to = 5;
bool has_to() const;
private:
bool _internal_has_to() const;
public:
void clear_to();
const std::string& to() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_to(ArgT0&& arg0, ArgT... args);
std::string* mutable_to();
PROTOBUF_NODISCARD std::string* release_to();
void set_allocated_to(std::string* to);
private:
const std::string& _internal_to() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
std::string* _internal_mutable_to();
public:

// optional string persistent_id = 8;
bool has_persistent_id() const;
private:
bool _internal_has_persistent_id() const;
public:
void clear_persistent_id();
const std::string& persistent_id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_persistent_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_persistent_id();
PROTOBUF_NODISCARD std::string* release_persistent_id();
void set_allocated_persistent_id(std::string* persistent_id);
private:
const std::string& _internal_persistent_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_persistent_id(const std::string& value);
std::string* _internal_mutable_persistent_id();
public:

// optional .mcs_proto.ErrorInfo error = 6;
bool has_error() const;
private:
bool _internal_has_error() const;
public:
void clear_error();
const ::mcs_proto::ErrorInfo& error() const;
PROTOBUF_NODISCARD ::mcs_proto::ErrorInfo* release_error();
::mcs_proto::ErrorInfo* mutable_error();
void set_allocated_error(::mcs_proto::ErrorInfo* error);
private:
const ::mcs_proto::ErrorInfo& _internal_error() const;
::mcs_proto::ErrorInfo* _internal_mutable_error();
public:
void unsafe_arena_set_allocated_error(
::mcs_proto::ErrorInfo* error);
::mcs_proto::ErrorInfo* unsafe_arena_release_error();

// optional .mcs_proto.Extension extension = 7;
bool has_extension() const;
private:
bool _internal_has_extension() const;
public:
void clear_extension();
const ::mcs_proto::Extension& extension() const;
PROTOBUF_NODISCARD ::mcs_proto::Extension* release_extension();
::mcs_proto::Extension* mutable_extension();
void set_allocated_extension(::mcs_proto::Extension* extension);
private:
const ::mcs_proto::Extension& _internal_extension() const;
::mcs_proto::Extension* _internal_mutable_extension();
public:
void unsafe_arena_set_allocated_extension(
::mcs_proto::Extension* extension);
::mcs_proto::Extension* unsafe_arena_release_extension();

// optional int64 rmq_id = 1;
bool has_rmq_id() const;
private:
bool _internal_has_rmq_id() const;
public:
void clear_rmq_id();
int64_t rmq_id() const;
void set_rmq_id(int64_t value);
private:
int64_t _internal_rmq_id() const;
void _internal_set_rmq_id(int64_t value);
public:

// required .mcs_proto.IqStanza.IqType type = 2;
bool has_type() const;
private:
bool _internal_has_type() const;
public:
void clear_type();
::mcs_proto::IqStanza_IqType type() const;
void set_type(::mcs_proto::IqStanza_IqType value);
private:
::mcs_proto::IqStanza_IqType _internal_type() const;
void _internal_set_type(::mcs_proto::IqStanza_IqType value);
public:

// optional int32 stream_id = 9;
bool has_stream_id() const;
private:
bool _internal_has_stream_id() const;
public:
void clear_stream_id();
int32_t stream_id() const;
void set_stream_id(int32_t value);
private:
int32_t _internal_stream_id() const;
void _internal_set_stream_id(int32_t value);
public:

// optional int64 account_id = 11;
bool has_account_id() const;
private:
bool _internal_has_account_id() const;
public:
void clear_account_id();
int64_t account_id() const;
void set_account_id(int64_t value);
private:
int64_t _internal_account_id() const;
void _internal_set_account_id(int64_t value);
public:

// optional int64 status = 12;
bool has_status() const;
private:
bool _internal_has_status() const;
public:
void clear_status();
int64_t status() const;
void set_status(int64_t value);
private:
int64_t _internal_status() const;
void _internal_set_status(int64_t value);
public:

// optional int32 last_stream_id_received = 10;
bool has_last_stream_id_received() const;
private:
bool _internal_has_last_stream_id_received() const;
public:
void clear_last_stream_id_received();
int32_t last_stream_id_received() const;
void set_last_stream_id_received(int32_t value);
private:
int32_t _internal_last_stream_id_received() const;
void _internal_set_last_stream_id_received(int32_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.IqStanza)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistent_id_;
::mcs_proto::ErrorInfo* error_;
::mcs_proto::Extension* extension_;
int64_t rmq_id_;
int type_;
int32_t stream_id_;
int64_t account_id_;
int64_t status_;
int32_t last_stream_id_received_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT AppData final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.AppData) */ {
public:
inline AppData() : AppData(nullptr) {}
~AppData() override;
explicit PROTOBUF_CONSTEXPR AppData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

AppData(const AppData& from);
AppData(AppData&& from) noexcept
: AppData() {
*this = ::std::move(from);
}

inline AppData& operator=(const AppData& from) {
CopyFrom(from);
return *this;
}
inline AppData& operator=(AppData&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const AppData& default_instance() {
return *internal_default_instance();
}
static inline const AppData* internal_default_instance() {
return reinterpret_cast<const AppData*>(
&_AppData_default_instance_);
}
static constexpr int kIndexInFileMessages =
13;

friend void swap(AppData& a, AppData& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(AppData* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(AppData* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

AppData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<AppData>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const AppData& from);
void MergeFrom(const AppData& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(AppData* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.AppData";
}
protected:
explicit AppData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kKeyFieldNumber = 1,
kValueFieldNumber = 2,
};
// required string key = 1;
bool has_key() const;
private:
bool _internal_has_key() const;
public:
void clear_key();
const std::string& key() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_key(ArgT0&& arg0, ArgT... args);
std::string* mutable_key();
PROTOBUF_NODISCARD std::string* release_key();
void set_allocated_key(std::string* key);
private:
const std::string& _internal_key() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
std::string* _internal_mutable_key();
public:

// required string value = 2;
bool has_value() const;
private:
bool _internal_has_value() const;
public:
void clear_value();
const std::string& value() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_value(ArgT0&& arg0, ArgT... args);
std::string* mutable_value();
PROTOBUF_NODISCARD std::string* release_value();
void set_allocated_value(std::string* value);
private:
const std::string& _internal_value() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
std::string* _internal_mutable_value();
public:

// @@protoc_insertion_point(class_scope:mcs_proto.AppData)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT DataMessageStanza final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.DataMessageStanza) */ {
public:
inline DataMessageStanza() : DataMessageStanza(nullptr) {}
~DataMessageStanza() override;
explicit PROTOBUF_CONSTEXPR DataMessageStanza(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

DataMessageStanza(const DataMessageStanza& from);
DataMessageStanza(DataMessageStanza&& from) noexcept
: DataMessageStanza() {
*this = ::std::move(from);
}

inline DataMessageStanza& operator=(const DataMessageStanza& from) {
CopyFrom(from);
return *this;
}
inline DataMessageStanza& operator=(DataMessageStanza&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const DataMessageStanza& default_instance() {
return *internal_default_instance();
}
static inline const DataMessageStanza* internal_default_instance() {
return reinterpret_cast<const DataMessageStanza*>(
&_DataMessageStanza_default_instance_);
}
static constexpr int kIndexInFileMessages =
14;

friend void swap(DataMessageStanza& a, DataMessageStanza& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(DataMessageStanza* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(DataMessageStanza* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

DataMessageStanza* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<DataMessageStanza>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const DataMessageStanza& from);
void MergeFrom(const DataMessageStanza& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(DataMessageStanza* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.DataMessageStanza";
}
protected:
explicit DataMessageStanza(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kAppDataFieldNumber = 7,
kIdFieldNumber = 2,
kFromFieldNumber = 3,
kToFieldNumber = 4,
kCategoryFieldNumber = 5,
kTokenFieldNumber = 6,
kPersistentIdFieldNumber = 9,
kRegIdFieldNumber = 13,
kRawDataFieldNumber = 21,
kStreamIdFieldNumber = 10,
kLastStreamIdReceivedFieldNumber = 11,
kDeviceUserIdFieldNumber = 16,
kFromTrustedServerFieldNumber = 8,
kImmediateAckFieldNumber = 24,
kTtlFieldNumber = 17,
kSentFieldNumber = 18,
kStatusFieldNumber = 20,
kQueuedFieldNumber = 19,
};
// repeated .mcs_proto.AppData app_data = 7;
int app_data_size() const;
private:
int _internal_app_data_size() const;
public:
void clear_app_data();
::mcs_proto::AppData* mutable_app_data(int index);
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >*
mutable_app_data();
private:
const ::mcs_proto::AppData& _internal_app_data(int index) const;
::mcs_proto::AppData* _internal_add_app_data();
public:
const ::mcs_proto::AppData& app_data(int index) const;
::mcs_proto::AppData* add_app_data();
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >&
app_data() const;

// optional string id = 2;
bool has_id() const;
private:
bool _internal_has_id() const;
public:
void clear_id();
const std::string& id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_id();
PROTOBUF_NODISCARD std::string* release_id();
void set_allocated_id(std::string* id);
private:
const std::string& _internal_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
std::string* _internal_mutable_id();
public:

// required string from = 3;
bool has_from() const;
private:
bool _internal_has_from() const;
public:
void clear_from();
const std::string& from() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_from(ArgT0&& arg0, ArgT... args);
std::string* mutable_from();
PROTOBUF_NODISCARD std::string* release_from();
void set_allocated_from(std::string* from);
private:
const std::string& _internal_from() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_from(const std::string& value);
std::string* _internal_mutable_from();
public:

// optional string to = 4;
bool has_to() const;
private:
bool _internal_has_to() const;
public:
void clear_to();
const std::string& to() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_to(ArgT0&& arg0, ArgT... args);
std::string* mutable_to();
PROTOBUF_NODISCARD std::string* release_to();
void set_allocated_to(std::string* to);
private:
const std::string& _internal_to() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_to(const std::string& value);
std::string* _internal_mutable_to();
public:

// required string category = 5;
bool has_category() const;
private:
bool _internal_has_category() const;
public:
void clear_category();
const std::string& category() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_category(ArgT0&& arg0, ArgT... args);
std::string* mutable_category();
PROTOBUF_NODISCARD std::string* release_category();
void set_allocated_category(std::string* category);
private:
const std::string& _internal_category() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_category(const std::string& value);
std::string* _internal_mutable_category();
public:

// optional string token = 6;
bool has_token() const;
private:
bool _internal_has_token() const;
public:
void clear_token();
const std::string& token() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_token(ArgT0&& arg0, ArgT... args);
std::string* mutable_token();
PROTOBUF_NODISCARD std::string* release_token();
void set_allocated_token(std::string* token);
private:
const std::string& _internal_token() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
std::string* _internal_mutable_token();
public:

// optional string persistent_id = 9;
bool has_persistent_id() const;
private:
bool _internal_has_persistent_id() const;
public:
void clear_persistent_id();
const std::string& persistent_id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_persistent_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_persistent_id();
PROTOBUF_NODISCARD std::string* release_persistent_id();
void set_allocated_persistent_id(std::string* persistent_id);
private:
const std::string& _internal_persistent_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_persistent_id(const std::string& value);
std::string* _internal_mutable_persistent_id();
public:

// optional string reg_id = 13;
bool has_reg_id() const;
private:
bool _internal_has_reg_id() const;
public:
void clear_reg_id();
const std::string& reg_id() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_reg_id(ArgT0&& arg0, ArgT... args);
std::string* mutable_reg_id();
PROTOBUF_NODISCARD std::string* release_reg_id();
void set_allocated_reg_id(std::string* reg_id);
private:
const std::string& _internal_reg_id() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_reg_id(const std::string& value);
std::string* _internal_mutable_reg_id();
public:

// optional bytes raw_data = 21;
bool has_raw_data() const;
private:
bool _internal_has_raw_data() const;
public:
void clear_raw_data();
const std::string& raw_data() const;
template <typename ArgT0 = const std::string&, typename... ArgT>
void set_raw_data(ArgT0&& arg0, ArgT... args);
std::string* mutable_raw_data();
PROTOBUF_NODISCARD std::string* release_raw_data();
void set_allocated_raw_data(std::string* raw_data);
private:
const std::string& _internal_raw_data() const;
inline PROTOBUF_ALWAYS_INLINE void _internal_set_raw_data(const std::string& value);
std::string* _internal_mutable_raw_data();
public:

// optional int32 stream_id = 10;
bool has_stream_id() const;
private:
bool _internal_has_stream_id() const;
public:
void clear_stream_id();
int32_t stream_id() const;
void set_stream_id(int32_t value);
private:
int32_t _internal_stream_id() const;
void _internal_set_stream_id(int32_t value);
public:

// optional int32 last_stream_id_received = 11;
bool has_last_stream_id_received() const;
private:
bool _internal_has_last_stream_id_received() const;
public:
void clear_last_stream_id_received();
int32_t last_stream_id_received() const;
void set_last_stream_id_received(int32_t value);
private:
int32_t _internal_last_stream_id_received() const;
void _internal_set_last_stream_id_received(int32_t value);
public:

// optional int64 device_user_id = 16;
bool has_device_user_id() const;
private:
bool _internal_has_device_user_id() const;
public:
void clear_device_user_id();
int64_t device_user_id() const;
void set_device_user_id(int64_t value);
private:
int64_t _internal_device_user_id() const;
void _internal_set_device_user_id(int64_t value);
public:

// optional bool from_trusted_server = 8;
bool has_from_trusted_server() const;
private:
bool _internal_has_from_trusted_server() const;
public:
void clear_from_trusted_server();
bool from_trusted_server() const;
void set_from_trusted_server(bool value);
private:
bool _internal_from_trusted_server() const;
void _internal_set_from_trusted_server(bool value);
public:

// optional bool immediate_ack = 24;
bool has_immediate_ack() const;
private:
bool _internal_has_immediate_ack() const;
public:
void clear_immediate_ack();
bool immediate_ack() const;
void set_immediate_ack(bool value);
private:
bool _internal_immediate_ack() const;
void _internal_set_immediate_ack(bool value);
public:

// optional int32 ttl = 17;
bool has_ttl() const;
private:
bool _internal_has_ttl() const;
public:
void clear_ttl();
int32_t ttl() const;
void set_ttl(int32_t value);
private:
int32_t _internal_ttl() const;
void _internal_set_ttl(int32_t value);
public:

// optional int64 sent = 18;
bool has_sent() const;
private:
bool _internal_has_sent() const;
public:
void clear_sent();
int64_t sent() const;
void set_sent(int64_t value);
private:
int64_t _internal_sent() const;
void _internal_set_sent(int64_t value);
public:

// optional int64 status = 20;
bool has_status() const;
private:
bool _internal_has_status() const;
public:
void clear_status();
int64_t status() const;
void set_status(int64_t value);
private:
int64_t _internal_status() const;
void _internal_set_status(int64_t value);
public:

// optional int32 queued = 19;
bool has_queued() const;
private:
bool _internal_has_queued() const;
public:
void clear_queued();
int32_t queued() const;
void set_queued(int32_t value);
private:
int32_t _internal_queued() const;
void _internal_set_queued(int32_t value);
public:

// @@protoc_insertion_point(class_scope:mcs_proto.DataMessageStanza)
private:
class _Internal;

// helper for ByteSizeLong()
size_t RequiredFieldsByteSizeFallback() const;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData > app_data_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr from_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr to_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr category_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr persistent_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reg_id_;
::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr raw_data_;
int32_t stream_id_;
int32_t last_stream_id_received_;
int64_t device_user_id_;
bool from_trusted_server_;
bool immediate_ack_;
int32_t ttl_;
int64_t sent_;
int64_t status_;
int32_t queued_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT StreamAck final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.StreamAck) */ {
public:
inline StreamAck() : StreamAck(nullptr) {}
~StreamAck() override;
explicit PROTOBUF_CONSTEXPR StreamAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

StreamAck(const StreamAck& from);
StreamAck(StreamAck&& from) noexcept
: StreamAck() {
*this = ::std::move(from);
}

inline StreamAck& operator=(const StreamAck& from) {
CopyFrom(from);
return *this;
}
inline StreamAck& operator=(StreamAck&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const StreamAck& default_instance() {
return *internal_default_instance();
}
static inline const StreamAck* internal_default_instance() {
return reinterpret_cast<const StreamAck*>(
&_StreamAck_default_instance_);
}
static constexpr int kIndexInFileMessages =
15;

friend void swap(StreamAck& a, StreamAck& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(StreamAck* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(StreamAck* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

StreamAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<StreamAck>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const StreamAck& from);
void MergeFrom(const StreamAck& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(StreamAck* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.StreamAck";
}
protected:
explicit StreamAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

// @@protoc_insertion_point(class_scope:mcs_proto.StreamAck)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_mcs_2eproto;
};
// -------------------------------------------------------------------

class GCM_EXPORT SelectiveAck final :
public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:mcs_proto.SelectiveAck) */ {
public:
inline SelectiveAck() : SelectiveAck(nullptr) {}
~SelectiveAck() override;
explicit PROTOBUF_CONSTEXPR SelectiveAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

SelectiveAck(const SelectiveAck& from);
SelectiveAck(SelectiveAck&& from) noexcept
: SelectiveAck() {
*this = ::std::move(from);
}

inline SelectiveAck& operator=(const SelectiveAck& from) {
CopyFrom(from);
return *this;
}
inline SelectiveAck& operator=(SelectiveAck&& from) noexcept {
if (this == &from) return *this;
if (GetOwningArena() == from.GetOwningArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
&& GetOwningArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
) {
InternalSwap(&from);
} else {
CopyFrom(from);
}
return *this;
}

inline const std::string& unknown_fields() const {
return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
}
inline std::string* mutable_unknown_fields() {
return _internal_metadata_.mutable_unknown_fields<std::string>();
}

static const SelectiveAck& default_instance() {
return *internal_default_instance();
}
static inline const SelectiveAck* internal_default_instance() {
return reinterpret_cast<const SelectiveAck*>(
&_SelectiveAck_default_instance_);
}
static constexpr int kIndexInFileMessages =
16;

friend void swap(SelectiveAck& a, SelectiveAck& b) {
a.Swap(&b);
}
PROTOBUF_NOINLINE void Swap(SelectiveAck* other) {
if (other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() != nullptr &&
GetOwningArena() == other->GetOwningArena()) {
#else  // PROTOBUF_FORCE_COPY_IN_SWAP
if (GetOwningArena() == other->GetOwningArena()) {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
InternalSwap(other);
} else {
::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
}
}
void UnsafeArenaSwap(SelectiveAck* other) {
if (other == this) return;
GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
InternalSwap(other);
}

// implements Message ----------------------------------------------

SelectiveAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
return CreateMaybeMessage<SelectiveAck>(arena);
}
void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
void CopyFrom(const SelectiveAck& from);
void MergeFrom(const SelectiveAck& from);
PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
bool IsInitialized() const final;

size_t ByteSizeLong() const final;
const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
uint8_t* _InternalSerialize(
uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
int GetCachedSize() const final { return _cached_size_.Get(); }

private:
void SharedCtor();
void SharedDtor();
void SetCachedSize(int size) const;
void InternalSwap(SelectiveAck* other);

private:
friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
return "mcs_proto.SelectiveAck";
}
protected:
explicit SelectiveAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
bool is_message_owned = false);
public:

std::string GetTypeName() const final;

// nested types ----------------------------------------------------

// accessors -------------------------------------------------------

enum : int {
kIdFieldNumber = 1,
};
// repeated string id = 1;
int id_size() const;
private:
int _internal_id_size() const;
public:
void clear_id();
const std::string& id(int index) const;
std::string* mutable_id(int index);
void set_id(int index, const std::string& value);
void set_id(int index, std::string&& value);
void set_id(int index, const char* value);
void set_id(int index, const char* value, size_t size);
std::string* add_id();
void add_id(const std::string& value);
void add_id(std::string&& value);
void add_id(const char* value);
void add_id(const char* value, size_t size);
const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& id() const;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_id();
private:
const std::string& _internal_id(int index) const;
std::string* _internal_add_id();
public:

// @@protoc_insertion_point(class_scope:mcs_proto.SelectiveAck)
private:
class _Internal;

template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
typedef void InternalArenaConstructable_;
typedef void DestructorSkippable_;
::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> id_;
mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
friend struct ::TableStruct_mcs_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeartbeatPing

// optional int32 stream_id = 1;
inline bool HeartbeatPing::_internal_has_stream_id() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool HeartbeatPing::has_stream_id() const {
return _internal_has_stream_id();
}
inline void HeartbeatPing::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline int32_t HeartbeatPing::_internal_stream_id() const {
return stream_id_;
}
inline int32_t HeartbeatPing::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.stream_id)
return _internal_stream_id();
}
inline void HeartbeatPing::_internal_set_stream_id(int32_t value) {
_has_bits_[0] |= 0x00000001u;
stream_id_ = value;
}
inline void HeartbeatPing::set_stream_id(int32_t value) {
_internal_set_stream_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatPing::_internal_has_last_stream_id_received() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool HeartbeatPing::has_last_stream_id_received() const {
return _internal_has_last_stream_id_received();
}
inline void HeartbeatPing::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline int32_t HeartbeatPing::_internal_last_stream_id_received() const {
return last_stream_id_received_;
}
inline int32_t HeartbeatPing::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.last_stream_id_received)
return _internal_last_stream_id_received();
}
inline void HeartbeatPing::_internal_set_last_stream_id_received(int32_t value) {
_has_bits_[0] |= 0x00000002u;
last_stream_id_received_ = value;
}
inline void HeartbeatPing::set_last_stream_id_received(int32_t value) {
_internal_set_last_stream_id_received(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatPing::_internal_has_status() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool HeartbeatPing::has_status() const {
return _internal_has_status();
}
inline void HeartbeatPing::clear_status() {
status_ = int64_t{0};
_has_bits_[0] &= ~0x00000004u;
}
inline int64_t HeartbeatPing::_internal_status() const {
return status_;
}
inline int64_t HeartbeatPing::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatPing.status)
return _internal_status();
}
inline void HeartbeatPing::_internal_set_status(int64_t value) {
_has_bits_[0] |= 0x00000004u;
status_ = value;
}
inline void HeartbeatPing::set_status(int64_t value) {
_internal_set_status(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatPing.status)
}

// -------------------------------------------------------------------

// HeartbeatAck

// optional int32 stream_id = 1;
inline bool HeartbeatAck::_internal_has_stream_id() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool HeartbeatAck::has_stream_id() const {
return _internal_has_stream_id();
}
inline void HeartbeatAck::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline int32_t HeartbeatAck::_internal_stream_id() const {
return stream_id_;
}
inline int32_t HeartbeatAck::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.stream_id)
return _internal_stream_id();
}
inline void HeartbeatAck::_internal_set_stream_id(int32_t value) {
_has_bits_[0] |= 0x00000001u;
stream_id_ = value;
}
inline void HeartbeatAck::set_stream_id(int32_t value) {
_internal_set_stream_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.stream_id)
}

// optional int32 last_stream_id_received = 2;
inline bool HeartbeatAck::_internal_has_last_stream_id_received() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool HeartbeatAck::has_last_stream_id_received() const {
return _internal_has_last_stream_id_received();
}
inline void HeartbeatAck::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline int32_t HeartbeatAck::_internal_last_stream_id_received() const {
return last_stream_id_received_;
}
inline int32_t HeartbeatAck::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.last_stream_id_received)
return _internal_last_stream_id_received();
}
inline void HeartbeatAck::_internal_set_last_stream_id_received(int32_t value) {
_has_bits_[0] |= 0x00000002u;
last_stream_id_received_ = value;
}
inline void HeartbeatAck::set_last_stream_id_received(int32_t value) {
_internal_set_last_stream_id_received(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.last_stream_id_received)
}

// optional int64 status = 3;
inline bool HeartbeatAck::_internal_has_status() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool HeartbeatAck::has_status() const {
return _internal_has_status();
}
inline void HeartbeatAck::clear_status() {
status_ = int64_t{0};
_has_bits_[0] &= ~0x00000004u;
}
inline int64_t HeartbeatAck::_internal_status() const {
return status_;
}
inline int64_t HeartbeatAck::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatAck.status)
return _internal_status();
}
inline void HeartbeatAck::_internal_set_status(int64_t value) {
_has_bits_[0] |= 0x00000004u;
status_ = value;
}
inline void HeartbeatAck::set_status(int64_t value) {
_internal_set_status(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatAck.status)
}

// -------------------------------------------------------------------

// ErrorInfo

// required int32 code = 1;
inline bool ErrorInfo::_internal_has_code() const {
bool value = (_has_bits_[0] & 0x00000008u) != 0;
return value;
}
inline bool ErrorInfo::has_code() const {
return _internal_has_code();
}
inline void ErrorInfo::clear_code() {
code_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline int32_t ErrorInfo::_internal_code() const {
return code_;
}
inline int32_t ErrorInfo::code() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.code)
return _internal_code();
}
inline void ErrorInfo::_internal_set_code(int32_t value) {
_has_bits_[0] |= 0x00000008u;
code_ = value;
}
inline void ErrorInfo::set_code(int32_t value) {
_internal_set_code(value);
// @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.code)
}

// optional string message = 2;
inline bool ErrorInfo::_internal_has_message() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool ErrorInfo::has_message() const {
return _internal_has_message();
}
inline void ErrorInfo::clear_message() {
message_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ErrorInfo::message() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.message)
return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_message(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.message)
}
inline std::string* ErrorInfo::mutable_message() {
std::string* _s = _internal_mutable_message();
// @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.message)
return _s;
}
inline const std::string& ErrorInfo::_internal_message() const {
return message_.Get();
}
inline void ErrorInfo::_internal_set_message(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
message_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_message() {
_has_bits_[0] |= 0x00000001u;
return message_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_message() {
// @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.message)
if (!_internal_has_message()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (message_.IsDefault()) {
message_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void ErrorInfo::set_allocated_message(std::string* message) {
if (message != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (message_.IsDefault()) {
message_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.message)
}

// optional string type = 3;
inline bool ErrorInfo::_internal_has_type() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool ErrorInfo::has_type() const {
return _internal_has_type();
}
inline void ErrorInfo::clear_type() {
type_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ErrorInfo::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.type)
return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ErrorInfo::set_type(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.ErrorInfo.type)
}
inline std::string* ErrorInfo::mutable_type() {
std::string* _s = _internal_mutable_type();
// @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.type)
return _s;
}
inline const std::string& ErrorInfo::_internal_type() const {
return type_.Get();
}
inline void ErrorInfo::_internal_set_type(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
type_.Set(value, GetArenaForAllocation());
}
inline std::string* ErrorInfo::_internal_mutable_type() {
_has_bits_[0] |= 0x00000002u;
return type_.Mutable(GetArenaForAllocation());
}
inline std::string* ErrorInfo::release_type() {
// @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.type)
if (!_internal_has_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (type_.IsDefault()) {
type_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void ErrorInfo::set_allocated_type(std::string* type) {
if (type != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (type_.IsDefault()) {
type_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.type)
}

// optional .mcs_proto.Extension extension = 4;
inline bool ErrorInfo::_internal_has_extension() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
PROTOBUF_ASSUME(!value || extension_ != nullptr);
return value;
}
inline bool ErrorInfo::has_extension() const {
return _internal_has_extension();
}
inline void ErrorInfo::clear_extension() {
if (extension_ != nullptr) extension_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs_proto::Extension& ErrorInfo::_internal_extension() const {
const ::mcs_proto::Extension* p = extension_;
return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::Extension&>(
::mcs_proto::_Extension_default_instance_);
}
inline const ::mcs_proto::Extension& ErrorInfo::extension() const {
// @@protoc_insertion_point(field_get:mcs_proto.ErrorInfo.extension)
return _internal_extension();
}
inline void ErrorInfo::unsafe_arena_set_allocated_extension(
::mcs_proto::Extension* extension) {
if (GetArenaForAllocation() == nullptr) {
delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_);
}
extension_ = extension;
if (extension) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
// @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.ErrorInfo.extension)
}
inline ::mcs_proto::Extension* ErrorInfo::release_extension() {
_has_bits_[0] &= ~0x00000004u;
::mcs_proto::Extension* temp = extension_;
extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
if (GetArenaForAllocation() != nullptr) {
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
return temp;
}
inline ::mcs_proto::Extension* ErrorInfo::unsafe_arena_release_extension() {
// @@protoc_insertion_point(field_release:mcs_proto.ErrorInfo.extension)
_has_bits_[0] &= ~0x00000004u;
::mcs_proto::Extension* temp = extension_;
extension_ = nullptr;
return temp;
}
inline ::mcs_proto::Extension* ErrorInfo::_internal_mutable_extension() {
_has_bits_[0] |= 0x00000004u;
if (extension_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::Extension>(GetArenaForAllocation());
extension_ = p;
}
return extension_;
}
inline ::mcs_proto::Extension* ErrorInfo::mutable_extension() {
::mcs_proto::Extension* _msg = _internal_mutable_extension();
// @@protoc_insertion_point(field_mutable:mcs_proto.ErrorInfo.extension)
return _msg;
}
inline void ErrorInfo::set_allocated_extension(::mcs_proto::Extension* extension) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
if (message_arena == nullptr) {
delete extension_;
}
if (extension) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extension);
if (message_arena != submessage_arena) {
extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, extension, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
extension_ = extension;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.ErrorInfo.extension)
}

// -------------------------------------------------------------------

// Setting

// required string name = 1;
inline bool Setting::_internal_has_name() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool Setting::has_name() const {
return _internal_has_name();
}
inline void Setting::clear_name() {
name_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Setting::name() const {
// @@protoc_insertion_point(field_get:mcs_proto.Setting.name)
return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Setting::set_name(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.Setting.name)
}
inline std::string* Setting::mutable_name() {
std::string* _s = _internal_mutable_name();
// @@protoc_insertion_point(field_mutable:mcs_proto.Setting.name)
return _s;
}
inline const std::string& Setting::_internal_name() const {
return name_.Get();
}
inline void Setting::_internal_set_name(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
name_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_name() {
_has_bits_[0] |= 0x00000001u;
return name_.Mutable(GetArenaForAllocation());
}
inline std::string* Setting::release_name() {
// @@protoc_insertion_point(field_release:mcs_proto.Setting.name)
if (!_internal_has_name()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (name_.IsDefault()) {
name_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void Setting::set_allocated_name(std::string* name) {
if (name != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (name_.IsDefault()) {
name_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.name)
}

// required string value = 2;
inline bool Setting::_internal_has_value() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool Setting::has_value() const {
return _internal_has_value();
}
inline void Setting::clear_value() {
value_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Setting::value() const {
// @@protoc_insertion_point(field_get:mcs_proto.Setting.value)
return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Setting::set_value(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.Setting.value)
}
inline std::string* Setting::mutable_value() {
std::string* _s = _internal_mutable_value();
// @@protoc_insertion_point(field_mutable:mcs_proto.Setting.value)
return _s;
}
inline const std::string& Setting::_internal_value() const {
return value_.Get();
}
inline void Setting::_internal_set_value(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
value_.Set(value, GetArenaForAllocation());
}
inline std::string* Setting::_internal_mutable_value() {
_has_bits_[0] |= 0x00000002u;
return value_.Mutable(GetArenaForAllocation());
}
inline std::string* Setting::release_value() {
// @@protoc_insertion_point(field_release:mcs_proto.Setting.value)
if (!_internal_has_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (value_.IsDefault()) {
value_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void Setting::set_allocated_value(std::string* value) {
if (value != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (value_.IsDefault()) {
value_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.Setting.value)
}

// -------------------------------------------------------------------

// HeartbeatStat

// required string ip = 1;
inline bool HeartbeatStat::_internal_has_ip() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool HeartbeatStat::has_ip() const {
return _internal_has_ip();
}
inline void HeartbeatStat::clear_ip() {
ip_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeartbeatStat::ip() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.ip)
return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatStat::set_ip(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.ip)
}
inline std::string* HeartbeatStat::mutable_ip() {
std::string* _s = _internal_mutable_ip();
// @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatStat.ip)
return _s;
}
inline const std::string& HeartbeatStat::_internal_ip() const {
return ip_.Get();
}
inline void HeartbeatStat::_internal_set_ip(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
ip_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartbeatStat::_internal_mutable_ip() {
_has_bits_[0] |= 0x00000001u;
return ip_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartbeatStat::release_ip() {
// @@protoc_insertion_point(field_release:mcs_proto.HeartbeatStat.ip)
if (!_internal_has_ip()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (ip_.IsDefault()) {
ip_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void HeartbeatStat::set_allocated_ip(std::string* ip) {
if (ip != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (ip_.IsDefault()) {
ip_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatStat.ip)
}

// required bool timeout = 2;
inline bool HeartbeatStat::_internal_has_timeout() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool HeartbeatStat::has_timeout() const {
return _internal_has_timeout();
}
inline void HeartbeatStat::clear_timeout() {
timeout_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool HeartbeatStat::_internal_timeout() const {
return timeout_;
}
inline bool HeartbeatStat::timeout() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.timeout)
return _internal_timeout();
}
inline void HeartbeatStat::_internal_set_timeout(bool value) {
_has_bits_[0] |= 0x00000002u;
timeout_ = value;
}
inline void HeartbeatStat::set_timeout(bool value) {
_internal_set_timeout(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.timeout)
}

// required int32 interval_ms = 3;
inline bool HeartbeatStat::_internal_has_interval_ms() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool HeartbeatStat::has_interval_ms() const {
return _internal_has_interval_ms();
}
inline void HeartbeatStat::clear_interval_ms() {
interval_ms_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline int32_t HeartbeatStat::_internal_interval_ms() const {
return interval_ms_;
}
inline int32_t HeartbeatStat::interval_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatStat.interval_ms)
return _internal_interval_ms();
}
inline void HeartbeatStat::_internal_set_interval_ms(int32_t value) {
_has_bits_[0] |= 0x00000004u;
interval_ms_ = value;
}
inline void HeartbeatStat::set_interval_ms(int32_t value) {
_internal_set_interval_ms(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatStat.interval_ms)
}

// -------------------------------------------------------------------

// HeartbeatConfig

// optional bool upload_stat = 1;
inline bool HeartbeatConfig::_internal_has_upload_stat() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool HeartbeatConfig::has_upload_stat() const {
return _internal_has_upload_stat();
}
inline void HeartbeatConfig::clear_upload_stat() {
upload_stat_ = false;
_has_bits_[0] &= ~0x00000002u;
}
inline bool HeartbeatConfig::_internal_upload_stat() const {
return upload_stat_;
}
inline bool HeartbeatConfig::upload_stat() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.upload_stat)
return _internal_upload_stat();
}
inline void HeartbeatConfig::_internal_set_upload_stat(bool value) {
_has_bits_[0] |= 0x00000002u;
upload_stat_ = value;
}
inline void HeartbeatConfig::set_upload_stat(bool value) {
_internal_set_upload_stat(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.upload_stat)
}

// optional string ip = 2;
inline bool HeartbeatConfig::_internal_has_ip() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool HeartbeatConfig::has_ip() const {
return _internal_has_ip();
}
inline void HeartbeatConfig::clear_ip() {
ip_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HeartbeatConfig::ip() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.ip)
return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HeartbeatConfig::set_ip(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
ip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.ip)
}
inline std::string* HeartbeatConfig::mutable_ip() {
std::string* _s = _internal_mutable_ip();
// @@protoc_insertion_point(field_mutable:mcs_proto.HeartbeatConfig.ip)
return _s;
}
inline const std::string& HeartbeatConfig::_internal_ip() const {
return ip_.Get();
}
inline void HeartbeatConfig::_internal_set_ip(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
ip_.Set(value, GetArenaForAllocation());
}
inline std::string* HeartbeatConfig::_internal_mutable_ip() {
_has_bits_[0] |= 0x00000001u;
return ip_.Mutable(GetArenaForAllocation());
}
inline std::string* HeartbeatConfig::release_ip() {
// @@protoc_insertion_point(field_release:mcs_proto.HeartbeatConfig.ip)
if (!_internal_has_ip()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = ip_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (ip_.IsDefault()) {
ip_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void HeartbeatConfig::set_allocated_ip(std::string* ip) {
if (ip != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
ip_.SetAllocated(ip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (ip_.IsDefault()) {
ip_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.HeartbeatConfig.ip)
}

// optional int32 interval_ms = 3;
inline bool HeartbeatConfig::_internal_has_interval_ms() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool HeartbeatConfig::has_interval_ms() const {
return _internal_has_interval_ms();
}
inline void HeartbeatConfig::clear_interval_ms() {
interval_ms_ = 0;
_has_bits_[0] &= ~0x00000004u;
}
inline int32_t HeartbeatConfig::_internal_interval_ms() const {
return interval_ms_;
}
inline int32_t HeartbeatConfig::interval_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.HeartbeatConfig.interval_ms)
return _internal_interval_ms();
}
inline void HeartbeatConfig::_internal_set_interval_ms(int32_t value) {
_has_bits_[0] |= 0x00000004u;
interval_ms_ = value;
}
inline void HeartbeatConfig::set_interval_ms(int32_t value) {
_internal_set_interval_ms(value);
// @@protoc_insertion_point(field_set:mcs_proto.HeartbeatConfig.interval_ms)
}

// -------------------------------------------------------------------

// ClientEvent

// optional .mcs_proto.ClientEvent.Type type = 1;
inline bool ClientEvent::_internal_has_type() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool ClientEvent::has_type() const {
return _internal_has_type();
}
inline void ClientEvent::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00000001u;
}
inline ::mcs_proto::ClientEvent_Type ClientEvent::_internal_type() const {
return static_cast< ::mcs_proto::ClientEvent_Type >(type_);
}
inline ::mcs_proto::ClientEvent_Type ClientEvent::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.type)
return _internal_type();
}
inline void ClientEvent::_internal_set_type(::mcs_proto::ClientEvent_Type value) {
assert(::mcs_proto::ClientEvent_Type_IsValid(value));
_has_bits_[0] |= 0x00000001u;
type_ = value;
}
inline void ClientEvent::set_type(::mcs_proto::ClientEvent_Type value) {
_internal_set_type(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.type)
}

// optional uint32 number_discarded_events = 100;
inline bool ClientEvent::_internal_has_number_discarded_events() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool ClientEvent::has_number_discarded_events() const {
return _internal_has_number_discarded_events();
}
inline void ClientEvent::clear_number_discarded_events() {
number_discarded_events_ = 0u;
_has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ClientEvent::_internal_number_discarded_events() const {
return number_discarded_events_;
}
inline uint32_t ClientEvent::number_discarded_events() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.number_discarded_events)
return _internal_number_discarded_events();
}
inline void ClientEvent::_internal_set_number_discarded_events(uint32_t value) {
_has_bits_[0] |= 0x00000002u;
number_discarded_events_ = value;
}
inline void ClientEvent::set_number_discarded_events(uint32_t value) {
_internal_set_number_discarded_events(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.number_discarded_events)
}

// optional int32 network_type = 200;
inline bool ClientEvent::_internal_has_network_type() const {
bool value = (_has_bits_[0] & 0x00000008u) != 0;
return value;
}
inline bool ClientEvent::has_network_type() const {
return _internal_has_network_type();
}
inline void ClientEvent::clear_network_type() {
network_type_ = 0;
_has_bits_[0] &= ~0x00000008u;
}
inline int32_t ClientEvent::_internal_network_type() const {
return network_type_;
}
inline int32_t ClientEvent::network_type() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.network_type)
return _internal_network_type();
}
inline void ClientEvent::_internal_set_network_type(int32_t value) {
_has_bits_[0] |= 0x00000008u;
network_type_ = value;
}
inline void ClientEvent::set_network_type(int32_t value) {
_internal_set_network_type(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.network_type)
}

// optional uint64 time_connection_started_ms = 202;
inline bool ClientEvent::_internal_has_time_connection_started_ms() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool ClientEvent::has_time_connection_started_ms() const {
return _internal_has_time_connection_started_ms();
}
inline void ClientEvent::clear_time_connection_started_ms() {
time_connection_started_ms_ = uint64_t{0u};
_has_bits_[0] &= ~0x00000004u;
}
inline uint64_t ClientEvent::_internal_time_connection_started_ms() const {
return time_connection_started_ms_;
}
inline uint64_t ClientEvent::time_connection_started_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_started_ms)
return _internal_time_connection_started_ms();
}
inline void ClientEvent::_internal_set_time_connection_started_ms(uint64_t value) {
_has_bits_[0] |= 0x00000004u;
time_connection_started_ms_ = value;
}
inline void ClientEvent::set_time_connection_started_ms(uint64_t value) {
_internal_set_time_connection_started_ms(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_started_ms)
}

// optional uint64 time_connection_ended_ms = 203;
inline bool ClientEvent::_internal_has_time_connection_ended_ms() const {
bool value = (_has_bits_[0] & 0x00000020u) != 0;
return value;
}
inline bool ClientEvent::has_time_connection_ended_ms() const {
return _internal_has_time_connection_ended_ms();
}
inline void ClientEvent::clear_time_connection_ended_ms() {
time_connection_ended_ms_ = uint64_t{0u};
_has_bits_[0] &= ~0x00000020u;
}
inline uint64_t ClientEvent::_internal_time_connection_ended_ms() const {
return time_connection_ended_ms_;
}
inline uint64_t ClientEvent::time_connection_ended_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_ended_ms)
return _internal_time_connection_ended_ms();
}
inline void ClientEvent::_internal_set_time_connection_ended_ms(uint64_t value) {
_has_bits_[0] |= 0x00000020u;
time_connection_ended_ms_ = value;
}
inline void ClientEvent::set_time_connection_ended_ms(uint64_t value) {
_internal_set_time_connection_ended_ms(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_ended_ms)
}

// optional int32 error_code = 204;
inline bool ClientEvent::_internal_has_error_code() const {
bool value = (_has_bits_[0] & 0x00000010u) != 0;
return value;
}
inline bool ClientEvent::has_error_code() const {
return _internal_has_error_code();
}
inline void ClientEvent::clear_error_code() {
error_code_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline int32_t ClientEvent::_internal_error_code() const {
return error_code_;
}
inline int32_t ClientEvent::error_code() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.error_code)
return _internal_error_code();
}
inline void ClientEvent::_internal_set_error_code(int32_t value) {
_has_bits_[0] |= 0x00000010u;
error_code_ = value;
}
inline void ClientEvent::set_error_code(int32_t value) {
_internal_set_error_code(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.error_code)
}

// optional uint64 time_connection_established_ms = 300;
inline bool ClientEvent::_internal_has_time_connection_established_ms() const {
bool value = (_has_bits_[0] & 0x00000040u) != 0;
return value;
}
inline bool ClientEvent::has_time_connection_established_ms() const {
return _internal_has_time_connection_established_ms();
}
inline void ClientEvent::clear_time_connection_established_ms() {
time_connection_established_ms_ = uint64_t{0u};
_has_bits_[0] &= ~0x00000040u;
}
inline uint64_t ClientEvent::_internal_time_connection_established_ms() const {
return time_connection_established_ms_;
}
inline uint64_t ClientEvent::time_connection_established_ms() const {
// @@protoc_insertion_point(field_get:mcs_proto.ClientEvent.time_connection_established_ms)
return _internal_time_connection_established_ms();
}
inline void ClientEvent::_internal_set_time_connection_established_ms(uint64_t value) {
_has_bits_[0] |= 0x00000040u;
time_connection_established_ms_ = value;
}
inline void ClientEvent::set_time_connection_established_ms(uint64_t value) {
_internal_set_time_connection_established_ms(value);
// @@protoc_insertion_point(field_set:mcs_proto.ClientEvent.time_connection_established_ms)
}

// -------------------------------------------------------------------

// LoginRequest

// required string id = 1;
inline bool LoginRequest::_internal_has_id() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool LoginRequest::has_id() const {
return _internal_has_id();
}
inline void LoginRequest::clear_id() {
id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginRequest::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.id)
return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.id)
}
inline std::string* LoginRequest::mutable_id() {
std::string* _s = _internal_mutable_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.id)
return _s;
}
inline const std::string& LoginRequest::_internal_id() const {
return id_.Get();
}
inline void LoginRequest::_internal_set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_id() {
_has_bits_[0] |= 0x00000001u;
return id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.id)
if (!_internal_has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginRequest::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.id)
}

// required string domain = 2;
inline bool LoginRequest::_internal_has_domain() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool LoginRequest::has_domain() const {
return _internal_has_domain();
}
inline void LoginRequest::clear_domain() {
domain_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginRequest::domain() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.domain)
return _internal_domain();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_domain(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
domain_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.domain)
}
inline std::string* LoginRequest::mutable_domain() {
std::string* _s = _internal_mutable_domain();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.domain)
return _s;
}
inline const std::string& LoginRequest::_internal_domain() const {
return domain_.Get();
}
inline void LoginRequest::_internal_set_domain(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
domain_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_domain() {
_has_bits_[0] |= 0x00000002u;
return domain_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_domain() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.domain)
if (!_internal_has_domain()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = domain_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (domain_.IsDefault()) {
domain_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginRequest::set_allocated_domain(std::string* domain) {
if (domain != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
domain_.SetAllocated(domain, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (domain_.IsDefault()) {
domain_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.domain)
}

// required string user = 3;
inline bool LoginRequest::_internal_has_user() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool LoginRequest::has_user() const {
return _internal_has_user();
}
inline void LoginRequest::clear_user() {
user_.ClearToEmpty();
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& LoginRequest::user() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.user)
return _internal_user();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_user(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000004u;
user_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.user)
}
inline std::string* LoginRequest::mutable_user() {
std::string* _s = _internal_mutable_user();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.user)
return _s;
}
inline const std::string& LoginRequest::_internal_user() const {
return user_.Get();
}
inline void LoginRequest::_internal_set_user(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
user_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_user() {
_has_bits_[0] |= 0x00000004u;
return user_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_user() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.user)
if (!_internal_has_user()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
auto* p = user_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (user_.IsDefault()) {
user_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginRequest::set_allocated_user(std::string* user) {
if (user != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
user_.SetAllocated(user, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (user_.IsDefault()) {
user_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.user)
}

// required string resource = 4;
inline bool LoginRequest::_internal_has_resource() const {
bool value = (_has_bits_[0] & 0x00000008u) != 0;
return value;
}
inline bool LoginRequest::has_resource() const {
return _internal_has_resource();
}
inline void LoginRequest::clear_resource() {
resource_.ClearToEmpty();
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& LoginRequest::resource() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.resource)
return _internal_resource();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_resource(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000008u;
resource_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.resource)
}
inline std::string* LoginRequest::mutable_resource() {
std::string* _s = _internal_mutable_resource();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.resource)
return _s;
}
inline const std::string& LoginRequest::_internal_resource() const {
return resource_.Get();
}
inline void LoginRequest::_internal_set_resource(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
resource_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_resource() {
_has_bits_[0] |= 0x00000008u;
return resource_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_resource() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.resource)
if (!_internal_has_resource()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
auto* p = resource_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (resource_.IsDefault()) {
resource_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginRequest::set_allocated_resource(std::string* resource) {
if (resource != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
resource_.SetAllocated(resource, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (resource_.IsDefault()) {
resource_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.resource)
}

// required string auth_token = 5;
inline bool LoginRequest::_internal_has_auth_token() const {
bool value = (_has_bits_[0] & 0x00000010u) != 0;
return value;
}
inline bool LoginRequest::has_auth_token() const {
return _internal_has_auth_token();
}
inline void LoginRequest::clear_auth_token() {
auth_token_.ClearToEmpty();
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& LoginRequest::auth_token() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_token)
return _internal_auth_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_auth_token(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000010u;
auth_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_token)
}
inline std::string* LoginRequest::mutable_auth_token() {
std::string* _s = _internal_mutable_auth_token();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.auth_token)
return _s;
}
inline const std::string& LoginRequest::_internal_auth_token() const {
return auth_token_.Get();
}
inline void LoginRequest::_internal_set_auth_token(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
auth_token_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_auth_token() {
_has_bits_[0] |= 0x00000010u;
return auth_token_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_auth_token() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.auth_token)
if (!_internal_has_auth_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
auto* p = auth_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (auth_token_.IsDefault()) {
auth_token_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginRequest::set_allocated_auth_token(std::string* auth_token) {
if (auth_token != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
auth_token_.SetAllocated(auth_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (auth_token_.IsDefault()) {
auth_token_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.auth_token)
}

// optional string device_id = 6;
inline bool LoginRequest::_internal_has_device_id() const {
bool value = (_has_bits_[0] & 0x00000020u) != 0;
return value;
}
inline bool LoginRequest::has_device_id() const {
return _internal_has_device_id();
}
inline void LoginRequest::clear_device_id() {
device_id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& LoginRequest::device_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.device_id)
return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_device_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000020u;
device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.device_id)
}
inline std::string* LoginRequest::mutable_device_id() {
std::string* _s = _internal_mutable_device_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.device_id)
return _s;
}
inline const std::string& LoginRequest::_internal_device_id() const {
return device_id_.Get();
}
inline void LoginRequest::_internal_set_device_id(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_device_id() {
_has_bits_[0] |= 0x00000020u;
return device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_device_id() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.device_id)
if (!_internal_has_device_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
auto* p = device_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (device_id_.IsDefault()) {
device_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginRequest::set_allocated_device_id(std::string* device_id) {
if (device_id != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (device_id_.IsDefault()) {
device_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.device_id)
}

// optional int64 last_rmq_id = 7;
inline bool LoginRequest::_internal_has_last_rmq_id() const {
bool value = (_has_bits_[0] & 0x00000080u) != 0;
return value;
}
inline bool LoginRequest::has_last_rmq_id() const {
return _internal_has_last_rmq_id();
}
inline void LoginRequest::clear_last_rmq_id() {
last_rmq_id_ = int64_t{0};
_has_bits_[0] &= ~0x00000080u;
}
inline int64_t LoginRequest::_internal_last_rmq_id() const {
return last_rmq_id_;
}
inline int64_t LoginRequest::last_rmq_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.last_rmq_id)
return _internal_last_rmq_id();
}
inline void LoginRequest::_internal_set_last_rmq_id(int64_t value) {
_has_bits_[0] |= 0x00000080u;
last_rmq_id_ = value;
}
inline void LoginRequest::set_last_rmq_id(int64_t value) {
_internal_set_last_rmq_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.last_rmq_id)
}

// repeated .mcs_proto.Setting setting = 8;
inline int LoginRequest::_internal_setting_size() const {
return setting_.size();
}
inline int LoginRequest::setting_size() const {
return _internal_setting_size();
}
inline void LoginRequest::clear_setting() {
setting_.Clear();
}
inline ::mcs_proto::Setting* LoginRequest::mutable_setting(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.setting)
return setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
LoginRequest::mutable_setting() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.setting)
return &setting_;
}
inline const ::mcs_proto::Setting& LoginRequest::_internal_setting(int index) const {
return setting_.Get(index);
}
inline const ::mcs_proto::Setting& LoginRequest::setting(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.setting)
return _internal_setting(index);
}
inline ::mcs_proto::Setting* LoginRequest::_internal_add_setting() {
return setting_.Add();
}
inline ::mcs_proto::Setting* LoginRequest::add_setting() {
::mcs_proto::Setting* _add = _internal_add_setting();
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.setting)
return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
LoginRequest::setting() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.setting)
return setting_;
}

// repeated string received_persistent_id = 10;
inline int LoginRequest::_internal_received_persistent_id_size() const {
return received_persistent_id_.size();
}
inline int LoginRequest::received_persistent_id_size() const {
return _internal_received_persistent_id_size();
}
inline void LoginRequest::clear_received_persistent_id() {
received_persistent_id_.Clear();
}
inline std::string* LoginRequest::add_received_persistent_id() {
std::string* _s = _internal_add_received_persistent_id();
// @@protoc_insertion_point(field_add_mutable:mcs_proto.LoginRequest.received_persistent_id)
return _s;
}
inline const std::string& LoginRequest::_internal_received_persistent_id(int index) const {
return received_persistent_id_.Get(index);
}
inline const std::string& LoginRequest::received_persistent_id(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.received_persistent_id)
return _internal_received_persistent_id(index);
}
inline std::string* LoginRequest::mutable_received_persistent_id(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.received_persistent_id)
return received_persistent_id_.Mutable(index);
}
inline void LoginRequest::set_received_persistent_id(int index, const std::string& value) {
received_persistent_id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::set_received_persistent_id(int index, std::string&& value) {
received_persistent_id_.Mutable(index)->assign(std::move(value));
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
received_persistent_id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::set_received_persistent_id(int index, const char* value, size_t size) {
received_persistent_id_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline std::string* LoginRequest::_internal_add_received_persistent_id() {
return received_persistent_id_.Add();
}
inline void LoginRequest::add_received_persistent_id(const std::string& value) {
received_persistent_id_.Add()->assign(value);
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(std::string&& value) {
received_persistent_id_.Add(std::move(value));
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
received_persistent_id_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:mcs_proto.LoginRequest.received_persistent_id)
}
inline void LoginRequest::add_received_persistent_id(const char* value, size_t size) {
received_persistent_id_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:mcs_proto.LoginRequest.received_persistent_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
LoginRequest::received_persistent_id() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.received_persistent_id)
return received_persistent_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
LoginRequest::mutable_received_persistent_id() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.received_persistent_id)
return &received_persistent_id_;
}

// optional bool adaptive_heartbeat = 12;
inline bool LoginRequest::_internal_has_adaptive_heartbeat() const {
bool value = (_has_bits_[0] & 0x00000100u) != 0;
return value;
}
inline bool LoginRequest::has_adaptive_heartbeat() const {
return _internal_has_adaptive_heartbeat();
}
inline void LoginRequest::clear_adaptive_heartbeat() {
adaptive_heartbeat_ = false;
_has_bits_[0] &= ~0x00000100u;
}
inline bool LoginRequest::_internal_adaptive_heartbeat() const {
return adaptive_heartbeat_;
}
inline bool LoginRequest::adaptive_heartbeat() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.adaptive_heartbeat)
return _internal_adaptive_heartbeat();
}
inline void LoginRequest::_internal_set_adaptive_heartbeat(bool value) {
_has_bits_[0] |= 0x00000100u;
adaptive_heartbeat_ = value;
}
inline void LoginRequest::set_adaptive_heartbeat(bool value) {
_internal_set_adaptive_heartbeat(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.adaptive_heartbeat)
}

// optional .mcs_proto.HeartbeatStat heartbeat_stat = 13;
inline bool LoginRequest::_internal_has_heartbeat_stat() const {
bool value = (_has_bits_[0] & 0x00000040u) != 0;
PROTOBUF_ASSUME(!value || heartbeat_stat_ != nullptr);
return value;
}
inline bool LoginRequest::has_heartbeat_stat() const {
return _internal_has_heartbeat_stat();
}
inline void LoginRequest::clear_heartbeat_stat() {
if (heartbeat_stat_ != nullptr) heartbeat_stat_->Clear();
_has_bits_[0] &= ~0x00000040u;
}
inline const ::mcs_proto::HeartbeatStat& LoginRequest::_internal_heartbeat_stat() const {
const ::mcs_proto::HeartbeatStat* p = heartbeat_stat_;
return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::HeartbeatStat&>(
::mcs_proto::_HeartbeatStat_default_instance_);
}
inline const ::mcs_proto::HeartbeatStat& LoginRequest::heartbeat_stat() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.heartbeat_stat)
return _internal_heartbeat_stat();
}
inline void LoginRequest::unsafe_arena_set_allocated_heartbeat_stat(
::mcs_proto::HeartbeatStat* heartbeat_stat) {
if (GetArenaForAllocation() == nullptr) {
delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_stat_);
}
heartbeat_stat_ = heartbeat_stat;
if (heartbeat_stat) {
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
// @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.LoginRequest.heartbeat_stat)
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::release_heartbeat_stat() {
_has_bits_[0] &= ~0x00000040u;
::mcs_proto::HeartbeatStat* temp = heartbeat_stat_;
heartbeat_stat_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
if (GetArenaForAllocation() != nullptr) {
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
return temp;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::unsafe_arena_release_heartbeat_stat() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginRequest.heartbeat_stat)
_has_bits_[0] &= ~0x00000040u;
::mcs_proto::HeartbeatStat* temp = heartbeat_stat_;
heartbeat_stat_ = nullptr;
return temp;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::_internal_mutable_heartbeat_stat() {
_has_bits_[0] |= 0x00000040u;
if (heartbeat_stat_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::HeartbeatStat>(GetArenaForAllocation());
heartbeat_stat_ = p;
}
return heartbeat_stat_;
}
inline ::mcs_proto::HeartbeatStat* LoginRequest::mutable_heartbeat_stat() {
::mcs_proto::HeartbeatStat* _msg = _internal_mutable_heartbeat_stat();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.heartbeat_stat)
return _msg;
}
inline void LoginRequest::set_allocated_heartbeat_stat(::mcs_proto::HeartbeatStat* heartbeat_stat) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
if (message_arena == nullptr) {
delete heartbeat_stat_;
}
if (heartbeat_stat) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat_stat);
if (message_arena != submessage_arena) {
heartbeat_stat = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, heartbeat_stat, submessage_arena);
}
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
heartbeat_stat_ = heartbeat_stat;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginRequest.heartbeat_stat)
}

// optional bool use_rmq2 = 14;
inline bool LoginRequest::_internal_has_use_rmq2() const {
bool value = (_has_bits_[0] & 0x00000200u) != 0;
return value;
}
inline bool LoginRequest::has_use_rmq2() const {
return _internal_has_use_rmq2();
}
inline void LoginRequest::clear_use_rmq2() {
use_rmq2_ = false;
_has_bits_[0] &= ~0x00000200u;
}
inline bool LoginRequest::_internal_use_rmq2() const {
return use_rmq2_;
}
inline bool LoginRequest::use_rmq2() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.use_rmq2)
return _internal_use_rmq2();
}
inline void LoginRequest::_internal_set_use_rmq2(bool value) {
_has_bits_[0] |= 0x00000200u;
use_rmq2_ = value;
}
inline void LoginRequest::set_use_rmq2(bool value) {
_internal_set_use_rmq2(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.use_rmq2)
}

// optional int64 account_id = 15;
inline bool LoginRequest::_internal_has_account_id() const {
bool value = (_has_bits_[0] & 0x00000800u) != 0;
return value;
}
inline bool LoginRequest::has_account_id() const {
return _internal_has_account_id();
}
inline void LoginRequest::clear_account_id() {
account_id_ = int64_t{0};
_has_bits_[0] &= ~0x00000800u;
}
inline int64_t LoginRequest::_internal_account_id() const {
return account_id_;
}
inline int64_t LoginRequest::account_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.account_id)
return _internal_account_id();
}
inline void LoginRequest::_internal_set_account_id(int64_t value) {
_has_bits_[0] |= 0x00000800u;
account_id_ = value;
}
inline void LoginRequest::set_account_id(int64_t value) {
_internal_set_account_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.account_id)
}

// optional .mcs_proto.LoginRequest.AuthService auth_service = 16;
inline bool LoginRequest::_internal_has_auth_service() const {
bool value = (_has_bits_[0] & 0x00002000u) != 0;
return value;
}
inline bool LoginRequest::has_auth_service() const {
return _internal_has_auth_service();
}
inline void LoginRequest::clear_auth_service() {
auth_service_ = 2;
_has_bits_[0] &= ~0x00002000u;
}
inline ::mcs_proto::LoginRequest_AuthService LoginRequest::_internal_auth_service() const {
return static_cast< ::mcs_proto::LoginRequest_AuthService >(auth_service_);
}
inline ::mcs_proto::LoginRequest_AuthService LoginRequest::auth_service() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.auth_service)
return _internal_auth_service();
}
inline void LoginRequest::_internal_set_auth_service(::mcs_proto::LoginRequest_AuthService value) {
assert(::mcs_proto::LoginRequest_AuthService_IsValid(value));
_has_bits_[0] |= 0x00002000u;
auth_service_ = value;
}
inline void LoginRequest::set_auth_service(::mcs_proto::LoginRequest_AuthService value) {
_internal_set_auth_service(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.auth_service)
}

// optional int32 network_type = 17;
inline bool LoginRequest::_internal_has_network_type() const {
bool value = (_has_bits_[0] & 0x00000400u) != 0;
return value;
}
inline bool LoginRequest::has_network_type() const {
return _internal_has_network_type();
}
inline void LoginRequest::clear_network_type() {
network_type_ = 0;
_has_bits_[0] &= ~0x00000400u;
}
inline int32_t LoginRequest::_internal_network_type() const {
return network_type_;
}
inline int32_t LoginRequest::network_type() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.network_type)
return _internal_network_type();
}
inline void LoginRequest::_internal_set_network_type(int32_t value) {
_has_bits_[0] |= 0x00000400u;
network_type_ = value;
}
inline void LoginRequest::set_network_type(int32_t value) {
_internal_set_network_type(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.network_type)
}

// optional int64 status = 18;
inline bool LoginRequest::_internal_has_status() const {
bool value = (_has_bits_[0] & 0x00001000u) != 0;
return value;
}
inline bool LoginRequest::has_status() const {
return _internal_has_status();
}
inline void LoginRequest::clear_status() {
status_ = int64_t{0};
_has_bits_[0] &= ~0x00001000u;
}
inline int64_t LoginRequest::_internal_status() const {
return status_;
}
inline int64_t LoginRequest::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.status)
return _internal_status();
}
inline void LoginRequest::_internal_set_status(int64_t value) {
_has_bits_[0] |= 0x00001000u;
status_ = value;
}
inline void LoginRequest::set_status(int64_t value) {
_internal_set_status(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginRequest.status)
}

// repeated .mcs_proto.ClientEvent client_event = 22;
inline int LoginRequest::_internal_client_event_size() const {
return client_event_.size();
}
inline int LoginRequest::client_event_size() const {
return _internal_client_event_size();
}
inline void LoginRequest::clear_client_event() {
client_event_.Clear();
}
inline ::mcs_proto::ClientEvent* LoginRequest::mutable_client_event(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginRequest.client_event)
return client_event_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >*
LoginRequest::mutable_client_event() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginRequest.client_event)
return &client_event_;
}
inline const ::mcs_proto::ClientEvent& LoginRequest::_internal_client_event(int index) const {
return client_event_.Get(index);
}
inline const ::mcs_proto::ClientEvent& LoginRequest::client_event(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginRequest.client_event)
return _internal_client_event(index);
}
inline ::mcs_proto::ClientEvent* LoginRequest::_internal_add_client_event() {
return client_event_.Add();
}
inline ::mcs_proto::ClientEvent* LoginRequest::add_client_event() {
::mcs_proto::ClientEvent* _add = _internal_add_client_event();
// @@protoc_insertion_point(field_add:mcs_proto.LoginRequest.client_event)
return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::ClientEvent >&
LoginRequest::client_event() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginRequest.client_event)
return client_event_;
}

// -------------------------------------------------------------------

// LoginResponse

// required string id = 1;
inline bool LoginResponse::_internal_has_id() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool LoginResponse::has_id() const {
return _internal_has_id();
}
inline void LoginResponse::clear_id() {
id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LoginResponse::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.id)
return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.id)
}
inline std::string* LoginResponse::mutable_id() {
std::string* _s = _internal_mutable_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.id)
return _s;
}
inline const std::string& LoginResponse::_internal_id() const {
return id_.Get();
}
inline void LoginResponse::_internal_set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_id() {
_has_bits_[0] |= 0x00000001u;
return id_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.id)
if (!_internal_has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginResponse::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.id)
}

// optional string jid = 2;
inline bool LoginResponse::_internal_has_jid() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool LoginResponse::has_jid() const {
return _internal_has_jid();
}
inline void LoginResponse::clear_jid() {
jid_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& LoginResponse::jid() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.jid)
return _internal_jid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginResponse::set_jid(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
jid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.jid)
}
inline std::string* LoginResponse::mutable_jid() {
std::string* _s = _internal_mutable_jid();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.jid)
return _s;
}
inline const std::string& LoginResponse::_internal_jid() const {
return jid_.Get();
}
inline void LoginResponse::_internal_set_jid(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
jid_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginResponse::_internal_mutable_jid() {
_has_bits_[0] |= 0x00000002u;
return jid_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginResponse::release_jid() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.jid)
if (!_internal_has_jid()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = jid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (jid_.IsDefault()) {
jid_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void LoginResponse::set_allocated_jid(std::string* jid) {
if (jid != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
jid_.SetAllocated(jid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (jid_.IsDefault()) {
jid_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.jid)
}

// optional .mcs_proto.ErrorInfo error = 3;
inline bool LoginResponse::_internal_has_error() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
PROTOBUF_ASSUME(!value || error_ != nullptr);
return value;
}
inline bool LoginResponse::has_error() const {
return _internal_has_error();
}
inline void LoginResponse::clear_error() {
if (error_ != nullptr) error_->Clear();
_has_bits_[0] &= ~0x00000004u;
}
inline const ::mcs_proto::ErrorInfo& LoginResponse::_internal_error() const {
const ::mcs_proto::ErrorInfo* p = error_;
return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::ErrorInfo&>(
::mcs_proto::_ErrorInfo_default_instance_);
}
inline const ::mcs_proto::ErrorInfo& LoginResponse::error() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.error)
return _internal_error();
}
inline void LoginResponse::unsafe_arena_set_allocated_error(
::mcs_proto::ErrorInfo* error) {
if (GetArenaForAllocation() == nullptr) {
delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
}
error_ = error;
if (error) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
// @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.LoginResponse.error)
}
inline ::mcs_proto::ErrorInfo* LoginResponse::release_error() {
_has_bits_[0] &= ~0x00000004u;
::mcs_proto::ErrorInfo* temp = error_;
error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
if (GetArenaForAllocation() != nullptr) {
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
return temp;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::unsafe_arena_release_error() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.error)
_has_bits_[0] &= ~0x00000004u;
::mcs_proto::ErrorInfo* temp = error_;
error_ = nullptr;
return temp;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::_internal_mutable_error() {
_has_bits_[0] |= 0x00000004u;
if (error_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::ErrorInfo>(GetArenaForAllocation());
error_ = p;
}
return error_;
}
inline ::mcs_proto::ErrorInfo* LoginResponse::mutable_error() {
::mcs_proto::ErrorInfo* _msg = _internal_mutable_error();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.error)
return _msg;
}
inline void LoginResponse::set_allocated_error(::mcs_proto::ErrorInfo* error) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
if (message_arena == nullptr) {
delete error_;
}
if (error) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
if (message_arena != submessage_arena) {
error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, error, submessage_arena);
}
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
error_ = error;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.error)
}

// repeated .mcs_proto.Setting setting = 4;
inline int LoginResponse::_internal_setting_size() const {
return setting_.size();
}
inline int LoginResponse::setting_size() const {
return _internal_setting_size();
}
inline void LoginResponse::clear_setting() {
setting_.Clear();
}
inline ::mcs_proto::Setting* LoginResponse::mutable_setting(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.setting)
return setting_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >*
LoginResponse::mutable_setting() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.LoginResponse.setting)
return &setting_;
}
inline const ::mcs_proto::Setting& LoginResponse::_internal_setting(int index) const {
return setting_.Get(index);
}
inline const ::mcs_proto::Setting& LoginResponse::setting(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.setting)
return _internal_setting(index);
}
inline ::mcs_proto::Setting* LoginResponse::_internal_add_setting() {
return setting_.Add();
}
inline ::mcs_proto::Setting* LoginResponse::add_setting() {
::mcs_proto::Setting* _add = _internal_add_setting();
// @@protoc_insertion_point(field_add:mcs_proto.LoginResponse.setting)
return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::Setting >&
LoginResponse::setting() const {
// @@protoc_insertion_point(field_list:mcs_proto.LoginResponse.setting)
return setting_;
}

// optional int32 stream_id = 5;
inline bool LoginResponse::_internal_has_stream_id() const {
bool value = (_has_bits_[0] & 0x00000010u) != 0;
return value;
}
inline bool LoginResponse::has_stream_id() const {
return _internal_has_stream_id();
}
inline void LoginResponse::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000010u;
}
inline int32_t LoginResponse::_internal_stream_id() const {
return stream_id_;
}
inline int32_t LoginResponse::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.stream_id)
return _internal_stream_id();
}
inline void LoginResponse::_internal_set_stream_id(int32_t value) {
_has_bits_[0] |= 0x00000010u;
stream_id_ = value;
}
inline void LoginResponse::set_stream_id(int32_t value) {
_internal_set_stream_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.stream_id)
}

// optional int32 last_stream_id_received = 6;
inline bool LoginResponse::_internal_has_last_stream_id_received() const {
bool value = (_has_bits_[0] & 0x00000020u) != 0;
return value;
}
inline bool LoginResponse::has_last_stream_id_received() const {
return _internal_has_last_stream_id_received();
}
inline void LoginResponse::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000020u;
}
inline int32_t LoginResponse::_internal_last_stream_id_received() const {
return last_stream_id_received_;
}
inline int32_t LoginResponse::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.last_stream_id_received)
return _internal_last_stream_id_received();
}
inline void LoginResponse::_internal_set_last_stream_id_received(int32_t value) {
_has_bits_[0] |= 0x00000020u;
last_stream_id_received_ = value;
}
inline void LoginResponse::set_last_stream_id_received(int32_t value) {
_internal_set_last_stream_id_received(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.last_stream_id_received)
}

// optional .mcs_proto.HeartbeatConfig heartbeat_config = 7;
inline bool LoginResponse::_internal_has_heartbeat_config() const {
bool value = (_has_bits_[0] & 0x00000008u) != 0;
PROTOBUF_ASSUME(!value || heartbeat_config_ != nullptr);
return value;
}
inline bool LoginResponse::has_heartbeat_config() const {
return _internal_has_heartbeat_config();
}
inline void LoginResponse::clear_heartbeat_config() {
if (heartbeat_config_ != nullptr) heartbeat_config_->Clear();
_has_bits_[0] &= ~0x00000008u;
}
inline const ::mcs_proto::HeartbeatConfig& LoginResponse::_internal_heartbeat_config() const {
const ::mcs_proto::HeartbeatConfig* p = heartbeat_config_;
return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::HeartbeatConfig&>(
::mcs_proto::_HeartbeatConfig_default_instance_);
}
inline const ::mcs_proto::HeartbeatConfig& LoginResponse::heartbeat_config() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.heartbeat_config)
return _internal_heartbeat_config();
}
inline void LoginResponse::unsafe_arena_set_allocated_heartbeat_config(
::mcs_proto::HeartbeatConfig* heartbeat_config) {
if (GetArenaForAllocation() == nullptr) {
delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(heartbeat_config_);
}
heartbeat_config_ = heartbeat_config;
if (heartbeat_config) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
// @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.LoginResponse.heartbeat_config)
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::release_heartbeat_config() {
_has_bits_[0] &= ~0x00000008u;
::mcs_proto::HeartbeatConfig* temp = heartbeat_config_;
heartbeat_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
if (GetArenaForAllocation() != nullptr) {
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
return temp;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::unsafe_arena_release_heartbeat_config() {
// @@protoc_insertion_point(field_release:mcs_proto.LoginResponse.heartbeat_config)
_has_bits_[0] &= ~0x00000008u;
::mcs_proto::HeartbeatConfig* temp = heartbeat_config_;
heartbeat_config_ = nullptr;
return temp;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::_internal_mutable_heartbeat_config() {
_has_bits_[0] |= 0x00000008u;
if (heartbeat_config_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::HeartbeatConfig>(GetArenaForAllocation());
heartbeat_config_ = p;
}
return heartbeat_config_;
}
inline ::mcs_proto::HeartbeatConfig* LoginResponse::mutable_heartbeat_config() {
::mcs_proto::HeartbeatConfig* _msg = _internal_mutable_heartbeat_config();
// @@protoc_insertion_point(field_mutable:mcs_proto.LoginResponse.heartbeat_config)
return _msg;
}
inline void LoginResponse::set_allocated_heartbeat_config(::mcs_proto::HeartbeatConfig* heartbeat_config) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
if (message_arena == nullptr) {
delete heartbeat_config_;
}
if (heartbeat_config) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(heartbeat_config);
if (message_arena != submessage_arena) {
heartbeat_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, heartbeat_config, submessage_arena);
}
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
heartbeat_config_ = heartbeat_config;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.LoginResponse.heartbeat_config)
}

// optional int64 server_timestamp = 8;
inline bool LoginResponse::_internal_has_server_timestamp() const {
bool value = (_has_bits_[0] & 0x00000040u) != 0;
return value;
}
inline bool LoginResponse::has_server_timestamp() const {
return _internal_has_server_timestamp();
}
inline void LoginResponse::clear_server_timestamp() {
server_timestamp_ = int64_t{0};
_has_bits_[0] &= ~0x00000040u;
}
inline int64_t LoginResponse::_internal_server_timestamp() const {
return server_timestamp_;
}
inline int64_t LoginResponse::server_timestamp() const {
// @@protoc_insertion_point(field_get:mcs_proto.LoginResponse.server_timestamp)
return _internal_server_timestamp();
}
inline void LoginResponse::_internal_set_server_timestamp(int64_t value) {
_has_bits_[0] |= 0x00000040u;
server_timestamp_ = value;
}
inline void LoginResponse::set_server_timestamp(int64_t value) {
_internal_set_server_timestamp(value);
// @@protoc_insertion_point(field_set:mcs_proto.LoginResponse.server_timestamp)
}

// -------------------------------------------------------------------

// StreamErrorStanza

// required string type = 1;
inline bool StreamErrorStanza::_internal_has_type() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool StreamErrorStanza::has_type() const {
return _internal_has_type();
}
inline void StreamErrorStanza::clear_type() {
type_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StreamErrorStanza::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.type)
return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamErrorStanza::set_type(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.type)
}
inline std::string* StreamErrorStanza::mutable_type() {
std::string* _s = _internal_mutable_type();
// @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.type)
return _s;
}
inline const std::string& StreamErrorStanza::_internal_type() const {
return type_.Get();
}
inline void StreamErrorStanza::_internal_set_type(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
type_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamErrorStanza::_internal_mutable_type() {
_has_bits_[0] |= 0x00000001u;
return type_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamErrorStanza::release_type() {
// @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.type)
if (!_internal_has_type()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (type_.IsDefault()) {
type_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void StreamErrorStanza::set_allocated_type(std::string* type) {
if (type != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (type_.IsDefault()) {
type_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.type)
}

// optional string text = 2;
inline bool StreamErrorStanza::_internal_has_text() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool StreamErrorStanza::has_text() const {
return _internal_has_text();
}
inline void StreamErrorStanza::clear_text() {
text_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StreamErrorStanza::text() const {
// @@protoc_insertion_point(field_get:mcs_proto.StreamErrorStanza.text)
return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamErrorStanza::set_text(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.StreamErrorStanza.text)
}
inline std::string* StreamErrorStanza::mutable_text() {
std::string* _s = _internal_mutable_text();
// @@protoc_insertion_point(field_mutable:mcs_proto.StreamErrorStanza.text)
return _s;
}
inline const std::string& StreamErrorStanza::_internal_text() const {
return text_.Get();
}
inline void StreamErrorStanza::_internal_set_text(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
text_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamErrorStanza::_internal_mutable_text() {
_has_bits_[0] |= 0x00000002u;
return text_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamErrorStanza::release_text() {
// @@protoc_insertion_point(field_release:mcs_proto.StreamErrorStanza.text)
if (!_internal_has_text()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = text_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (text_.IsDefault()) {
text_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void StreamErrorStanza::set_allocated_text(std::string* text) {
if (text != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
text_.SetAllocated(text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (text_.IsDefault()) {
text_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.StreamErrorStanza.text)
}

// -------------------------------------------------------------------

// Close

// -------------------------------------------------------------------

// Extension

// required int32 id = 1;
inline bool Extension::_internal_has_id() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool Extension::has_id() const {
return _internal_has_id();
}
inline void Extension::clear_id() {
id_ = 0;
_has_bits_[0] &= ~0x00000002u;
}
inline int32_t Extension::_internal_id() const {
return id_;
}
inline int32_t Extension::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.Extension.id)
return _internal_id();
}
inline void Extension::_internal_set_id(int32_t value) {
_has_bits_[0] |= 0x00000002u;
id_ = value;
}
inline void Extension::set_id(int32_t value) {
_internal_set_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.Extension.id)
}

// required bytes data = 2;
inline bool Extension::_internal_has_data() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool Extension::has_data() const {
return _internal_has_data();
}
inline void Extension::clear_data() {
data_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Extension::data() const {
// @@protoc_insertion_point(field_get:mcs_proto.Extension.data)
return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Extension::set_data(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.Extension.data)
}
inline std::string* Extension::mutable_data() {
std::string* _s = _internal_mutable_data();
// @@protoc_insertion_point(field_mutable:mcs_proto.Extension.data)
return _s;
}
inline const std::string& Extension::_internal_data() const {
return data_.Get();
}
inline void Extension::_internal_set_data(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
data_.Set(value, GetArenaForAllocation());
}
inline std::string* Extension::_internal_mutable_data() {
_has_bits_[0] |= 0x00000001u;
return data_.Mutable(GetArenaForAllocation());
}
inline std::string* Extension::release_data() {
// @@protoc_insertion_point(field_release:mcs_proto.Extension.data)
if (!_internal_has_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (data_.IsDefault()) {
data_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void Extension::set_allocated_data(std::string* data) {
if (data != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (data_.IsDefault()) {
data_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.Extension.data)
}

// -------------------------------------------------------------------

// IqStanza

// optional int64 rmq_id = 1;
inline bool IqStanza::_internal_has_rmq_id() const {
bool value = (_has_bits_[0] & 0x00000040u) != 0;
return value;
}
inline bool IqStanza::has_rmq_id() const {
return _internal_has_rmq_id();
}
inline void IqStanza::clear_rmq_id() {
rmq_id_ = int64_t{0};
_has_bits_[0] &= ~0x00000040u;
}
inline int64_t IqStanza::_internal_rmq_id() const {
return rmq_id_;
}
inline int64_t IqStanza::rmq_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.rmq_id)
return _internal_rmq_id();
}
inline void IqStanza::_internal_set_rmq_id(int64_t value) {
_has_bits_[0] |= 0x00000040u;
rmq_id_ = value;
}
inline void IqStanza::set_rmq_id(int64_t value) {
_internal_set_rmq_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.rmq_id)
}

// required .mcs_proto.IqStanza.IqType type = 2;
inline bool IqStanza::_internal_has_type() const {
bool value = (_has_bits_[0] & 0x00000080u) != 0;
return value;
}
inline bool IqStanza::has_type() const {
return _internal_has_type();
}
inline void IqStanza::clear_type() {
type_ = 0;
_has_bits_[0] &= ~0x00000080u;
}
inline ::mcs_proto::IqStanza_IqType IqStanza::_internal_type() const {
return static_cast< ::mcs_proto::IqStanza_IqType >(type_);
}
inline ::mcs_proto::IqStanza_IqType IqStanza::type() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.type)
return _internal_type();
}
inline void IqStanza::_internal_set_type(::mcs_proto::IqStanza_IqType value) {
assert(::mcs_proto::IqStanza_IqType_IsValid(value));
_has_bits_[0] |= 0x00000080u;
type_ = value;
}
inline void IqStanza::set_type(::mcs_proto::IqStanza_IqType value) {
_internal_set_type(value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.type)
}

// required string id = 3;
inline bool IqStanza::_internal_has_id() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool IqStanza::has_id() const {
return _internal_has_id();
}
inline void IqStanza::clear_id() {
id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& IqStanza::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.id)
return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IqStanza::set_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.id)
}
inline std::string* IqStanza::mutable_id() {
std::string* _s = _internal_mutable_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.id)
return _s;
}
inline const std::string& IqStanza::_internal_id() const {
return id_.Get();
}
inline void IqStanza::_internal_set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.Set(value, GetArenaForAllocation());
}
inline std::string* IqStanza::_internal_mutable_id() {
_has_bits_[0] |= 0x00000001u;
return id_.Mutable(GetArenaForAllocation());
}
inline std::string* IqStanza::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.id)
if (!_internal_has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void IqStanza::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.id)
}

// optional string from = 4;
inline bool IqStanza::_internal_has_from() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool IqStanza::has_from() const {
return _internal_has_from();
}
inline void IqStanza::clear_from() {
from_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& IqStanza::from() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.from)
return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IqStanza::set_from(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.from)
}
inline std::string* IqStanza::mutable_from() {
std::string* _s = _internal_mutable_from();
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.from)
return _s;
}
inline const std::string& IqStanza::_internal_from() const {
return from_.Get();
}
inline void IqStanza::_internal_set_from(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
from_.Set(value, GetArenaForAllocation());
}
inline std::string* IqStanza::_internal_mutable_from() {
_has_bits_[0] |= 0x00000002u;
return from_.Mutable(GetArenaForAllocation());
}
inline std::string* IqStanza::release_from() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.from)
if (!_internal_has_from()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = from_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (from_.IsDefault()) {
from_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void IqStanza::set_allocated_from(std::string* from) {
if (from != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (from_.IsDefault()) {
from_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.from)
}

// optional string to = 5;
inline bool IqStanza::_internal_has_to() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool IqStanza::has_to() const {
return _internal_has_to();
}
inline void IqStanza::clear_to() {
to_.ClearToEmpty();
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& IqStanza::to() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.to)
return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IqStanza::set_to(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000004u;
to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.to)
}
inline std::string* IqStanza::mutable_to() {
std::string* _s = _internal_mutable_to();
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.to)
return _s;
}
inline const std::string& IqStanza::_internal_to() const {
return to_.Get();
}
inline void IqStanza::_internal_set_to(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
to_.Set(value, GetArenaForAllocation());
}
inline std::string* IqStanza::_internal_mutable_to() {
_has_bits_[0] |= 0x00000004u;
return to_.Mutable(GetArenaForAllocation());
}
inline std::string* IqStanza::release_to() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.to)
if (!_internal_has_to()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
auto* p = to_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (to_.IsDefault()) {
to_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void IqStanza::set_allocated_to(std::string* to) {
if (to != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (to_.IsDefault()) {
to_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.to)
}

// optional .mcs_proto.ErrorInfo error = 6;
inline bool IqStanza::_internal_has_error() const {
bool value = (_has_bits_[0] & 0x00000010u) != 0;
PROTOBUF_ASSUME(!value || error_ != nullptr);
return value;
}
inline bool IqStanza::has_error() const {
return _internal_has_error();
}
inline void IqStanza::clear_error() {
if (error_ != nullptr) error_->Clear();
_has_bits_[0] &= ~0x00000010u;
}
inline const ::mcs_proto::ErrorInfo& IqStanza::_internal_error() const {
const ::mcs_proto::ErrorInfo* p = error_;
return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::ErrorInfo&>(
::mcs_proto::_ErrorInfo_default_instance_);
}
inline const ::mcs_proto::ErrorInfo& IqStanza::error() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.error)
return _internal_error();
}
inline void IqStanza::unsafe_arena_set_allocated_error(
::mcs_proto::ErrorInfo* error) {
if (GetArenaForAllocation() == nullptr) {
delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
}
error_ = error;
if (error) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
// @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.IqStanza.error)
}
inline ::mcs_proto::ErrorInfo* IqStanza::release_error() {
_has_bits_[0] &= ~0x00000010u;
::mcs_proto::ErrorInfo* temp = error_;
error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
if (GetArenaForAllocation() != nullptr) {
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
return temp;
}
inline ::mcs_proto::ErrorInfo* IqStanza::unsafe_arena_release_error() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.error)
_has_bits_[0] &= ~0x00000010u;
::mcs_proto::ErrorInfo* temp = error_;
error_ = nullptr;
return temp;
}
inline ::mcs_proto::ErrorInfo* IqStanza::_internal_mutable_error() {
_has_bits_[0] |= 0x00000010u;
if (error_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::ErrorInfo>(GetArenaForAllocation());
error_ = p;
}
return error_;
}
inline ::mcs_proto::ErrorInfo* IqStanza::mutable_error() {
::mcs_proto::ErrorInfo* _msg = _internal_mutable_error();
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.error)
return _msg;
}
inline void IqStanza::set_allocated_error(::mcs_proto::ErrorInfo* error) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
if (message_arena == nullptr) {
delete error_;
}
if (error) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
if (message_arena != submessage_arena) {
error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, error, submessage_arena);
}
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
error_ = error;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.error)
}

// optional .mcs_proto.Extension extension = 7;
inline bool IqStanza::_internal_has_extension() const {
bool value = (_has_bits_[0] & 0x00000020u) != 0;
PROTOBUF_ASSUME(!value || extension_ != nullptr);
return value;
}
inline bool IqStanza::has_extension() const {
return _internal_has_extension();
}
inline void IqStanza::clear_extension() {
if (extension_ != nullptr) extension_->Clear();
_has_bits_[0] &= ~0x00000020u;
}
inline const ::mcs_proto::Extension& IqStanza::_internal_extension() const {
const ::mcs_proto::Extension* p = extension_;
return p != nullptr ? *p : reinterpret_cast<const ::mcs_proto::Extension&>(
::mcs_proto::_Extension_default_instance_);
}
inline const ::mcs_proto::Extension& IqStanza::extension() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.extension)
return _internal_extension();
}
inline void IqStanza::unsafe_arena_set_allocated_extension(
::mcs_proto::Extension* extension) {
if (GetArenaForAllocation() == nullptr) {
delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(extension_);
}
extension_ = extension;
if (extension) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
// @@protoc_insertion_point(field_unsafe_arena_set_allocated:mcs_proto.IqStanza.extension)
}
inline ::mcs_proto::Extension* IqStanza::release_extension() {
_has_bits_[0] &= ~0x00000020u;
::mcs_proto::Extension* temp = extension_;
extension_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
if (GetArenaForAllocation() != nullptr) {
temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
}
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
return temp;
}
inline ::mcs_proto::Extension* IqStanza::unsafe_arena_release_extension() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.extension)
_has_bits_[0] &= ~0x00000020u;
::mcs_proto::Extension* temp = extension_;
extension_ = nullptr;
return temp;
}
inline ::mcs_proto::Extension* IqStanza::_internal_mutable_extension() {
_has_bits_[0] |= 0x00000020u;
if (extension_ == nullptr) {
auto* p = CreateMaybeMessage<::mcs_proto::Extension>(GetArenaForAllocation());
extension_ = p;
}
return extension_;
}
inline ::mcs_proto::Extension* IqStanza::mutable_extension() {
::mcs_proto::Extension* _msg = _internal_mutable_extension();
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.extension)
return _msg;
}
inline void IqStanza::set_allocated_extension(::mcs_proto::Extension* extension) {
::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
if (message_arena == nullptr) {
delete extension_;
}
if (extension) {
::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(extension);
if (message_arena != submessage_arena) {
extension = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
message_arena, extension, submessage_arena);
}
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
extension_ = extension;
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.extension)
}

// optional string persistent_id = 8;
inline bool IqStanza::_internal_has_persistent_id() const {
bool value = (_has_bits_[0] & 0x00000008u) != 0;
return value;
}
inline bool IqStanza::has_persistent_id() const {
return _internal_has_persistent_id();
}
inline void IqStanza::clear_persistent_id() {
persistent_id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& IqStanza::persistent_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.persistent_id)
return _internal_persistent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void IqStanza::set_persistent_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000008u;
persistent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.persistent_id)
}
inline std::string* IqStanza::mutable_persistent_id() {
std::string* _s = _internal_mutable_persistent_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.IqStanza.persistent_id)
return _s;
}
inline const std::string& IqStanza::_internal_persistent_id() const {
return persistent_id_.Get();
}
inline void IqStanza::_internal_set_persistent_id(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
persistent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* IqStanza::_internal_mutable_persistent_id() {
_has_bits_[0] |= 0x00000008u;
return persistent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* IqStanza::release_persistent_id() {
// @@protoc_insertion_point(field_release:mcs_proto.IqStanza.persistent_id)
if (!_internal_has_persistent_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
auto* p = persistent_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (persistent_id_.IsDefault()) {
persistent_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void IqStanza::set_allocated_persistent_id(std::string* persistent_id) {
if (persistent_id != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
persistent_id_.SetAllocated(persistent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (persistent_id_.IsDefault()) {
persistent_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.IqStanza.persistent_id)
}

// optional int32 stream_id = 9;
inline bool IqStanza::_internal_has_stream_id() const {
bool value = (_has_bits_[0] & 0x00000100u) != 0;
return value;
}
inline bool IqStanza::has_stream_id() const {
return _internal_has_stream_id();
}
inline void IqStanza::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000100u;
}
inline int32_t IqStanza::_internal_stream_id() const {
return stream_id_;
}
inline int32_t IqStanza::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.stream_id)
return _internal_stream_id();
}
inline void IqStanza::_internal_set_stream_id(int32_t value) {
_has_bits_[0] |= 0x00000100u;
stream_id_ = value;
}
inline void IqStanza::set_stream_id(int32_t value) {
_internal_set_stream_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.stream_id)
}

// optional int32 last_stream_id_received = 10;
inline bool IqStanza::_internal_has_last_stream_id_received() const {
bool value = (_has_bits_[0] & 0x00000800u) != 0;
return value;
}
inline bool IqStanza::has_last_stream_id_received() const {
return _internal_has_last_stream_id_received();
}
inline void IqStanza::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000800u;
}
inline int32_t IqStanza::_internal_last_stream_id_received() const {
return last_stream_id_received_;
}
inline int32_t IqStanza::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.last_stream_id_received)
return _internal_last_stream_id_received();
}
inline void IqStanza::_internal_set_last_stream_id_received(int32_t value) {
_has_bits_[0] |= 0x00000800u;
last_stream_id_received_ = value;
}
inline void IqStanza::set_last_stream_id_received(int32_t value) {
_internal_set_last_stream_id_received(value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.last_stream_id_received)
}

// optional int64 account_id = 11;
inline bool IqStanza::_internal_has_account_id() const {
bool value = (_has_bits_[0] & 0x00000200u) != 0;
return value;
}
inline bool IqStanza::has_account_id() const {
return _internal_has_account_id();
}
inline void IqStanza::clear_account_id() {
account_id_ = int64_t{0};
_has_bits_[0] &= ~0x00000200u;
}
inline int64_t IqStanza::_internal_account_id() const {
return account_id_;
}
inline int64_t IqStanza::account_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.account_id)
return _internal_account_id();
}
inline void IqStanza::_internal_set_account_id(int64_t value) {
_has_bits_[0] |= 0x00000200u;
account_id_ = value;
}
inline void IqStanza::set_account_id(int64_t value) {
_internal_set_account_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.account_id)
}

// optional int64 status = 12;
inline bool IqStanza::_internal_has_status() const {
bool value = (_has_bits_[0] & 0x00000400u) != 0;
return value;
}
inline bool IqStanza::has_status() const {
return _internal_has_status();
}
inline void IqStanza::clear_status() {
status_ = int64_t{0};
_has_bits_[0] &= ~0x00000400u;
}
inline int64_t IqStanza::_internal_status() const {
return status_;
}
inline int64_t IqStanza::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.IqStanza.status)
return _internal_status();
}
inline void IqStanza::_internal_set_status(int64_t value) {
_has_bits_[0] |= 0x00000400u;
status_ = value;
}
inline void IqStanza::set_status(int64_t value) {
_internal_set_status(value);
// @@protoc_insertion_point(field_set:mcs_proto.IqStanza.status)
}

// -------------------------------------------------------------------

// AppData

// required string key = 1;
inline bool AppData::_internal_has_key() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool AppData::has_key() const {
return _internal_has_key();
}
inline void AppData::clear_key() {
key_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AppData::key() const {
// @@protoc_insertion_point(field_get:mcs_proto.AppData.key)
return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppData::set_key(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.AppData.key)
}
inline std::string* AppData::mutable_key() {
std::string* _s = _internal_mutable_key();
// @@protoc_insertion_point(field_mutable:mcs_proto.AppData.key)
return _s;
}
inline const std::string& AppData::_internal_key() const {
return key_.Get();
}
inline void AppData::_internal_set_key(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
key_.Set(value, GetArenaForAllocation());
}
inline std::string* AppData::_internal_mutable_key() {
_has_bits_[0] |= 0x00000001u;
return key_.Mutable(GetArenaForAllocation());
}
inline std::string* AppData::release_key() {
// @@protoc_insertion_point(field_release:mcs_proto.AppData.key)
if (!_internal_has_key()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (key_.IsDefault()) {
key_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void AppData::set_allocated_key(std::string* key) {
if (key != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (key_.IsDefault()) {
key_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.key)
}

// required string value = 2;
inline bool AppData::_internal_has_value() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool AppData::has_value() const {
return _internal_has_value();
}
inline void AppData::clear_value() {
value_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& AppData::value() const {
// @@protoc_insertion_point(field_get:mcs_proto.AppData.value)
return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AppData::set_value(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.AppData.value)
}
inline std::string* AppData::mutable_value() {
std::string* _s = _internal_mutable_value();
// @@protoc_insertion_point(field_mutable:mcs_proto.AppData.value)
return _s;
}
inline const std::string& AppData::_internal_value() const {
return value_.Get();
}
inline void AppData::_internal_set_value(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
value_.Set(value, GetArenaForAllocation());
}
inline std::string* AppData::_internal_mutable_value() {
_has_bits_[0] |= 0x00000002u;
return value_.Mutable(GetArenaForAllocation());
}
inline std::string* AppData::release_value() {
// @@protoc_insertion_point(field_release:mcs_proto.AppData.value)
if (!_internal_has_value()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (value_.IsDefault()) {
value_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void AppData::set_allocated_value(std::string* value) {
if (value != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (value_.IsDefault()) {
value_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.AppData.value)
}

// -------------------------------------------------------------------

// DataMessageStanza

// optional string id = 2;
inline bool DataMessageStanza::_internal_has_id() const {
bool value = (_has_bits_[0] & 0x00000001u) != 0;
return value;
}
inline bool DataMessageStanza::has_id() const {
return _internal_has_id();
}
inline void DataMessageStanza::clear_id() {
id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DataMessageStanza::id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.id)
return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000001u;
id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.id)
}
inline std::string* DataMessageStanza::mutable_id() {
std::string* _s = _internal_mutable_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.id)
return _s;
}
inline const std::string& DataMessageStanza::_internal_id() const {
return id_.Get();
}
inline void DataMessageStanza::_internal_set_id(const std::string& value) {
_has_bits_[0] |= 0x00000001u;
id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_id() {
_has_bits_[0] |= 0x00000001u;
return id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_id() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.id)
if (!_internal_has_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000001u;
auto* p = id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_id(std::string* id) {
if (id != nullptr) {
_has_bits_[0] |= 0x00000001u;
} else {
_has_bits_[0] &= ~0x00000001u;
}
id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (id_.IsDefault()) {
id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.id)
}

// required string from = 3;
inline bool DataMessageStanza::_internal_has_from() const {
bool value = (_has_bits_[0] & 0x00000002u) != 0;
return value;
}
inline bool DataMessageStanza::has_from() const {
return _internal_has_from();
}
inline void DataMessageStanza::clear_from() {
from_.ClearToEmpty();
_has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DataMessageStanza::from() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from)
return _internal_from();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_from(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000002u;
from_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from)
}
inline std::string* DataMessageStanza::mutable_from() {
std::string* _s = _internal_mutable_from();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.from)
return _s;
}
inline const std::string& DataMessageStanza::_internal_from() const {
return from_.Get();
}
inline void DataMessageStanza::_internal_set_from(const std::string& value) {
_has_bits_[0] |= 0x00000002u;
from_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_from() {
_has_bits_[0] |= 0x00000002u;
return from_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_from() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.from)
if (!_internal_has_from()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000002u;
auto* p = from_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (from_.IsDefault()) {
from_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_from(std::string* from) {
if (from != nullptr) {
_has_bits_[0] |= 0x00000002u;
} else {
_has_bits_[0] &= ~0x00000002u;
}
from_.SetAllocated(from, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (from_.IsDefault()) {
from_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.from)
}

// optional string to = 4;
inline bool DataMessageStanza::_internal_has_to() const {
bool value = (_has_bits_[0] & 0x00000004u) != 0;
return value;
}
inline bool DataMessageStanza::has_to() const {
return _internal_has_to();
}
inline void DataMessageStanza::clear_to() {
to_.ClearToEmpty();
_has_bits_[0] &= ~0x00000004u;
}
inline const std::string& DataMessageStanza::to() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.to)
return _internal_to();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_to(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000004u;
to_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.to)
}
inline std::string* DataMessageStanza::mutable_to() {
std::string* _s = _internal_mutable_to();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.to)
return _s;
}
inline const std::string& DataMessageStanza::_internal_to() const {
return to_.Get();
}
inline void DataMessageStanza::_internal_set_to(const std::string& value) {
_has_bits_[0] |= 0x00000004u;
to_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_to() {
_has_bits_[0] |= 0x00000004u;
return to_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_to() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.to)
if (!_internal_has_to()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000004u;
auto* p = to_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (to_.IsDefault()) {
to_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_to(std::string* to) {
if (to != nullptr) {
_has_bits_[0] |= 0x00000004u;
} else {
_has_bits_[0] &= ~0x00000004u;
}
to_.SetAllocated(to, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (to_.IsDefault()) {
to_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.to)
}

// required string category = 5;
inline bool DataMessageStanza::_internal_has_category() const {
bool value = (_has_bits_[0] & 0x00000008u) != 0;
return value;
}
inline bool DataMessageStanza::has_category() const {
return _internal_has_category();
}
inline void DataMessageStanza::clear_category() {
category_.ClearToEmpty();
_has_bits_[0] &= ~0x00000008u;
}
inline const std::string& DataMessageStanza::category() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.category)
return _internal_category();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_category(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000008u;
category_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.category)
}
inline std::string* DataMessageStanza::mutable_category() {
std::string* _s = _internal_mutable_category();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.category)
return _s;
}
inline const std::string& DataMessageStanza::_internal_category() const {
return category_.Get();
}
inline void DataMessageStanza::_internal_set_category(const std::string& value) {
_has_bits_[0] |= 0x00000008u;
category_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_category() {
_has_bits_[0] |= 0x00000008u;
return category_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_category() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.category)
if (!_internal_has_category()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000008u;
auto* p = category_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (category_.IsDefault()) {
category_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_category(std::string* category) {
if (category != nullptr) {
_has_bits_[0] |= 0x00000008u;
} else {
_has_bits_[0] &= ~0x00000008u;
}
category_.SetAllocated(category, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (category_.IsDefault()) {
category_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.category)
}

// optional string token = 6;
inline bool DataMessageStanza::_internal_has_token() const {
bool value = (_has_bits_[0] & 0x00000010u) != 0;
return value;
}
inline bool DataMessageStanza::has_token() const {
return _internal_has_token();
}
inline void DataMessageStanza::clear_token() {
token_.ClearToEmpty();
_has_bits_[0] &= ~0x00000010u;
}
inline const std::string& DataMessageStanza::token() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.token)
return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_token(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000010u;
token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.token)
}
inline std::string* DataMessageStanza::mutable_token() {
std::string* _s = _internal_mutable_token();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.token)
return _s;
}
inline const std::string& DataMessageStanza::_internal_token() const {
return token_.Get();
}
inline void DataMessageStanza::_internal_set_token(const std::string& value) {
_has_bits_[0] |= 0x00000010u;
token_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_token() {
_has_bits_[0] |= 0x00000010u;
return token_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_token() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.token)
if (!_internal_has_token()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000010u;
auto* p = token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (token_.IsDefault()) {
token_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_token(std::string* token) {
if (token != nullptr) {
_has_bits_[0] |= 0x00000010u;
} else {
_has_bits_[0] &= ~0x00000010u;
}
token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (token_.IsDefault()) {
token_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.token)
}

// repeated .mcs_proto.AppData app_data = 7;
inline int DataMessageStanza::_internal_app_data_size() const {
return app_data_.size();
}
inline int DataMessageStanza::app_data_size() const {
return _internal_app_data_size();
}
inline void DataMessageStanza::clear_app_data() {
app_data_.Clear();
}
inline ::mcs_proto::AppData* DataMessageStanza::mutable_app_data(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.app_data)
return app_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >*
DataMessageStanza::mutable_app_data() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.DataMessageStanza.app_data)
return &app_data_;
}
inline const ::mcs_proto::AppData& DataMessageStanza::_internal_app_data(int index) const {
return app_data_.Get(index);
}
inline const ::mcs_proto::AppData& DataMessageStanza::app_data(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.app_data)
return _internal_app_data(index);
}
inline ::mcs_proto::AppData* DataMessageStanza::_internal_add_app_data() {
return app_data_.Add();
}
inline ::mcs_proto::AppData* DataMessageStanza::add_app_data() {
::mcs_proto::AppData* _add = _internal_add_app_data();
// @@protoc_insertion_point(field_add:mcs_proto.DataMessageStanza.app_data)
return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::mcs_proto::AppData >&
DataMessageStanza::app_data() const {
// @@protoc_insertion_point(field_list:mcs_proto.DataMessageStanza.app_data)
return app_data_;
}

// optional bool from_trusted_server = 8;
inline bool DataMessageStanza::_internal_has_from_trusted_server() const {
bool value = (_has_bits_[0] & 0x00000800u) != 0;
return value;
}
inline bool DataMessageStanza::has_from_trusted_server() const {
return _internal_has_from_trusted_server();
}
inline void DataMessageStanza::clear_from_trusted_server() {
from_trusted_server_ = false;
_has_bits_[0] &= ~0x00000800u;
}
inline bool DataMessageStanza::_internal_from_trusted_server() const {
return from_trusted_server_;
}
inline bool DataMessageStanza::from_trusted_server() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.from_trusted_server)
return _internal_from_trusted_server();
}
inline void DataMessageStanza::_internal_set_from_trusted_server(bool value) {
_has_bits_[0] |= 0x00000800u;
from_trusted_server_ = value;
}
inline void DataMessageStanza::set_from_trusted_server(bool value) {
_internal_set_from_trusted_server(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.from_trusted_server)
}

// optional string persistent_id = 9;
inline bool DataMessageStanza::_internal_has_persistent_id() const {
bool value = (_has_bits_[0] & 0x00000020u) != 0;
return value;
}
inline bool DataMessageStanza::has_persistent_id() const {
return _internal_has_persistent_id();
}
inline void DataMessageStanza::clear_persistent_id() {
persistent_id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000020u;
}
inline const std::string& DataMessageStanza::persistent_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.persistent_id)
return _internal_persistent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_persistent_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000020u;
persistent_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.persistent_id)
}
inline std::string* DataMessageStanza::mutable_persistent_id() {
std::string* _s = _internal_mutable_persistent_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.persistent_id)
return _s;
}
inline const std::string& DataMessageStanza::_internal_persistent_id() const {
return persistent_id_.Get();
}
inline void DataMessageStanza::_internal_set_persistent_id(const std::string& value) {
_has_bits_[0] |= 0x00000020u;
persistent_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_persistent_id() {
_has_bits_[0] |= 0x00000020u;
return persistent_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_persistent_id() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.persistent_id)
if (!_internal_has_persistent_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000020u;
auto* p = persistent_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (persistent_id_.IsDefault()) {
persistent_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_persistent_id(std::string* persistent_id) {
if (persistent_id != nullptr) {
_has_bits_[0] |= 0x00000020u;
} else {
_has_bits_[0] &= ~0x00000020u;
}
persistent_id_.SetAllocated(persistent_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (persistent_id_.IsDefault()) {
persistent_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.persistent_id)
}

// optional int32 stream_id = 10;
inline bool DataMessageStanza::_internal_has_stream_id() const {
bool value = (_has_bits_[0] & 0x00000100u) != 0;
return value;
}
inline bool DataMessageStanza::has_stream_id() const {
return _internal_has_stream_id();
}
inline void DataMessageStanza::clear_stream_id() {
stream_id_ = 0;
_has_bits_[0] &= ~0x00000100u;
}
inline int32_t DataMessageStanza::_internal_stream_id() const {
return stream_id_;
}
inline int32_t DataMessageStanza::stream_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.stream_id)
return _internal_stream_id();
}
inline void DataMessageStanza::_internal_set_stream_id(int32_t value) {
_has_bits_[0] |= 0x00000100u;
stream_id_ = value;
}
inline void DataMessageStanza::set_stream_id(int32_t value) {
_internal_set_stream_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.stream_id)
}

// optional int32 last_stream_id_received = 11;
inline bool DataMessageStanza::_internal_has_last_stream_id_received() const {
bool value = (_has_bits_[0] & 0x00000200u) != 0;
return value;
}
inline bool DataMessageStanza::has_last_stream_id_received() const {
return _internal_has_last_stream_id_received();
}
inline void DataMessageStanza::clear_last_stream_id_received() {
last_stream_id_received_ = 0;
_has_bits_[0] &= ~0x00000200u;
}
inline int32_t DataMessageStanza::_internal_last_stream_id_received() const {
return last_stream_id_received_;
}
inline int32_t DataMessageStanza::last_stream_id_received() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.last_stream_id_received)
return _internal_last_stream_id_received();
}
inline void DataMessageStanza::_internal_set_last_stream_id_received(int32_t value) {
_has_bits_[0] |= 0x00000200u;
last_stream_id_received_ = value;
}
inline void DataMessageStanza::set_last_stream_id_received(int32_t value) {
_internal_set_last_stream_id_received(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.last_stream_id_received)
}

// optional string reg_id = 13;
inline bool DataMessageStanza::_internal_has_reg_id() const {
bool value = (_has_bits_[0] & 0x00000040u) != 0;
return value;
}
inline bool DataMessageStanza::has_reg_id() const {
return _internal_has_reg_id();
}
inline void DataMessageStanza::clear_reg_id() {
reg_id_.ClearToEmpty();
_has_bits_[0] &= ~0x00000040u;
}
inline const std::string& DataMessageStanza::reg_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.reg_id)
return _internal_reg_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_reg_id(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000040u;
reg_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.reg_id)
}
inline std::string* DataMessageStanza::mutable_reg_id() {
std::string* _s = _internal_mutable_reg_id();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.reg_id)
return _s;
}
inline const std::string& DataMessageStanza::_internal_reg_id() const {
return reg_id_.Get();
}
inline void DataMessageStanza::_internal_set_reg_id(const std::string& value) {
_has_bits_[0] |= 0x00000040u;
reg_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_reg_id() {
_has_bits_[0] |= 0x00000040u;
return reg_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_reg_id() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.reg_id)
if (!_internal_has_reg_id()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000040u;
auto* p = reg_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (reg_id_.IsDefault()) {
reg_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_reg_id(std::string* reg_id) {
if (reg_id != nullptr) {
_has_bits_[0] |= 0x00000040u;
} else {
_has_bits_[0] &= ~0x00000040u;
}
reg_id_.SetAllocated(reg_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (reg_id_.IsDefault()) {
reg_id_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.reg_id)
}

// optional int64 device_user_id = 16;
inline bool DataMessageStanza::_internal_has_device_user_id() const {
bool value = (_has_bits_[0] & 0x00000400u) != 0;
return value;
}
inline bool DataMessageStanza::has_device_user_id() const {
return _internal_has_device_user_id();
}
inline void DataMessageStanza::clear_device_user_id() {
device_user_id_ = int64_t{0};
_has_bits_[0] &= ~0x00000400u;
}
inline int64_t DataMessageStanza::_internal_device_user_id() const {
return device_user_id_;
}
inline int64_t DataMessageStanza::device_user_id() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.device_user_id)
return _internal_device_user_id();
}
inline void DataMessageStanza::_internal_set_device_user_id(int64_t value) {
_has_bits_[0] |= 0x00000400u;
device_user_id_ = value;
}
inline void DataMessageStanza::set_device_user_id(int64_t value) {
_internal_set_device_user_id(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.device_user_id)
}

// optional int32 ttl = 17;
inline bool DataMessageStanza::_internal_has_ttl() const {
bool value = (_has_bits_[0] & 0x00002000u) != 0;
return value;
}
inline bool DataMessageStanza::has_ttl() const {
return _internal_has_ttl();
}
inline void DataMessageStanza::clear_ttl() {
ttl_ = 0;
_has_bits_[0] &= ~0x00002000u;
}
inline int32_t DataMessageStanza::_internal_ttl() const {
return ttl_;
}
inline int32_t DataMessageStanza::ttl() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.ttl)
return _internal_ttl();
}
inline void DataMessageStanza::_internal_set_ttl(int32_t value) {
_has_bits_[0] |= 0x00002000u;
ttl_ = value;
}
inline void DataMessageStanza::set_ttl(int32_t value) {
_internal_set_ttl(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.ttl)
}

// optional int64 sent = 18;
inline bool DataMessageStanza::_internal_has_sent() const {
bool value = (_has_bits_[0] & 0x00004000u) != 0;
return value;
}
inline bool DataMessageStanza::has_sent() const {
return _internal_has_sent();
}
inline void DataMessageStanza::clear_sent() {
sent_ = int64_t{0};
_has_bits_[0] &= ~0x00004000u;
}
inline int64_t DataMessageStanza::_internal_sent() const {
return sent_;
}
inline int64_t DataMessageStanza::sent() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.sent)
return _internal_sent();
}
inline void DataMessageStanza::_internal_set_sent(int64_t value) {
_has_bits_[0] |= 0x00004000u;
sent_ = value;
}
inline void DataMessageStanza::set_sent(int64_t value) {
_internal_set_sent(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.sent)
}

// optional int32 queued = 19;
inline bool DataMessageStanza::_internal_has_queued() const {
bool value = (_has_bits_[0] & 0x00010000u) != 0;
return value;
}
inline bool DataMessageStanza::has_queued() const {
return _internal_has_queued();
}
inline void DataMessageStanza::clear_queued() {
queued_ = 0;
_has_bits_[0] &= ~0x00010000u;
}
inline int32_t DataMessageStanza::_internal_queued() const {
return queued_;
}
inline int32_t DataMessageStanza::queued() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.queued)
return _internal_queued();
}
inline void DataMessageStanza::_internal_set_queued(int32_t value) {
_has_bits_[0] |= 0x00010000u;
queued_ = value;
}
inline void DataMessageStanza::set_queued(int32_t value) {
_internal_set_queued(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.queued)
}

// optional int64 status = 20;
inline bool DataMessageStanza::_internal_has_status() const {
bool value = (_has_bits_[0] & 0x00008000u) != 0;
return value;
}
inline bool DataMessageStanza::has_status() const {
return _internal_has_status();
}
inline void DataMessageStanza::clear_status() {
status_ = int64_t{0};
_has_bits_[0] &= ~0x00008000u;
}
inline int64_t DataMessageStanza::_internal_status() const {
return status_;
}
inline int64_t DataMessageStanza::status() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.status)
return _internal_status();
}
inline void DataMessageStanza::_internal_set_status(int64_t value) {
_has_bits_[0] |= 0x00008000u;
status_ = value;
}
inline void DataMessageStanza::set_status(int64_t value) {
_internal_set_status(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.status)
}

// optional bytes raw_data = 21;
inline bool DataMessageStanza::_internal_has_raw_data() const {
bool value = (_has_bits_[0] & 0x00000080u) != 0;
return value;
}
inline bool DataMessageStanza::has_raw_data() const {
return _internal_has_raw_data();
}
inline void DataMessageStanza::clear_raw_data() {
raw_data_.ClearToEmpty();
_has_bits_[0] &= ~0x00000080u;
}
inline const std::string& DataMessageStanza::raw_data() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.raw_data)
return _internal_raw_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataMessageStanza::set_raw_data(ArgT0&& arg0, ArgT... args) {
_has_bits_[0] |= 0x00000080u;
raw_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.raw_data)
}
inline std::string* DataMessageStanza::mutable_raw_data() {
std::string* _s = _internal_mutable_raw_data();
// @@protoc_insertion_point(field_mutable:mcs_proto.DataMessageStanza.raw_data)
return _s;
}
inline const std::string& DataMessageStanza::_internal_raw_data() const {
return raw_data_.Get();
}
inline void DataMessageStanza::_internal_set_raw_data(const std::string& value) {
_has_bits_[0] |= 0x00000080u;
raw_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DataMessageStanza::_internal_mutable_raw_data() {
_has_bits_[0] |= 0x00000080u;
return raw_data_.Mutable(GetArenaForAllocation());
}
inline std::string* DataMessageStanza::release_raw_data() {
// @@protoc_insertion_point(field_release:mcs_proto.DataMessageStanza.raw_data)
if (!_internal_has_raw_data()) {
return nullptr;
}
_has_bits_[0] &= ~0x00000080u;
auto* p = raw_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (raw_data_.IsDefault()) {
raw_data_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
return p;
}
inline void DataMessageStanza::set_allocated_raw_data(std::string* raw_data) {
if (raw_data != nullptr) {
_has_bits_[0] |= 0x00000080u;
} else {
_has_bits_[0] &= ~0x00000080u;
}
raw_data_.SetAllocated(raw_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
if (raw_data_.IsDefault()) {
raw_data_.Set("", GetArenaForAllocation());
}
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
// @@protoc_insertion_point(field_set_allocated:mcs_proto.DataMessageStanza.raw_data)
}

// optional bool immediate_ack = 24;
inline bool DataMessageStanza::_internal_has_immediate_ack() const {
bool value = (_has_bits_[0] & 0x00001000u) != 0;
return value;
}
inline bool DataMessageStanza::has_immediate_ack() const {
return _internal_has_immediate_ack();
}
inline void DataMessageStanza::clear_immediate_ack() {
immediate_ack_ = false;
_has_bits_[0] &= ~0x00001000u;
}
inline bool DataMessageStanza::_internal_immediate_ack() const {
return immediate_ack_;
}
inline bool DataMessageStanza::immediate_ack() const {
// @@protoc_insertion_point(field_get:mcs_proto.DataMessageStanza.immediate_ack)
return _internal_immediate_ack();
}
inline void DataMessageStanza::_internal_set_immediate_ack(bool value) {
_has_bits_[0] |= 0x00001000u;
immediate_ack_ = value;
}
inline void DataMessageStanza::set_immediate_ack(bool value) {
_internal_set_immediate_ack(value);
// @@protoc_insertion_point(field_set:mcs_proto.DataMessageStanza.immediate_ack)
}

// -------------------------------------------------------------------

// StreamAck

// -------------------------------------------------------------------

// SelectiveAck

// repeated string id = 1;
inline int SelectiveAck::_internal_id_size() const {
return id_.size();
}
inline int SelectiveAck::id_size() const {
return _internal_id_size();
}
inline void SelectiveAck::clear_id() {
id_.Clear();
}
inline std::string* SelectiveAck::add_id() {
std::string* _s = _internal_add_id();
// @@protoc_insertion_point(field_add_mutable:mcs_proto.SelectiveAck.id)
return _s;
}
inline const std::string& SelectiveAck::_internal_id(int index) const {
return id_.Get(index);
}
inline const std::string& SelectiveAck::id(int index) const {
// @@protoc_insertion_point(field_get:mcs_proto.SelectiveAck.id)
return _internal_id(index);
}
inline std::string* SelectiveAck::mutable_id(int index) {
// @@protoc_insertion_point(field_mutable:mcs_proto.SelectiveAck.id)
return id_.Mutable(index);
}
inline void SelectiveAck::set_id(int index, const std::string& value) {
id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::set_id(int index, std::string&& value) {
id_.Mutable(index)->assign(std::move(value));
// @@protoc_insertion_point(field_set:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::set_id(int index, const char* value) {
GOOGLE_DCHECK(value != nullptr);
id_.Mutable(index)->assign(value);
// @@protoc_insertion_point(field_set_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::set_id(int index, const char* value, size_t size) {
id_.Mutable(index)->assign(
reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_set_pointer:mcs_proto.SelectiveAck.id)
}
inline std::string* SelectiveAck::_internal_add_id() {
return id_.Add();
}
inline void SelectiveAck::add_id(const std::string& value) {
id_.Add()->assign(value);
// @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(std::string&& value) {
id_.Add(std::move(value));
// @@protoc_insertion_point(field_add:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value) {
GOOGLE_DCHECK(value != nullptr);
id_.Add()->assign(value);
// @@protoc_insertion_point(field_add_char:mcs_proto.SelectiveAck.id)
}
inline void SelectiveAck::add_id(const char* value, size_t size) {
id_.Add()->assign(reinterpret_cast<const char*>(value), size);
// @@protoc_insertion_point(field_add_pointer:mcs_proto.SelectiveAck.id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SelectiveAck::id() const {
// @@protoc_insertion_point(field_list:mcs_proto.SelectiveAck.id)
return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SelectiveAck::mutable_id() {
// @@protoc_insertion_point(field_mutable_list:mcs_proto.SelectiveAck.id)
return &id_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mcs_proto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::mcs_proto::ClientEvent_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::mcs_proto::LoginRequest_AuthService> : ::std::true_type {};
template <> struct is_proto_enum< ::mcs_proto::IqStanza_IqType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_mcs_2eproto
