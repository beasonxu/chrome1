// gpu/ipc/common/gpu_channel.mojom-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_TEST_UTILS_H_
#define GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_TEST_UTILS_H_

#include "gpu/ipc/common/gpu_channel.mojom.h"
#include "gpu/gpu_export.h"


namespace gpu {
namespace mojom {


class GPU_EXPORT GpuChannelInterceptorForTesting : public GpuChannel {
  virtual GpuChannel* GetForwardingInterface() = 0;
  void CrashForTesting() override;
  void TerminateForTesting() override;
  void GetChannelToken(GetChannelTokenCallback callback) override;
  void Flush(FlushCallback callback) override;
  void CreateCommandBuffer(CreateCommandBufferParamsPtr params, int32_t routing_id, ::base::UnsafeSharedMemoryRegion shared_state, ::mojo::PendingAssociatedReceiver<CommandBuffer> receiver, ::mojo::PendingAssociatedRemote<CommandBufferClient> client, CreateCommandBufferCallback callback) override;
  void DestroyCommandBuffer(int32_t routing_id, DestroyCommandBufferCallback callback) override;
  void ScheduleImageDecode(ScheduleImageDecodeParamsPtr params, uint64_t decode_release_count) override;
  void FlushDeferredRequests(std::vector<DeferredRequestPtr> requests) override;
  void CreateStreamTexture(int32_t stream_id, ::mojo::PendingAssociatedReceiver<StreamTexture> receiver, CreateStreamTextureCallback callback) override;
  void WaitForTokenInRange(int32_t routing_id, int32_t start, int32_t end, WaitForTokenInRangeCallback callback) override;
  void WaitForGetOffsetInRange(int32_t routing_id, uint32_t set_get_buffer_count, int32_t start, int32_t end, WaitForGetOffsetInRangeCallback callback) override;
};
class GPU_EXPORT GpuChannelAsyncWaiter {
 public:
  explicit GpuChannelAsyncWaiter(GpuChannel* proxy);

  GpuChannelAsyncWaiter(const GpuChannelAsyncWaiter&) = delete;
  GpuChannelAsyncWaiter& operator=(const GpuChannelAsyncWaiter&) = delete;

  ~GpuChannelAsyncWaiter();
  void GetChannelToken(
      ::base::UnguessableToken* out_token);
  void Flush(
      );
  void CreateCommandBuffer(
      CreateCommandBufferParamsPtr params, int32_t routing_id, ::base::UnsafeSharedMemoryRegion shared_state, ::mojo::PendingAssociatedReceiver<CommandBuffer> receiver, ::mojo::PendingAssociatedRemote<CommandBufferClient> client, ::gpu::ContextResult* out_result, ::gpu::Capabilities* out_capabilties);
  void DestroyCommandBuffer(
      int32_t routing_id);
  void CreateStreamTexture(
      int32_t stream_id, ::mojo::PendingAssociatedReceiver<StreamTexture> receiver, bool* out_success);
  void WaitForTokenInRange(
      int32_t routing_id, int32_t start, int32_t end, ::gpu::CommandBuffer::State* out_state);
  void WaitForGetOffsetInRange(
      int32_t routing_id, uint32_t set_get_buffer_count, int32_t start, int32_t end, ::gpu::CommandBuffer::State* out_state);

 private:
  GpuChannel* const proxy_;
};


class GPU_EXPORT CommandBufferInterceptorForTesting : public CommandBuffer {
  virtual CommandBuffer* GetForwardingInterface() = 0;
  void SetGetBuffer(int32_t shm_id) override;
  void RegisterTransferBuffer(int32_t id, ::base::UnsafeSharedMemoryRegion buffer) override;
  void CreateGpuFenceFromHandle(uint32_t gpu_fence_id, ::gfx::GpuFenceHandle fence_handle) override;
  void GetGpuFenceHandle(uint32_t id, GetGpuFenceHandleCallback callback) override;
  void SignalSyncToken(const ::gpu::SyncToken& sync_token, uint32_t signal_id) override;
  void SignalQuery(uint32_t query, uint32_t signal_id) override;
  void BindMediaReceiver(::mojo::GenericPendingAssociatedReceiver receiver, BindMediaReceiverCallback callback) override;
};
class GPU_EXPORT CommandBufferAsyncWaiter {
 public:
  explicit CommandBufferAsyncWaiter(CommandBuffer* proxy);

  CommandBufferAsyncWaiter(const CommandBufferAsyncWaiter&) = delete;
  CommandBufferAsyncWaiter& operator=(const CommandBufferAsyncWaiter&) = delete;

  ~CommandBufferAsyncWaiter();
  void GetGpuFenceHandle(
      uint32_t id, ::gfx::GpuFenceHandle* out_fence_handle);
  void BindMediaReceiver(
      ::mojo::GenericPendingAssociatedReceiver receiver);

 private:
  CommandBuffer* const proxy_;
};


class GPU_EXPORT CommandBufferClientInterceptorForTesting : public CommandBufferClient {
  virtual CommandBufferClient* GetForwardingInterface() = 0;
  void OnConsoleMessage(const std::string& message) override;
  void OnGpuSwitched(::gl::GpuPreference active_gpu_heuristic) override;
  void OnDestroyed(::gpu::error::ContextLostReason reason, ::gpu::error::Error error) override;
  void OnReturnData(const std::vector<uint8_t>& data) override;
  void OnSignalAck(uint32_t signal_id, const ::gpu::CommandBuffer::State& state) override;
};
class GPU_EXPORT CommandBufferClientAsyncWaiter {
 public:
  explicit CommandBufferClientAsyncWaiter(CommandBufferClient* proxy);

  CommandBufferClientAsyncWaiter(const CommandBufferClientAsyncWaiter&) = delete;
  CommandBufferClientAsyncWaiter& operator=(const CommandBufferClientAsyncWaiter&) = delete;

  ~CommandBufferClientAsyncWaiter();

 private:
  CommandBufferClient* const proxy_;
};


class GPU_EXPORT StreamTextureInterceptorForTesting : public StreamTexture {
  virtual StreamTexture* GetForwardingInterface() = 0;
  void ForwardForSurfaceRequest(const ::base::UnguessableToken& token) override;
  void StartListening(::mojo::PendingAssociatedRemote<StreamTextureClient> client) override;
  void UpdateRotatedVisibleSize(const ::gfx::Size& rotated_visible_size) override;
};
class GPU_EXPORT StreamTextureAsyncWaiter {
 public:
  explicit StreamTextureAsyncWaiter(StreamTexture* proxy);

  StreamTextureAsyncWaiter(const StreamTextureAsyncWaiter&) = delete;
  StreamTextureAsyncWaiter& operator=(const StreamTextureAsyncWaiter&) = delete;

  ~StreamTextureAsyncWaiter();

 private:
  StreamTexture* const proxy_;
};


class GPU_EXPORT StreamTextureClientInterceptorForTesting : public StreamTextureClient {
  virtual StreamTextureClient* GetForwardingInterface() = 0;
  void OnFrameAvailable() override;
  void OnFrameWithInfoAvailable(const ::gpu::Mailbox& mailbox, const ::gfx::Size& coded_size, const ::gfx::Rect& visible_rect, absl::optional<::gpu::VulkanYCbCrInfo> info) override;
};
class GPU_EXPORT StreamTextureClientAsyncWaiter {
 public:
  explicit StreamTextureClientAsyncWaiter(StreamTextureClient* proxy);

  StreamTextureClientAsyncWaiter(const StreamTextureClientAsyncWaiter&) = delete;
  StreamTextureClientAsyncWaiter& operator=(const StreamTextureClientAsyncWaiter&) = delete;

  ~StreamTextureClientAsyncWaiter();

 private:
  StreamTextureClient* const proxy_;
};




}  // namespace mojom
}  // namespace gpu

#endif  // GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_TEST_UTILS_H_