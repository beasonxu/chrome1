// gpu/ipc/common/gpu_channel.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_SHARED_H_
#define GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "gpu/ipc/common/gpu_channel.mojom-shared-internal.h"
#include "gpu/ipc/common/capabilities.mojom-shared.h"
#include "gpu/ipc/common/context_result.mojom-shared.h"
#include "gpu/ipc/common/mailbox.mojom-shared.h"
#include "gpu/ipc/common/surface_handle.mojom-shared.h"
#include "gpu/ipc/common/sync_token.mojom-shared.h"
#include "gpu/ipc/common/vulkan_ycbcr_info.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"
#include "mojo/public/mojom/base/generic_pending_associated_receiver.mojom-shared.h"
#include "services/viz/public/mojom/compositing/resource_format.mojom-shared.h"
#include "skia/public/mojom/image_info.mojom-shared.h"
#include "skia/public/mojom/surface_origin.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/mojom/buffer_types.mojom-shared.h"
#include "ui/gfx/mojom/color_space.mojom-shared.h"
#include "ui/gfx/mojom/gpu_fence_handle.mojom-shared.h"
#include "ui/gfx/mojom/presentation_feedback.mojom-shared.h"
#include "ui/gl/mojom/gpu_preference.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "base/component_export.h"




namespace gpu {
namespace mojom {
class ContextCreationAttribsDataView;

class CreateCommandBufferParamsDataView;

class CommandBufferStateDataView;

class ScheduleImageDecodeParamsDataView;

using SwapBuffersCompleteParamsDataView = mojo::native::NativeStructDataView;

class DeferredRequestDataView;

class DeferredCommandBufferRequestDataView;

class AsyncFlushParamsDataView;

class ReturnFrontBufferParamsDataView;

class CreateSharedImageParamsDataView;

class CreateSharedImageWithDataParamsDataView;

class CreateGMBSharedImageParamsDataView;

class UpdateSharedImageParamsDataView;

class DeferredRequestParamsDataView;
class DeferredCommandBufferRequestParamsDataView;
class DeferredSharedImageRequestDataView;


}  // namespace mojom
}  // namespace gpu

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::gpu::mojom::ContextCreationAttribsDataView> {
  using Data = ::gpu::mojom::internal::ContextCreationAttribs_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::CreateCommandBufferParamsDataView> {
  using Data = ::gpu::mojom::internal::CreateCommandBufferParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::CommandBufferStateDataView> {
  using Data = ::gpu::mojom::internal::CommandBufferState_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::ScheduleImageDecodeParamsDataView> {
  using Data = ::gpu::mojom::internal::ScheduleImageDecodeParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::DeferredRequestDataView> {
  using Data = ::gpu::mojom::internal::DeferredRequest_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::DeferredCommandBufferRequestDataView> {
  using Data = ::gpu::mojom::internal::DeferredCommandBufferRequest_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::AsyncFlushParamsDataView> {
  using Data = ::gpu::mojom::internal::AsyncFlushParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::ReturnFrontBufferParamsDataView> {
  using Data = ::gpu::mojom::internal::ReturnFrontBufferParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::CreateSharedImageParamsDataView> {
  using Data = ::gpu::mojom::internal::CreateSharedImageParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::CreateSharedImageWithDataParamsDataView> {
  using Data = ::gpu::mojom::internal::CreateSharedImageWithDataParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::CreateGMBSharedImageParamsDataView> {
  using Data = ::gpu::mojom::internal::CreateGMBSharedImageParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::UpdateSharedImageParamsDataView> {
  using Data = ::gpu::mojom::internal::UpdateSharedImageParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::gpu::mojom::DeferredRequestParamsDataView> {
  using Data = ::gpu::mojom::internal::DeferredRequestParams_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::gpu::mojom::DeferredCommandBufferRequestParamsDataView> {
  using Data = ::gpu::mojom::internal::DeferredCommandBufferRequestParams_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::gpu::mojom::DeferredSharedImageRequestDataView> {
  using Data = ::gpu::mojom::internal::DeferredSharedImageRequest_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace gpu {
namespace mojom {


enum class ContextType : int32_t {
  
  kWebGL1 = 0,
  
  kWebGL2 = 1,
  
  kOpenGLES2 = 2,
  
  kOpenGLES3 = 3,
  
  kOpenGLES31ForTesting = 4,
  
  kWebGPU = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) std::ostream& operator<<(std::ostream& os, ContextType value);
inline bool IsKnownEnumValue(ContextType value) {
  return internal::ContextType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ContextColorSpace : int32_t {
  
  kUnspecified = 0,
  
  kSRGB = 1,
  
  kDisplayP3 = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) std::ostream& operator<<(std::ostream& os, ContextColorSpace value);
inline bool IsKnownEnumValue(ContextColorSpace value) {
  return internal::ContextColorSpace_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class SchedulingPriority : int32_t {
  
  kHigh = 0,
  
  kNormal = 1,
  
  kLow = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) std::ostream& operator<<(std::ostream& os, SchedulingPriority value);
inline bool IsKnownEnumValue(SchedulingPriority value) {
  return internal::SchedulingPriority_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
using Error = mojo::NativeEnum;
using ContextLostReason = mojo::NativeEnum;
// Interface base classes. They are used for type safety check.
class GpuChannelInterfaceBase {};

using GpuChannelPtrDataView =
    mojo::InterfacePtrDataView<GpuChannelInterfaceBase>;
using GpuChannelRequestDataView =
    mojo::InterfaceRequestDataView<GpuChannelInterfaceBase>;
using GpuChannelAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<GpuChannelInterfaceBase>;
using GpuChannelAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<GpuChannelInterfaceBase>;
class CommandBufferInterfaceBase {};

using CommandBufferPtrDataView =
    mojo::InterfacePtrDataView<CommandBufferInterfaceBase>;
using CommandBufferRequestDataView =
    mojo::InterfaceRequestDataView<CommandBufferInterfaceBase>;
using CommandBufferAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<CommandBufferInterfaceBase>;
using CommandBufferAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<CommandBufferInterfaceBase>;
class CommandBufferClientInterfaceBase {};

using CommandBufferClientPtrDataView =
    mojo::InterfacePtrDataView<CommandBufferClientInterfaceBase>;
using CommandBufferClientRequestDataView =
    mojo::InterfaceRequestDataView<CommandBufferClientInterfaceBase>;
using CommandBufferClientAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<CommandBufferClientInterfaceBase>;
using CommandBufferClientAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<CommandBufferClientInterfaceBase>;
class StreamTextureInterfaceBase {};

using StreamTexturePtrDataView =
    mojo::InterfacePtrDataView<StreamTextureInterfaceBase>;
using StreamTextureRequestDataView =
    mojo::InterfaceRequestDataView<StreamTextureInterfaceBase>;
using StreamTextureAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<StreamTextureInterfaceBase>;
using StreamTextureAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<StreamTextureInterfaceBase>;
class StreamTextureClientInterfaceBase {};

using StreamTextureClientPtrDataView =
    mojo::InterfacePtrDataView<StreamTextureClientInterfaceBase>;
using StreamTextureClientRequestDataView =
    mojo::InterfaceRequestDataView<StreamTextureClientInterfaceBase>;
using StreamTextureClientAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<StreamTextureClientInterfaceBase>;
using StreamTextureClientAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<StreamTextureClientInterfaceBase>;


class ContextCreationAttribsDataView {
 public:
  ContextCreationAttribsDataView() = default;

  ContextCreationAttribsDataView(
      internal::ContextCreationAttribs_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetOffscreenFramebufferSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOffscreenFramebufferSize(UserType* output) {
    
    auto* pointer = data_->offscreen_framebuffer_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadGpuPreference(UserType* output) const {
    auto data_value = data_->gpu_preference;
    return mojo::internal::Deserialize<::gl::mojom::GpuPreference>(
        data_value, output);
  }
  ::gl::mojom::GpuPreference gpu_preference() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gl::mojom::GpuPreference>(data_->gpu_preference));
  }
  int32_t alpha_size() const {
    return data_->alpha_size;
  }
  int32_t blue_size() const {
    return data_->blue_size;
  }
  int32_t green_size() const {
    return data_->green_size;
  }
  int32_t red_size() const {
    return data_->red_size;
  }
  int32_t depth_size() const {
    return data_->depth_size;
  }
  int32_t stencil_size() const {
    return data_->stencil_size;
  }
  int32_t samples() const {
    return data_->samples;
  }
  int32_t sample_buffers() const {
    return data_->sample_buffers;
  }
  bool buffer_preserved() const {
    return data_->buffer_preserved;
  }
  bool bind_generates_resource() const {
    return data_->bind_generates_resource;
  }
  bool fail_if_major_perf_caveat() const {
    return data_->fail_if_major_perf_caveat;
  }
  bool lose_context_when_out_of_memory() const {
    return data_->lose_context_when_out_of_memory;
  }
  bool should_use_native_gmb_for_backbuffer() const {
    return data_->should_use_native_gmb_for_backbuffer;
  }
  bool own_offscreen_surface() const {
    return data_->own_offscreen_surface;
  }
  bool single_buffer() const {
    return data_->single_buffer;
  }
  bool enable_gles2_interface() const {
    return data_->enable_gles2_interface;
  }
  bool enable_grcontext() const {
    return data_->enable_grcontext;
  }
  bool enable_raster_interface() const {
    return data_->enable_raster_interface;
  }
  bool enable_oop_rasterization() const {
    return data_->enable_oop_rasterization;
  }
  bool enable_swap_timestamps_if_supported() const {
    return data_->enable_swap_timestamps_if_supported;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadContextType(UserType* output) const {
    auto data_value = data_->context_type;
    return mojo::internal::Deserialize<::gpu::mojom::ContextType>(
        data_value, output);
  }
  ContextType context_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gpu::mojom::ContextType>(data_->context_type));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) const {
    auto data_value = data_->color_space;
    return mojo::internal::Deserialize<::gpu::mojom::ContextColorSpace>(
        data_value, output);
  }
  ContextColorSpace color_space() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gpu::mojom::ContextColorSpace>(data_->color_space));
  }
 private:
  internal::ContextCreationAttribs_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CreateCommandBufferParamsDataView {
 public:
  CreateCommandBufferParamsDataView() = default;

  CreateCommandBufferParamsDataView(
      internal::CreateCommandBufferParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetSurfaceHandleDataView(
      ::gpu::mojom::SurfaceHandleDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSurfaceHandle(UserType* output) {
    
    auto* pointer = data_->surface_handle.Get();
    return mojo::internal::Deserialize<::gpu::mojom::SurfaceHandleDataView>(
        pointer, output, message_);
  }
  int32_t share_group_id() const {
    return data_->share_group_id;
  }
  int32_t stream_id() const {
    return data_->stream_id;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadStreamPriority(UserType* output) const {
    auto data_value = data_->stream_priority;
    return mojo::internal::Deserialize<::gpu::mojom::SchedulingPriority>(
        data_value, output);
  }
  SchedulingPriority stream_priority() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gpu::mojom::SchedulingPriority>(data_->stream_priority));
  }
  inline void GetAttribsDataView(
      ContextCreationAttribsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAttribs(UserType* output) {
    
    auto* pointer = data_->attribs.Get();
    return mojo::internal::Deserialize<::gpu::mojom::ContextCreationAttribsDataView>(
        pointer, output, message_);
  }
  inline void GetActiveUrlDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadActiveUrl(UserType* output) {
    
    auto* pointer = data_->active_url.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
 private:
  internal::CreateCommandBufferParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CommandBufferStateDataView {
 public:
  CommandBufferStateDataView() = default;

  CommandBufferStateDataView(
      internal::CommandBufferState_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t get_offset() const {
    return data_->get_offset;
  }
  int32_t token() const {
    return data_->token;
  }
  uint64_t release_count() const {
    return data_->release_count;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadError(UserType* output) const {
    auto data_value = data_->error;
    return mojo::internal::Deserialize<::gpu::mojom::Error>(
        data_value, output);
  }
  Error error() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gpu::mojom::Error>(data_->error));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadContextLostReason(UserType* output) const {
    auto data_value = data_->context_lost_reason;
    return mojo::internal::Deserialize<::gpu::mojom::ContextLostReason>(
        data_value, output);
  }
  ContextLostReason context_lost_reason() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gpu::mojom::ContextLostReason>(data_->context_lost_reason));
  }
  uint32_t generation() const {
    return data_->generation;
  }
  uint32_t set_get_buffer_count() const {
    return data_->set_get_buffer_count;
  }
 private:
  internal::CommandBufferState_Data* data_ = nullptr;
};



class ScheduleImageDecodeParamsDataView {
 public:
  ScheduleImageDecodeParamsDataView() = default;

  ScheduleImageDecodeParamsDataView(
      internal::ScheduleImageDecodeParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetEncodedDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadEncodedData(UserType* output) {
    
    auto* pointer = data_->encoded_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetOutputSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOutputSize(UserType* output) {
    
    auto* pointer = data_->output_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  int32_t raster_decoder_route_id() const {
    return data_->raster_decoder_route_id;
  }
  uint32_t transfer_cache_entry_id() const {
    return data_->transfer_cache_entry_id;
  }
  int32_t discardable_handle_shm_id() const {
    return data_->discardable_handle_shm_id;
  }
  uint32_t discardable_handle_shm_offset() const {
    return data_->discardable_handle_shm_offset;
  }
  uint64_t discardable_handle_release_count() const {
    return data_->discardable_handle_release_count;
  }
  inline void GetTargetColorSpaceDataView(
      ::gfx::mojom::ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTargetColorSpace(UserType* output) {
    
    auto* pointer = data_->target_color_space.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  bool needs_mips() const {
    return data_->needs_mips;
  }
 private:
  internal::ScheduleImageDecodeParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DeferredRequestDataView {
 public:
  DeferredRequestDataView() = default;

  DeferredRequestDataView(
      internal::DeferredRequest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetParamsDataView(
      DeferredRequestParamsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParams(UserType* output) {
    
    auto* pointer = !data_->params.is_null() ? &data_->params : nullptr;
    return mojo::internal::Deserialize<::gpu::mojom::DeferredRequestParamsDataView>(
        pointer, output, message_);
  }
  inline void GetSyncTokenFencesDataView(
      mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSyncTokenFences(UserType* output) {
    
    auto* pointer = data_->sync_token_fences.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>>(
        pointer, output, message_);
  }
 private:
  internal::DeferredRequest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DeferredCommandBufferRequestDataView {
 public:
  DeferredCommandBufferRequestDataView() = default;

  DeferredCommandBufferRequestDataView(
      internal::DeferredCommandBufferRequest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t routing_id() const {
    return data_->routing_id;
  }
  inline void GetParamsDataView(
      DeferredCommandBufferRequestParamsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParams(UserType* output) {
    
    auto* pointer = !data_->params.is_null() ? &data_->params : nullptr;
    return mojo::internal::Deserialize<::gpu::mojom::DeferredCommandBufferRequestParamsDataView>(
        pointer, output, message_);
  }
 private:
  internal::DeferredCommandBufferRequest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AsyncFlushParamsDataView {
 public:
  AsyncFlushParamsDataView() = default;

  AsyncFlushParamsDataView(
      internal::AsyncFlushParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t put_offset() const {
    return data_->put_offset;
  }
  uint32_t flush_id() const {
    return data_->flush_id;
  }
  inline void GetSyncTokenFencesDataView(
      mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSyncTokenFences(UserType* output) {
    
    auto* pointer = data_->sync_token_fences.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>>(
        pointer, output, message_);
  }
 private:
  internal::AsyncFlushParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ReturnFrontBufferParamsDataView {
 public:
  ReturnFrontBufferParamsDataView() = default;

  ReturnFrontBufferParamsDataView(
      internal::ReturnFrontBufferParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetMailboxDataView(
      ::gpu::mojom::MailboxDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailbox(UserType* output) {
    
    auto* pointer = data_->mailbox.Get();
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        pointer, output, message_);
  }
  bool is_lost() const {
    return data_->is_lost;
  }
 private:
  internal::ReturnFrontBufferParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CreateSharedImageParamsDataView {
 public:
  CreateSharedImageParamsDataView() = default;

  CreateSharedImageParamsDataView(
      internal::CreateSharedImageParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetMailboxDataView(
      ::gpu::mojom::MailboxDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailbox(UserType* output) {
    
    auto* pointer = data_->mailbox.Get();
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadFormat(UserType* output) const {
    auto data_value = data_->format;
    return mojo::internal::Deserialize<::viz::mojom::ResourceFormat>(
        data_value, output);
  }
  ::viz::mojom::ResourceFormat format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::viz::mojom::ResourceFormat>(data_->format));
  }
  inline void GetSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSize(UserType* output) {
    
    auto* pointer = data_->size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetColorSpaceDataView(
      ::gfx::mojom::ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) {
    
    auto* pointer = data_->color_space.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  uint32_t usage() const {
    return data_->usage;
  }
  uint32_t release_id() const {
    return data_->release_id;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSurfaceOrigin(UserType* output) const {
    auto data_value = data_->surface_origin;
    return mojo::internal::Deserialize<::skia::mojom::SurfaceOrigin>(
        data_value, output);
  }
  ::skia::mojom::SurfaceOrigin surface_origin() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::skia::mojom::SurfaceOrigin>(data_->surface_origin));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAlphaType(UserType* output) const {
    auto data_value = data_->alpha_type;
    return mojo::internal::Deserialize<::skia::mojom::AlphaType>(
        data_value, output);
  }
  ::skia::mojom::AlphaType alpha_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::skia::mojom::AlphaType>(data_->alpha_type));
  }
 private:
  internal::CreateSharedImageParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CreateSharedImageWithDataParamsDataView {
 public:
  CreateSharedImageWithDataParamsDataView() = default;

  CreateSharedImageWithDataParamsDataView(
      internal::CreateSharedImageWithDataParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetMailboxDataView(
      ::gpu::mojom::MailboxDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailbox(UserType* output) {
    
    auto* pointer = data_->mailbox.Get();
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadFormat(UserType* output) const {
    auto data_value = data_->format;
    return mojo::internal::Deserialize<::viz::mojom::ResourceFormat>(
        data_value, output);
  }
  ::viz::mojom::ResourceFormat format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::viz::mojom::ResourceFormat>(data_->format));
  }
  inline void GetSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSize(UserType* output) {
    
    auto* pointer = data_->size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetColorSpaceDataView(
      ::gfx::mojom::ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) {
    
    auto* pointer = data_->color_space.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  uint32_t usage() const {
    return data_->usage;
  }
  uint32_t release_id() const {
    return data_->release_id;
  }
  uint32_t pixel_data_offset() const {
    return data_->pixel_data_offset;
  }
  uint32_t pixel_data_size() const {
    return data_->pixel_data_size;
  }
  bool done_with_shm() const {
    return data_->done_with_shm;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSurfaceOrigin(UserType* output) const {
    auto data_value = data_->surface_origin;
    return mojo::internal::Deserialize<::skia::mojom::SurfaceOrigin>(
        data_value, output);
  }
  ::skia::mojom::SurfaceOrigin surface_origin() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::skia::mojom::SurfaceOrigin>(data_->surface_origin));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAlphaType(UserType* output) const {
    auto data_value = data_->alpha_type;
    return mojo::internal::Deserialize<::skia::mojom::AlphaType>(
        data_value, output);
  }
  ::skia::mojom::AlphaType alpha_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::skia::mojom::AlphaType>(data_->alpha_type));
  }
 private:
  internal::CreateSharedImageWithDataParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CreateGMBSharedImageParamsDataView {
 public:
  CreateGMBSharedImageParamsDataView() = default;

  CreateGMBSharedImageParamsDataView(
      internal::CreateGMBSharedImageParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetMailboxDataView(
      ::gpu::mojom::MailboxDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailbox(UserType* output) {
    
    auto* pointer = data_->mailbox.Get();
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        pointer, output, message_);
  }
  inline void GetBufferHandleDataView(
      ::gfx::mojom::GpuMemoryBufferHandleDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBufferHandle(UserType* output) {
    
    auto* pointer = data_->buffer_handle.Get();
    return mojo::internal::Deserialize<::gfx::mojom::GpuMemoryBufferHandleDataView>(
        pointer, output, message_);
  }
  inline void GetSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSize(UserType* output) {
    
    auto* pointer = data_->size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadFormat(UserType* output) const {
    auto data_value = data_->format;
    return mojo::internal::Deserialize<::gfx::mojom::BufferFormat>(
        data_value, output);
  }
  ::gfx::mojom::BufferFormat format() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gfx::mojom::BufferFormat>(data_->format));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadPlane(UserType* output) const {
    auto data_value = data_->plane;
    return mojo::internal::Deserialize<::gfx::mojom::BufferPlane>(
        data_value, output);
  }
  ::gfx::mojom::BufferPlane plane() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::gfx::mojom::BufferPlane>(data_->plane));
  }
  inline void GetColorSpaceDataView(
      ::gfx::mojom::ColorSpaceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadColorSpace(UserType* output) {
    
    auto* pointer = data_->color_space.Get();
    return mojo::internal::Deserialize<::gfx::mojom::ColorSpaceDataView>(
        pointer, output, message_);
  }
  uint32_t usage() const {
    return data_->usage;
  }
  uint32_t release_id() const {
    return data_->release_id;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSurfaceOrigin(UserType* output) const {
    auto data_value = data_->surface_origin;
    return mojo::internal::Deserialize<::skia::mojom::SurfaceOrigin>(
        data_value, output);
  }
  ::skia::mojom::SurfaceOrigin surface_origin() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::skia::mojom::SurfaceOrigin>(data_->surface_origin));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAlphaType(UserType* output) const {
    auto data_value = data_->alpha_type;
    return mojo::internal::Deserialize<::skia::mojom::AlphaType>(
        data_value, output);
  }
  ::skia::mojom::AlphaType alpha_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::skia::mojom::AlphaType>(data_->alpha_type));
  }
 private:
  internal::CreateGMBSharedImageParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class UpdateSharedImageParamsDataView {
 public:
  UpdateSharedImageParamsDataView() = default;

  UpdateSharedImageParamsDataView(
      internal::UpdateSharedImageParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetMailboxDataView(
      ::gpu::mojom::MailboxDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMailbox(UserType* output) {
    
    auto* pointer = data_->mailbox.Get();
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        pointer, output, message_);
  }
  uint32_t release_id() const {
    return data_->release_id;
  }
  inline void GetInFenceHandleDataView(
      ::gfx::mojom::GpuFenceHandleDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInFenceHandle(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::GpuFenceHandleDataView, UserType>(),
    "Attempting to read the optional `in_fence_handle` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInFenceHandle` instead "
    "of `ReadInFenceHandle if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->in_fence_handle.Get();
    return mojo::internal::Deserialize<::gfx::mojom::GpuFenceHandleDataView>(
        pointer, output, message_);
  }
 private:
  internal::UpdateSharedImageParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DeferredRequestParamsDataView {
 public:
  using Tag = internal::DeferredRequestParams_Data::DeferredRequestParams_Tag;

  DeferredRequestParamsDataView() = default;

  DeferredRequestParamsDataView(
      internal::DeferredRequestParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_command_buffer_request() const { return data_->tag == Tag::kCommandBufferRequest; }
  inline void GetCommandBufferRequestDataView(
      DeferredCommandBufferRequestDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadCommandBufferRequest(UserType* output) const {
    
    CHECK(is_command_buffer_request());
    return mojo::internal::Deserialize<::gpu::mojom::DeferredCommandBufferRequestDataView>(
        data_->data.f_command_buffer_request.Get(), output, message_);
  }
  bool is_shared_image_request() const { return data_->tag == Tag::kSharedImageRequest; }
  inline void GetSharedImageRequestDataView(
      DeferredSharedImageRequestDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadSharedImageRequest(UserType* output) const {
    
    CHECK(is_shared_image_request());
    return mojo::internal::Deserialize<::gpu::mojom::DeferredSharedImageRequestDataView>(
        data_->data.f_shared_image_request.Get(), output, message_);
  }
  bool is_destroy_stream_texture() const { return data_->tag == Tag::kDestroyStreamTexture; }
  int32_t destroy_stream_texture() const {
    CHECK(is_destroy_stream_texture());
    return data_->data.f_destroy_stream_texture;
  }

 private:
  internal::DeferredRequestParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DeferredCommandBufferRequestParamsDataView {
 public:
  using Tag = internal::DeferredCommandBufferRequestParams_Data::DeferredCommandBufferRequestParams_Tag;

  DeferredCommandBufferRequestParamsDataView() = default;

  DeferredCommandBufferRequestParamsDataView(
      internal::DeferredCommandBufferRequestParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_async_flush() const { return data_->tag == Tag::kAsyncFlush; }
  inline void GetAsyncFlushDataView(
      AsyncFlushParamsDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadAsyncFlush(UserType* output) const {
    
    CHECK(is_async_flush());
    return mojo::internal::Deserialize<::gpu::mojom::AsyncFlushParamsDataView>(
        data_->data.f_async_flush.Get(), output, message_);
  }
  bool is_destroy_transfer_buffer() const { return data_->tag == Tag::kDestroyTransferBuffer; }
  int32_t destroy_transfer_buffer() const {
    CHECK(is_destroy_transfer_buffer());
    return data_->data.f_destroy_transfer_buffer;
  }
  bool is_take_front_buffer() const { return data_->tag == Tag::kTakeFrontBuffer; }
  inline void GetTakeFrontBufferDataView(
      ::gpu::mojom::MailboxDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadTakeFrontBuffer(UserType* output) const {
    
    CHECK(is_take_front_buffer());
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        data_->data.f_take_front_buffer.Get(), output, message_);
  }
  bool is_return_front_buffer() const { return data_->tag == Tag::kReturnFrontBuffer; }
  inline void GetReturnFrontBufferDataView(
      ReturnFrontBufferParamsDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadReturnFrontBuffer(UserType* output) const {
    
    CHECK(is_return_front_buffer());
    return mojo::internal::Deserialize<::gpu::mojom::ReturnFrontBufferParamsDataView>(
        data_->data.f_return_front_buffer.Get(), output, message_);
  }

 private:
  internal::DeferredCommandBufferRequestParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DeferredSharedImageRequestDataView {
 public:
  using Tag = internal::DeferredSharedImageRequest_Data::DeferredSharedImageRequest_Tag;

  DeferredSharedImageRequestDataView() = default;

  DeferredSharedImageRequestDataView(
      internal::DeferredSharedImageRequest_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_nop() const { return data_->tag == Tag::kNop; }
  uint8_t nop() const {
    CHECK(is_nop());
    return data_->data.f_nop;
  }
  bool is_create_shared_image() const { return data_->tag == Tag::kCreateSharedImage; }
  inline void GetCreateSharedImageDataView(
      CreateSharedImageParamsDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadCreateSharedImage(UserType* output) const {
    
    CHECK(is_create_shared_image());
    return mojo::internal::Deserialize<::gpu::mojom::CreateSharedImageParamsDataView>(
        data_->data.f_create_shared_image.Get(), output, message_);
  }
  bool is_create_shared_image_with_data() const { return data_->tag == Tag::kCreateSharedImageWithData; }
  inline void GetCreateSharedImageWithDataDataView(
      CreateSharedImageWithDataParamsDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadCreateSharedImageWithData(UserType* output) const {
    
    CHECK(is_create_shared_image_with_data());
    return mojo::internal::Deserialize<::gpu::mojom::CreateSharedImageWithDataParamsDataView>(
        data_->data.f_create_shared_image_with_data.Get(), output, message_);
  }
  bool is_create_gmb_shared_image() const { return data_->tag == Tag::kCreateGmbSharedImage; }
  inline void GetCreateGmbSharedImageDataView(
      CreateGMBSharedImageParamsDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadCreateGmbSharedImage(UserType* output) const {
    
    CHECK(is_create_gmb_shared_image());
    return mojo::internal::Deserialize<::gpu::mojom::CreateGMBSharedImageParamsDataView>(
        data_->data.f_create_gmb_shared_image.Get(), output, message_);
  }
  bool is_register_upload_buffer() const { return data_->tag == Tag::kRegisterUploadBuffer; }
  inline void GetRegisterUploadBufferDataView(
      ::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadRegisterUploadBuffer(UserType* output) const {
    
    CHECK(is_register_upload_buffer());
    return mojo::internal::Deserialize<::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView>(
        data_->data.f_register_upload_buffer.Get(), output, message_);
  }
  bool is_update_shared_image() const { return data_->tag == Tag::kUpdateSharedImage; }
  inline void GetUpdateSharedImageDataView(
      UpdateSharedImageParamsDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadUpdateSharedImage(UserType* output) const {
    
    CHECK(is_update_shared_image());
    return mojo::internal::Deserialize<::gpu::mojom::UpdateSharedImageParamsDataView>(
        data_->data.f_update_shared_image.Get(), output, message_);
  }
  bool is_destroy_shared_image() const { return data_->tag == Tag::kDestroySharedImage; }
  inline void GetDestroySharedImageDataView(
      ::gpu::mojom::MailboxDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadDestroySharedImage(UserType* output) const {
    
    CHECK(is_destroy_shared_image());
    return mojo::internal::Deserialize<::gpu::mojom::MailboxDataView>(
        data_->data.f_destroy_shared_image.Get(), output, message_);
  }

 private:
  internal::DeferredSharedImageRequest_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace gpu

namespace std {

template <>
struct hash<::gpu::mojom::ContextType>
    : public mojo::internal::EnumHashImpl<::gpu::mojom::ContextType> {};

template <>
struct hash<::gpu::mojom::ContextColorSpace>
    : public mojo::internal::EnumHashImpl<::gpu::mojom::ContextColorSpace> {};

template <>
struct hash<::gpu::mojom::SchedulingPriority>
    : public mojo::internal::EnumHashImpl<::gpu::mojom::SchedulingPriority> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::ContextType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::gpu::mojom::ContextType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::gpu::mojom::ContextType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::ContextColorSpace, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::gpu::mojom::ContextColorSpace, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::gpu::mojom::ContextColorSpace>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::SchedulingPriority, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::gpu::mojom::SchedulingPriority, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::gpu::mojom::SchedulingPriority>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::ContextCreationAttribsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::ContextCreationAttribsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::ContextCreationAttribs_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::offscreen_framebuffer_size(input)) in_offscreen_framebuffer_size = Traits::offscreen_framebuffer_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->offscreen_framebuffer_size)::BaseType> offscreen_framebuffer_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_offscreen_framebuffer_size, offscreen_framebuffer_size_fragment);
    fragment->offscreen_framebuffer_size.Set(
        offscreen_framebuffer_size_fragment.is_null() ? nullptr : offscreen_framebuffer_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->offscreen_framebuffer_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null offscreen_framebuffer_size in ContextCreationAttribs struct");
    mojo::internal::Serialize<::gl::mojom::GpuPreference>(
        Traits::gpu_preference(input), &fragment->gpu_preference);
    fragment->alpha_size = Traits::alpha_size(input);
    fragment->blue_size = Traits::blue_size(input);
    fragment->green_size = Traits::green_size(input);
    fragment->red_size = Traits::red_size(input);
    fragment->depth_size = Traits::depth_size(input);
    fragment->stencil_size = Traits::stencil_size(input);
    fragment->samples = Traits::samples(input);
    fragment->sample_buffers = Traits::sample_buffers(input);
    fragment->buffer_preserved = Traits::buffer_preserved(input);
    fragment->bind_generates_resource = Traits::bind_generates_resource(input);
    fragment->fail_if_major_perf_caveat = Traits::fail_if_major_perf_caveat(input);
    fragment->lose_context_when_out_of_memory = Traits::lose_context_when_out_of_memory(input);
    fragment->should_use_native_gmb_for_backbuffer = Traits::should_use_native_gmb_for_backbuffer(input);
    fragment->own_offscreen_surface = Traits::own_offscreen_surface(input);
    fragment->single_buffer = Traits::single_buffer(input);
    fragment->enable_gles2_interface = Traits::enable_gles2_interface(input);
    fragment->enable_grcontext = Traits::enable_grcontext(input);
    fragment->enable_raster_interface = Traits::enable_raster_interface(input);
    fragment->enable_oop_rasterization = Traits::enable_oop_rasterization(input);
    fragment->enable_swap_timestamps_if_supported = Traits::enable_swap_timestamps_if_supported(input);
    mojo::internal::Serialize<::gpu::mojom::ContextType>(
        Traits::context_type(input), &fragment->context_type);
    mojo::internal::Serialize<::gpu::mojom::ContextColorSpace>(
        Traits::color_space(input), &fragment->color_space);
  }

  static bool Deserialize(::gpu::mojom::internal::ContextCreationAttribs_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::ContextCreationAttribsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::CreateCommandBufferParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::CreateCommandBufferParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::CreateCommandBufferParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::surface_handle(input)) in_surface_handle = Traits::surface_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->surface_handle)::BaseType> surface_handle_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::SurfaceHandleDataView>(
        in_surface_handle, surface_handle_fragment);
    fragment->surface_handle.Set(
        surface_handle_fragment.is_null() ? nullptr : surface_handle_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->surface_handle.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null surface_handle in CreateCommandBufferParams struct");
    fragment->share_group_id = Traits::share_group_id(input);
    fragment->stream_id = Traits::stream_id(input);
    mojo::internal::Serialize<::gpu::mojom::SchedulingPriority>(
        Traits::stream_priority(input), &fragment->stream_priority);
    decltype(Traits::attribs(input)) in_attribs = Traits::attribs(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->attribs)::BaseType> attribs_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::ContextCreationAttribsDataView>(
        in_attribs, attribs_fragment);
    fragment->attribs.Set(
        attribs_fragment.is_null() ? nullptr : attribs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->attribs.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null attribs in CreateCommandBufferParams struct");
    decltype(Traits::active_url(input)) in_active_url = Traits::active_url(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->active_url)::BaseType> active_url_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_active_url, active_url_fragment);
    fragment->active_url.Set(
        active_url_fragment.is_null() ? nullptr : active_url_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->active_url.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null active_url in CreateCommandBufferParams struct");
  }

  static bool Deserialize(::gpu::mojom::internal::CreateCommandBufferParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::CreateCommandBufferParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::CommandBufferStateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::CommandBufferStateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::CommandBufferState_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->get_offset = Traits::get_offset(input);
    fragment->token = Traits::token(input);
    fragment->release_count = Traits::release_count(input);
    mojo::internal::Serialize<::gpu::mojom::Error>(
        Traits::error(input), &fragment->error);
    mojo::internal::Serialize<::gpu::mojom::ContextLostReason>(
        Traits::context_lost_reason(input), &fragment->context_lost_reason);
    fragment->generation = Traits::generation(input);
    fragment->set_get_buffer_count = Traits::set_get_buffer_count(input);
  }

  static bool Deserialize(::gpu::mojom::internal::CommandBufferState_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::CommandBufferStateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::ScheduleImageDecodeParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::ScheduleImageDecodeParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::ScheduleImageDecodeParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::encoded_data(input)) in_encoded_data = Traits::encoded_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->encoded_data)::BaseType>
        encoded_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams encoded_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_encoded_data, encoded_data_fragment, &encoded_data_validate_params);
    fragment->encoded_data.Set(
        encoded_data_fragment.is_null() ? nullptr : encoded_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->encoded_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null encoded_data in ScheduleImageDecodeParams struct");
    decltype(Traits::output_size(input)) in_output_size = Traits::output_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->output_size)::BaseType> output_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_output_size, output_size_fragment);
    fragment->output_size.Set(
        output_size_fragment.is_null() ? nullptr : output_size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->output_size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null output_size in ScheduleImageDecodeParams struct");
    fragment->raster_decoder_route_id = Traits::raster_decoder_route_id(input);
    fragment->transfer_cache_entry_id = Traits::transfer_cache_entry_id(input);
    fragment->discardable_handle_shm_id = Traits::discardable_handle_shm_id(input);
    fragment->discardable_handle_shm_offset = Traits::discardable_handle_shm_offset(input);
    fragment->discardable_handle_release_count = Traits::discardable_handle_release_count(input);
    decltype(Traits::target_color_space(input)) in_target_color_space = Traits::target_color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->target_color_space)::BaseType> target_color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
        in_target_color_space, target_color_space_fragment);
    fragment->target_color_space.Set(
        target_color_space_fragment.is_null() ? nullptr : target_color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->target_color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null target_color_space in ScheduleImageDecodeParams struct");
    fragment->needs_mips = Traits::needs_mips(input);
  }

  static bool Deserialize(::gpu::mojom::internal::ScheduleImageDecodeParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::ScheduleImageDecodeParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::DeferredRequestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::DeferredRequestDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::DeferredRequest_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::params(input)) in_params = Traits::params(input);
    mojo::internal::MessageFragment<decltype(fragment->params)>
        params_fragment(fragment.message());
    params_fragment.Claim(&fragment->params);
    mojo::internal::Serialize<::gpu::mojom::DeferredRequestParamsDataView>(
        in_params, params_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->params.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null params in DeferredRequest struct");
    decltype(Traits::sync_token_fences(input)) in_sync_token_fences = Traits::sync_token_fences(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->sync_token_fences)::BaseType>
        sync_token_fences_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams sync_token_fences_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>>(
        in_sync_token_fences, sync_token_fences_fragment, &sync_token_fences_validate_params);
    fragment->sync_token_fences.Set(
        sync_token_fences_fragment.is_null() ? nullptr : sync_token_fences_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->sync_token_fences.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null sync_token_fences in DeferredRequest struct");
  }

  static bool Deserialize(::gpu::mojom::internal::DeferredRequest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::DeferredRequestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::DeferredCommandBufferRequestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::DeferredCommandBufferRequestDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::DeferredCommandBufferRequest_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->routing_id = Traits::routing_id(input);
    decltype(Traits::params(input)) in_params = Traits::params(input);
    mojo::internal::MessageFragment<decltype(fragment->params)>
        params_fragment(fragment.message());
    params_fragment.Claim(&fragment->params);
    mojo::internal::Serialize<::gpu::mojom::DeferredCommandBufferRequestParamsDataView>(
        in_params, params_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->params.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null params in DeferredCommandBufferRequest struct");
  }

  static bool Deserialize(::gpu::mojom::internal::DeferredCommandBufferRequest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::DeferredCommandBufferRequestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::AsyncFlushParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::AsyncFlushParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::AsyncFlushParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->put_offset = Traits::put_offset(input);
    fragment->flush_id = Traits::flush_id(input);
    decltype(Traits::sync_token_fences(input)) in_sync_token_fences = Traits::sync_token_fences(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->sync_token_fences)::BaseType>
        sync_token_fences_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams sync_token_fences_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>>(
        in_sync_token_fences, sync_token_fences_fragment, &sync_token_fences_validate_params);
    fragment->sync_token_fences.Set(
        sync_token_fences_fragment.is_null() ? nullptr : sync_token_fences_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->sync_token_fences.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null sync_token_fences in AsyncFlushParams struct");
  }

  static bool Deserialize(::gpu::mojom::internal::AsyncFlushParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::AsyncFlushParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::ReturnFrontBufferParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::ReturnFrontBufferParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::ReturnFrontBufferParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::mailbox(input)) in_mailbox = Traits::mailbox(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox)::BaseType> mailbox_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
        in_mailbox, mailbox_fragment);
    fragment->mailbox.Set(
        mailbox_fragment.is_null() ? nullptr : mailbox_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox in ReturnFrontBufferParams struct");
    fragment->is_lost = Traits::is_lost(input);
  }

  static bool Deserialize(::gpu::mojom::internal::ReturnFrontBufferParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::ReturnFrontBufferParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::CreateSharedImageParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::CreateSharedImageParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::CreateSharedImageParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::mailbox(input)) in_mailbox = Traits::mailbox(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox)::BaseType> mailbox_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
        in_mailbox, mailbox_fragment);
    fragment->mailbox.Set(
        mailbox_fragment.is_null() ? nullptr : mailbox_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox in CreateSharedImageParams struct");
    mojo::internal::Serialize<::viz::mojom::ResourceFormat>(
        Traits::format(input), &fragment->format);
    decltype(Traits::size(input)) in_size = Traits::size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->size)::BaseType> size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_size, size_fragment);
    fragment->size.Set(
        size_fragment.is_null() ? nullptr : size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null size in CreateSharedImageParams struct");
    decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space)::BaseType> color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
        in_color_space, color_space_fragment);
    fragment->color_space.Set(
        color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space in CreateSharedImageParams struct");
    fragment->usage = Traits::usage(input);
    fragment->release_id = Traits::release_id(input);
    mojo::internal::Serialize<::skia::mojom::SurfaceOrigin>(
        Traits::surface_origin(input), &fragment->surface_origin);
    mojo::internal::Serialize<::skia::mojom::AlphaType>(
        Traits::alpha_type(input), &fragment->alpha_type);
  }

  static bool Deserialize(::gpu::mojom::internal::CreateSharedImageParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::CreateSharedImageParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::CreateSharedImageWithDataParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::CreateSharedImageWithDataParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::CreateSharedImageWithDataParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::mailbox(input)) in_mailbox = Traits::mailbox(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox)::BaseType> mailbox_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
        in_mailbox, mailbox_fragment);
    fragment->mailbox.Set(
        mailbox_fragment.is_null() ? nullptr : mailbox_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox in CreateSharedImageWithDataParams struct");
    mojo::internal::Serialize<::viz::mojom::ResourceFormat>(
        Traits::format(input), &fragment->format);
    decltype(Traits::size(input)) in_size = Traits::size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->size)::BaseType> size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_size, size_fragment);
    fragment->size.Set(
        size_fragment.is_null() ? nullptr : size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null size in CreateSharedImageWithDataParams struct");
    decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space)::BaseType> color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
        in_color_space, color_space_fragment);
    fragment->color_space.Set(
        color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space in CreateSharedImageWithDataParams struct");
    fragment->usage = Traits::usage(input);
    fragment->release_id = Traits::release_id(input);
    fragment->pixel_data_offset = Traits::pixel_data_offset(input);
    fragment->pixel_data_size = Traits::pixel_data_size(input);
    fragment->done_with_shm = Traits::done_with_shm(input);
    mojo::internal::Serialize<::skia::mojom::SurfaceOrigin>(
        Traits::surface_origin(input), &fragment->surface_origin);
    mojo::internal::Serialize<::skia::mojom::AlphaType>(
        Traits::alpha_type(input), &fragment->alpha_type);
  }

  static bool Deserialize(::gpu::mojom::internal::CreateSharedImageWithDataParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::CreateSharedImageWithDataParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::CreateGMBSharedImageParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::CreateGMBSharedImageParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::CreateGMBSharedImageParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::mailbox(input)) in_mailbox = Traits::mailbox(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox)::BaseType> mailbox_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
        in_mailbox, mailbox_fragment);
    fragment->mailbox.Set(
        mailbox_fragment.is_null() ? nullptr : mailbox_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox in CreateGMBSharedImageParams struct");
    decltype(Traits::buffer_handle(input)) in_buffer_handle = Traits::buffer_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->buffer_handle)::BaseType> buffer_handle_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::GpuMemoryBufferHandleDataView>(
        in_buffer_handle, buffer_handle_fragment);
    fragment->buffer_handle.Set(
        buffer_handle_fragment.is_null() ? nullptr : buffer_handle_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->buffer_handle.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null buffer_handle in CreateGMBSharedImageParams struct");
    decltype(Traits::size(input)) in_size = Traits::size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->size)::BaseType> size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_size, size_fragment);
    fragment->size.Set(
        size_fragment.is_null() ? nullptr : size_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->size.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null size in CreateGMBSharedImageParams struct");
    mojo::internal::Serialize<::gfx::mojom::BufferFormat>(
        Traits::format(input), &fragment->format);
    mojo::internal::Serialize<::gfx::mojom::BufferPlane>(
        Traits::plane(input), &fragment->plane);
    decltype(Traits::color_space(input)) in_color_space = Traits::color_space(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->color_space)::BaseType> color_space_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::ColorSpaceDataView>(
        in_color_space, color_space_fragment);
    fragment->color_space.Set(
        color_space_fragment.is_null() ? nullptr : color_space_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->color_space.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null color_space in CreateGMBSharedImageParams struct");
    fragment->usage = Traits::usage(input);
    fragment->release_id = Traits::release_id(input);
    mojo::internal::Serialize<::skia::mojom::SurfaceOrigin>(
        Traits::surface_origin(input), &fragment->surface_origin);
    mojo::internal::Serialize<::skia::mojom::AlphaType>(
        Traits::alpha_type(input), &fragment->alpha_type);
  }

  static bool Deserialize(::gpu::mojom::internal::CreateGMBSharedImageParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::CreateGMBSharedImageParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::UpdateSharedImageParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::gpu::mojom::UpdateSharedImageParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::gpu::mojom::internal::UpdateSharedImageParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::mailbox(input)) in_mailbox = Traits::mailbox(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mailbox)::BaseType> mailbox_fragment(
            fragment.message());
    mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
        in_mailbox, mailbox_fragment);
    fragment->mailbox.Set(
        mailbox_fragment.is_null() ? nullptr : mailbox_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mailbox.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mailbox in UpdateSharedImageParams struct");
    fragment->release_id = Traits::release_id(input);
    decltype(Traits::in_fence_handle(input)) in_in_fence_handle = Traits::in_fence_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->in_fence_handle)::BaseType> in_fence_handle_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::GpuFenceHandleDataView>(
        in_in_fence_handle, in_fence_handle_fragment);
    fragment->in_fence_handle.Set(
        in_fence_handle_fragment.is_null() ? nullptr : in_fence_handle_fragment.data());
  }

  static bool Deserialize(::gpu::mojom::internal::UpdateSharedImageParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::UpdateSharedImageParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::DeferredRequestParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::gpu::mojom::DeferredRequestParamsDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::gpu::mojom::internal::DeferredRequestParams_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::gpu::mojom::DeferredRequestParamsDataView::Tag::kCommandBufferRequest: {
        decltype(Traits::command_buffer_request(input))
            in_command_buffer_request = Traits::command_buffer_request(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_command_buffer_request)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::DeferredCommandBufferRequestDataView>(
            in_command_buffer_request, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null command_buffer_request in DeferredRequestParams union");
        fragment->data.f_command_buffer_request.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredRequestParamsDataView::Tag::kSharedImageRequest: {
        decltype(Traits::shared_image_request(input))
            in_shared_image_request = Traits::shared_image_request(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_shared_image_request)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::DeferredSharedImageRequestDataView>(
            in_shared_image_request, value_fragment, false);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null shared_image_request in DeferredRequestParams union");
        fragment->data.f_shared_image_request.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredRequestParamsDataView::Tag::kDestroyStreamTexture: {
        decltype(Traits::destroy_stream_texture(input))
            in_destroy_stream_texture = Traits::destroy_stream_texture(input);
        fragment->data.f_destroy_stream_texture = in_destroy_stream_texture;
        break;
      }
    }
  }

  static bool Deserialize(::gpu::mojom::internal::DeferredRequestParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::DeferredRequestParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::DeferredCommandBufferRequestParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::gpu::mojom::DeferredCommandBufferRequestParamsDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::gpu::mojom::internal::DeferredCommandBufferRequestParams_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::gpu::mojom::DeferredCommandBufferRequestParamsDataView::Tag::kAsyncFlush: {
        decltype(Traits::async_flush(input))
            in_async_flush = Traits::async_flush(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_async_flush)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::AsyncFlushParamsDataView>(
            in_async_flush, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null async_flush in DeferredCommandBufferRequestParams union");
        fragment->data.f_async_flush.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredCommandBufferRequestParamsDataView::Tag::kDestroyTransferBuffer: {
        decltype(Traits::destroy_transfer_buffer(input))
            in_destroy_transfer_buffer = Traits::destroy_transfer_buffer(input);
        fragment->data.f_destroy_transfer_buffer = in_destroy_transfer_buffer;
        break;
      }
      case ::gpu::mojom::DeferredCommandBufferRequestParamsDataView::Tag::kTakeFrontBuffer: {
        decltype(Traits::take_front_buffer(input))
            in_take_front_buffer = Traits::take_front_buffer(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_take_front_buffer)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
            in_take_front_buffer, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null take_front_buffer in DeferredCommandBufferRequestParams union");
        fragment->data.f_take_front_buffer.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredCommandBufferRequestParamsDataView::Tag::kReturnFrontBuffer: {
        decltype(Traits::return_front_buffer(input))
            in_return_front_buffer = Traits::return_front_buffer(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_return_front_buffer)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::ReturnFrontBufferParamsDataView>(
            in_return_front_buffer, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null return_front_buffer in DeferredCommandBufferRequestParams union");
        fragment->data.f_return_front_buffer.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::gpu::mojom::internal::DeferredCommandBufferRequestParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::DeferredCommandBufferRequestParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::gpu::mojom::DeferredSharedImageRequestDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::gpu::mojom::DeferredSharedImageRequestDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::gpu::mojom::internal::DeferredSharedImageRequest_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kNop: {
        decltype(Traits::nop(input))
            in_nop = Traits::nop(input);
        fragment->data.f_nop = in_nop;
        break;
      }
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kCreateSharedImage: {
        decltype(Traits::create_shared_image(input))
            in_create_shared_image = Traits::create_shared_image(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_create_shared_image)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::CreateSharedImageParamsDataView>(
            in_create_shared_image, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null create_shared_image in DeferredSharedImageRequest union");
        fragment->data.f_create_shared_image.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kCreateSharedImageWithData: {
        decltype(Traits::create_shared_image_with_data(input))
            in_create_shared_image_with_data = Traits::create_shared_image_with_data(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_create_shared_image_with_data)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::CreateSharedImageWithDataParamsDataView>(
            in_create_shared_image_with_data, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null create_shared_image_with_data in DeferredSharedImageRequest union");
        fragment->data.f_create_shared_image_with_data.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kCreateGmbSharedImage: {
        decltype(Traits::create_gmb_shared_image(input))
            in_create_gmb_shared_image = Traits::create_gmb_shared_image(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_create_gmb_shared_image)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::CreateGMBSharedImageParamsDataView>(
            in_create_gmb_shared_image, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null create_gmb_shared_image in DeferredSharedImageRequest union");
        fragment->data.f_create_gmb_shared_image.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kRegisterUploadBuffer: {
        decltype(Traits::register_upload_buffer(input))
            in_register_upload_buffer = Traits::register_upload_buffer(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_register_upload_buffer)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView>(
            in_register_upload_buffer, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null register_upload_buffer in DeferredSharedImageRequest union");
        fragment->data.f_register_upload_buffer.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kUpdateSharedImage: {
        decltype(Traits::update_shared_image(input))
            in_update_shared_image = Traits::update_shared_image(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_update_shared_image)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::UpdateSharedImageParamsDataView>(
            in_update_shared_image, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null update_shared_image in DeferredSharedImageRequest union");
        fragment->data.f_update_shared_image.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::gpu::mojom::DeferredSharedImageRequestDataView::Tag::kDestroySharedImage: {
        decltype(Traits::destroy_shared_image(input))
            in_destroy_shared_image = Traits::destroy_shared_image(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_destroy_shared_image)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::gpu::mojom::MailboxDataView>(
            in_destroy_shared_image, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null destroy_shared_image in DeferredSharedImageRequest union");
        fragment->data.f_destroy_shared_image.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::gpu::mojom::internal::DeferredSharedImageRequest_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::gpu::mojom::DeferredSharedImageRequestDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace gpu {
namespace mojom {

inline void ContextCreationAttribsDataView::GetOffscreenFramebufferSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->offscreen_framebuffer_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}


inline void CreateCommandBufferParamsDataView::GetSurfaceHandleDataView(
    ::gpu::mojom::SurfaceHandleDataView* output) {
  auto pointer = data_->surface_handle.Get();
  *output = ::gpu::mojom::SurfaceHandleDataView(pointer, message_);
}
inline void CreateCommandBufferParamsDataView::GetAttribsDataView(
    ContextCreationAttribsDataView* output) {
  auto pointer = data_->attribs.Get();
  *output = ContextCreationAttribsDataView(pointer, message_);
}
inline void CreateCommandBufferParamsDataView::GetActiveUrlDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->active_url.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}




inline void ScheduleImageDecodeParamsDataView::GetEncodedDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->encoded_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void ScheduleImageDecodeParamsDataView::GetOutputSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->output_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void ScheduleImageDecodeParamsDataView::GetTargetColorSpaceDataView(
    ::gfx::mojom::ColorSpaceDataView* output) {
  auto pointer = data_->target_color_space.Get();
  *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}


inline void DeferredRequestDataView::GetParamsDataView(
    DeferredRequestParamsDataView* output) {
  auto pointer = &data_->params;
  *output = DeferredRequestParamsDataView(pointer, message_);
}
inline void DeferredRequestDataView::GetSyncTokenFencesDataView(
    mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>* output) {
  auto pointer = data_->sync_token_fences.Get();
  *output = mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>(pointer, message_);
}


inline void DeferredCommandBufferRequestDataView::GetParamsDataView(
    DeferredCommandBufferRequestParamsDataView* output) {
  auto pointer = &data_->params;
  *output = DeferredCommandBufferRequestParamsDataView(pointer, message_);
}


inline void AsyncFlushParamsDataView::GetSyncTokenFencesDataView(
    mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>* output) {
  auto pointer = data_->sync_token_fences.Get();
  *output = mojo::ArrayDataView<::gpu::mojom::SyncTokenDataView>(pointer, message_);
}


inline void ReturnFrontBufferParamsDataView::GetMailboxDataView(
    ::gpu::mojom::MailboxDataView* output) {
  auto pointer = data_->mailbox.Get();
  *output = ::gpu::mojom::MailboxDataView(pointer, message_);
}


inline void CreateSharedImageParamsDataView::GetMailboxDataView(
    ::gpu::mojom::MailboxDataView* output) {
  auto pointer = data_->mailbox.Get();
  *output = ::gpu::mojom::MailboxDataView(pointer, message_);
}
inline void CreateSharedImageParamsDataView::GetSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void CreateSharedImageParamsDataView::GetColorSpaceDataView(
    ::gfx::mojom::ColorSpaceDataView* output) {
  auto pointer = data_->color_space.Get();
  *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}


inline void CreateSharedImageWithDataParamsDataView::GetMailboxDataView(
    ::gpu::mojom::MailboxDataView* output) {
  auto pointer = data_->mailbox.Get();
  *output = ::gpu::mojom::MailboxDataView(pointer, message_);
}
inline void CreateSharedImageWithDataParamsDataView::GetSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void CreateSharedImageWithDataParamsDataView::GetColorSpaceDataView(
    ::gfx::mojom::ColorSpaceDataView* output) {
  auto pointer = data_->color_space.Get();
  *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}


inline void CreateGMBSharedImageParamsDataView::GetMailboxDataView(
    ::gpu::mojom::MailboxDataView* output) {
  auto pointer = data_->mailbox.Get();
  *output = ::gpu::mojom::MailboxDataView(pointer, message_);
}
inline void CreateGMBSharedImageParamsDataView::GetBufferHandleDataView(
    ::gfx::mojom::GpuMemoryBufferHandleDataView* output) {
  auto pointer = data_->buffer_handle.Get();
  *output = ::gfx::mojom::GpuMemoryBufferHandleDataView(pointer, message_);
}
inline void CreateGMBSharedImageParamsDataView::GetSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void CreateGMBSharedImageParamsDataView::GetColorSpaceDataView(
    ::gfx::mojom::ColorSpaceDataView* output) {
  auto pointer = data_->color_space.Get();
  *output = ::gfx::mojom::ColorSpaceDataView(pointer, message_);
}


inline void UpdateSharedImageParamsDataView::GetMailboxDataView(
    ::gpu::mojom::MailboxDataView* output) {
  auto pointer = data_->mailbox.Get();
  *output = ::gpu::mojom::MailboxDataView(pointer, message_);
}
inline void UpdateSharedImageParamsDataView::GetInFenceHandleDataView(
    ::gfx::mojom::GpuFenceHandleDataView* output) {
  auto pointer = data_->in_fence_handle.Get();
  *output = ::gfx::mojom::GpuFenceHandleDataView(pointer, message_);
}


inline void DeferredRequestParamsDataView::GetCommandBufferRequestDataView(
    DeferredCommandBufferRequestDataView* output) const {
  CHECK(is_command_buffer_request());
  *output = DeferredCommandBufferRequestDataView(data_->data.f_command_buffer_request.Get(), message_);
}
inline void DeferredRequestParamsDataView::GetSharedImageRequestDataView(
    DeferredSharedImageRequestDataView* output) const {
  CHECK(is_shared_image_request());
  *output = DeferredSharedImageRequestDataView(data_->data.f_shared_image_request.Get(), message_);
}

inline void DeferredCommandBufferRequestParamsDataView::GetAsyncFlushDataView(
    AsyncFlushParamsDataView* output) const {
  CHECK(is_async_flush());
  *output = AsyncFlushParamsDataView(data_->data.f_async_flush.Get(), message_);
}
inline void DeferredCommandBufferRequestParamsDataView::GetTakeFrontBufferDataView(
    ::gpu::mojom::MailboxDataView* output) const {
  CHECK(is_take_front_buffer());
  *output = ::gpu::mojom::MailboxDataView(data_->data.f_take_front_buffer.Get(), message_);
}
inline void DeferredCommandBufferRequestParamsDataView::GetReturnFrontBufferDataView(
    ReturnFrontBufferParamsDataView* output) const {
  CHECK(is_return_front_buffer());
  *output = ReturnFrontBufferParamsDataView(data_->data.f_return_front_buffer.Get(), message_);
}

inline void DeferredSharedImageRequestDataView::GetCreateSharedImageDataView(
    CreateSharedImageParamsDataView* output) const {
  CHECK(is_create_shared_image());
  *output = CreateSharedImageParamsDataView(data_->data.f_create_shared_image.Get(), message_);
}
inline void DeferredSharedImageRequestDataView::GetCreateSharedImageWithDataDataView(
    CreateSharedImageWithDataParamsDataView* output) const {
  CHECK(is_create_shared_image_with_data());
  *output = CreateSharedImageWithDataParamsDataView(data_->data.f_create_shared_image_with_data.Get(), message_);
}
inline void DeferredSharedImageRequestDataView::GetCreateGmbSharedImageDataView(
    CreateGMBSharedImageParamsDataView* output) const {
  CHECK(is_create_gmb_shared_image());
  *output = CreateGMBSharedImageParamsDataView(data_->data.f_create_gmb_shared_image.Get(), message_);
}
inline void DeferredSharedImageRequestDataView::GetRegisterUploadBufferDataView(
    ::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView* output) const {
  CHECK(is_register_upload_buffer());
  *output = ::mojo_base::mojom::ReadOnlySharedMemoryRegionDataView(data_->data.f_register_upload_buffer.Get(), message_);
}
inline void DeferredSharedImageRequestDataView::GetUpdateSharedImageDataView(
    UpdateSharedImageParamsDataView* output) const {
  CHECK(is_update_shared_image());
  *output = UpdateSharedImageParamsDataView(data_->data.f_update_shared_image.Get(), message_);
}
inline void DeferredSharedImageRequestDataView::GetDestroySharedImageDataView(
    ::gpu::mojom::MailboxDataView* output) const {
  CHECK(is_destroy_shared_image());
  *output = ::gpu::mojom::MailboxDataView(data_->data.f_destroy_shared_image.Get(), message_);
}


}  // namespace mojom
}  // namespace gpu

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) TraceFormatTraits<::gpu::mojom::ContextType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::gpu::mojom::ContextType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) TraceFormatTraits<::gpu::mojom::ContextColorSpace> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::gpu::mojom::ContextColorSpace value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_GPU_EXPORT) TraceFormatTraits<::gpu::mojom::SchedulingPriority> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::gpu::mojom::SchedulingPriority value);
};

} // namespace perfetto

#endif  // GPU_IPC_COMMON_GPU_CHANNEL_MOJOM_SHARED_H_