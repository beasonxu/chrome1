// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/lite/experimental/acceleration/configuration/configuration.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto {
  static const uint32_t offsets[];
};
namespace tflite {
namespace proto {
class BenchmarkError;
struct BenchmarkErrorDefaultTypeInternal;
extern BenchmarkErrorDefaultTypeInternal _BenchmarkError_default_instance_;
class BenchmarkEvent;
struct BenchmarkEventDefaultTypeInternal;
extern BenchmarkEventDefaultTypeInternal _BenchmarkEvent_default_instance_;
class BenchmarkInitializationFailure;
struct BenchmarkInitializationFailureDefaultTypeInternal;
extern BenchmarkInitializationFailureDefaultTypeInternal _BenchmarkInitializationFailure_default_instance_;
class BenchmarkMetric;
struct BenchmarkMetricDefaultTypeInternal;
extern BenchmarkMetricDefaultTypeInternal _BenchmarkMetric_default_instance_;
class BenchmarkResult;
struct BenchmarkResultDefaultTypeInternal;
extern BenchmarkResultDefaultTypeInternal _BenchmarkResult_default_instance_;
class BenchmarkStoragePaths;
struct BenchmarkStoragePathsDefaultTypeInternal;
extern BenchmarkStoragePathsDefaultTypeInternal _BenchmarkStoragePaths_default_instance_;
class BestAccelerationDecision;
struct BestAccelerationDecisionDefaultTypeInternal;
extern BestAccelerationDecisionDefaultTypeInternal _BestAccelerationDecision_default_instance_;
class CPUSettings;
struct CPUSettingsDefaultTypeInternal;
extern CPUSettingsDefaultTypeInternal _CPUSettings_default_instance_;
class ComputeSettings;
struct ComputeSettingsDefaultTypeInternal;
extern ComputeSettingsDefaultTypeInternal _ComputeSettings_default_instance_;
class CoralSettings;
struct CoralSettingsDefaultTypeInternal;
extern CoralSettingsDefaultTypeInternal _CoralSettings_default_instance_;
class CoreMLSettings;
struct CoreMLSettingsDefaultTypeInternal;
extern CoreMLSettingsDefaultTypeInternal _CoreMLSettings_default_instance_;
class EdgeTpuDeviceSpec;
struct EdgeTpuDeviceSpecDefaultTypeInternal;
extern EdgeTpuDeviceSpecDefaultTypeInternal _EdgeTpuDeviceSpec_default_instance_;
class EdgeTpuInactivePowerConfig;
struct EdgeTpuInactivePowerConfigDefaultTypeInternal;
extern EdgeTpuInactivePowerConfigDefaultTypeInternal _EdgeTpuInactivePowerConfig_default_instance_;
class EdgeTpuSettings;
struct EdgeTpuSettingsDefaultTypeInternal;
extern EdgeTpuSettingsDefaultTypeInternal _EdgeTpuSettings_default_instance_;
class ErrorCode;
struct ErrorCodeDefaultTypeInternal;
extern ErrorCodeDefaultTypeInternal _ErrorCode_default_instance_;
class FallbackSettings;
struct FallbackSettingsDefaultTypeInternal;
extern FallbackSettingsDefaultTypeInternal _FallbackSettings_default_instance_;
class GPUSettings;
struct GPUSettingsDefaultTypeInternal;
extern GPUSettingsDefaultTypeInternal _GPUSettings_default_instance_;
class HexagonSettings;
struct HexagonSettingsDefaultTypeInternal;
extern HexagonSettingsDefaultTypeInternal _HexagonSettings_default_instance_;
class MiniBenchmarkEvent;
struct MiniBenchmarkEventDefaultTypeInternal;
extern MiniBenchmarkEventDefaultTypeInternal _MiniBenchmarkEvent_default_instance_;
class MinibenchmarkSettings;
struct MinibenchmarkSettingsDefaultTypeInternal;
extern MinibenchmarkSettingsDefaultTypeInternal _MinibenchmarkSettings_default_instance_;
class ModelFile;
struct ModelFileDefaultTypeInternal;
extern ModelFileDefaultTypeInternal _ModelFile_default_instance_;
class NNAPISettings;
struct NNAPISettingsDefaultTypeInternal;
extern NNAPISettingsDefaultTypeInternal _NNAPISettings_default_instance_;
class TFLiteSettings;
struct TFLiteSettingsDefaultTypeInternal;
extern TFLiteSettingsDefaultTypeInternal _TFLiteSettings_default_instance_;
class XNNPackSettings;
struct XNNPackSettingsDefaultTypeInternal;
extern XNNPackSettingsDefaultTypeInternal _XNNPackSettings_default_instance_;
}  // namespace proto
}  // namespace tflite
PROTOBUF_NAMESPACE_OPEN
template<> ::tflite::proto::BenchmarkError* Arena::CreateMaybeMessage<::tflite::proto::BenchmarkError>(Arena*);
template<> ::tflite::proto::BenchmarkEvent* Arena::CreateMaybeMessage<::tflite::proto::BenchmarkEvent>(Arena*);
template<> ::tflite::proto::BenchmarkInitializationFailure* Arena::CreateMaybeMessage<::tflite::proto::BenchmarkInitializationFailure>(Arena*);
template<> ::tflite::proto::BenchmarkMetric* Arena::CreateMaybeMessage<::tflite::proto::BenchmarkMetric>(Arena*);
template<> ::tflite::proto::BenchmarkResult* Arena::CreateMaybeMessage<::tflite::proto::BenchmarkResult>(Arena*);
template<> ::tflite::proto::BenchmarkStoragePaths* Arena::CreateMaybeMessage<::tflite::proto::BenchmarkStoragePaths>(Arena*);
template<> ::tflite::proto::BestAccelerationDecision* Arena::CreateMaybeMessage<::tflite::proto::BestAccelerationDecision>(Arena*);
template<> ::tflite::proto::CPUSettings* Arena::CreateMaybeMessage<::tflite::proto::CPUSettings>(Arena*);
template<> ::tflite::proto::ComputeSettings* Arena::CreateMaybeMessage<::tflite::proto::ComputeSettings>(Arena*);
template<> ::tflite::proto::CoralSettings* Arena::CreateMaybeMessage<::tflite::proto::CoralSettings>(Arena*);
template<> ::tflite::proto::CoreMLSettings* Arena::CreateMaybeMessage<::tflite::proto::CoreMLSettings>(Arena*);
template<> ::tflite::proto::EdgeTpuDeviceSpec* Arena::CreateMaybeMessage<::tflite::proto::EdgeTpuDeviceSpec>(Arena*);
template<> ::tflite::proto::EdgeTpuInactivePowerConfig* Arena::CreateMaybeMessage<::tflite::proto::EdgeTpuInactivePowerConfig>(Arena*);
template<> ::tflite::proto::EdgeTpuSettings* Arena::CreateMaybeMessage<::tflite::proto::EdgeTpuSettings>(Arena*);
template<> ::tflite::proto::ErrorCode* Arena::CreateMaybeMessage<::tflite::proto::ErrorCode>(Arena*);
template<> ::tflite::proto::FallbackSettings* Arena::CreateMaybeMessage<::tflite::proto::FallbackSettings>(Arena*);
template<> ::tflite::proto::GPUSettings* Arena::CreateMaybeMessage<::tflite::proto::GPUSettings>(Arena*);
template<> ::tflite::proto::HexagonSettings* Arena::CreateMaybeMessage<::tflite::proto::HexagonSettings>(Arena*);
template<> ::tflite::proto::MiniBenchmarkEvent* Arena::CreateMaybeMessage<::tflite::proto::MiniBenchmarkEvent>(Arena*);
template<> ::tflite::proto::MinibenchmarkSettings* Arena::CreateMaybeMessage<::tflite::proto::MinibenchmarkSettings>(Arena*);
template<> ::tflite::proto::ModelFile* Arena::CreateMaybeMessage<::tflite::proto::ModelFile>(Arena*);
template<> ::tflite::proto::NNAPISettings* Arena::CreateMaybeMessage<::tflite::proto::NNAPISettings>(Arena*);
template<> ::tflite::proto::TFLiteSettings* Arena::CreateMaybeMessage<::tflite::proto::TFLiteSettings>(Arena*);
template<> ::tflite::proto::XNNPackSettings* Arena::CreateMaybeMessage<::tflite::proto::XNNPackSettings>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace tflite {
namespace proto {

enum CoreMLSettings_EnabledDevices : int {
  CoreMLSettings_EnabledDevices_DEVICES_ALL = 0,
  CoreMLSettings_EnabledDevices_DEVICES_WITH_NEURAL_ENGINE = 1
};
bool CoreMLSettings_EnabledDevices_IsValid(int value);
constexpr CoreMLSettings_EnabledDevices CoreMLSettings_EnabledDevices_EnabledDevices_MIN = CoreMLSettings_EnabledDevices_DEVICES_ALL;
constexpr CoreMLSettings_EnabledDevices CoreMLSettings_EnabledDevices_EnabledDevices_MAX = CoreMLSettings_EnabledDevices_DEVICES_WITH_NEURAL_ENGINE;
constexpr int CoreMLSettings_EnabledDevices_EnabledDevices_ARRAYSIZE = CoreMLSettings_EnabledDevices_EnabledDevices_MAX + 1;

const std::string& CoreMLSettings_EnabledDevices_Name(CoreMLSettings_EnabledDevices value);
template<typename T>
inline const std::string& CoreMLSettings_EnabledDevices_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CoreMLSettings_EnabledDevices>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CoreMLSettings_EnabledDevices_Name.");
  return CoreMLSettings_EnabledDevices_Name(static_cast<CoreMLSettings_EnabledDevices>(enum_t_value));
}
bool CoreMLSettings_EnabledDevices_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CoreMLSettings_EnabledDevices* value);
enum EdgeTpuDeviceSpec_PlatformType : int {
  EdgeTpuDeviceSpec_PlatformType_MMIO = 0,
  EdgeTpuDeviceSpec_PlatformType_REFERENCE = 1,
  EdgeTpuDeviceSpec_PlatformType_SIMULATOR = 2,
  EdgeTpuDeviceSpec_PlatformType_REMOTE_SIMULATOR = 3
};
bool EdgeTpuDeviceSpec_PlatformType_IsValid(int value);
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec_PlatformType_PlatformType_MIN = EdgeTpuDeviceSpec_PlatformType_MMIO;
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec_PlatformType_PlatformType_MAX = EdgeTpuDeviceSpec_PlatformType_REMOTE_SIMULATOR;
constexpr int EdgeTpuDeviceSpec_PlatformType_PlatformType_ARRAYSIZE = EdgeTpuDeviceSpec_PlatformType_PlatformType_MAX + 1;

const std::string& EdgeTpuDeviceSpec_PlatformType_Name(EdgeTpuDeviceSpec_PlatformType value);
template<typename T>
inline const std::string& EdgeTpuDeviceSpec_PlatformType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EdgeTpuDeviceSpec_PlatformType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EdgeTpuDeviceSpec_PlatformType_Name.");
  return EdgeTpuDeviceSpec_PlatformType_Name(static_cast<EdgeTpuDeviceSpec_PlatformType>(enum_t_value));
}
bool EdgeTpuDeviceSpec_PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuDeviceSpec_PlatformType* value);
enum EdgeTpuSettings_FloatTruncationType : int {
  EdgeTpuSettings_FloatTruncationType_UNSPECIFIED = 0,
  EdgeTpuSettings_FloatTruncationType_NO_TRUNCATION = 1,
  EdgeTpuSettings_FloatTruncationType_BFLOAT16 = 2,
  EdgeTpuSettings_FloatTruncationType_HALF = 3
};
bool EdgeTpuSettings_FloatTruncationType_IsValid(int value);
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings_FloatTruncationType_FloatTruncationType_MIN = EdgeTpuSettings_FloatTruncationType_UNSPECIFIED;
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings_FloatTruncationType_FloatTruncationType_MAX = EdgeTpuSettings_FloatTruncationType_HALF;
constexpr int EdgeTpuSettings_FloatTruncationType_FloatTruncationType_ARRAYSIZE = EdgeTpuSettings_FloatTruncationType_FloatTruncationType_MAX + 1;

const std::string& EdgeTpuSettings_FloatTruncationType_Name(EdgeTpuSettings_FloatTruncationType value);
template<typename T>
inline const std::string& EdgeTpuSettings_FloatTruncationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EdgeTpuSettings_FloatTruncationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EdgeTpuSettings_FloatTruncationType_Name.");
  return EdgeTpuSettings_FloatTruncationType_Name(static_cast<EdgeTpuSettings_FloatTruncationType>(enum_t_value));
}
bool EdgeTpuSettings_FloatTruncationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuSettings_FloatTruncationType* value);
enum EdgeTpuSettings_QosClass : int {
  EdgeTpuSettings_QosClass_QOS_UNDEFINED = 0,
  EdgeTpuSettings_QosClass_BEST_EFFORT = 1,
  EdgeTpuSettings_QosClass_REALTIME = 2
};
bool EdgeTpuSettings_QosClass_IsValid(int value);
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings_QosClass_QosClass_MIN = EdgeTpuSettings_QosClass_QOS_UNDEFINED;
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings_QosClass_QosClass_MAX = EdgeTpuSettings_QosClass_REALTIME;
constexpr int EdgeTpuSettings_QosClass_QosClass_ARRAYSIZE = EdgeTpuSettings_QosClass_QosClass_MAX + 1;

const std::string& EdgeTpuSettings_QosClass_Name(EdgeTpuSettings_QosClass value);
template<typename T>
inline const std::string& EdgeTpuSettings_QosClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EdgeTpuSettings_QosClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EdgeTpuSettings_QosClass_Name.");
  return EdgeTpuSettings_QosClass_Name(static_cast<EdgeTpuSettings_QosClass>(enum_t_value));
}
bool EdgeTpuSettings_QosClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuSettings_QosClass* value);
enum CoralSettings_Performance : int {
  CoralSettings_Performance_UNDEFINED = 0,
  CoralSettings_Performance_MAXIMUM = 1,
  CoralSettings_Performance_HIGH = 2,
  CoralSettings_Performance_MEDIUM = 3,
  CoralSettings_Performance_LOW = 4
};
bool CoralSettings_Performance_IsValid(int value);
constexpr CoralSettings_Performance CoralSettings_Performance_Performance_MIN = CoralSettings_Performance_UNDEFINED;
constexpr CoralSettings_Performance CoralSettings_Performance_Performance_MAX = CoralSettings_Performance_LOW;
constexpr int CoralSettings_Performance_Performance_ARRAYSIZE = CoralSettings_Performance_Performance_MAX + 1;

const std::string& CoralSettings_Performance_Name(CoralSettings_Performance value);
template<typename T>
inline const std::string& CoralSettings_Performance_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CoralSettings_Performance>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CoralSettings_Performance_Name.");
  return CoralSettings_Performance_Name(static_cast<CoralSettings_Performance>(enum_t_value));
}
bool CoralSettings_Performance_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CoralSettings_Performance* value);
enum ExecutionPreference : int {
  ANY = 0,
  LOW_LATENCY = 1,
  LOW_POWER = 2,
  FORCE_CPU = 3
};
bool ExecutionPreference_IsValid(int value);
constexpr ExecutionPreference ExecutionPreference_MIN = ANY;
constexpr ExecutionPreference ExecutionPreference_MAX = FORCE_CPU;
constexpr int ExecutionPreference_ARRAYSIZE = ExecutionPreference_MAX + 1;

const std::string& ExecutionPreference_Name(ExecutionPreference value);
template<typename T>
inline const std::string& ExecutionPreference_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ExecutionPreference>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ExecutionPreference_Name.");
  return ExecutionPreference_Name(static_cast<ExecutionPreference>(enum_t_value));
}
bool ExecutionPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutionPreference* value);
enum Delegate : int {
  NONE = 0,
  NNAPI = 1,
  GPU = 2,
  HEXAGON = 3,
  XNNPACK = 4,
  EDGETPU = 5,
  EDGETPU_CORAL = 6,
  CORE_ML = 7
};
bool Delegate_IsValid(int value);
constexpr Delegate Delegate_MIN = NONE;
constexpr Delegate Delegate_MAX = CORE_ML;
constexpr int Delegate_ARRAYSIZE = Delegate_MAX + 1;

const std::string& Delegate_Name(Delegate value);
template<typename T>
inline const std::string& Delegate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Delegate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Delegate_Name.");
  return Delegate_Name(static_cast<Delegate>(enum_t_value));
}
bool Delegate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Delegate* value);
enum NNAPIExecutionPreference : int {
  UNDEFINED = 0,
  NNAPI_LOW_POWER = 1,
  NNAPI_FAST_SINGLE_ANSWER = 2,
  NNAPI_SUSTAINED_SPEED = 3
};
bool NNAPIExecutionPreference_IsValid(int value);
constexpr NNAPIExecutionPreference NNAPIExecutionPreference_MIN = UNDEFINED;
constexpr NNAPIExecutionPreference NNAPIExecutionPreference_MAX = NNAPI_SUSTAINED_SPEED;
constexpr int NNAPIExecutionPreference_ARRAYSIZE = NNAPIExecutionPreference_MAX + 1;

const std::string& NNAPIExecutionPreference_Name(NNAPIExecutionPreference value);
template<typename T>
inline const std::string& NNAPIExecutionPreference_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NNAPIExecutionPreference>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NNAPIExecutionPreference_Name.");
  return NNAPIExecutionPreference_Name(static_cast<NNAPIExecutionPreference>(enum_t_value));
}
bool NNAPIExecutionPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NNAPIExecutionPreference* value);
enum NNAPIExecutionPriority : int {
  NNAPI_PRIORITY_UNDEFINED = 0,
  NNAPI_PRIORITY_LOW = 1,
  NNAPI_PRIORITY_MEDIUM = 2,
  NNAPI_PRIORITY_HIGH = 3
};
bool NNAPIExecutionPriority_IsValid(int value);
constexpr NNAPIExecutionPriority NNAPIExecutionPriority_MIN = NNAPI_PRIORITY_UNDEFINED;
constexpr NNAPIExecutionPriority NNAPIExecutionPriority_MAX = NNAPI_PRIORITY_HIGH;
constexpr int NNAPIExecutionPriority_ARRAYSIZE = NNAPIExecutionPriority_MAX + 1;

const std::string& NNAPIExecutionPriority_Name(NNAPIExecutionPriority value);
template<typename T>
inline const std::string& NNAPIExecutionPriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NNAPIExecutionPriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NNAPIExecutionPriority_Name.");
  return NNAPIExecutionPriority_Name(static_cast<NNAPIExecutionPriority>(enum_t_value));
}
bool NNAPIExecutionPriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NNAPIExecutionPriority* value);
enum GPUBackend : int {
  UNSET = 0,
  OPENCL = 1,
  OPENGL = 2
};
bool GPUBackend_IsValid(int value);
constexpr GPUBackend GPUBackend_MIN = UNSET;
constexpr GPUBackend GPUBackend_MAX = OPENGL;
constexpr int GPUBackend_ARRAYSIZE = GPUBackend_MAX + 1;

const std::string& GPUBackend_Name(GPUBackend value);
template<typename T>
inline const std::string& GPUBackend_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GPUBackend>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GPUBackend_Name.");
  return GPUBackend_Name(static_cast<GPUBackend>(enum_t_value));
}
bool GPUBackend_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPUBackend* value);
enum GPUInferencePriority : int {
  GPU_PRIORITY_AUTO = 0,
  GPU_PRIORITY_MAX_PRECISION = 1,
  GPU_PRIORITY_MIN_LATENCY = 2,
  GPU_PRIORITY_MIN_MEMORY_USAGE = 3
};
bool GPUInferencePriority_IsValid(int value);
constexpr GPUInferencePriority GPUInferencePriority_MIN = GPU_PRIORITY_AUTO;
constexpr GPUInferencePriority GPUInferencePriority_MAX = GPU_PRIORITY_MIN_MEMORY_USAGE;
constexpr int GPUInferencePriority_ARRAYSIZE = GPUInferencePriority_MAX + 1;

const std::string& GPUInferencePriority_Name(GPUInferencePriority value);
template<typename T>
inline const std::string& GPUInferencePriority_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GPUInferencePriority>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GPUInferencePriority_Name.");
  return GPUInferencePriority_Name(static_cast<GPUInferencePriority>(enum_t_value));
}
bool GPUInferencePriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPUInferencePriority* value);
enum GPUInferenceUsage : int {
  GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER = 0,
  GPU_INFERENCE_PREFERENCE_SUSTAINED_SPEED = 1
};
bool GPUInferenceUsage_IsValid(int value);
constexpr GPUInferenceUsage GPUInferenceUsage_MIN = GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER;
constexpr GPUInferenceUsage GPUInferenceUsage_MAX = GPU_INFERENCE_PREFERENCE_SUSTAINED_SPEED;
constexpr int GPUInferenceUsage_ARRAYSIZE = GPUInferenceUsage_MAX + 1;

const std::string& GPUInferenceUsage_Name(GPUInferenceUsage value);
template<typename T>
inline const std::string& GPUInferenceUsage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GPUInferenceUsage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GPUInferenceUsage_Name.");
  return GPUInferenceUsage_Name(static_cast<GPUInferenceUsage>(enum_t_value));
}
bool GPUInferenceUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPUInferenceUsage* value);
enum XNNPackFlags : int {
  TFLITE_XNNPACK_DELEGATE_NO_FLAGS = 0,
  TFLITE_XNNPACK_DELEGATE_FLAG_QS8 = 1,
  TFLITE_XNNPACK_DELEGATE_FLAG_QU8 = 2,
  TFLITE_XNNPACK_DELEGATE_FLAG_QS8_QU8 = 3,
  TFLITE_XNNPACK_DELEGATE_FLAG_FORCE_FP16 = 4
};
bool XNNPackFlags_IsValid(int value);
constexpr XNNPackFlags XNNPackFlags_MIN = TFLITE_XNNPACK_DELEGATE_NO_FLAGS;
constexpr XNNPackFlags XNNPackFlags_MAX = TFLITE_XNNPACK_DELEGATE_FLAG_FORCE_FP16;
constexpr int XNNPackFlags_ARRAYSIZE = XNNPackFlags_MAX + 1;

const std::string& XNNPackFlags_Name(XNNPackFlags value);
template<typename T>
inline const std::string& XNNPackFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, XNNPackFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function XNNPackFlags_Name.");
  return XNNPackFlags_Name(static_cast<XNNPackFlags>(enum_t_value));
}
bool XNNPackFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, XNNPackFlags* value);
enum EdgeTpuPowerState : int {
  UNDEFINED_POWERSTATE = 0,
  TPU_CORE_OFF = 1,
  READY = 2,
  ACTIVE_MIN_POWER = 3,
  ACTIVE_VERY_LOW_POWER = 4,
  ACTIVE_LOW_POWER = 5,
  ACTIVE = 6,
  OVER_DRIVE = 7
};
bool EdgeTpuPowerState_IsValid(int value);
constexpr EdgeTpuPowerState EdgeTpuPowerState_MIN = UNDEFINED_POWERSTATE;
constexpr EdgeTpuPowerState EdgeTpuPowerState_MAX = OVER_DRIVE;
constexpr int EdgeTpuPowerState_ARRAYSIZE = EdgeTpuPowerState_MAX + 1;

const std::string& EdgeTpuPowerState_Name(EdgeTpuPowerState value);
template<typename T>
inline const std::string& EdgeTpuPowerState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EdgeTpuPowerState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EdgeTpuPowerState_Name.");
  return EdgeTpuPowerState_Name(static_cast<EdgeTpuPowerState>(enum_t_value));
}
bool EdgeTpuPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuPowerState* value);
enum BenchmarkEventType : int {
  UNDEFINED_BENCHMARK_EVENT_TYPE = 0,
  START = 1,
  END = 2,
  ERROR = 3,
  LOGGED = 4,
  RECOVERED_ERROR = 5
};
bool BenchmarkEventType_IsValid(int value);
constexpr BenchmarkEventType BenchmarkEventType_MIN = UNDEFINED_BENCHMARK_EVENT_TYPE;
constexpr BenchmarkEventType BenchmarkEventType_MAX = RECOVERED_ERROR;
constexpr int BenchmarkEventType_ARRAYSIZE = BenchmarkEventType_MAX + 1;

const std::string& BenchmarkEventType_Name(BenchmarkEventType value);
template<typename T>
inline const std::string& BenchmarkEventType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BenchmarkEventType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BenchmarkEventType_Name.");
  return BenchmarkEventType_Name(static_cast<BenchmarkEventType>(enum_t_value));
}
bool BenchmarkEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BenchmarkEventType* value);
enum BenchmarkStage : int {
  UNKNOWN = 0,
  INITIALIZATION = 1,
  INFERENCE = 2
};
bool BenchmarkStage_IsValid(int value);
constexpr BenchmarkStage BenchmarkStage_MIN = UNKNOWN;
constexpr BenchmarkStage BenchmarkStage_MAX = INFERENCE;
constexpr int BenchmarkStage_ARRAYSIZE = BenchmarkStage_MAX + 1;

const std::string& BenchmarkStage_Name(BenchmarkStage value);
template<typename T>
inline const std::string& BenchmarkStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BenchmarkStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BenchmarkStage_Name.");
  return BenchmarkStage_Name(static_cast<BenchmarkStage>(enum_t_value));
}
bool BenchmarkStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BenchmarkStage* value);
// ===================================================================

class ComputeSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.ComputeSettings) */ {
 public:
  inline ComputeSettings() : ComputeSettings(nullptr) {}
  ~ComputeSettings() override;
  explicit PROTOBUF_CONSTEXPR ComputeSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputeSettings(const ComputeSettings& from);
  ComputeSettings(ComputeSettings&& from) noexcept
    : ComputeSettings() {
    *this = ::std::move(from);
  }

  inline ComputeSettings& operator=(const ComputeSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputeSettings& operator=(ComputeSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ComputeSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputeSettings* internal_default_instance() {
    return reinterpret_cast<const ComputeSettings*>(
               &_ComputeSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ComputeSettings& a, ComputeSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ComputeSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputeSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputeSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputeSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ComputeSettings& from);
  void MergeFrom(const ComputeSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ComputeSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.ComputeSettings";
  }
  protected:
  explicit ComputeSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelNamespaceForStatisticsFieldNumber = 3,
    kModelIdentifierForStatisticsFieldNumber = 4,
    kTfliteSettingsFieldNumber = 2,
    kSettingsToTestLocallyFieldNumber = 5,
    kPreferenceFieldNumber = 1,
  };
  // optional string model_namespace_for_statistics = 3;
  bool has_model_namespace_for_statistics() const;
  private:
  bool _internal_has_model_namespace_for_statistics() const;
  public:
  void clear_model_namespace_for_statistics();
  const std::string& model_namespace_for_statistics() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_namespace_for_statistics(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_namespace_for_statistics();
  PROTOBUF_NODISCARD std::string* release_model_namespace_for_statistics();
  void set_allocated_model_namespace_for_statistics(std::string* model_namespace_for_statistics);
  private:
  const std::string& _internal_model_namespace_for_statistics() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_namespace_for_statistics(const std::string& value);
  std::string* _internal_mutable_model_namespace_for_statistics();
  public:

  // optional string model_identifier_for_statistics = 4;
  bool has_model_identifier_for_statistics() const;
  private:
  bool _internal_has_model_identifier_for_statistics() const;
  public:
  void clear_model_identifier_for_statistics();
  const std::string& model_identifier_for_statistics() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_identifier_for_statistics(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_identifier_for_statistics();
  PROTOBUF_NODISCARD std::string* release_model_identifier_for_statistics();
  void set_allocated_model_identifier_for_statistics(std::string* model_identifier_for_statistics);
  private:
  const std::string& _internal_model_identifier_for_statistics() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_identifier_for_statistics(const std::string& value);
  std::string* _internal_mutable_model_identifier_for_statistics();
  public:

  // optional .tflite.proto.TFLiteSettings tflite_settings = 2;
  bool has_tflite_settings() const;
  private:
  bool _internal_has_tflite_settings() const;
  public:
  void clear_tflite_settings();
  const ::tflite::proto::TFLiteSettings& tflite_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::TFLiteSettings* release_tflite_settings();
  ::tflite::proto::TFLiteSettings* mutable_tflite_settings();
  void set_allocated_tflite_settings(::tflite::proto::TFLiteSettings* tflite_settings);
  private:
  const ::tflite::proto::TFLiteSettings& _internal_tflite_settings() const;
  ::tflite::proto::TFLiteSettings* _internal_mutable_tflite_settings();
  public:
  void unsafe_arena_set_allocated_tflite_settings(
      ::tflite::proto::TFLiteSettings* tflite_settings);
  ::tflite::proto::TFLiteSettings* unsafe_arena_release_tflite_settings();

  // optional .tflite.proto.MinibenchmarkSettings settings_to_test_locally = 5;
  bool has_settings_to_test_locally() const;
  private:
  bool _internal_has_settings_to_test_locally() const;
  public:
  void clear_settings_to_test_locally();
  const ::tflite::proto::MinibenchmarkSettings& settings_to_test_locally() const;
  PROTOBUF_NODISCARD ::tflite::proto::MinibenchmarkSettings* release_settings_to_test_locally();
  ::tflite::proto::MinibenchmarkSettings* mutable_settings_to_test_locally();
  void set_allocated_settings_to_test_locally(::tflite::proto::MinibenchmarkSettings* settings_to_test_locally);
  private:
  const ::tflite::proto::MinibenchmarkSettings& _internal_settings_to_test_locally() const;
  ::tflite::proto::MinibenchmarkSettings* _internal_mutable_settings_to_test_locally();
  public:
  void unsafe_arena_set_allocated_settings_to_test_locally(
      ::tflite::proto::MinibenchmarkSettings* settings_to_test_locally);
  ::tflite::proto::MinibenchmarkSettings* unsafe_arena_release_settings_to_test_locally();

  // optional .tflite.proto.ExecutionPreference preference = 1;
  bool has_preference() const;
  private:
  bool _internal_has_preference() const;
  public:
  void clear_preference();
  ::tflite::proto::ExecutionPreference preference() const;
  void set_preference(::tflite::proto::ExecutionPreference value);
  private:
  ::tflite::proto::ExecutionPreference _internal_preference() const;
  void _internal_set_preference(::tflite::proto::ExecutionPreference value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.ComputeSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_namespace_for_statistics_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_identifier_for_statistics_;
  ::tflite::proto::TFLiteSettings* tflite_settings_;
  ::tflite::proto::MinibenchmarkSettings* settings_to_test_locally_;
  int preference_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class NNAPISettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.NNAPISettings) */ {
 public:
  inline NNAPISettings() : NNAPISettings(nullptr) {}
  ~NNAPISettings() override;
  explicit PROTOBUF_CONSTEXPR NNAPISettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NNAPISettings(const NNAPISettings& from);
  NNAPISettings(NNAPISettings&& from) noexcept
    : NNAPISettings() {
    *this = ::std::move(from);
  }

  inline NNAPISettings& operator=(const NNAPISettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline NNAPISettings& operator=(NNAPISettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NNAPISettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const NNAPISettings* internal_default_instance() {
    return reinterpret_cast<const NNAPISettings*>(
               &_NNAPISettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(NNAPISettings& a, NNAPISettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NNAPISettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NNAPISettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NNAPISettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NNAPISettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NNAPISettings& from);
  void MergeFrom(const NNAPISettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NNAPISettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.NNAPISettings";
  }
  protected:
  explicit NNAPISettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAcceleratorNameFieldNumber = 1,
    kCacheDirectoryFieldNumber = 2,
    kModelTokenFieldNumber = 3,
    kFallbackSettingsFieldNumber = 6,
    kExecutionPreferenceFieldNumber = 4,
    kNoOfNnapiInstancesToCacheFieldNumber = 5,
    kExecutionPriorityFieldNumber = 8,
    kAllowNnapiCpuOnAndroid10PlusFieldNumber = 7,
    kAllowDynamicDimensionsFieldNumber = 9,
    kAllowFp16PrecisionForFp32FieldNumber = 10,
    kUseBurstComputationFieldNumber = 11,
    kSupportLibraryHandleFieldNumber = 12,
  };
  // optional string accelerator_name = 1;
  bool has_accelerator_name() const;
  private:
  bool _internal_has_accelerator_name() const;
  public:
  void clear_accelerator_name();
  const std::string& accelerator_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accelerator_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accelerator_name();
  PROTOBUF_NODISCARD std::string* release_accelerator_name();
  void set_allocated_accelerator_name(std::string* accelerator_name);
  private:
  const std::string& _internal_accelerator_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accelerator_name(const std::string& value);
  std::string* _internal_mutable_accelerator_name();
  public:

  // optional string cache_directory = 2;
  bool has_cache_directory() const;
  private:
  bool _internal_has_cache_directory() const;
  public:
  void clear_cache_directory();
  const std::string& cache_directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_directory();
  PROTOBUF_NODISCARD std::string* release_cache_directory();
  void set_allocated_cache_directory(std::string* cache_directory);
  private:
  const std::string& _internal_cache_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_directory(const std::string& value);
  std::string* _internal_mutable_cache_directory();
  public:

  // optional string model_token = 3;
  bool has_model_token() const;
  private:
  bool _internal_has_model_token() const;
  public:
  void clear_model_token();
  const std::string& model_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_token();
  PROTOBUF_NODISCARD std::string* release_model_token();
  void set_allocated_model_token(std::string* model_token);
  private:
  const std::string& _internal_model_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_token(const std::string& value);
  std::string* _internal_mutable_model_token();
  public:

  // optional .tflite.proto.FallbackSettings fallback_settings = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_fallback_settings() const;
  private:
  bool _internal_has_fallback_settings() const;
  public:
  PROTOBUF_DEPRECATED void clear_fallback_settings();
  PROTOBUF_DEPRECATED const ::tflite::proto::FallbackSettings& fallback_settings() const;
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED ::tflite::proto::FallbackSettings* release_fallback_settings();
  PROTOBUF_DEPRECATED ::tflite::proto::FallbackSettings* mutable_fallback_settings();
  PROTOBUF_DEPRECATED void set_allocated_fallback_settings(::tflite::proto::FallbackSettings* fallback_settings);
  private:
  const ::tflite::proto::FallbackSettings& _internal_fallback_settings() const;
  ::tflite::proto::FallbackSettings* _internal_mutable_fallback_settings();
  public:
  PROTOBUF_DEPRECATED void unsafe_arena_set_allocated_fallback_settings(
      ::tflite::proto::FallbackSettings* fallback_settings);
  PROTOBUF_DEPRECATED ::tflite::proto::FallbackSettings* unsafe_arena_release_fallback_settings();

  // optional .tflite.proto.NNAPIExecutionPreference execution_preference = 4;
  bool has_execution_preference() const;
  private:
  bool _internal_has_execution_preference() const;
  public:
  void clear_execution_preference();
  ::tflite::proto::NNAPIExecutionPreference execution_preference() const;
  void set_execution_preference(::tflite::proto::NNAPIExecutionPreference value);
  private:
  ::tflite::proto::NNAPIExecutionPreference _internal_execution_preference() const;
  void _internal_set_execution_preference(::tflite::proto::NNAPIExecutionPreference value);
  public:

  // optional int32 no_of_nnapi_instances_to_cache = 5;
  bool has_no_of_nnapi_instances_to_cache() const;
  private:
  bool _internal_has_no_of_nnapi_instances_to_cache() const;
  public:
  void clear_no_of_nnapi_instances_to_cache();
  int32_t no_of_nnapi_instances_to_cache() const;
  void set_no_of_nnapi_instances_to_cache(int32_t value);
  private:
  int32_t _internal_no_of_nnapi_instances_to_cache() const;
  void _internal_set_no_of_nnapi_instances_to_cache(int32_t value);
  public:

  // optional .tflite.proto.NNAPIExecutionPriority execution_priority = 8;
  bool has_execution_priority() const;
  private:
  bool _internal_has_execution_priority() const;
  public:
  void clear_execution_priority();
  ::tflite::proto::NNAPIExecutionPriority execution_priority() const;
  void set_execution_priority(::tflite::proto::NNAPIExecutionPriority value);
  private:
  ::tflite::proto::NNAPIExecutionPriority _internal_execution_priority() const;
  void _internal_set_execution_priority(::tflite::proto::NNAPIExecutionPriority value);
  public:

  // optional bool allow_nnapi_cpu_on_android_10_plus = 7;
  bool has_allow_nnapi_cpu_on_android_10_plus() const;
  private:
  bool _internal_has_allow_nnapi_cpu_on_android_10_plus() const;
  public:
  void clear_allow_nnapi_cpu_on_android_10_plus();
  bool allow_nnapi_cpu_on_android_10_plus() const;
  void set_allow_nnapi_cpu_on_android_10_plus(bool value);
  private:
  bool _internal_allow_nnapi_cpu_on_android_10_plus() const;
  void _internal_set_allow_nnapi_cpu_on_android_10_plus(bool value);
  public:

  // optional bool allow_dynamic_dimensions = 9;
  bool has_allow_dynamic_dimensions() const;
  private:
  bool _internal_has_allow_dynamic_dimensions() const;
  public:
  void clear_allow_dynamic_dimensions();
  bool allow_dynamic_dimensions() const;
  void set_allow_dynamic_dimensions(bool value);
  private:
  bool _internal_allow_dynamic_dimensions() const;
  void _internal_set_allow_dynamic_dimensions(bool value);
  public:

  // optional bool allow_fp16_precision_for_fp32 = 10;
  bool has_allow_fp16_precision_for_fp32() const;
  private:
  bool _internal_has_allow_fp16_precision_for_fp32() const;
  public:
  void clear_allow_fp16_precision_for_fp32();
  bool allow_fp16_precision_for_fp32() const;
  void set_allow_fp16_precision_for_fp32(bool value);
  private:
  bool _internal_allow_fp16_precision_for_fp32() const;
  void _internal_set_allow_fp16_precision_for_fp32(bool value);
  public:

  // optional bool use_burst_computation = 11;
  bool has_use_burst_computation() const;
  private:
  bool _internal_has_use_burst_computation() const;
  public:
  void clear_use_burst_computation();
  bool use_burst_computation() const;
  void set_use_burst_computation(bool value);
  private:
  bool _internal_use_burst_computation() const;
  void _internal_set_use_burst_computation(bool value);
  public:

  // optional int64 support_library_handle = 12;
  bool has_support_library_handle() const;
  private:
  bool _internal_has_support_library_handle() const;
  public:
  void clear_support_library_handle();
  int64_t support_library_handle() const;
  void set_support_library_handle(int64_t value);
  private:
  int64_t _internal_support_library_handle() const;
  void _internal_set_support_library_handle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.NNAPISettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accelerator_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_token_;
  ::tflite::proto::FallbackSettings* fallback_settings_;
  int execution_preference_;
  int32_t no_of_nnapi_instances_to_cache_;
  int execution_priority_;
  bool allow_nnapi_cpu_on_android_10_plus_;
  bool allow_dynamic_dimensions_;
  bool allow_fp16_precision_for_fp32_;
  bool use_burst_computation_;
  int64_t support_library_handle_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class GPUSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.GPUSettings) */ {
 public:
  inline GPUSettings() : GPUSettings(nullptr) {}
  ~GPUSettings() override;
  explicit PROTOBUF_CONSTEXPR GPUSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GPUSettings(const GPUSettings& from);
  GPUSettings(GPUSettings&& from) noexcept
    : GPUSettings() {
    *this = ::std::move(from);
  }

  inline GPUSettings& operator=(const GPUSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline GPUSettings& operator=(GPUSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GPUSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const GPUSettings* internal_default_instance() {
    return reinterpret_cast<const GPUSettings*>(
               &_GPUSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GPUSettings& a, GPUSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GPUSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GPUSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GPUSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GPUSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GPUSettings& from);
  void MergeFrom(const GPUSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GPUSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.GPUSettings";
  }
  protected:
  explicit GPUSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacheDirectoryFieldNumber = 8,
    kModelTokenFieldNumber = 9,
    kIsPrecisionLossAllowedFieldNumber = 1,
    kForceBackendFieldNumber = 3,
    kInferencePriority1FieldNumber = 4,
    kInferencePriority2FieldNumber = 5,
    kInferencePriority3FieldNumber = 6,
    kInferencePreferenceFieldNumber = 7,
    kEnableQuantizedInferenceFieldNumber = 2,
  };
  // optional string cache_directory = 8;
  bool has_cache_directory() const;
  private:
  bool _internal_has_cache_directory() const;
  public:
  void clear_cache_directory();
  const std::string& cache_directory() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_directory(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_directory();
  PROTOBUF_NODISCARD std::string* release_cache_directory();
  void set_allocated_cache_directory(std::string* cache_directory);
  private:
  const std::string& _internal_cache_directory() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_directory(const std::string& value);
  std::string* _internal_mutable_cache_directory();
  public:

  // optional string model_token = 9;
  bool has_model_token() const;
  private:
  bool _internal_has_model_token() const;
  public:
  void clear_model_token();
  const std::string& model_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_token();
  PROTOBUF_NODISCARD std::string* release_model_token();
  void set_allocated_model_token(std::string* model_token);
  private:
  const std::string& _internal_model_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_token(const std::string& value);
  std::string* _internal_mutable_model_token();
  public:

  // optional bool is_precision_loss_allowed = 1;
  bool has_is_precision_loss_allowed() const;
  private:
  bool _internal_has_is_precision_loss_allowed() const;
  public:
  void clear_is_precision_loss_allowed();
  bool is_precision_loss_allowed() const;
  void set_is_precision_loss_allowed(bool value);
  private:
  bool _internal_is_precision_loss_allowed() const;
  void _internal_set_is_precision_loss_allowed(bool value);
  public:

  // optional .tflite.proto.GPUBackend force_backend = 3;
  bool has_force_backend() const;
  private:
  bool _internal_has_force_backend() const;
  public:
  void clear_force_backend();
  ::tflite::proto::GPUBackend force_backend() const;
  void set_force_backend(::tflite::proto::GPUBackend value);
  private:
  ::tflite::proto::GPUBackend _internal_force_backend() const;
  void _internal_set_force_backend(::tflite::proto::GPUBackend value);
  public:

  // optional .tflite.proto.GPUInferencePriority inference_priority1 = 4 [default = GPU_PRIORITY_AUTO];
  bool has_inference_priority1() const;
  private:
  bool _internal_has_inference_priority1() const;
  public:
  void clear_inference_priority1();
  ::tflite::proto::GPUInferencePriority inference_priority1() const;
  void set_inference_priority1(::tflite::proto::GPUInferencePriority value);
  private:
  ::tflite::proto::GPUInferencePriority _internal_inference_priority1() const;
  void _internal_set_inference_priority1(::tflite::proto::GPUInferencePriority value);
  public:

  // optional .tflite.proto.GPUInferencePriority inference_priority2 = 5 [default = GPU_PRIORITY_AUTO];
  bool has_inference_priority2() const;
  private:
  bool _internal_has_inference_priority2() const;
  public:
  void clear_inference_priority2();
  ::tflite::proto::GPUInferencePriority inference_priority2() const;
  void set_inference_priority2(::tflite::proto::GPUInferencePriority value);
  private:
  ::tflite::proto::GPUInferencePriority _internal_inference_priority2() const;
  void _internal_set_inference_priority2(::tflite::proto::GPUInferencePriority value);
  public:

  // optional .tflite.proto.GPUInferencePriority inference_priority3 = 6 [default = GPU_PRIORITY_AUTO];
  bool has_inference_priority3() const;
  private:
  bool _internal_has_inference_priority3() const;
  public:
  void clear_inference_priority3();
  ::tflite::proto::GPUInferencePriority inference_priority3() const;
  void set_inference_priority3(::tflite::proto::GPUInferencePriority value);
  private:
  ::tflite::proto::GPUInferencePriority _internal_inference_priority3() const;
  void _internal_set_inference_priority3(::tflite::proto::GPUInferencePriority value);
  public:

  // optional .tflite.proto.GPUInferenceUsage inference_preference = 7;
  bool has_inference_preference() const;
  private:
  bool _internal_has_inference_preference() const;
  public:
  void clear_inference_preference();
  ::tflite::proto::GPUInferenceUsage inference_preference() const;
  void set_inference_preference(::tflite::proto::GPUInferenceUsage value);
  private:
  ::tflite::proto::GPUInferenceUsage _internal_inference_preference() const;
  void _internal_set_inference_preference(::tflite::proto::GPUInferenceUsage value);
  public:

  // optional bool enable_quantized_inference = 2 [default = true];
  bool has_enable_quantized_inference() const;
  private:
  bool _internal_has_enable_quantized_inference() const;
  public:
  void clear_enable_quantized_inference();
  bool enable_quantized_inference() const;
  void set_enable_quantized_inference(bool value);
  private:
  bool _internal_enable_quantized_inference() const;
  void _internal_set_enable_quantized_inference(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.GPUSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_directory_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_token_;
  bool is_precision_loss_allowed_;
  int force_backend_;
  int inference_priority1_;
  int inference_priority2_;
  int inference_priority3_;
  int inference_preference_;
  bool enable_quantized_inference_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class HexagonSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.HexagonSettings) */ {
 public:
  inline HexagonSettings() : HexagonSettings(nullptr) {}
  ~HexagonSettings() override;
  explicit PROTOBUF_CONSTEXPR HexagonSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HexagonSettings(const HexagonSettings& from);
  HexagonSettings(HexagonSettings&& from) noexcept
    : HexagonSettings() {
    *this = ::std::move(from);
  }

  inline HexagonSettings& operator=(const HexagonSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline HexagonSettings& operator=(HexagonSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HexagonSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const HexagonSettings* internal_default_instance() {
    return reinterpret_cast<const HexagonSettings*>(
               &_HexagonSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HexagonSettings& a, HexagonSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(HexagonSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HexagonSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HexagonSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HexagonSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HexagonSettings& from);
  void MergeFrom(const HexagonSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HexagonSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.HexagonSettings";
  }
  protected:
  explicit HexagonSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDebugLevelFieldNumber = 1,
    kPowersaveLevelFieldNumber = 2,
    kPrintGraphProfileFieldNumber = 3,
    kPrintGraphDebugFieldNumber = 4,
  };
  // optional int32 debug_level = 1;
  bool has_debug_level() const;
  private:
  bool _internal_has_debug_level() const;
  public:
  void clear_debug_level();
  int32_t debug_level() const;
  void set_debug_level(int32_t value);
  private:
  int32_t _internal_debug_level() const;
  void _internal_set_debug_level(int32_t value);
  public:

  // optional int32 powersave_level = 2;
  bool has_powersave_level() const;
  private:
  bool _internal_has_powersave_level() const;
  public:
  void clear_powersave_level();
  int32_t powersave_level() const;
  void set_powersave_level(int32_t value);
  private:
  int32_t _internal_powersave_level() const;
  void _internal_set_powersave_level(int32_t value);
  public:

  // optional bool print_graph_profile = 3;
  bool has_print_graph_profile() const;
  private:
  bool _internal_has_print_graph_profile() const;
  public:
  void clear_print_graph_profile();
  bool print_graph_profile() const;
  void set_print_graph_profile(bool value);
  private:
  bool _internal_print_graph_profile() const;
  void _internal_set_print_graph_profile(bool value);
  public:

  // optional bool print_graph_debug = 4;
  bool has_print_graph_debug() const;
  private:
  bool _internal_has_print_graph_debug() const;
  public:
  void clear_print_graph_debug();
  bool print_graph_debug() const;
  void set_print_graph_debug(bool value);
  private:
  bool _internal_print_graph_debug() const;
  void _internal_set_print_graph_debug(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.HexagonSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t debug_level_;
  int32_t powersave_level_;
  bool print_graph_profile_;
  bool print_graph_debug_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class XNNPackSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.XNNPackSettings) */ {
 public:
  inline XNNPackSettings() : XNNPackSettings(nullptr) {}
  ~XNNPackSettings() override;
  explicit PROTOBUF_CONSTEXPR XNNPackSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  XNNPackSettings(const XNNPackSettings& from);
  XNNPackSettings(XNNPackSettings&& from) noexcept
    : XNNPackSettings() {
    *this = ::std::move(from);
  }

  inline XNNPackSettings& operator=(const XNNPackSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline XNNPackSettings& operator=(XNNPackSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const XNNPackSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const XNNPackSettings* internal_default_instance() {
    return reinterpret_cast<const XNNPackSettings*>(
               &_XNNPackSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(XNNPackSettings& a, XNNPackSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(XNNPackSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(XNNPackSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  XNNPackSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<XNNPackSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const XNNPackSettings& from);
  void MergeFrom(const XNNPackSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(XNNPackSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.XNNPackSettings";
  }
  protected:
  explicit XNNPackSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumThreadsFieldNumber = 1,
    kFlagsFieldNumber = 2,
  };
  // optional int32 num_threads = 1;
  bool has_num_threads() const;
  private:
  bool _internal_has_num_threads() const;
  public:
  void clear_num_threads();
  int32_t num_threads() const;
  void set_num_threads(int32_t value);
  private:
  int32_t _internal_num_threads() const;
  void _internal_set_num_threads(int32_t value);
  public:

  // optional .tflite.proto.XNNPackFlags flags = 2 [default = TFLITE_XNNPACK_DELEGATE_NO_FLAGS];
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  ::tflite::proto::XNNPackFlags flags() const;
  void set_flags(::tflite::proto::XNNPackFlags value);
  private:
  ::tflite::proto::XNNPackFlags _internal_flags() const;
  void _internal_set_flags(::tflite::proto::XNNPackFlags value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.XNNPackSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t num_threads_;
  int flags_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class CoreMLSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.CoreMLSettings) */ {
 public:
  inline CoreMLSettings() : CoreMLSettings(nullptr) {}
  ~CoreMLSettings() override;
  explicit PROTOBUF_CONSTEXPR CoreMLSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoreMLSettings(const CoreMLSettings& from);
  CoreMLSettings(CoreMLSettings&& from) noexcept
    : CoreMLSettings() {
    *this = ::std::move(from);
  }

  inline CoreMLSettings& operator=(const CoreMLSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoreMLSettings& operator=(CoreMLSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CoreMLSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoreMLSettings* internal_default_instance() {
    return reinterpret_cast<const CoreMLSettings*>(
               &_CoreMLSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CoreMLSettings& a, CoreMLSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CoreMLSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoreMLSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoreMLSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoreMLSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CoreMLSettings& from);
  void MergeFrom(const CoreMLSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CoreMLSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.CoreMLSettings";
  }
  protected:
  explicit CoreMLSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CoreMLSettings_EnabledDevices EnabledDevices;
  static constexpr EnabledDevices DEVICES_ALL =
    CoreMLSettings_EnabledDevices_DEVICES_ALL;
  static constexpr EnabledDevices DEVICES_WITH_NEURAL_ENGINE =
    CoreMLSettings_EnabledDevices_DEVICES_WITH_NEURAL_ENGINE;
  static inline bool EnabledDevices_IsValid(int value) {
    return CoreMLSettings_EnabledDevices_IsValid(value);
  }
  static constexpr EnabledDevices EnabledDevices_MIN =
    CoreMLSettings_EnabledDevices_EnabledDevices_MIN;
  static constexpr EnabledDevices EnabledDevices_MAX =
    CoreMLSettings_EnabledDevices_EnabledDevices_MAX;
  static constexpr int EnabledDevices_ARRAYSIZE =
    CoreMLSettings_EnabledDevices_EnabledDevices_ARRAYSIZE;
  template<typename T>
  static inline const std::string& EnabledDevices_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EnabledDevices>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EnabledDevices_Name.");
    return CoreMLSettings_EnabledDevices_Name(enum_t_value);
  }
  static inline bool EnabledDevices_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EnabledDevices* value) {
    return CoreMLSettings_EnabledDevices_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledDevicesFieldNumber = 1,
    kCoremlVersionFieldNumber = 2,
    kMaxDelegatedPartitionsFieldNumber = 3,
    kMinNodesPerPartitionFieldNumber = 4,
  };
  // optional .tflite.proto.CoreMLSettings.EnabledDevices enabled_devices = 1;
  bool has_enabled_devices() const;
  private:
  bool _internal_has_enabled_devices() const;
  public:
  void clear_enabled_devices();
  ::tflite::proto::CoreMLSettings_EnabledDevices enabled_devices() const;
  void set_enabled_devices(::tflite::proto::CoreMLSettings_EnabledDevices value);
  private:
  ::tflite::proto::CoreMLSettings_EnabledDevices _internal_enabled_devices() const;
  void _internal_set_enabled_devices(::tflite::proto::CoreMLSettings_EnabledDevices value);
  public:

  // optional int32 coreml_version = 2;
  bool has_coreml_version() const;
  private:
  bool _internal_has_coreml_version() const;
  public:
  void clear_coreml_version();
  int32_t coreml_version() const;
  void set_coreml_version(int32_t value);
  private:
  int32_t _internal_coreml_version() const;
  void _internal_set_coreml_version(int32_t value);
  public:

  // optional int32 max_delegated_partitions = 3 [default = 0];
  bool has_max_delegated_partitions() const;
  private:
  bool _internal_has_max_delegated_partitions() const;
  public:
  void clear_max_delegated_partitions();
  int32_t max_delegated_partitions() const;
  void set_max_delegated_partitions(int32_t value);
  private:
  int32_t _internal_max_delegated_partitions() const;
  void _internal_set_max_delegated_partitions(int32_t value);
  public:

  // optional int32 min_nodes_per_partition = 4 [default = 2];
  bool has_min_nodes_per_partition() const;
  private:
  bool _internal_has_min_nodes_per_partition() const;
  public:
  void clear_min_nodes_per_partition();
  int32_t min_nodes_per_partition() const;
  void set_min_nodes_per_partition(int32_t value);
  private:
  int32_t _internal_min_nodes_per_partition() const;
  void _internal_set_min_nodes_per_partition(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.CoreMLSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int enabled_devices_;
  int32_t coreml_version_;
  int32_t max_delegated_partitions_;
  int32_t min_nodes_per_partition_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class EdgeTpuDeviceSpec final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.EdgeTpuDeviceSpec) */ {
 public:
  inline EdgeTpuDeviceSpec() : EdgeTpuDeviceSpec(nullptr) {}
  ~EdgeTpuDeviceSpec() override;
  explicit PROTOBUF_CONSTEXPR EdgeTpuDeviceSpec(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeTpuDeviceSpec(const EdgeTpuDeviceSpec& from);
  EdgeTpuDeviceSpec(EdgeTpuDeviceSpec&& from) noexcept
    : EdgeTpuDeviceSpec() {
    *this = ::std::move(from);
  }

  inline EdgeTpuDeviceSpec& operator=(const EdgeTpuDeviceSpec& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeTpuDeviceSpec& operator=(EdgeTpuDeviceSpec&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EdgeTpuDeviceSpec& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeTpuDeviceSpec* internal_default_instance() {
    return reinterpret_cast<const EdgeTpuDeviceSpec*>(
               &_EdgeTpuDeviceSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(EdgeTpuDeviceSpec& a, EdgeTpuDeviceSpec& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EdgeTpuDeviceSpec* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeTpuDeviceSpec* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgeTpuDeviceSpec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgeTpuDeviceSpec>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EdgeTpuDeviceSpec& from);
  void MergeFrom(const EdgeTpuDeviceSpec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EdgeTpuDeviceSpec* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.EdgeTpuDeviceSpec";
  }
  protected:
  explicit EdgeTpuDeviceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EdgeTpuDeviceSpec_PlatformType PlatformType;
  static constexpr PlatformType MMIO =
    EdgeTpuDeviceSpec_PlatformType_MMIO;
  static constexpr PlatformType REFERENCE =
    EdgeTpuDeviceSpec_PlatformType_REFERENCE;
  static constexpr PlatformType SIMULATOR =
    EdgeTpuDeviceSpec_PlatformType_SIMULATOR;
  static constexpr PlatformType REMOTE_SIMULATOR =
    EdgeTpuDeviceSpec_PlatformType_REMOTE_SIMULATOR;
  static inline bool PlatformType_IsValid(int value) {
    return EdgeTpuDeviceSpec_PlatformType_IsValid(value);
  }
  static constexpr PlatformType PlatformType_MIN =
    EdgeTpuDeviceSpec_PlatformType_PlatformType_MIN;
  static constexpr PlatformType PlatformType_MAX =
    EdgeTpuDeviceSpec_PlatformType_PlatformType_MAX;
  static constexpr int PlatformType_ARRAYSIZE =
    EdgeTpuDeviceSpec_PlatformType_PlatformType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PlatformType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PlatformType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PlatformType_Name.");
    return EdgeTpuDeviceSpec_PlatformType_Name(enum_t_value);
  }
  static inline bool PlatformType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PlatformType* value) {
    return EdgeTpuDeviceSpec_PlatformType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDevicePathsFieldNumber = 3,
    kPlatformTypeFieldNumber = 1,
    kNumChipsFieldNumber = 2,
    kChipFamilyFieldNumber = 4,
  };
  // repeated string device_paths = 3;
  int device_paths_size() const;
  private:
  int _internal_device_paths_size() const;
  public:
  void clear_device_paths();
  const std::string& device_paths(int index) const;
  std::string* mutable_device_paths(int index);
  void set_device_paths(int index, const std::string& value);
  void set_device_paths(int index, std::string&& value);
  void set_device_paths(int index, const char* value);
  void set_device_paths(int index, const char* value, size_t size);
  std::string* add_device_paths();
  void add_device_paths(const std::string& value);
  void add_device_paths(std::string&& value);
  void add_device_paths(const char* value);
  void add_device_paths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_paths();
  private:
  const std::string& _internal_device_paths(int index) const;
  std::string* _internal_add_device_paths();
  public:

  // optional .tflite.proto.EdgeTpuDeviceSpec.PlatformType platform_type = 1;
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::tflite::proto::EdgeTpuDeviceSpec_PlatformType platform_type() const;
  void set_platform_type(::tflite::proto::EdgeTpuDeviceSpec_PlatformType value);
  private:
  ::tflite::proto::EdgeTpuDeviceSpec_PlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::tflite::proto::EdgeTpuDeviceSpec_PlatformType value);
  public:

  // optional int32 num_chips = 2;
  bool has_num_chips() const;
  private:
  bool _internal_has_num_chips() const;
  public:
  void clear_num_chips();
  int32_t num_chips() const;
  void set_num_chips(int32_t value);
  private:
  int32_t _internal_num_chips() const;
  void _internal_set_num_chips(int32_t value);
  public:

  // optional int32 chip_family = 4;
  bool has_chip_family() const;
  private:
  bool _internal_has_chip_family() const;
  public:
  void clear_chip_family();
  int32_t chip_family() const;
  void set_chip_family(int32_t value);
  private:
  int32_t _internal_chip_family() const;
  void _internal_set_chip_family(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.EdgeTpuDeviceSpec)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_paths_;
  int platform_type_;
  int32_t num_chips_;
  int32_t chip_family_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class EdgeTpuInactivePowerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.EdgeTpuInactivePowerConfig) */ {
 public:
  inline EdgeTpuInactivePowerConfig() : EdgeTpuInactivePowerConfig(nullptr) {}
  ~EdgeTpuInactivePowerConfig() override;
  explicit PROTOBUF_CONSTEXPR EdgeTpuInactivePowerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeTpuInactivePowerConfig(const EdgeTpuInactivePowerConfig& from);
  EdgeTpuInactivePowerConfig(EdgeTpuInactivePowerConfig&& from) noexcept
    : EdgeTpuInactivePowerConfig() {
    *this = ::std::move(from);
  }

  inline EdgeTpuInactivePowerConfig& operator=(const EdgeTpuInactivePowerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeTpuInactivePowerConfig& operator=(EdgeTpuInactivePowerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EdgeTpuInactivePowerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeTpuInactivePowerConfig* internal_default_instance() {
    return reinterpret_cast<const EdgeTpuInactivePowerConfig*>(
               &_EdgeTpuInactivePowerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EdgeTpuInactivePowerConfig& a, EdgeTpuInactivePowerConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EdgeTpuInactivePowerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeTpuInactivePowerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgeTpuInactivePowerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgeTpuInactivePowerConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EdgeTpuInactivePowerConfig& from);
  void MergeFrom(const EdgeTpuInactivePowerConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EdgeTpuInactivePowerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.EdgeTpuInactivePowerConfig";
  }
  protected:
  explicit EdgeTpuInactivePowerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInactiveTimeoutUsFieldNumber = 2,
    kInactivePowerStateFieldNumber = 1,
  };
  // optional int64 inactive_timeout_us = 2;
  bool has_inactive_timeout_us() const;
  private:
  bool _internal_has_inactive_timeout_us() const;
  public:
  void clear_inactive_timeout_us();
  int64_t inactive_timeout_us() const;
  void set_inactive_timeout_us(int64_t value);
  private:
  int64_t _internal_inactive_timeout_us() const;
  void _internal_set_inactive_timeout_us(int64_t value);
  public:

  // optional .tflite.proto.EdgeTpuPowerState inactive_power_state = 1;
  bool has_inactive_power_state() const;
  private:
  bool _internal_has_inactive_power_state() const;
  public:
  void clear_inactive_power_state();
  ::tflite::proto::EdgeTpuPowerState inactive_power_state() const;
  void set_inactive_power_state(::tflite::proto::EdgeTpuPowerState value);
  private:
  ::tflite::proto::EdgeTpuPowerState _internal_inactive_power_state() const;
  void _internal_set_inactive_power_state(::tflite::proto::EdgeTpuPowerState value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.EdgeTpuInactivePowerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t inactive_timeout_us_;
  int inactive_power_state_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class EdgeTpuSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.EdgeTpuSettings) */ {
 public:
  inline EdgeTpuSettings() : EdgeTpuSettings(nullptr) {}
  ~EdgeTpuSettings() override;
  explicit PROTOBUF_CONSTEXPR EdgeTpuSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EdgeTpuSettings(const EdgeTpuSettings& from);
  EdgeTpuSettings(EdgeTpuSettings&& from) noexcept
    : EdgeTpuSettings() {
    *this = ::std::move(from);
  }

  inline EdgeTpuSettings& operator=(const EdgeTpuSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline EdgeTpuSettings& operator=(EdgeTpuSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EdgeTpuSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const EdgeTpuSettings* internal_default_instance() {
    return reinterpret_cast<const EdgeTpuSettings*>(
               &_EdgeTpuSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(EdgeTpuSettings& a, EdgeTpuSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EdgeTpuSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EdgeTpuSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EdgeTpuSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EdgeTpuSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EdgeTpuSettings& from);
  void MergeFrom(const EdgeTpuSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EdgeTpuSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.EdgeTpuSettings";
  }
  protected:
  explicit EdgeTpuSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef EdgeTpuSettings_FloatTruncationType FloatTruncationType;
  static constexpr FloatTruncationType UNSPECIFIED =
    EdgeTpuSettings_FloatTruncationType_UNSPECIFIED;
  static constexpr FloatTruncationType NO_TRUNCATION =
    EdgeTpuSettings_FloatTruncationType_NO_TRUNCATION;
  static constexpr FloatTruncationType BFLOAT16 =
    EdgeTpuSettings_FloatTruncationType_BFLOAT16;
  static constexpr FloatTruncationType HALF =
    EdgeTpuSettings_FloatTruncationType_HALF;
  static inline bool FloatTruncationType_IsValid(int value) {
    return EdgeTpuSettings_FloatTruncationType_IsValid(value);
  }
  static constexpr FloatTruncationType FloatTruncationType_MIN =
    EdgeTpuSettings_FloatTruncationType_FloatTruncationType_MIN;
  static constexpr FloatTruncationType FloatTruncationType_MAX =
    EdgeTpuSettings_FloatTruncationType_FloatTruncationType_MAX;
  static constexpr int FloatTruncationType_ARRAYSIZE =
    EdgeTpuSettings_FloatTruncationType_FloatTruncationType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FloatTruncationType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FloatTruncationType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FloatTruncationType_Name.");
    return EdgeTpuSettings_FloatTruncationType_Name(enum_t_value);
  }
  static inline bool FloatTruncationType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FloatTruncationType* value) {
    return EdgeTpuSettings_FloatTruncationType_Parse(name, value);
  }

  typedef EdgeTpuSettings_QosClass QosClass;
  static constexpr QosClass QOS_UNDEFINED =
    EdgeTpuSettings_QosClass_QOS_UNDEFINED;
  static constexpr QosClass BEST_EFFORT =
    EdgeTpuSettings_QosClass_BEST_EFFORT;
  static constexpr QosClass REALTIME =
    EdgeTpuSettings_QosClass_REALTIME;
  static inline bool QosClass_IsValid(int value) {
    return EdgeTpuSettings_QosClass_IsValid(value);
  }
  static constexpr QosClass QosClass_MIN =
    EdgeTpuSettings_QosClass_QosClass_MIN;
  static constexpr QosClass QosClass_MAX =
    EdgeTpuSettings_QosClass_QosClass_MAX;
  static constexpr int QosClass_ARRAYSIZE =
    EdgeTpuSettings_QosClass_QosClass_ARRAYSIZE;
  template<typename T>
  static inline const std::string& QosClass_Name(T enum_t_value) {
    static_assert(::std::is_same<T, QosClass>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function QosClass_Name.");
    return EdgeTpuSettings_QosClass_Name(enum_t_value);
  }
  static inline bool QosClass_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      QosClass* value) {
    return EdgeTpuSettings_QosClass_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInactivePowerConfigsFieldNumber = 2,
    kModelTokenFieldNumber = 5,
    kEdgetpuDeviceSpecFieldNumber = 4,
    kInferencePowerStateFieldNumber = 1,
    kFloatTruncationTypeFieldNumber = 6,
    kQosClassFieldNumber = 7,
    kInferencePriorityFieldNumber = 3,
  };
  // repeated .tflite.proto.EdgeTpuInactivePowerConfig inactive_power_configs = 2;
  int inactive_power_configs_size() const;
  private:
  int _internal_inactive_power_configs_size() const;
  public:
  void clear_inactive_power_configs();
  ::tflite::proto::EdgeTpuInactivePowerConfig* mutable_inactive_power_configs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::EdgeTpuInactivePowerConfig >*
      mutable_inactive_power_configs();
  private:
  const ::tflite::proto::EdgeTpuInactivePowerConfig& _internal_inactive_power_configs(int index) const;
  ::tflite::proto::EdgeTpuInactivePowerConfig* _internal_add_inactive_power_configs();
  public:
  const ::tflite::proto::EdgeTpuInactivePowerConfig& inactive_power_configs(int index) const;
  ::tflite::proto::EdgeTpuInactivePowerConfig* add_inactive_power_configs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::EdgeTpuInactivePowerConfig >&
      inactive_power_configs() const;

  // optional string model_token = 5;
  bool has_model_token() const;
  private:
  bool _internal_has_model_token() const;
  public:
  void clear_model_token();
  const std::string& model_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_model_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_model_token();
  PROTOBUF_NODISCARD std::string* release_model_token();
  void set_allocated_model_token(std::string* model_token);
  private:
  const std::string& _internal_model_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_model_token(const std::string& value);
  std::string* _internal_mutable_model_token();
  public:

  // optional .tflite.proto.EdgeTpuDeviceSpec edgetpu_device_spec = 4;
  bool has_edgetpu_device_spec() const;
  private:
  bool _internal_has_edgetpu_device_spec() const;
  public:
  void clear_edgetpu_device_spec();
  const ::tflite::proto::EdgeTpuDeviceSpec& edgetpu_device_spec() const;
  PROTOBUF_NODISCARD ::tflite::proto::EdgeTpuDeviceSpec* release_edgetpu_device_spec();
  ::tflite::proto::EdgeTpuDeviceSpec* mutable_edgetpu_device_spec();
  void set_allocated_edgetpu_device_spec(::tflite::proto::EdgeTpuDeviceSpec* edgetpu_device_spec);
  private:
  const ::tflite::proto::EdgeTpuDeviceSpec& _internal_edgetpu_device_spec() const;
  ::tflite::proto::EdgeTpuDeviceSpec* _internal_mutable_edgetpu_device_spec();
  public:
  void unsafe_arena_set_allocated_edgetpu_device_spec(
      ::tflite::proto::EdgeTpuDeviceSpec* edgetpu_device_spec);
  ::tflite::proto::EdgeTpuDeviceSpec* unsafe_arena_release_edgetpu_device_spec();

  // optional .tflite.proto.EdgeTpuPowerState inference_power_state = 1;
  bool has_inference_power_state() const;
  private:
  bool _internal_has_inference_power_state() const;
  public:
  void clear_inference_power_state();
  ::tflite::proto::EdgeTpuPowerState inference_power_state() const;
  void set_inference_power_state(::tflite::proto::EdgeTpuPowerState value);
  private:
  ::tflite::proto::EdgeTpuPowerState _internal_inference_power_state() const;
  void _internal_set_inference_power_state(::tflite::proto::EdgeTpuPowerState value);
  public:

  // optional .tflite.proto.EdgeTpuSettings.FloatTruncationType float_truncation_type = 6;
  bool has_float_truncation_type() const;
  private:
  bool _internal_has_float_truncation_type() const;
  public:
  void clear_float_truncation_type();
  ::tflite::proto::EdgeTpuSettings_FloatTruncationType float_truncation_type() const;
  void set_float_truncation_type(::tflite::proto::EdgeTpuSettings_FloatTruncationType value);
  private:
  ::tflite::proto::EdgeTpuSettings_FloatTruncationType _internal_float_truncation_type() const;
  void _internal_set_float_truncation_type(::tflite::proto::EdgeTpuSettings_FloatTruncationType value);
  public:

  // optional .tflite.proto.EdgeTpuSettings.QosClass qos_class = 7 [default = QOS_UNDEFINED];
  bool has_qos_class() const;
  private:
  bool _internal_has_qos_class() const;
  public:
  void clear_qos_class();
  ::tflite::proto::EdgeTpuSettings_QosClass qos_class() const;
  void set_qos_class(::tflite::proto::EdgeTpuSettings_QosClass value);
  private:
  ::tflite::proto::EdgeTpuSettings_QosClass _internal_qos_class() const;
  void _internal_set_qos_class(::tflite::proto::EdgeTpuSettings_QosClass value);
  public:

  // optional int32 inference_priority = 3 [default = -1];
  bool has_inference_priority() const;
  private:
  bool _internal_has_inference_priority() const;
  public:
  void clear_inference_priority();
  int32_t inference_priority() const;
  void set_inference_priority(int32_t value);
  private:
  int32_t _internal_inference_priority() const;
  void _internal_set_inference_priority(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.EdgeTpuSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::EdgeTpuInactivePowerConfig > inactive_power_configs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr model_token_;
  ::tflite::proto::EdgeTpuDeviceSpec* edgetpu_device_spec_;
  int inference_power_state_;
  int float_truncation_type_;
  int qos_class_;
  int32_t inference_priority_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class CoralSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.CoralSettings) */ {
 public:
  inline CoralSettings() : CoralSettings(nullptr) {}
  ~CoralSettings() override;
  explicit PROTOBUF_CONSTEXPR CoralSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoralSettings(const CoralSettings& from);
  CoralSettings(CoralSettings&& from) noexcept
    : CoralSettings() {
    *this = ::std::move(from);
  }

  inline CoralSettings& operator=(const CoralSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoralSettings& operator=(CoralSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CoralSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoralSettings* internal_default_instance() {
    return reinterpret_cast<const CoralSettings*>(
               &_CoralSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CoralSettings& a, CoralSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CoralSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoralSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoralSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoralSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CoralSettings& from);
  void MergeFrom(const CoralSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CoralSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.CoralSettings";
  }
  protected:
  explicit CoralSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CoralSettings_Performance Performance;
  static constexpr Performance UNDEFINED =
    CoralSettings_Performance_UNDEFINED;
  static constexpr Performance MAXIMUM =
    CoralSettings_Performance_MAXIMUM;
  static constexpr Performance HIGH =
    CoralSettings_Performance_HIGH;
  static constexpr Performance MEDIUM =
    CoralSettings_Performance_MEDIUM;
  static constexpr Performance LOW =
    CoralSettings_Performance_LOW;
  static inline bool Performance_IsValid(int value) {
    return CoralSettings_Performance_IsValid(value);
  }
  static constexpr Performance Performance_MIN =
    CoralSettings_Performance_Performance_MIN;
  static constexpr Performance Performance_MAX =
    CoralSettings_Performance_Performance_MAX;
  static constexpr int Performance_ARRAYSIZE =
    CoralSettings_Performance_Performance_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Performance_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Performance>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Performance_Name.");
    return CoralSettings_Performance_Name(enum_t_value);
  }
  static inline bool Performance_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Performance* value) {
    return CoralSettings_Performance_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFieldNumber = 1,
    kUsbAlwaysDfuFieldNumber = 3,
    kUsbMaxBulkInQueueLengthFieldNumber = 4,
    kPerformanceFieldNumber = 2,
  };
  // optional string device = 1;
  bool has_device() const;
  private:
  bool _internal_has_device() const;
  public:
  void clear_device();
  const std::string& device() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device();
  PROTOBUF_NODISCARD std::string* release_device();
  void set_allocated_device(std::string* device);
  private:
  const std::string& _internal_device() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device(const std::string& value);
  std::string* _internal_mutable_device();
  public:

  // optional bool usb_always_dfu = 3;
  bool has_usb_always_dfu() const;
  private:
  bool _internal_has_usb_always_dfu() const;
  public:
  void clear_usb_always_dfu();
  bool usb_always_dfu() const;
  void set_usb_always_dfu(bool value);
  private:
  bool _internal_usb_always_dfu() const;
  void _internal_set_usb_always_dfu(bool value);
  public:

  // optional int32 usb_max_bulk_in_queue_length = 4;
  bool has_usb_max_bulk_in_queue_length() const;
  private:
  bool _internal_has_usb_max_bulk_in_queue_length() const;
  public:
  void clear_usb_max_bulk_in_queue_length();
  int32_t usb_max_bulk_in_queue_length() const;
  void set_usb_max_bulk_in_queue_length(int32_t value);
  private:
  int32_t _internal_usb_max_bulk_in_queue_length() const;
  void _internal_set_usb_max_bulk_in_queue_length(int32_t value);
  public:

  // optional .tflite.proto.CoralSettings.Performance performance = 2 [default = MAXIMUM];
  bool has_performance() const;
  private:
  bool _internal_has_performance() const;
  public:
  void clear_performance();
  ::tflite::proto::CoralSettings_Performance performance() const;
  void set_performance(::tflite::proto::CoralSettings_Performance value);
  private:
  ::tflite::proto::CoralSettings_Performance _internal_performance() const;
  void _internal_set_performance(::tflite::proto::CoralSettings_Performance value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.CoralSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_;
  bool usb_always_dfu_;
  int32_t usb_max_bulk_in_queue_length_;
  int performance_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class CPUSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.CPUSettings) */ {
 public:
  inline CPUSettings() : CPUSettings(nullptr) {}
  ~CPUSettings() override;
  explicit PROTOBUF_CONSTEXPR CPUSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPUSettings(const CPUSettings& from);
  CPUSettings(CPUSettings&& from) noexcept
    : CPUSettings() {
    *this = ::std::move(from);
  }

  inline CPUSettings& operator=(const CPUSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPUSettings& operator=(CPUSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CPUSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPUSettings* internal_default_instance() {
    return reinterpret_cast<const CPUSettings*>(
               &_CPUSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CPUSettings& a, CPUSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CPUSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPUSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPUSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPUSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CPUSettings& from);
  void MergeFrom(const CPUSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CPUSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.CPUSettings";
  }
  protected:
  explicit CPUSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumThreadsFieldNumber = 1,
  };
  // optional int32 num_threads = 1 [default = -1];
  bool has_num_threads() const;
  private:
  bool _internal_has_num_threads() const;
  public:
  void clear_num_threads();
  int32_t num_threads() const;
  void set_num_threads(int32_t value);
  private:
  int32_t _internal_num_threads() const;
  void _internal_set_num_threads(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.CPUSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t num_threads_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class TFLiteSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.TFLiteSettings) */ {
 public:
  inline TFLiteSettings() : TFLiteSettings(nullptr) {}
  ~TFLiteSettings() override;
  explicit PROTOBUF_CONSTEXPR TFLiteSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TFLiteSettings(const TFLiteSettings& from);
  TFLiteSettings(TFLiteSettings&& from) noexcept
    : TFLiteSettings() {
    *this = ::std::move(from);
  }

  inline TFLiteSettings& operator=(const TFLiteSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline TFLiteSettings& operator=(TFLiteSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TFLiteSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const TFLiteSettings* internal_default_instance() {
    return reinterpret_cast<const TFLiteSettings*>(
               &_TFLiteSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(TFLiteSettings& a, TFLiteSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TFLiteSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TFLiteSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TFLiteSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TFLiteSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TFLiteSettings& from);
  void MergeFrom(const TFLiteSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TFLiteSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.TFLiteSettings";
  }
  protected:
  explicit TFLiteSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNnapiSettingsFieldNumber = 2,
    kGpuSettingsFieldNumber = 3,
    kHexagonSettingsFieldNumber = 4,
    kXnnpackSettingsFieldNumber = 5,
    kCpuSettingsFieldNumber = 6,
    kEdgetpuSettingsFieldNumber = 8,
    kFallbackSettingsFieldNumber = 9,
    kCoralSettingsFieldNumber = 10,
    kCoremlSettingsFieldNumber = 11,
    kDelegateFieldNumber = 1,
    kMaxDelegatedPartitionsFieldNumber = 7,
    kDisableDefaultDelegatesFieldNumber = 12,
  };
  // optional .tflite.proto.NNAPISettings nnapi_settings = 2;
  bool has_nnapi_settings() const;
  private:
  bool _internal_has_nnapi_settings() const;
  public:
  void clear_nnapi_settings();
  const ::tflite::proto::NNAPISettings& nnapi_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::NNAPISettings* release_nnapi_settings();
  ::tflite::proto::NNAPISettings* mutable_nnapi_settings();
  void set_allocated_nnapi_settings(::tflite::proto::NNAPISettings* nnapi_settings);
  private:
  const ::tflite::proto::NNAPISettings& _internal_nnapi_settings() const;
  ::tflite::proto::NNAPISettings* _internal_mutable_nnapi_settings();
  public:
  void unsafe_arena_set_allocated_nnapi_settings(
      ::tflite::proto::NNAPISettings* nnapi_settings);
  ::tflite::proto::NNAPISettings* unsafe_arena_release_nnapi_settings();

  // optional .tflite.proto.GPUSettings gpu_settings = 3;
  bool has_gpu_settings() const;
  private:
  bool _internal_has_gpu_settings() const;
  public:
  void clear_gpu_settings();
  const ::tflite::proto::GPUSettings& gpu_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::GPUSettings* release_gpu_settings();
  ::tflite::proto::GPUSettings* mutable_gpu_settings();
  void set_allocated_gpu_settings(::tflite::proto::GPUSettings* gpu_settings);
  private:
  const ::tflite::proto::GPUSettings& _internal_gpu_settings() const;
  ::tflite::proto::GPUSettings* _internal_mutable_gpu_settings();
  public:
  void unsafe_arena_set_allocated_gpu_settings(
      ::tflite::proto::GPUSettings* gpu_settings);
  ::tflite::proto::GPUSettings* unsafe_arena_release_gpu_settings();

  // optional .tflite.proto.HexagonSettings hexagon_settings = 4;
  bool has_hexagon_settings() const;
  private:
  bool _internal_has_hexagon_settings() const;
  public:
  void clear_hexagon_settings();
  const ::tflite::proto::HexagonSettings& hexagon_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::HexagonSettings* release_hexagon_settings();
  ::tflite::proto::HexagonSettings* mutable_hexagon_settings();
  void set_allocated_hexagon_settings(::tflite::proto::HexagonSettings* hexagon_settings);
  private:
  const ::tflite::proto::HexagonSettings& _internal_hexagon_settings() const;
  ::tflite::proto::HexagonSettings* _internal_mutable_hexagon_settings();
  public:
  void unsafe_arena_set_allocated_hexagon_settings(
      ::tflite::proto::HexagonSettings* hexagon_settings);
  ::tflite::proto::HexagonSettings* unsafe_arena_release_hexagon_settings();

  // optional .tflite.proto.XNNPackSettings xnnpack_settings = 5;
  bool has_xnnpack_settings() const;
  private:
  bool _internal_has_xnnpack_settings() const;
  public:
  void clear_xnnpack_settings();
  const ::tflite::proto::XNNPackSettings& xnnpack_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::XNNPackSettings* release_xnnpack_settings();
  ::tflite::proto::XNNPackSettings* mutable_xnnpack_settings();
  void set_allocated_xnnpack_settings(::tflite::proto::XNNPackSettings* xnnpack_settings);
  private:
  const ::tflite::proto::XNNPackSettings& _internal_xnnpack_settings() const;
  ::tflite::proto::XNNPackSettings* _internal_mutable_xnnpack_settings();
  public:
  void unsafe_arena_set_allocated_xnnpack_settings(
      ::tflite::proto::XNNPackSettings* xnnpack_settings);
  ::tflite::proto::XNNPackSettings* unsafe_arena_release_xnnpack_settings();

  // optional .tflite.proto.CPUSettings cpu_settings = 6;
  bool has_cpu_settings() const;
  private:
  bool _internal_has_cpu_settings() const;
  public:
  void clear_cpu_settings();
  const ::tflite::proto::CPUSettings& cpu_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::CPUSettings* release_cpu_settings();
  ::tflite::proto::CPUSettings* mutable_cpu_settings();
  void set_allocated_cpu_settings(::tflite::proto::CPUSettings* cpu_settings);
  private:
  const ::tflite::proto::CPUSettings& _internal_cpu_settings() const;
  ::tflite::proto::CPUSettings* _internal_mutable_cpu_settings();
  public:
  void unsafe_arena_set_allocated_cpu_settings(
      ::tflite::proto::CPUSettings* cpu_settings);
  ::tflite::proto::CPUSettings* unsafe_arena_release_cpu_settings();

  // optional .tflite.proto.EdgeTpuSettings edgetpu_settings = 8;
  bool has_edgetpu_settings() const;
  private:
  bool _internal_has_edgetpu_settings() const;
  public:
  void clear_edgetpu_settings();
  const ::tflite::proto::EdgeTpuSettings& edgetpu_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::EdgeTpuSettings* release_edgetpu_settings();
  ::tflite::proto::EdgeTpuSettings* mutable_edgetpu_settings();
  void set_allocated_edgetpu_settings(::tflite::proto::EdgeTpuSettings* edgetpu_settings);
  private:
  const ::tflite::proto::EdgeTpuSettings& _internal_edgetpu_settings() const;
  ::tflite::proto::EdgeTpuSettings* _internal_mutable_edgetpu_settings();
  public:
  void unsafe_arena_set_allocated_edgetpu_settings(
      ::tflite::proto::EdgeTpuSettings* edgetpu_settings);
  ::tflite::proto::EdgeTpuSettings* unsafe_arena_release_edgetpu_settings();

  // optional .tflite.proto.FallbackSettings fallback_settings = 9;
  bool has_fallback_settings() const;
  private:
  bool _internal_has_fallback_settings() const;
  public:
  void clear_fallback_settings();
  const ::tflite::proto::FallbackSettings& fallback_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::FallbackSettings* release_fallback_settings();
  ::tflite::proto::FallbackSettings* mutable_fallback_settings();
  void set_allocated_fallback_settings(::tflite::proto::FallbackSettings* fallback_settings);
  private:
  const ::tflite::proto::FallbackSettings& _internal_fallback_settings() const;
  ::tflite::proto::FallbackSettings* _internal_mutable_fallback_settings();
  public:
  void unsafe_arena_set_allocated_fallback_settings(
      ::tflite::proto::FallbackSettings* fallback_settings);
  ::tflite::proto::FallbackSettings* unsafe_arena_release_fallback_settings();

  // optional .tflite.proto.CoralSettings coral_settings = 10;
  bool has_coral_settings() const;
  private:
  bool _internal_has_coral_settings() const;
  public:
  void clear_coral_settings();
  const ::tflite::proto::CoralSettings& coral_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::CoralSettings* release_coral_settings();
  ::tflite::proto::CoralSettings* mutable_coral_settings();
  void set_allocated_coral_settings(::tflite::proto::CoralSettings* coral_settings);
  private:
  const ::tflite::proto::CoralSettings& _internal_coral_settings() const;
  ::tflite::proto::CoralSettings* _internal_mutable_coral_settings();
  public:
  void unsafe_arena_set_allocated_coral_settings(
      ::tflite::proto::CoralSettings* coral_settings);
  ::tflite::proto::CoralSettings* unsafe_arena_release_coral_settings();

  // optional .tflite.proto.CoreMLSettings coreml_settings = 11;
  bool has_coreml_settings() const;
  private:
  bool _internal_has_coreml_settings() const;
  public:
  void clear_coreml_settings();
  const ::tflite::proto::CoreMLSettings& coreml_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::CoreMLSettings* release_coreml_settings();
  ::tflite::proto::CoreMLSettings* mutable_coreml_settings();
  void set_allocated_coreml_settings(::tflite::proto::CoreMLSettings* coreml_settings);
  private:
  const ::tflite::proto::CoreMLSettings& _internal_coreml_settings() const;
  ::tflite::proto::CoreMLSettings* _internal_mutable_coreml_settings();
  public:
  void unsafe_arena_set_allocated_coreml_settings(
      ::tflite::proto::CoreMLSettings* coreml_settings);
  ::tflite::proto::CoreMLSettings* unsafe_arena_release_coreml_settings();

  // optional .tflite.proto.Delegate delegate = 1;
  bool has_delegate() const;
  private:
  bool _internal_has_delegate() const;
  public:
  void clear_delegate();
  ::tflite::proto::Delegate delegate() const;
  void set_delegate(::tflite::proto::Delegate value);
  private:
  ::tflite::proto::Delegate _internal_delegate() const;
  void _internal_set_delegate(::tflite::proto::Delegate value);
  public:

  // optional int32 max_delegated_partitions = 7;
  bool has_max_delegated_partitions() const;
  private:
  bool _internal_has_max_delegated_partitions() const;
  public:
  void clear_max_delegated_partitions();
  int32_t max_delegated_partitions() const;
  void set_max_delegated_partitions(int32_t value);
  private:
  int32_t _internal_max_delegated_partitions() const;
  void _internal_set_max_delegated_partitions(int32_t value);
  public:

  // optional bool disable_default_delegates = 12;
  bool has_disable_default_delegates() const;
  private:
  bool _internal_has_disable_default_delegates() const;
  public:
  void clear_disable_default_delegates();
  bool disable_default_delegates() const;
  void set_disable_default_delegates(bool value);
  private:
  bool _internal_disable_default_delegates() const;
  void _internal_set_disable_default_delegates(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.TFLiteSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::tflite::proto::NNAPISettings* nnapi_settings_;
  ::tflite::proto::GPUSettings* gpu_settings_;
  ::tflite::proto::HexagonSettings* hexagon_settings_;
  ::tflite::proto::XNNPackSettings* xnnpack_settings_;
  ::tflite::proto::CPUSettings* cpu_settings_;
  ::tflite::proto::EdgeTpuSettings* edgetpu_settings_;
  ::tflite::proto::FallbackSettings* fallback_settings_;
  ::tflite::proto::CoralSettings* coral_settings_;
  ::tflite::proto::CoreMLSettings* coreml_settings_;
  int delegate_;
  int32_t max_delegated_partitions_;
  bool disable_default_delegates_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class FallbackSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.FallbackSettings) */ {
 public:
  inline FallbackSettings() : FallbackSettings(nullptr) {}
  ~FallbackSettings() override;
  explicit PROTOBUF_CONSTEXPR FallbackSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FallbackSettings(const FallbackSettings& from);
  FallbackSettings(FallbackSettings&& from) noexcept
    : FallbackSettings() {
    *this = ::std::move(from);
  }

  inline FallbackSettings& operator=(const FallbackSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline FallbackSettings& operator=(FallbackSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FallbackSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const FallbackSettings* internal_default_instance() {
    return reinterpret_cast<const FallbackSettings*>(
               &_FallbackSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FallbackSettings& a, FallbackSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FallbackSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FallbackSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FallbackSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FallbackSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FallbackSettings& from);
  void MergeFrom(const FallbackSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FallbackSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.FallbackSettings";
  }
  protected:
  explicit FallbackSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowAutomaticFallbackOnCompilationErrorFieldNumber = 7,
    kAllowAutomaticFallbackOnExecutionErrorFieldNumber = 8,
  };
  // optional bool allow_automatic_fallback_on_compilation_error = 7;
  bool has_allow_automatic_fallback_on_compilation_error() const;
  private:
  bool _internal_has_allow_automatic_fallback_on_compilation_error() const;
  public:
  void clear_allow_automatic_fallback_on_compilation_error();
  bool allow_automatic_fallback_on_compilation_error() const;
  void set_allow_automatic_fallback_on_compilation_error(bool value);
  private:
  bool _internal_allow_automatic_fallback_on_compilation_error() const;
  void _internal_set_allow_automatic_fallback_on_compilation_error(bool value);
  public:

  // optional bool allow_automatic_fallback_on_execution_error = 8;
  bool has_allow_automatic_fallback_on_execution_error() const;
  private:
  bool _internal_has_allow_automatic_fallback_on_execution_error() const;
  public:
  void clear_allow_automatic_fallback_on_execution_error();
  bool allow_automatic_fallback_on_execution_error() const;
  void set_allow_automatic_fallback_on_execution_error(bool value);
  private:
  bool _internal_allow_automatic_fallback_on_execution_error() const;
  void _internal_set_allow_automatic_fallback_on_execution_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.FallbackSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool allow_automatic_fallback_on_compilation_error_;
  bool allow_automatic_fallback_on_execution_error_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkMetric final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BenchmarkMetric) */ {
 public:
  inline BenchmarkMetric() : BenchmarkMetric(nullptr) {}
  ~BenchmarkMetric() override;
  explicit PROTOBUF_CONSTEXPR BenchmarkMetric(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BenchmarkMetric(const BenchmarkMetric& from);
  BenchmarkMetric(BenchmarkMetric&& from) noexcept
    : BenchmarkMetric() {
    *this = ::std::move(from);
  }

  inline BenchmarkMetric& operator=(const BenchmarkMetric& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkMetric& operator=(BenchmarkMetric&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BenchmarkMetric& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkMetric* internal_default_instance() {
    return reinterpret_cast<const BenchmarkMetric*>(
               &_BenchmarkMetric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(BenchmarkMetric& a, BenchmarkMetric& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BenchmarkMetric* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkMetric* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkMetric* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BenchmarkMetric>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BenchmarkMetric& from);
  void MergeFrom(const BenchmarkMetric& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkMetric* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BenchmarkMetric";
  }
  protected:
  explicit BenchmarkMetric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValuesFieldNumber = 2,
    kNameFieldNumber = 1,
  };
  // repeated float values = 2 [packed = true];
  int values_size() const;
  private:
  int _internal_values_size() const;
  public:
  void clear_values();
  private:
  float _internal_values(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_values() const;
  void _internal_add_values(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_values();
  public:
  float values(int index) const;
  void set_values(int index, float value);
  void add_values(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      values() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_values();

  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BenchmarkMetric)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > values_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BenchmarkResult) */ {
 public:
  inline BenchmarkResult() : BenchmarkResult(nullptr) {}
  ~BenchmarkResult() override;
  explicit PROTOBUF_CONSTEXPR BenchmarkResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BenchmarkResult(const BenchmarkResult& from);
  BenchmarkResult(BenchmarkResult&& from) noexcept
    : BenchmarkResult() {
    *this = ::std::move(from);
  }

  inline BenchmarkResult& operator=(const BenchmarkResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkResult& operator=(BenchmarkResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BenchmarkResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkResult* internal_default_instance() {
    return reinterpret_cast<const BenchmarkResult*>(
               &_BenchmarkResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(BenchmarkResult& a, BenchmarkResult& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BenchmarkResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BenchmarkResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BenchmarkResult& from);
  void MergeFrom(const BenchmarkResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BenchmarkResult";
  }
  protected:
  explicit BenchmarkResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitializationTimeUsFieldNumber = 1,
    kInferenceTimeUsFieldNumber = 2,
    kMetricsFieldNumber = 5,
    kMaxMemoryKbFieldNumber = 3,
    kOkFieldNumber = 4,
  };
  // repeated int64 initialization_time_us = 1 [packed = true];
  int initialization_time_us_size() const;
  private:
  int _internal_initialization_time_us_size() const;
  public:
  void clear_initialization_time_us();
  private:
  int64_t _internal_initialization_time_us(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_initialization_time_us() const;
  void _internal_add_initialization_time_us(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_initialization_time_us();
  public:
  int64_t initialization_time_us(int index) const;
  void set_initialization_time_us(int index, int64_t value);
  void add_initialization_time_us(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      initialization_time_us() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_initialization_time_us();

  // repeated int64 inference_time_us = 2 [packed = true];
  int inference_time_us_size() const;
  private:
  int _internal_inference_time_us_size() const;
  public:
  void clear_inference_time_us();
  private:
  int64_t _internal_inference_time_us(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_inference_time_us() const;
  void _internal_add_inference_time_us(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_inference_time_us();
  public:
  int64_t inference_time_us(int index) const;
  void set_inference_time_us(int index, int64_t value);
  void add_inference_time_us(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      inference_time_us() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_inference_time_us();

  // repeated .tflite.proto.BenchmarkMetric metrics = 5;
  int metrics_size() const;
  private:
  int _internal_metrics_size() const;
  public:
  void clear_metrics();
  ::tflite::proto::BenchmarkMetric* mutable_metrics(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::BenchmarkMetric >*
      mutable_metrics();
  private:
  const ::tflite::proto::BenchmarkMetric& _internal_metrics(int index) const;
  ::tflite::proto::BenchmarkMetric* _internal_add_metrics();
  public:
  const ::tflite::proto::BenchmarkMetric& metrics(int index) const;
  ::tflite::proto::BenchmarkMetric* add_metrics();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::BenchmarkMetric >&
      metrics() const;

  // optional int32 max_memory_kb = 3;
  bool has_max_memory_kb() const;
  private:
  bool _internal_has_max_memory_kb() const;
  public:
  void clear_max_memory_kb();
  int32_t max_memory_kb() const;
  void set_max_memory_kb(int32_t value);
  private:
  int32_t _internal_max_memory_kb() const;
  void _internal_set_max_memory_kb(int32_t value);
  public:

  // optional bool ok = 4;
  bool has_ok() const;
  private:
  bool _internal_has_ok() const;
  public:
  void clear_ok();
  bool ok() const;
  void set_ok(bool value);
  private:
  bool _internal_ok() const;
  void _internal_set_ok(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BenchmarkResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > initialization_time_us_;
  mutable std::atomic<int> _initialization_time_us_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > inference_time_us_;
  mutable std::atomic<int> _inference_time_us_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::BenchmarkMetric > metrics_;
  int32_t max_memory_kb_;
  bool ok_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class ErrorCode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.ErrorCode) */ {
 public:
  inline ErrorCode() : ErrorCode(nullptr) {}
  ~ErrorCode() override;
  explicit PROTOBUF_CONSTEXPR ErrorCode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ErrorCode(const ErrorCode& from);
  ErrorCode(ErrorCode&& from) noexcept
    : ErrorCode() {
    *this = ::std::move(from);
  }

  inline ErrorCode& operator=(const ErrorCode& from) {
    CopyFrom(from);
    return *this;
  }
  inline ErrorCode& operator=(ErrorCode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ErrorCode& default_instance() {
    return *internal_default_instance();
  }
  static inline const ErrorCode* internal_default_instance() {
    return reinterpret_cast<const ErrorCode*>(
               &_ErrorCode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ErrorCode& a, ErrorCode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ErrorCode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ErrorCode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ErrorCode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ErrorCode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ErrorCode& from);
  void MergeFrom(const ErrorCode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ErrorCode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.ErrorCode";
  }
  protected:
  explicit ErrorCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kTfliteErrorFieldNumber = 2,
    kUnderlyingApiErrorFieldNumber = 3,
  };
  // optional .tflite.proto.Delegate source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  ::tflite::proto::Delegate source() const;
  void set_source(::tflite::proto::Delegate value);
  private:
  ::tflite::proto::Delegate _internal_source() const;
  void _internal_set_source(::tflite::proto::Delegate value);
  public:

  // optional int32 tflite_error = 2;
  bool has_tflite_error() const;
  private:
  bool _internal_has_tflite_error() const;
  public:
  void clear_tflite_error();
  int32_t tflite_error() const;
  void set_tflite_error(int32_t value);
  private:
  int32_t _internal_tflite_error() const;
  void _internal_set_tflite_error(int32_t value);
  public:

  // optional int64 underlying_api_error = 3;
  bool has_underlying_api_error() const;
  private:
  bool _internal_has_underlying_api_error() const;
  public:
  void clear_underlying_api_error();
  int64_t underlying_api_error() const;
  void set_underlying_api_error(int64_t value);
  private:
  int64_t _internal_underlying_api_error() const;
  void _internal_set_underlying_api_error(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.ErrorCode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int source_;
  int32_t tflite_error_;
  int64_t underlying_api_error_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkError final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BenchmarkError) */ {
 public:
  inline BenchmarkError() : BenchmarkError(nullptr) {}
  ~BenchmarkError() override;
  explicit PROTOBUF_CONSTEXPR BenchmarkError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BenchmarkError(const BenchmarkError& from);
  BenchmarkError(BenchmarkError&& from) noexcept
    : BenchmarkError() {
    *this = ::std::move(from);
  }

  inline BenchmarkError& operator=(const BenchmarkError& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkError& operator=(BenchmarkError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BenchmarkError& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkError* internal_default_instance() {
    return reinterpret_cast<const BenchmarkError*>(
               &_BenchmarkError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(BenchmarkError& a, BenchmarkError& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BenchmarkError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BenchmarkError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BenchmarkError& from);
  void MergeFrom(const BenchmarkError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BenchmarkError";
  }
  protected:
  explicit BenchmarkError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 4,
    kStageFieldNumber = 1,
    kExitCodeFieldNumber = 2,
    kSignalFieldNumber = 3,
    kMiniBenchmarkErrorCodeFieldNumber = 5,
  };
  // repeated .tflite.proto.ErrorCode error_code = 4;
  int error_code_size() const;
  private:
  int _internal_error_code_size() const;
  public:
  void clear_error_code();
  ::tflite::proto::ErrorCode* mutable_error_code(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::ErrorCode >*
      mutable_error_code();
  private:
  const ::tflite::proto::ErrorCode& _internal_error_code(int index) const;
  ::tflite::proto::ErrorCode* _internal_add_error_code();
  public:
  const ::tflite::proto::ErrorCode& error_code(int index) const;
  ::tflite::proto::ErrorCode* add_error_code();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::ErrorCode >&
      error_code() const;

  // optional .tflite.proto.BenchmarkStage stage = 1;
  bool has_stage() const;
  private:
  bool _internal_has_stage() const;
  public:
  void clear_stage();
  ::tflite::proto::BenchmarkStage stage() const;
  void set_stage(::tflite::proto::BenchmarkStage value);
  private:
  ::tflite::proto::BenchmarkStage _internal_stage() const;
  void _internal_set_stage(::tflite::proto::BenchmarkStage value);
  public:

  // optional int32 exit_code = 2;
  bool has_exit_code() const;
  private:
  bool _internal_has_exit_code() const;
  public:
  void clear_exit_code();
  int32_t exit_code() const;
  void set_exit_code(int32_t value);
  private:
  int32_t _internal_exit_code() const;
  void _internal_set_exit_code(int32_t value);
  public:

  // optional int32 signal = 3;
  bool has_signal() const;
  private:
  bool _internal_has_signal() const;
  public:
  void clear_signal();
  int32_t signal() const;
  void set_signal(int32_t value);
  private:
  int32_t _internal_signal() const;
  void _internal_set_signal(int32_t value);
  public:

  // optional int32 mini_benchmark_error_code = 5;
  bool has_mini_benchmark_error_code() const;
  private:
  bool _internal_has_mini_benchmark_error_code() const;
  public:
  void clear_mini_benchmark_error_code();
  int32_t mini_benchmark_error_code() const;
  void set_mini_benchmark_error_code(int32_t value);
  private:
  int32_t _internal_mini_benchmark_error_code() const;
  void _internal_set_mini_benchmark_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BenchmarkError)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::ErrorCode > error_code_;
  int stage_;
  int32_t exit_code_;
  int32_t signal_;
  int32_t mini_benchmark_error_code_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BenchmarkEvent) */ {
 public:
  inline BenchmarkEvent() : BenchmarkEvent(nullptr) {}
  ~BenchmarkEvent() override;
  explicit PROTOBUF_CONSTEXPR BenchmarkEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BenchmarkEvent(const BenchmarkEvent& from);
  BenchmarkEvent(BenchmarkEvent&& from) noexcept
    : BenchmarkEvent() {
    *this = ::std::move(from);
  }

  inline BenchmarkEvent& operator=(const BenchmarkEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkEvent& operator=(BenchmarkEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BenchmarkEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkEvent* internal_default_instance() {
    return reinterpret_cast<const BenchmarkEvent*>(
               &_BenchmarkEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(BenchmarkEvent& a, BenchmarkEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BenchmarkEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BenchmarkEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BenchmarkEvent& from);
  void MergeFrom(const BenchmarkEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BenchmarkEvent";
  }
  protected:
  explicit BenchmarkEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTfliteSettingsFieldNumber = 1,
    kResultFieldNumber = 3,
    kErrorFieldNumber = 4,
    kBoottimeUsFieldNumber = 5,
    kWallclockUsFieldNumber = 6,
    kEventTypeFieldNumber = 2,
  };
  // optional .tflite.proto.TFLiteSettings tflite_settings = 1;
  bool has_tflite_settings() const;
  private:
  bool _internal_has_tflite_settings() const;
  public:
  void clear_tflite_settings();
  const ::tflite::proto::TFLiteSettings& tflite_settings() const;
  PROTOBUF_NODISCARD ::tflite::proto::TFLiteSettings* release_tflite_settings();
  ::tflite::proto::TFLiteSettings* mutable_tflite_settings();
  void set_allocated_tflite_settings(::tflite::proto::TFLiteSettings* tflite_settings);
  private:
  const ::tflite::proto::TFLiteSettings& _internal_tflite_settings() const;
  ::tflite::proto::TFLiteSettings* _internal_mutable_tflite_settings();
  public:
  void unsafe_arena_set_allocated_tflite_settings(
      ::tflite::proto::TFLiteSettings* tflite_settings);
  ::tflite::proto::TFLiteSettings* unsafe_arena_release_tflite_settings();

  // optional .tflite.proto.BenchmarkResult result = 3;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::tflite::proto::BenchmarkResult& result() const;
  PROTOBUF_NODISCARD ::tflite::proto::BenchmarkResult* release_result();
  ::tflite::proto::BenchmarkResult* mutable_result();
  void set_allocated_result(::tflite::proto::BenchmarkResult* result);
  private:
  const ::tflite::proto::BenchmarkResult& _internal_result() const;
  ::tflite::proto::BenchmarkResult* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::tflite::proto::BenchmarkResult* result);
  ::tflite::proto::BenchmarkResult* unsafe_arena_release_result();

  // optional .tflite.proto.BenchmarkError error = 4;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::tflite::proto::BenchmarkError& error() const;
  PROTOBUF_NODISCARD ::tflite::proto::BenchmarkError* release_error();
  ::tflite::proto::BenchmarkError* mutable_error();
  void set_allocated_error(::tflite::proto::BenchmarkError* error);
  private:
  const ::tflite::proto::BenchmarkError& _internal_error() const;
  ::tflite::proto::BenchmarkError* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::tflite::proto::BenchmarkError* error);
  ::tflite::proto::BenchmarkError* unsafe_arena_release_error();

  // optional int64 boottime_us = 5;
  bool has_boottime_us() const;
  private:
  bool _internal_has_boottime_us() const;
  public:
  void clear_boottime_us();
  int64_t boottime_us() const;
  void set_boottime_us(int64_t value);
  private:
  int64_t _internal_boottime_us() const;
  void _internal_set_boottime_us(int64_t value);
  public:

  // optional int64 wallclock_us = 6;
  bool has_wallclock_us() const;
  private:
  bool _internal_has_wallclock_us() const;
  public:
  void clear_wallclock_us();
  int64_t wallclock_us() const;
  void set_wallclock_us(int64_t value);
  private:
  int64_t _internal_wallclock_us() const;
  void _internal_set_wallclock_us(int64_t value);
  public:

  // optional .tflite.proto.BenchmarkEventType event_type = 2;
  bool has_event_type() const;
  private:
  bool _internal_has_event_type() const;
  public:
  void clear_event_type();
  ::tflite::proto::BenchmarkEventType event_type() const;
  void set_event_type(::tflite::proto::BenchmarkEventType value);
  private:
  ::tflite::proto::BenchmarkEventType _internal_event_type() const;
  void _internal_set_event_type(::tflite::proto::BenchmarkEventType value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BenchmarkEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::tflite::proto::TFLiteSettings* tflite_settings_;
  ::tflite::proto::BenchmarkResult* result_;
  ::tflite::proto::BenchmarkError* error_;
  int64_t boottime_us_;
  int64_t wallclock_us_;
  int event_type_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BestAccelerationDecision final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BestAccelerationDecision) */ {
 public:
  inline BestAccelerationDecision() : BestAccelerationDecision(nullptr) {}
  ~BestAccelerationDecision() override;
  explicit PROTOBUF_CONSTEXPR BestAccelerationDecision(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BestAccelerationDecision(const BestAccelerationDecision& from);
  BestAccelerationDecision(BestAccelerationDecision&& from) noexcept
    : BestAccelerationDecision() {
    *this = ::std::move(from);
  }

  inline BestAccelerationDecision& operator=(const BestAccelerationDecision& from) {
    CopyFrom(from);
    return *this;
  }
  inline BestAccelerationDecision& operator=(BestAccelerationDecision&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BestAccelerationDecision& default_instance() {
    return *internal_default_instance();
  }
  static inline const BestAccelerationDecision* internal_default_instance() {
    return reinterpret_cast<const BestAccelerationDecision*>(
               &_BestAccelerationDecision_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(BestAccelerationDecision& a, BestAccelerationDecision& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BestAccelerationDecision* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BestAccelerationDecision* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BestAccelerationDecision* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BestAccelerationDecision>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BestAccelerationDecision& from);
  void MergeFrom(const BestAccelerationDecision& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BestAccelerationDecision* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BestAccelerationDecision";
  }
  protected:
  explicit BestAccelerationDecision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinLatencyEventFieldNumber = 2,
    kMinInferenceTimeUsFieldNumber = 3,
    kNumberOfSourceEventsFieldNumber = 1,
  };
  // optional .tflite.proto.BenchmarkEvent min_latency_event = 2;
  bool has_min_latency_event() const;
  private:
  bool _internal_has_min_latency_event() const;
  public:
  void clear_min_latency_event();
  const ::tflite::proto::BenchmarkEvent& min_latency_event() const;
  PROTOBUF_NODISCARD ::tflite::proto::BenchmarkEvent* release_min_latency_event();
  ::tflite::proto::BenchmarkEvent* mutable_min_latency_event();
  void set_allocated_min_latency_event(::tflite::proto::BenchmarkEvent* min_latency_event);
  private:
  const ::tflite::proto::BenchmarkEvent& _internal_min_latency_event() const;
  ::tflite::proto::BenchmarkEvent* _internal_mutable_min_latency_event();
  public:
  void unsafe_arena_set_allocated_min_latency_event(
      ::tflite::proto::BenchmarkEvent* min_latency_event);
  ::tflite::proto::BenchmarkEvent* unsafe_arena_release_min_latency_event();

  // optional int64 min_inference_time_us = 3;
  bool has_min_inference_time_us() const;
  private:
  bool _internal_has_min_inference_time_us() const;
  public:
  void clear_min_inference_time_us();
  int64_t min_inference_time_us() const;
  void set_min_inference_time_us(int64_t value);
  private:
  int64_t _internal_min_inference_time_us() const;
  void _internal_set_min_inference_time_us(int64_t value);
  public:

  // optional int32 number_of_source_events = 1;
  bool has_number_of_source_events() const;
  private:
  bool _internal_has_number_of_source_events() const;
  public:
  void clear_number_of_source_events();
  int32_t number_of_source_events() const;
  void set_number_of_source_events(int32_t value);
  private:
  int32_t _internal_number_of_source_events() const;
  void _internal_set_number_of_source_events(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BestAccelerationDecision)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::tflite::proto::BenchmarkEvent* min_latency_event_;
  int64_t min_inference_time_us_;
  int32_t number_of_source_events_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkInitializationFailure final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BenchmarkInitializationFailure) */ {
 public:
  inline BenchmarkInitializationFailure() : BenchmarkInitializationFailure(nullptr) {}
  ~BenchmarkInitializationFailure() override;
  explicit PROTOBUF_CONSTEXPR BenchmarkInitializationFailure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BenchmarkInitializationFailure(const BenchmarkInitializationFailure& from);
  BenchmarkInitializationFailure(BenchmarkInitializationFailure&& from) noexcept
    : BenchmarkInitializationFailure() {
    *this = ::std::move(from);
  }

  inline BenchmarkInitializationFailure& operator=(const BenchmarkInitializationFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkInitializationFailure& operator=(BenchmarkInitializationFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BenchmarkInitializationFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkInitializationFailure* internal_default_instance() {
    return reinterpret_cast<const BenchmarkInitializationFailure*>(
               &_BenchmarkInitializationFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(BenchmarkInitializationFailure& a, BenchmarkInitializationFailure& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BenchmarkInitializationFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkInitializationFailure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkInitializationFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BenchmarkInitializationFailure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BenchmarkInitializationFailure& from);
  void MergeFrom(const BenchmarkInitializationFailure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkInitializationFailure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BenchmarkInitializationFailure";
  }
  protected:
  explicit BenchmarkInitializationFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInitializationStatusFieldNumber = 1,
  };
  // optional int32 initialization_status = 1;
  bool has_initialization_status() const;
  private:
  bool _internal_has_initialization_status() const;
  public:
  void clear_initialization_status();
  int32_t initialization_status() const;
  void set_initialization_status(int32_t value);
  private:
  int32_t _internal_initialization_status() const;
  void _internal_set_initialization_status(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BenchmarkInitializationFailure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t initialization_status_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class MiniBenchmarkEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.MiniBenchmarkEvent) */ {
 public:
  inline MiniBenchmarkEvent() : MiniBenchmarkEvent(nullptr) {}
  ~MiniBenchmarkEvent() override;
  explicit PROTOBUF_CONSTEXPR MiniBenchmarkEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MiniBenchmarkEvent(const MiniBenchmarkEvent& from);
  MiniBenchmarkEvent(MiniBenchmarkEvent&& from) noexcept
    : MiniBenchmarkEvent() {
    *this = ::std::move(from);
  }

  inline MiniBenchmarkEvent& operator=(const MiniBenchmarkEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline MiniBenchmarkEvent& operator=(MiniBenchmarkEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MiniBenchmarkEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const MiniBenchmarkEvent* internal_default_instance() {
    return reinterpret_cast<const MiniBenchmarkEvent*>(
               &_MiniBenchmarkEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(MiniBenchmarkEvent& a, MiniBenchmarkEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MiniBenchmarkEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MiniBenchmarkEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MiniBenchmarkEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MiniBenchmarkEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MiniBenchmarkEvent& from);
  void MergeFrom(const MiniBenchmarkEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MiniBenchmarkEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.MiniBenchmarkEvent";
  }
  protected:
  explicit MiniBenchmarkEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBestAccelerationDecisionFieldNumber = 2,
    kInitializationFailureFieldNumber = 3,
    kBenchmarkEventFieldNumber = 4,
    kIsLogFlushingEventFieldNumber = 1,
  };
  // optional .tflite.proto.BestAccelerationDecision best_acceleration_decision = 2;
  bool has_best_acceleration_decision() const;
  private:
  bool _internal_has_best_acceleration_decision() const;
  public:
  void clear_best_acceleration_decision();
  const ::tflite::proto::BestAccelerationDecision& best_acceleration_decision() const;
  PROTOBUF_NODISCARD ::tflite::proto::BestAccelerationDecision* release_best_acceleration_decision();
  ::tflite::proto::BestAccelerationDecision* mutable_best_acceleration_decision();
  void set_allocated_best_acceleration_decision(::tflite::proto::BestAccelerationDecision* best_acceleration_decision);
  private:
  const ::tflite::proto::BestAccelerationDecision& _internal_best_acceleration_decision() const;
  ::tflite::proto::BestAccelerationDecision* _internal_mutable_best_acceleration_decision();
  public:
  void unsafe_arena_set_allocated_best_acceleration_decision(
      ::tflite::proto::BestAccelerationDecision* best_acceleration_decision);
  ::tflite::proto::BestAccelerationDecision* unsafe_arena_release_best_acceleration_decision();

  // optional .tflite.proto.BenchmarkInitializationFailure initialization_failure = 3;
  bool has_initialization_failure() const;
  private:
  bool _internal_has_initialization_failure() const;
  public:
  void clear_initialization_failure();
  const ::tflite::proto::BenchmarkInitializationFailure& initialization_failure() const;
  PROTOBUF_NODISCARD ::tflite::proto::BenchmarkInitializationFailure* release_initialization_failure();
  ::tflite::proto::BenchmarkInitializationFailure* mutable_initialization_failure();
  void set_allocated_initialization_failure(::tflite::proto::BenchmarkInitializationFailure* initialization_failure);
  private:
  const ::tflite::proto::BenchmarkInitializationFailure& _internal_initialization_failure() const;
  ::tflite::proto::BenchmarkInitializationFailure* _internal_mutable_initialization_failure();
  public:
  void unsafe_arena_set_allocated_initialization_failure(
      ::tflite::proto::BenchmarkInitializationFailure* initialization_failure);
  ::tflite::proto::BenchmarkInitializationFailure* unsafe_arena_release_initialization_failure();

  // optional .tflite.proto.BenchmarkEvent benchmark_event = 4;
  bool has_benchmark_event() const;
  private:
  bool _internal_has_benchmark_event() const;
  public:
  void clear_benchmark_event();
  const ::tflite::proto::BenchmarkEvent& benchmark_event() const;
  PROTOBUF_NODISCARD ::tflite::proto::BenchmarkEvent* release_benchmark_event();
  ::tflite::proto::BenchmarkEvent* mutable_benchmark_event();
  void set_allocated_benchmark_event(::tflite::proto::BenchmarkEvent* benchmark_event);
  private:
  const ::tflite::proto::BenchmarkEvent& _internal_benchmark_event() const;
  ::tflite::proto::BenchmarkEvent* _internal_mutable_benchmark_event();
  public:
  void unsafe_arena_set_allocated_benchmark_event(
      ::tflite::proto::BenchmarkEvent* benchmark_event);
  ::tflite::proto::BenchmarkEvent* unsafe_arena_release_benchmark_event();

  // optional bool is_log_flushing_event = 1;
  bool has_is_log_flushing_event() const;
  private:
  bool _internal_has_is_log_flushing_event() const;
  public:
  void clear_is_log_flushing_event();
  bool is_log_flushing_event() const;
  void set_is_log_flushing_event(bool value);
  private:
  bool _internal_is_log_flushing_event() const;
  void _internal_set_is_log_flushing_event(bool value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.MiniBenchmarkEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::tflite::proto::BestAccelerationDecision* best_acceleration_decision_;
  ::tflite::proto::BenchmarkInitializationFailure* initialization_failure_;
  ::tflite::proto::BenchmarkEvent* benchmark_event_;
  bool is_log_flushing_event_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class ModelFile final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.ModelFile) */ {
 public:
  inline ModelFile() : ModelFile(nullptr) {}
  ~ModelFile() override;
  explicit PROTOBUF_CONSTEXPR ModelFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelFile(const ModelFile& from);
  ModelFile(ModelFile&& from) noexcept
    : ModelFile() {
    *this = ::std::move(from);
  }

  inline ModelFile& operator=(const ModelFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelFile& operator=(ModelFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ModelFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelFile* internal_default_instance() {
    return reinterpret_cast<const ModelFile*>(
               &_ModelFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ModelFile& a, ModelFile& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ModelFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelFile>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelFile& from);
  void MergeFrom(const ModelFile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.ModelFile";
  }
  protected:
  explicit ModelFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kFdFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLengthFieldNumber = 4,
  };
  // optional string filename = 1;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional int64 fd = 2;
  bool has_fd() const;
  private:
  bool _internal_has_fd() const;
  public:
  void clear_fd();
  int64_t fd() const;
  void set_fd(int64_t value);
  private:
  int64_t _internal_fd() const;
  void _internal_set_fd(int64_t value);
  public:

  // optional int64 offset = 3;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // optional int64 length = 4;
  bool has_length() const;
  private:
  bool _internal_has_length() const;
  public:
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.ModelFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  int64_t fd_;
  int64_t offset_;
  int64_t length_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class BenchmarkStoragePaths final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.BenchmarkStoragePaths) */ {
 public:
  inline BenchmarkStoragePaths() : BenchmarkStoragePaths(nullptr) {}
  ~BenchmarkStoragePaths() override;
  explicit PROTOBUF_CONSTEXPR BenchmarkStoragePaths(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BenchmarkStoragePaths(const BenchmarkStoragePaths& from);
  BenchmarkStoragePaths(BenchmarkStoragePaths&& from) noexcept
    : BenchmarkStoragePaths() {
    *this = ::std::move(from);
  }

  inline BenchmarkStoragePaths& operator=(const BenchmarkStoragePaths& from) {
    CopyFrom(from);
    return *this;
  }
  inline BenchmarkStoragePaths& operator=(BenchmarkStoragePaths&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BenchmarkStoragePaths& default_instance() {
    return *internal_default_instance();
  }
  static inline const BenchmarkStoragePaths* internal_default_instance() {
    return reinterpret_cast<const BenchmarkStoragePaths*>(
               &_BenchmarkStoragePaths_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(BenchmarkStoragePaths& a, BenchmarkStoragePaths& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BenchmarkStoragePaths* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BenchmarkStoragePaths* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BenchmarkStoragePaths* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BenchmarkStoragePaths>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BenchmarkStoragePaths& from);
  void MergeFrom(const BenchmarkStoragePaths& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BenchmarkStoragePaths* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.BenchmarkStoragePaths";
  }
  protected:
  explicit BenchmarkStoragePaths(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStorageFilePathFieldNumber = 1,
    kDataDirectoryPathFieldNumber = 2,
  };
  // optional string storage_file_path = 1;
  bool has_storage_file_path() const;
  private:
  bool _internal_has_storage_file_path() const;
  public:
  void clear_storage_file_path();
  const std::string& storage_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_storage_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_storage_file_path();
  PROTOBUF_NODISCARD std::string* release_storage_file_path();
  void set_allocated_storage_file_path(std::string* storage_file_path);
  private:
  const std::string& _internal_storage_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_storage_file_path(const std::string& value);
  std::string* _internal_mutable_storage_file_path();
  public:

  // optional string data_directory_path = 2;
  bool has_data_directory_path() const;
  private:
  bool _internal_has_data_directory_path() const;
  public:
  void clear_data_directory_path();
  const std::string& data_directory_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data_directory_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data_directory_path();
  PROTOBUF_NODISCARD std::string* release_data_directory_path();
  void set_allocated_data_directory_path(std::string* data_directory_path);
  private:
  const std::string& _internal_data_directory_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data_directory_path(const std::string& value);
  std::string* _internal_mutable_data_directory_path();
  public:

  // @@protoc_insertion_point(class_scope:tflite.proto.BenchmarkStoragePaths)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr storage_file_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_directory_path_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// -------------------------------------------------------------------

class MinibenchmarkSettings final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:tflite.proto.MinibenchmarkSettings) */ {
 public:
  inline MinibenchmarkSettings() : MinibenchmarkSettings(nullptr) {}
  ~MinibenchmarkSettings() override;
  explicit PROTOBUF_CONSTEXPR MinibenchmarkSettings(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MinibenchmarkSettings(const MinibenchmarkSettings& from);
  MinibenchmarkSettings(MinibenchmarkSettings&& from) noexcept
    : MinibenchmarkSettings() {
    *this = ::std::move(from);
  }

  inline MinibenchmarkSettings& operator=(const MinibenchmarkSettings& from) {
    CopyFrom(from);
    return *this;
  }
  inline MinibenchmarkSettings& operator=(MinibenchmarkSettings&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MinibenchmarkSettings& default_instance() {
    return *internal_default_instance();
  }
  static inline const MinibenchmarkSettings* internal_default_instance() {
    return reinterpret_cast<const MinibenchmarkSettings*>(
               &_MinibenchmarkSettings_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(MinibenchmarkSettings& a, MinibenchmarkSettings& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MinibenchmarkSettings* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MinibenchmarkSettings* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MinibenchmarkSettings* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MinibenchmarkSettings>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MinibenchmarkSettings& from);
  void MergeFrom(const MinibenchmarkSettings& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MinibenchmarkSettings* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "tflite.proto.MinibenchmarkSettings";
  }
  protected:
  explicit MinibenchmarkSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSettingsToTestFieldNumber = 1,
    kModelFileFieldNumber = 2,
    kStoragePathsFieldNumber = 3,
  };
  // repeated .tflite.proto.TFLiteSettings settings_to_test = 1;
  int settings_to_test_size() const;
  private:
  int _internal_settings_to_test_size() const;
  public:
  void clear_settings_to_test();
  ::tflite::proto::TFLiteSettings* mutable_settings_to_test(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::TFLiteSettings >*
      mutable_settings_to_test();
  private:
  const ::tflite::proto::TFLiteSettings& _internal_settings_to_test(int index) const;
  ::tflite::proto::TFLiteSettings* _internal_add_settings_to_test();
  public:
  const ::tflite::proto::TFLiteSettings& settings_to_test(int index) const;
  ::tflite::proto::TFLiteSettings* add_settings_to_test();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::TFLiteSettings >&
      settings_to_test() const;

  // optional .tflite.proto.ModelFile model_file = 2;
  bool has_model_file() const;
  private:
  bool _internal_has_model_file() const;
  public:
  void clear_model_file();
  const ::tflite::proto::ModelFile& model_file() const;
  PROTOBUF_NODISCARD ::tflite::proto::ModelFile* release_model_file();
  ::tflite::proto::ModelFile* mutable_model_file();
  void set_allocated_model_file(::tflite::proto::ModelFile* model_file);
  private:
  const ::tflite::proto::ModelFile& _internal_model_file() const;
  ::tflite::proto::ModelFile* _internal_mutable_model_file();
  public:
  void unsafe_arena_set_allocated_model_file(
      ::tflite::proto::ModelFile* model_file);
  ::tflite::proto::ModelFile* unsafe_arena_release_model_file();

  // optional .tflite.proto.BenchmarkStoragePaths storage_paths = 3;
  bool has_storage_paths() const;
  private:
  bool _internal_has_storage_paths() const;
  public:
  void clear_storage_paths();
  const ::tflite::proto::BenchmarkStoragePaths& storage_paths() const;
  PROTOBUF_NODISCARD ::tflite::proto::BenchmarkStoragePaths* release_storage_paths();
  ::tflite::proto::BenchmarkStoragePaths* mutable_storage_paths();
  void set_allocated_storage_paths(::tflite::proto::BenchmarkStoragePaths* storage_paths);
  private:
  const ::tflite::proto::BenchmarkStoragePaths& _internal_storage_paths() const;
  ::tflite::proto::BenchmarkStoragePaths* _internal_mutable_storage_paths();
  public:
  void unsafe_arena_set_allocated_storage_paths(
      ::tflite::proto::BenchmarkStoragePaths* storage_paths);
  ::tflite::proto::BenchmarkStoragePaths* unsafe_arena_release_storage_paths();

  // @@protoc_insertion_point(class_scope:tflite.proto.MinibenchmarkSettings)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::TFLiteSettings > settings_to_test_;
  ::tflite::proto::ModelFile* model_file_;
  ::tflite::proto::BenchmarkStoragePaths* storage_paths_;
  friend struct ::TableStruct_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ComputeSettings

// optional .tflite.proto.ExecutionPreference preference = 1;
inline bool ComputeSettings::_internal_has_preference() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ComputeSettings::has_preference() const {
  return _internal_has_preference();
}
inline void ComputeSettings::clear_preference() {
  preference_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::tflite::proto::ExecutionPreference ComputeSettings::_internal_preference() const {
  return static_cast< ::tflite::proto::ExecutionPreference >(preference_);
}
inline ::tflite::proto::ExecutionPreference ComputeSettings::preference() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ComputeSettings.preference)
  return _internal_preference();
}
inline void ComputeSettings::_internal_set_preference(::tflite::proto::ExecutionPreference value) {
  assert(::tflite::proto::ExecutionPreference_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  preference_ = value;
}
inline void ComputeSettings::set_preference(::tflite::proto::ExecutionPreference value) {
  _internal_set_preference(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ComputeSettings.preference)
}

// optional .tflite.proto.TFLiteSettings tflite_settings = 2;
inline bool ComputeSettings::_internal_has_tflite_settings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || tflite_settings_ != nullptr);
  return value;
}
inline bool ComputeSettings::has_tflite_settings() const {
  return _internal_has_tflite_settings();
}
inline void ComputeSettings::clear_tflite_settings() {
  if (tflite_settings_ != nullptr) tflite_settings_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::tflite::proto::TFLiteSettings& ComputeSettings::_internal_tflite_settings() const {
  const ::tflite::proto::TFLiteSettings* p = tflite_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::TFLiteSettings&>(
      ::tflite::proto::_TFLiteSettings_default_instance_);
}
inline const ::tflite::proto::TFLiteSettings& ComputeSettings::tflite_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ComputeSettings.tflite_settings)
  return _internal_tflite_settings();
}
inline void ComputeSettings::unsafe_arena_set_allocated_tflite_settings(
    ::tflite::proto::TFLiteSettings* tflite_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tflite_settings_);
  }
  tflite_settings_ = tflite_settings;
  if (tflite_settings) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.ComputeSettings.tflite_settings)
}
inline ::tflite::proto::TFLiteSettings* ComputeSettings::release_tflite_settings() {
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::TFLiteSettings* temp = tflite_settings_;
  tflite_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::TFLiteSettings* ComputeSettings::unsafe_arena_release_tflite_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.ComputeSettings.tflite_settings)
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::TFLiteSettings* temp = tflite_settings_;
  tflite_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::TFLiteSettings* ComputeSettings::_internal_mutable_tflite_settings() {
  _has_bits_[0] |= 0x00000004u;
  if (tflite_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::TFLiteSettings>(GetArenaForAllocation());
    tflite_settings_ = p;
  }
  return tflite_settings_;
}
inline ::tflite::proto::TFLiteSettings* ComputeSettings::mutable_tflite_settings() {
  ::tflite::proto::TFLiteSettings* _msg = _internal_mutable_tflite_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.ComputeSettings.tflite_settings)
  return _msg;
}
inline void ComputeSettings::set_allocated_tflite_settings(::tflite::proto::TFLiteSettings* tflite_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tflite_settings_;
  }
  if (tflite_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tflite_settings);
    if (message_arena != submessage_arena) {
      tflite_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tflite_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tflite_settings_ = tflite_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.ComputeSettings.tflite_settings)
}

// optional string model_namespace_for_statistics = 3;
inline bool ComputeSettings::_internal_has_model_namespace_for_statistics() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ComputeSettings::has_model_namespace_for_statistics() const {
  return _internal_has_model_namespace_for_statistics();
}
inline void ComputeSettings::clear_model_namespace_for_statistics() {
  model_namespace_for_statistics_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ComputeSettings::model_namespace_for_statistics() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ComputeSettings.model_namespace_for_statistics)
  return _internal_model_namespace_for_statistics();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputeSettings::set_model_namespace_for_statistics(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_namespace_for_statistics_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.ComputeSettings.model_namespace_for_statistics)
}
inline std::string* ComputeSettings::mutable_model_namespace_for_statistics() {
  std::string* _s = _internal_mutable_model_namespace_for_statistics();
  // @@protoc_insertion_point(field_mutable:tflite.proto.ComputeSettings.model_namespace_for_statistics)
  return _s;
}
inline const std::string& ComputeSettings::_internal_model_namespace_for_statistics() const {
  return model_namespace_for_statistics_.Get();
}
inline void ComputeSettings::_internal_set_model_namespace_for_statistics(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_namespace_for_statistics_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputeSettings::_internal_mutable_model_namespace_for_statistics() {
  _has_bits_[0] |= 0x00000001u;
  return model_namespace_for_statistics_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputeSettings::release_model_namespace_for_statistics() {
  // @@protoc_insertion_point(field_release:tflite.proto.ComputeSettings.model_namespace_for_statistics)
  if (!_internal_has_model_namespace_for_statistics()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_namespace_for_statistics_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_namespace_for_statistics_.IsDefault()) {
    model_namespace_for_statistics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ComputeSettings::set_allocated_model_namespace_for_statistics(std::string* model_namespace_for_statistics) {
  if (model_namespace_for_statistics != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_namespace_for_statistics_.SetAllocated(model_namespace_for_statistics, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_namespace_for_statistics_.IsDefault()) {
    model_namespace_for_statistics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.ComputeSettings.model_namespace_for_statistics)
}

// optional string model_identifier_for_statistics = 4;
inline bool ComputeSettings::_internal_has_model_identifier_for_statistics() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ComputeSettings::has_model_identifier_for_statistics() const {
  return _internal_has_model_identifier_for_statistics();
}
inline void ComputeSettings::clear_model_identifier_for_statistics() {
  model_identifier_for_statistics_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ComputeSettings::model_identifier_for_statistics() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ComputeSettings.model_identifier_for_statistics)
  return _internal_model_identifier_for_statistics();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ComputeSettings::set_model_identifier_for_statistics(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 model_identifier_for_statistics_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.ComputeSettings.model_identifier_for_statistics)
}
inline std::string* ComputeSettings::mutable_model_identifier_for_statistics() {
  std::string* _s = _internal_mutable_model_identifier_for_statistics();
  // @@protoc_insertion_point(field_mutable:tflite.proto.ComputeSettings.model_identifier_for_statistics)
  return _s;
}
inline const std::string& ComputeSettings::_internal_model_identifier_for_statistics() const {
  return model_identifier_for_statistics_.Get();
}
inline void ComputeSettings::_internal_set_model_identifier_for_statistics(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_identifier_for_statistics_.Set(value, GetArenaForAllocation());
}
inline std::string* ComputeSettings::_internal_mutable_model_identifier_for_statistics() {
  _has_bits_[0] |= 0x00000002u;
  return model_identifier_for_statistics_.Mutable(GetArenaForAllocation());
}
inline std::string* ComputeSettings::release_model_identifier_for_statistics() {
  // @@protoc_insertion_point(field_release:tflite.proto.ComputeSettings.model_identifier_for_statistics)
  if (!_internal_has_model_identifier_for_statistics()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = model_identifier_for_statistics_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_for_statistics_.IsDefault()) {
    model_identifier_for_statistics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ComputeSettings::set_allocated_model_identifier_for_statistics(std::string* model_identifier_for_statistics) {
  if (model_identifier_for_statistics != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_identifier_for_statistics_.SetAllocated(model_identifier_for_statistics, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_identifier_for_statistics_.IsDefault()) {
    model_identifier_for_statistics_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.ComputeSettings.model_identifier_for_statistics)
}

// optional .tflite.proto.MinibenchmarkSettings settings_to_test_locally = 5;
inline bool ComputeSettings::_internal_has_settings_to_test_locally() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || settings_to_test_locally_ != nullptr);
  return value;
}
inline bool ComputeSettings::has_settings_to_test_locally() const {
  return _internal_has_settings_to_test_locally();
}
inline void ComputeSettings::clear_settings_to_test_locally() {
  if (settings_to_test_locally_ != nullptr) settings_to_test_locally_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::tflite::proto::MinibenchmarkSettings& ComputeSettings::_internal_settings_to_test_locally() const {
  const ::tflite::proto::MinibenchmarkSettings* p = settings_to_test_locally_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::MinibenchmarkSettings&>(
      ::tflite::proto::_MinibenchmarkSettings_default_instance_);
}
inline const ::tflite::proto::MinibenchmarkSettings& ComputeSettings::settings_to_test_locally() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ComputeSettings.settings_to_test_locally)
  return _internal_settings_to_test_locally();
}
inline void ComputeSettings::unsafe_arena_set_allocated_settings_to_test_locally(
    ::tflite::proto::MinibenchmarkSettings* settings_to_test_locally) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(settings_to_test_locally_);
  }
  settings_to_test_locally_ = settings_to_test_locally;
  if (settings_to_test_locally) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.ComputeSettings.settings_to_test_locally)
}
inline ::tflite::proto::MinibenchmarkSettings* ComputeSettings::release_settings_to_test_locally() {
  _has_bits_[0] &= ~0x00000008u;
  ::tflite::proto::MinibenchmarkSettings* temp = settings_to_test_locally_;
  settings_to_test_locally_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::MinibenchmarkSettings* ComputeSettings::unsafe_arena_release_settings_to_test_locally() {
  // @@protoc_insertion_point(field_release:tflite.proto.ComputeSettings.settings_to_test_locally)
  _has_bits_[0] &= ~0x00000008u;
  ::tflite::proto::MinibenchmarkSettings* temp = settings_to_test_locally_;
  settings_to_test_locally_ = nullptr;
  return temp;
}
inline ::tflite::proto::MinibenchmarkSettings* ComputeSettings::_internal_mutable_settings_to_test_locally() {
  _has_bits_[0] |= 0x00000008u;
  if (settings_to_test_locally_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::MinibenchmarkSettings>(GetArenaForAllocation());
    settings_to_test_locally_ = p;
  }
  return settings_to_test_locally_;
}
inline ::tflite::proto::MinibenchmarkSettings* ComputeSettings::mutable_settings_to_test_locally() {
  ::tflite::proto::MinibenchmarkSettings* _msg = _internal_mutable_settings_to_test_locally();
  // @@protoc_insertion_point(field_mutable:tflite.proto.ComputeSettings.settings_to_test_locally)
  return _msg;
}
inline void ComputeSettings::set_allocated_settings_to_test_locally(::tflite::proto::MinibenchmarkSettings* settings_to_test_locally) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete settings_to_test_locally_;
  }
  if (settings_to_test_locally) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(settings_to_test_locally);
    if (message_arena != submessage_arena) {
      settings_to_test_locally = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings_to_test_locally, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  settings_to_test_locally_ = settings_to_test_locally;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.ComputeSettings.settings_to_test_locally)
}

// -------------------------------------------------------------------

// NNAPISettings

// optional string accelerator_name = 1;
inline bool NNAPISettings::_internal_has_accelerator_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NNAPISettings::has_accelerator_name() const {
  return _internal_has_accelerator_name();
}
inline void NNAPISettings::clear_accelerator_name() {
  accelerator_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NNAPISettings::accelerator_name() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.accelerator_name)
  return _internal_accelerator_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NNAPISettings::set_accelerator_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 accelerator_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.accelerator_name)
}
inline std::string* NNAPISettings::mutable_accelerator_name() {
  std::string* _s = _internal_mutable_accelerator_name();
  // @@protoc_insertion_point(field_mutable:tflite.proto.NNAPISettings.accelerator_name)
  return _s;
}
inline const std::string& NNAPISettings::_internal_accelerator_name() const {
  return accelerator_name_.Get();
}
inline void NNAPISettings::_internal_set_accelerator_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  accelerator_name_.Set(value, GetArenaForAllocation());
}
inline std::string* NNAPISettings::_internal_mutable_accelerator_name() {
  _has_bits_[0] |= 0x00000001u;
  return accelerator_name_.Mutable(GetArenaForAllocation());
}
inline std::string* NNAPISettings::release_accelerator_name() {
  // @@protoc_insertion_point(field_release:tflite.proto.NNAPISettings.accelerator_name)
  if (!_internal_has_accelerator_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = accelerator_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (accelerator_name_.IsDefault()) {
    accelerator_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NNAPISettings::set_allocated_accelerator_name(std::string* accelerator_name) {
  if (accelerator_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  accelerator_name_.SetAllocated(accelerator_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (accelerator_name_.IsDefault()) {
    accelerator_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.NNAPISettings.accelerator_name)
}

// optional string cache_directory = 2;
inline bool NNAPISettings::_internal_has_cache_directory() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool NNAPISettings::has_cache_directory() const {
  return _internal_has_cache_directory();
}
inline void NNAPISettings::clear_cache_directory() {
  cache_directory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& NNAPISettings::cache_directory() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.cache_directory)
  return _internal_cache_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NNAPISettings::set_cache_directory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 cache_directory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.cache_directory)
}
inline std::string* NNAPISettings::mutable_cache_directory() {
  std::string* _s = _internal_mutable_cache_directory();
  // @@protoc_insertion_point(field_mutable:tflite.proto.NNAPISettings.cache_directory)
  return _s;
}
inline const std::string& NNAPISettings::_internal_cache_directory() const {
  return cache_directory_.Get();
}
inline void NNAPISettings::_internal_set_cache_directory(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  cache_directory_.Set(value, GetArenaForAllocation());
}
inline std::string* NNAPISettings::_internal_mutable_cache_directory() {
  _has_bits_[0] |= 0x00000002u;
  return cache_directory_.Mutable(GetArenaForAllocation());
}
inline std::string* NNAPISettings::release_cache_directory() {
  // @@protoc_insertion_point(field_release:tflite.proto.NNAPISettings.cache_directory)
  if (!_internal_has_cache_directory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = cache_directory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_directory_.IsDefault()) {
    cache_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NNAPISettings::set_allocated_cache_directory(std::string* cache_directory) {
  if (cache_directory != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cache_directory_.SetAllocated(cache_directory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_directory_.IsDefault()) {
    cache_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.NNAPISettings.cache_directory)
}

// optional string model_token = 3;
inline bool NNAPISettings::_internal_has_model_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool NNAPISettings::has_model_token() const {
  return _internal_has_model_token();
}
inline void NNAPISettings::clear_model_token() {
  model_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& NNAPISettings::model_token() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.model_token)
  return _internal_model_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NNAPISettings::set_model_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 model_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.model_token)
}
inline std::string* NNAPISettings::mutable_model_token() {
  std::string* _s = _internal_mutable_model_token();
  // @@protoc_insertion_point(field_mutable:tflite.proto.NNAPISettings.model_token)
  return _s;
}
inline const std::string& NNAPISettings::_internal_model_token() const {
  return model_token_.Get();
}
inline void NNAPISettings::_internal_set_model_token(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  model_token_.Set(value, GetArenaForAllocation());
}
inline std::string* NNAPISettings::_internal_mutable_model_token() {
  _has_bits_[0] |= 0x00000004u;
  return model_token_.Mutable(GetArenaForAllocation());
}
inline std::string* NNAPISettings::release_model_token() {
  // @@protoc_insertion_point(field_release:tflite.proto.NNAPISettings.model_token)
  if (!_internal_has_model_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = model_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_token_.IsDefault()) {
    model_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NNAPISettings::set_allocated_model_token(std::string* model_token) {
  if (model_token != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  model_token_.SetAllocated(model_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_token_.IsDefault()) {
    model_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.NNAPISettings.model_token)
}

// optional .tflite.proto.NNAPIExecutionPreference execution_preference = 4;
inline bool NNAPISettings::_internal_has_execution_preference() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool NNAPISettings::has_execution_preference() const {
  return _internal_has_execution_preference();
}
inline void NNAPISettings::clear_execution_preference() {
  execution_preference_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::tflite::proto::NNAPIExecutionPreference NNAPISettings::_internal_execution_preference() const {
  return static_cast< ::tflite::proto::NNAPIExecutionPreference >(execution_preference_);
}
inline ::tflite::proto::NNAPIExecutionPreference NNAPISettings::execution_preference() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.execution_preference)
  return _internal_execution_preference();
}
inline void NNAPISettings::_internal_set_execution_preference(::tflite::proto::NNAPIExecutionPreference value) {
  assert(::tflite::proto::NNAPIExecutionPreference_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  execution_preference_ = value;
}
inline void NNAPISettings::set_execution_preference(::tflite::proto::NNAPIExecutionPreference value) {
  _internal_set_execution_preference(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.execution_preference)
}

// optional int32 no_of_nnapi_instances_to_cache = 5;
inline bool NNAPISettings::_internal_has_no_of_nnapi_instances_to_cache() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool NNAPISettings::has_no_of_nnapi_instances_to_cache() const {
  return _internal_has_no_of_nnapi_instances_to_cache();
}
inline void NNAPISettings::clear_no_of_nnapi_instances_to_cache() {
  no_of_nnapi_instances_to_cache_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t NNAPISettings::_internal_no_of_nnapi_instances_to_cache() const {
  return no_of_nnapi_instances_to_cache_;
}
inline int32_t NNAPISettings::no_of_nnapi_instances_to_cache() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.no_of_nnapi_instances_to_cache)
  return _internal_no_of_nnapi_instances_to_cache();
}
inline void NNAPISettings::_internal_set_no_of_nnapi_instances_to_cache(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  no_of_nnapi_instances_to_cache_ = value;
}
inline void NNAPISettings::set_no_of_nnapi_instances_to_cache(int32_t value) {
  _internal_set_no_of_nnapi_instances_to_cache(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.no_of_nnapi_instances_to_cache)
}

// optional .tflite.proto.FallbackSettings fallback_settings = 6 [deprecated = true];
inline bool NNAPISettings::_internal_has_fallback_settings() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || fallback_settings_ != nullptr);
  return value;
}
inline bool NNAPISettings::has_fallback_settings() const {
  return _internal_has_fallback_settings();
}
inline void NNAPISettings::clear_fallback_settings() {
  if (fallback_settings_ != nullptr) fallback_settings_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::tflite::proto::FallbackSettings& NNAPISettings::_internal_fallback_settings() const {
  const ::tflite::proto::FallbackSettings* p = fallback_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::FallbackSettings&>(
      ::tflite::proto::_FallbackSettings_default_instance_);
}
inline const ::tflite::proto::FallbackSettings& NNAPISettings::fallback_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.fallback_settings)
  return _internal_fallback_settings();
}
inline void NNAPISettings::unsafe_arena_set_allocated_fallback_settings(
    ::tflite::proto::FallbackSettings* fallback_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fallback_settings_);
  }
  fallback_settings_ = fallback_settings;
  if (fallback_settings) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.NNAPISettings.fallback_settings)
}
inline ::tflite::proto::FallbackSettings* NNAPISettings::release_fallback_settings() {
  _has_bits_[0] &= ~0x00000008u;
  ::tflite::proto::FallbackSettings* temp = fallback_settings_;
  fallback_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::FallbackSettings* NNAPISettings::unsafe_arena_release_fallback_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.NNAPISettings.fallback_settings)
  _has_bits_[0] &= ~0x00000008u;
  ::tflite::proto::FallbackSettings* temp = fallback_settings_;
  fallback_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::FallbackSettings* NNAPISettings::_internal_mutable_fallback_settings() {
  _has_bits_[0] |= 0x00000008u;
  if (fallback_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::FallbackSettings>(GetArenaForAllocation());
    fallback_settings_ = p;
  }
  return fallback_settings_;
}
inline ::tflite::proto::FallbackSettings* NNAPISettings::mutable_fallback_settings() {
  ::tflite::proto::FallbackSettings* _msg = _internal_mutable_fallback_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.NNAPISettings.fallback_settings)
  return _msg;
}
inline void NNAPISettings::set_allocated_fallback_settings(::tflite::proto::FallbackSettings* fallback_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fallback_settings_;
  }
  if (fallback_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fallback_settings);
    if (message_arena != submessage_arena) {
      fallback_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fallback_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  fallback_settings_ = fallback_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.NNAPISettings.fallback_settings)
}

// optional bool allow_nnapi_cpu_on_android_10_plus = 7;
inline bool NNAPISettings::_internal_has_allow_nnapi_cpu_on_android_10_plus() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool NNAPISettings::has_allow_nnapi_cpu_on_android_10_plus() const {
  return _internal_has_allow_nnapi_cpu_on_android_10_plus();
}
inline void NNAPISettings::clear_allow_nnapi_cpu_on_android_10_plus() {
  allow_nnapi_cpu_on_android_10_plus_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool NNAPISettings::_internal_allow_nnapi_cpu_on_android_10_plus() const {
  return allow_nnapi_cpu_on_android_10_plus_;
}
inline bool NNAPISettings::allow_nnapi_cpu_on_android_10_plus() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.allow_nnapi_cpu_on_android_10_plus)
  return _internal_allow_nnapi_cpu_on_android_10_plus();
}
inline void NNAPISettings::_internal_set_allow_nnapi_cpu_on_android_10_plus(bool value) {
  _has_bits_[0] |= 0x00000080u;
  allow_nnapi_cpu_on_android_10_plus_ = value;
}
inline void NNAPISettings::set_allow_nnapi_cpu_on_android_10_plus(bool value) {
  _internal_set_allow_nnapi_cpu_on_android_10_plus(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.allow_nnapi_cpu_on_android_10_plus)
}

// optional .tflite.proto.NNAPIExecutionPriority execution_priority = 8;
inline bool NNAPISettings::_internal_has_execution_priority() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool NNAPISettings::has_execution_priority() const {
  return _internal_has_execution_priority();
}
inline void NNAPISettings::clear_execution_priority() {
  execution_priority_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::tflite::proto::NNAPIExecutionPriority NNAPISettings::_internal_execution_priority() const {
  return static_cast< ::tflite::proto::NNAPIExecutionPriority >(execution_priority_);
}
inline ::tflite::proto::NNAPIExecutionPriority NNAPISettings::execution_priority() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.execution_priority)
  return _internal_execution_priority();
}
inline void NNAPISettings::_internal_set_execution_priority(::tflite::proto::NNAPIExecutionPriority value) {
  assert(::tflite::proto::NNAPIExecutionPriority_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  execution_priority_ = value;
}
inline void NNAPISettings::set_execution_priority(::tflite::proto::NNAPIExecutionPriority value) {
  _internal_set_execution_priority(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.execution_priority)
}

// optional bool allow_dynamic_dimensions = 9;
inline bool NNAPISettings::_internal_has_allow_dynamic_dimensions() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool NNAPISettings::has_allow_dynamic_dimensions() const {
  return _internal_has_allow_dynamic_dimensions();
}
inline void NNAPISettings::clear_allow_dynamic_dimensions() {
  allow_dynamic_dimensions_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool NNAPISettings::_internal_allow_dynamic_dimensions() const {
  return allow_dynamic_dimensions_;
}
inline bool NNAPISettings::allow_dynamic_dimensions() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.allow_dynamic_dimensions)
  return _internal_allow_dynamic_dimensions();
}
inline void NNAPISettings::_internal_set_allow_dynamic_dimensions(bool value) {
  _has_bits_[0] |= 0x00000100u;
  allow_dynamic_dimensions_ = value;
}
inline void NNAPISettings::set_allow_dynamic_dimensions(bool value) {
  _internal_set_allow_dynamic_dimensions(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.allow_dynamic_dimensions)
}

// optional bool allow_fp16_precision_for_fp32 = 10;
inline bool NNAPISettings::_internal_has_allow_fp16_precision_for_fp32() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool NNAPISettings::has_allow_fp16_precision_for_fp32() const {
  return _internal_has_allow_fp16_precision_for_fp32();
}
inline void NNAPISettings::clear_allow_fp16_precision_for_fp32() {
  allow_fp16_precision_for_fp32_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool NNAPISettings::_internal_allow_fp16_precision_for_fp32() const {
  return allow_fp16_precision_for_fp32_;
}
inline bool NNAPISettings::allow_fp16_precision_for_fp32() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.allow_fp16_precision_for_fp32)
  return _internal_allow_fp16_precision_for_fp32();
}
inline void NNAPISettings::_internal_set_allow_fp16_precision_for_fp32(bool value) {
  _has_bits_[0] |= 0x00000200u;
  allow_fp16_precision_for_fp32_ = value;
}
inline void NNAPISettings::set_allow_fp16_precision_for_fp32(bool value) {
  _internal_set_allow_fp16_precision_for_fp32(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.allow_fp16_precision_for_fp32)
}

// optional bool use_burst_computation = 11;
inline bool NNAPISettings::_internal_has_use_burst_computation() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool NNAPISettings::has_use_burst_computation() const {
  return _internal_has_use_burst_computation();
}
inline void NNAPISettings::clear_use_burst_computation() {
  use_burst_computation_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool NNAPISettings::_internal_use_burst_computation() const {
  return use_burst_computation_;
}
inline bool NNAPISettings::use_burst_computation() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.use_burst_computation)
  return _internal_use_burst_computation();
}
inline void NNAPISettings::_internal_set_use_burst_computation(bool value) {
  _has_bits_[0] |= 0x00000400u;
  use_burst_computation_ = value;
}
inline void NNAPISettings::set_use_burst_computation(bool value) {
  _internal_set_use_burst_computation(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.use_burst_computation)
}

// optional int64 support_library_handle = 12;
inline bool NNAPISettings::_internal_has_support_library_handle() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool NNAPISettings::has_support_library_handle() const {
  return _internal_has_support_library_handle();
}
inline void NNAPISettings::clear_support_library_handle() {
  support_library_handle_ = int64_t{0};
  _has_bits_[0] &= ~0x00000800u;
}
inline int64_t NNAPISettings::_internal_support_library_handle() const {
  return support_library_handle_;
}
inline int64_t NNAPISettings::support_library_handle() const {
  // @@protoc_insertion_point(field_get:tflite.proto.NNAPISettings.support_library_handle)
  return _internal_support_library_handle();
}
inline void NNAPISettings::_internal_set_support_library_handle(int64_t value) {
  _has_bits_[0] |= 0x00000800u;
  support_library_handle_ = value;
}
inline void NNAPISettings::set_support_library_handle(int64_t value) {
  _internal_set_support_library_handle(value);
  // @@protoc_insertion_point(field_set:tflite.proto.NNAPISettings.support_library_handle)
}

// -------------------------------------------------------------------

// GPUSettings

// optional bool is_precision_loss_allowed = 1;
inline bool GPUSettings::_internal_has_is_precision_loss_allowed() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GPUSettings::has_is_precision_loss_allowed() const {
  return _internal_has_is_precision_loss_allowed();
}
inline void GPUSettings::clear_is_precision_loss_allowed() {
  is_precision_loss_allowed_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GPUSettings::_internal_is_precision_loss_allowed() const {
  return is_precision_loss_allowed_;
}
inline bool GPUSettings::is_precision_loss_allowed() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.is_precision_loss_allowed)
  return _internal_is_precision_loss_allowed();
}
inline void GPUSettings::_internal_set_is_precision_loss_allowed(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_precision_loss_allowed_ = value;
}
inline void GPUSettings::set_is_precision_loss_allowed(bool value) {
  _internal_set_is_precision_loss_allowed(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.is_precision_loss_allowed)
}

// optional bool enable_quantized_inference = 2 [default = true];
inline bool GPUSettings::_internal_has_enable_quantized_inference() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GPUSettings::has_enable_quantized_inference() const {
  return _internal_has_enable_quantized_inference();
}
inline void GPUSettings::clear_enable_quantized_inference() {
  enable_quantized_inference_ = true;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool GPUSettings::_internal_enable_quantized_inference() const {
  return enable_quantized_inference_;
}
inline bool GPUSettings::enable_quantized_inference() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.enable_quantized_inference)
  return _internal_enable_quantized_inference();
}
inline void GPUSettings::_internal_set_enable_quantized_inference(bool value) {
  _has_bits_[0] |= 0x00000100u;
  enable_quantized_inference_ = value;
}
inline void GPUSettings::set_enable_quantized_inference(bool value) {
  _internal_set_enable_quantized_inference(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.enable_quantized_inference)
}

// optional .tflite.proto.GPUBackend force_backend = 3;
inline bool GPUSettings::_internal_has_force_backend() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GPUSettings::has_force_backend() const {
  return _internal_has_force_backend();
}
inline void GPUSettings::clear_force_backend() {
  force_backend_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::tflite::proto::GPUBackend GPUSettings::_internal_force_backend() const {
  return static_cast< ::tflite::proto::GPUBackend >(force_backend_);
}
inline ::tflite::proto::GPUBackend GPUSettings::force_backend() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.force_backend)
  return _internal_force_backend();
}
inline void GPUSettings::_internal_set_force_backend(::tflite::proto::GPUBackend value) {
  assert(::tflite::proto::GPUBackend_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  force_backend_ = value;
}
inline void GPUSettings::set_force_backend(::tflite::proto::GPUBackend value) {
  _internal_set_force_backend(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.force_backend)
}

// optional .tflite.proto.GPUInferencePriority inference_priority1 = 4 [default = GPU_PRIORITY_AUTO];
inline bool GPUSettings::_internal_has_inference_priority1() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GPUSettings::has_inference_priority1() const {
  return _internal_has_inference_priority1();
}
inline void GPUSettings::clear_inference_priority1() {
  inference_priority1_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::tflite::proto::GPUInferencePriority GPUSettings::_internal_inference_priority1() const {
  return static_cast< ::tflite::proto::GPUInferencePriority >(inference_priority1_);
}
inline ::tflite::proto::GPUInferencePriority GPUSettings::inference_priority1() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.inference_priority1)
  return _internal_inference_priority1();
}
inline void GPUSettings::_internal_set_inference_priority1(::tflite::proto::GPUInferencePriority value) {
  assert(::tflite::proto::GPUInferencePriority_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  inference_priority1_ = value;
}
inline void GPUSettings::set_inference_priority1(::tflite::proto::GPUInferencePriority value) {
  _internal_set_inference_priority1(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.inference_priority1)
}

// optional .tflite.proto.GPUInferencePriority inference_priority2 = 5 [default = GPU_PRIORITY_AUTO];
inline bool GPUSettings::_internal_has_inference_priority2() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GPUSettings::has_inference_priority2() const {
  return _internal_has_inference_priority2();
}
inline void GPUSettings::clear_inference_priority2() {
  inference_priority2_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::tflite::proto::GPUInferencePriority GPUSettings::_internal_inference_priority2() const {
  return static_cast< ::tflite::proto::GPUInferencePriority >(inference_priority2_);
}
inline ::tflite::proto::GPUInferencePriority GPUSettings::inference_priority2() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.inference_priority2)
  return _internal_inference_priority2();
}
inline void GPUSettings::_internal_set_inference_priority2(::tflite::proto::GPUInferencePriority value) {
  assert(::tflite::proto::GPUInferencePriority_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  inference_priority2_ = value;
}
inline void GPUSettings::set_inference_priority2(::tflite::proto::GPUInferencePriority value) {
  _internal_set_inference_priority2(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.inference_priority2)
}

// optional .tflite.proto.GPUInferencePriority inference_priority3 = 6 [default = GPU_PRIORITY_AUTO];
inline bool GPUSettings::_internal_has_inference_priority3() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GPUSettings::has_inference_priority3() const {
  return _internal_has_inference_priority3();
}
inline void GPUSettings::clear_inference_priority3() {
  inference_priority3_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::tflite::proto::GPUInferencePriority GPUSettings::_internal_inference_priority3() const {
  return static_cast< ::tflite::proto::GPUInferencePriority >(inference_priority3_);
}
inline ::tflite::proto::GPUInferencePriority GPUSettings::inference_priority3() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.inference_priority3)
  return _internal_inference_priority3();
}
inline void GPUSettings::_internal_set_inference_priority3(::tflite::proto::GPUInferencePriority value) {
  assert(::tflite::proto::GPUInferencePriority_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  inference_priority3_ = value;
}
inline void GPUSettings::set_inference_priority3(::tflite::proto::GPUInferencePriority value) {
  _internal_set_inference_priority3(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.inference_priority3)
}

// optional .tflite.proto.GPUInferenceUsage inference_preference = 7;
inline bool GPUSettings::_internal_has_inference_preference() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GPUSettings::has_inference_preference() const {
  return _internal_has_inference_preference();
}
inline void GPUSettings::clear_inference_preference() {
  inference_preference_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::tflite::proto::GPUInferenceUsage GPUSettings::_internal_inference_preference() const {
  return static_cast< ::tflite::proto::GPUInferenceUsage >(inference_preference_);
}
inline ::tflite::proto::GPUInferenceUsage GPUSettings::inference_preference() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.inference_preference)
  return _internal_inference_preference();
}
inline void GPUSettings::_internal_set_inference_preference(::tflite::proto::GPUInferenceUsage value) {
  assert(::tflite::proto::GPUInferenceUsage_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  inference_preference_ = value;
}
inline void GPUSettings::set_inference_preference(::tflite::proto::GPUInferenceUsage value) {
  _internal_set_inference_preference(value);
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.inference_preference)
}

// optional string cache_directory = 8;
inline bool GPUSettings::_internal_has_cache_directory() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GPUSettings::has_cache_directory() const {
  return _internal_has_cache_directory();
}
inline void GPUSettings::clear_cache_directory() {
  cache_directory_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GPUSettings::cache_directory() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.cache_directory)
  return _internal_cache_directory();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GPUSettings::set_cache_directory(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cache_directory_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.cache_directory)
}
inline std::string* GPUSettings::mutable_cache_directory() {
  std::string* _s = _internal_mutable_cache_directory();
  // @@protoc_insertion_point(field_mutable:tflite.proto.GPUSettings.cache_directory)
  return _s;
}
inline const std::string& GPUSettings::_internal_cache_directory() const {
  return cache_directory_.Get();
}
inline void GPUSettings::_internal_set_cache_directory(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cache_directory_.Set(value, GetArenaForAllocation());
}
inline std::string* GPUSettings::_internal_mutable_cache_directory() {
  _has_bits_[0] |= 0x00000001u;
  return cache_directory_.Mutable(GetArenaForAllocation());
}
inline std::string* GPUSettings::release_cache_directory() {
  // @@protoc_insertion_point(field_release:tflite.proto.GPUSettings.cache_directory)
  if (!_internal_has_cache_directory()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cache_directory_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_directory_.IsDefault()) {
    cache_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GPUSettings::set_allocated_cache_directory(std::string* cache_directory) {
  if (cache_directory != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cache_directory_.SetAllocated(cache_directory, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_directory_.IsDefault()) {
    cache_directory_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.GPUSettings.cache_directory)
}

// optional string model_token = 9;
inline bool GPUSettings::_internal_has_model_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GPUSettings::has_model_token() const {
  return _internal_has_model_token();
}
inline void GPUSettings::clear_model_token() {
  model_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GPUSettings::model_token() const {
  // @@protoc_insertion_point(field_get:tflite.proto.GPUSettings.model_token)
  return _internal_model_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GPUSettings::set_model_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 model_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.GPUSettings.model_token)
}
inline std::string* GPUSettings::mutable_model_token() {
  std::string* _s = _internal_mutable_model_token();
  // @@protoc_insertion_point(field_mutable:tflite.proto.GPUSettings.model_token)
  return _s;
}
inline const std::string& GPUSettings::_internal_model_token() const {
  return model_token_.Get();
}
inline void GPUSettings::_internal_set_model_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  model_token_.Set(value, GetArenaForAllocation());
}
inline std::string* GPUSettings::_internal_mutable_model_token() {
  _has_bits_[0] |= 0x00000002u;
  return model_token_.Mutable(GetArenaForAllocation());
}
inline std::string* GPUSettings::release_model_token() {
  // @@protoc_insertion_point(field_release:tflite.proto.GPUSettings.model_token)
  if (!_internal_has_model_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = model_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_token_.IsDefault()) {
    model_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GPUSettings::set_allocated_model_token(std::string* model_token) {
  if (model_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_token_.SetAllocated(model_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_token_.IsDefault()) {
    model_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.GPUSettings.model_token)
}

// -------------------------------------------------------------------

// HexagonSettings

// optional int32 debug_level = 1;
inline bool HexagonSettings::_internal_has_debug_level() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HexagonSettings::has_debug_level() const {
  return _internal_has_debug_level();
}
inline void HexagonSettings::clear_debug_level() {
  debug_level_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t HexagonSettings::_internal_debug_level() const {
  return debug_level_;
}
inline int32_t HexagonSettings::debug_level() const {
  // @@protoc_insertion_point(field_get:tflite.proto.HexagonSettings.debug_level)
  return _internal_debug_level();
}
inline void HexagonSettings::_internal_set_debug_level(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  debug_level_ = value;
}
inline void HexagonSettings::set_debug_level(int32_t value) {
  _internal_set_debug_level(value);
  // @@protoc_insertion_point(field_set:tflite.proto.HexagonSettings.debug_level)
}

// optional int32 powersave_level = 2;
inline bool HexagonSettings::_internal_has_powersave_level() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HexagonSettings::has_powersave_level() const {
  return _internal_has_powersave_level();
}
inline void HexagonSettings::clear_powersave_level() {
  powersave_level_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t HexagonSettings::_internal_powersave_level() const {
  return powersave_level_;
}
inline int32_t HexagonSettings::powersave_level() const {
  // @@protoc_insertion_point(field_get:tflite.proto.HexagonSettings.powersave_level)
  return _internal_powersave_level();
}
inline void HexagonSettings::_internal_set_powersave_level(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  powersave_level_ = value;
}
inline void HexagonSettings::set_powersave_level(int32_t value) {
  _internal_set_powersave_level(value);
  // @@protoc_insertion_point(field_set:tflite.proto.HexagonSettings.powersave_level)
}

// optional bool print_graph_profile = 3;
inline bool HexagonSettings::_internal_has_print_graph_profile() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool HexagonSettings::has_print_graph_profile() const {
  return _internal_has_print_graph_profile();
}
inline void HexagonSettings::clear_print_graph_profile() {
  print_graph_profile_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool HexagonSettings::_internal_print_graph_profile() const {
  return print_graph_profile_;
}
inline bool HexagonSettings::print_graph_profile() const {
  // @@protoc_insertion_point(field_get:tflite.proto.HexagonSettings.print_graph_profile)
  return _internal_print_graph_profile();
}
inline void HexagonSettings::_internal_set_print_graph_profile(bool value) {
  _has_bits_[0] |= 0x00000004u;
  print_graph_profile_ = value;
}
inline void HexagonSettings::set_print_graph_profile(bool value) {
  _internal_set_print_graph_profile(value);
  // @@protoc_insertion_point(field_set:tflite.proto.HexagonSettings.print_graph_profile)
}

// optional bool print_graph_debug = 4;
inline bool HexagonSettings::_internal_has_print_graph_debug() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool HexagonSettings::has_print_graph_debug() const {
  return _internal_has_print_graph_debug();
}
inline void HexagonSettings::clear_print_graph_debug() {
  print_graph_debug_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool HexagonSettings::_internal_print_graph_debug() const {
  return print_graph_debug_;
}
inline bool HexagonSettings::print_graph_debug() const {
  // @@protoc_insertion_point(field_get:tflite.proto.HexagonSettings.print_graph_debug)
  return _internal_print_graph_debug();
}
inline void HexagonSettings::_internal_set_print_graph_debug(bool value) {
  _has_bits_[0] |= 0x00000008u;
  print_graph_debug_ = value;
}
inline void HexagonSettings::set_print_graph_debug(bool value) {
  _internal_set_print_graph_debug(value);
  // @@protoc_insertion_point(field_set:tflite.proto.HexagonSettings.print_graph_debug)
}

// -------------------------------------------------------------------

// XNNPackSettings

// optional int32 num_threads = 1;
inline bool XNNPackSettings::_internal_has_num_threads() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool XNNPackSettings::has_num_threads() const {
  return _internal_has_num_threads();
}
inline void XNNPackSettings::clear_num_threads() {
  num_threads_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t XNNPackSettings::_internal_num_threads() const {
  return num_threads_;
}
inline int32_t XNNPackSettings::num_threads() const {
  // @@protoc_insertion_point(field_get:tflite.proto.XNNPackSettings.num_threads)
  return _internal_num_threads();
}
inline void XNNPackSettings::_internal_set_num_threads(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  num_threads_ = value;
}
inline void XNNPackSettings::set_num_threads(int32_t value) {
  _internal_set_num_threads(value);
  // @@protoc_insertion_point(field_set:tflite.proto.XNNPackSettings.num_threads)
}

// optional .tflite.proto.XNNPackFlags flags = 2 [default = TFLITE_XNNPACK_DELEGATE_NO_FLAGS];
inline bool XNNPackSettings::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool XNNPackSettings::has_flags() const {
  return _internal_has_flags();
}
inline void XNNPackSettings::clear_flags() {
  flags_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::tflite::proto::XNNPackFlags XNNPackSettings::_internal_flags() const {
  return static_cast< ::tflite::proto::XNNPackFlags >(flags_);
}
inline ::tflite::proto::XNNPackFlags XNNPackSettings::flags() const {
  // @@protoc_insertion_point(field_get:tflite.proto.XNNPackSettings.flags)
  return _internal_flags();
}
inline void XNNPackSettings::_internal_set_flags(::tflite::proto::XNNPackFlags value) {
  assert(::tflite::proto::XNNPackFlags_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  flags_ = value;
}
inline void XNNPackSettings::set_flags(::tflite::proto::XNNPackFlags value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:tflite.proto.XNNPackSettings.flags)
}

// -------------------------------------------------------------------

// CoreMLSettings

// optional .tflite.proto.CoreMLSettings.EnabledDevices enabled_devices = 1;
inline bool CoreMLSettings::_internal_has_enabled_devices() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CoreMLSettings::has_enabled_devices() const {
  return _internal_has_enabled_devices();
}
inline void CoreMLSettings::clear_enabled_devices() {
  enabled_devices_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::tflite::proto::CoreMLSettings_EnabledDevices CoreMLSettings::_internal_enabled_devices() const {
  return static_cast< ::tflite::proto::CoreMLSettings_EnabledDevices >(enabled_devices_);
}
inline ::tflite::proto::CoreMLSettings_EnabledDevices CoreMLSettings::enabled_devices() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoreMLSettings.enabled_devices)
  return _internal_enabled_devices();
}
inline void CoreMLSettings::_internal_set_enabled_devices(::tflite::proto::CoreMLSettings_EnabledDevices value) {
  assert(::tflite::proto::CoreMLSettings_EnabledDevices_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  enabled_devices_ = value;
}
inline void CoreMLSettings::set_enabled_devices(::tflite::proto::CoreMLSettings_EnabledDevices value) {
  _internal_set_enabled_devices(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoreMLSettings.enabled_devices)
}

// optional int32 coreml_version = 2;
inline bool CoreMLSettings::_internal_has_coreml_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CoreMLSettings::has_coreml_version() const {
  return _internal_has_coreml_version();
}
inline void CoreMLSettings::clear_coreml_version() {
  coreml_version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CoreMLSettings::_internal_coreml_version() const {
  return coreml_version_;
}
inline int32_t CoreMLSettings::coreml_version() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoreMLSettings.coreml_version)
  return _internal_coreml_version();
}
inline void CoreMLSettings::_internal_set_coreml_version(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  coreml_version_ = value;
}
inline void CoreMLSettings::set_coreml_version(int32_t value) {
  _internal_set_coreml_version(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoreMLSettings.coreml_version)
}

// optional int32 max_delegated_partitions = 3 [default = 0];
inline bool CoreMLSettings::_internal_has_max_delegated_partitions() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CoreMLSettings::has_max_delegated_partitions() const {
  return _internal_has_max_delegated_partitions();
}
inline void CoreMLSettings::clear_max_delegated_partitions() {
  max_delegated_partitions_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CoreMLSettings::_internal_max_delegated_partitions() const {
  return max_delegated_partitions_;
}
inline int32_t CoreMLSettings::max_delegated_partitions() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoreMLSettings.max_delegated_partitions)
  return _internal_max_delegated_partitions();
}
inline void CoreMLSettings::_internal_set_max_delegated_partitions(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  max_delegated_partitions_ = value;
}
inline void CoreMLSettings::set_max_delegated_partitions(int32_t value) {
  _internal_set_max_delegated_partitions(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoreMLSettings.max_delegated_partitions)
}

// optional int32 min_nodes_per_partition = 4 [default = 2];
inline bool CoreMLSettings::_internal_has_min_nodes_per_partition() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CoreMLSettings::has_min_nodes_per_partition() const {
  return _internal_has_min_nodes_per_partition();
}
inline void CoreMLSettings::clear_min_nodes_per_partition() {
  min_nodes_per_partition_ = 2;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CoreMLSettings::_internal_min_nodes_per_partition() const {
  return min_nodes_per_partition_;
}
inline int32_t CoreMLSettings::min_nodes_per_partition() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoreMLSettings.min_nodes_per_partition)
  return _internal_min_nodes_per_partition();
}
inline void CoreMLSettings::_internal_set_min_nodes_per_partition(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  min_nodes_per_partition_ = value;
}
inline void CoreMLSettings::set_min_nodes_per_partition(int32_t value) {
  _internal_set_min_nodes_per_partition(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoreMLSettings.min_nodes_per_partition)
}

// -------------------------------------------------------------------

// EdgeTpuDeviceSpec

// optional .tflite.proto.EdgeTpuDeviceSpec.PlatformType platform_type = 1;
inline bool EdgeTpuDeviceSpec::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EdgeTpuDeviceSpec::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void EdgeTpuDeviceSpec::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::tflite::proto::EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::_internal_platform_type() const {
  return static_cast< ::tflite::proto::EdgeTpuDeviceSpec_PlatformType >(platform_type_);
}
inline ::tflite::proto::EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::platform_type() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuDeviceSpec.platform_type)
  return _internal_platform_type();
}
inline void EdgeTpuDeviceSpec::_internal_set_platform_type(::tflite::proto::EdgeTpuDeviceSpec_PlatformType value) {
  assert(::tflite::proto::EdgeTpuDeviceSpec_PlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  platform_type_ = value;
}
inline void EdgeTpuDeviceSpec::set_platform_type(::tflite::proto::EdgeTpuDeviceSpec_PlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuDeviceSpec.platform_type)
}

// optional int32 num_chips = 2;
inline bool EdgeTpuDeviceSpec::_internal_has_num_chips() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EdgeTpuDeviceSpec::has_num_chips() const {
  return _internal_has_num_chips();
}
inline void EdgeTpuDeviceSpec::clear_num_chips() {
  num_chips_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t EdgeTpuDeviceSpec::_internal_num_chips() const {
  return num_chips_;
}
inline int32_t EdgeTpuDeviceSpec::num_chips() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuDeviceSpec.num_chips)
  return _internal_num_chips();
}
inline void EdgeTpuDeviceSpec::_internal_set_num_chips(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  num_chips_ = value;
}
inline void EdgeTpuDeviceSpec::set_num_chips(int32_t value) {
  _internal_set_num_chips(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuDeviceSpec.num_chips)
}

// repeated string device_paths = 3;
inline int EdgeTpuDeviceSpec::_internal_device_paths_size() const {
  return device_paths_.size();
}
inline int EdgeTpuDeviceSpec::device_paths_size() const {
  return _internal_device_paths_size();
}
inline void EdgeTpuDeviceSpec::clear_device_paths() {
  device_paths_.Clear();
}
inline std::string* EdgeTpuDeviceSpec::add_device_paths() {
  std::string* _s = _internal_add_device_paths();
  // @@protoc_insertion_point(field_add_mutable:tflite.proto.EdgeTpuDeviceSpec.device_paths)
  return _s;
}
inline const std::string& EdgeTpuDeviceSpec::_internal_device_paths(int index) const {
  return device_paths_.Get(index);
}
inline const std::string& EdgeTpuDeviceSpec::device_paths(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuDeviceSpec.device_paths)
  return _internal_device_paths(index);
}
inline std::string* EdgeTpuDeviceSpec::mutable_device_paths(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.proto.EdgeTpuDeviceSpec.device_paths)
  return device_paths_.Mutable(index);
}
inline void EdgeTpuDeviceSpec::set_device_paths(int index, const std::string& value) {
  device_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline void EdgeTpuDeviceSpec::set_device_paths(int index, std::string&& value) {
  device_paths_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline void EdgeTpuDeviceSpec::set_device_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline void EdgeTpuDeviceSpec::set_device_paths(int index, const char* value, size_t size) {
  device_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline std::string* EdgeTpuDeviceSpec::_internal_add_device_paths() {
  return device_paths_.Add();
}
inline void EdgeTpuDeviceSpec::add_device_paths(const std::string& value) {
  device_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline void EdgeTpuDeviceSpec::add_device_paths(std::string&& value) {
  device_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline void EdgeTpuDeviceSpec::add_device_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline void EdgeTpuDeviceSpec::add_device_paths(const char* value, size_t size) {
  device_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tflite.proto.EdgeTpuDeviceSpec.device_paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
EdgeTpuDeviceSpec::device_paths() const {
  // @@protoc_insertion_point(field_list:tflite.proto.EdgeTpuDeviceSpec.device_paths)
  return device_paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
EdgeTpuDeviceSpec::mutable_device_paths() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.EdgeTpuDeviceSpec.device_paths)
  return &device_paths_;
}

// optional int32 chip_family = 4;
inline bool EdgeTpuDeviceSpec::_internal_has_chip_family() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EdgeTpuDeviceSpec::has_chip_family() const {
  return _internal_has_chip_family();
}
inline void EdgeTpuDeviceSpec::clear_chip_family() {
  chip_family_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t EdgeTpuDeviceSpec::_internal_chip_family() const {
  return chip_family_;
}
inline int32_t EdgeTpuDeviceSpec::chip_family() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuDeviceSpec.chip_family)
  return _internal_chip_family();
}
inline void EdgeTpuDeviceSpec::_internal_set_chip_family(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  chip_family_ = value;
}
inline void EdgeTpuDeviceSpec::set_chip_family(int32_t value) {
  _internal_set_chip_family(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuDeviceSpec.chip_family)
}

// -------------------------------------------------------------------

// EdgeTpuInactivePowerConfig

// optional .tflite.proto.EdgeTpuPowerState inactive_power_state = 1;
inline bool EdgeTpuInactivePowerConfig::_internal_has_inactive_power_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool EdgeTpuInactivePowerConfig::has_inactive_power_state() const {
  return _internal_has_inactive_power_state();
}
inline void EdgeTpuInactivePowerConfig::clear_inactive_power_state() {
  inactive_power_state_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::tflite::proto::EdgeTpuPowerState EdgeTpuInactivePowerConfig::_internal_inactive_power_state() const {
  return static_cast< ::tflite::proto::EdgeTpuPowerState >(inactive_power_state_);
}
inline ::tflite::proto::EdgeTpuPowerState EdgeTpuInactivePowerConfig::inactive_power_state() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuInactivePowerConfig.inactive_power_state)
  return _internal_inactive_power_state();
}
inline void EdgeTpuInactivePowerConfig::_internal_set_inactive_power_state(::tflite::proto::EdgeTpuPowerState value) {
  assert(::tflite::proto::EdgeTpuPowerState_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  inactive_power_state_ = value;
}
inline void EdgeTpuInactivePowerConfig::set_inactive_power_state(::tflite::proto::EdgeTpuPowerState value) {
  _internal_set_inactive_power_state(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuInactivePowerConfig.inactive_power_state)
}

// optional int64 inactive_timeout_us = 2;
inline bool EdgeTpuInactivePowerConfig::_internal_has_inactive_timeout_us() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EdgeTpuInactivePowerConfig::has_inactive_timeout_us() const {
  return _internal_has_inactive_timeout_us();
}
inline void EdgeTpuInactivePowerConfig::clear_inactive_timeout_us() {
  inactive_timeout_us_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t EdgeTpuInactivePowerConfig::_internal_inactive_timeout_us() const {
  return inactive_timeout_us_;
}
inline int64_t EdgeTpuInactivePowerConfig::inactive_timeout_us() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuInactivePowerConfig.inactive_timeout_us)
  return _internal_inactive_timeout_us();
}
inline void EdgeTpuInactivePowerConfig::_internal_set_inactive_timeout_us(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  inactive_timeout_us_ = value;
}
inline void EdgeTpuInactivePowerConfig::set_inactive_timeout_us(int64_t value) {
  _internal_set_inactive_timeout_us(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuInactivePowerConfig.inactive_timeout_us)
}

// -------------------------------------------------------------------

// EdgeTpuSettings

// optional .tflite.proto.EdgeTpuPowerState inference_power_state = 1;
inline bool EdgeTpuSettings::_internal_has_inference_power_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool EdgeTpuSettings::has_inference_power_state() const {
  return _internal_has_inference_power_state();
}
inline void EdgeTpuSettings::clear_inference_power_state() {
  inference_power_state_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::tflite::proto::EdgeTpuPowerState EdgeTpuSettings::_internal_inference_power_state() const {
  return static_cast< ::tflite::proto::EdgeTpuPowerState >(inference_power_state_);
}
inline ::tflite::proto::EdgeTpuPowerState EdgeTpuSettings::inference_power_state() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.inference_power_state)
  return _internal_inference_power_state();
}
inline void EdgeTpuSettings::_internal_set_inference_power_state(::tflite::proto::EdgeTpuPowerState value) {
  assert(::tflite::proto::EdgeTpuPowerState_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  inference_power_state_ = value;
}
inline void EdgeTpuSettings::set_inference_power_state(::tflite::proto::EdgeTpuPowerState value) {
  _internal_set_inference_power_state(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuSettings.inference_power_state)
}

// repeated .tflite.proto.EdgeTpuInactivePowerConfig inactive_power_configs = 2;
inline int EdgeTpuSettings::_internal_inactive_power_configs_size() const {
  return inactive_power_configs_.size();
}
inline int EdgeTpuSettings::inactive_power_configs_size() const {
  return _internal_inactive_power_configs_size();
}
inline void EdgeTpuSettings::clear_inactive_power_configs() {
  inactive_power_configs_.Clear();
}
inline ::tflite::proto::EdgeTpuInactivePowerConfig* EdgeTpuSettings::mutable_inactive_power_configs(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.proto.EdgeTpuSettings.inactive_power_configs)
  return inactive_power_configs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::EdgeTpuInactivePowerConfig >*
EdgeTpuSettings::mutable_inactive_power_configs() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.EdgeTpuSettings.inactive_power_configs)
  return &inactive_power_configs_;
}
inline const ::tflite::proto::EdgeTpuInactivePowerConfig& EdgeTpuSettings::_internal_inactive_power_configs(int index) const {
  return inactive_power_configs_.Get(index);
}
inline const ::tflite::proto::EdgeTpuInactivePowerConfig& EdgeTpuSettings::inactive_power_configs(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.inactive_power_configs)
  return _internal_inactive_power_configs(index);
}
inline ::tflite::proto::EdgeTpuInactivePowerConfig* EdgeTpuSettings::_internal_add_inactive_power_configs() {
  return inactive_power_configs_.Add();
}
inline ::tflite::proto::EdgeTpuInactivePowerConfig* EdgeTpuSettings::add_inactive_power_configs() {
  ::tflite::proto::EdgeTpuInactivePowerConfig* _add = _internal_add_inactive_power_configs();
  // @@protoc_insertion_point(field_add:tflite.proto.EdgeTpuSettings.inactive_power_configs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::EdgeTpuInactivePowerConfig >&
EdgeTpuSettings::inactive_power_configs() const {
  // @@protoc_insertion_point(field_list:tflite.proto.EdgeTpuSettings.inactive_power_configs)
  return inactive_power_configs_;
}

// optional int32 inference_priority = 3 [default = -1];
inline bool EdgeTpuSettings::_internal_has_inference_priority() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool EdgeTpuSettings::has_inference_priority() const {
  return _internal_has_inference_priority();
}
inline void EdgeTpuSettings::clear_inference_priority() {
  inference_priority_ = -1;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t EdgeTpuSettings::_internal_inference_priority() const {
  return inference_priority_;
}
inline int32_t EdgeTpuSettings::inference_priority() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.inference_priority)
  return _internal_inference_priority();
}
inline void EdgeTpuSettings::_internal_set_inference_priority(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  inference_priority_ = value;
}
inline void EdgeTpuSettings::set_inference_priority(int32_t value) {
  _internal_set_inference_priority(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuSettings.inference_priority)
}

// optional .tflite.proto.EdgeTpuDeviceSpec edgetpu_device_spec = 4;
inline bool EdgeTpuSettings::_internal_has_edgetpu_device_spec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || edgetpu_device_spec_ != nullptr);
  return value;
}
inline bool EdgeTpuSettings::has_edgetpu_device_spec() const {
  return _internal_has_edgetpu_device_spec();
}
inline void EdgeTpuSettings::clear_edgetpu_device_spec() {
  if (edgetpu_device_spec_ != nullptr) edgetpu_device_spec_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::tflite::proto::EdgeTpuDeviceSpec& EdgeTpuSettings::_internal_edgetpu_device_spec() const {
  const ::tflite::proto::EdgeTpuDeviceSpec* p = edgetpu_device_spec_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::EdgeTpuDeviceSpec&>(
      ::tflite::proto::_EdgeTpuDeviceSpec_default_instance_);
}
inline const ::tflite::proto::EdgeTpuDeviceSpec& EdgeTpuSettings::edgetpu_device_spec() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.edgetpu_device_spec)
  return _internal_edgetpu_device_spec();
}
inline void EdgeTpuSettings::unsafe_arena_set_allocated_edgetpu_device_spec(
    ::tflite::proto::EdgeTpuDeviceSpec* edgetpu_device_spec) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edgetpu_device_spec_);
  }
  edgetpu_device_spec_ = edgetpu_device_spec;
  if (edgetpu_device_spec) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.EdgeTpuSettings.edgetpu_device_spec)
}
inline ::tflite::proto::EdgeTpuDeviceSpec* EdgeTpuSettings::release_edgetpu_device_spec() {
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::EdgeTpuDeviceSpec* temp = edgetpu_device_spec_;
  edgetpu_device_spec_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::EdgeTpuDeviceSpec* EdgeTpuSettings::unsafe_arena_release_edgetpu_device_spec() {
  // @@protoc_insertion_point(field_release:tflite.proto.EdgeTpuSettings.edgetpu_device_spec)
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::EdgeTpuDeviceSpec* temp = edgetpu_device_spec_;
  edgetpu_device_spec_ = nullptr;
  return temp;
}
inline ::tflite::proto::EdgeTpuDeviceSpec* EdgeTpuSettings::_internal_mutable_edgetpu_device_spec() {
  _has_bits_[0] |= 0x00000002u;
  if (edgetpu_device_spec_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::EdgeTpuDeviceSpec>(GetArenaForAllocation());
    edgetpu_device_spec_ = p;
  }
  return edgetpu_device_spec_;
}
inline ::tflite::proto::EdgeTpuDeviceSpec* EdgeTpuSettings::mutable_edgetpu_device_spec() {
  ::tflite::proto::EdgeTpuDeviceSpec* _msg = _internal_mutable_edgetpu_device_spec();
  // @@protoc_insertion_point(field_mutable:tflite.proto.EdgeTpuSettings.edgetpu_device_spec)
  return _msg;
}
inline void EdgeTpuSettings::set_allocated_edgetpu_device_spec(::tflite::proto::EdgeTpuDeviceSpec* edgetpu_device_spec) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edgetpu_device_spec_;
  }
  if (edgetpu_device_spec) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edgetpu_device_spec);
    if (message_arena != submessage_arena) {
      edgetpu_device_spec = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edgetpu_device_spec, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  edgetpu_device_spec_ = edgetpu_device_spec;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.EdgeTpuSettings.edgetpu_device_spec)
}

// optional string model_token = 5;
inline bool EdgeTpuSettings::_internal_has_model_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool EdgeTpuSettings::has_model_token() const {
  return _internal_has_model_token();
}
inline void EdgeTpuSettings::clear_model_token() {
  model_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& EdgeTpuSettings::model_token() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.model_token)
  return _internal_model_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EdgeTpuSettings::set_model_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 model_token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuSettings.model_token)
}
inline std::string* EdgeTpuSettings::mutable_model_token() {
  std::string* _s = _internal_mutable_model_token();
  // @@protoc_insertion_point(field_mutable:tflite.proto.EdgeTpuSettings.model_token)
  return _s;
}
inline const std::string& EdgeTpuSettings::_internal_model_token() const {
  return model_token_.Get();
}
inline void EdgeTpuSettings::_internal_set_model_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  model_token_.Set(value, GetArenaForAllocation());
}
inline std::string* EdgeTpuSettings::_internal_mutable_model_token() {
  _has_bits_[0] |= 0x00000001u;
  return model_token_.Mutable(GetArenaForAllocation());
}
inline std::string* EdgeTpuSettings::release_model_token() {
  // @@protoc_insertion_point(field_release:tflite.proto.EdgeTpuSettings.model_token)
  if (!_internal_has_model_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = model_token_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_token_.IsDefault()) {
    model_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void EdgeTpuSettings::set_allocated_model_token(std::string* model_token) {
  if (model_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_token_.SetAllocated(model_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (model_token_.IsDefault()) {
    model_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.EdgeTpuSettings.model_token)
}

// optional .tflite.proto.EdgeTpuSettings.FloatTruncationType float_truncation_type = 6;
inline bool EdgeTpuSettings::_internal_has_float_truncation_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool EdgeTpuSettings::has_float_truncation_type() const {
  return _internal_has_float_truncation_type();
}
inline void EdgeTpuSettings::clear_float_truncation_type() {
  float_truncation_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::tflite::proto::EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::_internal_float_truncation_type() const {
  return static_cast< ::tflite::proto::EdgeTpuSettings_FloatTruncationType >(float_truncation_type_);
}
inline ::tflite::proto::EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::float_truncation_type() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.float_truncation_type)
  return _internal_float_truncation_type();
}
inline void EdgeTpuSettings::_internal_set_float_truncation_type(::tflite::proto::EdgeTpuSettings_FloatTruncationType value) {
  assert(::tflite::proto::EdgeTpuSettings_FloatTruncationType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  float_truncation_type_ = value;
}
inline void EdgeTpuSettings::set_float_truncation_type(::tflite::proto::EdgeTpuSettings_FloatTruncationType value) {
  _internal_set_float_truncation_type(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuSettings.float_truncation_type)
}

// optional .tflite.proto.EdgeTpuSettings.QosClass qos_class = 7 [default = QOS_UNDEFINED];
inline bool EdgeTpuSettings::_internal_has_qos_class() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool EdgeTpuSettings::has_qos_class() const {
  return _internal_has_qos_class();
}
inline void EdgeTpuSettings::clear_qos_class() {
  qos_class_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::tflite::proto::EdgeTpuSettings_QosClass EdgeTpuSettings::_internal_qos_class() const {
  return static_cast< ::tflite::proto::EdgeTpuSettings_QosClass >(qos_class_);
}
inline ::tflite::proto::EdgeTpuSettings_QosClass EdgeTpuSettings::qos_class() const {
  // @@protoc_insertion_point(field_get:tflite.proto.EdgeTpuSettings.qos_class)
  return _internal_qos_class();
}
inline void EdgeTpuSettings::_internal_set_qos_class(::tflite::proto::EdgeTpuSettings_QosClass value) {
  assert(::tflite::proto::EdgeTpuSettings_QosClass_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  qos_class_ = value;
}
inline void EdgeTpuSettings::set_qos_class(::tflite::proto::EdgeTpuSettings_QosClass value) {
  _internal_set_qos_class(value);
  // @@protoc_insertion_point(field_set:tflite.proto.EdgeTpuSettings.qos_class)
}

// -------------------------------------------------------------------

// CoralSettings

// optional string device = 1;
inline bool CoralSettings::_internal_has_device() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CoralSettings::has_device() const {
  return _internal_has_device();
}
inline void CoralSettings::clear_device() {
  device_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CoralSettings::device() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoralSettings.device)
  return _internal_device();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CoralSettings::set_device(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.CoralSettings.device)
}
inline std::string* CoralSettings::mutable_device() {
  std::string* _s = _internal_mutable_device();
  // @@protoc_insertion_point(field_mutable:tflite.proto.CoralSettings.device)
  return _s;
}
inline const std::string& CoralSettings::_internal_device() const {
  return device_.Get();
}
inline void CoralSettings::_internal_set_device(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_.Set(value, GetArenaForAllocation());
}
inline std::string* CoralSettings::_internal_mutable_device() {
  _has_bits_[0] |= 0x00000001u;
  return device_.Mutable(GetArenaForAllocation());
}
inline std::string* CoralSettings::release_device() {
  // @@protoc_insertion_point(field_release:tflite.proto.CoralSettings.device)
  if (!_internal_has_device()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_.IsDefault()) {
    device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CoralSettings::set_allocated_device(std::string* device) {
  if (device != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_.SetAllocated(device, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_.IsDefault()) {
    device_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.CoralSettings.device)
}

// optional .tflite.proto.CoralSettings.Performance performance = 2 [default = MAXIMUM];
inline bool CoralSettings::_internal_has_performance() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CoralSettings::has_performance() const {
  return _internal_has_performance();
}
inline void CoralSettings::clear_performance() {
  performance_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::tflite::proto::CoralSettings_Performance CoralSettings::_internal_performance() const {
  return static_cast< ::tflite::proto::CoralSettings_Performance >(performance_);
}
inline ::tflite::proto::CoralSettings_Performance CoralSettings::performance() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoralSettings.performance)
  return _internal_performance();
}
inline void CoralSettings::_internal_set_performance(::tflite::proto::CoralSettings_Performance value) {
  assert(::tflite::proto::CoralSettings_Performance_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  performance_ = value;
}
inline void CoralSettings::set_performance(::tflite::proto::CoralSettings_Performance value) {
  _internal_set_performance(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoralSettings.performance)
}

// optional bool usb_always_dfu = 3;
inline bool CoralSettings::_internal_has_usb_always_dfu() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CoralSettings::has_usb_always_dfu() const {
  return _internal_has_usb_always_dfu();
}
inline void CoralSettings::clear_usb_always_dfu() {
  usb_always_dfu_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CoralSettings::_internal_usb_always_dfu() const {
  return usb_always_dfu_;
}
inline bool CoralSettings::usb_always_dfu() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoralSettings.usb_always_dfu)
  return _internal_usb_always_dfu();
}
inline void CoralSettings::_internal_set_usb_always_dfu(bool value) {
  _has_bits_[0] |= 0x00000002u;
  usb_always_dfu_ = value;
}
inline void CoralSettings::set_usb_always_dfu(bool value) {
  _internal_set_usb_always_dfu(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoralSettings.usb_always_dfu)
}

// optional int32 usb_max_bulk_in_queue_length = 4;
inline bool CoralSettings::_internal_has_usb_max_bulk_in_queue_length() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CoralSettings::has_usb_max_bulk_in_queue_length() const {
  return _internal_has_usb_max_bulk_in_queue_length();
}
inline void CoralSettings::clear_usb_max_bulk_in_queue_length() {
  usb_max_bulk_in_queue_length_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CoralSettings::_internal_usb_max_bulk_in_queue_length() const {
  return usb_max_bulk_in_queue_length_;
}
inline int32_t CoralSettings::usb_max_bulk_in_queue_length() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CoralSettings.usb_max_bulk_in_queue_length)
  return _internal_usb_max_bulk_in_queue_length();
}
inline void CoralSettings::_internal_set_usb_max_bulk_in_queue_length(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  usb_max_bulk_in_queue_length_ = value;
}
inline void CoralSettings::set_usb_max_bulk_in_queue_length(int32_t value) {
  _internal_set_usb_max_bulk_in_queue_length(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CoralSettings.usb_max_bulk_in_queue_length)
}

// -------------------------------------------------------------------

// CPUSettings

// optional int32 num_threads = 1 [default = -1];
inline bool CPUSettings::_internal_has_num_threads() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CPUSettings::has_num_threads() const {
  return _internal_has_num_threads();
}
inline void CPUSettings::clear_num_threads() {
  num_threads_ = -1;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CPUSettings::_internal_num_threads() const {
  return num_threads_;
}
inline int32_t CPUSettings::num_threads() const {
  // @@protoc_insertion_point(field_get:tflite.proto.CPUSettings.num_threads)
  return _internal_num_threads();
}
inline void CPUSettings::_internal_set_num_threads(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  num_threads_ = value;
}
inline void CPUSettings::set_num_threads(int32_t value) {
  _internal_set_num_threads(value);
  // @@protoc_insertion_point(field_set:tflite.proto.CPUSettings.num_threads)
}

// -------------------------------------------------------------------

// TFLiteSettings

// optional .tflite.proto.Delegate delegate = 1;
inline bool TFLiteSettings::_internal_has_delegate() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TFLiteSettings::has_delegate() const {
  return _internal_has_delegate();
}
inline void TFLiteSettings::clear_delegate() {
  delegate_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::tflite::proto::Delegate TFLiteSettings::_internal_delegate() const {
  return static_cast< ::tflite::proto::Delegate >(delegate_);
}
inline ::tflite::proto::Delegate TFLiteSettings::delegate() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.delegate)
  return _internal_delegate();
}
inline void TFLiteSettings::_internal_set_delegate(::tflite::proto::Delegate value) {
  assert(::tflite::proto::Delegate_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  delegate_ = value;
}
inline void TFLiteSettings::set_delegate(::tflite::proto::Delegate value) {
  _internal_set_delegate(value);
  // @@protoc_insertion_point(field_set:tflite.proto.TFLiteSettings.delegate)
}

// optional .tflite.proto.NNAPISettings nnapi_settings = 2;
inline bool TFLiteSettings::_internal_has_nnapi_settings() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || nnapi_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_nnapi_settings() const {
  return _internal_has_nnapi_settings();
}
inline void TFLiteSettings::clear_nnapi_settings() {
  if (nnapi_settings_ != nullptr) nnapi_settings_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::tflite::proto::NNAPISettings& TFLiteSettings::_internal_nnapi_settings() const {
  const ::tflite::proto::NNAPISettings* p = nnapi_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::NNAPISettings&>(
      ::tflite::proto::_NNAPISettings_default_instance_);
}
inline const ::tflite::proto::NNAPISettings& TFLiteSettings::nnapi_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.nnapi_settings)
  return _internal_nnapi_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_nnapi_settings(
    ::tflite::proto::NNAPISettings* nnapi_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(nnapi_settings_);
  }
  nnapi_settings_ = nnapi_settings;
  if (nnapi_settings) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.nnapi_settings)
}
inline ::tflite::proto::NNAPISettings* TFLiteSettings::release_nnapi_settings() {
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::NNAPISettings* temp = nnapi_settings_;
  nnapi_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::NNAPISettings* TFLiteSettings::unsafe_arena_release_nnapi_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.nnapi_settings)
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::NNAPISettings* temp = nnapi_settings_;
  nnapi_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::NNAPISettings* TFLiteSettings::_internal_mutable_nnapi_settings() {
  _has_bits_[0] |= 0x00000001u;
  if (nnapi_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::NNAPISettings>(GetArenaForAllocation());
    nnapi_settings_ = p;
  }
  return nnapi_settings_;
}
inline ::tflite::proto::NNAPISettings* TFLiteSettings::mutable_nnapi_settings() {
  ::tflite::proto::NNAPISettings* _msg = _internal_mutable_nnapi_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.nnapi_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_nnapi_settings(::tflite::proto::NNAPISettings* nnapi_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete nnapi_settings_;
  }
  if (nnapi_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nnapi_settings);
    if (message_arena != submessage_arena) {
      nnapi_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nnapi_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nnapi_settings_ = nnapi_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.nnapi_settings)
}

// optional .tflite.proto.GPUSettings gpu_settings = 3;
inline bool TFLiteSettings::_internal_has_gpu_settings() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || gpu_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_gpu_settings() const {
  return _internal_has_gpu_settings();
}
inline void TFLiteSettings::clear_gpu_settings() {
  if (gpu_settings_ != nullptr) gpu_settings_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::tflite::proto::GPUSettings& TFLiteSettings::_internal_gpu_settings() const {
  const ::tflite::proto::GPUSettings* p = gpu_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::GPUSettings&>(
      ::tflite::proto::_GPUSettings_default_instance_);
}
inline const ::tflite::proto::GPUSettings& TFLiteSettings::gpu_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.gpu_settings)
  return _internal_gpu_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_gpu_settings(
    ::tflite::proto::GPUSettings* gpu_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(gpu_settings_);
  }
  gpu_settings_ = gpu_settings;
  if (gpu_settings) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.gpu_settings)
}
inline ::tflite::proto::GPUSettings* TFLiteSettings::release_gpu_settings() {
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::GPUSettings* temp = gpu_settings_;
  gpu_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::GPUSettings* TFLiteSettings::unsafe_arena_release_gpu_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.gpu_settings)
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::GPUSettings* temp = gpu_settings_;
  gpu_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::GPUSettings* TFLiteSettings::_internal_mutable_gpu_settings() {
  _has_bits_[0] |= 0x00000002u;
  if (gpu_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::GPUSettings>(GetArenaForAllocation());
    gpu_settings_ = p;
  }
  return gpu_settings_;
}
inline ::tflite::proto::GPUSettings* TFLiteSettings::mutable_gpu_settings() {
  ::tflite::proto::GPUSettings* _msg = _internal_mutable_gpu_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.gpu_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_gpu_settings(::tflite::proto::GPUSettings* gpu_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete gpu_settings_;
  }
  if (gpu_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(gpu_settings);
    if (message_arena != submessage_arena) {
      gpu_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gpu_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gpu_settings_ = gpu_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.gpu_settings)
}

// optional .tflite.proto.HexagonSettings hexagon_settings = 4;
inline bool TFLiteSettings::_internal_has_hexagon_settings() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || hexagon_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_hexagon_settings() const {
  return _internal_has_hexagon_settings();
}
inline void TFLiteSettings::clear_hexagon_settings() {
  if (hexagon_settings_ != nullptr) hexagon_settings_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::tflite::proto::HexagonSettings& TFLiteSettings::_internal_hexagon_settings() const {
  const ::tflite::proto::HexagonSettings* p = hexagon_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::HexagonSettings&>(
      ::tflite::proto::_HexagonSettings_default_instance_);
}
inline const ::tflite::proto::HexagonSettings& TFLiteSettings::hexagon_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.hexagon_settings)
  return _internal_hexagon_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_hexagon_settings(
    ::tflite::proto::HexagonSettings* hexagon_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(hexagon_settings_);
  }
  hexagon_settings_ = hexagon_settings;
  if (hexagon_settings) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.hexagon_settings)
}
inline ::tflite::proto::HexagonSettings* TFLiteSettings::release_hexagon_settings() {
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::HexagonSettings* temp = hexagon_settings_;
  hexagon_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::HexagonSettings* TFLiteSettings::unsafe_arena_release_hexagon_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.hexagon_settings)
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::HexagonSettings* temp = hexagon_settings_;
  hexagon_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::HexagonSettings* TFLiteSettings::_internal_mutable_hexagon_settings() {
  _has_bits_[0] |= 0x00000004u;
  if (hexagon_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::HexagonSettings>(GetArenaForAllocation());
    hexagon_settings_ = p;
  }
  return hexagon_settings_;
}
inline ::tflite::proto::HexagonSettings* TFLiteSettings::mutable_hexagon_settings() {
  ::tflite::proto::HexagonSettings* _msg = _internal_mutable_hexagon_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.hexagon_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_hexagon_settings(::tflite::proto::HexagonSettings* hexagon_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete hexagon_settings_;
  }
  if (hexagon_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(hexagon_settings);
    if (message_arena != submessage_arena) {
      hexagon_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hexagon_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  hexagon_settings_ = hexagon_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.hexagon_settings)
}

// optional .tflite.proto.XNNPackSettings xnnpack_settings = 5;
inline bool TFLiteSettings::_internal_has_xnnpack_settings() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || xnnpack_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_xnnpack_settings() const {
  return _internal_has_xnnpack_settings();
}
inline void TFLiteSettings::clear_xnnpack_settings() {
  if (xnnpack_settings_ != nullptr) xnnpack_settings_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::tflite::proto::XNNPackSettings& TFLiteSettings::_internal_xnnpack_settings() const {
  const ::tflite::proto::XNNPackSettings* p = xnnpack_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::XNNPackSettings&>(
      ::tflite::proto::_XNNPackSettings_default_instance_);
}
inline const ::tflite::proto::XNNPackSettings& TFLiteSettings::xnnpack_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.xnnpack_settings)
  return _internal_xnnpack_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_xnnpack_settings(
    ::tflite::proto::XNNPackSettings* xnnpack_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(xnnpack_settings_);
  }
  xnnpack_settings_ = xnnpack_settings;
  if (xnnpack_settings) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.xnnpack_settings)
}
inline ::tflite::proto::XNNPackSettings* TFLiteSettings::release_xnnpack_settings() {
  _has_bits_[0] &= ~0x00000008u;
  ::tflite::proto::XNNPackSettings* temp = xnnpack_settings_;
  xnnpack_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::XNNPackSettings* TFLiteSettings::unsafe_arena_release_xnnpack_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.xnnpack_settings)
  _has_bits_[0] &= ~0x00000008u;
  ::tflite::proto::XNNPackSettings* temp = xnnpack_settings_;
  xnnpack_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::XNNPackSettings* TFLiteSettings::_internal_mutable_xnnpack_settings() {
  _has_bits_[0] |= 0x00000008u;
  if (xnnpack_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::XNNPackSettings>(GetArenaForAllocation());
    xnnpack_settings_ = p;
  }
  return xnnpack_settings_;
}
inline ::tflite::proto::XNNPackSettings* TFLiteSettings::mutable_xnnpack_settings() {
  ::tflite::proto::XNNPackSettings* _msg = _internal_mutable_xnnpack_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.xnnpack_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_xnnpack_settings(::tflite::proto::XNNPackSettings* xnnpack_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete xnnpack_settings_;
  }
  if (xnnpack_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(xnnpack_settings);
    if (message_arena != submessage_arena) {
      xnnpack_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, xnnpack_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  xnnpack_settings_ = xnnpack_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.xnnpack_settings)
}

// optional .tflite.proto.CoreMLSettings coreml_settings = 11;
inline bool TFLiteSettings::_internal_has_coreml_settings() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || coreml_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_coreml_settings() const {
  return _internal_has_coreml_settings();
}
inline void TFLiteSettings::clear_coreml_settings() {
  if (coreml_settings_ != nullptr) coreml_settings_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::tflite::proto::CoreMLSettings& TFLiteSettings::_internal_coreml_settings() const {
  const ::tflite::proto::CoreMLSettings* p = coreml_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::CoreMLSettings&>(
      ::tflite::proto::_CoreMLSettings_default_instance_);
}
inline const ::tflite::proto::CoreMLSettings& TFLiteSettings::coreml_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.coreml_settings)
  return _internal_coreml_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_coreml_settings(
    ::tflite::proto::CoreMLSettings* coreml_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coreml_settings_);
  }
  coreml_settings_ = coreml_settings;
  if (coreml_settings) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.coreml_settings)
}
inline ::tflite::proto::CoreMLSettings* TFLiteSettings::release_coreml_settings() {
  _has_bits_[0] &= ~0x00000100u;
  ::tflite::proto::CoreMLSettings* temp = coreml_settings_;
  coreml_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::CoreMLSettings* TFLiteSettings::unsafe_arena_release_coreml_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.coreml_settings)
  _has_bits_[0] &= ~0x00000100u;
  ::tflite::proto::CoreMLSettings* temp = coreml_settings_;
  coreml_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::CoreMLSettings* TFLiteSettings::_internal_mutable_coreml_settings() {
  _has_bits_[0] |= 0x00000100u;
  if (coreml_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::CoreMLSettings>(GetArenaForAllocation());
    coreml_settings_ = p;
  }
  return coreml_settings_;
}
inline ::tflite::proto::CoreMLSettings* TFLiteSettings::mutable_coreml_settings() {
  ::tflite::proto::CoreMLSettings* _msg = _internal_mutable_coreml_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.coreml_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_coreml_settings(::tflite::proto::CoreMLSettings* coreml_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete coreml_settings_;
  }
  if (coreml_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coreml_settings);
    if (message_arena != submessage_arena) {
      coreml_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coreml_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  coreml_settings_ = coreml_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.coreml_settings)
}

// optional .tflite.proto.CPUSettings cpu_settings = 6;
inline bool TFLiteSettings::_internal_has_cpu_settings() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || cpu_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_cpu_settings() const {
  return _internal_has_cpu_settings();
}
inline void TFLiteSettings::clear_cpu_settings() {
  if (cpu_settings_ != nullptr) cpu_settings_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::tflite::proto::CPUSettings& TFLiteSettings::_internal_cpu_settings() const {
  const ::tflite::proto::CPUSettings* p = cpu_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::CPUSettings&>(
      ::tflite::proto::_CPUSettings_default_instance_);
}
inline const ::tflite::proto::CPUSettings& TFLiteSettings::cpu_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.cpu_settings)
  return _internal_cpu_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_cpu_settings(
    ::tflite::proto::CPUSettings* cpu_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cpu_settings_);
  }
  cpu_settings_ = cpu_settings;
  if (cpu_settings) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.cpu_settings)
}
inline ::tflite::proto::CPUSettings* TFLiteSettings::release_cpu_settings() {
  _has_bits_[0] &= ~0x00000010u;
  ::tflite::proto::CPUSettings* temp = cpu_settings_;
  cpu_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::CPUSettings* TFLiteSettings::unsafe_arena_release_cpu_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.cpu_settings)
  _has_bits_[0] &= ~0x00000010u;
  ::tflite::proto::CPUSettings* temp = cpu_settings_;
  cpu_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::CPUSettings* TFLiteSettings::_internal_mutable_cpu_settings() {
  _has_bits_[0] |= 0x00000010u;
  if (cpu_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::CPUSettings>(GetArenaForAllocation());
    cpu_settings_ = p;
  }
  return cpu_settings_;
}
inline ::tflite::proto::CPUSettings* TFLiteSettings::mutable_cpu_settings() {
  ::tflite::proto::CPUSettings* _msg = _internal_mutable_cpu_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.cpu_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_cpu_settings(::tflite::proto::CPUSettings* cpu_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cpu_settings_;
  }
  if (cpu_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cpu_settings);
    if (message_arena != submessage_arena) {
      cpu_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cpu_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  cpu_settings_ = cpu_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.cpu_settings)
}

// optional int32 max_delegated_partitions = 7;
inline bool TFLiteSettings::_internal_has_max_delegated_partitions() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TFLiteSettings::has_max_delegated_partitions() const {
  return _internal_has_max_delegated_partitions();
}
inline void TFLiteSettings::clear_max_delegated_partitions() {
  max_delegated_partitions_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t TFLiteSettings::_internal_max_delegated_partitions() const {
  return max_delegated_partitions_;
}
inline int32_t TFLiteSettings::max_delegated_partitions() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.max_delegated_partitions)
  return _internal_max_delegated_partitions();
}
inline void TFLiteSettings::_internal_set_max_delegated_partitions(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  max_delegated_partitions_ = value;
}
inline void TFLiteSettings::set_max_delegated_partitions(int32_t value) {
  _internal_set_max_delegated_partitions(value);
  // @@protoc_insertion_point(field_set:tflite.proto.TFLiteSettings.max_delegated_partitions)
}

// optional .tflite.proto.EdgeTpuSettings edgetpu_settings = 8;
inline bool TFLiteSettings::_internal_has_edgetpu_settings() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || edgetpu_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_edgetpu_settings() const {
  return _internal_has_edgetpu_settings();
}
inline void TFLiteSettings::clear_edgetpu_settings() {
  if (edgetpu_settings_ != nullptr) edgetpu_settings_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::tflite::proto::EdgeTpuSettings& TFLiteSettings::_internal_edgetpu_settings() const {
  const ::tflite::proto::EdgeTpuSettings* p = edgetpu_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::EdgeTpuSettings&>(
      ::tflite::proto::_EdgeTpuSettings_default_instance_);
}
inline const ::tflite::proto::EdgeTpuSettings& TFLiteSettings::edgetpu_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.edgetpu_settings)
  return _internal_edgetpu_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_edgetpu_settings(
    ::tflite::proto::EdgeTpuSettings* edgetpu_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(edgetpu_settings_);
  }
  edgetpu_settings_ = edgetpu_settings;
  if (edgetpu_settings) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.edgetpu_settings)
}
inline ::tflite::proto::EdgeTpuSettings* TFLiteSettings::release_edgetpu_settings() {
  _has_bits_[0] &= ~0x00000020u;
  ::tflite::proto::EdgeTpuSettings* temp = edgetpu_settings_;
  edgetpu_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::EdgeTpuSettings* TFLiteSettings::unsafe_arena_release_edgetpu_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.edgetpu_settings)
  _has_bits_[0] &= ~0x00000020u;
  ::tflite::proto::EdgeTpuSettings* temp = edgetpu_settings_;
  edgetpu_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::EdgeTpuSettings* TFLiteSettings::_internal_mutable_edgetpu_settings() {
  _has_bits_[0] |= 0x00000020u;
  if (edgetpu_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::EdgeTpuSettings>(GetArenaForAllocation());
    edgetpu_settings_ = p;
  }
  return edgetpu_settings_;
}
inline ::tflite::proto::EdgeTpuSettings* TFLiteSettings::mutable_edgetpu_settings() {
  ::tflite::proto::EdgeTpuSettings* _msg = _internal_mutable_edgetpu_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.edgetpu_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_edgetpu_settings(::tflite::proto::EdgeTpuSettings* edgetpu_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete edgetpu_settings_;
  }
  if (edgetpu_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(edgetpu_settings);
    if (message_arena != submessage_arena) {
      edgetpu_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, edgetpu_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  edgetpu_settings_ = edgetpu_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.edgetpu_settings)
}

// optional .tflite.proto.CoralSettings coral_settings = 10;
inline bool TFLiteSettings::_internal_has_coral_settings() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || coral_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_coral_settings() const {
  return _internal_has_coral_settings();
}
inline void TFLiteSettings::clear_coral_settings() {
  if (coral_settings_ != nullptr) coral_settings_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::tflite::proto::CoralSettings& TFLiteSettings::_internal_coral_settings() const {
  const ::tflite::proto::CoralSettings* p = coral_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::CoralSettings&>(
      ::tflite::proto::_CoralSettings_default_instance_);
}
inline const ::tflite::proto::CoralSettings& TFLiteSettings::coral_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.coral_settings)
  return _internal_coral_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_coral_settings(
    ::tflite::proto::CoralSettings* coral_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coral_settings_);
  }
  coral_settings_ = coral_settings;
  if (coral_settings) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.coral_settings)
}
inline ::tflite::proto::CoralSettings* TFLiteSettings::release_coral_settings() {
  _has_bits_[0] &= ~0x00000080u;
  ::tflite::proto::CoralSettings* temp = coral_settings_;
  coral_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::CoralSettings* TFLiteSettings::unsafe_arena_release_coral_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.coral_settings)
  _has_bits_[0] &= ~0x00000080u;
  ::tflite::proto::CoralSettings* temp = coral_settings_;
  coral_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::CoralSettings* TFLiteSettings::_internal_mutable_coral_settings() {
  _has_bits_[0] |= 0x00000080u;
  if (coral_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::CoralSettings>(GetArenaForAllocation());
    coral_settings_ = p;
  }
  return coral_settings_;
}
inline ::tflite::proto::CoralSettings* TFLiteSettings::mutable_coral_settings() {
  ::tflite::proto::CoralSettings* _msg = _internal_mutable_coral_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.coral_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_coral_settings(::tflite::proto::CoralSettings* coral_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete coral_settings_;
  }
  if (coral_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coral_settings);
    if (message_arena != submessage_arena) {
      coral_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coral_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  coral_settings_ = coral_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.coral_settings)
}

// optional .tflite.proto.FallbackSettings fallback_settings = 9;
inline bool TFLiteSettings::_internal_has_fallback_settings() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || fallback_settings_ != nullptr);
  return value;
}
inline bool TFLiteSettings::has_fallback_settings() const {
  return _internal_has_fallback_settings();
}
inline void TFLiteSettings::clear_fallback_settings() {
  if (fallback_settings_ != nullptr) fallback_settings_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::tflite::proto::FallbackSettings& TFLiteSettings::_internal_fallback_settings() const {
  const ::tflite::proto::FallbackSettings* p = fallback_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::FallbackSettings&>(
      ::tflite::proto::_FallbackSettings_default_instance_);
}
inline const ::tflite::proto::FallbackSettings& TFLiteSettings::fallback_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.fallback_settings)
  return _internal_fallback_settings();
}
inline void TFLiteSettings::unsafe_arena_set_allocated_fallback_settings(
    ::tflite::proto::FallbackSettings* fallback_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fallback_settings_);
  }
  fallback_settings_ = fallback_settings;
  if (fallback_settings) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.TFLiteSettings.fallback_settings)
}
inline ::tflite::proto::FallbackSettings* TFLiteSettings::release_fallback_settings() {
  _has_bits_[0] &= ~0x00000040u;
  ::tflite::proto::FallbackSettings* temp = fallback_settings_;
  fallback_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::FallbackSettings* TFLiteSettings::unsafe_arena_release_fallback_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.TFLiteSettings.fallback_settings)
  _has_bits_[0] &= ~0x00000040u;
  ::tflite::proto::FallbackSettings* temp = fallback_settings_;
  fallback_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::FallbackSettings* TFLiteSettings::_internal_mutable_fallback_settings() {
  _has_bits_[0] |= 0x00000040u;
  if (fallback_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::FallbackSettings>(GetArenaForAllocation());
    fallback_settings_ = p;
  }
  return fallback_settings_;
}
inline ::tflite::proto::FallbackSettings* TFLiteSettings::mutable_fallback_settings() {
  ::tflite::proto::FallbackSettings* _msg = _internal_mutable_fallback_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.TFLiteSettings.fallback_settings)
  return _msg;
}
inline void TFLiteSettings::set_allocated_fallback_settings(::tflite::proto::FallbackSettings* fallback_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fallback_settings_;
  }
  if (fallback_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(fallback_settings);
    if (message_arena != submessage_arena) {
      fallback_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fallback_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  fallback_settings_ = fallback_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.TFLiteSettings.fallback_settings)
}

// optional bool disable_default_delegates = 12;
inline bool TFLiteSettings::_internal_has_disable_default_delegates() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TFLiteSettings::has_disable_default_delegates() const {
  return _internal_has_disable_default_delegates();
}
inline void TFLiteSettings::clear_disable_default_delegates() {
  disable_default_delegates_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool TFLiteSettings::_internal_disable_default_delegates() const {
  return disable_default_delegates_;
}
inline bool TFLiteSettings::disable_default_delegates() const {
  // @@protoc_insertion_point(field_get:tflite.proto.TFLiteSettings.disable_default_delegates)
  return _internal_disable_default_delegates();
}
inline void TFLiteSettings::_internal_set_disable_default_delegates(bool value) {
  _has_bits_[0] |= 0x00000800u;
  disable_default_delegates_ = value;
}
inline void TFLiteSettings::set_disable_default_delegates(bool value) {
  _internal_set_disable_default_delegates(value);
  // @@protoc_insertion_point(field_set:tflite.proto.TFLiteSettings.disable_default_delegates)
}

// -------------------------------------------------------------------

// FallbackSettings

// optional bool allow_automatic_fallback_on_compilation_error = 7;
inline bool FallbackSettings::_internal_has_allow_automatic_fallback_on_compilation_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool FallbackSettings::has_allow_automatic_fallback_on_compilation_error() const {
  return _internal_has_allow_automatic_fallback_on_compilation_error();
}
inline void FallbackSettings::clear_allow_automatic_fallback_on_compilation_error() {
  allow_automatic_fallback_on_compilation_error_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool FallbackSettings::_internal_allow_automatic_fallback_on_compilation_error() const {
  return allow_automatic_fallback_on_compilation_error_;
}
inline bool FallbackSettings::allow_automatic_fallback_on_compilation_error() const {
  // @@protoc_insertion_point(field_get:tflite.proto.FallbackSettings.allow_automatic_fallback_on_compilation_error)
  return _internal_allow_automatic_fallback_on_compilation_error();
}
inline void FallbackSettings::_internal_set_allow_automatic_fallback_on_compilation_error(bool value) {
  _has_bits_[0] |= 0x00000001u;
  allow_automatic_fallback_on_compilation_error_ = value;
}
inline void FallbackSettings::set_allow_automatic_fallback_on_compilation_error(bool value) {
  _internal_set_allow_automatic_fallback_on_compilation_error(value);
  // @@protoc_insertion_point(field_set:tflite.proto.FallbackSettings.allow_automatic_fallback_on_compilation_error)
}

// optional bool allow_automatic_fallback_on_execution_error = 8;
inline bool FallbackSettings::_internal_has_allow_automatic_fallback_on_execution_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool FallbackSettings::has_allow_automatic_fallback_on_execution_error() const {
  return _internal_has_allow_automatic_fallback_on_execution_error();
}
inline void FallbackSettings::clear_allow_automatic_fallback_on_execution_error() {
  allow_automatic_fallback_on_execution_error_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool FallbackSettings::_internal_allow_automatic_fallback_on_execution_error() const {
  return allow_automatic_fallback_on_execution_error_;
}
inline bool FallbackSettings::allow_automatic_fallback_on_execution_error() const {
  // @@protoc_insertion_point(field_get:tflite.proto.FallbackSettings.allow_automatic_fallback_on_execution_error)
  return _internal_allow_automatic_fallback_on_execution_error();
}
inline void FallbackSettings::_internal_set_allow_automatic_fallback_on_execution_error(bool value) {
  _has_bits_[0] |= 0x00000002u;
  allow_automatic_fallback_on_execution_error_ = value;
}
inline void FallbackSettings::set_allow_automatic_fallback_on_execution_error(bool value) {
  _internal_set_allow_automatic_fallback_on_execution_error(value);
  // @@protoc_insertion_point(field_set:tflite.proto.FallbackSettings.allow_automatic_fallback_on_execution_error)
}

// -------------------------------------------------------------------

// BenchmarkMetric

// optional string name = 1;
inline bool BenchmarkMetric::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BenchmarkMetric::has_name() const {
  return _internal_has_name();
}
inline void BenchmarkMetric::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BenchmarkMetric::name() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkMetric.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BenchmarkMetric::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkMetric.name)
}
inline std::string* BenchmarkMetric::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkMetric.name)
  return _s;
}
inline const std::string& BenchmarkMetric::_internal_name() const {
  return name_.Get();
}
inline void BenchmarkMetric::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* BenchmarkMetric::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* BenchmarkMetric::release_name() {
  // @@protoc_insertion_point(field_release:tflite.proto.BenchmarkMetric.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BenchmarkMetric::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BenchmarkMetric.name)
}

// repeated float values = 2 [packed = true];
inline int BenchmarkMetric::_internal_values_size() const {
  return values_.size();
}
inline int BenchmarkMetric::values_size() const {
  return _internal_values_size();
}
inline void BenchmarkMetric::clear_values() {
  values_.Clear();
}
inline float BenchmarkMetric::_internal_values(int index) const {
  return values_.Get(index);
}
inline float BenchmarkMetric::values(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkMetric.values)
  return _internal_values(index);
}
inline void BenchmarkMetric::set_values(int index, float value) {
  values_.Set(index, value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkMetric.values)
}
inline void BenchmarkMetric::_internal_add_values(float value) {
  values_.Add(value);
}
inline void BenchmarkMetric::add_values(float value) {
  _internal_add_values(value);
  // @@protoc_insertion_point(field_add:tflite.proto.BenchmarkMetric.values)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
BenchmarkMetric::_internal_values() const {
  return values_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
BenchmarkMetric::values() const {
  // @@protoc_insertion_point(field_list:tflite.proto.BenchmarkMetric.values)
  return _internal_values();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
BenchmarkMetric::_internal_mutable_values() {
  return &values_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
BenchmarkMetric::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.BenchmarkMetric.values)
  return _internal_mutable_values();
}

// -------------------------------------------------------------------

// BenchmarkResult

// repeated int64 initialization_time_us = 1 [packed = true];
inline int BenchmarkResult::_internal_initialization_time_us_size() const {
  return initialization_time_us_.size();
}
inline int BenchmarkResult::initialization_time_us_size() const {
  return _internal_initialization_time_us_size();
}
inline void BenchmarkResult::clear_initialization_time_us() {
  initialization_time_us_.Clear();
}
inline int64_t BenchmarkResult::_internal_initialization_time_us(int index) const {
  return initialization_time_us_.Get(index);
}
inline int64_t BenchmarkResult::initialization_time_us(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkResult.initialization_time_us)
  return _internal_initialization_time_us(index);
}
inline void BenchmarkResult::set_initialization_time_us(int index, int64_t value) {
  initialization_time_us_.Set(index, value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkResult.initialization_time_us)
}
inline void BenchmarkResult::_internal_add_initialization_time_us(int64_t value) {
  initialization_time_us_.Add(value);
}
inline void BenchmarkResult::add_initialization_time_us(int64_t value) {
  _internal_add_initialization_time_us(value);
  // @@protoc_insertion_point(field_add:tflite.proto.BenchmarkResult.initialization_time_us)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
BenchmarkResult::_internal_initialization_time_us() const {
  return initialization_time_us_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
BenchmarkResult::initialization_time_us() const {
  // @@protoc_insertion_point(field_list:tflite.proto.BenchmarkResult.initialization_time_us)
  return _internal_initialization_time_us();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
BenchmarkResult::_internal_mutable_initialization_time_us() {
  return &initialization_time_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
BenchmarkResult::mutable_initialization_time_us() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.BenchmarkResult.initialization_time_us)
  return _internal_mutable_initialization_time_us();
}

// repeated int64 inference_time_us = 2 [packed = true];
inline int BenchmarkResult::_internal_inference_time_us_size() const {
  return inference_time_us_.size();
}
inline int BenchmarkResult::inference_time_us_size() const {
  return _internal_inference_time_us_size();
}
inline void BenchmarkResult::clear_inference_time_us() {
  inference_time_us_.Clear();
}
inline int64_t BenchmarkResult::_internal_inference_time_us(int index) const {
  return inference_time_us_.Get(index);
}
inline int64_t BenchmarkResult::inference_time_us(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkResult.inference_time_us)
  return _internal_inference_time_us(index);
}
inline void BenchmarkResult::set_inference_time_us(int index, int64_t value) {
  inference_time_us_.Set(index, value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkResult.inference_time_us)
}
inline void BenchmarkResult::_internal_add_inference_time_us(int64_t value) {
  inference_time_us_.Add(value);
}
inline void BenchmarkResult::add_inference_time_us(int64_t value) {
  _internal_add_inference_time_us(value);
  // @@protoc_insertion_point(field_add:tflite.proto.BenchmarkResult.inference_time_us)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
BenchmarkResult::_internal_inference_time_us() const {
  return inference_time_us_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
BenchmarkResult::inference_time_us() const {
  // @@protoc_insertion_point(field_list:tflite.proto.BenchmarkResult.inference_time_us)
  return _internal_inference_time_us();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
BenchmarkResult::_internal_mutable_inference_time_us() {
  return &inference_time_us_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
BenchmarkResult::mutable_inference_time_us() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.BenchmarkResult.inference_time_us)
  return _internal_mutable_inference_time_us();
}

// optional int32 max_memory_kb = 3;
inline bool BenchmarkResult::_internal_has_max_memory_kb() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BenchmarkResult::has_max_memory_kb() const {
  return _internal_has_max_memory_kb();
}
inline void BenchmarkResult::clear_max_memory_kb() {
  max_memory_kb_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t BenchmarkResult::_internal_max_memory_kb() const {
  return max_memory_kb_;
}
inline int32_t BenchmarkResult::max_memory_kb() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkResult.max_memory_kb)
  return _internal_max_memory_kb();
}
inline void BenchmarkResult::_internal_set_max_memory_kb(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  max_memory_kb_ = value;
}
inline void BenchmarkResult::set_max_memory_kb(int32_t value) {
  _internal_set_max_memory_kb(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkResult.max_memory_kb)
}

// optional bool ok = 4;
inline bool BenchmarkResult::_internal_has_ok() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BenchmarkResult::has_ok() const {
  return _internal_has_ok();
}
inline void BenchmarkResult::clear_ok() {
  ok_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool BenchmarkResult::_internal_ok() const {
  return ok_;
}
inline bool BenchmarkResult::ok() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkResult.ok)
  return _internal_ok();
}
inline void BenchmarkResult::_internal_set_ok(bool value) {
  _has_bits_[0] |= 0x00000002u;
  ok_ = value;
}
inline void BenchmarkResult::set_ok(bool value) {
  _internal_set_ok(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkResult.ok)
}

// repeated .tflite.proto.BenchmarkMetric metrics = 5;
inline int BenchmarkResult::_internal_metrics_size() const {
  return metrics_.size();
}
inline int BenchmarkResult::metrics_size() const {
  return _internal_metrics_size();
}
inline void BenchmarkResult::clear_metrics() {
  metrics_.Clear();
}
inline ::tflite::proto::BenchmarkMetric* BenchmarkResult::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkResult.metrics)
  return metrics_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::BenchmarkMetric >*
BenchmarkResult::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.BenchmarkResult.metrics)
  return &metrics_;
}
inline const ::tflite::proto::BenchmarkMetric& BenchmarkResult::_internal_metrics(int index) const {
  return metrics_.Get(index);
}
inline const ::tflite::proto::BenchmarkMetric& BenchmarkResult::metrics(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkResult.metrics)
  return _internal_metrics(index);
}
inline ::tflite::proto::BenchmarkMetric* BenchmarkResult::_internal_add_metrics() {
  return metrics_.Add();
}
inline ::tflite::proto::BenchmarkMetric* BenchmarkResult::add_metrics() {
  ::tflite::proto::BenchmarkMetric* _add = _internal_add_metrics();
  // @@protoc_insertion_point(field_add:tflite.proto.BenchmarkResult.metrics)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::BenchmarkMetric >&
BenchmarkResult::metrics() const {
  // @@protoc_insertion_point(field_list:tflite.proto.BenchmarkResult.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// ErrorCode

// optional .tflite.proto.Delegate source = 1;
inline bool ErrorCode::_internal_has_source() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ErrorCode::has_source() const {
  return _internal_has_source();
}
inline void ErrorCode::clear_source() {
  source_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::tflite::proto::Delegate ErrorCode::_internal_source() const {
  return static_cast< ::tflite::proto::Delegate >(source_);
}
inline ::tflite::proto::Delegate ErrorCode::source() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ErrorCode.source)
  return _internal_source();
}
inline void ErrorCode::_internal_set_source(::tflite::proto::Delegate value) {
  assert(::tflite::proto::Delegate_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  source_ = value;
}
inline void ErrorCode::set_source(::tflite::proto::Delegate value) {
  _internal_set_source(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ErrorCode.source)
}

// optional int32 tflite_error = 2;
inline bool ErrorCode::_internal_has_tflite_error() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ErrorCode::has_tflite_error() const {
  return _internal_has_tflite_error();
}
inline void ErrorCode::clear_tflite_error() {
  tflite_error_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t ErrorCode::_internal_tflite_error() const {
  return tflite_error_;
}
inline int32_t ErrorCode::tflite_error() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ErrorCode.tflite_error)
  return _internal_tflite_error();
}
inline void ErrorCode::_internal_set_tflite_error(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  tflite_error_ = value;
}
inline void ErrorCode::set_tflite_error(int32_t value) {
  _internal_set_tflite_error(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ErrorCode.tflite_error)
}

// optional int64 underlying_api_error = 3;
inline bool ErrorCode::_internal_has_underlying_api_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ErrorCode::has_underlying_api_error() const {
  return _internal_has_underlying_api_error();
}
inline void ErrorCode::clear_underlying_api_error() {
  underlying_api_error_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t ErrorCode::_internal_underlying_api_error() const {
  return underlying_api_error_;
}
inline int64_t ErrorCode::underlying_api_error() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ErrorCode.underlying_api_error)
  return _internal_underlying_api_error();
}
inline void ErrorCode::_internal_set_underlying_api_error(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  underlying_api_error_ = value;
}
inline void ErrorCode::set_underlying_api_error(int64_t value) {
  _internal_set_underlying_api_error(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ErrorCode.underlying_api_error)
}

// -------------------------------------------------------------------

// BenchmarkError

// optional .tflite.proto.BenchmarkStage stage = 1;
inline bool BenchmarkError::_internal_has_stage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BenchmarkError::has_stage() const {
  return _internal_has_stage();
}
inline void BenchmarkError::clear_stage() {
  stage_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::tflite::proto::BenchmarkStage BenchmarkError::_internal_stage() const {
  return static_cast< ::tflite::proto::BenchmarkStage >(stage_);
}
inline ::tflite::proto::BenchmarkStage BenchmarkError::stage() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkError.stage)
  return _internal_stage();
}
inline void BenchmarkError::_internal_set_stage(::tflite::proto::BenchmarkStage value) {
  assert(::tflite::proto::BenchmarkStage_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  stage_ = value;
}
inline void BenchmarkError::set_stage(::tflite::proto::BenchmarkStage value) {
  _internal_set_stage(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkError.stage)
}

// optional int32 exit_code = 2;
inline bool BenchmarkError::_internal_has_exit_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BenchmarkError::has_exit_code() const {
  return _internal_has_exit_code();
}
inline void BenchmarkError::clear_exit_code() {
  exit_code_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t BenchmarkError::_internal_exit_code() const {
  return exit_code_;
}
inline int32_t BenchmarkError::exit_code() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkError.exit_code)
  return _internal_exit_code();
}
inline void BenchmarkError::_internal_set_exit_code(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  exit_code_ = value;
}
inline void BenchmarkError::set_exit_code(int32_t value) {
  _internal_set_exit_code(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkError.exit_code)
}

// optional int32 signal = 3;
inline bool BenchmarkError::_internal_has_signal() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BenchmarkError::has_signal() const {
  return _internal_has_signal();
}
inline void BenchmarkError::clear_signal() {
  signal_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t BenchmarkError::_internal_signal() const {
  return signal_;
}
inline int32_t BenchmarkError::signal() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkError.signal)
  return _internal_signal();
}
inline void BenchmarkError::_internal_set_signal(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  signal_ = value;
}
inline void BenchmarkError::set_signal(int32_t value) {
  _internal_set_signal(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkError.signal)
}

// repeated .tflite.proto.ErrorCode error_code = 4;
inline int BenchmarkError::_internal_error_code_size() const {
  return error_code_.size();
}
inline int BenchmarkError::error_code_size() const {
  return _internal_error_code_size();
}
inline void BenchmarkError::clear_error_code() {
  error_code_.Clear();
}
inline ::tflite::proto::ErrorCode* BenchmarkError::mutable_error_code(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkError.error_code)
  return error_code_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::ErrorCode >*
BenchmarkError::mutable_error_code() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.BenchmarkError.error_code)
  return &error_code_;
}
inline const ::tflite::proto::ErrorCode& BenchmarkError::_internal_error_code(int index) const {
  return error_code_.Get(index);
}
inline const ::tflite::proto::ErrorCode& BenchmarkError::error_code(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkError.error_code)
  return _internal_error_code(index);
}
inline ::tflite::proto::ErrorCode* BenchmarkError::_internal_add_error_code() {
  return error_code_.Add();
}
inline ::tflite::proto::ErrorCode* BenchmarkError::add_error_code() {
  ::tflite::proto::ErrorCode* _add = _internal_add_error_code();
  // @@protoc_insertion_point(field_add:tflite.proto.BenchmarkError.error_code)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::ErrorCode >&
BenchmarkError::error_code() const {
  // @@protoc_insertion_point(field_list:tflite.proto.BenchmarkError.error_code)
  return error_code_;
}

// optional int32 mini_benchmark_error_code = 5;
inline bool BenchmarkError::_internal_has_mini_benchmark_error_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BenchmarkError::has_mini_benchmark_error_code() const {
  return _internal_has_mini_benchmark_error_code();
}
inline void BenchmarkError::clear_mini_benchmark_error_code() {
  mini_benchmark_error_code_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t BenchmarkError::_internal_mini_benchmark_error_code() const {
  return mini_benchmark_error_code_;
}
inline int32_t BenchmarkError::mini_benchmark_error_code() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkError.mini_benchmark_error_code)
  return _internal_mini_benchmark_error_code();
}
inline void BenchmarkError::_internal_set_mini_benchmark_error_code(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  mini_benchmark_error_code_ = value;
}
inline void BenchmarkError::set_mini_benchmark_error_code(int32_t value) {
  _internal_set_mini_benchmark_error_code(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkError.mini_benchmark_error_code)
}

// -------------------------------------------------------------------

// BenchmarkEvent

// optional .tflite.proto.TFLiteSettings tflite_settings = 1;
inline bool BenchmarkEvent::_internal_has_tflite_settings() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || tflite_settings_ != nullptr);
  return value;
}
inline bool BenchmarkEvent::has_tflite_settings() const {
  return _internal_has_tflite_settings();
}
inline void BenchmarkEvent::clear_tflite_settings() {
  if (tflite_settings_ != nullptr) tflite_settings_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::tflite::proto::TFLiteSettings& BenchmarkEvent::_internal_tflite_settings() const {
  const ::tflite::proto::TFLiteSettings* p = tflite_settings_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::TFLiteSettings&>(
      ::tflite::proto::_TFLiteSettings_default_instance_);
}
inline const ::tflite::proto::TFLiteSettings& BenchmarkEvent::tflite_settings() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkEvent.tflite_settings)
  return _internal_tflite_settings();
}
inline void BenchmarkEvent::unsafe_arena_set_allocated_tflite_settings(
    ::tflite::proto::TFLiteSettings* tflite_settings) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tflite_settings_);
  }
  tflite_settings_ = tflite_settings;
  if (tflite_settings) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.BenchmarkEvent.tflite_settings)
}
inline ::tflite::proto::TFLiteSettings* BenchmarkEvent::release_tflite_settings() {
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::TFLiteSettings* temp = tflite_settings_;
  tflite_settings_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::TFLiteSettings* BenchmarkEvent::unsafe_arena_release_tflite_settings() {
  // @@protoc_insertion_point(field_release:tflite.proto.BenchmarkEvent.tflite_settings)
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::TFLiteSettings* temp = tflite_settings_;
  tflite_settings_ = nullptr;
  return temp;
}
inline ::tflite::proto::TFLiteSettings* BenchmarkEvent::_internal_mutable_tflite_settings() {
  _has_bits_[0] |= 0x00000001u;
  if (tflite_settings_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::TFLiteSettings>(GetArenaForAllocation());
    tflite_settings_ = p;
  }
  return tflite_settings_;
}
inline ::tflite::proto::TFLiteSettings* BenchmarkEvent::mutable_tflite_settings() {
  ::tflite::proto::TFLiteSettings* _msg = _internal_mutable_tflite_settings();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkEvent.tflite_settings)
  return _msg;
}
inline void BenchmarkEvent::set_allocated_tflite_settings(::tflite::proto::TFLiteSettings* tflite_settings) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tflite_settings_;
  }
  if (tflite_settings) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tflite_settings);
    if (message_arena != submessage_arena) {
      tflite_settings = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tflite_settings, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tflite_settings_ = tflite_settings;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BenchmarkEvent.tflite_settings)
}

// optional .tflite.proto.BenchmarkEventType event_type = 2;
inline bool BenchmarkEvent::_internal_has_event_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool BenchmarkEvent::has_event_type() const {
  return _internal_has_event_type();
}
inline void BenchmarkEvent::clear_event_type() {
  event_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::tflite::proto::BenchmarkEventType BenchmarkEvent::_internal_event_type() const {
  return static_cast< ::tflite::proto::BenchmarkEventType >(event_type_);
}
inline ::tflite::proto::BenchmarkEventType BenchmarkEvent::event_type() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkEvent.event_type)
  return _internal_event_type();
}
inline void BenchmarkEvent::_internal_set_event_type(::tflite::proto::BenchmarkEventType value) {
  assert(::tflite::proto::BenchmarkEventType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  event_type_ = value;
}
inline void BenchmarkEvent::set_event_type(::tflite::proto::BenchmarkEventType value) {
  _internal_set_event_type(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkEvent.event_type)
}

// optional .tflite.proto.BenchmarkResult result = 3;
inline bool BenchmarkEvent::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || result_ != nullptr);
  return value;
}
inline bool BenchmarkEvent::has_result() const {
  return _internal_has_result();
}
inline void BenchmarkEvent::clear_result() {
  if (result_ != nullptr) result_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::tflite::proto::BenchmarkResult& BenchmarkEvent::_internal_result() const {
  const ::tflite::proto::BenchmarkResult* p = result_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BenchmarkResult&>(
      ::tflite::proto::_BenchmarkResult_default_instance_);
}
inline const ::tflite::proto::BenchmarkResult& BenchmarkEvent::result() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkEvent.result)
  return _internal_result();
}
inline void BenchmarkEvent::unsafe_arena_set_allocated_result(
    ::tflite::proto::BenchmarkResult* result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(result_);
  }
  result_ = result;
  if (result) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.BenchmarkEvent.result)
}
inline ::tflite::proto::BenchmarkResult* BenchmarkEvent::release_result() {
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::BenchmarkResult* temp = result_;
  result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BenchmarkResult* BenchmarkEvent::unsafe_arena_release_result() {
  // @@protoc_insertion_point(field_release:tflite.proto.BenchmarkEvent.result)
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::BenchmarkResult* temp = result_;
  result_ = nullptr;
  return temp;
}
inline ::tflite::proto::BenchmarkResult* BenchmarkEvent::_internal_mutable_result() {
  _has_bits_[0] |= 0x00000002u;
  if (result_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BenchmarkResult>(GetArenaForAllocation());
    result_ = p;
  }
  return result_;
}
inline ::tflite::proto::BenchmarkResult* BenchmarkEvent::mutable_result() {
  ::tflite::proto::BenchmarkResult* _msg = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkEvent.result)
  return _msg;
}
inline void BenchmarkEvent::set_allocated_result(::tflite::proto::BenchmarkResult* result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete result_;
  }
  if (result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(result);
    if (message_arena != submessage_arena) {
      result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, result, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  result_ = result;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BenchmarkEvent.result)
}

// optional .tflite.proto.BenchmarkError error = 4;
inline bool BenchmarkEvent::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool BenchmarkEvent::has_error() const {
  return _internal_has_error();
}
inline void BenchmarkEvent::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::tflite::proto::BenchmarkError& BenchmarkEvent::_internal_error() const {
  const ::tflite::proto::BenchmarkError* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BenchmarkError&>(
      ::tflite::proto::_BenchmarkError_default_instance_);
}
inline const ::tflite::proto::BenchmarkError& BenchmarkEvent::error() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkEvent.error)
  return _internal_error();
}
inline void BenchmarkEvent::unsafe_arena_set_allocated_error(
    ::tflite::proto::BenchmarkError* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.BenchmarkEvent.error)
}
inline ::tflite::proto::BenchmarkError* BenchmarkEvent::release_error() {
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::BenchmarkError* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BenchmarkError* BenchmarkEvent::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:tflite.proto.BenchmarkEvent.error)
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::BenchmarkError* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::tflite::proto::BenchmarkError* BenchmarkEvent::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000004u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BenchmarkError>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::tflite::proto::BenchmarkError* BenchmarkEvent::mutable_error() {
  ::tflite::proto::BenchmarkError* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkEvent.error)
  return _msg;
}
inline void BenchmarkEvent::set_allocated_error(::tflite::proto::BenchmarkError* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BenchmarkEvent.error)
}

// optional int64 boottime_us = 5;
inline bool BenchmarkEvent::_internal_has_boottime_us() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool BenchmarkEvent::has_boottime_us() const {
  return _internal_has_boottime_us();
}
inline void BenchmarkEvent::clear_boottime_us() {
  boottime_us_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t BenchmarkEvent::_internal_boottime_us() const {
  return boottime_us_;
}
inline int64_t BenchmarkEvent::boottime_us() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkEvent.boottime_us)
  return _internal_boottime_us();
}
inline void BenchmarkEvent::_internal_set_boottime_us(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  boottime_us_ = value;
}
inline void BenchmarkEvent::set_boottime_us(int64_t value) {
  _internal_set_boottime_us(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkEvent.boottime_us)
}

// optional int64 wallclock_us = 6;
inline bool BenchmarkEvent::_internal_has_wallclock_us() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool BenchmarkEvent::has_wallclock_us() const {
  return _internal_has_wallclock_us();
}
inline void BenchmarkEvent::clear_wallclock_us() {
  wallclock_us_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t BenchmarkEvent::_internal_wallclock_us() const {
  return wallclock_us_;
}
inline int64_t BenchmarkEvent::wallclock_us() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkEvent.wallclock_us)
  return _internal_wallclock_us();
}
inline void BenchmarkEvent::_internal_set_wallclock_us(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  wallclock_us_ = value;
}
inline void BenchmarkEvent::set_wallclock_us(int64_t value) {
  _internal_set_wallclock_us(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkEvent.wallclock_us)
}

// -------------------------------------------------------------------

// BestAccelerationDecision

// optional int32 number_of_source_events = 1;
inline bool BestAccelerationDecision::_internal_has_number_of_source_events() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool BestAccelerationDecision::has_number_of_source_events() const {
  return _internal_has_number_of_source_events();
}
inline void BestAccelerationDecision::clear_number_of_source_events() {
  number_of_source_events_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t BestAccelerationDecision::_internal_number_of_source_events() const {
  return number_of_source_events_;
}
inline int32_t BestAccelerationDecision::number_of_source_events() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BestAccelerationDecision.number_of_source_events)
  return _internal_number_of_source_events();
}
inline void BestAccelerationDecision::_internal_set_number_of_source_events(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  number_of_source_events_ = value;
}
inline void BestAccelerationDecision::set_number_of_source_events(int32_t value) {
  _internal_set_number_of_source_events(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BestAccelerationDecision.number_of_source_events)
}

// optional .tflite.proto.BenchmarkEvent min_latency_event = 2;
inline bool BestAccelerationDecision::_internal_has_min_latency_event() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || min_latency_event_ != nullptr);
  return value;
}
inline bool BestAccelerationDecision::has_min_latency_event() const {
  return _internal_has_min_latency_event();
}
inline void BestAccelerationDecision::clear_min_latency_event() {
  if (min_latency_event_ != nullptr) min_latency_event_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::tflite::proto::BenchmarkEvent& BestAccelerationDecision::_internal_min_latency_event() const {
  const ::tflite::proto::BenchmarkEvent* p = min_latency_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BenchmarkEvent&>(
      ::tflite::proto::_BenchmarkEvent_default_instance_);
}
inline const ::tflite::proto::BenchmarkEvent& BestAccelerationDecision::min_latency_event() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BestAccelerationDecision.min_latency_event)
  return _internal_min_latency_event();
}
inline void BestAccelerationDecision::unsafe_arena_set_allocated_min_latency_event(
    ::tflite::proto::BenchmarkEvent* min_latency_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(min_latency_event_);
  }
  min_latency_event_ = min_latency_event;
  if (min_latency_event) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.BestAccelerationDecision.min_latency_event)
}
inline ::tflite::proto::BenchmarkEvent* BestAccelerationDecision::release_min_latency_event() {
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::BenchmarkEvent* temp = min_latency_event_;
  min_latency_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BenchmarkEvent* BestAccelerationDecision::unsafe_arena_release_min_latency_event() {
  // @@protoc_insertion_point(field_release:tflite.proto.BestAccelerationDecision.min_latency_event)
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::BenchmarkEvent* temp = min_latency_event_;
  min_latency_event_ = nullptr;
  return temp;
}
inline ::tflite::proto::BenchmarkEvent* BestAccelerationDecision::_internal_mutable_min_latency_event() {
  _has_bits_[0] |= 0x00000001u;
  if (min_latency_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BenchmarkEvent>(GetArenaForAllocation());
    min_latency_event_ = p;
  }
  return min_latency_event_;
}
inline ::tflite::proto::BenchmarkEvent* BestAccelerationDecision::mutable_min_latency_event() {
  ::tflite::proto::BenchmarkEvent* _msg = _internal_mutable_min_latency_event();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BestAccelerationDecision.min_latency_event)
  return _msg;
}
inline void BestAccelerationDecision::set_allocated_min_latency_event(::tflite::proto::BenchmarkEvent* min_latency_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete min_latency_event_;
  }
  if (min_latency_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(min_latency_event);
    if (message_arena != submessage_arena) {
      min_latency_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, min_latency_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  min_latency_event_ = min_latency_event;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BestAccelerationDecision.min_latency_event)
}

// optional int64 min_inference_time_us = 3;
inline bool BestAccelerationDecision::_internal_has_min_inference_time_us() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BestAccelerationDecision::has_min_inference_time_us() const {
  return _internal_has_min_inference_time_us();
}
inline void BestAccelerationDecision::clear_min_inference_time_us() {
  min_inference_time_us_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t BestAccelerationDecision::_internal_min_inference_time_us() const {
  return min_inference_time_us_;
}
inline int64_t BestAccelerationDecision::min_inference_time_us() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BestAccelerationDecision.min_inference_time_us)
  return _internal_min_inference_time_us();
}
inline void BestAccelerationDecision::_internal_set_min_inference_time_us(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  min_inference_time_us_ = value;
}
inline void BestAccelerationDecision::set_min_inference_time_us(int64_t value) {
  _internal_set_min_inference_time_us(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BestAccelerationDecision.min_inference_time_us)
}

// -------------------------------------------------------------------

// BenchmarkInitializationFailure

// optional int32 initialization_status = 1;
inline bool BenchmarkInitializationFailure::_internal_has_initialization_status() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BenchmarkInitializationFailure::has_initialization_status() const {
  return _internal_has_initialization_status();
}
inline void BenchmarkInitializationFailure::clear_initialization_status() {
  initialization_status_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t BenchmarkInitializationFailure::_internal_initialization_status() const {
  return initialization_status_;
}
inline int32_t BenchmarkInitializationFailure::initialization_status() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkInitializationFailure.initialization_status)
  return _internal_initialization_status();
}
inline void BenchmarkInitializationFailure::_internal_set_initialization_status(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  initialization_status_ = value;
}
inline void BenchmarkInitializationFailure::set_initialization_status(int32_t value) {
  _internal_set_initialization_status(value);
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkInitializationFailure.initialization_status)
}

// -------------------------------------------------------------------

// MiniBenchmarkEvent

// optional bool is_log_flushing_event = 1;
inline bool MiniBenchmarkEvent::_internal_has_is_log_flushing_event() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MiniBenchmarkEvent::has_is_log_flushing_event() const {
  return _internal_has_is_log_flushing_event();
}
inline void MiniBenchmarkEvent::clear_is_log_flushing_event() {
  is_log_flushing_event_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool MiniBenchmarkEvent::_internal_is_log_flushing_event() const {
  return is_log_flushing_event_;
}
inline bool MiniBenchmarkEvent::is_log_flushing_event() const {
  // @@protoc_insertion_point(field_get:tflite.proto.MiniBenchmarkEvent.is_log_flushing_event)
  return _internal_is_log_flushing_event();
}
inline void MiniBenchmarkEvent::_internal_set_is_log_flushing_event(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_log_flushing_event_ = value;
}
inline void MiniBenchmarkEvent::set_is_log_flushing_event(bool value) {
  _internal_set_is_log_flushing_event(value);
  // @@protoc_insertion_point(field_set:tflite.proto.MiniBenchmarkEvent.is_log_flushing_event)
}

// optional .tflite.proto.BestAccelerationDecision best_acceleration_decision = 2;
inline bool MiniBenchmarkEvent::_internal_has_best_acceleration_decision() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || best_acceleration_decision_ != nullptr);
  return value;
}
inline bool MiniBenchmarkEvent::has_best_acceleration_decision() const {
  return _internal_has_best_acceleration_decision();
}
inline void MiniBenchmarkEvent::clear_best_acceleration_decision() {
  if (best_acceleration_decision_ != nullptr) best_acceleration_decision_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::tflite::proto::BestAccelerationDecision& MiniBenchmarkEvent::_internal_best_acceleration_decision() const {
  const ::tflite::proto::BestAccelerationDecision* p = best_acceleration_decision_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BestAccelerationDecision&>(
      ::tflite::proto::_BestAccelerationDecision_default_instance_);
}
inline const ::tflite::proto::BestAccelerationDecision& MiniBenchmarkEvent::best_acceleration_decision() const {
  // @@protoc_insertion_point(field_get:tflite.proto.MiniBenchmarkEvent.best_acceleration_decision)
  return _internal_best_acceleration_decision();
}
inline void MiniBenchmarkEvent::unsafe_arena_set_allocated_best_acceleration_decision(
    ::tflite::proto::BestAccelerationDecision* best_acceleration_decision) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(best_acceleration_decision_);
  }
  best_acceleration_decision_ = best_acceleration_decision;
  if (best_acceleration_decision) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.MiniBenchmarkEvent.best_acceleration_decision)
}
inline ::tflite::proto::BestAccelerationDecision* MiniBenchmarkEvent::release_best_acceleration_decision() {
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::BestAccelerationDecision* temp = best_acceleration_decision_;
  best_acceleration_decision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BestAccelerationDecision* MiniBenchmarkEvent::unsafe_arena_release_best_acceleration_decision() {
  // @@protoc_insertion_point(field_release:tflite.proto.MiniBenchmarkEvent.best_acceleration_decision)
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::BestAccelerationDecision* temp = best_acceleration_decision_;
  best_acceleration_decision_ = nullptr;
  return temp;
}
inline ::tflite::proto::BestAccelerationDecision* MiniBenchmarkEvent::_internal_mutable_best_acceleration_decision() {
  _has_bits_[0] |= 0x00000001u;
  if (best_acceleration_decision_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BestAccelerationDecision>(GetArenaForAllocation());
    best_acceleration_decision_ = p;
  }
  return best_acceleration_decision_;
}
inline ::tflite::proto::BestAccelerationDecision* MiniBenchmarkEvent::mutable_best_acceleration_decision() {
  ::tflite::proto::BestAccelerationDecision* _msg = _internal_mutable_best_acceleration_decision();
  // @@protoc_insertion_point(field_mutable:tflite.proto.MiniBenchmarkEvent.best_acceleration_decision)
  return _msg;
}
inline void MiniBenchmarkEvent::set_allocated_best_acceleration_decision(::tflite::proto::BestAccelerationDecision* best_acceleration_decision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete best_acceleration_decision_;
  }
  if (best_acceleration_decision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(best_acceleration_decision);
    if (message_arena != submessage_arena) {
      best_acceleration_decision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, best_acceleration_decision, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  best_acceleration_decision_ = best_acceleration_decision;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.MiniBenchmarkEvent.best_acceleration_decision)
}

// optional .tflite.proto.BenchmarkInitializationFailure initialization_failure = 3;
inline bool MiniBenchmarkEvent::_internal_has_initialization_failure() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || initialization_failure_ != nullptr);
  return value;
}
inline bool MiniBenchmarkEvent::has_initialization_failure() const {
  return _internal_has_initialization_failure();
}
inline void MiniBenchmarkEvent::clear_initialization_failure() {
  if (initialization_failure_ != nullptr) initialization_failure_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::tflite::proto::BenchmarkInitializationFailure& MiniBenchmarkEvent::_internal_initialization_failure() const {
  const ::tflite::proto::BenchmarkInitializationFailure* p = initialization_failure_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BenchmarkInitializationFailure&>(
      ::tflite::proto::_BenchmarkInitializationFailure_default_instance_);
}
inline const ::tflite::proto::BenchmarkInitializationFailure& MiniBenchmarkEvent::initialization_failure() const {
  // @@protoc_insertion_point(field_get:tflite.proto.MiniBenchmarkEvent.initialization_failure)
  return _internal_initialization_failure();
}
inline void MiniBenchmarkEvent::unsafe_arena_set_allocated_initialization_failure(
    ::tflite::proto::BenchmarkInitializationFailure* initialization_failure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(initialization_failure_);
  }
  initialization_failure_ = initialization_failure;
  if (initialization_failure) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.MiniBenchmarkEvent.initialization_failure)
}
inline ::tflite::proto::BenchmarkInitializationFailure* MiniBenchmarkEvent::release_initialization_failure() {
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::BenchmarkInitializationFailure* temp = initialization_failure_;
  initialization_failure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BenchmarkInitializationFailure* MiniBenchmarkEvent::unsafe_arena_release_initialization_failure() {
  // @@protoc_insertion_point(field_release:tflite.proto.MiniBenchmarkEvent.initialization_failure)
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::BenchmarkInitializationFailure* temp = initialization_failure_;
  initialization_failure_ = nullptr;
  return temp;
}
inline ::tflite::proto::BenchmarkInitializationFailure* MiniBenchmarkEvent::_internal_mutable_initialization_failure() {
  _has_bits_[0] |= 0x00000002u;
  if (initialization_failure_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BenchmarkInitializationFailure>(GetArenaForAllocation());
    initialization_failure_ = p;
  }
  return initialization_failure_;
}
inline ::tflite::proto::BenchmarkInitializationFailure* MiniBenchmarkEvent::mutable_initialization_failure() {
  ::tflite::proto::BenchmarkInitializationFailure* _msg = _internal_mutable_initialization_failure();
  // @@protoc_insertion_point(field_mutable:tflite.proto.MiniBenchmarkEvent.initialization_failure)
  return _msg;
}
inline void MiniBenchmarkEvent::set_allocated_initialization_failure(::tflite::proto::BenchmarkInitializationFailure* initialization_failure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete initialization_failure_;
  }
  if (initialization_failure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(initialization_failure);
    if (message_arena != submessage_arena) {
      initialization_failure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, initialization_failure, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  initialization_failure_ = initialization_failure;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.MiniBenchmarkEvent.initialization_failure)
}

// optional .tflite.proto.BenchmarkEvent benchmark_event = 4;
inline bool MiniBenchmarkEvent::_internal_has_benchmark_event() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || benchmark_event_ != nullptr);
  return value;
}
inline bool MiniBenchmarkEvent::has_benchmark_event() const {
  return _internal_has_benchmark_event();
}
inline void MiniBenchmarkEvent::clear_benchmark_event() {
  if (benchmark_event_ != nullptr) benchmark_event_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::tflite::proto::BenchmarkEvent& MiniBenchmarkEvent::_internal_benchmark_event() const {
  const ::tflite::proto::BenchmarkEvent* p = benchmark_event_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BenchmarkEvent&>(
      ::tflite::proto::_BenchmarkEvent_default_instance_);
}
inline const ::tflite::proto::BenchmarkEvent& MiniBenchmarkEvent::benchmark_event() const {
  // @@protoc_insertion_point(field_get:tflite.proto.MiniBenchmarkEvent.benchmark_event)
  return _internal_benchmark_event();
}
inline void MiniBenchmarkEvent::unsafe_arena_set_allocated_benchmark_event(
    ::tflite::proto::BenchmarkEvent* benchmark_event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(benchmark_event_);
  }
  benchmark_event_ = benchmark_event;
  if (benchmark_event) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.MiniBenchmarkEvent.benchmark_event)
}
inline ::tflite::proto::BenchmarkEvent* MiniBenchmarkEvent::release_benchmark_event() {
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::BenchmarkEvent* temp = benchmark_event_;
  benchmark_event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BenchmarkEvent* MiniBenchmarkEvent::unsafe_arena_release_benchmark_event() {
  // @@protoc_insertion_point(field_release:tflite.proto.MiniBenchmarkEvent.benchmark_event)
  _has_bits_[0] &= ~0x00000004u;
  ::tflite::proto::BenchmarkEvent* temp = benchmark_event_;
  benchmark_event_ = nullptr;
  return temp;
}
inline ::tflite::proto::BenchmarkEvent* MiniBenchmarkEvent::_internal_mutable_benchmark_event() {
  _has_bits_[0] |= 0x00000004u;
  if (benchmark_event_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BenchmarkEvent>(GetArenaForAllocation());
    benchmark_event_ = p;
  }
  return benchmark_event_;
}
inline ::tflite::proto::BenchmarkEvent* MiniBenchmarkEvent::mutable_benchmark_event() {
  ::tflite::proto::BenchmarkEvent* _msg = _internal_mutable_benchmark_event();
  // @@protoc_insertion_point(field_mutable:tflite.proto.MiniBenchmarkEvent.benchmark_event)
  return _msg;
}
inline void MiniBenchmarkEvent::set_allocated_benchmark_event(::tflite::proto::BenchmarkEvent* benchmark_event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete benchmark_event_;
  }
  if (benchmark_event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(benchmark_event);
    if (message_arena != submessage_arena) {
      benchmark_event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, benchmark_event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  benchmark_event_ = benchmark_event;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.MiniBenchmarkEvent.benchmark_event)
}

// -------------------------------------------------------------------

// ModelFile

// optional string filename = 1;
inline bool ModelFile::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelFile::has_filename() const {
  return _internal_has_filename();
}
inline void ModelFile::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelFile::filename() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ModelFile.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelFile::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filename_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.ModelFile.filename)
}
inline std::string* ModelFile::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:tflite.proto.ModelFile.filename)
  return _s;
}
inline const std::string& ModelFile::_internal_filename() const {
  return filename_.Get();
}
inline void ModelFile::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelFile::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelFile::release_filename() {
  // @@protoc_insertion_point(field_release:tflite.proto.ModelFile.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filename_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault()) {
    filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModelFile::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(filename, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault()) {
    filename_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.ModelFile.filename)
}

// optional int64 fd = 2;
inline bool ModelFile::_internal_has_fd() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ModelFile::has_fd() const {
  return _internal_has_fd();
}
inline void ModelFile::clear_fd() {
  fd_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ModelFile::_internal_fd() const {
  return fd_;
}
inline int64_t ModelFile::fd() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ModelFile.fd)
  return _internal_fd();
}
inline void ModelFile::_internal_set_fd(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  fd_ = value;
}
inline void ModelFile::set_fd(int64_t value) {
  _internal_set_fd(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ModelFile.fd)
}

// optional int64 offset = 3;
inline bool ModelFile::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModelFile::has_offset() const {
  return _internal_has_offset();
}
inline void ModelFile::clear_offset() {
  offset_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t ModelFile::_internal_offset() const {
  return offset_;
}
inline int64_t ModelFile::offset() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ModelFile.offset)
  return _internal_offset();
}
inline void ModelFile::_internal_set_offset(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
}
inline void ModelFile::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ModelFile.offset)
}

// optional int64 length = 4;
inline bool ModelFile::_internal_has_length() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModelFile::has_length() const {
  return _internal_has_length();
}
inline void ModelFile::clear_length() {
  length_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t ModelFile::_internal_length() const {
  return length_;
}
inline int64_t ModelFile::length() const {
  // @@protoc_insertion_point(field_get:tflite.proto.ModelFile.length)
  return _internal_length();
}
inline void ModelFile::_internal_set_length(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  length_ = value;
}
inline void ModelFile::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:tflite.proto.ModelFile.length)
}

// -------------------------------------------------------------------

// BenchmarkStoragePaths

// optional string storage_file_path = 1;
inline bool BenchmarkStoragePaths::_internal_has_storage_file_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool BenchmarkStoragePaths::has_storage_file_path() const {
  return _internal_has_storage_file_path();
}
inline void BenchmarkStoragePaths::clear_storage_file_path() {
  storage_file_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& BenchmarkStoragePaths::storage_file_path() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkStoragePaths.storage_file_path)
  return _internal_storage_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BenchmarkStoragePaths::set_storage_file_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 storage_file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkStoragePaths.storage_file_path)
}
inline std::string* BenchmarkStoragePaths::mutable_storage_file_path() {
  std::string* _s = _internal_mutable_storage_file_path();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkStoragePaths.storage_file_path)
  return _s;
}
inline const std::string& BenchmarkStoragePaths::_internal_storage_file_path() const {
  return storage_file_path_.Get();
}
inline void BenchmarkStoragePaths::_internal_set_storage_file_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  storage_file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* BenchmarkStoragePaths::_internal_mutable_storage_file_path() {
  _has_bits_[0] |= 0x00000001u;
  return storage_file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* BenchmarkStoragePaths::release_storage_file_path() {
  // @@protoc_insertion_point(field_release:tflite.proto.BenchmarkStoragePaths.storage_file_path)
  if (!_internal_has_storage_file_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = storage_file_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storage_file_path_.IsDefault()) {
    storage_file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BenchmarkStoragePaths::set_allocated_storage_file_path(std::string* storage_file_path) {
  if (storage_file_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  storage_file_path_.SetAllocated(storage_file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (storage_file_path_.IsDefault()) {
    storage_file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BenchmarkStoragePaths.storage_file_path)
}

// optional string data_directory_path = 2;
inline bool BenchmarkStoragePaths::_internal_has_data_directory_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool BenchmarkStoragePaths::has_data_directory_path() const {
  return _internal_has_data_directory_path();
}
inline void BenchmarkStoragePaths::clear_data_directory_path() {
  data_directory_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& BenchmarkStoragePaths::data_directory_path() const {
  // @@protoc_insertion_point(field_get:tflite.proto.BenchmarkStoragePaths.data_directory_path)
  return _internal_data_directory_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BenchmarkStoragePaths::set_data_directory_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_directory_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:tflite.proto.BenchmarkStoragePaths.data_directory_path)
}
inline std::string* BenchmarkStoragePaths::mutable_data_directory_path() {
  std::string* _s = _internal_mutable_data_directory_path();
  // @@protoc_insertion_point(field_mutable:tflite.proto.BenchmarkStoragePaths.data_directory_path)
  return _s;
}
inline const std::string& BenchmarkStoragePaths::_internal_data_directory_path() const {
  return data_directory_path_.Get();
}
inline void BenchmarkStoragePaths::_internal_set_data_directory_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_directory_path_.Set(value, GetArenaForAllocation());
}
inline std::string* BenchmarkStoragePaths::_internal_mutable_data_directory_path() {
  _has_bits_[0] |= 0x00000002u;
  return data_directory_path_.Mutable(GetArenaForAllocation());
}
inline std::string* BenchmarkStoragePaths::release_data_directory_path() {
  // @@protoc_insertion_point(field_release:tflite.proto.BenchmarkStoragePaths.data_directory_path)
  if (!_internal_has_data_directory_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_directory_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_directory_path_.IsDefault()) {
    data_directory_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void BenchmarkStoragePaths::set_allocated_data_directory_path(std::string* data_directory_path) {
  if (data_directory_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_directory_path_.SetAllocated(data_directory_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_directory_path_.IsDefault()) {
    data_directory_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.BenchmarkStoragePaths.data_directory_path)
}

// -------------------------------------------------------------------

// MinibenchmarkSettings

// repeated .tflite.proto.TFLiteSettings settings_to_test = 1;
inline int MinibenchmarkSettings::_internal_settings_to_test_size() const {
  return settings_to_test_.size();
}
inline int MinibenchmarkSettings::settings_to_test_size() const {
  return _internal_settings_to_test_size();
}
inline void MinibenchmarkSettings::clear_settings_to_test() {
  settings_to_test_.Clear();
}
inline ::tflite::proto::TFLiteSettings* MinibenchmarkSettings::mutable_settings_to_test(int index) {
  // @@protoc_insertion_point(field_mutable:tflite.proto.MinibenchmarkSettings.settings_to_test)
  return settings_to_test_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::TFLiteSettings >*
MinibenchmarkSettings::mutable_settings_to_test() {
  // @@protoc_insertion_point(field_mutable_list:tflite.proto.MinibenchmarkSettings.settings_to_test)
  return &settings_to_test_;
}
inline const ::tflite::proto::TFLiteSettings& MinibenchmarkSettings::_internal_settings_to_test(int index) const {
  return settings_to_test_.Get(index);
}
inline const ::tflite::proto::TFLiteSettings& MinibenchmarkSettings::settings_to_test(int index) const {
  // @@protoc_insertion_point(field_get:tflite.proto.MinibenchmarkSettings.settings_to_test)
  return _internal_settings_to_test(index);
}
inline ::tflite::proto::TFLiteSettings* MinibenchmarkSettings::_internal_add_settings_to_test() {
  return settings_to_test_.Add();
}
inline ::tflite::proto::TFLiteSettings* MinibenchmarkSettings::add_settings_to_test() {
  ::tflite::proto::TFLiteSettings* _add = _internal_add_settings_to_test();
  // @@protoc_insertion_point(field_add:tflite.proto.MinibenchmarkSettings.settings_to_test)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::tflite::proto::TFLiteSettings >&
MinibenchmarkSettings::settings_to_test() const {
  // @@protoc_insertion_point(field_list:tflite.proto.MinibenchmarkSettings.settings_to_test)
  return settings_to_test_;
}

// optional .tflite.proto.ModelFile model_file = 2;
inline bool MinibenchmarkSettings::_internal_has_model_file() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || model_file_ != nullptr);
  return value;
}
inline bool MinibenchmarkSettings::has_model_file() const {
  return _internal_has_model_file();
}
inline void MinibenchmarkSettings::clear_model_file() {
  if (model_file_ != nullptr) model_file_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::tflite::proto::ModelFile& MinibenchmarkSettings::_internal_model_file() const {
  const ::tflite::proto::ModelFile* p = model_file_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::ModelFile&>(
      ::tflite::proto::_ModelFile_default_instance_);
}
inline const ::tflite::proto::ModelFile& MinibenchmarkSettings::model_file() const {
  // @@protoc_insertion_point(field_get:tflite.proto.MinibenchmarkSettings.model_file)
  return _internal_model_file();
}
inline void MinibenchmarkSettings::unsafe_arena_set_allocated_model_file(
    ::tflite::proto::ModelFile* model_file) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_file_);
  }
  model_file_ = model_file;
  if (model_file) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.MinibenchmarkSettings.model_file)
}
inline ::tflite::proto::ModelFile* MinibenchmarkSettings::release_model_file() {
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::ModelFile* temp = model_file_;
  model_file_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::ModelFile* MinibenchmarkSettings::unsafe_arena_release_model_file() {
  // @@protoc_insertion_point(field_release:tflite.proto.MinibenchmarkSettings.model_file)
  _has_bits_[0] &= ~0x00000001u;
  ::tflite::proto::ModelFile* temp = model_file_;
  model_file_ = nullptr;
  return temp;
}
inline ::tflite::proto::ModelFile* MinibenchmarkSettings::_internal_mutable_model_file() {
  _has_bits_[0] |= 0x00000001u;
  if (model_file_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::ModelFile>(GetArenaForAllocation());
    model_file_ = p;
  }
  return model_file_;
}
inline ::tflite::proto::ModelFile* MinibenchmarkSettings::mutable_model_file() {
  ::tflite::proto::ModelFile* _msg = _internal_mutable_model_file();
  // @@protoc_insertion_point(field_mutable:tflite.proto.MinibenchmarkSettings.model_file)
  return _msg;
}
inline void MinibenchmarkSettings::set_allocated_model_file(::tflite::proto::ModelFile* model_file) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete model_file_;
  }
  if (model_file) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_file);
    if (message_arena != submessage_arena) {
      model_file = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_file, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_file_ = model_file;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.MinibenchmarkSettings.model_file)
}

// optional .tflite.proto.BenchmarkStoragePaths storage_paths = 3;
inline bool MinibenchmarkSettings::_internal_has_storage_paths() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || storage_paths_ != nullptr);
  return value;
}
inline bool MinibenchmarkSettings::has_storage_paths() const {
  return _internal_has_storage_paths();
}
inline void MinibenchmarkSettings::clear_storage_paths() {
  if (storage_paths_ != nullptr) storage_paths_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::tflite::proto::BenchmarkStoragePaths& MinibenchmarkSettings::_internal_storage_paths() const {
  const ::tflite::proto::BenchmarkStoragePaths* p = storage_paths_;
  return p != nullptr ? *p : reinterpret_cast<const ::tflite::proto::BenchmarkStoragePaths&>(
      ::tflite::proto::_BenchmarkStoragePaths_default_instance_);
}
inline const ::tflite::proto::BenchmarkStoragePaths& MinibenchmarkSettings::storage_paths() const {
  // @@protoc_insertion_point(field_get:tflite.proto.MinibenchmarkSettings.storage_paths)
  return _internal_storage_paths();
}
inline void MinibenchmarkSettings::unsafe_arena_set_allocated_storage_paths(
    ::tflite::proto::BenchmarkStoragePaths* storage_paths) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(storage_paths_);
  }
  storage_paths_ = storage_paths;
  if (storage_paths) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:tflite.proto.MinibenchmarkSettings.storage_paths)
}
inline ::tflite::proto::BenchmarkStoragePaths* MinibenchmarkSettings::release_storage_paths() {
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::BenchmarkStoragePaths* temp = storage_paths_;
  storage_paths_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::tflite::proto::BenchmarkStoragePaths* MinibenchmarkSettings::unsafe_arena_release_storage_paths() {
  // @@protoc_insertion_point(field_release:tflite.proto.MinibenchmarkSettings.storage_paths)
  _has_bits_[0] &= ~0x00000002u;
  ::tflite::proto::BenchmarkStoragePaths* temp = storage_paths_;
  storage_paths_ = nullptr;
  return temp;
}
inline ::tflite::proto::BenchmarkStoragePaths* MinibenchmarkSettings::_internal_mutable_storage_paths() {
  _has_bits_[0] |= 0x00000002u;
  if (storage_paths_ == nullptr) {
    auto* p = CreateMaybeMessage<::tflite::proto::BenchmarkStoragePaths>(GetArenaForAllocation());
    storage_paths_ = p;
  }
  return storage_paths_;
}
inline ::tflite::proto::BenchmarkStoragePaths* MinibenchmarkSettings::mutable_storage_paths() {
  ::tflite::proto::BenchmarkStoragePaths* _msg = _internal_mutable_storage_paths();
  // @@protoc_insertion_point(field_mutable:tflite.proto.MinibenchmarkSettings.storage_paths)
  return _msg;
}
inline void MinibenchmarkSettings::set_allocated_storage_paths(::tflite::proto::BenchmarkStoragePaths* storage_paths) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete storage_paths_;
  }
  if (storage_paths) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(storage_paths);
    if (message_arena != submessage_arena) {
      storage_paths = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, storage_paths, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  storage_paths_ = storage_paths;
  // @@protoc_insertion_point(field_set_allocated:tflite.proto.MinibenchmarkSettings.storage_paths)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace tflite

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::tflite::proto::CoreMLSettings_EnabledDevices> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::EdgeTpuDeviceSpec_PlatformType> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::EdgeTpuSettings_FloatTruncationType> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::EdgeTpuSettings_QosClass> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::CoralSettings_Performance> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::ExecutionPreference> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::Delegate> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::NNAPIExecutionPreference> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::NNAPIExecutionPriority> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::GPUBackend> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::GPUInferencePriority> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::GPUInferenceUsage> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::XNNPackFlags> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::EdgeTpuPowerState> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::BenchmarkEventType> : ::std::true_type {};
template <> struct is_proto_enum< ::tflite::proto::BenchmarkStage> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_tensorflow_2flite_2fexperimental_2facceleration_2fconfiguration_2fconfiguration_2eproto
