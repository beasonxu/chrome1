// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/lite/experimental/acceleration/configuration/configuration.proto

#include "tensorflow/lite/experimental/acceleration/configuration/configuration.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace tflite {
namespace proto {
PROTOBUF_CONSTEXPR ComputeSettings::ComputeSettings(
    ::_pbi::ConstantInitialized)
  : model_namespace_for_statistics_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_identifier_for_statistics_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , tflite_settings_(nullptr)
  , settings_to_test_locally_(nullptr)
  , preference_(0)
{}
struct ComputeSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ComputeSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ComputeSettingsDefaultTypeInternal() {}
  union {
    ComputeSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ComputeSettingsDefaultTypeInternal _ComputeSettings_default_instance_;
PROTOBUF_CONSTEXPR NNAPISettings::NNAPISettings(
    ::_pbi::ConstantInitialized)
  : accelerator_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cache_directory_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , fallback_settings_(nullptr)
  , execution_preference_(0)

  , no_of_nnapi_instances_to_cache_(0)
  , execution_priority_(0)

  , allow_nnapi_cpu_on_android_10_plus_(false)
  , allow_dynamic_dimensions_(false)
  , allow_fp16_precision_for_fp32_(false)
  , use_burst_computation_(false)
  , support_library_handle_(int64_t{0}){}
struct NNAPISettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NNAPISettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NNAPISettingsDefaultTypeInternal() {}
  union {
    NNAPISettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NNAPISettingsDefaultTypeInternal _NNAPISettings_default_instance_;
PROTOBUF_CONSTEXPR GPUSettings::GPUSettings(
    ::_pbi::ConstantInitialized)
  : cache_directory_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , model_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , is_precision_loss_allowed_(false)
  , force_backend_(0)

  , inference_priority1_(0)

  , inference_priority2_(0)

  , inference_priority3_(0)

  , inference_preference_(0)

  , enable_quantized_inference_(true){}
struct GPUSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GPUSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GPUSettingsDefaultTypeInternal() {}
  union {
    GPUSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GPUSettingsDefaultTypeInternal _GPUSettings_default_instance_;
PROTOBUF_CONSTEXPR HexagonSettings::HexagonSettings(
    ::_pbi::ConstantInitialized)
  : debug_level_(0)
  , powersave_level_(0)
  , print_graph_profile_(false)
  , print_graph_debug_(false){}
struct HexagonSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HexagonSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HexagonSettingsDefaultTypeInternal() {}
  union {
    HexagonSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HexagonSettingsDefaultTypeInternal _HexagonSettings_default_instance_;
PROTOBUF_CONSTEXPR XNNPackSettings::XNNPackSettings(
    ::_pbi::ConstantInitialized)
  : num_threads_(0)
  , flags_(0)
{}
struct XNNPackSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR XNNPackSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~XNNPackSettingsDefaultTypeInternal() {}
  union {
    XNNPackSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 XNNPackSettingsDefaultTypeInternal _XNNPackSettings_default_instance_;
PROTOBUF_CONSTEXPR CoreMLSettings::CoreMLSettings(
    ::_pbi::ConstantInitialized)
  : enabled_devices_(0)

  , coreml_version_(0)
  , max_delegated_partitions_(0)
  , min_nodes_per_partition_(2){}
struct CoreMLSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoreMLSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoreMLSettingsDefaultTypeInternal() {}
  union {
    CoreMLSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoreMLSettingsDefaultTypeInternal _CoreMLSettings_default_instance_;
PROTOBUF_CONSTEXPR EdgeTpuDeviceSpec::EdgeTpuDeviceSpec(
    ::_pbi::ConstantInitialized)
  : device_paths_()
  , platform_type_(0)

  , num_chips_(0)
  , chip_family_(0){}
struct EdgeTpuDeviceSpecDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeTpuDeviceSpecDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeTpuDeviceSpecDefaultTypeInternal() {}
  union {
    EdgeTpuDeviceSpec _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeTpuDeviceSpecDefaultTypeInternal _EdgeTpuDeviceSpec_default_instance_;
PROTOBUF_CONSTEXPR EdgeTpuInactivePowerConfig::EdgeTpuInactivePowerConfig(
    ::_pbi::ConstantInitialized)
  : inactive_timeout_us_(int64_t{0})
  , inactive_power_state_(0)
{}
struct EdgeTpuInactivePowerConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeTpuInactivePowerConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeTpuInactivePowerConfigDefaultTypeInternal() {}
  union {
    EdgeTpuInactivePowerConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeTpuInactivePowerConfigDefaultTypeInternal _EdgeTpuInactivePowerConfig_default_instance_;
PROTOBUF_CONSTEXPR EdgeTpuSettings::EdgeTpuSettings(
    ::_pbi::ConstantInitialized)
  : inactive_power_configs_()
  , model_token_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , edgetpu_device_spec_(nullptr)
  , inference_power_state_(0)

  , float_truncation_type_(0)

  , qos_class_(0)

  , inference_priority_(-1){}
struct EdgeTpuSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EdgeTpuSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EdgeTpuSettingsDefaultTypeInternal() {}
  union {
    EdgeTpuSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EdgeTpuSettingsDefaultTypeInternal _EdgeTpuSettings_default_instance_;
PROTOBUF_CONSTEXPR CoralSettings::CoralSettings(
    ::_pbi::ConstantInitialized)
  : device_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , usb_always_dfu_(false)
  , usb_max_bulk_in_queue_length_(0)
  , performance_(1)
{}
struct CoralSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CoralSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CoralSettingsDefaultTypeInternal() {}
  union {
    CoralSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CoralSettingsDefaultTypeInternal _CoralSettings_default_instance_;
PROTOBUF_CONSTEXPR CPUSettings::CPUSettings(
    ::_pbi::ConstantInitialized)
  : num_threads_(-1){}
struct CPUSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CPUSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CPUSettingsDefaultTypeInternal() {}
  union {
    CPUSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CPUSettingsDefaultTypeInternal _CPUSettings_default_instance_;
PROTOBUF_CONSTEXPR TFLiteSettings::TFLiteSettings(
    ::_pbi::ConstantInitialized)
  : nnapi_settings_(nullptr)
  , gpu_settings_(nullptr)
  , hexagon_settings_(nullptr)
  , xnnpack_settings_(nullptr)
  , cpu_settings_(nullptr)
  , edgetpu_settings_(nullptr)
  , fallback_settings_(nullptr)
  , coral_settings_(nullptr)
  , coreml_settings_(nullptr)
  , delegate_(0)

  , max_delegated_partitions_(0)
  , disable_default_delegates_(false){}
struct TFLiteSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TFLiteSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TFLiteSettingsDefaultTypeInternal() {}
  union {
    TFLiteSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TFLiteSettingsDefaultTypeInternal _TFLiteSettings_default_instance_;
PROTOBUF_CONSTEXPR FallbackSettings::FallbackSettings(
    ::_pbi::ConstantInitialized)
  : allow_automatic_fallback_on_compilation_error_(false)
  , allow_automatic_fallback_on_execution_error_(false){}
struct FallbackSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FallbackSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FallbackSettingsDefaultTypeInternal() {}
  union {
    FallbackSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FallbackSettingsDefaultTypeInternal _FallbackSettings_default_instance_;
PROTOBUF_CONSTEXPR BenchmarkMetric::BenchmarkMetric(
    ::_pbi::ConstantInitialized)
  : values_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct BenchmarkMetricDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BenchmarkMetricDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BenchmarkMetricDefaultTypeInternal() {}
  union {
    BenchmarkMetric _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BenchmarkMetricDefaultTypeInternal _BenchmarkMetric_default_instance_;
PROTOBUF_CONSTEXPR BenchmarkResult::BenchmarkResult(
    ::_pbi::ConstantInitialized)
  : initialization_time_us_()
  , _initialization_time_us_cached_byte_size_(0)
  , inference_time_us_()
  , _inference_time_us_cached_byte_size_(0)
  , metrics_()
  , max_memory_kb_(0)
  , ok_(false){}
struct BenchmarkResultDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BenchmarkResultDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BenchmarkResultDefaultTypeInternal() {}
  union {
    BenchmarkResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BenchmarkResultDefaultTypeInternal _BenchmarkResult_default_instance_;
PROTOBUF_CONSTEXPR ErrorCode::ErrorCode(
    ::_pbi::ConstantInitialized)
  : source_(0)

  , tflite_error_(0)
  , underlying_api_error_(int64_t{0}){}
struct ErrorCodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ErrorCodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ErrorCodeDefaultTypeInternal() {}
  union {
    ErrorCode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ErrorCodeDefaultTypeInternal _ErrorCode_default_instance_;
PROTOBUF_CONSTEXPR BenchmarkError::BenchmarkError(
    ::_pbi::ConstantInitialized)
  : error_code_()
  , stage_(0)

  , exit_code_(0)
  , signal_(0)
  , mini_benchmark_error_code_(0){}
struct BenchmarkErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BenchmarkErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BenchmarkErrorDefaultTypeInternal() {}
  union {
    BenchmarkError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BenchmarkErrorDefaultTypeInternal _BenchmarkError_default_instance_;
PROTOBUF_CONSTEXPR BenchmarkEvent::BenchmarkEvent(
    ::_pbi::ConstantInitialized)
  : tflite_settings_(nullptr)
  , result_(nullptr)
  , error_(nullptr)
  , boottime_us_(int64_t{0})
  , wallclock_us_(int64_t{0})
  , event_type_(0)
{}
struct BenchmarkEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BenchmarkEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BenchmarkEventDefaultTypeInternal() {}
  union {
    BenchmarkEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BenchmarkEventDefaultTypeInternal _BenchmarkEvent_default_instance_;
PROTOBUF_CONSTEXPR BestAccelerationDecision::BestAccelerationDecision(
    ::_pbi::ConstantInitialized)
  : min_latency_event_(nullptr)
  , min_inference_time_us_(int64_t{0})
  , number_of_source_events_(0){}
struct BestAccelerationDecisionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BestAccelerationDecisionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BestAccelerationDecisionDefaultTypeInternal() {}
  union {
    BestAccelerationDecision _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BestAccelerationDecisionDefaultTypeInternal _BestAccelerationDecision_default_instance_;
PROTOBUF_CONSTEXPR BenchmarkInitializationFailure::BenchmarkInitializationFailure(
    ::_pbi::ConstantInitialized)
  : initialization_status_(0){}
struct BenchmarkInitializationFailureDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BenchmarkInitializationFailureDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BenchmarkInitializationFailureDefaultTypeInternal() {}
  union {
    BenchmarkInitializationFailure _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BenchmarkInitializationFailureDefaultTypeInternal _BenchmarkInitializationFailure_default_instance_;
PROTOBUF_CONSTEXPR MiniBenchmarkEvent::MiniBenchmarkEvent(
    ::_pbi::ConstantInitialized)
  : best_acceleration_decision_(nullptr)
  , initialization_failure_(nullptr)
  , benchmark_event_(nullptr)
  , is_log_flushing_event_(false){}
struct MiniBenchmarkEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MiniBenchmarkEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MiniBenchmarkEventDefaultTypeInternal() {}
  union {
    MiniBenchmarkEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MiniBenchmarkEventDefaultTypeInternal _MiniBenchmarkEvent_default_instance_;
PROTOBUF_CONSTEXPR ModelFile::ModelFile(
    ::_pbi::ConstantInitialized)
  : filename_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , fd_(int64_t{0})
  , offset_(int64_t{0})
  , length_(int64_t{0}){}
struct ModelFileDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ModelFileDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ModelFileDefaultTypeInternal() {}
  union {
    ModelFile _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ModelFileDefaultTypeInternal _ModelFile_default_instance_;
PROTOBUF_CONSTEXPR BenchmarkStoragePaths::BenchmarkStoragePaths(
    ::_pbi::ConstantInitialized)
  : storage_file_path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , data_directory_path_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct BenchmarkStoragePathsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BenchmarkStoragePathsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BenchmarkStoragePathsDefaultTypeInternal() {}
  union {
    BenchmarkStoragePaths _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BenchmarkStoragePathsDefaultTypeInternal _BenchmarkStoragePaths_default_instance_;
PROTOBUF_CONSTEXPR MinibenchmarkSettings::MinibenchmarkSettings(
    ::_pbi::ConstantInitialized)
  : settings_to_test_()
  , model_file_(nullptr)
  , storage_paths_(nullptr){}
struct MinibenchmarkSettingsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MinibenchmarkSettingsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MinibenchmarkSettingsDefaultTypeInternal() {}
  union {
    MinibenchmarkSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MinibenchmarkSettingsDefaultTypeInternal _MinibenchmarkSettings_default_instance_;
}  // namespace proto
}  // namespace tflite
namespace tflite {
namespace proto {
bool CoreMLSettings_EnabledDevices_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CoreMLSettings_EnabledDevices_strings[2] = {};

static const char CoreMLSettings_EnabledDevices_names[] =
  "DEVICES_ALL"
  "DEVICES_WITH_NEURAL_ENGINE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CoreMLSettings_EnabledDevices_entries[] = {
  { {CoreMLSettings_EnabledDevices_names + 0, 11}, 0 },
  { {CoreMLSettings_EnabledDevices_names + 11, 26}, 1 },
};

static const int CoreMLSettings_EnabledDevices_entries_by_number[] = {
  0, // 0 -> DEVICES_ALL
  1, // 1 -> DEVICES_WITH_NEURAL_ENGINE
};

const std::string& CoreMLSettings_EnabledDevices_Name(
    CoreMLSettings_EnabledDevices value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CoreMLSettings_EnabledDevices_entries,
          CoreMLSettings_EnabledDevices_entries_by_number,
          2, CoreMLSettings_EnabledDevices_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CoreMLSettings_EnabledDevices_entries,
      CoreMLSettings_EnabledDevices_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CoreMLSettings_EnabledDevices_strings[idx].get();
}
bool CoreMLSettings_EnabledDevices_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CoreMLSettings_EnabledDevices* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CoreMLSettings_EnabledDevices_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<CoreMLSettings_EnabledDevices>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CoreMLSettings_EnabledDevices CoreMLSettings::DEVICES_ALL;
constexpr CoreMLSettings_EnabledDevices CoreMLSettings::DEVICES_WITH_NEURAL_ENGINE;
constexpr CoreMLSettings_EnabledDevices CoreMLSettings::EnabledDevices_MIN;
constexpr CoreMLSettings_EnabledDevices CoreMLSettings::EnabledDevices_MAX;
constexpr int CoreMLSettings::EnabledDevices_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EdgeTpuDeviceSpec_PlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EdgeTpuDeviceSpec_PlatformType_strings[4] = {};

static const char EdgeTpuDeviceSpec_PlatformType_names[] =
  "MMIO"
  "REFERENCE"
  "REMOTE_SIMULATOR"
  "SIMULATOR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EdgeTpuDeviceSpec_PlatformType_entries[] = {
  { {EdgeTpuDeviceSpec_PlatformType_names + 0, 4}, 0 },
  { {EdgeTpuDeviceSpec_PlatformType_names + 4, 9}, 1 },
  { {EdgeTpuDeviceSpec_PlatformType_names + 13, 16}, 3 },
  { {EdgeTpuDeviceSpec_PlatformType_names + 29, 9}, 2 },
};

static const int EdgeTpuDeviceSpec_PlatformType_entries_by_number[] = {
  0, // 0 -> MMIO
  1, // 1 -> REFERENCE
  3, // 2 -> SIMULATOR
  2, // 3 -> REMOTE_SIMULATOR
};

const std::string& EdgeTpuDeviceSpec_PlatformType_Name(
    EdgeTpuDeviceSpec_PlatformType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EdgeTpuDeviceSpec_PlatformType_entries,
          EdgeTpuDeviceSpec_PlatformType_entries_by_number,
          4, EdgeTpuDeviceSpec_PlatformType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EdgeTpuDeviceSpec_PlatformType_entries,
      EdgeTpuDeviceSpec_PlatformType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EdgeTpuDeviceSpec_PlatformType_strings[idx].get();
}
bool EdgeTpuDeviceSpec_PlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuDeviceSpec_PlatformType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EdgeTpuDeviceSpec_PlatformType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EdgeTpuDeviceSpec_PlatformType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::MMIO;
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::REFERENCE;
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::SIMULATOR;
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::REMOTE_SIMULATOR;
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::PlatformType_MIN;
constexpr EdgeTpuDeviceSpec_PlatformType EdgeTpuDeviceSpec::PlatformType_MAX;
constexpr int EdgeTpuDeviceSpec::PlatformType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EdgeTpuSettings_FloatTruncationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EdgeTpuSettings_FloatTruncationType_strings[4] = {};

static const char EdgeTpuSettings_FloatTruncationType_names[] =
  "BFLOAT16"
  "HALF"
  "NO_TRUNCATION"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EdgeTpuSettings_FloatTruncationType_entries[] = {
  { {EdgeTpuSettings_FloatTruncationType_names + 0, 8}, 2 },
  { {EdgeTpuSettings_FloatTruncationType_names + 8, 4}, 3 },
  { {EdgeTpuSettings_FloatTruncationType_names + 12, 13}, 1 },
  { {EdgeTpuSettings_FloatTruncationType_names + 25, 11}, 0 },
};

static const int EdgeTpuSettings_FloatTruncationType_entries_by_number[] = {
  3, // 0 -> UNSPECIFIED
  2, // 1 -> NO_TRUNCATION
  0, // 2 -> BFLOAT16
  1, // 3 -> HALF
};

const std::string& EdgeTpuSettings_FloatTruncationType_Name(
    EdgeTpuSettings_FloatTruncationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EdgeTpuSettings_FloatTruncationType_entries,
          EdgeTpuSettings_FloatTruncationType_entries_by_number,
          4, EdgeTpuSettings_FloatTruncationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EdgeTpuSettings_FloatTruncationType_entries,
      EdgeTpuSettings_FloatTruncationType_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EdgeTpuSettings_FloatTruncationType_strings[idx].get();
}
bool EdgeTpuSettings_FloatTruncationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuSettings_FloatTruncationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EdgeTpuSettings_FloatTruncationType_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<EdgeTpuSettings_FloatTruncationType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::UNSPECIFIED;
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::NO_TRUNCATION;
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::BFLOAT16;
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::HALF;
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::FloatTruncationType_MIN;
constexpr EdgeTpuSettings_FloatTruncationType EdgeTpuSettings::FloatTruncationType_MAX;
constexpr int EdgeTpuSettings::FloatTruncationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool EdgeTpuSettings_QosClass_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EdgeTpuSettings_QosClass_strings[3] = {};

static const char EdgeTpuSettings_QosClass_names[] =
  "BEST_EFFORT"
  "QOS_UNDEFINED"
  "REALTIME";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EdgeTpuSettings_QosClass_entries[] = {
  { {EdgeTpuSettings_QosClass_names + 0, 11}, 1 },
  { {EdgeTpuSettings_QosClass_names + 11, 13}, 0 },
  { {EdgeTpuSettings_QosClass_names + 24, 8}, 2 },
};

static const int EdgeTpuSettings_QosClass_entries_by_number[] = {
  1, // 0 -> QOS_UNDEFINED
  0, // 1 -> BEST_EFFORT
  2, // 2 -> REALTIME
};

const std::string& EdgeTpuSettings_QosClass_Name(
    EdgeTpuSettings_QosClass value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EdgeTpuSettings_QosClass_entries,
          EdgeTpuSettings_QosClass_entries_by_number,
          3, EdgeTpuSettings_QosClass_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EdgeTpuSettings_QosClass_entries,
      EdgeTpuSettings_QosClass_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EdgeTpuSettings_QosClass_strings[idx].get();
}
bool EdgeTpuSettings_QosClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuSettings_QosClass* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EdgeTpuSettings_QosClass_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<EdgeTpuSettings_QosClass>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings::QOS_UNDEFINED;
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings::BEST_EFFORT;
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings::REALTIME;
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings::QosClass_MIN;
constexpr EdgeTpuSettings_QosClass EdgeTpuSettings::QosClass_MAX;
constexpr int EdgeTpuSettings::QosClass_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CoralSettings_Performance_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CoralSettings_Performance_strings[5] = {};

static const char CoralSettings_Performance_names[] =
  "HIGH"
  "LOW"
  "MAXIMUM"
  "MEDIUM"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CoralSettings_Performance_entries[] = {
  { {CoralSettings_Performance_names + 0, 4}, 2 },
  { {CoralSettings_Performance_names + 4, 3}, 4 },
  { {CoralSettings_Performance_names + 7, 7}, 1 },
  { {CoralSettings_Performance_names + 14, 6}, 3 },
  { {CoralSettings_Performance_names + 20, 9}, 0 },
};

static const int CoralSettings_Performance_entries_by_number[] = {
  4, // 0 -> UNDEFINED
  2, // 1 -> MAXIMUM
  0, // 2 -> HIGH
  3, // 3 -> MEDIUM
  1, // 4 -> LOW
};

const std::string& CoralSettings_Performance_Name(
    CoralSettings_Performance value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CoralSettings_Performance_entries,
          CoralSettings_Performance_entries_by_number,
          5, CoralSettings_Performance_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CoralSettings_Performance_entries,
      CoralSettings_Performance_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CoralSettings_Performance_strings[idx].get();
}
bool CoralSettings_Performance_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CoralSettings_Performance* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CoralSettings_Performance_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<CoralSettings_Performance>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CoralSettings_Performance CoralSettings::UNDEFINED;
constexpr CoralSettings_Performance CoralSettings::MAXIMUM;
constexpr CoralSettings_Performance CoralSettings::HIGH;
constexpr CoralSettings_Performance CoralSettings::MEDIUM;
constexpr CoralSettings_Performance CoralSettings::LOW;
constexpr CoralSettings_Performance CoralSettings::Performance_MIN;
constexpr CoralSettings_Performance CoralSettings::Performance_MAX;
constexpr int CoralSettings::Performance_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool ExecutionPreference_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ExecutionPreference_strings[4] = {};

static const char ExecutionPreference_names[] =
  "ANY"
  "FORCE_CPU"
  "LOW_LATENCY"
  "LOW_POWER";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ExecutionPreference_entries[] = {
  { {ExecutionPreference_names + 0, 3}, 0 },
  { {ExecutionPreference_names + 3, 9}, 3 },
  { {ExecutionPreference_names + 12, 11}, 1 },
  { {ExecutionPreference_names + 23, 9}, 2 },
};

static const int ExecutionPreference_entries_by_number[] = {
  0, // 0 -> ANY
  2, // 1 -> LOW_LATENCY
  3, // 2 -> LOW_POWER
  1, // 3 -> FORCE_CPU
};

const std::string& ExecutionPreference_Name(
    ExecutionPreference value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ExecutionPreference_entries,
          ExecutionPreference_entries_by_number,
          4, ExecutionPreference_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ExecutionPreference_entries,
      ExecutionPreference_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ExecutionPreference_strings[idx].get();
}
bool ExecutionPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ExecutionPreference* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ExecutionPreference_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<ExecutionPreference>(int_value);
  }
  return success;
}
bool Delegate_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Delegate_strings[8] = {};

static const char Delegate_names[] =
  "CORE_ML"
  "EDGETPU"
  "EDGETPU_CORAL"
  "GPU"
  "HEXAGON"
  "NNAPI"
  "NONE"
  "XNNPACK";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Delegate_entries[] = {
  { {Delegate_names + 0, 7}, 7 },
  { {Delegate_names + 7, 7}, 5 },
  { {Delegate_names + 14, 13}, 6 },
  { {Delegate_names + 27, 3}, 2 },
  { {Delegate_names + 30, 7}, 3 },
  { {Delegate_names + 37, 5}, 1 },
  { {Delegate_names + 42, 4}, 0 },
  { {Delegate_names + 46, 7}, 4 },
};

static const int Delegate_entries_by_number[] = {
  6, // 0 -> NONE
  5, // 1 -> NNAPI
  3, // 2 -> GPU
  4, // 3 -> HEXAGON
  7, // 4 -> XNNPACK
  1, // 5 -> EDGETPU
  2, // 6 -> EDGETPU_CORAL
  0, // 7 -> CORE_ML
};

const std::string& Delegate_Name(
    Delegate value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Delegate_entries,
          Delegate_entries_by_number,
          8, Delegate_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Delegate_entries,
      Delegate_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Delegate_strings[idx].get();
}
bool Delegate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Delegate* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Delegate_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<Delegate>(int_value);
  }
  return success;
}
bool NNAPIExecutionPreference_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NNAPIExecutionPreference_strings[4] = {};

static const char NNAPIExecutionPreference_names[] =
  "NNAPI_FAST_SINGLE_ANSWER"
  "NNAPI_LOW_POWER"
  "NNAPI_SUSTAINED_SPEED"
  "UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NNAPIExecutionPreference_entries[] = {
  { {NNAPIExecutionPreference_names + 0, 24}, 2 },
  { {NNAPIExecutionPreference_names + 24, 15}, 1 },
  { {NNAPIExecutionPreference_names + 39, 21}, 3 },
  { {NNAPIExecutionPreference_names + 60, 9}, 0 },
};

static const int NNAPIExecutionPreference_entries_by_number[] = {
  3, // 0 -> UNDEFINED
  1, // 1 -> NNAPI_LOW_POWER
  0, // 2 -> NNAPI_FAST_SINGLE_ANSWER
  2, // 3 -> NNAPI_SUSTAINED_SPEED
};

const std::string& NNAPIExecutionPreference_Name(
    NNAPIExecutionPreference value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NNAPIExecutionPreference_entries,
          NNAPIExecutionPreference_entries_by_number,
          4, NNAPIExecutionPreference_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NNAPIExecutionPreference_entries,
      NNAPIExecutionPreference_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NNAPIExecutionPreference_strings[idx].get();
}
bool NNAPIExecutionPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NNAPIExecutionPreference* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NNAPIExecutionPreference_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<NNAPIExecutionPreference>(int_value);
  }
  return success;
}
bool NNAPIExecutionPriority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NNAPIExecutionPriority_strings[4] = {};

static const char NNAPIExecutionPriority_names[] =
  "NNAPI_PRIORITY_HIGH"
  "NNAPI_PRIORITY_LOW"
  "NNAPI_PRIORITY_MEDIUM"
  "NNAPI_PRIORITY_UNDEFINED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NNAPIExecutionPriority_entries[] = {
  { {NNAPIExecutionPriority_names + 0, 19}, 3 },
  { {NNAPIExecutionPriority_names + 19, 18}, 1 },
  { {NNAPIExecutionPriority_names + 37, 21}, 2 },
  { {NNAPIExecutionPriority_names + 58, 24}, 0 },
};

static const int NNAPIExecutionPriority_entries_by_number[] = {
  3, // 0 -> NNAPI_PRIORITY_UNDEFINED
  1, // 1 -> NNAPI_PRIORITY_LOW
  2, // 2 -> NNAPI_PRIORITY_MEDIUM
  0, // 3 -> NNAPI_PRIORITY_HIGH
};

const std::string& NNAPIExecutionPriority_Name(
    NNAPIExecutionPriority value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NNAPIExecutionPriority_entries,
          NNAPIExecutionPriority_entries_by_number,
          4, NNAPIExecutionPriority_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NNAPIExecutionPriority_entries,
      NNAPIExecutionPriority_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NNAPIExecutionPriority_strings[idx].get();
}
bool NNAPIExecutionPriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NNAPIExecutionPriority* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NNAPIExecutionPriority_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<NNAPIExecutionPriority>(int_value);
  }
  return success;
}
bool GPUBackend_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GPUBackend_strings[3] = {};

static const char GPUBackend_names[] =
  "OPENCL"
  "OPENGL"
  "UNSET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GPUBackend_entries[] = {
  { {GPUBackend_names + 0, 6}, 1 },
  { {GPUBackend_names + 6, 6}, 2 },
  { {GPUBackend_names + 12, 5}, 0 },
};

static const int GPUBackend_entries_by_number[] = {
  2, // 0 -> UNSET
  0, // 1 -> OPENCL
  1, // 2 -> OPENGL
};

const std::string& GPUBackend_Name(
    GPUBackend value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GPUBackend_entries,
          GPUBackend_entries_by_number,
          3, GPUBackend_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GPUBackend_entries,
      GPUBackend_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GPUBackend_strings[idx].get();
}
bool GPUBackend_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPUBackend* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GPUBackend_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<GPUBackend>(int_value);
  }
  return success;
}
bool GPUInferencePriority_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GPUInferencePriority_strings[4] = {};

static const char GPUInferencePriority_names[] =
  "GPU_PRIORITY_AUTO"
  "GPU_PRIORITY_MAX_PRECISION"
  "GPU_PRIORITY_MIN_LATENCY"
  "GPU_PRIORITY_MIN_MEMORY_USAGE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GPUInferencePriority_entries[] = {
  { {GPUInferencePriority_names + 0, 17}, 0 },
  { {GPUInferencePriority_names + 17, 26}, 1 },
  { {GPUInferencePriority_names + 43, 24}, 2 },
  { {GPUInferencePriority_names + 67, 29}, 3 },
};

static const int GPUInferencePriority_entries_by_number[] = {
  0, // 0 -> GPU_PRIORITY_AUTO
  1, // 1 -> GPU_PRIORITY_MAX_PRECISION
  2, // 2 -> GPU_PRIORITY_MIN_LATENCY
  3, // 3 -> GPU_PRIORITY_MIN_MEMORY_USAGE
};

const std::string& GPUInferencePriority_Name(
    GPUInferencePriority value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GPUInferencePriority_entries,
          GPUInferencePriority_entries_by_number,
          4, GPUInferencePriority_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GPUInferencePriority_entries,
      GPUInferencePriority_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GPUInferencePriority_strings[idx].get();
}
bool GPUInferencePriority_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPUInferencePriority* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GPUInferencePriority_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<GPUInferencePriority>(int_value);
  }
  return success;
}
bool GPUInferenceUsage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> GPUInferenceUsage_strings[2] = {};

static const char GPUInferenceUsage_names[] =
  "GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER"
  "GPU_INFERENCE_PREFERENCE_SUSTAINED_SPEED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry GPUInferenceUsage_entries[] = {
  { {GPUInferenceUsage_names + 0, 43}, 0 },
  { {GPUInferenceUsage_names + 43, 40}, 1 },
};

static const int GPUInferenceUsage_entries_by_number[] = {
  0, // 0 -> GPU_INFERENCE_PREFERENCE_FAST_SINGLE_ANSWER
  1, // 1 -> GPU_INFERENCE_PREFERENCE_SUSTAINED_SPEED
};

const std::string& GPUInferenceUsage_Name(
    GPUInferenceUsage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          GPUInferenceUsage_entries,
          GPUInferenceUsage_entries_by_number,
          2, GPUInferenceUsage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      GPUInferenceUsage_entries,
      GPUInferenceUsage_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     GPUInferenceUsage_strings[idx].get();
}
bool GPUInferenceUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GPUInferenceUsage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      GPUInferenceUsage_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<GPUInferenceUsage>(int_value);
  }
  return success;
}
bool XNNPackFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> XNNPackFlags_strings[5] = {};

static const char XNNPackFlags_names[] =
  "TFLITE_XNNPACK_DELEGATE_FLAG_FORCE_FP16"
  "TFLITE_XNNPACK_DELEGATE_FLAG_QS8"
  "TFLITE_XNNPACK_DELEGATE_FLAG_QS8_QU8"
  "TFLITE_XNNPACK_DELEGATE_FLAG_QU8"
  "TFLITE_XNNPACK_DELEGATE_NO_FLAGS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry XNNPackFlags_entries[] = {
  { {XNNPackFlags_names + 0, 39}, 4 },
  { {XNNPackFlags_names + 39, 32}, 1 },
  { {XNNPackFlags_names + 71, 36}, 3 },
  { {XNNPackFlags_names + 107, 32}, 2 },
  { {XNNPackFlags_names + 139, 32}, 0 },
};

static const int XNNPackFlags_entries_by_number[] = {
  4, // 0 -> TFLITE_XNNPACK_DELEGATE_NO_FLAGS
  1, // 1 -> TFLITE_XNNPACK_DELEGATE_FLAG_QS8
  3, // 2 -> TFLITE_XNNPACK_DELEGATE_FLAG_QU8
  2, // 3 -> TFLITE_XNNPACK_DELEGATE_FLAG_QS8_QU8
  0, // 4 -> TFLITE_XNNPACK_DELEGATE_FLAG_FORCE_FP16
};

const std::string& XNNPackFlags_Name(
    XNNPackFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          XNNPackFlags_entries,
          XNNPackFlags_entries_by_number,
          5, XNNPackFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      XNNPackFlags_entries,
      XNNPackFlags_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     XNNPackFlags_strings[idx].get();
}
bool XNNPackFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, XNNPackFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      XNNPackFlags_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<XNNPackFlags>(int_value);
  }
  return success;
}
bool EdgeTpuPowerState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> EdgeTpuPowerState_strings[8] = {};

static const char EdgeTpuPowerState_names[] =
  "ACTIVE"
  "ACTIVE_LOW_POWER"
  "ACTIVE_MIN_POWER"
  "ACTIVE_VERY_LOW_POWER"
  "OVER_DRIVE"
  "READY"
  "TPU_CORE_OFF"
  "UNDEFINED_POWERSTATE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry EdgeTpuPowerState_entries[] = {
  { {EdgeTpuPowerState_names + 0, 6}, 6 },
  { {EdgeTpuPowerState_names + 6, 16}, 5 },
  { {EdgeTpuPowerState_names + 22, 16}, 3 },
  { {EdgeTpuPowerState_names + 38, 21}, 4 },
  { {EdgeTpuPowerState_names + 59, 10}, 7 },
  { {EdgeTpuPowerState_names + 69, 5}, 2 },
  { {EdgeTpuPowerState_names + 74, 12}, 1 },
  { {EdgeTpuPowerState_names + 86, 20}, 0 },
};

static const int EdgeTpuPowerState_entries_by_number[] = {
  7, // 0 -> UNDEFINED_POWERSTATE
  6, // 1 -> TPU_CORE_OFF
  5, // 2 -> READY
  2, // 3 -> ACTIVE_MIN_POWER
  3, // 4 -> ACTIVE_VERY_LOW_POWER
  1, // 5 -> ACTIVE_LOW_POWER
  0, // 6 -> ACTIVE
  4, // 7 -> OVER_DRIVE
};

const std::string& EdgeTpuPowerState_Name(
    EdgeTpuPowerState value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          EdgeTpuPowerState_entries,
          EdgeTpuPowerState_entries_by_number,
          8, EdgeTpuPowerState_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      EdgeTpuPowerState_entries,
      EdgeTpuPowerState_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     EdgeTpuPowerState_strings[idx].get();
}
bool EdgeTpuPowerState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EdgeTpuPowerState* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      EdgeTpuPowerState_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<EdgeTpuPowerState>(int_value);
  }
  return success;
}
bool BenchmarkEventType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BenchmarkEventType_strings[6] = {};

static const char BenchmarkEventType_names[] =
  "END"
  "ERROR"
  "LOGGED"
  "RECOVERED_ERROR"
  "START"
  "UNDEFINED_BENCHMARK_EVENT_TYPE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BenchmarkEventType_entries[] = {
  { {BenchmarkEventType_names + 0, 3}, 2 },
  { {BenchmarkEventType_names + 3, 5}, 3 },
  { {BenchmarkEventType_names + 8, 6}, 4 },
  { {BenchmarkEventType_names + 14, 15}, 5 },
  { {BenchmarkEventType_names + 29, 5}, 1 },
  { {BenchmarkEventType_names + 34, 30}, 0 },
};

static const int BenchmarkEventType_entries_by_number[] = {
  5, // 0 -> UNDEFINED_BENCHMARK_EVENT_TYPE
  4, // 1 -> START
  0, // 2 -> END
  1, // 3 -> ERROR
  2, // 4 -> LOGGED
  3, // 5 -> RECOVERED_ERROR
};

const std::string& BenchmarkEventType_Name(
    BenchmarkEventType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BenchmarkEventType_entries,
          BenchmarkEventType_entries_by_number,
          6, BenchmarkEventType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BenchmarkEventType_entries,
      BenchmarkEventType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BenchmarkEventType_strings[idx].get();
}
bool BenchmarkEventType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BenchmarkEventType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BenchmarkEventType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<BenchmarkEventType>(int_value);
  }
  return success;
}
bool BenchmarkStage_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> BenchmarkStage_strings[3] = {};

static const char BenchmarkStage_names[] =
  "INFERENCE"
  "INITIALIZATION"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry BenchmarkStage_entries[] = {
  { {BenchmarkStage_names + 0, 9}, 2 },
  { {BenchmarkStage_names + 9, 14}, 1 },
  { {BenchmarkStage_names + 23, 7}, 0 },
};

static const int BenchmarkStage_entries_by_number[] = {
  2, // 0 -> UNKNOWN
  1, // 1 -> INITIALIZATION
  0, // 2 -> INFERENCE
};

const std::string& BenchmarkStage_Name(
    BenchmarkStage value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          BenchmarkStage_entries,
          BenchmarkStage_entries_by_number,
          3, BenchmarkStage_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      BenchmarkStage_entries,
      BenchmarkStage_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     BenchmarkStage_strings[idx].get();
}
bool BenchmarkStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BenchmarkStage* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      BenchmarkStage_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<BenchmarkStage>(int_value);
  }
  return success;
}

// ===================================================================

class ComputeSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<ComputeSettings>()._has_bits_);
  static void set_has_preference(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::tflite::proto::TFLiteSettings& tflite_settings(const ComputeSettings* msg);
  static void set_has_tflite_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_model_namespace_for_statistics(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model_identifier_for_statistics(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::tflite::proto::MinibenchmarkSettings& settings_to_test_locally(const ComputeSettings* msg);
  static void set_has_settings_to_test_locally(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::tflite::proto::TFLiteSettings&
ComputeSettings::_Internal::tflite_settings(const ComputeSettings* msg) {
  return *msg->tflite_settings_;
}
const ::tflite::proto::MinibenchmarkSettings&
ComputeSettings::_Internal::settings_to_test_locally(const ComputeSettings* msg) {
  return *msg->settings_to_test_locally_;
}
ComputeSettings::ComputeSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.ComputeSettings)
}
ComputeSettings::ComputeSettings(const ComputeSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_namespace_for_statistics_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_namespace_for_statistics_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_namespace_for_statistics()) {
    model_namespace_for_statistics_.Set(from._internal_model_namespace_for_statistics(), 
      GetArenaForAllocation());
  }
  model_identifier_for_statistics_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_identifier_for_statistics_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_identifier_for_statistics()) {
    model_identifier_for_statistics_.Set(from._internal_model_identifier_for_statistics(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_tflite_settings()) {
    tflite_settings_ = new ::tflite::proto::TFLiteSettings(*from.tflite_settings_);
  } else {
    tflite_settings_ = nullptr;
  }
  if (from._internal_has_settings_to_test_locally()) {
    settings_to_test_locally_ = new ::tflite::proto::MinibenchmarkSettings(*from.settings_to_test_locally_);
  } else {
    settings_to_test_locally_ = nullptr;
  }
  preference_ = from.preference_;
  // @@protoc_insertion_point(copy_constructor:tflite.proto.ComputeSettings)
}

inline void ComputeSettings::SharedCtor() {
model_namespace_for_statistics_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_namespace_for_statistics_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_identifier_for_statistics_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_identifier_for_statistics_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tflite_settings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&preference_) -
    reinterpret_cast<char*>(&tflite_settings_)) + sizeof(preference_));
}

ComputeSettings::~ComputeSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.ComputeSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ComputeSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_namespace_for_statistics_.Destroy();
  model_identifier_for_statistics_.Destroy();
  if (this != internal_default_instance()) delete tflite_settings_;
  if (this != internal_default_instance()) delete settings_to_test_locally_;
}

void ComputeSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ComputeSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.ComputeSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      model_namespace_for_statistics_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_identifier_for_statistics_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(tflite_settings_ != nullptr);
      tflite_settings_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(settings_to_test_locally_ != nullptr);
      settings_to_test_locally_->Clear();
    }
  }
  preference_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ComputeSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.ExecutionPreference preference = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::ExecutionPreference_IsValid(val))) {
            _internal_set_preference(static_cast<::tflite::proto::ExecutionPreference>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.TFLiteSettings tflite_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_tflite_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_namespace_for_statistics = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_namespace_for_statistics();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_identifier_for_statistics = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_model_identifier_for_statistics();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.MinibenchmarkSettings settings_to_test_locally = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings_to_test_locally(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ComputeSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.ComputeSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.ExecutionPreference preference = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_preference(), target);
  }

  // optional .tflite.proto.TFLiteSettings tflite_settings = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::tflite_settings(this),
        _Internal::tflite_settings(this).GetCachedSize(), target, stream);
  }

  // optional string model_namespace_for_statistics = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_namespace_for_statistics(), target);
  }

  // optional string model_identifier_for_statistics = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_model_identifier_for_statistics(), target);
  }

  // optional .tflite.proto.MinibenchmarkSettings settings_to_test_locally = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::settings_to_test_locally(this),
        _Internal::settings_to_test_locally(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.ComputeSettings)
  return target;
}

size_t ComputeSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.ComputeSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string model_namespace_for_statistics = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_namespace_for_statistics());
    }

    // optional string model_identifier_for_statistics = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_identifier_for_statistics());
    }

    // optional .tflite.proto.TFLiteSettings tflite_settings = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tflite_settings_);
    }

    // optional .tflite.proto.MinibenchmarkSettings settings_to_test_locally = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *settings_to_test_locally_);
    }

    // optional .tflite.proto.ExecutionPreference preference = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_preference());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ComputeSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ComputeSettings*>(
      &from));
}

void ComputeSettings::MergeFrom(const ComputeSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.ComputeSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_namespace_for_statistics(from._internal_model_namespace_for_statistics());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_identifier_for_statistics(from._internal_model_identifier_for_statistics());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_tflite_settings()->::tflite::proto::TFLiteSettings::MergeFrom(from._internal_tflite_settings());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_settings_to_test_locally()->::tflite::proto::MinibenchmarkSettings::MergeFrom(from._internal_settings_to_test_locally());
    }
    if (cached_has_bits & 0x00000010u) {
      preference_ = from.preference_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ComputeSettings::CopyFrom(const ComputeSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.ComputeSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ComputeSettings::IsInitialized() const {
  return true;
}

void ComputeSettings::InternalSwap(ComputeSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_namespace_for_statistics_, lhs_arena,
      &other->model_namespace_for_statistics_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_identifier_for_statistics_, lhs_arena,
      &other->model_identifier_for_statistics_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ComputeSettings, preference_)
      + sizeof(ComputeSettings::preference_)
      - PROTOBUF_FIELD_OFFSET(ComputeSettings, tflite_settings_)>(
          reinterpret_cast<char*>(&tflite_settings_),
          reinterpret_cast<char*>(&other->tflite_settings_));
}

std::string ComputeSettings::GetTypeName() const {
  return "tflite.proto.ComputeSettings";
}


// ===================================================================

class NNAPISettings::_Internal {
 public:
  using HasBits = decltype(std::declval<NNAPISettings>()._has_bits_);
  static void set_has_accelerator_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cache_directory(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model_token(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_execution_preference(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_no_of_nnapi_instances_to_cache(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::tflite::proto::FallbackSettings& fallback_settings(const NNAPISettings* msg);
  static void set_has_fallback_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_allow_nnapi_cpu_on_android_10_plus(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_execution_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_allow_dynamic_dimensions(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_allow_fp16_precision_for_fp32(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_use_burst_computation(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_support_library_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::tflite::proto::FallbackSettings&
NNAPISettings::_Internal::fallback_settings(const NNAPISettings* msg) {
  return *msg->fallback_settings_;
}
NNAPISettings::NNAPISettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.NNAPISettings)
}
NNAPISettings::NNAPISettings(const NNAPISettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  accelerator_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    accelerator_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_accelerator_name()) {
    accelerator_name_.Set(from._internal_accelerator_name(), 
      GetArenaForAllocation());
  }
  cache_directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cache_directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cache_directory()) {
    cache_directory_.Set(from._internal_cache_directory(), 
      GetArenaForAllocation());
  }
  model_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_token()) {
    model_token_.Set(from._internal_model_token(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_fallback_settings()) {
    fallback_settings_ = new ::tflite::proto::FallbackSettings(*from.fallback_settings_);
  } else {
    fallback_settings_ = nullptr;
  }
  ::memcpy(&execution_preference_, &from.execution_preference_,
    static_cast<size_t>(reinterpret_cast<char*>(&support_library_handle_) -
    reinterpret_cast<char*>(&execution_preference_)) + sizeof(support_library_handle_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.NNAPISettings)
}

inline void NNAPISettings::SharedCtor() {
accelerator_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  accelerator_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cache_directory_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cache_directory_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fallback_settings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&support_library_handle_) -
    reinterpret_cast<char*>(&fallback_settings_)) + sizeof(support_library_handle_));
}

NNAPISettings::~NNAPISettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.NNAPISettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NNAPISettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  accelerator_name_.Destroy();
  cache_directory_.Destroy();
  model_token_.Destroy();
  if (this != internal_default_instance()) delete fallback_settings_;
}

void NNAPISettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NNAPISettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.NNAPISettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      accelerator_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      cache_directory_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      model_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(fallback_settings_ != nullptr);
      fallback_settings_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&execution_preference_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allow_nnapi_cpu_on_android_10_plus_) -
        reinterpret_cast<char*>(&execution_preference_)) + sizeof(allow_nnapi_cpu_on_android_10_plus_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&allow_dynamic_dimensions_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&support_library_handle_) -
        reinterpret_cast<char*>(&allow_dynamic_dimensions_)) + sizeof(support_library_handle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NNAPISettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string accelerator_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_accelerator_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cache_directory = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cache_directory();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_token = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_model_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.NNAPIExecutionPreference execution_preference = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::NNAPIExecutionPreference_IsValid(val))) {
            _internal_set_execution_preference(static_cast<::tflite::proto::NNAPIExecutionPreference>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 no_of_nnapi_instances_to_cache = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_no_of_nnapi_instances_to_cache(&has_bits);
          no_of_nnapi_instances_to_cache_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.FallbackSettings fallback_settings = 6 [deprecated = true];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_fallback_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_nnapi_cpu_on_android_10_plus = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_allow_nnapi_cpu_on_android_10_plus(&has_bits);
          allow_nnapi_cpu_on_android_10_plus_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.NNAPIExecutionPriority execution_priority = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::NNAPIExecutionPriority_IsValid(val))) {
            _internal_set_execution_priority(static_cast<::tflite::proto::NNAPIExecutionPriority>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(8, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_dynamic_dimensions = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_allow_dynamic_dimensions(&has_bits);
          allow_dynamic_dimensions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_fp16_precision_for_fp32 = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_allow_fp16_precision_for_fp32(&has_bits);
          allow_fp16_precision_for_fp32_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_burst_computation = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_use_burst_computation(&has_bits);
          use_burst_computation_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 support_library_handle = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_support_library_handle(&has_bits);
          support_library_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NNAPISettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.NNAPISettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string accelerator_name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_accelerator_name(), target);
  }

  // optional string cache_directory = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cache_directory(), target);
  }

  // optional string model_token = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_model_token(), target);
  }

  // optional .tflite.proto.NNAPIExecutionPreference execution_preference = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_execution_preference(), target);
  }

  // optional int32 no_of_nnapi_instances_to_cache = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_no_of_nnapi_instances_to_cache(), target);
  }

  // optional .tflite.proto.FallbackSettings fallback_settings = 6 [deprecated = true];
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::fallback_settings(this),
        _Internal::fallback_settings(this).GetCachedSize(), target, stream);
  }

  // optional bool allow_nnapi_cpu_on_android_10_plus = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_nnapi_cpu_on_android_10_plus(), target);
  }

  // optional .tflite.proto.NNAPIExecutionPriority execution_priority = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      8, this->_internal_execution_priority(), target);
  }

  // optional bool allow_dynamic_dimensions = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_allow_dynamic_dimensions(), target);
  }

  // optional bool allow_fp16_precision_for_fp32 = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_allow_fp16_precision_for_fp32(), target);
  }

  // optional bool use_burst_computation = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_use_burst_computation(), target);
  }

  // optional int64 support_library_handle = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(12, this->_internal_support_library_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.NNAPISettings)
  return target;
}

size_t NNAPISettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.NNAPISettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string accelerator_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_accelerator_name());
    }

    // optional string cache_directory = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cache_directory());
    }

    // optional string model_token = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_token());
    }

    // optional .tflite.proto.FallbackSettings fallback_settings = 6 [deprecated = true];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fallback_settings_);
    }

    // optional .tflite.proto.NNAPIExecutionPreference execution_preference = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_execution_preference());
    }

    // optional int32 no_of_nnapi_instances_to_cache = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_no_of_nnapi_instances_to_cache());
    }

    // optional .tflite.proto.NNAPIExecutionPriority execution_priority = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_execution_priority());
    }

    // optional bool allow_nnapi_cpu_on_android_10_plus = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool allow_dynamic_dimensions = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool allow_fp16_precision_for_fp32 = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool use_burst_computation = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int64 support_library_handle = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_support_library_handle());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NNAPISettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NNAPISettings*>(
      &from));
}

void NNAPISettings::MergeFrom(const NNAPISettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.NNAPISettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_accelerator_name(from._internal_accelerator_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_cache_directory(from._internal_cache_directory());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_model_token(from._internal_model_token());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_fallback_settings()->::tflite::proto::FallbackSettings::MergeFrom(from._internal_fallback_settings());
    }
    if (cached_has_bits & 0x00000010u) {
      execution_preference_ = from.execution_preference_;
    }
    if (cached_has_bits & 0x00000020u) {
      no_of_nnapi_instances_to_cache_ = from.no_of_nnapi_instances_to_cache_;
    }
    if (cached_has_bits & 0x00000040u) {
      execution_priority_ = from.execution_priority_;
    }
    if (cached_has_bits & 0x00000080u) {
      allow_nnapi_cpu_on_android_10_plus_ = from.allow_nnapi_cpu_on_android_10_plus_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      allow_dynamic_dimensions_ = from.allow_dynamic_dimensions_;
    }
    if (cached_has_bits & 0x00000200u) {
      allow_fp16_precision_for_fp32_ = from.allow_fp16_precision_for_fp32_;
    }
    if (cached_has_bits & 0x00000400u) {
      use_burst_computation_ = from.use_burst_computation_;
    }
    if (cached_has_bits & 0x00000800u) {
      support_library_handle_ = from.support_library_handle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NNAPISettings::CopyFrom(const NNAPISettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.NNAPISettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NNAPISettings::IsInitialized() const {
  return true;
}

void NNAPISettings::InternalSwap(NNAPISettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &accelerator_name_, lhs_arena,
      &other->accelerator_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cache_directory_, lhs_arena,
      &other->cache_directory_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_token_, lhs_arena,
      &other->model_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NNAPISettings, support_library_handle_)
      + sizeof(NNAPISettings::support_library_handle_)
      - PROTOBUF_FIELD_OFFSET(NNAPISettings, fallback_settings_)>(
          reinterpret_cast<char*>(&fallback_settings_),
          reinterpret_cast<char*>(&other->fallback_settings_));
}

std::string NNAPISettings::GetTypeName() const {
  return "tflite.proto.NNAPISettings";
}


// ===================================================================

class GPUSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<GPUSettings>()._has_bits_);
  static void set_has_is_precision_loss_allowed(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_quantized_inference(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_force_backend(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_inference_priority1(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_inference_priority2(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_inference_priority3(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_inference_preference(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_cache_directory(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GPUSettings::GPUSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.GPUSettings)
}
GPUSettings::GPUSettings(const GPUSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  cache_directory_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cache_directory_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cache_directory()) {
    cache_directory_.Set(from._internal_cache_directory(), 
      GetArenaForAllocation());
  }
  model_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_token()) {
    model_token_.Set(from._internal_model_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&is_precision_loss_allowed_, &from.is_precision_loss_allowed_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_quantized_inference_) -
    reinterpret_cast<char*>(&is_precision_loss_allowed_)) + sizeof(enable_quantized_inference_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.GPUSettings)
}

inline void GPUSettings::SharedCtor() {
cache_directory_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cache_directory_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_precision_loss_allowed_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&inference_preference_) -
    reinterpret_cast<char*>(&is_precision_loss_allowed_)) + sizeof(inference_preference_));
enable_quantized_inference_ = true;
}

GPUSettings::~GPUSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.GPUSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GPUSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  cache_directory_.Destroy();
  model_token_.Destroy();
}

void GPUSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GPUSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.GPUSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      cache_directory_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_token_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&is_precision_loss_allowed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&inference_preference_) -
        reinterpret_cast<char*>(&is_precision_loss_allowed_)) + sizeof(inference_preference_));
  }
  enable_quantized_inference_ = true;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GPUSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_precision_loss_allowed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_precision_loss_allowed(&has_bits);
          is_precision_loss_allowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_quantized_inference = 2 [default = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_enable_quantized_inference(&has_bits);
          enable_quantized_inference_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.GPUBackend force_backend = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::GPUBackend_IsValid(val))) {
            _internal_set_force_backend(static_cast<::tflite::proto::GPUBackend>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.GPUInferencePriority inference_priority1 = 4 [default = GPU_PRIORITY_AUTO];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::GPUInferencePriority_IsValid(val))) {
            _internal_set_inference_priority1(static_cast<::tflite::proto::GPUInferencePriority>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.GPUInferencePriority inference_priority2 = 5 [default = GPU_PRIORITY_AUTO];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::GPUInferencePriority_IsValid(val))) {
            _internal_set_inference_priority2(static_cast<::tflite::proto::GPUInferencePriority>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.GPUInferencePriority inference_priority3 = 6 [default = GPU_PRIORITY_AUTO];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::GPUInferencePriority_IsValid(val))) {
            _internal_set_inference_priority3(static_cast<::tflite::proto::GPUInferencePriority>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.GPUInferenceUsage inference_preference = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::GPUInferenceUsage_IsValid(val))) {
            _internal_set_inference_preference(static_cast<::tflite::proto::GPUInferenceUsage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string cache_directory = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_cache_directory();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_token = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_model_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GPUSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.GPUSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_precision_loss_allowed = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_precision_loss_allowed(), target);
  }

  // optional bool enable_quantized_inference = 2 [default = true];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_enable_quantized_inference(), target);
  }

  // optional .tflite.proto.GPUBackend force_backend = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_force_backend(), target);
  }

  // optional .tflite.proto.GPUInferencePriority inference_priority1 = 4 [default = GPU_PRIORITY_AUTO];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_inference_priority1(), target);
  }

  // optional .tflite.proto.GPUInferencePriority inference_priority2 = 5 [default = GPU_PRIORITY_AUTO];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_inference_priority2(), target);
  }

  // optional .tflite.proto.GPUInferencePriority inference_priority3 = 6 [default = GPU_PRIORITY_AUTO];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_inference_priority3(), target);
  }

  // optional .tflite.proto.GPUInferenceUsage inference_preference = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_inference_preference(), target);
  }

  // optional string cache_directory = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_cache_directory(), target);
  }

  // optional string model_token = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_model_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.GPUSettings)
  return target;
}

size_t GPUSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.GPUSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string cache_directory = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cache_directory());
    }

    // optional string model_token = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_token());
    }

    // optional bool is_precision_loss_allowed = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional .tflite.proto.GPUBackend force_backend = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_force_backend());
    }

    // optional .tflite.proto.GPUInferencePriority inference_priority1 = 4 [default = GPU_PRIORITY_AUTO];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inference_priority1());
    }

    // optional .tflite.proto.GPUInferencePriority inference_priority2 = 5 [default = GPU_PRIORITY_AUTO];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inference_priority2());
    }

    // optional .tflite.proto.GPUInferencePriority inference_priority3 = 6 [default = GPU_PRIORITY_AUTO];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inference_priority3());
    }

    // optional .tflite.proto.GPUInferenceUsage inference_preference = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inference_preference());
    }

  }
  // optional bool enable_quantized_inference = 2 [default = true];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GPUSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GPUSettings*>(
      &from));
}

void GPUSettings::MergeFrom(const GPUSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.GPUSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_cache_directory(from._internal_cache_directory());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model_token(from._internal_model_token());
    }
    if (cached_has_bits & 0x00000004u) {
      is_precision_loss_allowed_ = from.is_precision_loss_allowed_;
    }
    if (cached_has_bits & 0x00000008u) {
      force_backend_ = from.force_backend_;
    }
    if (cached_has_bits & 0x00000010u) {
      inference_priority1_ = from.inference_priority1_;
    }
    if (cached_has_bits & 0x00000020u) {
      inference_priority2_ = from.inference_priority2_;
    }
    if (cached_has_bits & 0x00000040u) {
      inference_priority3_ = from.inference_priority3_;
    }
    if (cached_has_bits & 0x00000080u) {
      inference_preference_ = from.inference_preference_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_enable_quantized_inference(from._internal_enable_quantized_inference());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GPUSettings::CopyFrom(const GPUSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.GPUSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPUSettings::IsInitialized() const {
  return true;
}

void GPUSettings::InternalSwap(GPUSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cache_directory_, lhs_arena,
      &other->cache_directory_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_token_, lhs_arena,
      &other->model_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GPUSettings, inference_preference_)
      + sizeof(GPUSettings::inference_preference_)
      - PROTOBUF_FIELD_OFFSET(GPUSettings, is_precision_loss_allowed_)>(
          reinterpret_cast<char*>(&is_precision_loss_allowed_),
          reinterpret_cast<char*>(&other->is_precision_loss_allowed_));
  swap(enable_quantized_inference_, other->enable_quantized_inference_);
}

std::string GPUSettings::GetTypeName() const {
  return "tflite.proto.GPUSettings";
}


// ===================================================================

class HexagonSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<HexagonSettings>()._has_bits_);
  static void set_has_debug_level(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_powersave_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_print_graph_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_print_graph_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

HexagonSettings::HexagonSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.HexagonSettings)
}
HexagonSettings::HexagonSettings(const HexagonSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&debug_level_, &from.debug_level_,
    static_cast<size_t>(reinterpret_cast<char*>(&print_graph_debug_) -
    reinterpret_cast<char*>(&debug_level_)) + sizeof(print_graph_debug_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.HexagonSettings)
}

inline void HexagonSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&debug_level_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&print_graph_debug_) -
    reinterpret_cast<char*>(&debug_level_)) + sizeof(print_graph_debug_));
}

HexagonSettings::~HexagonSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.HexagonSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HexagonSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HexagonSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void HexagonSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.HexagonSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&debug_level_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&print_graph_debug_) -
        reinterpret_cast<char*>(&debug_level_)) + sizeof(print_graph_debug_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* HexagonSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 debug_level = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_debug_level(&has_bits);
          debug_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 powersave_level = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_powersave_level(&has_bits);
          powersave_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool print_graph_profile = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_print_graph_profile(&has_bits);
          print_graph_profile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool print_graph_debug = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_print_graph_debug(&has_bits);
          print_graph_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HexagonSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.HexagonSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 debug_level = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_debug_level(), target);
  }

  // optional int32 powersave_level = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_powersave_level(), target);
  }

  // optional bool print_graph_profile = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_print_graph_profile(), target);
  }

  // optional bool print_graph_debug = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_print_graph_debug(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.HexagonSettings)
  return target;
}

size_t HexagonSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.HexagonSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 debug_level = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_debug_level());
    }

    // optional int32 powersave_level = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_powersave_level());
    }

    // optional bool print_graph_profile = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool print_graph_debug = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void HexagonSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const HexagonSettings*>(
      &from));
}

void HexagonSettings::MergeFrom(const HexagonSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.HexagonSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      debug_level_ = from.debug_level_;
    }
    if (cached_has_bits & 0x00000002u) {
      powersave_level_ = from.powersave_level_;
    }
    if (cached_has_bits & 0x00000004u) {
      print_graph_profile_ = from.print_graph_profile_;
    }
    if (cached_has_bits & 0x00000008u) {
      print_graph_debug_ = from.print_graph_debug_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void HexagonSettings::CopyFrom(const HexagonSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.HexagonSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HexagonSettings::IsInitialized() const {
  return true;
}

void HexagonSettings::InternalSwap(HexagonSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HexagonSettings, print_graph_debug_)
      + sizeof(HexagonSettings::print_graph_debug_)
      - PROTOBUF_FIELD_OFFSET(HexagonSettings, debug_level_)>(
          reinterpret_cast<char*>(&debug_level_),
          reinterpret_cast<char*>(&other->debug_level_));
}

std::string HexagonSettings::GetTypeName() const {
  return "tflite.proto.HexagonSettings";
}


// ===================================================================

class XNNPackSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<XNNPackSettings>()._has_bits_);
  static void set_has_num_threads(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

XNNPackSettings::XNNPackSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.XNNPackSettings)
}
XNNPackSettings::XNNPackSettings(const XNNPackSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&num_threads_, &from.num_threads_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&num_threads_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.XNNPackSettings)
}

inline void XNNPackSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&num_threads_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&num_threads_)) + sizeof(flags_));
}

XNNPackSettings::~XNNPackSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.XNNPackSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void XNNPackSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void XNNPackSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void XNNPackSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.XNNPackSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&num_threads_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&flags_) -
        reinterpret_cast<char*>(&num_threads_)) + sizeof(flags_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* XNNPackSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 num_threads = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num_threads(&has_bits);
          num_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.XNNPackFlags flags = 2 [default = TFLITE_XNNPACK_DELEGATE_NO_FLAGS];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::XNNPackFlags_IsValid(val))) {
            _internal_set_flags(static_cast<::tflite::proto::XNNPackFlags>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* XNNPackSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.XNNPackSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_threads = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_threads(), target);
  }

  // optional .tflite.proto.XNNPackFlags flags = 2 [default = TFLITE_XNNPACK_DELEGATE_NO_FLAGS];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.XNNPackSettings)
  return target;
}

size_t XNNPackSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.XNNPackSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 num_threads = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_threads());
    }

    // optional .tflite.proto.XNNPackFlags flags = 2 [default = TFLITE_XNNPACK_DELEGATE_NO_FLAGS];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_flags());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void XNNPackSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const XNNPackSettings*>(
      &from));
}

void XNNPackSettings::MergeFrom(const XNNPackSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.XNNPackSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      num_threads_ = from.num_threads_;
    }
    if (cached_has_bits & 0x00000002u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void XNNPackSettings::CopyFrom(const XNNPackSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.XNNPackSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XNNPackSettings::IsInitialized() const {
  return true;
}

void XNNPackSettings::InternalSwap(XNNPackSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(XNNPackSettings, flags_)
      + sizeof(XNNPackSettings::flags_)
      - PROTOBUF_FIELD_OFFSET(XNNPackSettings, num_threads_)>(
          reinterpret_cast<char*>(&num_threads_),
          reinterpret_cast<char*>(&other->num_threads_));
}

std::string XNNPackSettings::GetTypeName() const {
  return "tflite.proto.XNNPackSettings";
}


// ===================================================================

class CoreMLSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<CoreMLSettings>()._has_bits_);
  static void set_has_enabled_devices(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_coreml_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_max_delegated_partitions(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_nodes_per_partition(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CoreMLSettings::CoreMLSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.CoreMLSettings)
}
CoreMLSettings::CoreMLSettings(const CoreMLSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&enabled_devices_, &from.enabled_devices_,
    static_cast<size_t>(reinterpret_cast<char*>(&min_nodes_per_partition_) -
    reinterpret_cast<char*>(&enabled_devices_)) + sizeof(min_nodes_per_partition_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.CoreMLSettings)
}

inline void CoreMLSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&enabled_devices_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_delegated_partitions_) -
    reinterpret_cast<char*>(&enabled_devices_)) + sizeof(max_delegated_partitions_));
min_nodes_per_partition_ = 2;
}

CoreMLSettings::~CoreMLSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.CoreMLSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoreMLSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CoreMLSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoreMLSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.CoreMLSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&enabled_devices_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_delegated_partitions_) -
        reinterpret_cast<char*>(&enabled_devices_)) + sizeof(max_delegated_partitions_));
    min_nodes_per_partition_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CoreMLSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.CoreMLSettings.EnabledDevices enabled_devices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::CoreMLSettings_EnabledDevices_IsValid(val))) {
            _internal_set_enabled_devices(static_cast<::tflite::proto::CoreMLSettings_EnabledDevices>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 coreml_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_coreml_version(&has_bits);
          coreml_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_delegated_partitions = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_delegated_partitions(&has_bits);
          max_delegated_partitions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 min_nodes_per_partition = 4 [default = 2];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_min_nodes_per_partition(&has_bits);
          min_nodes_per_partition_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoreMLSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.CoreMLSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.CoreMLSettings.EnabledDevices enabled_devices = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_enabled_devices(), target);
  }

  // optional int32 coreml_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_coreml_version(), target);
  }

  // optional int32 max_delegated_partitions = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_delegated_partitions(), target);
  }

  // optional int32 min_nodes_per_partition = 4 [default = 2];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_min_nodes_per_partition(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.CoreMLSettings)
  return target;
}

size_t CoreMLSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.CoreMLSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .tflite.proto.CoreMLSettings.EnabledDevices enabled_devices = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_enabled_devices());
    }

    // optional int32 coreml_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_coreml_version());
    }

    // optional int32 max_delegated_partitions = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_delegated_partitions());
    }

    // optional int32 min_nodes_per_partition = 4 [default = 2];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_min_nodes_per_partition());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CoreMLSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CoreMLSettings*>(
      &from));
}

void CoreMLSettings::MergeFrom(const CoreMLSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.CoreMLSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      enabled_devices_ = from.enabled_devices_;
    }
    if (cached_has_bits & 0x00000002u) {
      coreml_version_ = from.coreml_version_;
    }
    if (cached_has_bits & 0x00000004u) {
      max_delegated_partitions_ = from.max_delegated_partitions_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_nodes_per_partition_ = from.min_nodes_per_partition_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CoreMLSettings::CopyFrom(const CoreMLSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.CoreMLSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoreMLSettings::IsInitialized() const {
  return true;
}

void CoreMLSettings::InternalSwap(CoreMLSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoreMLSettings, max_delegated_partitions_)
      + sizeof(CoreMLSettings::max_delegated_partitions_)
      - PROTOBUF_FIELD_OFFSET(CoreMLSettings, enabled_devices_)>(
          reinterpret_cast<char*>(&enabled_devices_),
          reinterpret_cast<char*>(&other->enabled_devices_));
  swap(min_nodes_per_partition_, other->min_nodes_per_partition_);
}

std::string CoreMLSettings::GetTypeName() const {
  return "tflite.proto.CoreMLSettings";
}


// ===================================================================

class EdgeTpuDeviceSpec::_Internal {
 public:
  using HasBits = decltype(std::declval<EdgeTpuDeviceSpec>()._has_bits_);
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_chips(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_chip_family(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

EdgeTpuDeviceSpec::EdgeTpuDeviceSpec(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  device_paths_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.EdgeTpuDeviceSpec)
}
EdgeTpuDeviceSpec::EdgeTpuDeviceSpec(const EdgeTpuDeviceSpec& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      device_paths_(from.device_paths_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&platform_type_, &from.platform_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&chip_family_) -
    reinterpret_cast<char*>(&platform_type_)) + sizeof(chip_family_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.EdgeTpuDeviceSpec)
}

inline void EdgeTpuDeviceSpec::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&platform_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chip_family_) -
    reinterpret_cast<char*>(&platform_type_)) + sizeof(chip_family_));
}

EdgeTpuDeviceSpec::~EdgeTpuDeviceSpec() {
  // @@protoc_insertion_point(destructor:tflite.proto.EdgeTpuDeviceSpec)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgeTpuDeviceSpec::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EdgeTpuDeviceSpec::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EdgeTpuDeviceSpec::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.EdgeTpuDeviceSpec)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_paths_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&platform_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chip_family_) -
        reinterpret_cast<char*>(&platform_type_)) + sizeof(chip_family_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EdgeTpuDeviceSpec::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.EdgeTpuDeviceSpec.PlatformType platform_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::EdgeTpuDeviceSpec_PlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::tflite::proto::EdgeTpuDeviceSpec_PlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_chips = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_chips(&has_bits);
          num_chips_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string device_paths = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_device_paths();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 chip_family = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_chip_family(&has_bits);
          chip_family_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgeTpuDeviceSpec::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.EdgeTpuDeviceSpec)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.EdgeTpuDeviceSpec.PlatformType platform_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_platform_type(), target);
  }

  // optional int32 num_chips = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_chips(), target);
  }

  // repeated string device_paths = 3;
  for (int i = 0, n = this->_internal_device_paths_size(); i < n; i++) {
    const auto& s = this->_internal_device_paths(i);
    target = stream->WriteString(3, s, target);
  }

  // optional int32 chip_family = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_chip_family(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.EdgeTpuDeviceSpec)
  return target;
}

size_t EdgeTpuDeviceSpec::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.EdgeTpuDeviceSpec)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string device_paths = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(device_paths_.size());
  for (int i = 0, n = device_paths_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      device_paths_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .tflite.proto.EdgeTpuDeviceSpec.PlatformType platform_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional int32 num_chips = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_chips());
    }

    // optional int32 chip_family = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_chip_family());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EdgeTpuDeviceSpec::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EdgeTpuDeviceSpec*>(
      &from));
}

void EdgeTpuDeviceSpec::MergeFrom(const EdgeTpuDeviceSpec& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.EdgeTpuDeviceSpec)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  device_paths_.MergeFrom(from.device_paths_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      num_chips_ = from.num_chips_;
    }
    if (cached_has_bits & 0x00000004u) {
      chip_family_ = from.chip_family_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EdgeTpuDeviceSpec::CopyFrom(const EdgeTpuDeviceSpec& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.EdgeTpuDeviceSpec)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgeTpuDeviceSpec::IsInitialized() const {
  return true;
}

void EdgeTpuDeviceSpec::InternalSwap(EdgeTpuDeviceSpec* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  device_paths_.InternalSwap(&other->device_paths_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgeTpuDeviceSpec, chip_family_)
      + sizeof(EdgeTpuDeviceSpec::chip_family_)
      - PROTOBUF_FIELD_OFFSET(EdgeTpuDeviceSpec, platform_type_)>(
          reinterpret_cast<char*>(&platform_type_),
          reinterpret_cast<char*>(&other->platform_type_));
}

std::string EdgeTpuDeviceSpec::GetTypeName() const {
  return "tflite.proto.EdgeTpuDeviceSpec";
}


// ===================================================================

class EdgeTpuInactivePowerConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<EdgeTpuInactivePowerConfig>()._has_bits_);
  static void set_has_inactive_power_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_inactive_timeout_us(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

EdgeTpuInactivePowerConfig::EdgeTpuInactivePowerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.EdgeTpuInactivePowerConfig)
}
EdgeTpuInactivePowerConfig::EdgeTpuInactivePowerConfig(const EdgeTpuInactivePowerConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&inactive_timeout_us_, &from.inactive_timeout_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&inactive_power_state_) -
    reinterpret_cast<char*>(&inactive_timeout_us_)) + sizeof(inactive_power_state_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.EdgeTpuInactivePowerConfig)
}

inline void EdgeTpuInactivePowerConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&inactive_timeout_us_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&inactive_power_state_) -
    reinterpret_cast<char*>(&inactive_timeout_us_)) + sizeof(inactive_power_state_));
}

EdgeTpuInactivePowerConfig::~EdgeTpuInactivePowerConfig() {
  // @@protoc_insertion_point(destructor:tflite.proto.EdgeTpuInactivePowerConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgeTpuInactivePowerConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EdgeTpuInactivePowerConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EdgeTpuInactivePowerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.EdgeTpuInactivePowerConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&inactive_timeout_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&inactive_power_state_) -
        reinterpret_cast<char*>(&inactive_timeout_us_)) + sizeof(inactive_power_state_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EdgeTpuInactivePowerConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.EdgeTpuPowerState inactive_power_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::EdgeTpuPowerState_IsValid(val))) {
            _internal_set_inactive_power_state(static_cast<::tflite::proto::EdgeTpuPowerState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int64 inactive_timeout_us = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_inactive_timeout_us(&has_bits);
          inactive_timeout_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgeTpuInactivePowerConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.EdgeTpuInactivePowerConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.EdgeTpuPowerState inactive_power_state = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_inactive_power_state(), target);
  }

  // optional int64 inactive_timeout_us = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_inactive_timeout_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.EdgeTpuInactivePowerConfig)
  return target;
}

size_t EdgeTpuInactivePowerConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.EdgeTpuInactivePowerConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 inactive_timeout_us = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_inactive_timeout_us());
    }

    // optional .tflite.proto.EdgeTpuPowerState inactive_power_state = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inactive_power_state());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EdgeTpuInactivePowerConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EdgeTpuInactivePowerConfig*>(
      &from));
}

void EdgeTpuInactivePowerConfig::MergeFrom(const EdgeTpuInactivePowerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.EdgeTpuInactivePowerConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      inactive_timeout_us_ = from.inactive_timeout_us_;
    }
    if (cached_has_bits & 0x00000002u) {
      inactive_power_state_ = from.inactive_power_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EdgeTpuInactivePowerConfig::CopyFrom(const EdgeTpuInactivePowerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.EdgeTpuInactivePowerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgeTpuInactivePowerConfig::IsInitialized() const {
  return true;
}

void EdgeTpuInactivePowerConfig::InternalSwap(EdgeTpuInactivePowerConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgeTpuInactivePowerConfig, inactive_power_state_)
      + sizeof(EdgeTpuInactivePowerConfig::inactive_power_state_)
      - PROTOBUF_FIELD_OFFSET(EdgeTpuInactivePowerConfig, inactive_timeout_us_)>(
          reinterpret_cast<char*>(&inactive_timeout_us_),
          reinterpret_cast<char*>(&other->inactive_timeout_us_));
}

std::string EdgeTpuInactivePowerConfig::GetTypeName() const {
  return "tflite.proto.EdgeTpuInactivePowerConfig";
}


// ===================================================================

class EdgeTpuSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<EdgeTpuSettings>()._has_bits_);
  static void set_has_inference_power_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_inference_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::tflite::proto::EdgeTpuDeviceSpec& edgetpu_device_spec(const EdgeTpuSettings* msg);
  static void set_has_edgetpu_device_spec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_model_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_float_truncation_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_qos_class(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::tflite::proto::EdgeTpuDeviceSpec&
EdgeTpuSettings::_Internal::edgetpu_device_spec(const EdgeTpuSettings* msg) {
  return *msg->edgetpu_device_spec_;
}
EdgeTpuSettings::EdgeTpuSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  inactive_power_configs_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.EdgeTpuSettings)
}
EdgeTpuSettings::EdgeTpuSettings(const EdgeTpuSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      inactive_power_configs_(from.inactive_power_configs_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  model_token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model_token()) {
    model_token_.Set(from._internal_model_token(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_edgetpu_device_spec()) {
    edgetpu_device_spec_ = new ::tflite::proto::EdgeTpuDeviceSpec(*from.edgetpu_device_spec_);
  } else {
    edgetpu_device_spec_ = nullptr;
  }
  ::memcpy(&inference_power_state_, &from.inference_power_state_,
    static_cast<size_t>(reinterpret_cast<char*>(&inference_priority_) -
    reinterpret_cast<char*>(&inference_power_state_)) + sizeof(inference_priority_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.EdgeTpuSettings)
}

inline void EdgeTpuSettings::SharedCtor() {
model_token_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_token_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&edgetpu_device_spec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&qos_class_) -
    reinterpret_cast<char*>(&edgetpu_device_spec_)) + sizeof(qos_class_));
inference_priority_ = -1;
}

EdgeTpuSettings::~EdgeTpuSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.EdgeTpuSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EdgeTpuSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_token_.Destroy();
  if (this != internal_default_instance()) delete edgetpu_device_spec_;
}

void EdgeTpuSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EdgeTpuSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.EdgeTpuSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  inactive_power_configs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      model_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(edgetpu_device_spec_ != nullptr);
      edgetpu_device_spec_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&inference_power_state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&qos_class_) -
        reinterpret_cast<char*>(&inference_power_state_)) + sizeof(qos_class_));
    inference_priority_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EdgeTpuSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.EdgeTpuPowerState inference_power_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::EdgeTpuPowerState_IsValid(val))) {
            _internal_set_inference_power_state(static_cast<::tflite::proto::EdgeTpuPowerState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .tflite.proto.EdgeTpuInactivePowerConfig inactive_power_configs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_inactive_power_configs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 inference_priority = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_inference_priority(&has_bits);
          inference_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.EdgeTpuDeviceSpec edgetpu_device_spec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_edgetpu_device_spec(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model_token = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_model_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.EdgeTpuSettings.FloatTruncationType float_truncation_type = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::EdgeTpuSettings_FloatTruncationType_IsValid(val))) {
            _internal_set_float_truncation_type(static_cast<::tflite::proto::EdgeTpuSettings_FloatTruncationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.EdgeTpuSettings.QosClass qos_class = 7 [default = QOS_UNDEFINED];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::EdgeTpuSettings_QosClass_IsValid(val))) {
            _internal_set_qos_class(static_cast<::tflite::proto::EdgeTpuSettings_QosClass>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EdgeTpuSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.EdgeTpuSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.EdgeTpuPowerState inference_power_state = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_inference_power_state(), target);
  }

  // repeated .tflite.proto.EdgeTpuInactivePowerConfig inactive_power_configs = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_inactive_power_configs_size()); i < n; i++) {
    const auto& repfield = this->_internal_inactive_power_configs(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 inference_priority = 3 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_inference_priority(), target);
  }

  // optional .tflite.proto.EdgeTpuDeviceSpec edgetpu_device_spec = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::edgetpu_device_spec(this),
        _Internal::edgetpu_device_spec(this).GetCachedSize(), target, stream);
  }

  // optional string model_token = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_model_token(), target);
  }

  // optional .tflite.proto.EdgeTpuSettings.FloatTruncationType float_truncation_type = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      6, this->_internal_float_truncation_type(), target);
  }

  // optional .tflite.proto.EdgeTpuSettings.QosClass qos_class = 7 [default = QOS_UNDEFINED];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_qos_class(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.EdgeTpuSettings)
  return target;
}

size_t EdgeTpuSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.EdgeTpuSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tflite.proto.EdgeTpuInactivePowerConfig inactive_power_configs = 2;
  total_size += 1UL * this->_internal_inactive_power_configs_size();
  for (const auto& msg : this->inactive_power_configs_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string model_token = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model_token());
    }

    // optional .tflite.proto.EdgeTpuDeviceSpec edgetpu_device_spec = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *edgetpu_device_spec_);
    }

    // optional .tflite.proto.EdgeTpuPowerState inference_power_state = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_inference_power_state());
    }

    // optional .tflite.proto.EdgeTpuSettings.FloatTruncationType float_truncation_type = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_float_truncation_type());
    }

    // optional .tflite.proto.EdgeTpuSettings.QosClass qos_class = 7 [default = QOS_UNDEFINED];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_qos_class());
    }

    // optional int32 inference_priority = 3 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_inference_priority());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EdgeTpuSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EdgeTpuSettings*>(
      &from));
}

void EdgeTpuSettings::MergeFrom(const EdgeTpuSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.EdgeTpuSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  inactive_power_configs_.MergeFrom(from.inactive_power_configs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model_token(from._internal_model_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_edgetpu_device_spec()->::tflite::proto::EdgeTpuDeviceSpec::MergeFrom(from._internal_edgetpu_device_spec());
    }
    if (cached_has_bits & 0x00000004u) {
      inference_power_state_ = from.inference_power_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      float_truncation_type_ = from.float_truncation_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      qos_class_ = from.qos_class_;
    }
    if (cached_has_bits & 0x00000020u) {
      inference_priority_ = from.inference_priority_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EdgeTpuSettings::CopyFrom(const EdgeTpuSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.EdgeTpuSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EdgeTpuSettings::IsInitialized() const {
  return true;
}

void EdgeTpuSettings::InternalSwap(EdgeTpuSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  inactive_power_configs_.InternalSwap(&other->inactive_power_configs_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &model_token_, lhs_arena,
      &other->model_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(EdgeTpuSettings, qos_class_)
      + sizeof(EdgeTpuSettings::qos_class_)
      - PROTOBUF_FIELD_OFFSET(EdgeTpuSettings, edgetpu_device_spec_)>(
          reinterpret_cast<char*>(&edgetpu_device_spec_),
          reinterpret_cast<char*>(&other->edgetpu_device_spec_));
  swap(inference_priority_, other->inference_priority_);
}

std::string EdgeTpuSettings::GetTypeName() const {
  return "tflite.proto.EdgeTpuSettings";
}


// ===================================================================

class CoralSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<CoralSettings>()._has_bits_);
  static void set_has_device(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_performance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_usb_always_dfu(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_usb_max_bulk_in_queue_length(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CoralSettings::CoralSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.CoralSettings)
}
CoralSettings::CoralSettings(const CoralSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  device_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device()) {
    device_.Set(from._internal_device(), 
      GetArenaForAllocation());
  }
  ::memcpy(&usb_always_dfu_, &from.usb_always_dfu_,
    static_cast<size_t>(reinterpret_cast<char*>(&performance_) -
    reinterpret_cast<char*>(&usb_always_dfu_)) + sizeof(performance_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.CoralSettings)
}

inline void CoralSettings::SharedCtor() {
device_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&usb_always_dfu_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&usb_max_bulk_in_queue_length_) -
    reinterpret_cast<char*>(&usb_always_dfu_)) + sizeof(usb_max_bulk_in_queue_length_));
performance_ = 1;
}

CoralSettings::~CoralSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.CoralSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CoralSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_.Destroy();
}

void CoralSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CoralSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.CoralSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&usb_always_dfu_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&usb_max_bulk_in_queue_length_) -
        reinterpret_cast<char*>(&usb_always_dfu_)) + sizeof(usb_max_bulk_in_queue_length_));
    performance_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CoralSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.CoralSettings.Performance performance = 2 [default = MAXIMUM];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::CoralSettings_Performance_IsValid(val))) {
            _internal_set_performance(static_cast<::tflite::proto::CoralSettings_Performance>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool usb_always_dfu = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_usb_always_dfu(&has_bits);
          usb_always_dfu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 usb_max_bulk_in_queue_length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_usb_max_bulk_in_queue_length(&has_bits);
          usb_max_bulk_in_queue_length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CoralSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.CoralSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device(), target);
  }

  // optional .tflite.proto.CoralSettings.Performance performance = 2 [default = MAXIMUM];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_performance(), target);
  }

  // optional bool usb_always_dfu = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_usb_always_dfu(), target);
  }

  // optional int32 usb_max_bulk_in_queue_length = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_usb_max_bulk_in_queue_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.CoralSettings)
  return target;
}

size_t CoralSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.CoralSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string device = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device());
    }

    // optional bool usb_always_dfu = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 usb_max_bulk_in_queue_length = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_usb_max_bulk_in_queue_length());
    }

    // optional .tflite.proto.CoralSettings.Performance performance = 2 [default = MAXIMUM];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_performance());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CoralSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CoralSettings*>(
      &from));
}

void CoralSettings::MergeFrom(const CoralSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.CoralSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device(from._internal_device());
    }
    if (cached_has_bits & 0x00000002u) {
      usb_always_dfu_ = from.usb_always_dfu_;
    }
    if (cached_has_bits & 0x00000004u) {
      usb_max_bulk_in_queue_length_ = from.usb_max_bulk_in_queue_length_;
    }
    if (cached_has_bits & 0x00000008u) {
      performance_ = from.performance_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CoralSettings::CopyFrom(const CoralSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.CoralSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CoralSettings::IsInitialized() const {
  return true;
}

void CoralSettings::InternalSwap(CoralSettings* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_, lhs_arena,
      &other->device_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CoralSettings, usb_max_bulk_in_queue_length_)
      + sizeof(CoralSettings::usb_max_bulk_in_queue_length_)
      - PROTOBUF_FIELD_OFFSET(CoralSettings, usb_always_dfu_)>(
          reinterpret_cast<char*>(&usb_always_dfu_),
          reinterpret_cast<char*>(&other->usb_always_dfu_));
  swap(performance_, other->performance_);
}

std::string CoralSettings::GetTypeName() const {
  return "tflite.proto.CoralSettings";
}


// ===================================================================

class CPUSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<CPUSettings>()._has_bits_);
  static void set_has_num_threads(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CPUSettings::CPUSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.CPUSettings)
}
CPUSettings::CPUSettings(const CPUSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  num_threads_ = from.num_threads_;
  // @@protoc_insertion_point(copy_constructor:tflite.proto.CPUSettings)
}

inline void CPUSettings::SharedCtor() {
num_threads_ = -1;
}

CPUSettings::~CPUSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.CPUSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CPUSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CPUSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CPUSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.CPUSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  num_threads_ = -1;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CPUSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 num_threads = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_num_threads(&has_bits);
          num_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CPUSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.CPUSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 num_threads = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_num_threads(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.CPUSettings)
  return target;
}

size_t CPUSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.CPUSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 num_threads = 1 [default = -1];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_threads());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CPUSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CPUSettings*>(
      &from));
}

void CPUSettings::MergeFrom(const CPUSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.CPUSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_num_threads()) {
    _internal_set_num_threads(from._internal_num_threads());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CPUSettings::CopyFrom(const CPUSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.CPUSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CPUSettings::IsInitialized() const {
  return true;
}

void CPUSettings::InternalSwap(CPUSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(num_threads_, other->num_threads_);
}

std::string CPUSettings::GetTypeName() const {
  return "tflite.proto.CPUSettings";
}


// ===================================================================

class TFLiteSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<TFLiteSettings>()._has_bits_);
  static void set_has_delegate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::tflite::proto::NNAPISettings& nnapi_settings(const TFLiteSettings* msg);
  static void set_has_nnapi_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::tflite::proto::GPUSettings& gpu_settings(const TFLiteSettings* msg);
  static void set_has_gpu_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::tflite::proto::HexagonSettings& hexagon_settings(const TFLiteSettings* msg);
  static void set_has_hexagon_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::tflite::proto::XNNPackSettings& xnnpack_settings(const TFLiteSettings* msg);
  static void set_has_xnnpack_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::tflite::proto::CoreMLSettings& coreml_settings(const TFLiteSettings* msg);
  static void set_has_coreml_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::tflite::proto::CPUSettings& cpu_settings(const TFLiteSettings* msg);
  static void set_has_cpu_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_max_delegated_partitions(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::tflite::proto::EdgeTpuSettings& edgetpu_settings(const TFLiteSettings* msg);
  static void set_has_edgetpu_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::tflite::proto::CoralSettings& coral_settings(const TFLiteSettings* msg);
  static void set_has_coral_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::tflite::proto::FallbackSettings& fallback_settings(const TFLiteSettings* msg);
  static void set_has_fallback_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_disable_default_delegates(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::tflite::proto::NNAPISettings&
TFLiteSettings::_Internal::nnapi_settings(const TFLiteSettings* msg) {
  return *msg->nnapi_settings_;
}
const ::tflite::proto::GPUSettings&
TFLiteSettings::_Internal::gpu_settings(const TFLiteSettings* msg) {
  return *msg->gpu_settings_;
}
const ::tflite::proto::HexagonSettings&
TFLiteSettings::_Internal::hexagon_settings(const TFLiteSettings* msg) {
  return *msg->hexagon_settings_;
}
const ::tflite::proto::XNNPackSettings&
TFLiteSettings::_Internal::xnnpack_settings(const TFLiteSettings* msg) {
  return *msg->xnnpack_settings_;
}
const ::tflite::proto::CoreMLSettings&
TFLiteSettings::_Internal::coreml_settings(const TFLiteSettings* msg) {
  return *msg->coreml_settings_;
}
const ::tflite::proto::CPUSettings&
TFLiteSettings::_Internal::cpu_settings(const TFLiteSettings* msg) {
  return *msg->cpu_settings_;
}
const ::tflite::proto::EdgeTpuSettings&
TFLiteSettings::_Internal::edgetpu_settings(const TFLiteSettings* msg) {
  return *msg->edgetpu_settings_;
}
const ::tflite::proto::CoralSettings&
TFLiteSettings::_Internal::coral_settings(const TFLiteSettings* msg) {
  return *msg->coral_settings_;
}
const ::tflite::proto::FallbackSettings&
TFLiteSettings::_Internal::fallback_settings(const TFLiteSettings* msg) {
  return *msg->fallback_settings_;
}
TFLiteSettings::TFLiteSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.TFLiteSettings)
}
TFLiteSettings::TFLiteSettings(const TFLiteSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_nnapi_settings()) {
    nnapi_settings_ = new ::tflite::proto::NNAPISettings(*from.nnapi_settings_);
  } else {
    nnapi_settings_ = nullptr;
  }
  if (from._internal_has_gpu_settings()) {
    gpu_settings_ = new ::tflite::proto::GPUSettings(*from.gpu_settings_);
  } else {
    gpu_settings_ = nullptr;
  }
  if (from._internal_has_hexagon_settings()) {
    hexagon_settings_ = new ::tflite::proto::HexagonSettings(*from.hexagon_settings_);
  } else {
    hexagon_settings_ = nullptr;
  }
  if (from._internal_has_xnnpack_settings()) {
    xnnpack_settings_ = new ::tflite::proto::XNNPackSettings(*from.xnnpack_settings_);
  } else {
    xnnpack_settings_ = nullptr;
  }
  if (from._internal_has_cpu_settings()) {
    cpu_settings_ = new ::tflite::proto::CPUSettings(*from.cpu_settings_);
  } else {
    cpu_settings_ = nullptr;
  }
  if (from._internal_has_edgetpu_settings()) {
    edgetpu_settings_ = new ::tflite::proto::EdgeTpuSettings(*from.edgetpu_settings_);
  } else {
    edgetpu_settings_ = nullptr;
  }
  if (from._internal_has_fallback_settings()) {
    fallback_settings_ = new ::tflite::proto::FallbackSettings(*from.fallback_settings_);
  } else {
    fallback_settings_ = nullptr;
  }
  if (from._internal_has_coral_settings()) {
    coral_settings_ = new ::tflite::proto::CoralSettings(*from.coral_settings_);
  } else {
    coral_settings_ = nullptr;
  }
  if (from._internal_has_coreml_settings()) {
    coreml_settings_ = new ::tflite::proto::CoreMLSettings(*from.coreml_settings_);
  } else {
    coreml_settings_ = nullptr;
  }
  ::memcpy(&delegate_, &from.delegate_,
    static_cast<size_t>(reinterpret_cast<char*>(&disable_default_delegates_) -
    reinterpret_cast<char*>(&delegate_)) + sizeof(disable_default_delegates_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.TFLiteSettings)
}

inline void TFLiteSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&nnapi_settings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&disable_default_delegates_) -
    reinterpret_cast<char*>(&nnapi_settings_)) + sizeof(disable_default_delegates_));
}

TFLiteSettings::~TFLiteSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.TFLiteSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TFLiteSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete nnapi_settings_;
  if (this != internal_default_instance()) delete gpu_settings_;
  if (this != internal_default_instance()) delete hexagon_settings_;
  if (this != internal_default_instance()) delete xnnpack_settings_;
  if (this != internal_default_instance()) delete cpu_settings_;
  if (this != internal_default_instance()) delete edgetpu_settings_;
  if (this != internal_default_instance()) delete fallback_settings_;
  if (this != internal_default_instance()) delete coral_settings_;
  if (this != internal_default_instance()) delete coreml_settings_;
}

void TFLiteSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TFLiteSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.TFLiteSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(nnapi_settings_ != nullptr);
      nnapi_settings_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(gpu_settings_ != nullptr);
      gpu_settings_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(hexagon_settings_ != nullptr);
      hexagon_settings_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(xnnpack_settings_ != nullptr);
      xnnpack_settings_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(cpu_settings_ != nullptr);
      cpu_settings_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(edgetpu_settings_ != nullptr);
      edgetpu_settings_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(fallback_settings_ != nullptr);
      fallback_settings_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(coral_settings_ != nullptr);
      coral_settings_->Clear();
    }
  }
  if (cached_has_bits & 0x00000100u) {
    GOOGLE_DCHECK(coreml_settings_ != nullptr);
    coreml_settings_->Clear();
  }
  if (cached_has_bits & 0x00000e00u) {
    ::memset(&delegate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disable_default_delegates_) -
        reinterpret_cast<char*>(&delegate_)) + sizeof(disable_default_delegates_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TFLiteSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.Delegate delegate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::Delegate_IsValid(val))) {
            _internal_set_delegate(static_cast<::tflite::proto::Delegate>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.NNAPISettings nnapi_settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_nnapi_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.GPUSettings gpu_settings = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_gpu_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.HexagonSettings hexagon_settings = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_hexagon_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.XNNPackSettings xnnpack_settings = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_xnnpack_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.CPUSettings cpu_settings = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_cpu_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_delegated_partitions = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_max_delegated_partitions(&has_bits);
          max_delegated_partitions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.EdgeTpuSettings edgetpu_settings = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_edgetpu_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.FallbackSettings fallback_settings = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_fallback_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.CoralSettings coral_settings = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_coral_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.CoreMLSettings coreml_settings = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_coreml_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_default_delegates = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_disable_default_delegates(&has_bits);
          disable_default_delegates_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TFLiteSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.TFLiteSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.Delegate delegate = 1;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_delegate(), target);
  }

  // optional .tflite.proto.NNAPISettings nnapi_settings = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::nnapi_settings(this),
        _Internal::nnapi_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.GPUSettings gpu_settings = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::gpu_settings(this),
        _Internal::gpu_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.HexagonSettings hexagon_settings = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::hexagon_settings(this),
        _Internal::hexagon_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.XNNPackSettings xnnpack_settings = 5;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::xnnpack_settings(this),
        _Internal::xnnpack_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.CPUSettings cpu_settings = 6;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::cpu_settings(this),
        _Internal::cpu_settings(this).GetCachedSize(), target, stream);
  }

  // optional int32 max_delegated_partitions = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_max_delegated_partitions(), target);
  }

  // optional .tflite.proto.EdgeTpuSettings edgetpu_settings = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::edgetpu_settings(this),
        _Internal::edgetpu_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.FallbackSettings fallback_settings = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::fallback_settings(this),
        _Internal::fallback_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.CoralSettings coral_settings = 10;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::coral_settings(this),
        _Internal::coral_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.CoreMLSettings coreml_settings = 11;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::coreml_settings(this),
        _Internal::coreml_settings(this).GetCachedSize(), target, stream);
  }

  // optional bool disable_default_delegates = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(12, this->_internal_disable_default_delegates(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.TFLiteSettings)
  return target;
}

size_t TFLiteSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.TFLiteSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .tflite.proto.NNAPISettings nnapi_settings = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *nnapi_settings_);
    }

    // optional .tflite.proto.GPUSettings gpu_settings = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *gpu_settings_);
    }

    // optional .tflite.proto.HexagonSettings hexagon_settings = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hexagon_settings_);
    }

    // optional .tflite.proto.XNNPackSettings xnnpack_settings = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *xnnpack_settings_);
    }

    // optional .tflite.proto.CPUSettings cpu_settings = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cpu_settings_);
    }

    // optional .tflite.proto.EdgeTpuSettings edgetpu_settings = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *edgetpu_settings_);
    }

    // optional .tflite.proto.FallbackSettings fallback_settings = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *fallback_settings_);
    }

    // optional .tflite.proto.CoralSettings coral_settings = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *coral_settings_);
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .tflite.proto.CoreMLSettings coreml_settings = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *coreml_settings_);
    }

    // optional .tflite.proto.Delegate delegate = 1;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_delegate());
    }

    // optional int32 max_delegated_partitions = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_delegated_partitions());
    }

    // optional bool disable_default_delegates = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TFLiteSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TFLiteSettings*>(
      &from));
}

void TFLiteSettings::MergeFrom(const TFLiteSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.TFLiteSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_nnapi_settings()->::tflite::proto::NNAPISettings::MergeFrom(from._internal_nnapi_settings());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_gpu_settings()->::tflite::proto::GPUSettings::MergeFrom(from._internal_gpu_settings());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_hexagon_settings()->::tflite::proto::HexagonSettings::MergeFrom(from._internal_hexagon_settings());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_xnnpack_settings()->::tflite::proto::XNNPackSettings::MergeFrom(from._internal_xnnpack_settings());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_cpu_settings()->::tflite::proto::CPUSettings::MergeFrom(from._internal_cpu_settings());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_edgetpu_settings()->::tflite::proto::EdgeTpuSettings::MergeFrom(from._internal_edgetpu_settings());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_fallback_settings()->::tflite::proto::FallbackSettings::MergeFrom(from._internal_fallback_settings());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_coral_settings()->::tflite::proto::CoralSettings::MergeFrom(from._internal_coral_settings());
    }
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_coreml_settings()->::tflite::proto::CoreMLSettings::MergeFrom(from._internal_coreml_settings());
    }
    if (cached_has_bits & 0x00000200u) {
      delegate_ = from.delegate_;
    }
    if (cached_has_bits & 0x00000400u) {
      max_delegated_partitions_ = from.max_delegated_partitions_;
    }
    if (cached_has_bits & 0x00000800u) {
      disable_default_delegates_ = from.disable_default_delegates_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TFLiteSettings::CopyFrom(const TFLiteSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.TFLiteSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TFLiteSettings::IsInitialized() const {
  return true;
}

void TFLiteSettings::InternalSwap(TFLiteSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TFLiteSettings, disable_default_delegates_)
      + sizeof(TFLiteSettings::disable_default_delegates_)
      - PROTOBUF_FIELD_OFFSET(TFLiteSettings, nnapi_settings_)>(
          reinterpret_cast<char*>(&nnapi_settings_),
          reinterpret_cast<char*>(&other->nnapi_settings_));
}

std::string TFLiteSettings::GetTypeName() const {
  return "tflite.proto.TFLiteSettings";
}


// ===================================================================

class FallbackSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<FallbackSettings>()._has_bits_);
  static void set_has_allow_automatic_fallback_on_compilation_error(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_automatic_fallback_on_execution_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

FallbackSettings::FallbackSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.FallbackSettings)
}
FallbackSettings::FallbackSettings(const FallbackSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&allow_automatic_fallback_on_compilation_error_, &from.allow_automatic_fallback_on_compilation_error_,
    static_cast<size_t>(reinterpret_cast<char*>(&allow_automatic_fallback_on_execution_error_) -
    reinterpret_cast<char*>(&allow_automatic_fallback_on_compilation_error_)) + sizeof(allow_automatic_fallback_on_execution_error_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.FallbackSettings)
}

inline void FallbackSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&allow_automatic_fallback_on_compilation_error_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_automatic_fallback_on_execution_error_) -
    reinterpret_cast<char*>(&allow_automatic_fallback_on_compilation_error_)) + sizeof(allow_automatic_fallback_on_execution_error_));
}

FallbackSettings::~FallbackSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.FallbackSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void FallbackSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void FallbackSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void FallbackSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.FallbackSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&allow_automatic_fallback_on_compilation_error_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&allow_automatic_fallback_on_execution_error_) -
      reinterpret_cast<char*>(&allow_automatic_fallback_on_compilation_error_)) + sizeof(allow_automatic_fallback_on_execution_error_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* FallbackSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool allow_automatic_fallback_on_compilation_error = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_allow_automatic_fallback_on_compilation_error(&has_bits);
          allow_automatic_fallback_on_compilation_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_automatic_fallback_on_execution_error = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_allow_automatic_fallback_on_execution_error(&has_bits);
          allow_automatic_fallback_on_execution_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* FallbackSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.FallbackSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool allow_automatic_fallback_on_compilation_error = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_allow_automatic_fallback_on_compilation_error(), target);
  }

  // optional bool allow_automatic_fallback_on_execution_error = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_allow_automatic_fallback_on_execution_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.FallbackSettings)
  return target;
}

size_t FallbackSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.FallbackSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool allow_automatic_fallback_on_compilation_error = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool allow_automatic_fallback_on_execution_error = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void FallbackSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const FallbackSettings*>(
      &from));
}

void FallbackSettings::MergeFrom(const FallbackSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.FallbackSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      allow_automatic_fallback_on_compilation_error_ = from.allow_automatic_fallback_on_compilation_error_;
    }
    if (cached_has_bits & 0x00000002u) {
      allow_automatic_fallback_on_execution_error_ = from.allow_automatic_fallback_on_execution_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void FallbackSettings::CopyFrom(const FallbackSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.FallbackSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FallbackSettings::IsInitialized() const {
  return true;
}

void FallbackSettings::InternalSwap(FallbackSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(FallbackSettings, allow_automatic_fallback_on_execution_error_)
      + sizeof(FallbackSettings::allow_automatic_fallback_on_execution_error_)
      - PROTOBUF_FIELD_OFFSET(FallbackSettings, allow_automatic_fallback_on_compilation_error_)>(
          reinterpret_cast<char*>(&allow_automatic_fallback_on_compilation_error_),
          reinterpret_cast<char*>(&other->allow_automatic_fallback_on_compilation_error_));
}

std::string FallbackSettings::GetTypeName() const {
  return "tflite.proto.FallbackSettings";
}


// ===================================================================

class BenchmarkMetric::_Internal {
 public:
  using HasBits = decltype(std::declval<BenchmarkMetric>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BenchmarkMetric::BenchmarkMetric(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  values_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BenchmarkMetric)
}
BenchmarkMetric::BenchmarkMetric(const BenchmarkMetric& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      values_(from.values_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BenchmarkMetric)
}

inline void BenchmarkMetric::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BenchmarkMetric::~BenchmarkMetric() {
  // @@protoc_insertion_point(destructor:tflite.proto.BenchmarkMetric)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BenchmarkMetric::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
}

void BenchmarkMetric::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BenchmarkMetric::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BenchmarkMetric)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  values_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BenchmarkMetric::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float values = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_values(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_values(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BenchmarkMetric::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BenchmarkMetric)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // repeated float values = 2 [packed = true];
  if (this->_internal_values_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BenchmarkMetric)
  return target;
}

size_t BenchmarkMetric::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BenchmarkMetric)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float values = 2 [packed = true];
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_values_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // optional string name = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BenchmarkMetric::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BenchmarkMetric*>(
      &from));
}

void BenchmarkMetric::MergeFrom(const BenchmarkMetric& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BenchmarkMetric)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  values_.MergeFrom(from.values_);
  if (from._internal_has_name()) {
    _internal_set_name(from._internal_name());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BenchmarkMetric::CopyFrom(const BenchmarkMetric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BenchmarkMetric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BenchmarkMetric::IsInitialized() const {
  return true;
}

void BenchmarkMetric::InternalSwap(BenchmarkMetric* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  values_.InternalSwap(&other->values_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
}

std::string BenchmarkMetric::GetTypeName() const {
  return "tflite.proto.BenchmarkMetric";
}


// ===================================================================

class BenchmarkResult::_Internal {
 public:
  using HasBits = decltype(std::declval<BenchmarkResult>()._has_bits_);
  static void set_has_max_memory_kb(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ok(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BenchmarkResult::BenchmarkResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  initialization_time_us_(arena),
  inference_time_us_(arena),
  metrics_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BenchmarkResult)
}
BenchmarkResult::BenchmarkResult(const BenchmarkResult& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      initialization_time_us_(from.initialization_time_us_),
      inference_time_us_(from.inference_time_us_),
      metrics_(from.metrics_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&max_memory_kb_, &from.max_memory_kb_,
    static_cast<size_t>(reinterpret_cast<char*>(&ok_) -
    reinterpret_cast<char*>(&max_memory_kb_)) + sizeof(ok_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BenchmarkResult)
}

inline void BenchmarkResult::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&max_memory_kb_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ok_) -
    reinterpret_cast<char*>(&max_memory_kb_)) + sizeof(ok_));
}

BenchmarkResult::~BenchmarkResult() {
  // @@protoc_insertion_point(destructor:tflite.proto.BenchmarkResult)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BenchmarkResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BenchmarkResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BenchmarkResult::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BenchmarkResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  initialization_time_us_.Clear();
  inference_time_us_.Clear();
  metrics_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&max_memory_kb_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ok_) -
        reinterpret_cast<char*>(&max_memory_kb_)) + sizeof(ok_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BenchmarkResult::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int64 initialization_time_us = 1 [packed = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_initialization_time_us(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 8) {
          _internal_add_initialization_time_us(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 inference_time_us = 2 [packed = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_inference_time_us(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_inference_time_us(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_memory_kb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_max_memory_kb(&has_bits);
          max_memory_kb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool ok = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ok(&has_bits);
          ok_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .tflite.proto.BenchmarkMetric metrics = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_metrics(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BenchmarkResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BenchmarkResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int64 initialization_time_us = 1 [packed = true];
  {
    int byte_size = _initialization_time_us_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          1, _internal_initialization_time_us(), byte_size, target);
    }
  }

  // repeated int64 inference_time_us = 2 [packed = true];
  {
    int byte_size = _inference_time_us_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_inference_time_us(), byte_size, target);
    }
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 max_memory_kb = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_max_memory_kb(), target);
  }

  // optional bool ok = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_ok(), target);
  }

  // repeated .tflite.proto.BenchmarkMetric metrics = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_metrics_size()); i < n; i++) {
    const auto& repfield = this->_internal_metrics(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BenchmarkResult)
  return target;
}

size_t BenchmarkResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BenchmarkResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 initialization_time_us = 1 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->initialization_time_us_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _initialization_time_us_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 inference_time_us = 2 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->inference_time_us_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _inference_time_us_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated .tflite.proto.BenchmarkMetric metrics = 5;
  total_size += 1UL * this->_internal_metrics_size();
  for (const auto& msg : this->metrics_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 max_memory_kb = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_memory_kb());
    }

    // optional bool ok = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BenchmarkResult::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BenchmarkResult*>(
      &from));
}

void BenchmarkResult::MergeFrom(const BenchmarkResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BenchmarkResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  initialization_time_us_.MergeFrom(from.initialization_time_us_);
  inference_time_us_.MergeFrom(from.inference_time_us_);
  metrics_.MergeFrom(from.metrics_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      max_memory_kb_ = from.max_memory_kb_;
    }
    if (cached_has_bits & 0x00000002u) {
      ok_ = from.ok_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BenchmarkResult::CopyFrom(const BenchmarkResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BenchmarkResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BenchmarkResult::IsInitialized() const {
  return true;
}

void BenchmarkResult::InternalSwap(BenchmarkResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  initialization_time_us_.InternalSwap(&other->initialization_time_us_);
  inference_time_us_.InternalSwap(&other->inference_time_us_);
  metrics_.InternalSwap(&other->metrics_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BenchmarkResult, ok_)
      + sizeof(BenchmarkResult::ok_)
      - PROTOBUF_FIELD_OFFSET(BenchmarkResult, max_memory_kb_)>(
          reinterpret_cast<char*>(&max_memory_kb_),
          reinterpret_cast<char*>(&other->max_memory_kb_));
}

std::string BenchmarkResult::GetTypeName() const {
  return "tflite.proto.BenchmarkResult";
}


// ===================================================================

class ErrorCode::_Internal {
 public:
  using HasBits = decltype(std::declval<ErrorCode>()._has_bits_);
  static void set_has_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_tflite_error(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_underlying_api_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ErrorCode::ErrorCode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.ErrorCode)
}
ErrorCode::ErrorCode(const ErrorCode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&source_, &from.source_,
    static_cast<size_t>(reinterpret_cast<char*>(&underlying_api_error_) -
    reinterpret_cast<char*>(&source_)) + sizeof(underlying_api_error_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.ErrorCode)
}

inline void ErrorCode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&source_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&underlying_api_error_) -
    reinterpret_cast<char*>(&source_)) + sizeof(underlying_api_error_));
}

ErrorCode::~ErrorCode() {
  // @@protoc_insertion_point(destructor:tflite.proto.ErrorCode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ErrorCode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ErrorCode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ErrorCode::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.ErrorCode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&source_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&underlying_api_error_) -
        reinterpret_cast<char*>(&source_)) + sizeof(underlying_api_error_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ErrorCode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.Delegate source = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::Delegate_IsValid(val))) {
            _internal_set_source(static_cast<::tflite::proto::Delegate>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 tflite_error = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tflite_error(&has_bits);
          tflite_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 underlying_api_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_underlying_api_error(&has_bits);
          underlying_api_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ErrorCode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.ErrorCode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.Delegate source = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_source(), target);
  }

  // optional int32 tflite_error = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_tflite_error(), target);
  }

  // optional int64 underlying_api_error = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_underlying_api_error(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.ErrorCode)
  return target;
}

size_t ErrorCode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.ErrorCode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .tflite.proto.Delegate source = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_source());
    }

    // optional int32 tflite_error = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tflite_error());
    }

    // optional int64 underlying_api_error = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_underlying_api_error());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ErrorCode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ErrorCode*>(
      &from));
}

void ErrorCode::MergeFrom(const ErrorCode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.ErrorCode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      source_ = from.source_;
    }
    if (cached_has_bits & 0x00000002u) {
      tflite_error_ = from.tflite_error_;
    }
    if (cached_has_bits & 0x00000004u) {
      underlying_api_error_ = from.underlying_api_error_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ErrorCode::CopyFrom(const ErrorCode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.ErrorCode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ErrorCode::IsInitialized() const {
  return true;
}

void ErrorCode::InternalSwap(ErrorCode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ErrorCode, underlying_api_error_)
      + sizeof(ErrorCode::underlying_api_error_)
      - PROTOBUF_FIELD_OFFSET(ErrorCode, source_)>(
          reinterpret_cast<char*>(&source_),
          reinterpret_cast<char*>(&other->source_));
}

std::string ErrorCode::GetTypeName() const {
  return "tflite.proto.ErrorCode";
}


// ===================================================================

class BenchmarkError::_Internal {
 public:
  using HasBits = decltype(std::declval<BenchmarkError>()._has_bits_);
  static void set_has_stage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_exit_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_signal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mini_benchmark_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

BenchmarkError::BenchmarkError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  error_code_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BenchmarkError)
}
BenchmarkError::BenchmarkError(const BenchmarkError& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      error_code_(from.error_code_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&stage_, &from.stage_,
    static_cast<size_t>(reinterpret_cast<char*>(&mini_benchmark_error_code_) -
    reinterpret_cast<char*>(&stage_)) + sizeof(mini_benchmark_error_code_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BenchmarkError)
}

inline void BenchmarkError::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stage_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mini_benchmark_error_code_) -
    reinterpret_cast<char*>(&stage_)) + sizeof(mini_benchmark_error_code_));
}

BenchmarkError::~BenchmarkError() {
  // @@protoc_insertion_point(destructor:tflite.proto.BenchmarkError)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BenchmarkError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BenchmarkError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BenchmarkError::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BenchmarkError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_code_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&stage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mini_benchmark_error_code_) -
        reinterpret_cast<char*>(&stage_)) + sizeof(mini_benchmark_error_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BenchmarkError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.BenchmarkStage stage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::BenchmarkStage_IsValid(val))) {
            _internal_set_stage(static_cast<::tflite::proto::BenchmarkStage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 exit_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_exit_code(&has_bits);
          exit_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 signal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_signal(&has_bits);
          signal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .tflite.proto.ErrorCode error_code = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_error_code(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 mini_benchmark_error_code = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_mini_benchmark_error_code(&has_bits);
          mini_benchmark_error_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BenchmarkError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BenchmarkError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.BenchmarkStage stage = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_stage(), target);
  }

  // optional int32 exit_code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_exit_code(), target);
  }

  // optional int32 signal = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_signal(), target);
  }

  // repeated .tflite.proto.ErrorCode error_code = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_error_code_size()); i < n; i++) {
    const auto& repfield = this->_internal_error_code(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 mini_benchmark_error_code = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_mini_benchmark_error_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BenchmarkError)
  return target;
}

size_t BenchmarkError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BenchmarkError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tflite.proto.ErrorCode error_code = 4;
  total_size += 1UL * this->_internal_error_code_size();
  for (const auto& msg : this->error_code_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .tflite.proto.BenchmarkStage stage = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_stage());
    }

    // optional int32 exit_code = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_exit_code());
    }

    // optional int32 signal = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_signal());
    }

    // optional int32 mini_benchmark_error_code = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_mini_benchmark_error_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BenchmarkError::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BenchmarkError*>(
      &from));
}

void BenchmarkError::MergeFrom(const BenchmarkError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BenchmarkError)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  error_code_.MergeFrom(from.error_code_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      stage_ = from.stage_;
    }
    if (cached_has_bits & 0x00000002u) {
      exit_code_ = from.exit_code_;
    }
    if (cached_has_bits & 0x00000004u) {
      signal_ = from.signal_;
    }
    if (cached_has_bits & 0x00000008u) {
      mini_benchmark_error_code_ = from.mini_benchmark_error_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BenchmarkError::CopyFrom(const BenchmarkError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BenchmarkError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BenchmarkError::IsInitialized() const {
  return true;
}

void BenchmarkError::InternalSwap(BenchmarkError* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  error_code_.InternalSwap(&other->error_code_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BenchmarkError, mini_benchmark_error_code_)
      + sizeof(BenchmarkError::mini_benchmark_error_code_)
      - PROTOBUF_FIELD_OFFSET(BenchmarkError, stage_)>(
          reinterpret_cast<char*>(&stage_),
          reinterpret_cast<char*>(&other->stage_));
}

std::string BenchmarkError::GetTypeName() const {
  return "tflite.proto.BenchmarkError";
}


// ===================================================================

class BenchmarkEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<BenchmarkEvent>()._has_bits_);
  static const ::tflite::proto::TFLiteSettings& tflite_settings(const BenchmarkEvent* msg);
  static void set_has_tflite_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_event_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::tflite::proto::BenchmarkResult& result(const BenchmarkEvent* msg);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::tflite::proto::BenchmarkError& error(const BenchmarkEvent* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_boottime_us(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_wallclock_us(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::tflite::proto::TFLiteSettings&
BenchmarkEvent::_Internal::tflite_settings(const BenchmarkEvent* msg) {
  return *msg->tflite_settings_;
}
const ::tflite::proto::BenchmarkResult&
BenchmarkEvent::_Internal::result(const BenchmarkEvent* msg) {
  return *msg->result_;
}
const ::tflite::proto::BenchmarkError&
BenchmarkEvent::_Internal::error(const BenchmarkEvent* msg) {
  return *msg->error_;
}
BenchmarkEvent::BenchmarkEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BenchmarkEvent)
}
BenchmarkEvent::BenchmarkEvent(const BenchmarkEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_tflite_settings()) {
    tflite_settings_ = new ::tflite::proto::TFLiteSettings(*from.tflite_settings_);
  } else {
    tflite_settings_ = nullptr;
  }
  if (from._internal_has_result()) {
    result_ = new ::tflite::proto::BenchmarkResult(*from.result_);
  } else {
    result_ = nullptr;
  }
  if (from._internal_has_error()) {
    error_ = new ::tflite::proto::BenchmarkError(*from.error_);
  } else {
    error_ = nullptr;
  }
  ::memcpy(&boottime_us_, &from.boottime_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&event_type_) -
    reinterpret_cast<char*>(&boottime_us_)) + sizeof(event_type_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BenchmarkEvent)
}

inline void BenchmarkEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tflite_settings_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&event_type_) -
    reinterpret_cast<char*>(&tflite_settings_)) + sizeof(event_type_));
}

BenchmarkEvent::~BenchmarkEvent() {
  // @@protoc_insertion_point(destructor:tflite.proto.BenchmarkEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BenchmarkEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete tflite_settings_;
  if (this != internal_default_instance()) delete result_;
  if (this != internal_default_instance()) delete error_;
}

void BenchmarkEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BenchmarkEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BenchmarkEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(tflite_settings_ != nullptr);
      tflite_settings_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(result_ != nullptr);
      result_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(error_ != nullptr);
      error_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&boottime_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&event_type_) -
        reinterpret_cast<char*>(&boottime_us_)) + sizeof(event_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BenchmarkEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .tflite.proto.TFLiteSettings tflite_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tflite_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkEventType event_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::tflite::proto::BenchmarkEventType_IsValid(val))) {
            _internal_set_event_type(static_cast<::tflite::proto::BenchmarkEventType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkResult result = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_result(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkError error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 boottime_us = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_boottime_us(&has_bits);
          boottime_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 wallclock_us = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_wallclock_us(&has_bits);
          wallclock_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BenchmarkEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BenchmarkEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.TFLiteSettings tflite_settings = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tflite_settings(this),
        _Internal::tflite_settings(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.BenchmarkEventType event_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_event_type(), target);
  }

  // optional .tflite.proto.BenchmarkResult result = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::result(this),
        _Internal::result(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.BenchmarkError error = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::error(this),
        _Internal::error(this).GetCachedSize(), target, stream);
  }

  // optional int64 boottime_us = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_boottime_us(), target);
  }

  // optional int64 wallclock_us = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_wallclock_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BenchmarkEvent)
  return target;
}

size_t BenchmarkEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BenchmarkEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .tflite.proto.TFLiteSettings tflite_settings = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tflite_settings_);
    }

    // optional .tflite.proto.BenchmarkResult result = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *result_);
    }

    // optional .tflite.proto.BenchmarkError error = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_);
    }

    // optional int64 boottime_us = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_boottime_us());
    }

    // optional int64 wallclock_us = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_wallclock_us());
    }

    // optional .tflite.proto.BenchmarkEventType event_type = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_event_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BenchmarkEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BenchmarkEvent*>(
      &from));
}

void BenchmarkEvent::MergeFrom(const BenchmarkEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BenchmarkEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_tflite_settings()->::tflite::proto::TFLiteSettings::MergeFrom(from._internal_tflite_settings());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_result()->::tflite::proto::BenchmarkResult::MergeFrom(from._internal_result());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_error()->::tflite::proto::BenchmarkError::MergeFrom(from._internal_error());
    }
    if (cached_has_bits & 0x00000008u) {
      boottime_us_ = from.boottime_us_;
    }
    if (cached_has_bits & 0x00000010u) {
      wallclock_us_ = from.wallclock_us_;
    }
    if (cached_has_bits & 0x00000020u) {
      event_type_ = from.event_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BenchmarkEvent::CopyFrom(const BenchmarkEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BenchmarkEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BenchmarkEvent::IsInitialized() const {
  return true;
}

void BenchmarkEvent::InternalSwap(BenchmarkEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BenchmarkEvent, event_type_)
      + sizeof(BenchmarkEvent::event_type_)
      - PROTOBUF_FIELD_OFFSET(BenchmarkEvent, tflite_settings_)>(
          reinterpret_cast<char*>(&tflite_settings_),
          reinterpret_cast<char*>(&other->tflite_settings_));
}

std::string BenchmarkEvent::GetTypeName() const {
  return "tflite.proto.BenchmarkEvent";
}


// ===================================================================

class BestAccelerationDecision::_Internal {
 public:
  using HasBits = decltype(std::declval<BestAccelerationDecision>()._has_bits_);
  static void set_has_number_of_source_events(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::tflite::proto::BenchmarkEvent& min_latency_event(const BestAccelerationDecision* msg);
  static void set_has_min_latency_event(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_min_inference_time_us(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::tflite::proto::BenchmarkEvent&
BestAccelerationDecision::_Internal::min_latency_event(const BestAccelerationDecision* msg) {
  return *msg->min_latency_event_;
}
BestAccelerationDecision::BestAccelerationDecision(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BestAccelerationDecision)
}
BestAccelerationDecision::BestAccelerationDecision(const BestAccelerationDecision& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_min_latency_event()) {
    min_latency_event_ = new ::tflite::proto::BenchmarkEvent(*from.min_latency_event_);
  } else {
    min_latency_event_ = nullptr;
  }
  ::memcpy(&min_inference_time_us_, &from.min_inference_time_us_,
    static_cast<size_t>(reinterpret_cast<char*>(&number_of_source_events_) -
    reinterpret_cast<char*>(&min_inference_time_us_)) + sizeof(number_of_source_events_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BestAccelerationDecision)
}

inline void BestAccelerationDecision::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&min_latency_event_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&number_of_source_events_) -
    reinterpret_cast<char*>(&min_latency_event_)) + sizeof(number_of_source_events_));
}

BestAccelerationDecision::~BestAccelerationDecision() {
  // @@protoc_insertion_point(destructor:tflite.proto.BestAccelerationDecision)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BestAccelerationDecision::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete min_latency_event_;
}

void BestAccelerationDecision::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BestAccelerationDecision::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BestAccelerationDecision)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(min_latency_event_ != nullptr);
    min_latency_event_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&min_inference_time_us_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&number_of_source_events_) -
        reinterpret_cast<char*>(&min_inference_time_us_)) + sizeof(number_of_source_events_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BestAccelerationDecision::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 number_of_source_events = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_number_of_source_events(&has_bits);
          number_of_source_events_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkEvent min_latency_event = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_min_latency_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 min_inference_time_us = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_min_inference_time_us(&has_bits);
          min_inference_time_us_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BestAccelerationDecision::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BestAccelerationDecision)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 number_of_source_events = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_number_of_source_events(), target);
  }

  // optional .tflite.proto.BenchmarkEvent min_latency_event = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::min_latency_event(this),
        _Internal::min_latency_event(this).GetCachedSize(), target, stream);
  }

  // optional int64 min_inference_time_us = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_min_inference_time_us(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BestAccelerationDecision)
  return target;
}

size_t BestAccelerationDecision::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BestAccelerationDecision)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .tflite.proto.BenchmarkEvent min_latency_event = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *min_latency_event_);
    }

    // optional int64 min_inference_time_us = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_min_inference_time_us());
    }

    // optional int32 number_of_source_events = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_number_of_source_events());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BestAccelerationDecision::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BestAccelerationDecision*>(
      &from));
}

void BestAccelerationDecision::MergeFrom(const BestAccelerationDecision& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BestAccelerationDecision)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_min_latency_event()->::tflite::proto::BenchmarkEvent::MergeFrom(from._internal_min_latency_event());
    }
    if (cached_has_bits & 0x00000002u) {
      min_inference_time_us_ = from.min_inference_time_us_;
    }
    if (cached_has_bits & 0x00000004u) {
      number_of_source_events_ = from.number_of_source_events_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BestAccelerationDecision::CopyFrom(const BestAccelerationDecision& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BestAccelerationDecision)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BestAccelerationDecision::IsInitialized() const {
  return true;
}

void BestAccelerationDecision::InternalSwap(BestAccelerationDecision* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(BestAccelerationDecision, number_of_source_events_)
      + sizeof(BestAccelerationDecision::number_of_source_events_)
      - PROTOBUF_FIELD_OFFSET(BestAccelerationDecision, min_latency_event_)>(
          reinterpret_cast<char*>(&min_latency_event_),
          reinterpret_cast<char*>(&other->min_latency_event_));
}

std::string BestAccelerationDecision::GetTypeName() const {
  return "tflite.proto.BestAccelerationDecision";
}


// ===================================================================

class BenchmarkInitializationFailure::_Internal {
 public:
  using HasBits = decltype(std::declval<BenchmarkInitializationFailure>()._has_bits_);
  static void set_has_initialization_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

BenchmarkInitializationFailure::BenchmarkInitializationFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BenchmarkInitializationFailure)
}
BenchmarkInitializationFailure::BenchmarkInitializationFailure(const BenchmarkInitializationFailure& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  initialization_status_ = from.initialization_status_;
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BenchmarkInitializationFailure)
}

inline void BenchmarkInitializationFailure::SharedCtor() {
initialization_status_ = 0;
}

BenchmarkInitializationFailure::~BenchmarkInitializationFailure() {
  // @@protoc_insertion_point(destructor:tflite.proto.BenchmarkInitializationFailure)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BenchmarkInitializationFailure::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BenchmarkInitializationFailure::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BenchmarkInitializationFailure::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BenchmarkInitializationFailure)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  initialization_status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BenchmarkInitializationFailure::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 initialization_status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_initialization_status(&has_bits);
          initialization_status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BenchmarkInitializationFailure::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BenchmarkInitializationFailure)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 initialization_status = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_initialization_status(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BenchmarkInitializationFailure)
  return target;
}

size_t BenchmarkInitializationFailure::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BenchmarkInitializationFailure)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 initialization_status = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_initialization_status());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BenchmarkInitializationFailure::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BenchmarkInitializationFailure*>(
      &from));
}

void BenchmarkInitializationFailure::MergeFrom(const BenchmarkInitializationFailure& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BenchmarkInitializationFailure)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_initialization_status()) {
    _internal_set_initialization_status(from._internal_initialization_status());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BenchmarkInitializationFailure::CopyFrom(const BenchmarkInitializationFailure& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BenchmarkInitializationFailure)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BenchmarkInitializationFailure::IsInitialized() const {
  return true;
}

void BenchmarkInitializationFailure::InternalSwap(BenchmarkInitializationFailure* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(initialization_status_, other->initialization_status_);
}

std::string BenchmarkInitializationFailure::GetTypeName() const {
  return "tflite.proto.BenchmarkInitializationFailure";
}


// ===================================================================

class MiniBenchmarkEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<MiniBenchmarkEvent>()._has_bits_);
  static void set_has_is_log_flushing_event(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::tflite::proto::BestAccelerationDecision& best_acceleration_decision(const MiniBenchmarkEvent* msg);
  static void set_has_best_acceleration_decision(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::tflite::proto::BenchmarkInitializationFailure& initialization_failure(const MiniBenchmarkEvent* msg);
  static void set_has_initialization_failure(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::tflite::proto::BenchmarkEvent& benchmark_event(const MiniBenchmarkEvent* msg);
  static void set_has_benchmark_event(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::tflite::proto::BestAccelerationDecision&
MiniBenchmarkEvent::_Internal::best_acceleration_decision(const MiniBenchmarkEvent* msg) {
  return *msg->best_acceleration_decision_;
}
const ::tflite::proto::BenchmarkInitializationFailure&
MiniBenchmarkEvent::_Internal::initialization_failure(const MiniBenchmarkEvent* msg) {
  return *msg->initialization_failure_;
}
const ::tflite::proto::BenchmarkEvent&
MiniBenchmarkEvent::_Internal::benchmark_event(const MiniBenchmarkEvent* msg) {
  return *msg->benchmark_event_;
}
MiniBenchmarkEvent::MiniBenchmarkEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.MiniBenchmarkEvent)
}
MiniBenchmarkEvent::MiniBenchmarkEvent(const MiniBenchmarkEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_best_acceleration_decision()) {
    best_acceleration_decision_ = new ::tflite::proto::BestAccelerationDecision(*from.best_acceleration_decision_);
  } else {
    best_acceleration_decision_ = nullptr;
  }
  if (from._internal_has_initialization_failure()) {
    initialization_failure_ = new ::tflite::proto::BenchmarkInitializationFailure(*from.initialization_failure_);
  } else {
    initialization_failure_ = nullptr;
  }
  if (from._internal_has_benchmark_event()) {
    benchmark_event_ = new ::tflite::proto::BenchmarkEvent(*from.benchmark_event_);
  } else {
    benchmark_event_ = nullptr;
  }
  is_log_flushing_event_ = from.is_log_flushing_event_;
  // @@protoc_insertion_point(copy_constructor:tflite.proto.MiniBenchmarkEvent)
}

inline void MiniBenchmarkEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&best_acceleration_decision_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_log_flushing_event_) -
    reinterpret_cast<char*>(&best_acceleration_decision_)) + sizeof(is_log_flushing_event_));
}

MiniBenchmarkEvent::~MiniBenchmarkEvent() {
  // @@protoc_insertion_point(destructor:tflite.proto.MiniBenchmarkEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MiniBenchmarkEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete best_acceleration_decision_;
  if (this != internal_default_instance()) delete initialization_failure_;
  if (this != internal_default_instance()) delete benchmark_event_;
}

void MiniBenchmarkEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MiniBenchmarkEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.MiniBenchmarkEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(best_acceleration_decision_ != nullptr);
      best_acceleration_decision_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(initialization_failure_ != nullptr);
      initialization_failure_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(benchmark_event_ != nullptr);
      benchmark_event_->Clear();
    }
  }
  is_log_flushing_event_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MiniBenchmarkEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_log_flushing_event = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_log_flushing_event(&has_bits);
          is_log_flushing_event_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BestAccelerationDecision best_acceleration_decision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_best_acceleration_decision(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkInitializationFailure initialization_failure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_initialization_failure(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkEvent benchmark_event = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_benchmark_event(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MiniBenchmarkEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.MiniBenchmarkEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_log_flushing_event = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_log_flushing_event(), target);
  }

  // optional .tflite.proto.BestAccelerationDecision best_acceleration_decision = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::best_acceleration_decision(this),
        _Internal::best_acceleration_decision(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.BenchmarkInitializationFailure initialization_failure = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::initialization_failure(this),
        _Internal::initialization_failure(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.BenchmarkEvent benchmark_event = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::benchmark_event(this),
        _Internal::benchmark_event(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.MiniBenchmarkEvent)
  return target;
}

size_t MiniBenchmarkEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.MiniBenchmarkEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .tflite.proto.BestAccelerationDecision best_acceleration_decision = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *best_acceleration_decision_);
    }

    // optional .tflite.proto.BenchmarkInitializationFailure initialization_failure = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *initialization_failure_);
    }

    // optional .tflite.proto.BenchmarkEvent benchmark_event = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *benchmark_event_);
    }

    // optional bool is_log_flushing_event = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MiniBenchmarkEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MiniBenchmarkEvent*>(
      &from));
}

void MiniBenchmarkEvent::MergeFrom(const MiniBenchmarkEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.MiniBenchmarkEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_best_acceleration_decision()->::tflite::proto::BestAccelerationDecision::MergeFrom(from._internal_best_acceleration_decision());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_initialization_failure()->::tflite::proto::BenchmarkInitializationFailure::MergeFrom(from._internal_initialization_failure());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_benchmark_event()->::tflite::proto::BenchmarkEvent::MergeFrom(from._internal_benchmark_event());
    }
    if (cached_has_bits & 0x00000008u) {
      is_log_flushing_event_ = from.is_log_flushing_event_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MiniBenchmarkEvent::CopyFrom(const MiniBenchmarkEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.MiniBenchmarkEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MiniBenchmarkEvent::IsInitialized() const {
  return true;
}

void MiniBenchmarkEvent::InternalSwap(MiniBenchmarkEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MiniBenchmarkEvent, is_log_flushing_event_)
      + sizeof(MiniBenchmarkEvent::is_log_flushing_event_)
      - PROTOBUF_FIELD_OFFSET(MiniBenchmarkEvent, best_acceleration_decision_)>(
          reinterpret_cast<char*>(&best_acceleration_decision_),
          reinterpret_cast<char*>(&other->best_acceleration_decision_));
}

std::string MiniBenchmarkEvent::GetTypeName() const {
  return "tflite.proto.MiniBenchmarkEvent";
}


// ===================================================================

class ModelFile::_Internal {
 public:
  using HasBits = decltype(std::declval<ModelFile>()._has_bits_);
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fd(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ModelFile::ModelFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.ModelFile)
}
ModelFile::ModelFile(const ModelFile& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    filename_.Set(from._internal_filename(), 
      GetArenaForAllocation());
  }
  ::memcpy(&fd_, &from.fd_,
    static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&fd_)) + sizeof(length_));
  // @@protoc_insertion_point(copy_constructor:tflite.proto.ModelFile)
}

inline void ModelFile::SharedCtor() {
filename_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  filename_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fd_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&length_) -
    reinterpret_cast<char*>(&fd_)) + sizeof(length_));
}

ModelFile::~ModelFile() {
  // @@protoc_insertion_point(destructor:tflite.proto.ModelFile)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ModelFile::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  filename_.Destroy();
}

void ModelFile::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ModelFile::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.ModelFile)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    filename_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&fd_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&length_) -
        reinterpret_cast<char*>(&fd_)) + sizeof(length_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ModelFile::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string filename = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 fd = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fd(&has_bits);
          fd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 offset = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 length = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_length(&has_bits);
          length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ModelFile::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.ModelFile)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string filename = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_filename(), target);
  }

  // optional int64 fd = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_fd(), target);
  }

  // optional int64 offset = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_offset(), target);
  }

  // optional int64 length = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_length(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.ModelFile)
  return target;
}

size_t ModelFile::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.ModelFile)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string filename = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional int64 fd = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_fd());
    }

    // optional int64 offset = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_offset());
    }

    // optional int64 length = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_length());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ModelFile::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ModelFile*>(
      &from));
}

void ModelFile::MergeFrom(const ModelFile& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.ModelFile)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000002u) {
      fd_ = from.fd_;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    if (cached_has_bits & 0x00000008u) {
      length_ = from.length_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ModelFile::CopyFrom(const ModelFile& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.ModelFile)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ModelFile::IsInitialized() const {
  return true;
}

void ModelFile::InternalSwap(ModelFile* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &filename_, lhs_arena,
      &other->filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ModelFile, length_)
      + sizeof(ModelFile::length_)
      - PROTOBUF_FIELD_OFFSET(ModelFile, fd_)>(
          reinterpret_cast<char*>(&fd_),
          reinterpret_cast<char*>(&other->fd_));
}

std::string ModelFile::GetTypeName() const {
  return "tflite.proto.ModelFile";
}


// ===================================================================

class BenchmarkStoragePaths::_Internal {
 public:
  using HasBits = decltype(std::declval<BenchmarkStoragePaths>()._has_bits_);
  static void set_has_storage_file_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data_directory_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

BenchmarkStoragePaths::BenchmarkStoragePaths(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.BenchmarkStoragePaths)
}
BenchmarkStoragePaths::BenchmarkStoragePaths(const BenchmarkStoragePaths& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  storage_file_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    storage_file_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_storage_file_path()) {
    storage_file_path_.Set(from._internal_storage_file_path(), 
      GetArenaForAllocation());
  }
  data_directory_path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_directory_path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data_directory_path()) {
    data_directory_path_.Set(from._internal_data_directory_path(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:tflite.proto.BenchmarkStoragePaths)
}

inline void BenchmarkStoragePaths::SharedCtor() {
storage_file_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  storage_file_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
data_directory_path_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_directory_path_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

BenchmarkStoragePaths::~BenchmarkStoragePaths() {
  // @@protoc_insertion_point(destructor:tflite.proto.BenchmarkStoragePaths)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BenchmarkStoragePaths::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  storage_file_path_.Destroy();
  data_directory_path_.Destroy();
}

void BenchmarkStoragePaths::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void BenchmarkStoragePaths::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.BenchmarkStoragePaths)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      storage_file_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      data_directory_path_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* BenchmarkStoragePaths::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string storage_file_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_storage_file_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string data_directory_path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data_directory_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BenchmarkStoragePaths::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.BenchmarkStoragePaths)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string storage_file_path = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_storage_file_path(), target);
  }

  // optional string data_directory_path = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_data_directory_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.BenchmarkStoragePaths)
  return target;
}

size_t BenchmarkStoragePaths::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.BenchmarkStoragePaths)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string storage_file_path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_storage_file_path());
    }

    // optional string data_directory_path = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_data_directory_path());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void BenchmarkStoragePaths::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const BenchmarkStoragePaths*>(
      &from));
}

void BenchmarkStoragePaths::MergeFrom(const BenchmarkStoragePaths& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.BenchmarkStoragePaths)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_storage_file_path(from._internal_storage_file_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_data_directory_path(from._internal_data_directory_path());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void BenchmarkStoragePaths::CopyFrom(const BenchmarkStoragePaths& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.BenchmarkStoragePaths)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BenchmarkStoragePaths::IsInitialized() const {
  return true;
}

void BenchmarkStoragePaths::InternalSwap(BenchmarkStoragePaths* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &storage_file_path_, lhs_arena,
      &other->storage_file_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &data_directory_path_, lhs_arena,
      &other->data_directory_path_, rhs_arena
  );
}

std::string BenchmarkStoragePaths::GetTypeName() const {
  return "tflite.proto.BenchmarkStoragePaths";
}


// ===================================================================

class MinibenchmarkSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<MinibenchmarkSettings>()._has_bits_);
  static const ::tflite::proto::ModelFile& model_file(const MinibenchmarkSettings* msg);
  static void set_has_model_file(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::tflite::proto::BenchmarkStoragePaths& storage_paths(const MinibenchmarkSettings* msg);
  static void set_has_storage_paths(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::tflite::proto::ModelFile&
MinibenchmarkSettings::_Internal::model_file(const MinibenchmarkSettings* msg) {
  return *msg->model_file_;
}
const ::tflite::proto::BenchmarkStoragePaths&
MinibenchmarkSettings::_Internal::storage_paths(const MinibenchmarkSettings* msg) {
  return *msg->storage_paths_;
}
MinibenchmarkSettings::MinibenchmarkSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  settings_to_test_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:tflite.proto.MinibenchmarkSettings)
}
MinibenchmarkSettings::MinibenchmarkSettings(const MinibenchmarkSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      settings_to_test_(from.settings_to_test_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_model_file()) {
    model_file_ = new ::tflite::proto::ModelFile(*from.model_file_);
  } else {
    model_file_ = nullptr;
  }
  if (from._internal_has_storage_paths()) {
    storage_paths_ = new ::tflite::proto::BenchmarkStoragePaths(*from.storage_paths_);
  } else {
    storage_paths_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:tflite.proto.MinibenchmarkSettings)
}

inline void MinibenchmarkSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&model_file_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&storage_paths_) -
    reinterpret_cast<char*>(&model_file_)) + sizeof(storage_paths_));
}

MinibenchmarkSettings::~MinibenchmarkSettings() {
  // @@protoc_insertion_point(destructor:tflite.proto.MinibenchmarkSettings)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MinibenchmarkSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete model_file_;
  if (this != internal_default_instance()) delete storage_paths_;
}

void MinibenchmarkSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MinibenchmarkSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:tflite.proto.MinibenchmarkSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  settings_to_test_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(model_file_ != nullptr);
      model_file_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(storage_paths_ != nullptr);
      storage_paths_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MinibenchmarkSettings::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .tflite.proto.TFLiteSettings settings_to_test = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_settings_to_test(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.ModelFile model_file = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_model_file(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .tflite.proto.BenchmarkStoragePaths storage_paths = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_storage_paths(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MinibenchmarkSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:tflite.proto.MinibenchmarkSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .tflite.proto.TFLiteSettings settings_to_test = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_settings_to_test_size()); i < n; i++) {
    const auto& repfield = this->_internal_settings_to_test(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .tflite.proto.ModelFile model_file = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::model_file(this),
        _Internal::model_file(this).GetCachedSize(), target, stream);
  }

  // optional .tflite.proto.BenchmarkStoragePaths storage_paths = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::storage_paths(this),
        _Internal::storage_paths(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:tflite.proto.MinibenchmarkSettings)
  return target;
}

size_t MinibenchmarkSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:tflite.proto.MinibenchmarkSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .tflite.proto.TFLiteSettings settings_to_test = 1;
  total_size += 1UL * this->_internal_settings_to_test_size();
  for (const auto& msg : this->settings_to_test_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .tflite.proto.ModelFile model_file = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *model_file_);
    }

    // optional .tflite.proto.BenchmarkStoragePaths storage_paths = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *storage_paths_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MinibenchmarkSettings::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MinibenchmarkSettings*>(
      &from));
}

void MinibenchmarkSettings::MergeFrom(const MinibenchmarkSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:tflite.proto.MinibenchmarkSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  settings_to_test_.MergeFrom(from.settings_to_test_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_model_file()->::tflite::proto::ModelFile::MergeFrom(from._internal_model_file());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_storage_paths()->::tflite::proto::BenchmarkStoragePaths::MergeFrom(from._internal_storage_paths());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MinibenchmarkSettings::CopyFrom(const MinibenchmarkSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:tflite.proto.MinibenchmarkSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MinibenchmarkSettings::IsInitialized() const {
  return true;
}

void MinibenchmarkSettings::InternalSwap(MinibenchmarkSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  settings_to_test_.InternalSwap(&other->settings_to_test_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MinibenchmarkSettings, storage_paths_)
      + sizeof(MinibenchmarkSettings::storage_paths_)
      - PROTOBUF_FIELD_OFFSET(MinibenchmarkSettings, model_file_)>(
          reinterpret_cast<char*>(&model_file_),
          reinterpret_cast<char*>(&other->model_file_));
}

std::string MinibenchmarkSettings::GetTypeName() const {
  return "tflite.proto.MinibenchmarkSettings";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace tflite
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::tflite::proto::ComputeSettings*
Arena::CreateMaybeMessage< ::tflite::proto::ComputeSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::ComputeSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::NNAPISettings*
Arena::CreateMaybeMessage< ::tflite::proto::NNAPISettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::NNAPISettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::GPUSettings*
Arena::CreateMaybeMessage< ::tflite::proto::GPUSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::GPUSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::HexagonSettings*
Arena::CreateMaybeMessage< ::tflite::proto::HexagonSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::HexagonSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::XNNPackSettings*
Arena::CreateMaybeMessage< ::tflite::proto::XNNPackSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::XNNPackSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::CoreMLSettings*
Arena::CreateMaybeMessage< ::tflite::proto::CoreMLSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::CoreMLSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::EdgeTpuDeviceSpec*
Arena::CreateMaybeMessage< ::tflite::proto::EdgeTpuDeviceSpec >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::EdgeTpuDeviceSpec >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::EdgeTpuInactivePowerConfig*
Arena::CreateMaybeMessage< ::tflite::proto::EdgeTpuInactivePowerConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::EdgeTpuInactivePowerConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::EdgeTpuSettings*
Arena::CreateMaybeMessage< ::tflite::proto::EdgeTpuSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::EdgeTpuSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::CoralSettings*
Arena::CreateMaybeMessage< ::tflite::proto::CoralSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::CoralSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::CPUSettings*
Arena::CreateMaybeMessage< ::tflite::proto::CPUSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::CPUSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::TFLiteSettings*
Arena::CreateMaybeMessage< ::tflite::proto::TFLiteSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::TFLiteSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::FallbackSettings*
Arena::CreateMaybeMessage< ::tflite::proto::FallbackSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::FallbackSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BenchmarkMetric*
Arena::CreateMaybeMessage< ::tflite::proto::BenchmarkMetric >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BenchmarkMetric >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BenchmarkResult*
Arena::CreateMaybeMessage< ::tflite::proto::BenchmarkResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BenchmarkResult >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::ErrorCode*
Arena::CreateMaybeMessage< ::tflite::proto::ErrorCode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::ErrorCode >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BenchmarkError*
Arena::CreateMaybeMessage< ::tflite::proto::BenchmarkError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BenchmarkError >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BenchmarkEvent*
Arena::CreateMaybeMessage< ::tflite::proto::BenchmarkEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BenchmarkEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BestAccelerationDecision*
Arena::CreateMaybeMessage< ::tflite::proto::BestAccelerationDecision >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BestAccelerationDecision >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BenchmarkInitializationFailure*
Arena::CreateMaybeMessage< ::tflite::proto::BenchmarkInitializationFailure >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BenchmarkInitializationFailure >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::MiniBenchmarkEvent*
Arena::CreateMaybeMessage< ::tflite::proto::MiniBenchmarkEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::MiniBenchmarkEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::ModelFile*
Arena::CreateMaybeMessage< ::tflite::proto::ModelFile >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::ModelFile >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::BenchmarkStoragePaths*
Arena::CreateMaybeMessage< ::tflite::proto::BenchmarkStoragePaths >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::BenchmarkStoragePaths >(arena);
}
template<> PROTOBUF_NOINLINE ::tflite::proto::MinibenchmarkSettings*
Arena::CreateMaybeMessage< ::tflite::proto::MinibenchmarkSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::tflite::proto::MinibenchmarkSettings >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
