{"version":3,"file":"LinearMemoryInspectorController_test.js","sourceRoot":"","sources":["../../../../../../../../../../../../third_party/devtools-frontend/src/test/unittests/front_end/ui/components/linear_memory_inspector/LinearMemoryInspectorController_test.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as SDK from '../../../../../../front_end/core/sdk/sdk.js';\nimport type * as Bindings from '../../../../../../front_end/models/bindings/bindings.js';\nimport * as LinearMemoryInspector from '../../../../../../front_end/ui/components/linear_memory_inspector/linear_memory_inspector.js';\nimport {describeWithEnvironment} from '../../../helpers/EnvironmentHelpers.js';\n\nconst {assert} = chai;\nconst {LinearMemoryInspectorController, ValueInterpreterDisplayUtils} = LinearMemoryInspector;\n\nclass MockRemoteObject extends SDK.RemoteObject.LocalJSONObject {\n  private objSubtype?: string;\n\n  constructor(array: ArrayBuffer) {\n    super(array);\n  }\n\n  arrayBufferByteLength() {\n    return this.value.byteLength;\n  }\n\n  get subtype(): string|undefined {\n    return 'arraybuffer';\n  }\n}\n\nfunction createWrapper(array: Uint8Array) {\n  const mockRemoteObj = new MockRemoteObject(array.buffer);\n  const mockRemoteArrayBuffer = new SDK.RemoteObject.RemoteArrayBuffer(mockRemoteObj);\n  return new LinearMemoryInspectorController.RemoteArrayBufferWrapper(mockRemoteArrayBuffer);\n}\n\ndescribeWithEnvironment('LinearMemoryInspectorController', () => {\n  it('throws an error on an invalid (out-of-bounds) memory range request', async () => {\n    const array = new Uint8Array([2, 4, 6, 2, 4]);\n    const wrapper = createWrapper(array);\n    try {\n      await LinearMemoryInspectorController.LinearMemoryInspectorController.getMemoryRange(wrapper, 10, 20);\n      throw new Error('Function did now throw.');\n    } catch (e) {\n      const error = e as Error;\n      assert.strictEqual(error.message, 'Requested range is out of bounds.');\n    }\n  });\n\n  it('throws an error on an invalid memory range request', async () => {\n    const array = new Uint8Array([2, 4, 6, 2, 4]);\n    const wrapper = createWrapper(array);\n    try {\n      await LinearMemoryInspectorController.LinearMemoryInspectorController.getMemoryRange(wrapper, 20, 10);\n      throw new Error('Function did now throw.');\n    } catch (e) {\n      const error = e as Error;\n      assert.strictEqual(error.message, 'Requested range is out of bounds.');\n    }\n  });\n\n  it('can pull updated data on memory range request', async () => {\n    const array = new Uint8Array([2, 4, 6, 2, 4]);\n    const wrapper = createWrapper(array);\n    const valuesBefore =\n        await LinearMemoryInspectorController.LinearMemoryInspectorController.getMemoryRange(wrapper, 0, array.length);\n\n    assert.strictEqual(valuesBefore.length, array.length);\n    for (let i = 0; i < array.length; ++i) {\n      assert.strictEqual(valuesBefore[i], array[i]);\n    }\n\n    const changedIndex = 0;\n    const changedValue = 10;\n    array[changedIndex] = changedValue;\n    const valuesAfter =\n        await LinearMemoryInspectorController.LinearMemoryInspectorController.getMemoryRange(wrapper, 0, array.length);\n\n    assert.strictEqual(valuesAfter.length, valuesBefore.length);\n    for (let i = 0; i < valuesBefore.length; ++i) {\n      if (i === changedIndex) {\n        assert.strictEqual(valuesAfter[i], changedValue);\n      } else {\n        assert.strictEqual(valuesAfter[i], valuesBefore[i]);\n      }\n    }\n  });\n\n  it('triggers saving and loading of settings on settings changed event', () => {\n    const instance = LinearMemoryInspectorController.LinearMemoryInspectorController.instance();\n\n    const valueTypes =\n        new Set([ValueInterpreterDisplayUtils.ValueType.Int16, ValueInterpreterDisplayUtils.ValueType.Float32]);\n    const valueTypeModes = new Map(\n        [[ValueInterpreterDisplayUtils.ValueType.Int16, ValueInterpreterDisplayUtils.ValueTypeMode.Hexadecimal]]);\n    const settings = {\n      valueTypes,\n      modes: valueTypeModes,\n      endianness: ValueInterpreterDisplayUtils.Endianness.Little,\n    };\n    const defaultSettings = instance.loadSettings();\n    instance.saveSettings(settings);\n\n    assert.notDeepEqual(defaultSettings, settings);\n\n    const actualSettings = instance.loadSettings();\n    assert.deepEqual(actualSettings, settings);\n  });\n\n  it('retrieves size of non-pointer ValueNode', () => {\n    const expectedSize = 20;\n    const mockValueNode = {\n      sourceType: {\n        typeMap: new Map<number, object>([\n          [1, {}],\n        ]),\n        typeInfo: {\n          size: expectedSize,\n          members: [{name: 'not_a_pointer', typeId: 1}],\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const size = LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectSize(mockValueNode);\n    assert.strictEqual(size, expectedSize);\n  });\n\n  it('retrieves object size for a pointer ValueNode', () => {\n    const expectedSize = 8;\n    const pointerSize = 4;\n    const nestedValueNode = {\n      sourceType: {\n        typeInfo: {\n          size: expectedSize,\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const pointerValueNode = {\n      sourceType: {\n        typeMap: new Map<number, object>([\n          [1, nestedValueNode.sourceType],\n        ]),\n        typeInfo: {\n          size: pointerSize,\n          members: [{name: '*', typeId: 1}],\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const size = LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectSize(pointerValueNode);\n    assert.strictEqual(size, expectedSize);\n  });\n\n  it('retrieves pointer size for a pointer-to-pointer ValueNode', () => {\n    const expectedSize = 4;\n    const pointerSize = 4;\n    const nestedValueNode = {\n      sourceType: {\n        typeInfo: {\n          size: 8,\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const nestedPointerValueNode = {\n      sourceType: {\n        typeInfo: {\n          size: expectedSize,\n          members: [{name: '*', typeId: 2}],\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const pointerValueNode = {\n      sourceType: {\n        typeMap: new Map<number, object>([\n          [1, nestedPointerValueNode.sourceType],\n          [2, nestedValueNode.sourceType],\n        ]),\n        typeInfo: {\n          size: pointerSize,\n          members: [{name: '*', typeId: 1}],\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const size = LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectSize(pointerValueNode);\n    assert.strictEqual(size, expectedSize);\n  });\n\n  it('throws an error when retrieving size of non-conforming (multiple pointer members) ValueNode', () => {\n    const expectedSize = 8;\n    const pointerSize = 4;\n    const nestedValueNode = {\n      sourceType: {\n        typeInfo: {\n          size: expectedSize,\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    const pointerValueNode = {\n      sourceType: {\n        typeMap: new Map<number, object>([\n          [1, nestedValueNode.sourceType],\n          [2, nestedValueNode.sourceType],\n        ]),\n        typeInfo: {\n          size: pointerSize,\n          members: [{name: '*', typeId: 1}, {name: '*', typeId: 2}],\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    try {\n      LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectSize(pointerValueNode);\n      throw new Error('Function did now throw an error.');\n    } catch (e) {\n      const error = e as Error;\n      assert.strictEqual(error.message, 'The number of pointers in typeInfo.members should not be greater than one.');\n    }\n  });\n\n  it('throws an error when retrieving size of non-conforming (typedId not in typeMap) ValueNode', () => {\n    const pointerValueNode = {\n      sourceType: {\n        typeMap: new Map<number, object>([\n          [42, {}],\n        ]),\n        typeInfo: {\n          size: 4,\n          members: [{name: '*', typeId: 1}],\n        },\n      },\n    } as Bindings.DebuggerLanguagePlugins.ValueNode;\n\n    try {\n      LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectSize(pointerValueNode);\n      throw new Error('Function did now throw an error.');\n    } catch (e) {\n      const error = e as Error;\n      assert.strictEqual(error.message, 'Cannot find the source type information for typeId 1.');\n    }\n  });\n\n  it('returns undefined when error happens in evaluateExpression', async () => {\n    const errorText = 'This is a test error';\n    const callFrame = {\n      evaluate: ({}) => {\n        return new Promise(resolve => {\n          resolve({error: errorText} as SDK.RuntimeModel.EvaluationResult);\n        });\n      },\n    } as SDK.DebuggerModel.CallFrame;\n    const stub = sinon.stub(console, 'error');\n    const instance = LinearMemoryInspectorController.LinearMemoryInspectorController.instance();\n    const expressionName = 'myCar';\n    const result = await instance.evaluateExpression(callFrame, expressionName);\n    assert.strictEqual(result, undefined);\n    assert.isTrue(stub.calledOnceWithExactly(\n        `Tried to evaluate the expression '${expressionName}' but got an error: ${errorText}`));\n  });\n\n  it('returns undefined when exceptionDetails is set on the result of evaluateExpression', async () => {\n    const exceptionText = 'This is a test exception\\'s detail text';\n    const callFrame = {\n      evaluate: ({}) => {\n        return new Promise(resolve => {\n          resolve({\n            object: {type: 'object'} as SDK.RemoteObject.RemoteObject,\n            exceptionDetails: {text: exceptionText},\n          } as SDK.RuntimeModel.EvaluationResult);\n        });\n      },\n    } as SDK.DebuggerModel.CallFrame;\n    const stub = sinon.stub(console, 'error');\n    const instance = LinearMemoryInspectorController.LinearMemoryInspectorController.instance();\n    const expressionName = 'myCar.manufacturer';\n    const result = await instance.evaluateExpression(callFrame, expressionName);\n    assert.strictEqual(result, undefined);\n    assert.isTrue(stub.calledOnceWithExactly(\n        `Tried to evaluate the expression '${expressionName}' but got an exception: ${exceptionText}`));\n  });\n\n  it('returns RemoteObject when no exception happens in evaluateExpression', async () => {\n    const expectedObj = {type: 'object'} as SDK.RemoteObject.RemoteObject;\n    const callFrame = {\n      evaluate: ({}) => {\n        return new Promise(resolve => {\n          resolve({\n            object: expectedObj,\n          } as SDK.RuntimeModel.EvaluationResult);\n        });\n      },\n    } as SDK.DebuggerModel.CallFrame;\n    const instance = LinearMemoryInspectorController.LinearMemoryInspectorController.instance();\n    const result = await instance.evaluateExpression(callFrame, 'myCar.manufacturer');\n    assert.deepEqual(result, expectedObj);\n  });\n\n  it('extracts array type correctly', () => {\n    const obj = {description: 'int[]'} as Bindings.DebuggerLanguagePlugins.ValueNode;\n    const extractedType = LinearMemoryInspector.LinearMemoryInspectorController.LinearMemoryInspectorController\n                              .extractObjectTypeDescription(obj);\n    assert.strictEqual(extractedType, 'int[]');\n  });\n\n  it('extracts multi-level pointer correctly', () => {\n    const obj = {description: 'int **'} as Bindings.DebuggerLanguagePlugins.ValueNode;\n    const extractedType = LinearMemoryInspector.LinearMemoryInspectorController.LinearMemoryInspectorController\n                              .extractObjectTypeDescription(obj);\n    assert.strictEqual(extractedType, 'int *');\n  });\n\n  it('extracts reference type correctly', () => {\n    const obj = {description: 'int &'} as Bindings.DebuggerLanguagePlugins.ValueNode;\n    const extractedType = LinearMemoryInspector.LinearMemoryInspectorController.LinearMemoryInspectorController\n                              .extractObjectTypeDescription(obj);\n    assert.strictEqual(extractedType, 'int');\n  });\n\n  it('extracts pointer type correctly', () => {\n    const obj = {description: 'int *'} as Bindings.DebuggerLanguagePlugins.ValueNode;\n    const extractedType = LinearMemoryInspector.LinearMemoryInspectorController.LinearMemoryInspectorController\n                              .extractObjectTypeDescription(obj);\n    assert.strictEqual(extractedType, 'int');\n  });\n\n  it('removes the provided highlightInfo when it is stored in the Controller', () => {\n    const highlightInfo = {startAddress: 0, size: 16, name: 'myNumbers', type: 'int[]'} as\n        LinearMemoryInspector.LinearMemoryViewerUtils.HighlightInfo;\n    const bufferId = 'someBufferId';\n    const instance = LinearMemoryInspectorController.LinearMemoryInspectorController.instance();\n\n    instance.setHighlightInfo(bufferId, highlightInfo);\n    assert.deepEqual(instance.getHighlightInfo(bufferId), highlightInfo);\n\n    instance.removeHighlight(bufferId, highlightInfo);\n    assert.deepEqual(instance.getHighlightInfo(bufferId), undefined);\n  });\n\n  it('does not change the stored highlight when the provided highlightInfo does not match', () => {\n    const highlightInfo = {startAddress: 0, size: 16, name: 'myNumbers', type: 'int[]'} as\n        LinearMemoryInspector.LinearMemoryViewerUtils.HighlightInfo;\n    const differentHighlightInfo = {startAddress: 20, size: 50, name: 'myBytes', type: 'bool[]'} as\n        LinearMemoryInspector.LinearMemoryViewerUtils.HighlightInfo;\n    const bufferId = 'someBufferId';\n    const instance = LinearMemoryInspectorController.LinearMemoryInspectorController.instance();\n\n    instance.setHighlightInfo(bufferId, highlightInfo);\n    assert.deepEqual(instance.getHighlightInfo(bufferId), highlightInfo);\n\n    instance.removeHighlight(bufferId, differentHighlightInfo);\n    assert.deepEqual(instance.getHighlightInfo(bufferId), highlightInfo);\n  });\n\n  it('extracts name unchanged when object is not pointer', () => {\n    const name = 'myNumbers';\n    const obj = {description: 'int[]'} as Bindings.DebuggerLanguagePlugins.ValueNode;\n    const extractedName =\n        LinearMemoryInspector.LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectName(\n            obj, name);\n    assert.strictEqual(extractedName, name);\n  });\n\n  it('extracts name with preprended \\'*\\' when object is a pointer', () => {\n    const name = 'myPointerObject';\n    const obj = {description: 'int *'} as Bindings.DebuggerLanguagePlugins.ValueNode;\n    const extractedName =\n        LinearMemoryInspector.LinearMemoryInspectorController.LinearMemoryInspectorController.extractObjectName(\n            obj, name);\n    assert.strictEqual(extractedName, '*' + name);\n  });\n});\n\ndescribe('RemoteArrayBufferWrapper', () => {\n  it('correctly wraps the remote object', async () => {\n    const array = new Uint8Array([2, 4, 6, 2, 4]);\n    const wrapper = createWrapper(array);\n\n    assert.strictEqual(wrapper.length(), array.length);\n\n    const extractedArray = await wrapper.getRange(0, 3);\n    assert.lengthOf(extractedArray, 3);\n\n    for (let i = 0; i < 3; ++i) {\n      assert.deepEqual(array[i], extractedArray[i]);\n    }\n  });\n});\n"]}