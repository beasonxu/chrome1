// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remoting.proto

#include "remoting.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace openscreen {
namespace cast {
PROTOBUF_CONSTEXPR DecoderBuffer::DecoderBuffer(
    ::_pbi::ConstantInitialized)
  : side_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , timestamp_usec_(int64_t{0})
  , duration_usec_(int64_t{0})
  , front_discard_usec_(int64_t{0})
  , back_discard_usec_(int64_t{0})
  , is_key_frame_(false)
  , is_eos_(false){}
struct DecoderBufferDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DecoderBufferDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DecoderBufferDefaultTypeInternal() {}
  union {
    DecoderBuffer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DecoderBufferDefaultTypeInternal _DecoderBuffer_default_instance_;
PROTOBUF_CONSTEXPR Size::Size(
    ::_pbi::ConstantInitialized)
  : width_(0)
  , height_(0){}
struct SizeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SizeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SizeDefaultTypeInternal() {}
  union {
    Size _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SizeDefaultTypeInternal _Size_default_instance_;
PROTOBUF_CONSTEXPR AudioDecoderConfig::AudioDecoderConfig(
    ::_pbi::ConstantInitialized)
  : extra_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , codec_(0)

  , sample_format_(0)

  , channel_layout_(0)

  , samples_per_second_(0)
  , seek_preroll_usec_(int64_t{0})
  , codec_delay_(0){}
struct AudioDecoderConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioDecoderConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioDecoderConfigDefaultTypeInternal() {}
  union {
    AudioDecoderConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioDecoderConfigDefaultTypeInternal _AudioDecoderConfig_default_instance_;
PROTOBUF_CONSTEXPR Rect::Rect(
    ::_pbi::ConstantInitialized)
  : x_(0)
  , y_(0)
  , width_(0)
  , height_(0){}
struct RectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectDefaultTypeInternal() {}
  union {
    Rect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectDefaultTypeInternal _Rect_default_instance_;
PROTOBUF_CONSTEXPR VideoDecoderConfig::VideoDecoderConfig(
    ::_pbi::ConstantInitialized)
  : extra_data_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , coded_size_(nullptr)
  , visible_rect_(nullptr)
  , natural_size_(nullptr)
  , codec_(0)

  , format_(0)

  , color_space_(0)

  , profile_(-1)
{}
struct VideoDecoderConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoDecoderConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoDecoderConfigDefaultTypeInternal() {}
  union {
    VideoDecoderConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoDecoderConfigDefaultTypeInternal _VideoDecoderConfig_default_instance_;
PROTOBUF_CONSTEXPR AudioDecoderInfo::AudioDecoderInfo(
    ::_pbi::ConstantInitialized)
  : decoder_type_(int64_t{0})
  , is_platform_decoder_(false){}
struct AudioDecoderInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AudioDecoderInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AudioDecoderInfoDefaultTypeInternal() {}
  union {
    AudioDecoderInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AudioDecoderInfoDefaultTypeInternal _AudioDecoderInfo_default_instance_;
PROTOBUF_CONSTEXPR VideoDecoderInfo::VideoDecoderInfo(
    ::_pbi::ConstantInitialized)
  : decoder_type_(int64_t{0})
  , is_platform_decoder_(false){}
struct VideoDecoderInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR VideoDecoderInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~VideoDecoderInfoDefaultTypeInternal() {}
  union {
    VideoDecoderInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 VideoDecoderInfoDefaultTypeInternal _VideoDecoderInfo_default_instance_;
PROTOBUF_CONSTEXPR PipelineStatistics::PipelineStatistics(
    ::_pbi::ConstantInitialized)
  : audio_decoder_info_(nullptr)
  , video_decoder_info_(nullptr)
  , audio_bytes_decoded_(uint64_t{0u})
  , video_bytes_decoded_(uint64_t{0u})
  , video_frames_decoded_(0u)
  , video_frames_dropped_(0u)
  , audio_memory_usage_(int64_t{0})
  , video_memory_usage_(int64_t{0})
  , video_frame_duration_average_usec_(int64_t{0}){}
struct PipelineStatisticsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PipelineStatisticsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PipelineStatisticsDefaultTypeInternal() {}
  union {
    PipelineStatistics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PipelineStatisticsDefaultTypeInternal _PipelineStatistics_default_instance_;
PROTOBUF_CONSTEXPR AcquireDemuxer::AcquireDemuxer(
    ::_pbi::ConstantInitialized)
  : audio_demuxer_handle_(0)
  , video_demuxer_handle_(0){}
struct AcquireDemuxerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR AcquireDemuxerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~AcquireDemuxerDefaultTypeInternal() {}
  union {
    AcquireDemuxer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 AcquireDemuxerDefaultTypeInternal _AcquireDemuxer_default_instance_;
PROTOBUF_CONSTEXPR RendererInitialize::RendererInitialize(
    ::_pbi::ConstantInitialized)
  : client_handle_(0)
  , audio_demuxer_handle_(0)
  , video_demuxer_handle_(0)
  , callback_handle_(0){}
struct RendererInitializeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RendererInitializeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RendererInitializeDefaultTypeInternal() {}
  union {
    RendererInitialize _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RendererInitializeDefaultTypeInternal _RendererInitialize_default_instance_;
PROTOBUF_CONSTEXPR RendererFlushUntil::RendererFlushUntil(
    ::_pbi::ConstantInitialized)
  : audio_count_(0u)
  , video_count_(0u)
  , callback_handle_(0){}
struct RendererFlushUntilDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RendererFlushUntilDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RendererFlushUntilDefaultTypeInternal() {}
  union {
    RendererFlushUntil _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RendererFlushUntilDefaultTypeInternal _RendererFlushUntil_default_instance_;
PROTOBUF_CONSTEXPR RendererClientOnTimeUpdate::RendererClientOnTimeUpdate(
    ::_pbi::ConstantInitialized)
  : time_usec_(int64_t{0})
  , max_time_usec_(int64_t{0}){}
struct RendererClientOnTimeUpdateDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RendererClientOnTimeUpdateDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RendererClientOnTimeUpdateDefaultTypeInternal() {}
  union {
    RendererClientOnTimeUpdate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RendererClientOnTimeUpdateDefaultTypeInternal _RendererClientOnTimeUpdate_default_instance_;
PROTOBUF_CONSTEXPR RendererClientOnBufferingStateChange::RendererClientOnBufferingStateChange(
    ::_pbi::ConstantInitialized)
  : state_(0)
{}
struct RendererClientOnBufferingStateChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RendererClientOnBufferingStateChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RendererClientOnBufferingStateChangeDefaultTypeInternal() {}
  union {
    RendererClientOnBufferingStateChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RendererClientOnBufferingStateChangeDefaultTypeInternal _RendererClientOnBufferingStateChange_default_instance_;
PROTOBUF_CONSTEXPR RendererClientOnAudioConfigChange::RendererClientOnAudioConfigChange(
    ::_pbi::ConstantInitialized)
  : audio_decoder_config_(nullptr){}
struct RendererClientOnAudioConfigChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RendererClientOnAudioConfigChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RendererClientOnAudioConfigChangeDefaultTypeInternal() {}
  union {
    RendererClientOnAudioConfigChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RendererClientOnAudioConfigChangeDefaultTypeInternal _RendererClientOnAudioConfigChange_default_instance_;
PROTOBUF_CONSTEXPR RendererClientOnVideoConfigChange::RendererClientOnVideoConfigChange(
    ::_pbi::ConstantInitialized)
  : video_decoder_config_(nullptr){}
struct RendererClientOnVideoConfigChangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RendererClientOnVideoConfigChangeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RendererClientOnVideoConfigChangeDefaultTypeInternal() {}
  union {
    RendererClientOnVideoConfigChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RendererClientOnVideoConfigChangeDefaultTypeInternal _RendererClientOnVideoConfigChange_default_instance_;
PROTOBUF_CONSTEXPR DemuxerStreamReadUntil::DemuxerStreamReadUntil(
    ::_pbi::ConstantInitialized)
  : callback_handle_(0)
  , count_(0u){}
struct DemuxerStreamReadUntilDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DemuxerStreamReadUntilDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DemuxerStreamReadUntilDefaultTypeInternal() {}
  union {
    DemuxerStreamReadUntil _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DemuxerStreamReadUntilDefaultTypeInternal _DemuxerStreamReadUntil_default_instance_;
PROTOBUF_CONSTEXPR DemuxerStreamInitializeCallback::DemuxerStreamInitializeCallback(
    ::_pbi::ConstantInitialized)
  : audio_decoder_config_(nullptr)
  , video_decoder_config_(nullptr)
  , type_(0){}
struct DemuxerStreamInitializeCallbackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DemuxerStreamInitializeCallbackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DemuxerStreamInitializeCallbackDefaultTypeInternal() {}
  union {
    DemuxerStreamInitializeCallback _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DemuxerStreamInitializeCallbackDefaultTypeInternal _DemuxerStreamInitializeCallback_default_instance_;
PROTOBUF_CONSTEXPR DemuxerStreamReadUntilCallback::DemuxerStreamReadUntilCallback(
    ::_pbi::ConstantInitialized)
  : audio_decoder_config_(nullptr)
  , video_decoder_config_(nullptr)
  , status_(0)

  , count_(0u){}
struct DemuxerStreamReadUntilCallbackDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DemuxerStreamReadUntilCallbackDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DemuxerStreamReadUntilCallbackDefaultTypeInternal() {}
  union {
    DemuxerStreamReadUntilCallback _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DemuxerStreamReadUntilCallbackDefaultTypeInternal _DemuxerStreamReadUntilCallback_default_instance_;
PROTOBUF_CONSTEXPR RpcMessage::RpcMessage(
    ::_pbi::ConstantInitialized)
  : handle_(0)
  , proc_(0)

  , _oneof_case_{}{}
struct RpcMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RpcMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RpcMessageDefaultTypeInternal() {}
  union {
    RpcMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RpcMessageDefaultTypeInternal _RpcMessage_default_instance_;
}  // namespace cast
}  // namespace openscreen
namespace openscreen {
namespace cast {
bool AudioDecoderConfig_Codec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioDecoderConfig_Codec_strings[20] = {};

static const char AudioDecoderConfig_Codec_names[] =
  "kCodecAAC"
  "kCodecAC3"
  "kCodecALAC"
  "kCodecAMR_NB"
  "kCodecAMR_WB"
  "kCodecDTS"
  "kCodecDTSXP2"
  "kCodecEAC3"
  "kCodecFLAC"
  "kCodecGSM_MS"
  "kCodecMP3"
  "kCodecMpegHAudio"
  "kCodecOpus"
  "kCodecPCM"
  "kCodecPCM_ALAW"
  "kCodecPCM_MULAW"
  "kCodecPCM_S16BE"
  "kCodecPCM_S24BE"
  "kCodecVorbis"
  "kUnknownAudioCodec";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioDecoderConfig_Codec_entries[] = {
  { {AudioDecoderConfig_Codec_names + 0, 9}, 1 },
  { {AudioDecoderConfig_Codec_names + 9, 9}, 16 },
  { {AudioDecoderConfig_Codec_names + 18, 10}, 15 },
  { {AudioDecoderConfig_Codec_names + 28, 12}, 6 },
  { {AudioDecoderConfig_Codec_names + 40, 12}, 7 },
  { {AudioDecoderConfig_Codec_names + 52, 9}, 18 },
  { {AudioDecoderConfig_Codec_names + 61, 12}, 19 },
  { {AudioDecoderConfig_Codec_names + 73, 10}, 13 },
  { {AudioDecoderConfig_Codec_names + 83, 10}, 5 },
  { {AudioDecoderConfig_Codec_names + 93, 12}, 9 },
  { {AudioDecoderConfig_Codec_names + 105, 9}, 2 },
  { {AudioDecoderConfig_Codec_names + 114, 16}, 17 },
  { {AudioDecoderConfig_Codec_names + 130, 10}, 12 },
  { {AudioDecoderConfig_Codec_names + 140, 9}, 3 },
  { {AudioDecoderConfig_Codec_names + 149, 14}, 14 },
  { {AudioDecoderConfig_Codec_names + 163, 15}, 8 },
  { {AudioDecoderConfig_Codec_names + 178, 15}, 10 },
  { {AudioDecoderConfig_Codec_names + 193, 15}, 11 },
  { {AudioDecoderConfig_Codec_names + 208, 12}, 4 },
  { {AudioDecoderConfig_Codec_names + 220, 18}, 0 },
};

static const int AudioDecoderConfig_Codec_entries_by_number[] = {
  19, // 0 -> kUnknownAudioCodec
  0, // 1 -> kCodecAAC
  10, // 2 -> kCodecMP3
  13, // 3 -> kCodecPCM
  18, // 4 -> kCodecVorbis
  8, // 5 -> kCodecFLAC
  3, // 6 -> kCodecAMR_NB
  4, // 7 -> kCodecAMR_WB
  15, // 8 -> kCodecPCM_MULAW
  9, // 9 -> kCodecGSM_MS
  16, // 10 -> kCodecPCM_S16BE
  17, // 11 -> kCodecPCM_S24BE
  12, // 12 -> kCodecOpus
  7, // 13 -> kCodecEAC3
  14, // 14 -> kCodecPCM_ALAW
  2, // 15 -> kCodecALAC
  1, // 16 -> kCodecAC3
  11, // 17 -> kCodecMpegHAudio
  5, // 18 -> kCodecDTS
  6, // 19 -> kCodecDTSXP2
};

const std::string& AudioDecoderConfig_Codec_Name(
    AudioDecoderConfig_Codec value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioDecoderConfig_Codec_entries,
          AudioDecoderConfig_Codec_entries_by_number,
          20, AudioDecoderConfig_Codec_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioDecoderConfig_Codec_entries,
      AudioDecoderConfig_Codec_entries_by_number,
      20, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioDecoderConfig_Codec_strings[idx].get();
}
bool AudioDecoderConfig_Codec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioDecoderConfig_Codec* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioDecoderConfig_Codec_entries, 20, name, &int_value);
  if (success) {
    *value = static_cast<AudioDecoderConfig_Codec>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kUnknownAudioCodec;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecAAC;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecMP3;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecPCM;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecVorbis;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecFLAC;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecAMR_NB;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecAMR_WB;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecPCM_MULAW;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecGSM_MS;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecPCM_S16BE;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecPCM_S24BE;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecOpus;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecEAC3;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecPCM_ALAW;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecALAC;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecAC3;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecMpegHAudio;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecDTS;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::kCodecDTSXP2;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::Codec_MIN;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig::Codec_MAX;
constexpr int AudioDecoderConfig::Codec_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AudioDecoderConfig_SampleFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioDecoderConfig_SampleFormat_strings[15] = {};

static const char AudioDecoderConfig_SampleFormat_names[] =
  "kSampleFormatAc3"
  "kSampleFormatDts"
  "kSampleFormatDtsxP2"
  "kSampleFormatEac3"
  "kSampleFormatF32"
  "kSampleFormatMpegHAudio"
  "kSampleFormatPlanarF32"
  "kSampleFormatPlanarS16"
  "kSampleFormatPlanarS32"
  "kSampleFormatPlanarU8"
  "kSampleFormatS16"
  "kSampleFormatS24"
  "kSampleFormatS32"
  "kSampleFormatU8"
  "kUnknownSampleFormat";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioDecoderConfig_SampleFormat_entries[] = {
  { {AudioDecoderConfig_SampleFormat_names + 0, 16}, 9 },
  { {AudioDecoderConfig_SampleFormat_names + 16, 16}, 13 },
  { {AudioDecoderConfig_SampleFormat_names + 32, 19}, 14 },
  { {AudioDecoderConfig_SampleFormat_names + 51, 17}, 10 },
  { {AudioDecoderConfig_SampleFormat_names + 68, 16}, 4 },
  { {AudioDecoderConfig_SampleFormat_names + 84, 23}, 11 },
  { {AudioDecoderConfig_SampleFormat_names + 107, 22}, 6 },
  { {AudioDecoderConfig_SampleFormat_names + 129, 22}, 5 },
  { {AudioDecoderConfig_SampleFormat_names + 151, 22}, 7 },
  { {AudioDecoderConfig_SampleFormat_names + 173, 21}, 12 },
  { {AudioDecoderConfig_SampleFormat_names + 194, 16}, 2 },
  { {AudioDecoderConfig_SampleFormat_names + 210, 16}, 8 },
  { {AudioDecoderConfig_SampleFormat_names + 226, 16}, 3 },
  { {AudioDecoderConfig_SampleFormat_names + 242, 15}, 1 },
  { {AudioDecoderConfig_SampleFormat_names + 257, 20}, 0 },
};

static const int AudioDecoderConfig_SampleFormat_entries_by_number[] = {
  14, // 0 -> kUnknownSampleFormat
  13, // 1 -> kSampleFormatU8
  10, // 2 -> kSampleFormatS16
  12, // 3 -> kSampleFormatS32
  4, // 4 -> kSampleFormatF32
  7, // 5 -> kSampleFormatPlanarS16
  6, // 6 -> kSampleFormatPlanarF32
  8, // 7 -> kSampleFormatPlanarS32
  11, // 8 -> kSampleFormatS24
  0, // 9 -> kSampleFormatAc3
  3, // 10 -> kSampleFormatEac3
  5, // 11 -> kSampleFormatMpegHAudio
  9, // 12 -> kSampleFormatPlanarU8
  1, // 13 -> kSampleFormatDts
  2, // 14 -> kSampleFormatDtsxP2
};

const std::string& AudioDecoderConfig_SampleFormat_Name(
    AudioDecoderConfig_SampleFormat value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioDecoderConfig_SampleFormat_entries,
          AudioDecoderConfig_SampleFormat_entries_by_number,
          15, AudioDecoderConfig_SampleFormat_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioDecoderConfig_SampleFormat_entries,
      AudioDecoderConfig_SampleFormat_entries_by_number,
      15, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioDecoderConfig_SampleFormat_strings[idx].get();
}
bool AudioDecoderConfig_SampleFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioDecoderConfig_SampleFormat* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioDecoderConfig_SampleFormat_entries, 15, name, &int_value);
  if (success) {
    *value = static_cast<AudioDecoderConfig_SampleFormat>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kUnknownSampleFormat;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatU8;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatS16;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatS32;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatF32;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatPlanarS16;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatPlanarF32;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatPlanarS32;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatS24;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatAc3;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatEac3;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatMpegHAudio;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatPlanarU8;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatDts;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::kSampleFormatDtsxP2;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::SampleFormat_MIN;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig::SampleFormat_MAX;
constexpr int AudioDecoderConfig::SampleFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool AudioDecoderConfig_ChannelLayout_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> AudioDecoderConfig_ChannelLayout_strings[33] = {};

static const char AudioDecoderConfig_ChannelLayout_names[] =
  "CHANNEL_LAYOUT_2POINT1"
  "CHANNEL_LAYOUT_2_1"
  "CHANNEL_LAYOUT_2_2"
  "CHANNEL_LAYOUT_3_1"
  "CHANNEL_LAYOUT_4_0"
  "CHANNEL_LAYOUT_4_1"
  "CHANNEL_LAYOUT_4_1_QUAD_SIDE"
  "CHANNEL_LAYOUT_5_0"
  "CHANNEL_LAYOUT_5_0_BACK"
  "CHANNEL_LAYOUT_5_1"
  "CHANNEL_LAYOUT_5_1_BACK"
  "CHANNEL_LAYOUT_6_0"
  "CHANNEL_LAYOUT_6_0_FRONT"
  "CHANNEL_LAYOUT_6_1"
  "CHANNEL_LAYOUT_6_1_BACK"
  "CHANNEL_LAYOUT_6_1_FRONT"
  "CHANNEL_LAYOUT_7_0"
  "CHANNEL_LAYOUT_7_0_FRONT"
  "CHANNEL_LAYOUT_7_1"
  "CHANNEL_LAYOUT_7_1_WIDE"
  "CHANNEL_LAYOUT_7_1_WIDE_BACK"
  "CHANNEL_LAYOUT_BITSTREAM"
  "CHANNEL_LAYOUT_DISCRETE"
  "CHANNEL_LAYOUT_HEXAGONAL"
  "CHANNEL_LAYOUT_MONO"
  "CHANNEL_LAYOUT_NONE"
  "CHANNEL_LAYOUT_OCTAGONAL"
  "CHANNEL_LAYOUT_QUAD"
  "CHANNEL_LAYOUT_STEREO"
  "CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC"
  "CHANNEL_LAYOUT_STEREO_DOWNMIX"
  "CHANNEL_LAYOUT_SURROUND"
  "CHANNEL_LAYOUT_UNSUPPORTED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry AudioDecoderConfig_ChannelLayout_entries[] = {
  { {AudioDecoderConfig_ChannelLayout_names + 0, 22}, 17 },
  { {AudioDecoderConfig_ChannelLayout_names + 22, 18}, 4 },
  { {AudioDecoderConfig_ChannelLayout_names + 40, 18}, 7 },
  { {AudioDecoderConfig_ChannelLayout_names + 58, 18}, 18 },
  { {AudioDecoderConfig_ChannelLayout_names + 76, 18}, 6 },
  { {AudioDecoderConfig_ChannelLayout_names + 94, 18}, 19 },
  { {AudioDecoderConfig_ChannelLayout_names + 112, 28}, 31 },
  { {AudioDecoderConfig_ChannelLayout_names + 140, 18}, 9 },
  { {AudioDecoderConfig_ChannelLayout_names + 158, 23}, 11 },
  { {AudioDecoderConfig_ChannelLayout_names + 181, 18}, 10 },
  { {AudioDecoderConfig_ChannelLayout_names + 199, 23}, 12 },
  { {AudioDecoderConfig_ChannelLayout_names + 222, 18}, 20 },
  { {AudioDecoderConfig_ChannelLayout_names + 240, 24}, 21 },
  { {AudioDecoderConfig_ChannelLayout_names + 264, 18}, 23 },
  { {AudioDecoderConfig_ChannelLayout_names + 282, 23}, 24 },
  { {AudioDecoderConfig_ChannelLayout_names + 305, 24}, 25 },
  { {AudioDecoderConfig_ChannelLayout_names + 329, 18}, 13 },
  { {AudioDecoderConfig_ChannelLayout_names + 347, 24}, 26 },
  { {AudioDecoderConfig_ChannelLayout_names + 371, 18}, 14 },
  { {AudioDecoderConfig_ChannelLayout_names + 389, 23}, 15 },
  { {AudioDecoderConfig_ChannelLayout_names + 412, 28}, 27 },
  { {AudioDecoderConfig_ChannelLayout_names + 440, 24}, 32 },
  { {AudioDecoderConfig_ChannelLayout_names + 464, 23}, 29 },
  { {AudioDecoderConfig_ChannelLayout_names + 487, 24}, 22 },
  { {AudioDecoderConfig_ChannelLayout_names + 511, 19}, 2 },
  { {AudioDecoderConfig_ChannelLayout_names + 530, 19}, 0 },
  { {AudioDecoderConfig_ChannelLayout_names + 549, 24}, 28 },
  { {AudioDecoderConfig_ChannelLayout_names + 573, 19}, 8 },
  { {AudioDecoderConfig_ChannelLayout_names + 592, 21}, 3 },
  { {AudioDecoderConfig_ChannelLayout_names + 613, 38}, 30 },
  { {AudioDecoderConfig_ChannelLayout_names + 651, 29}, 16 },
  { {AudioDecoderConfig_ChannelLayout_names + 680, 23}, 5 },
  { {AudioDecoderConfig_ChannelLayout_names + 703, 26}, 1 },
};

static const int AudioDecoderConfig_ChannelLayout_entries_by_number[] = {
  25, // 0 -> CHANNEL_LAYOUT_NONE
  32, // 1 -> CHANNEL_LAYOUT_UNSUPPORTED
  24, // 2 -> CHANNEL_LAYOUT_MONO
  28, // 3 -> CHANNEL_LAYOUT_STEREO
  1, // 4 -> CHANNEL_LAYOUT_2_1
  31, // 5 -> CHANNEL_LAYOUT_SURROUND
  4, // 6 -> CHANNEL_LAYOUT_4_0
  2, // 7 -> CHANNEL_LAYOUT_2_2
  27, // 8 -> CHANNEL_LAYOUT_QUAD
  7, // 9 -> CHANNEL_LAYOUT_5_0
  9, // 10 -> CHANNEL_LAYOUT_5_1
  8, // 11 -> CHANNEL_LAYOUT_5_0_BACK
  10, // 12 -> CHANNEL_LAYOUT_5_1_BACK
  16, // 13 -> CHANNEL_LAYOUT_7_0
  18, // 14 -> CHANNEL_LAYOUT_7_1
  19, // 15 -> CHANNEL_LAYOUT_7_1_WIDE
  30, // 16 -> CHANNEL_LAYOUT_STEREO_DOWNMIX
  0, // 17 -> CHANNEL_LAYOUT_2POINT1
  3, // 18 -> CHANNEL_LAYOUT_3_1
  5, // 19 -> CHANNEL_LAYOUT_4_1
  11, // 20 -> CHANNEL_LAYOUT_6_0
  12, // 21 -> CHANNEL_LAYOUT_6_0_FRONT
  23, // 22 -> CHANNEL_LAYOUT_HEXAGONAL
  13, // 23 -> CHANNEL_LAYOUT_6_1
  14, // 24 -> CHANNEL_LAYOUT_6_1_BACK
  15, // 25 -> CHANNEL_LAYOUT_6_1_FRONT
  17, // 26 -> CHANNEL_LAYOUT_7_0_FRONT
  20, // 27 -> CHANNEL_LAYOUT_7_1_WIDE_BACK
  26, // 28 -> CHANNEL_LAYOUT_OCTAGONAL
  22, // 29 -> CHANNEL_LAYOUT_DISCRETE
  29, // 30 -> CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC
  6, // 31 -> CHANNEL_LAYOUT_4_1_QUAD_SIDE
  21, // 32 -> CHANNEL_LAYOUT_BITSTREAM
};

const std::string& AudioDecoderConfig_ChannelLayout_Name(
    AudioDecoderConfig_ChannelLayout value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          AudioDecoderConfig_ChannelLayout_entries,
          AudioDecoderConfig_ChannelLayout_entries_by_number,
          33, AudioDecoderConfig_ChannelLayout_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      AudioDecoderConfig_ChannelLayout_entries,
      AudioDecoderConfig_ChannelLayout_entries_by_number,
      33, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     AudioDecoderConfig_ChannelLayout_strings[idx].get();
}
bool AudioDecoderConfig_ChannelLayout_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioDecoderConfig_ChannelLayout* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      AudioDecoderConfig_ChannelLayout_entries, 33, name, &int_value);
  if (success) {
    *value = static_cast<AudioDecoderConfig_ChannelLayout>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_NONE;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_UNSUPPORTED;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_MONO;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_STEREO;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_2_1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_SURROUND;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_4_0;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_2_2;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_QUAD;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_5_0;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_5_1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_5_0_BACK;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_5_1_BACK;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_7_0;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_7_1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_7_1_WIDE;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_STEREO_DOWNMIX;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_2POINT1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_3_1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_4_1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_6_0;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_6_0_FRONT;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_HEXAGONAL;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_6_1;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_6_1_BACK;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_6_1_FRONT;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_7_0_FRONT;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_7_1_WIDE_BACK;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_OCTAGONAL;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_DISCRETE;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_4_1_QUAD_SIDE;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::CHANNEL_LAYOUT_BITSTREAM;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::ChannelLayout_MIN;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig::ChannelLayout_MAX;
constexpr int AudioDecoderConfig::ChannelLayout_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VideoDecoderConfig_Codec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VideoDecoderConfig_Codec_strings[11] = {};

static const char VideoDecoderConfig_Codec_names[] =
  "kCodecAV1"
  "kCodecDolbyVision"
  "kCodecH264"
  "kCodecHEVC"
  "kCodecMPEG2"
  "kCodecMPEG4"
  "kCodecTheora"
  "kCodecVC1"
  "kCodecVP8"
  "kCodecVP9"
  "kUnknownVideoCodec";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VideoDecoderConfig_Codec_entries[] = {
  { {VideoDecoderConfig_Codec_names + 0, 9}, 10 },
  { {VideoDecoderConfig_Codec_names + 9, 17}, 9 },
  { {VideoDecoderConfig_Codec_names + 26, 10}, 1 },
  { {VideoDecoderConfig_Codec_names + 36, 10}, 8 },
  { {VideoDecoderConfig_Codec_names + 46, 11}, 3 },
  { {VideoDecoderConfig_Codec_names + 57, 11}, 4 },
  { {VideoDecoderConfig_Codec_names + 68, 12}, 5 },
  { {VideoDecoderConfig_Codec_names + 80, 9}, 2 },
  { {VideoDecoderConfig_Codec_names + 89, 9}, 6 },
  { {VideoDecoderConfig_Codec_names + 98, 9}, 7 },
  { {VideoDecoderConfig_Codec_names + 107, 18}, 0 },
};

static const int VideoDecoderConfig_Codec_entries_by_number[] = {
  10, // 0 -> kUnknownVideoCodec
  2, // 1 -> kCodecH264
  7, // 2 -> kCodecVC1
  4, // 3 -> kCodecMPEG2
  5, // 4 -> kCodecMPEG4
  6, // 5 -> kCodecTheora
  8, // 6 -> kCodecVP8
  9, // 7 -> kCodecVP9
  3, // 8 -> kCodecHEVC
  1, // 9 -> kCodecDolbyVision
  0, // 10 -> kCodecAV1
};

const std::string& VideoDecoderConfig_Codec_Name(
    VideoDecoderConfig_Codec value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VideoDecoderConfig_Codec_entries,
          VideoDecoderConfig_Codec_entries_by_number,
          11, VideoDecoderConfig_Codec_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VideoDecoderConfig_Codec_entries,
      VideoDecoderConfig_Codec_entries_by_number,
      11, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VideoDecoderConfig_Codec_strings[idx].get();
}
bool VideoDecoderConfig_Codec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_Codec* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VideoDecoderConfig_Codec_entries, 11, name, &int_value);
  if (success) {
    *value = static_cast<VideoDecoderConfig_Codec>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kUnknownVideoCodec;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecH264;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecVC1;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecMPEG2;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecMPEG4;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecTheora;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecVP8;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecVP9;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecHEVC;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecDolbyVision;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::kCodecAV1;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::Codec_MIN;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig::Codec_MAX;
constexpr int VideoDecoderConfig::Codec_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VideoDecoderConfig_Profile_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VideoDecoderConfig_Profile_strings[38] = {};

static const char VideoDecoderConfig_Profile_names[] =
  "AV1PROFILE_PROFILE_HIGH"
  "AV1PROFILE_PROFILE_MAIN"
  "AV1PROFILE_PROFILE_PRO"
  "DOLBYVISION_PROFILE0"
  "DOLBYVISION_PROFILE4"
  "DOLBYVISION_PROFILE5"
  "DOLBYVISION_PROFILE7"
  "DOLBYVISION_PROFILE8"
  "DOLBYVISION_PROFILE9"
  "H264PROFILE_BASELINE"
  "H264PROFILE_EXTENDED"
  "H264PROFILE_HIGH"
  "H264PROFILE_HIGH10PROFILE"
  "H264PROFILE_HIGH422PROFILE"
  "H264PROFILE_HIGH444PREDICTIVEPROFILE"
  "H264PROFILE_MAIN"
  "H264PROFILE_MULTIVIEWHIGH"
  "H264PROFILE_SCALABLEBASELINE"
  "H264PROFILE_SCALABLEHIGH"
  "H264PROFILE_STEREOHIGH"
  "HEVCPROFILE_3D_MAIN"
  "HEVCPROFILE_HIGH_THROUGHPUT"
  "HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED"
  "HEVCPROFILE_MAIN"
  "HEVCPROFILE_MAIN10"
  "HEVCPROFILE_MAIN_STILL_PICTURE"
  "HEVCPROFILE_MULTIVIEW_MAIN"
  "HEVCPROFILE_REXT"
  "HEVCPROFILE_SCALABLE_MAIN"
  "HEVCPROFILE_SCALABLE_REXT"
  "HEVCPROFILE_SCREEN_EXTENDED"
  "THEORAPROFILE_ANY"
  "VIDEO_CODEC_PROFILE_UNKNOWN"
  "VP8PROFILE_ANY"
  "VP9PROFILE_PROFILE0"
  "VP9PROFILE_PROFILE1"
  "VP9PROFILE_PROFILE2"
  "VP9PROFILE_PROFILE3";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VideoDecoderConfig_Profile_entries[] = {
  { {VideoDecoderConfig_Profile_names + 0, 23}, 25 },
  { {VideoDecoderConfig_Profile_names + 23, 23}, 24 },
  { {VideoDecoderConfig_Profile_names + 46, 22}, 26 },
  { {VideoDecoderConfig_Profile_names + 68, 20}, 19 },
  { {VideoDecoderConfig_Profile_names + 88, 20}, 20 },
  { {VideoDecoderConfig_Profile_names + 108, 20}, 21 },
  { {VideoDecoderConfig_Profile_names + 128, 20}, 22 },
  { {VideoDecoderConfig_Profile_names + 148, 20}, 27 },
  { {VideoDecoderConfig_Profile_names + 168, 20}, 28 },
  { {VideoDecoderConfig_Profile_names + 188, 20}, 0 },
  { {VideoDecoderConfig_Profile_names + 208, 20}, 2 },
  { {VideoDecoderConfig_Profile_names + 228, 16}, 3 },
  { {VideoDecoderConfig_Profile_names + 244, 25}, 4 },
  { {VideoDecoderConfig_Profile_names + 269, 26}, 5 },
  { {VideoDecoderConfig_Profile_names + 295, 36}, 6 },
  { {VideoDecoderConfig_Profile_names + 331, 16}, 1 },
  { {VideoDecoderConfig_Profile_names + 347, 25}, 10 },
  { {VideoDecoderConfig_Profile_names + 372, 28}, 7 },
  { {VideoDecoderConfig_Profile_names + 400, 24}, 8 },
  { {VideoDecoderConfig_Profile_names + 424, 22}, 9 },
  { {VideoDecoderConfig_Profile_names + 446, 19}, 33 },
  { {VideoDecoderConfig_Profile_names + 465, 27}, 30 },
  { {VideoDecoderConfig_Profile_names + 492, 43}, 36 },
  { {VideoDecoderConfig_Profile_names + 535, 16}, 16 },
  { {VideoDecoderConfig_Profile_names + 551, 18}, 17 },
  { {VideoDecoderConfig_Profile_names + 569, 30}, 18 },
  { {VideoDecoderConfig_Profile_names + 599, 26}, 31 },
  { {VideoDecoderConfig_Profile_names + 625, 16}, 29 },
  { {VideoDecoderConfig_Profile_names + 641, 25}, 32 },
  { {VideoDecoderConfig_Profile_names + 666, 25}, 35 },
  { {VideoDecoderConfig_Profile_names + 691, 27}, 34 },
  { {VideoDecoderConfig_Profile_names + 718, 17}, 23 },
  { {VideoDecoderConfig_Profile_names + 735, 27}, -1 },
  { {VideoDecoderConfig_Profile_names + 762, 14}, 11 },
  { {VideoDecoderConfig_Profile_names + 776, 19}, 12 },
  { {VideoDecoderConfig_Profile_names + 795, 19}, 13 },
  { {VideoDecoderConfig_Profile_names + 814, 19}, 14 },
  { {VideoDecoderConfig_Profile_names + 833, 19}, 15 },
};

static const int VideoDecoderConfig_Profile_entries_by_number[] = {
  32, // -1 -> VIDEO_CODEC_PROFILE_UNKNOWN
  9, // 0 -> H264PROFILE_BASELINE
  15, // 1 -> H264PROFILE_MAIN
  10, // 2 -> H264PROFILE_EXTENDED
  11, // 3 -> H264PROFILE_HIGH
  12, // 4 -> H264PROFILE_HIGH10PROFILE
  13, // 5 -> H264PROFILE_HIGH422PROFILE
  14, // 6 -> H264PROFILE_HIGH444PREDICTIVEPROFILE
  17, // 7 -> H264PROFILE_SCALABLEBASELINE
  18, // 8 -> H264PROFILE_SCALABLEHIGH
  19, // 9 -> H264PROFILE_STEREOHIGH
  16, // 10 -> H264PROFILE_MULTIVIEWHIGH
  33, // 11 -> VP8PROFILE_ANY
  34, // 12 -> VP9PROFILE_PROFILE0
  35, // 13 -> VP9PROFILE_PROFILE1
  36, // 14 -> VP9PROFILE_PROFILE2
  37, // 15 -> VP9PROFILE_PROFILE3
  23, // 16 -> HEVCPROFILE_MAIN
  24, // 17 -> HEVCPROFILE_MAIN10
  25, // 18 -> HEVCPROFILE_MAIN_STILL_PICTURE
  3, // 19 -> DOLBYVISION_PROFILE0
  4, // 20 -> DOLBYVISION_PROFILE4
  5, // 21 -> DOLBYVISION_PROFILE5
  6, // 22 -> DOLBYVISION_PROFILE7
  31, // 23 -> THEORAPROFILE_ANY
  1, // 24 -> AV1PROFILE_PROFILE_MAIN
  0, // 25 -> AV1PROFILE_PROFILE_HIGH
  2, // 26 -> AV1PROFILE_PROFILE_PRO
  7, // 27 -> DOLBYVISION_PROFILE8
  8, // 28 -> DOLBYVISION_PROFILE9
  27, // 29 -> HEVCPROFILE_REXT
  21, // 30 -> HEVCPROFILE_HIGH_THROUGHPUT
  26, // 31 -> HEVCPROFILE_MULTIVIEW_MAIN
  28, // 32 -> HEVCPROFILE_SCALABLE_MAIN
  20, // 33 -> HEVCPROFILE_3D_MAIN
  30, // 34 -> HEVCPROFILE_SCREEN_EXTENDED
  29, // 35 -> HEVCPROFILE_SCALABLE_REXT
  22, // 36 -> HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED
};

const std::string& VideoDecoderConfig_Profile_Name(
    VideoDecoderConfig_Profile value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VideoDecoderConfig_Profile_entries,
          VideoDecoderConfig_Profile_entries_by_number,
          38, VideoDecoderConfig_Profile_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VideoDecoderConfig_Profile_entries,
      VideoDecoderConfig_Profile_entries_by_number,
      38, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VideoDecoderConfig_Profile_strings[idx].get();
}
bool VideoDecoderConfig_Profile_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_Profile* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VideoDecoderConfig_Profile_entries, 38, name, &int_value);
  if (success) {
    *value = static_cast<VideoDecoderConfig_Profile>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::VIDEO_CODEC_PROFILE_UNKNOWN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_BASELINE;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_MAIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_EXTENDED;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_HIGH;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_HIGH10PROFILE;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_HIGH422PROFILE;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_HIGH444PREDICTIVEPROFILE;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_SCALABLEBASELINE;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_SCALABLEHIGH;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_STEREOHIGH;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::H264PROFILE_MULTIVIEWHIGH;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::VP8PROFILE_ANY;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::VP9PROFILE_PROFILE0;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::VP9PROFILE_PROFILE1;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::VP9PROFILE_PROFILE2;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::VP9PROFILE_PROFILE3;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_MAIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_MAIN10;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_MAIN_STILL_PICTURE;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::DOLBYVISION_PROFILE0;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::DOLBYVISION_PROFILE4;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::DOLBYVISION_PROFILE5;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::DOLBYVISION_PROFILE7;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::THEORAPROFILE_ANY;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::AV1PROFILE_PROFILE_MAIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::AV1PROFILE_PROFILE_HIGH;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::AV1PROFILE_PROFILE_PRO;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::DOLBYVISION_PROFILE8;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::DOLBYVISION_PROFILE9;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_REXT;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_HIGH_THROUGHPUT;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_MULTIVIEW_MAIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_SCALABLE_MAIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_3D_MAIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_SCREEN_EXTENDED;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_SCALABLE_REXT;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::Profile_MIN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig::Profile_MAX;
constexpr int VideoDecoderConfig::Profile_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VideoDecoderConfig_Format_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VideoDecoderConfig_Format_strings[29] = {};

static const char VideoDecoderConfig_Format_names[] =
  "PIXEL_FORMAT_ABGR"
  "PIXEL_FORMAT_ARGB"
  "PIXEL_FORMAT_I420"
  "PIXEL_FORMAT_I420A"
  "PIXEL_FORMAT_I422"
  "PIXEL_FORMAT_I444"
  "PIXEL_FORMAT_MJPEG"
  "PIXEL_FORMAT_NV12"
  "PIXEL_FORMAT_NV21"
  "PIXEL_FORMAT_P016LE"
  "PIXEL_FORMAT_RGB24"
  "PIXEL_FORMAT_RGB32"
  "PIXEL_FORMAT_UNKNOWN"
  "PIXEL_FORMAT_XB30"
  "PIXEL_FORMAT_XBGR"
  "PIXEL_FORMAT_XR30"
  "PIXEL_FORMAT_XRGB"
  "PIXEL_FORMAT_Y16"
  "PIXEL_FORMAT_YUV420P10"
  "PIXEL_FORMAT_YUV420P12"
  "PIXEL_FORMAT_YUV420P9"
  "PIXEL_FORMAT_YUV422P10"
  "PIXEL_FORMAT_YUV422P12"
  "PIXEL_FORMAT_YUV422P9"
  "PIXEL_FORMAT_YUV444P10"
  "PIXEL_FORMAT_YUV444P12"
  "PIXEL_FORMAT_YUV444P9"
  "PIXEL_FORMAT_YUY2"
  "PIXEL_FORMAT_YV12";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VideoDecoderConfig_Format_entries[] = {
  { {VideoDecoderConfig_Format_names + 0, 17}, 27 },
  { {VideoDecoderConfig_Format_names + 17, 17}, 10 },
  { {VideoDecoderConfig_Format_names + 34, 17}, 1 },
  { {VideoDecoderConfig_Format_names + 51, 18}, 4 },
  { {VideoDecoderConfig_Format_names + 69, 17}, 3 },
  { {VideoDecoderConfig_Format_names + 86, 17}, 5 },
  { {VideoDecoderConfig_Format_names + 103, 18}, 14 },
  { {VideoDecoderConfig_Format_names + 121, 17}, 6 },
  { {VideoDecoderConfig_Format_names + 138, 17}, 7 },
  { {VideoDecoderConfig_Format_names + 155, 19}, 29 },
  { {VideoDecoderConfig_Format_names + 174, 18}, 12 },
  { {VideoDecoderConfig_Format_names + 192, 18}, 13 },
  { {VideoDecoderConfig_Format_names + 210, 20}, 0 },
  { {VideoDecoderConfig_Format_names + 230, 17}, 31 },
  { {VideoDecoderConfig_Format_names + 247, 17}, 28 },
  { {VideoDecoderConfig_Format_names + 264, 17}, 30 },
  { {VideoDecoderConfig_Format_names + 281, 17}, 11 },
  { {VideoDecoderConfig_Format_names + 298, 16}, 26 },
  { {VideoDecoderConfig_Format_names + 314, 22}, 17 },
  { {VideoDecoderConfig_Format_names + 336, 22}, 22 },
  { {VideoDecoderConfig_Format_names + 358, 21}, 16 },
  { {VideoDecoderConfig_Format_names + 379, 22}, 19 },
  { {VideoDecoderConfig_Format_names + 401, 22}, 23 },
  { {VideoDecoderConfig_Format_names + 423, 21}, 18 },
  { {VideoDecoderConfig_Format_names + 444, 22}, 21 },
  { {VideoDecoderConfig_Format_names + 466, 22}, 24 },
  { {VideoDecoderConfig_Format_names + 488, 21}, 20 },
  { {VideoDecoderConfig_Format_names + 509, 17}, 9 },
  { {VideoDecoderConfig_Format_names + 526, 17}, 2 },
};

static const int VideoDecoderConfig_Format_entries_by_number[] = {
  12, // 0 -> PIXEL_FORMAT_UNKNOWN
  2, // 1 -> PIXEL_FORMAT_I420
  28, // 2 -> PIXEL_FORMAT_YV12
  4, // 3 -> PIXEL_FORMAT_I422
  3, // 4 -> PIXEL_FORMAT_I420A
  5, // 5 -> PIXEL_FORMAT_I444
  7, // 6 -> PIXEL_FORMAT_NV12
  8, // 7 -> PIXEL_FORMAT_NV21
  27, // 9 -> PIXEL_FORMAT_YUY2
  1, // 10 -> PIXEL_FORMAT_ARGB
  16, // 11 -> PIXEL_FORMAT_XRGB
  10, // 12 -> PIXEL_FORMAT_RGB24
  11, // 13 -> PIXEL_FORMAT_RGB32
  6, // 14 -> PIXEL_FORMAT_MJPEG
  20, // 16 -> PIXEL_FORMAT_YUV420P9
  18, // 17 -> PIXEL_FORMAT_YUV420P10
  23, // 18 -> PIXEL_FORMAT_YUV422P9
  21, // 19 -> PIXEL_FORMAT_YUV422P10
  26, // 20 -> PIXEL_FORMAT_YUV444P9
  24, // 21 -> PIXEL_FORMAT_YUV444P10
  19, // 22 -> PIXEL_FORMAT_YUV420P12
  22, // 23 -> PIXEL_FORMAT_YUV422P12
  25, // 24 -> PIXEL_FORMAT_YUV444P12
  17, // 26 -> PIXEL_FORMAT_Y16
  0, // 27 -> PIXEL_FORMAT_ABGR
  14, // 28 -> PIXEL_FORMAT_XBGR
  9, // 29 -> PIXEL_FORMAT_P016LE
  15, // 30 -> PIXEL_FORMAT_XR30
  13, // 31 -> PIXEL_FORMAT_XB30
};

const std::string& VideoDecoderConfig_Format_Name(
    VideoDecoderConfig_Format value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VideoDecoderConfig_Format_entries,
          VideoDecoderConfig_Format_entries_by_number,
          29, VideoDecoderConfig_Format_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VideoDecoderConfig_Format_entries,
      VideoDecoderConfig_Format_entries_by_number,
      29, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VideoDecoderConfig_Format_strings[idx].get();
}
bool VideoDecoderConfig_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_Format* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VideoDecoderConfig_Format_entries, 29, name, &int_value);
  if (success) {
    *value = static_cast<VideoDecoderConfig_Format>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_UNKNOWN;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_I420;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YV12;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_I422;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_I420A;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_I444;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_NV12;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_NV21;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUY2;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_ARGB;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_XRGB;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_RGB24;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_RGB32;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_MJPEG;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV420P9;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV420P10;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV422P9;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV422P10;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV444P9;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV444P10;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV420P12;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV422P12;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_YUV444P12;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_Y16;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_ABGR;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_XBGR;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_P016LE;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_XR30;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::PIXEL_FORMAT_XB30;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::Format_MIN;
constexpr VideoDecoderConfig_Format VideoDecoderConfig::Format_MAX;
constexpr int VideoDecoderConfig::Format_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool VideoDecoderConfig_ColorSpace_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> VideoDecoderConfig_ColorSpace_strings[4] = {};

static const char VideoDecoderConfig_ColorSpace_names[] =
  "COLOR_SPACE_HD_REC709"
  "COLOR_SPACE_JPEG"
  "COLOR_SPACE_SD_REC601"
  "COLOR_SPACE_UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry VideoDecoderConfig_ColorSpace_entries[] = {
  { {VideoDecoderConfig_ColorSpace_names + 0, 21}, 2 },
  { {VideoDecoderConfig_ColorSpace_names + 21, 16}, 1 },
  { {VideoDecoderConfig_ColorSpace_names + 37, 21}, 3 },
  { {VideoDecoderConfig_ColorSpace_names + 58, 23}, 0 },
};

static const int VideoDecoderConfig_ColorSpace_entries_by_number[] = {
  3, // 0 -> COLOR_SPACE_UNSPECIFIED
  1, // 1 -> COLOR_SPACE_JPEG
  0, // 2 -> COLOR_SPACE_HD_REC709
  2, // 3 -> COLOR_SPACE_SD_REC601
};

const std::string& VideoDecoderConfig_ColorSpace_Name(
    VideoDecoderConfig_ColorSpace value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          VideoDecoderConfig_ColorSpace_entries,
          VideoDecoderConfig_ColorSpace_entries_by_number,
          4, VideoDecoderConfig_ColorSpace_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      VideoDecoderConfig_ColorSpace_entries,
      VideoDecoderConfig_ColorSpace_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     VideoDecoderConfig_ColorSpace_strings[idx].get();
}
bool VideoDecoderConfig_ColorSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_ColorSpace* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      VideoDecoderConfig_ColorSpace_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<VideoDecoderConfig_ColorSpace>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig::COLOR_SPACE_UNSPECIFIED;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig::COLOR_SPACE_JPEG;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig::COLOR_SPACE_HD_REC709;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig::COLOR_SPACE_SD_REC601;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig::ColorSpace_MIN;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig::ColorSpace_MAX;
constexpr int VideoDecoderConfig::ColorSpace_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RendererClientOnBufferingStateChange_State_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RendererClientOnBufferingStateChange_State_strings[2] = {};

static const char RendererClientOnBufferingStateChange_State_names[] =
  "BUFFERING_HAVE_ENOUGH"
  "BUFFERING_HAVE_NOTHING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RendererClientOnBufferingStateChange_State_entries[] = {
  { {RendererClientOnBufferingStateChange_State_names + 0, 21}, 1 },
  { {RendererClientOnBufferingStateChange_State_names + 21, 22}, 0 },
};

static const int RendererClientOnBufferingStateChange_State_entries_by_number[] = {
  1, // 0 -> BUFFERING_HAVE_NOTHING
  0, // 1 -> BUFFERING_HAVE_ENOUGH
};

const std::string& RendererClientOnBufferingStateChange_State_Name(
    RendererClientOnBufferingStateChange_State value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RendererClientOnBufferingStateChange_State_entries,
          RendererClientOnBufferingStateChange_State_entries_by_number,
          2, RendererClientOnBufferingStateChange_State_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RendererClientOnBufferingStateChange_State_entries,
      RendererClientOnBufferingStateChange_State_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RendererClientOnBufferingStateChange_State_strings[idx].get();
}
bool RendererClientOnBufferingStateChange_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RendererClientOnBufferingStateChange_State* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RendererClientOnBufferingStateChange_State_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<RendererClientOnBufferingStateChange_State>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::BUFFERING_HAVE_NOTHING;
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::BUFFERING_HAVE_ENOUGH;
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::State_MIN;
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::State_MAX;
constexpr int RendererClientOnBufferingStateChange::State_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool DemuxerStreamReadUntilCallback_Status_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> DemuxerStreamReadUntilCallback_Status_strings[4] = {};

static const char DemuxerStreamReadUntilCallback_Status_names[] =
  "kAborted"
  "kConfigChanged"
  "kError"
  "kOk";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry DemuxerStreamReadUntilCallback_Status_entries[] = {
  { {DemuxerStreamReadUntilCallback_Status_names + 0, 8}, 1 },
  { {DemuxerStreamReadUntilCallback_Status_names + 8, 14}, 2 },
  { {DemuxerStreamReadUntilCallback_Status_names + 22, 6}, 3 },
  { {DemuxerStreamReadUntilCallback_Status_names + 28, 3}, 0 },
};

static const int DemuxerStreamReadUntilCallback_Status_entries_by_number[] = {
  3, // 0 -> kOk
  0, // 1 -> kAborted
  1, // 2 -> kConfigChanged
  2, // 3 -> kError
};

const std::string& DemuxerStreamReadUntilCallback_Status_Name(
    DemuxerStreamReadUntilCallback_Status value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          DemuxerStreamReadUntilCallback_Status_entries,
          DemuxerStreamReadUntilCallback_Status_entries_by_number,
          4, DemuxerStreamReadUntilCallback_Status_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      DemuxerStreamReadUntilCallback_Status_entries,
      DemuxerStreamReadUntilCallback_Status_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     DemuxerStreamReadUntilCallback_Status_strings[idx].get();
}
bool DemuxerStreamReadUntilCallback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DemuxerStreamReadUntilCallback_Status* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      DemuxerStreamReadUntilCallback_Status_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<DemuxerStreamReadUntilCallback_Status>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::kOk;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::kAborted;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::kConfigChanged;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::kError;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::Status_MIN;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::Status_MAX;
constexpr int DemuxerStreamReadUntilCallback::Status_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool RpcMessage_RpcProc_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 5:
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1100:
    case 1101:
    case 1102:
    case 2000:
    case 2001:
    case 2002:
    case 2003:
    case 2004:
    case 2005:
    case 2006:
    case 2009:
    case 2010:
    case 3000:
    case 3001:
    case 3002:
    case 3003:
    case 3100:
    case 3101:
    case 3102:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> RpcMessage_RpcProc_strings[28] = {};

static const char RpcMessage_RpcProc_names[] =
  "RPC_ACQUIRE_DEMUXER"
  "RPC_ACQUIRE_RENDERER"
  "RPC_ACQUIRE_RENDERER_DONE"
  "RPC_DS_ENABLEBITSTREAMCONVERTER"
  "RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK"
  "RPC_DS_INITIALIZE"
  "RPC_DS_INITIALIZE_CALLBACK"
  "RPC_DS_ONERROR"
  "RPC_DS_READUNTIL"
  "RPC_DS_READUNTIL_CALLBACK"
  "RPC_INTERNAL"
  "RPC_RC_ONAUDIOCONFIGCHANGE"
  "RPC_RC_ONBUFFERINGSTATECHANGE"
  "RPC_RC_ONENDED"
  "RPC_RC_ONERROR"
  "RPC_RC_ONSTATISTICSUPDATE"
  "RPC_RC_ONTIMEUPDATE"
  "RPC_RC_ONVIDEOCONFIGCHANGE"
  "RPC_RC_ONVIDEONATURALSIZECHANGE"
  "RPC_RC_ONVIDEOOPACITYCHANGE"
  "RPC_R_FLUSHUNTIL"
  "RPC_R_FLUSHUNTIL_CALLBACK"
  "RPC_R_INITIALIZE"
  "RPC_R_INITIALIZE_CALLBACK"
  "RPC_R_SETCDM_CALLBACK"
  "RPC_R_SETPLAYBACKRATE"
  "RPC_R_SETVOLUME"
  "RPC_R_STARTPLAYINGFROM";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry RpcMessage_RpcProc_entries[] = {
  { {RpcMessage_RpcProc_names + 0, 19}, 5 },
  { {RpcMessage_RpcProc_names + 19, 20}, 1 },
  { {RpcMessage_RpcProc_names + 39, 25}, 2 },
  { {RpcMessage_RpcProc_names + 64, 31}, 3002 },
  { {RpcMessage_RpcProc_names + 95, 40}, 3102 },
  { {RpcMessage_RpcProc_names + 135, 17}, 3000 },
  { {RpcMessage_RpcProc_names + 152, 26}, 3100 },
  { {RpcMessage_RpcProc_names + 178, 14}, 3003 },
  { {RpcMessage_RpcProc_names + 192, 16}, 3001 },
  { {RpcMessage_RpcProc_names + 208, 25}, 3101 },
  { {RpcMessage_RpcProc_names + 233, 12}, 0 },
  { {RpcMessage_RpcProc_names + 245, 26}, 2009 },
  { {RpcMessage_RpcProc_names + 271, 29}, 2001 },
  { {RpcMessage_RpcProc_names + 300, 14}, 2002 },
  { {RpcMessage_RpcProc_names + 314, 14}, 2003 },
  { {RpcMessage_RpcProc_names + 328, 25}, 2006 },
  { {RpcMessage_RpcProc_names + 353, 19}, 2000 },
  { {RpcMessage_RpcProc_names + 372, 26}, 2010 },
  { {RpcMessage_RpcProc_names + 398, 31}, 2004 },
  { {RpcMessage_RpcProc_names + 429, 27}, 2005 },
  { {RpcMessage_RpcProc_names + 456, 16}, 1001 },
  { {RpcMessage_RpcProc_names + 472, 25}, 1101 },
  { {RpcMessage_RpcProc_names + 497, 16}, 1000 },
  { {RpcMessage_RpcProc_names + 513, 25}, 1100 },
  { {RpcMessage_RpcProc_names + 538, 21}, 1102 },
  { {RpcMessage_RpcProc_names + 559, 21}, 1003 },
  { {RpcMessage_RpcProc_names + 580, 15}, 1004 },
  { {RpcMessage_RpcProc_names + 595, 22}, 1002 },
};

static const int RpcMessage_RpcProc_entries_by_number[] = {
  10, // 0 -> RPC_INTERNAL
  1, // 1 -> RPC_ACQUIRE_RENDERER
  2, // 2 -> RPC_ACQUIRE_RENDERER_DONE
  0, // 5 -> RPC_ACQUIRE_DEMUXER
  22, // 1000 -> RPC_R_INITIALIZE
  20, // 1001 -> RPC_R_FLUSHUNTIL
  27, // 1002 -> RPC_R_STARTPLAYINGFROM
  25, // 1003 -> RPC_R_SETPLAYBACKRATE
  26, // 1004 -> RPC_R_SETVOLUME
  23, // 1100 -> RPC_R_INITIALIZE_CALLBACK
  21, // 1101 -> RPC_R_FLUSHUNTIL_CALLBACK
  24, // 1102 -> RPC_R_SETCDM_CALLBACK
  16, // 2000 -> RPC_RC_ONTIMEUPDATE
  12, // 2001 -> RPC_RC_ONBUFFERINGSTATECHANGE
  13, // 2002 -> RPC_RC_ONENDED
  14, // 2003 -> RPC_RC_ONERROR
  18, // 2004 -> RPC_RC_ONVIDEONATURALSIZECHANGE
  19, // 2005 -> RPC_RC_ONVIDEOOPACITYCHANGE
  15, // 2006 -> RPC_RC_ONSTATISTICSUPDATE
  11, // 2009 -> RPC_RC_ONAUDIOCONFIGCHANGE
  17, // 2010 -> RPC_RC_ONVIDEOCONFIGCHANGE
  5, // 3000 -> RPC_DS_INITIALIZE
  8, // 3001 -> RPC_DS_READUNTIL
  3, // 3002 -> RPC_DS_ENABLEBITSTREAMCONVERTER
  7, // 3003 -> RPC_DS_ONERROR
  6, // 3100 -> RPC_DS_INITIALIZE_CALLBACK
  9, // 3101 -> RPC_DS_READUNTIL_CALLBACK
  4, // 3102 -> RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK
};

const std::string& RpcMessage_RpcProc_Name(
    RpcMessage_RpcProc value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          RpcMessage_RpcProc_entries,
          RpcMessage_RpcProc_entries_by_number,
          28, RpcMessage_RpcProc_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      RpcMessage_RpcProc_entries,
      RpcMessage_RpcProc_entries_by_number,
      28, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     RpcMessage_RpcProc_strings[idx].get();
}
bool RpcMessage_RpcProc_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RpcMessage_RpcProc* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      RpcMessage_RpcProc_entries, 28, name, &int_value);
  if (success) {
    *value = static_cast<RpcMessage_RpcProc>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr RpcMessage_RpcProc RpcMessage::RPC_INTERNAL;
constexpr RpcMessage_RpcProc RpcMessage::RPC_ACQUIRE_RENDERER;
constexpr RpcMessage_RpcProc RpcMessage::RPC_ACQUIRE_DEMUXER;
constexpr RpcMessage_RpcProc RpcMessage::RPC_ACQUIRE_RENDERER_DONE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_INITIALIZE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_FLUSHUNTIL;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_STARTPLAYINGFROM;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_SETPLAYBACKRATE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_SETVOLUME;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_INITIALIZE_CALLBACK;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_FLUSHUNTIL_CALLBACK;
constexpr RpcMessage_RpcProc RpcMessage::RPC_R_SETCDM_CALLBACK;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONTIMEUPDATE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONBUFFERINGSTATECHANGE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONENDED;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONERROR;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONVIDEONATURALSIZECHANGE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONVIDEOOPACITYCHANGE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONSTATISTICSUPDATE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONAUDIOCONFIGCHANGE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_RC_ONVIDEOCONFIGCHANGE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_INITIALIZE;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_READUNTIL;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_ENABLEBITSTREAMCONVERTER;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_ONERROR;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_INITIALIZE_CALLBACK;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_READUNTIL_CALLBACK;
constexpr RpcMessage_RpcProc RpcMessage::RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK;
constexpr RpcMessage_RpcProc RpcMessage::RpcProc_MIN;
constexpr RpcMessage_RpcProc RpcMessage::RpcProc_MAX;
constexpr int RpcMessage::RpcProc_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class DecoderBuffer::_Internal {
 public:
  using HasBits = decltype(std::declval<DecoderBuffer>()._has_bits_);
  static void set_has_timestamp_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_duration_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_key_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_front_discard_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_back_discard_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_side_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_eos(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

DecoderBuffer::DecoderBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.DecoderBuffer)
}
DecoderBuffer::DecoderBuffer(const DecoderBuffer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  side_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    side_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_side_data()) {
    side_data_.Set(from._internal_side_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_usec_, &from.timestamp_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_eos_) -
    reinterpret_cast<char*>(&timestamp_usec_)) + sizeof(is_eos_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.DecoderBuffer)
}

inline void DecoderBuffer::SharedCtor() {
side_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  side_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_usec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_eos_) -
    reinterpret_cast<char*>(&timestamp_usec_)) + sizeof(is_eos_));
}

DecoderBuffer::~DecoderBuffer() {
  // @@protoc_insertion_point(destructor:openscreen.cast.DecoderBuffer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DecoderBuffer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  side_data_.Destroy();
}

void DecoderBuffer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DecoderBuffer::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.DecoderBuffer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    side_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&timestamp_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_eos_) -
        reinterpret_cast<char*>(&timestamp_usec_)) + sizeof(is_eos_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DecoderBuffer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 timestamp_usec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_timestamp_usec(&has_bits);
          timestamp_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 duration_usec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_duration_usec(&has_bits);
          duration_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_key_frame = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_key_frame(&has_bits);
          is_key_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 front_discard_usec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_front_discard_usec(&has_bits);
          front_discard_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 back_discard_usec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_back_discard_usec(&has_bits);
          back_discard_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes side_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_side_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_eos = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_eos(&has_bits);
          is_eos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DecoderBuffer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.DecoderBuffer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 timestamp_usec = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_timestamp_usec(), target);
  }

  // optional int64 duration_usec = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_duration_usec(), target);
  }

  // optional bool is_key_frame = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_key_frame(), target);
  }

  // optional int64 front_discard_usec = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_front_discard_usec(), target);
  }

  // optional int64 back_discard_usec = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_back_discard_usec(), target);
  }

  // optional bytes side_data = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_side_data(), target);
  }

  // optional bool is_eos = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_eos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.DecoderBuffer)
  return target;
}

size_t DecoderBuffer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.DecoderBuffer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes side_data = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_side_data());
    }

    // optional int64 timestamp_usec = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_timestamp_usec());
    }

    // optional int64 duration_usec = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_duration_usec());
    }

    // optional int64 front_discard_usec = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_front_discard_usec());
    }

    // optional int64 back_discard_usec = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_back_discard_usec());
    }

    // optional bool is_key_frame = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_eos = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DecoderBuffer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DecoderBuffer*>(
      &from));
}

void DecoderBuffer::MergeFrom(const DecoderBuffer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.DecoderBuffer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_side_data(from._internal_side_data());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_usec_ = from.timestamp_usec_;
    }
    if (cached_has_bits & 0x00000004u) {
      duration_usec_ = from.duration_usec_;
    }
    if (cached_has_bits & 0x00000008u) {
      front_discard_usec_ = from.front_discard_usec_;
    }
    if (cached_has_bits & 0x00000010u) {
      back_discard_usec_ = from.back_discard_usec_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_key_frame_ = from.is_key_frame_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_eos_ = from.is_eos_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DecoderBuffer::CopyFrom(const DecoderBuffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.DecoderBuffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DecoderBuffer::IsInitialized() const {
  return true;
}

void DecoderBuffer::InternalSwap(DecoderBuffer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &side_data_, lhs_arena,
      &other->side_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DecoderBuffer, is_eos_)
      + sizeof(DecoderBuffer::is_eos_)
      - PROTOBUF_FIELD_OFFSET(DecoderBuffer, timestamp_usec_)>(
          reinterpret_cast<char*>(&timestamp_usec_),
          reinterpret_cast<char*>(&other->timestamp_usec_));
}

std::string DecoderBuffer::GetTypeName() const {
  return "openscreen.cast.DecoderBuffer";
}


// ===================================================================

class Size::_Internal {
 public:
  using HasBits = decltype(std::declval<Size>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Size::Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.Size)
}
Size::Size(const Size& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.Size)
}

inline void Size::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

Size::~Size() {
  // @@protoc_insertion_point(destructor:openscreen.cast.Size)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Size::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Size::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Size::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.Size)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Size::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Size::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.Size)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.Size)
  return target;
}

size_t Size::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.Size)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 width = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Size::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Size*>(
      &from));
}

void Size::MergeFrom(const Size& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.Size)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Size::CopyFrom(const Size& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.Size)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Size::IsInitialized() const {
  return true;
}

void Size::InternalSwap(Size* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Size, height_)
      + sizeof(Size::height_)
      - PROTOBUF_FIELD_OFFSET(Size, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

std::string Size::GetTypeName() const {
  return "openscreen.cast.Size";
}


// ===================================================================

class AudioDecoderConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioDecoderConfig>()._has_bits_);
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sample_format(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_channel_layout(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_samples_per_second(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_seek_preroll_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_codec_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_extra_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

AudioDecoderConfig::AudioDecoderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.AudioDecoderConfig)
}
AudioDecoderConfig::AudioDecoderConfig(const AudioDecoderConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  extra_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extra_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra_data()) {
    extra_data_.Set(from._internal_extra_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&codec_, &from.codec_,
    static_cast<size_t>(reinterpret_cast<char*>(&codec_delay_) -
    reinterpret_cast<char*>(&codec_)) + sizeof(codec_delay_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.AudioDecoderConfig)
}

inline void AudioDecoderConfig::SharedCtor() {
extra_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extra_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&codec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&codec_delay_) -
    reinterpret_cast<char*>(&codec_)) + sizeof(codec_delay_));
}

AudioDecoderConfig::~AudioDecoderConfig() {
  // @@protoc_insertion_point(destructor:openscreen.cast.AudioDecoderConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioDecoderConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  extra_data_.Destroy();
}

void AudioDecoderConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AudioDecoderConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.AudioDecoderConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    extra_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&codec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&codec_delay_) -
        reinterpret_cast<char*>(&codec_)) + sizeof(codec_delay_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioDecoderConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .openscreen.cast.AudioDecoderConfig.Codec codec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::AudioDecoderConfig_Codec_IsValid(val))) {
            _internal_set_codec(static_cast<::openscreen::cast::AudioDecoderConfig_Codec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.AudioDecoderConfig.SampleFormat sample_format = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::AudioDecoderConfig_SampleFormat_IsValid(val))) {
            _internal_set_sample_format(static_cast<::openscreen::cast::AudioDecoderConfig_SampleFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.AudioDecoderConfig.ChannelLayout channel_layout = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::AudioDecoderConfig_ChannelLayout_IsValid(val))) {
            _internal_set_channel_layout(static_cast<::openscreen::cast::AudioDecoderConfig_ChannelLayout>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 samples_per_second = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_samples_per_second(&has_bits);
          samples_per_second_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 seek_preroll_usec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_seek_preroll_usec(&has_bits);
          seek_preroll_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 codec_delay = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_codec_delay(&has_bits);
          codec_delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes extra_data = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_extra_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioDecoderConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.AudioDecoderConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .openscreen.cast.AudioDecoderConfig.Codec codec = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_codec(), target);
  }

  // optional .openscreen.cast.AudioDecoderConfig.SampleFormat sample_format = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_sample_format(), target);
  }

  // optional .openscreen.cast.AudioDecoderConfig.ChannelLayout channel_layout = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_channel_layout(), target);
  }

  // optional int32 samples_per_second = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_samples_per_second(), target);
  }

  // optional int64 seek_preroll_usec = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_seek_preroll_usec(), target);
  }

  // optional int32 codec_delay = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_codec_delay(), target);
  }

  // optional bytes extra_data = 8;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_extra_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.AudioDecoderConfig)
  return target;
}

size_t AudioDecoderConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.AudioDecoderConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes extra_data = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_extra_data());
    }

    // optional .openscreen.cast.AudioDecoderConfig.Codec codec = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_codec());
    }

    // optional .openscreen.cast.AudioDecoderConfig.SampleFormat sample_format = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_sample_format());
    }

    // optional .openscreen.cast.AudioDecoderConfig.ChannelLayout channel_layout = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_layout());
    }

    // optional int32 samples_per_second = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_samples_per_second());
    }

    // optional int64 seek_preroll_usec = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_seek_preroll_usec());
    }

    // optional int32 codec_delay = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_codec_delay());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioDecoderConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioDecoderConfig*>(
      &from));
}

void AudioDecoderConfig::MergeFrom(const AudioDecoderConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.AudioDecoderConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_extra_data(from._internal_extra_data());
    }
    if (cached_has_bits & 0x00000002u) {
      codec_ = from.codec_;
    }
    if (cached_has_bits & 0x00000004u) {
      sample_format_ = from.sample_format_;
    }
    if (cached_has_bits & 0x00000008u) {
      channel_layout_ = from.channel_layout_;
    }
    if (cached_has_bits & 0x00000010u) {
      samples_per_second_ = from.samples_per_second_;
    }
    if (cached_has_bits & 0x00000020u) {
      seek_preroll_usec_ = from.seek_preroll_usec_;
    }
    if (cached_has_bits & 0x00000040u) {
      codec_delay_ = from.codec_delay_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioDecoderConfig::CopyFrom(const AudioDecoderConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.AudioDecoderConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioDecoderConfig::IsInitialized() const {
  return true;
}

void AudioDecoderConfig::InternalSwap(AudioDecoderConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &extra_data_, lhs_arena,
      &other->extra_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioDecoderConfig, codec_delay_)
      + sizeof(AudioDecoderConfig::codec_delay_)
      - PROTOBUF_FIELD_OFFSET(AudioDecoderConfig, codec_)>(
          reinterpret_cast<char*>(&codec_),
          reinterpret_cast<char*>(&other->codec_));
}

std::string AudioDecoderConfig::GetTypeName() const {
  return "openscreen.cast.AudioDecoderConfig";
}


// ===================================================================

class Rect::_Internal {
 public:
  using HasBits = decltype(std::declval<Rect>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

Rect::Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.Rect)
}
Rect::Rect(const Rect& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.Rect)
}

inline void Rect::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&x_)) + sizeof(height_));
}

Rect::~Rect() {
  // @@protoc_insertion_point(destructor:openscreen.cast.Rect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Rect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Rect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Rect::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.Rect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&x_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Rect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.Rect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_x(), target);
  }

  // optional int32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_y(), target);
  }

  // optional int32 width = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_width(), target);
  }

  // optional int32 height = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.Rect)
  return target;
}

size_t Rect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.Rect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_x());
    }

    // optional int32 y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_y());
    }

    // optional int32 width = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Rect::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Rect*>(
      &from));
}

void Rect::MergeFrom(const Rect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.Rect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000008u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Rect::CopyFrom(const Rect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.Rect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  return true;
}

void Rect::InternalSwap(Rect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Rect, height_)
      + sizeof(Rect::height_)
      - PROTOBUF_FIELD_OFFSET(Rect, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

std::string Rect::GetTypeName() const {
  return "openscreen.cast.Rect";
}


// ===================================================================

class VideoDecoderConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoDecoderConfig>()._has_bits_);
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_color_space(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::openscreen::cast::Size& coded_size(const VideoDecoderConfig* msg);
  static void set_has_coded_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::openscreen::cast::Rect& visible_rect(const VideoDecoderConfig* msg);
  static void set_has_visible_rect(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::openscreen::cast::Size& natural_size(const VideoDecoderConfig* msg);
  static void set_has_natural_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_extra_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::openscreen::cast::Size&
VideoDecoderConfig::_Internal::coded_size(const VideoDecoderConfig* msg) {
  return *msg->coded_size_;
}
const ::openscreen::cast::Rect&
VideoDecoderConfig::_Internal::visible_rect(const VideoDecoderConfig* msg) {
  return *msg->visible_rect_;
}
const ::openscreen::cast::Size&
VideoDecoderConfig::_Internal::natural_size(const VideoDecoderConfig* msg) {
  return *msg->natural_size_;
}
VideoDecoderConfig::VideoDecoderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.VideoDecoderConfig)
}
VideoDecoderConfig::VideoDecoderConfig(const VideoDecoderConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  extra_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extra_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extra_data()) {
    extra_data_.Set(from._internal_extra_data(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_coded_size()) {
    coded_size_ = new ::openscreen::cast::Size(*from.coded_size_);
  } else {
    coded_size_ = nullptr;
  }
  if (from._internal_has_visible_rect()) {
    visible_rect_ = new ::openscreen::cast::Rect(*from.visible_rect_);
  } else {
    visible_rect_ = nullptr;
  }
  if (from._internal_has_natural_size()) {
    natural_size_ = new ::openscreen::cast::Size(*from.natural_size_);
  } else {
    natural_size_ = nullptr;
  }
  ::memcpy(&codec_, &from.codec_,
    static_cast<size_t>(reinterpret_cast<char*>(&profile_) -
    reinterpret_cast<char*>(&codec_)) + sizeof(profile_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.VideoDecoderConfig)
}

inline void VideoDecoderConfig::SharedCtor() {
extra_data_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extra_data_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&coded_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&color_space_) -
    reinterpret_cast<char*>(&coded_size_)) + sizeof(color_space_));
profile_ = -1;
}

VideoDecoderConfig::~VideoDecoderConfig() {
  // @@protoc_insertion_point(destructor:openscreen.cast.VideoDecoderConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoDecoderConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  extra_data_.Destroy();
  if (this != internal_default_instance()) delete coded_size_;
  if (this != internal_default_instance()) delete visible_rect_;
  if (this != internal_default_instance()) delete natural_size_;
}

void VideoDecoderConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VideoDecoderConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.VideoDecoderConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      extra_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(coded_size_ != nullptr);
      coded_size_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(visible_rect_ != nullptr);
      visible_rect_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(natural_size_ != nullptr);
      natural_size_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&codec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&color_space_) -
        reinterpret_cast<char*>(&codec_)) + sizeof(color_space_));
    profile_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoDecoderConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .openscreen.cast.VideoDecoderConfig.Codec codec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::VideoDecoderConfig_Codec_IsValid(val))) {
            _internal_set_codec(static_cast<::openscreen::cast::VideoDecoderConfig_Codec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.VideoDecoderConfig.Profile profile = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::VideoDecoderConfig_Profile_IsValid(val))) {
            _internal_set_profile(static_cast<::openscreen::cast::VideoDecoderConfig_Profile>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.VideoDecoderConfig.Format format = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::VideoDecoderConfig_Format_IsValid(val))) {
            _internal_set_format(static_cast<::openscreen::cast::VideoDecoderConfig_Format>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.VideoDecoderConfig.ColorSpace color_space = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::VideoDecoderConfig_ColorSpace_IsValid(val))) {
            _internal_set_color_space(static_cast<::openscreen::cast::VideoDecoderConfig_ColorSpace>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.Size coded_size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_coded_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.Rect visible_rect = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_visible_rect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.Size natural_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_natural_size(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes extra_data = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_extra_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoDecoderConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.VideoDecoderConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .openscreen.cast.VideoDecoderConfig.Codec codec = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_codec(), target);
  }

  // optional .openscreen.cast.VideoDecoderConfig.Profile profile = 3;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_profile(), target);
  }

  // optional .openscreen.cast.VideoDecoderConfig.Format format = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_format(), target);
  }

  // optional .openscreen.cast.VideoDecoderConfig.ColorSpace color_space = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_color_space(), target);
  }

  // optional .openscreen.cast.Size coded_size = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::coded_size(this),
        _Internal::coded_size(this).GetCachedSize(), target, stream);
  }

  // optional .openscreen.cast.Rect visible_rect = 7;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::visible_rect(this),
        _Internal::visible_rect(this).GetCachedSize(), target, stream);
  }

  // optional .openscreen.cast.Size natural_size = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::natural_size(this),
        _Internal::natural_size(this).GetCachedSize(), target, stream);
  }

  // optional bytes extra_data = 9;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        9, this->_internal_extra_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.VideoDecoderConfig)
  return target;
}

size_t VideoDecoderConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.VideoDecoderConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes extra_data = 9;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_extra_data());
    }

    // optional .openscreen.cast.Size coded_size = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *coded_size_);
    }

    // optional .openscreen.cast.Rect visible_rect = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *visible_rect_);
    }

    // optional .openscreen.cast.Size natural_size = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *natural_size_);
    }

    // optional .openscreen.cast.VideoDecoderConfig.Codec codec = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_codec());
    }

    // optional .openscreen.cast.VideoDecoderConfig.Format format = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
    }

    // optional .openscreen.cast.VideoDecoderConfig.ColorSpace color_space = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_color_space());
    }

    // optional .openscreen.cast.VideoDecoderConfig.Profile profile = 3;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_profile());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoDecoderConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoDecoderConfig*>(
      &from));
}

void VideoDecoderConfig::MergeFrom(const VideoDecoderConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.VideoDecoderConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_extra_data(from._internal_extra_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_coded_size()->::openscreen::cast::Size::MergeFrom(from._internal_coded_size());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_visible_rect()->::openscreen::cast::Rect::MergeFrom(from._internal_visible_rect());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_natural_size()->::openscreen::cast::Size::MergeFrom(from._internal_natural_size());
    }
    if (cached_has_bits & 0x00000010u) {
      codec_ = from.codec_;
    }
    if (cached_has_bits & 0x00000020u) {
      format_ = from.format_;
    }
    if (cached_has_bits & 0x00000040u) {
      color_space_ = from.color_space_;
    }
    if (cached_has_bits & 0x00000080u) {
      profile_ = from.profile_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoDecoderConfig::CopyFrom(const VideoDecoderConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.VideoDecoderConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoDecoderConfig::IsInitialized() const {
  return true;
}

void VideoDecoderConfig::InternalSwap(VideoDecoderConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &extra_data_, lhs_arena,
      &other->extra_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoDecoderConfig, color_space_)
      + sizeof(VideoDecoderConfig::color_space_)
      - PROTOBUF_FIELD_OFFSET(VideoDecoderConfig, coded_size_)>(
          reinterpret_cast<char*>(&coded_size_),
          reinterpret_cast<char*>(&other->coded_size_));
  swap(profile_, other->profile_);
}

std::string VideoDecoderConfig::GetTypeName() const {
  return "openscreen.cast.VideoDecoderConfig";
}


// ===================================================================

class AudioDecoderInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<AudioDecoderInfo>()._has_bits_);
  static void set_has_decoder_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_platform_decoder(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AudioDecoderInfo::AudioDecoderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.AudioDecoderInfo)
}
AudioDecoderInfo::AudioDecoderInfo(const AudioDecoderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&decoder_type_, &from.decoder_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_platform_decoder_) -
    reinterpret_cast<char*>(&decoder_type_)) + sizeof(is_platform_decoder_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.AudioDecoderInfo)
}

inline void AudioDecoderInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&decoder_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_platform_decoder_) -
    reinterpret_cast<char*>(&decoder_type_)) + sizeof(is_platform_decoder_));
}

AudioDecoderInfo::~AudioDecoderInfo() {
  // @@protoc_insertion_point(destructor:openscreen.cast.AudioDecoderInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AudioDecoderInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AudioDecoderInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AudioDecoderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.AudioDecoderInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&decoder_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_platform_decoder_) -
        reinterpret_cast<char*>(&decoder_type_)) + sizeof(is_platform_decoder_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AudioDecoderInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 decoder_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_decoder_type(&has_bits);
          decoder_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_platform_decoder = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_platform_decoder(&has_bits);
          is_platform_decoder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AudioDecoderInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.AudioDecoderInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 decoder_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_decoder_type(), target);
  }

  // optional bool is_platform_decoder = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_platform_decoder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.AudioDecoderInfo)
  return target;
}

size_t AudioDecoderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.AudioDecoderInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 decoder_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_decoder_type());
    }

    // optional bool is_platform_decoder = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AudioDecoderInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AudioDecoderInfo*>(
      &from));
}

void AudioDecoderInfo::MergeFrom(const AudioDecoderInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.AudioDecoderInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      decoder_type_ = from.decoder_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_platform_decoder_ = from.is_platform_decoder_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AudioDecoderInfo::CopyFrom(const AudioDecoderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.AudioDecoderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AudioDecoderInfo::IsInitialized() const {
  return true;
}

void AudioDecoderInfo::InternalSwap(AudioDecoderInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AudioDecoderInfo, is_platform_decoder_)
      + sizeof(AudioDecoderInfo::is_platform_decoder_)
      - PROTOBUF_FIELD_OFFSET(AudioDecoderInfo, decoder_type_)>(
          reinterpret_cast<char*>(&decoder_type_),
          reinterpret_cast<char*>(&other->decoder_type_));
}

std::string AudioDecoderInfo::GetTypeName() const {
  return "openscreen.cast.AudioDecoderInfo";
}


// ===================================================================

class VideoDecoderInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<VideoDecoderInfo>()._has_bits_);
  static void set_has_decoder_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_platform_decoder(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

VideoDecoderInfo::VideoDecoderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.VideoDecoderInfo)
}
VideoDecoderInfo::VideoDecoderInfo(const VideoDecoderInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&decoder_type_, &from.decoder_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_platform_decoder_) -
    reinterpret_cast<char*>(&decoder_type_)) + sizeof(is_platform_decoder_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.VideoDecoderInfo)
}

inline void VideoDecoderInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&decoder_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_platform_decoder_) -
    reinterpret_cast<char*>(&decoder_type_)) + sizeof(is_platform_decoder_));
}

VideoDecoderInfo::~VideoDecoderInfo() {
  // @@protoc_insertion_point(destructor:openscreen.cast.VideoDecoderInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void VideoDecoderInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void VideoDecoderInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void VideoDecoderInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.VideoDecoderInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&decoder_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_platform_decoder_) -
        reinterpret_cast<char*>(&decoder_type_)) + sizeof(is_platform_decoder_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* VideoDecoderInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 decoder_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_decoder_type(&has_bits);
          decoder_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_platform_decoder = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_platform_decoder(&has_bits);
          is_platform_decoder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* VideoDecoderInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.VideoDecoderInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 decoder_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_decoder_type(), target);
  }

  // optional bool is_platform_decoder = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_platform_decoder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.VideoDecoderInfo)
  return target;
}

size_t VideoDecoderInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.VideoDecoderInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 decoder_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_decoder_type());
    }

    // optional bool is_platform_decoder = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void VideoDecoderInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const VideoDecoderInfo*>(
      &from));
}

void VideoDecoderInfo::MergeFrom(const VideoDecoderInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.VideoDecoderInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      decoder_type_ = from.decoder_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_platform_decoder_ = from.is_platform_decoder_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void VideoDecoderInfo::CopyFrom(const VideoDecoderInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.VideoDecoderInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VideoDecoderInfo::IsInitialized() const {
  return true;
}

void VideoDecoderInfo::InternalSwap(VideoDecoderInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(VideoDecoderInfo, is_platform_decoder_)
      + sizeof(VideoDecoderInfo::is_platform_decoder_)
      - PROTOBUF_FIELD_OFFSET(VideoDecoderInfo, decoder_type_)>(
          reinterpret_cast<char*>(&decoder_type_),
          reinterpret_cast<char*>(&other->decoder_type_));
}

std::string VideoDecoderInfo::GetTypeName() const {
  return "openscreen.cast.VideoDecoderInfo";
}


// ===================================================================

class PipelineStatistics::_Internal {
 public:
  using HasBits = decltype(std::declval<PipelineStatistics>()._has_bits_);
  static void set_has_audio_bytes_decoded(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_video_bytes_decoded(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_video_frames_decoded(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_video_frames_dropped(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_audio_memory_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_video_memory_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_video_frame_duration_average_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::openscreen::cast::AudioDecoderInfo& audio_decoder_info(const PipelineStatistics* msg);
  static void set_has_audio_decoder_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::openscreen::cast::VideoDecoderInfo& video_decoder_info(const PipelineStatistics* msg);
  static void set_has_video_decoder_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::openscreen::cast::AudioDecoderInfo&
PipelineStatistics::_Internal::audio_decoder_info(const PipelineStatistics* msg) {
  return *msg->audio_decoder_info_;
}
const ::openscreen::cast::VideoDecoderInfo&
PipelineStatistics::_Internal::video_decoder_info(const PipelineStatistics* msg) {
  return *msg->video_decoder_info_;
}
PipelineStatistics::PipelineStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.PipelineStatistics)
}
PipelineStatistics::PipelineStatistics(const PipelineStatistics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_audio_decoder_info()) {
    audio_decoder_info_ = new ::openscreen::cast::AudioDecoderInfo(*from.audio_decoder_info_);
  } else {
    audio_decoder_info_ = nullptr;
  }
  if (from._internal_has_video_decoder_info()) {
    video_decoder_info_ = new ::openscreen::cast::VideoDecoderInfo(*from.video_decoder_info_);
  } else {
    video_decoder_info_ = nullptr;
  }
  ::memcpy(&audio_bytes_decoded_, &from.audio_bytes_decoded_,
    static_cast<size_t>(reinterpret_cast<char*>(&video_frame_duration_average_usec_) -
    reinterpret_cast<char*>(&audio_bytes_decoded_)) + sizeof(video_frame_duration_average_usec_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.PipelineStatistics)
}

inline void PipelineStatistics::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&audio_decoder_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&video_frame_duration_average_usec_) -
    reinterpret_cast<char*>(&audio_decoder_info_)) + sizeof(video_frame_duration_average_usec_));
}

PipelineStatistics::~PipelineStatistics() {
  // @@protoc_insertion_point(destructor:openscreen.cast.PipelineStatistics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PipelineStatistics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete audio_decoder_info_;
  if (this != internal_default_instance()) delete video_decoder_info_;
}

void PipelineStatistics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void PipelineStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.PipelineStatistics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(audio_decoder_info_ != nullptr);
      audio_decoder_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(video_decoder_info_ != nullptr);
      video_decoder_info_->Clear();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&audio_bytes_decoded_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&video_memory_usage_) -
        reinterpret_cast<char*>(&audio_bytes_decoded_)) + sizeof(video_memory_usage_));
  }
  video_frame_duration_average_usec_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* PipelineStatistics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 audio_bytes_decoded = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_audio_bytes_decoded(&has_bits);
          audio_bytes_decoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 video_bytes_decoded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_video_bytes_decoded(&has_bits);
          video_bytes_decoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 video_frames_decoded = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_video_frames_decoded(&has_bits);
          video_frames_decoded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 video_frames_dropped = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_video_frames_dropped(&has_bits);
          video_frames_dropped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 audio_memory_usage = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_audio_memory_usage(&has_bits);
          audio_memory_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 video_memory_usage = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_video_memory_usage(&has_bits);
          video_memory_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 video_frame_duration_average_usec = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_video_frame_duration_average_usec(&has_bits);
          video_frame_duration_average_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.AudioDecoderInfo audio_decoder_info = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_decoder_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.VideoDecoderInfo video_decoder_info = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_decoder_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PipelineStatistics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.PipelineStatistics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 audio_bytes_decoded = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_audio_bytes_decoded(), target);
  }

  // optional uint64 video_bytes_decoded = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_video_bytes_decoded(), target);
  }

  // optional uint32 video_frames_decoded = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_video_frames_decoded(), target);
  }

  // optional uint32 video_frames_dropped = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_video_frames_dropped(), target);
  }

  // optional int64 audio_memory_usage = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(5, this->_internal_audio_memory_usage(), target);
  }

  // optional int64 video_memory_usage = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_video_memory_usage(), target);
  }

  // optional int64 video_frame_duration_average_usec = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_video_frame_duration_average_usec(), target);
  }

  // optional .openscreen.cast.AudioDecoderInfo audio_decoder_info = 8;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::audio_decoder_info(this),
        _Internal::audio_decoder_info(this).GetCachedSize(), target, stream);
  }

  // optional .openscreen.cast.VideoDecoderInfo video_decoder_info = 9;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::video_decoder_info(this),
        _Internal::video_decoder_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.PipelineStatistics)
  return target;
}

size_t PipelineStatistics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.PipelineStatistics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .openscreen.cast.AudioDecoderInfo audio_decoder_info = 8;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_decoder_info_);
    }

    // optional .openscreen.cast.VideoDecoderInfo video_decoder_info = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *video_decoder_info_);
    }

    // optional uint64 audio_bytes_decoded = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_audio_bytes_decoded());
    }

    // optional uint64 video_bytes_decoded = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_video_bytes_decoded());
    }

    // optional uint32 video_frames_decoded = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_video_frames_decoded());
    }

    // optional uint32 video_frames_dropped = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_video_frames_dropped());
    }

    // optional int64 audio_memory_usage = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_audio_memory_usage());
    }

    // optional int64 video_memory_usage = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_video_memory_usage());
    }

  }
  // optional int64 video_frame_duration_average_usec = 7;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_video_frame_duration_average_usec());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void PipelineStatistics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const PipelineStatistics*>(
      &from));
}

void PipelineStatistics::MergeFrom(const PipelineStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.PipelineStatistics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_audio_decoder_info()->::openscreen::cast::AudioDecoderInfo::MergeFrom(from._internal_audio_decoder_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_video_decoder_info()->::openscreen::cast::VideoDecoderInfo::MergeFrom(from._internal_video_decoder_info());
    }
    if (cached_has_bits & 0x00000004u) {
      audio_bytes_decoded_ = from.audio_bytes_decoded_;
    }
    if (cached_has_bits & 0x00000008u) {
      video_bytes_decoded_ = from.video_bytes_decoded_;
    }
    if (cached_has_bits & 0x00000010u) {
      video_frames_decoded_ = from.video_frames_decoded_;
    }
    if (cached_has_bits & 0x00000020u) {
      video_frames_dropped_ = from.video_frames_dropped_;
    }
    if (cached_has_bits & 0x00000040u) {
      audio_memory_usage_ = from.audio_memory_usage_;
    }
    if (cached_has_bits & 0x00000080u) {
      video_memory_usage_ = from.video_memory_usage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_video_frame_duration_average_usec(from._internal_video_frame_duration_average_usec());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void PipelineStatistics::CopyFrom(const PipelineStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.PipelineStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PipelineStatistics::IsInitialized() const {
  return true;
}

void PipelineStatistics::InternalSwap(PipelineStatistics* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(PipelineStatistics, video_frame_duration_average_usec_)
      + sizeof(PipelineStatistics::video_frame_duration_average_usec_)
      - PROTOBUF_FIELD_OFFSET(PipelineStatistics, audio_decoder_info_)>(
          reinterpret_cast<char*>(&audio_decoder_info_),
          reinterpret_cast<char*>(&other->audio_decoder_info_));
}

std::string PipelineStatistics::GetTypeName() const {
  return "openscreen.cast.PipelineStatistics";
}


// ===================================================================

class AcquireDemuxer::_Internal {
 public:
  using HasBits = decltype(std::declval<AcquireDemuxer>()._has_bits_);
  static void set_has_audio_demuxer_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_video_demuxer_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

AcquireDemuxer::AcquireDemuxer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.AcquireDemuxer)
}
AcquireDemuxer::AcquireDemuxer(const AcquireDemuxer& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&audio_demuxer_handle_, &from.audio_demuxer_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&video_demuxer_handle_) -
    reinterpret_cast<char*>(&audio_demuxer_handle_)) + sizeof(video_demuxer_handle_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.AcquireDemuxer)
}

inline void AcquireDemuxer::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&audio_demuxer_handle_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&video_demuxer_handle_) -
    reinterpret_cast<char*>(&audio_demuxer_handle_)) + sizeof(video_demuxer_handle_));
}

AcquireDemuxer::~AcquireDemuxer() {
  // @@protoc_insertion_point(destructor:openscreen.cast.AcquireDemuxer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void AcquireDemuxer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void AcquireDemuxer::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void AcquireDemuxer::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.AcquireDemuxer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&audio_demuxer_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&video_demuxer_handle_) -
        reinterpret_cast<char*>(&audio_demuxer_handle_)) + sizeof(video_demuxer_handle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* AcquireDemuxer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 audio_demuxer_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_audio_demuxer_handle(&has_bits);
          audio_demuxer_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 video_demuxer_handle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_video_demuxer_handle(&has_bits);
          video_demuxer_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* AcquireDemuxer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.AcquireDemuxer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 audio_demuxer_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_audio_demuxer_handle(), target);
  }

  // optional int32 video_demuxer_handle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_video_demuxer_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.AcquireDemuxer)
  return target;
}

size_t AcquireDemuxer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.AcquireDemuxer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 audio_demuxer_handle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audio_demuxer_handle());
    }

    // optional int32 video_demuxer_handle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_video_demuxer_handle());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AcquireDemuxer::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const AcquireDemuxer*>(
      &from));
}

void AcquireDemuxer::MergeFrom(const AcquireDemuxer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.AcquireDemuxer)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      audio_demuxer_handle_ = from.audio_demuxer_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      video_demuxer_handle_ = from.video_demuxer_handle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void AcquireDemuxer::CopyFrom(const AcquireDemuxer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.AcquireDemuxer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AcquireDemuxer::IsInitialized() const {
  return true;
}

void AcquireDemuxer::InternalSwap(AcquireDemuxer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(AcquireDemuxer, video_demuxer_handle_)
      + sizeof(AcquireDemuxer::video_demuxer_handle_)
      - PROTOBUF_FIELD_OFFSET(AcquireDemuxer, audio_demuxer_handle_)>(
          reinterpret_cast<char*>(&audio_demuxer_handle_),
          reinterpret_cast<char*>(&other->audio_demuxer_handle_));
}

std::string AcquireDemuxer::GetTypeName() const {
  return "openscreen.cast.AcquireDemuxer";
}


// ===================================================================

class RendererInitialize::_Internal {
 public:
  using HasBits = decltype(std::declval<RendererInitialize>()._has_bits_);
  static void set_has_client_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_audio_demuxer_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_video_demuxer_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_callback_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

RendererInitialize::RendererInitialize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RendererInitialize)
}
RendererInitialize::RendererInitialize(const RendererInitialize& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&client_handle_, &from.client_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&callback_handle_) -
    reinterpret_cast<char*>(&client_handle_)) + sizeof(callback_handle_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RendererInitialize)
}

inline void RendererInitialize::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_handle_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&callback_handle_) -
    reinterpret_cast<char*>(&client_handle_)) + sizeof(callback_handle_));
}

RendererInitialize::~RendererInitialize() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RendererInitialize)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RendererInitialize::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RendererInitialize::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RendererInitialize::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RendererInitialize)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&client_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&callback_handle_) -
        reinterpret_cast<char*>(&client_handle_)) + sizeof(callback_handle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RendererInitialize::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 client_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_handle(&has_bits);
          client_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 audio_demuxer_handle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_audio_demuxer_handle(&has_bits);
          audio_demuxer_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 video_demuxer_handle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_video_demuxer_handle(&has_bits);
          video_demuxer_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 callback_handle = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_callback_handle(&has_bits);
          callback_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RendererInitialize::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RendererInitialize)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 client_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_client_handle(), target);
  }

  // optional int32 audio_demuxer_handle = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_audio_demuxer_handle(), target);
  }

  // optional int32 video_demuxer_handle = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_video_demuxer_handle(), target);
  }

  // optional int32 callback_handle = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_callback_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RendererInitialize)
  return target;
}

size_t RendererInitialize::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RendererInitialize)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 client_handle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client_handle());
    }

    // optional int32 audio_demuxer_handle = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audio_demuxer_handle());
    }

    // optional int32 video_demuxer_handle = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_video_demuxer_handle());
    }

    // optional int32 callback_handle = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_callback_handle());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RendererInitialize::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RendererInitialize*>(
      &from));
}

void RendererInitialize::MergeFrom(const RendererInitialize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RendererInitialize)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      client_handle_ = from.client_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      audio_demuxer_handle_ = from.audio_demuxer_handle_;
    }
    if (cached_has_bits & 0x00000004u) {
      video_demuxer_handle_ = from.video_demuxer_handle_;
    }
    if (cached_has_bits & 0x00000008u) {
      callback_handle_ = from.callback_handle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RendererInitialize::CopyFrom(const RendererInitialize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RendererInitialize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererInitialize::IsInitialized() const {
  return true;
}

void RendererInitialize::InternalSwap(RendererInitialize* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RendererInitialize, callback_handle_)
      + sizeof(RendererInitialize::callback_handle_)
      - PROTOBUF_FIELD_OFFSET(RendererInitialize, client_handle_)>(
          reinterpret_cast<char*>(&client_handle_),
          reinterpret_cast<char*>(&other->client_handle_));
}

std::string RendererInitialize::GetTypeName() const {
  return "openscreen.cast.RendererInitialize";
}


// ===================================================================

class RendererFlushUntil::_Internal {
 public:
  using HasBits = decltype(std::declval<RendererFlushUntil>()._has_bits_);
  static void set_has_audio_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_video_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_callback_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

RendererFlushUntil::RendererFlushUntil(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RendererFlushUntil)
}
RendererFlushUntil::RendererFlushUntil(const RendererFlushUntil& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&audio_count_, &from.audio_count_,
    static_cast<size_t>(reinterpret_cast<char*>(&callback_handle_) -
    reinterpret_cast<char*>(&audio_count_)) + sizeof(callback_handle_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RendererFlushUntil)
}

inline void RendererFlushUntil::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&audio_count_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&callback_handle_) -
    reinterpret_cast<char*>(&audio_count_)) + sizeof(callback_handle_));
}

RendererFlushUntil::~RendererFlushUntil() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RendererFlushUntil)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RendererFlushUntil::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RendererFlushUntil::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RendererFlushUntil::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RendererFlushUntil)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&audio_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&callback_handle_) -
        reinterpret_cast<char*>(&audio_count_)) + sizeof(callback_handle_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RendererFlushUntil::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 audio_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_audio_count(&has_bits);
          audio_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 video_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_video_count(&has_bits);
          video_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 callback_handle = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_callback_handle(&has_bits);
          callback_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RendererFlushUntil::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RendererFlushUntil)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 audio_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_audio_count(), target);
  }

  // optional uint32 video_count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_video_count(), target);
  }

  // optional int32 callback_handle = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_callback_handle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RendererFlushUntil)
  return target;
}

size_t RendererFlushUntil::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RendererFlushUntil)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 audio_count = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_audio_count());
    }

    // optional uint32 video_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_video_count());
    }

    // optional int32 callback_handle = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_callback_handle());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RendererFlushUntil::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RendererFlushUntil*>(
      &from));
}

void RendererFlushUntil::MergeFrom(const RendererFlushUntil& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RendererFlushUntil)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      audio_count_ = from.audio_count_;
    }
    if (cached_has_bits & 0x00000002u) {
      video_count_ = from.video_count_;
    }
    if (cached_has_bits & 0x00000004u) {
      callback_handle_ = from.callback_handle_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RendererFlushUntil::CopyFrom(const RendererFlushUntil& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RendererFlushUntil)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererFlushUntil::IsInitialized() const {
  return true;
}

void RendererFlushUntil::InternalSwap(RendererFlushUntil* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RendererFlushUntil, callback_handle_)
      + sizeof(RendererFlushUntil::callback_handle_)
      - PROTOBUF_FIELD_OFFSET(RendererFlushUntil, audio_count_)>(
          reinterpret_cast<char*>(&audio_count_),
          reinterpret_cast<char*>(&other->audio_count_));
}

std::string RendererFlushUntil::GetTypeName() const {
  return "openscreen.cast.RendererFlushUntil";
}


// ===================================================================

class RendererClientOnTimeUpdate::_Internal {
 public:
  using HasBits = decltype(std::declval<RendererClientOnTimeUpdate>()._has_bits_);
  static void set_has_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

RendererClientOnTimeUpdate::RendererClientOnTimeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RendererClientOnTimeUpdate)
}
RendererClientOnTimeUpdate::RendererClientOnTimeUpdate(const RendererClientOnTimeUpdate& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&time_usec_, &from.time_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_time_usec_) -
    reinterpret_cast<char*>(&time_usec_)) + sizeof(max_time_usec_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RendererClientOnTimeUpdate)
}

inline void RendererClientOnTimeUpdate::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&time_usec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&max_time_usec_) -
    reinterpret_cast<char*>(&time_usec_)) + sizeof(max_time_usec_));
}

RendererClientOnTimeUpdate::~RendererClientOnTimeUpdate() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RendererClientOnTimeUpdate)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RendererClientOnTimeUpdate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RendererClientOnTimeUpdate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RendererClientOnTimeUpdate::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RendererClientOnTimeUpdate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&time_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&max_time_usec_) -
        reinterpret_cast<char*>(&time_usec_)) + sizeof(max_time_usec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RendererClientOnTimeUpdate::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 time_usec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time_usec(&has_bits);
          time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 max_time_usec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_time_usec(&has_bits);
          max_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RendererClientOnTimeUpdate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RendererClientOnTimeUpdate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 time_usec = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_time_usec(), target);
  }

  // optional int64 max_time_usec = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_max_time_usec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RendererClientOnTimeUpdate)
  return target;
}

size_t RendererClientOnTimeUpdate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RendererClientOnTimeUpdate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 time_usec = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_usec());
    }

    // optional int64 max_time_usec = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_max_time_usec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RendererClientOnTimeUpdate::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RendererClientOnTimeUpdate*>(
      &from));
}

void RendererClientOnTimeUpdate::MergeFrom(const RendererClientOnTimeUpdate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RendererClientOnTimeUpdate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      time_usec_ = from.time_usec_;
    }
    if (cached_has_bits & 0x00000002u) {
      max_time_usec_ = from.max_time_usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RendererClientOnTimeUpdate::CopyFrom(const RendererClientOnTimeUpdate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RendererClientOnTimeUpdate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererClientOnTimeUpdate::IsInitialized() const {
  return true;
}

void RendererClientOnTimeUpdate::InternalSwap(RendererClientOnTimeUpdate* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RendererClientOnTimeUpdate, max_time_usec_)
      + sizeof(RendererClientOnTimeUpdate::max_time_usec_)
      - PROTOBUF_FIELD_OFFSET(RendererClientOnTimeUpdate, time_usec_)>(
          reinterpret_cast<char*>(&time_usec_),
          reinterpret_cast<char*>(&other->time_usec_));
}

std::string RendererClientOnTimeUpdate::GetTypeName() const {
  return "openscreen.cast.RendererClientOnTimeUpdate";
}


// ===================================================================

class RendererClientOnBufferingStateChange::_Internal {
 public:
  using HasBits = decltype(std::declval<RendererClientOnBufferingStateChange>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

RendererClientOnBufferingStateChange::RendererClientOnBufferingStateChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RendererClientOnBufferingStateChange)
}
RendererClientOnBufferingStateChange::RendererClientOnBufferingStateChange(const RendererClientOnBufferingStateChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  state_ = from.state_;
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RendererClientOnBufferingStateChange)
}

inline void RendererClientOnBufferingStateChange::SharedCtor() {
state_ = 0;
}

RendererClientOnBufferingStateChange::~RendererClientOnBufferingStateChange() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RendererClientOnBufferingStateChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RendererClientOnBufferingStateChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RendererClientOnBufferingStateChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RendererClientOnBufferingStateChange::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RendererClientOnBufferingStateChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  state_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RendererClientOnBufferingStateChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .openscreen.cast.RendererClientOnBufferingStateChange.State state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::RendererClientOnBufferingStateChange_State_IsValid(val))) {
            _internal_set_state(static_cast<::openscreen::cast::RendererClientOnBufferingStateChange_State>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RendererClientOnBufferingStateChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RendererClientOnBufferingStateChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .openscreen.cast.RendererClientOnBufferingStateChange.State state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RendererClientOnBufferingStateChange)
  return target;
}

size_t RendererClientOnBufferingStateChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RendererClientOnBufferingStateChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .openscreen.cast.RendererClientOnBufferingStateChange.State state = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_state());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RendererClientOnBufferingStateChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RendererClientOnBufferingStateChange*>(
      &from));
}

void RendererClientOnBufferingStateChange::MergeFrom(const RendererClientOnBufferingStateChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RendererClientOnBufferingStateChange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_state()) {
    _internal_set_state(from._internal_state());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RendererClientOnBufferingStateChange::CopyFrom(const RendererClientOnBufferingStateChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RendererClientOnBufferingStateChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererClientOnBufferingStateChange::IsInitialized() const {
  return true;
}

void RendererClientOnBufferingStateChange::InternalSwap(RendererClientOnBufferingStateChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(state_, other->state_);
}

std::string RendererClientOnBufferingStateChange::GetTypeName() const {
  return "openscreen.cast.RendererClientOnBufferingStateChange";
}


// ===================================================================

class RendererClientOnAudioConfigChange::_Internal {
 public:
  using HasBits = decltype(std::declval<RendererClientOnAudioConfigChange>()._has_bits_);
  static const ::openscreen::cast::AudioDecoderConfig& audio_decoder_config(const RendererClientOnAudioConfigChange* msg);
  static void set_has_audio_decoder_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::openscreen::cast::AudioDecoderConfig&
RendererClientOnAudioConfigChange::_Internal::audio_decoder_config(const RendererClientOnAudioConfigChange* msg) {
  return *msg->audio_decoder_config_;
}
RendererClientOnAudioConfigChange::RendererClientOnAudioConfigChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RendererClientOnAudioConfigChange)
}
RendererClientOnAudioConfigChange::RendererClientOnAudioConfigChange(const RendererClientOnAudioConfigChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_audio_decoder_config()) {
    audio_decoder_config_ = new ::openscreen::cast::AudioDecoderConfig(*from.audio_decoder_config_);
  } else {
    audio_decoder_config_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RendererClientOnAudioConfigChange)
}

inline void RendererClientOnAudioConfigChange::SharedCtor() {
audio_decoder_config_ = nullptr;
}

RendererClientOnAudioConfigChange::~RendererClientOnAudioConfigChange() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RendererClientOnAudioConfigChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RendererClientOnAudioConfigChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete audio_decoder_config_;
}

void RendererClientOnAudioConfigChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RendererClientOnAudioConfigChange::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RendererClientOnAudioConfigChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(audio_decoder_config_ != nullptr);
    audio_decoder_config_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RendererClientOnAudioConfigChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_decoder_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RendererClientOnAudioConfigChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RendererClientOnAudioConfigChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio_decoder_config(this),
        _Internal::audio_decoder_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RendererClientOnAudioConfigChange)
  return target;
}

size_t RendererClientOnAudioConfigChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RendererClientOnAudioConfigChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *audio_decoder_config_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RendererClientOnAudioConfigChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RendererClientOnAudioConfigChange*>(
      &from));
}

void RendererClientOnAudioConfigChange::MergeFrom(const RendererClientOnAudioConfigChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RendererClientOnAudioConfigChange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_audio_decoder_config()) {
    _internal_mutable_audio_decoder_config()->::openscreen::cast::AudioDecoderConfig::MergeFrom(from._internal_audio_decoder_config());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RendererClientOnAudioConfigChange::CopyFrom(const RendererClientOnAudioConfigChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RendererClientOnAudioConfigChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererClientOnAudioConfigChange::IsInitialized() const {
  return true;
}

void RendererClientOnAudioConfigChange::InternalSwap(RendererClientOnAudioConfigChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(audio_decoder_config_, other->audio_decoder_config_);
}

std::string RendererClientOnAudioConfigChange::GetTypeName() const {
  return "openscreen.cast.RendererClientOnAudioConfigChange";
}


// ===================================================================

class RendererClientOnVideoConfigChange::_Internal {
 public:
  using HasBits = decltype(std::declval<RendererClientOnVideoConfigChange>()._has_bits_);
  static const ::openscreen::cast::VideoDecoderConfig& video_decoder_config(const RendererClientOnVideoConfigChange* msg);
  static void set_has_video_decoder_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::openscreen::cast::VideoDecoderConfig&
RendererClientOnVideoConfigChange::_Internal::video_decoder_config(const RendererClientOnVideoConfigChange* msg) {
  return *msg->video_decoder_config_;
}
RendererClientOnVideoConfigChange::RendererClientOnVideoConfigChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RendererClientOnVideoConfigChange)
}
RendererClientOnVideoConfigChange::RendererClientOnVideoConfigChange(const RendererClientOnVideoConfigChange& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_video_decoder_config()) {
    video_decoder_config_ = new ::openscreen::cast::VideoDecoderConfig(*from.video_decoder_config_);
  } else {
    video_decoder_config_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RendererClientOnVideoConfigChange)
}

inline void RendererClientOnVideoConfigChange::SharedCtor() {
video_decoder_config_ = nullptr;
}

RendererClientOnVideoConfigChange::~RendererClientOnVideoConfigChange() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RendererClientOnVideoConfigChange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RendererClientOnVideoConfigChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete video_decoder_config_;
}

void RendererClientOnVideoConfigChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RendererClientOnVideoConfigChange::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RendererClientOnVideoConfigChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(video_decoder_config_ != nullptr);
    video_decoder_config_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RendererClientOnVideoConfigChange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_decoder_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RendererClientOnVideoConfigChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RendererClientOnVideoConfigChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::video_decoder_config(this),
        _Internal::video_decoder_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RendererClientOnVideoConfigChange)
  return target;
}

size_t RendererClientOnVideoConfigChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RendererClientOnVideoConfigChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *video_decoder_config_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RendererClientOnVideoConfigChange::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RendererClientOnVideoConfigChange*>(
      &from));
}

void RendererClientOnVideoConfigChange::MergeFrom(const RendererClientOnVideoConfigChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RendererClientOnVideoConfigChange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_video_decoder_config()) {
    _internal_mutable_video_decoder_config()->::openscreen::cast::VideoDecoderConfig::MergeFrom(from._internal_video_decoder_config());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RendererClientOnVideoConfigChange::CopyFrom(const RendererClientOnVideoConfigChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RendererClientOnVideoConfigChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RendererClientOnVideoConfigChange::IsInitialized() const {
  return true;
}

void RendererClientOnVideoConfigChange::InternalSwap(RendererClientOnVideoConfigChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(video_decoder_config_, other->video_decoder_config_);
}

std::string RendererClientOnVideoConfigChange::GetTypeName() const {
  return "openscreen.cast.RendererClientOnVideoConfigChange";
}


// ===================================================================

class DemuxerStreamReadUntil::_Internal {
 public:
  using HasBits = decltype(std::declval<DemuxerStreamReadUntil>()._has_bits_);
  static void set_has_callback_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

DemuxerStreamReadUntil::DemuxerStreamReadUntil(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.DemuxerStreamReadUntil)
}
DemuxerStreamReadUntil::DemuxerStreamReadUntil(const DemuxerStreamReadUntil& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&callback_handle_, &from.callback_handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&callback_handle_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.DemuxerStreamReadUntil)
}

inline void DemuxerStreamReadUntil::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&callback_handle_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&callback_handle_)) + sizeof(count_));
}

DemuxerStreamReadUntil::~DemuxerStreamReadUntil() {
  // @@protoc_insertion_point(destructor:openscreen.cast.DemuxerStreamReadUntil)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DemuxerStreamReadUntil::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void DemuxerStreamReadUntil::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DemuxerStreamReadUntil::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.DemuxerStreamReadUntil)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&callback_handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&callback_handle_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DemuxerStreamReadUntil::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 callback_handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_callback_handle(&has_bits);
          callback_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DemuxerStreamReadUntil::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.DemuxerStreamReadUntil)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 callback_handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_callback_handle(), target);
  }

  // optional uint32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.DemuxerStreamReadUntil)
  return target;
}

size_t DemuxerStreamReadUntil::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.DemuxerStreamReadUntil)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 callback_handle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_callback_handle());
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DemuxerStreamReadUntil::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DemuxerStreamReadUntil*>(
      &from));
}

void DemuxerStreamReadUntil::MergeFrom(const DemuxerStreamReadUntil& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.DemuxerStreamReadUntil)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      callback_handle_ = from.callback_handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DemuxerStreamReadUntil::CopyFrom(const DemuxerStreamReadUntil& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.DemuxerStreamReadUntil)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DemuxerStreamReadUntil::IsInitialized() const {
  return true;
}

void DemuxerStreamReadUntil::InternalSwap(DemuxerStreamReadUntil* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DemuxerStreamReadUntil, count_)
      + sizeof(DemuxerStreamReadUntil::count_)
      - PROTOBUF_FIELD_OFFSET(DemuxerStreamReadUntil, callback_handle_)>(
          reinterpret_cast<char*>(&callback_handle_),
          reinterpret_cast<char*>(&other->callback_handle_));
}

std::string DemuxerStreamReadUntil::GetTypeName() const {
  return "openscreen.cast.DemuxerStreamReadUntil";
}


// ===================================================================

class DemuxerStreamInitializeCallback::_Internal {
 public:
  using HasBits = decltype(std::declval<DemuxerStreamInitializeCallback>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::openscreen::cast::AudioDecoderConfig& audio_decoder_config(const DemuxerStreamInitializeCallback* msg);
  static void set_has_audio_decoder_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::openscreen::cast::VideoDecoderConfig& video_decoder_config(const DemuxerStreamInitializeCallback* msg);
  static void set_has_video_decoder_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::openscreen::cast::AudioDecoderConfig&
DemuxerStreamInitializeCallback::_Internal::audio_decoder_config(const DemuxerStreamInitializeCallback* msg) {
  return *msg->audio_decoder_config_;
}
const ::openscreen::cast::VideoDecoderConfig&
DemuxerStreamInitializeCallback::_Internal::video_decoder_config(const DemuxerStreamInitializeCallback* msg) {
  return *msg->video_decoder_config_;
}
DemuxerStreamInitializeCallback::DemuxerStreamInitializeCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.DemuxerStreamInitializeCallback)
}
DemuxerStreamInitializeCallback::DemuxerStreamInitializeCallback(const DemuxerStreamInitializeCallback& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_audio_decoder_config()) {
    audio_decoder_config_ = new ::openscreen::cast::AudioDecoderConfig(*from.audio_decoder_config_);
  } else {
    audio_decoder_config_ = nullptr;
  }
  if (from._internal_has_video_decoder_config()) {
    video_decoder_config_ = new ::openscreen::cast::VideoDecoderConfig(*from.video_decoder_config_);
  } else {
    video_decoder_config_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.DemuxerStreamInitializeCallback)
}

inline void DemuxerStreamInitializeCallback::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&audio_decoder_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&audio_decoder_config_)) + sizeof(type_));
}

DemuxerStreamInitializeCallback::~DemuxerStreamInitializeCallback() {
  // @@protoc_insertion_point(destructor:openscreen.cast.DemuxerStreamInitializeCallback)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DemuxerStreamInitializeCallback::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete audio_decoder_config_;
  if (this != internal_default_instance()) delete video_decoder_config_;
}

void DemuxerStreamInitializeCallback::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DemuxerStreamInitializeCallback::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.DemuxerStreamInitializeCallback)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(audio_decoder_config_ != nullptr);
      audio_decoder_config_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(video_decoder_config_ != nullptr);
      video_decoder_config_->Clear();
    }
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DemuxerStreamInitializeCallback::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_decoder_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_decoder_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DemuxerStreamInitializeCallback::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.DemuxerStreamInitializeCallback)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::audio_decoder_config(this),
        _Internal::audio_decoder_config(this).GetCachedSize(), target, stream);
  }

  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::video_decoder_config(this),
        _Internal::video_decoder_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.DemuxerStreamInitializeCallback)
  return target;
}

size_t DemuxerStreamInitializeCallback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.DemuxerStreamInitializeCallback)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_decoder_config_);
    }

    // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *video_decoder_config_);
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DemuxerStreamInitializeCallback::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DemuxerStreamInitializeCallback*>(
      &from));
}

void DemuxerStreamInitializeCallback::MergeFrom(const DemuxerStreamInitializeCallback& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.DemuxerStreamInitializeCallback)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_audio_decoder_config()->::openscreen::cast::AudioDecoderConfig::MergeFrom(from._internal_audio_decoder_config());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_video_decoder_config()->::openscreen::cast::VideoDecoderConfig::MergeFrom(from._internal_video_decoder_config());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DemuxerStreamInitializeCallback::CopyFrom(const DemuxerStreamInitializeCallback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.DemuxerStreamInitializeCallback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DemuxerStreamInitializeCallback::IsInitialized() const {
  return true;
}

void DemuxerStreamInitializeCallback::InternalSwap(DemuxerStreamInitializeCallback* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DemuxerStreamInitializeCallback, type_)
      + sizeof(DemuxerStreamInitializeCallback::type_)
      - PROTOBUF_FIELD_OFFSET(DemuxerStreamInitializeCallback, audio_decoder_config_)>(
          reinterpret_cast<char*>(&audio_decoder_config_),
          reinterpret_cast<char*>(&other->audio_decoder_config_));
}

std::string DemuxerStreamInitializeCallback::GetTypeName() const {
  return "openscreen.cast.DemuxerStreamInitializeCallback";
}


// ===================================================================

class DemuxerStreamReadUntilCallback::_Internal {
 public:
  using HasBits = decltype(std::declval<DemuxerStreamReadUntilCallback>()._has_bits_);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::openscreen::cast::AudioDecoderConfig& audio_decoder_config(const DemuxerStreamReadUntilCallback* msg);
  static void set_has_audio_decoder_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::openscreen::cast::VideoDecoderConfig& video_decoder_config(const DemuxerStreamReadUntilCallback* msg);
  static void set_has_video_decoder_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::openscreen::cast::AudioDecoderConfig&
DemuxerStreamReadUntilCallback::_Internal::audio_decoder_config(const DemuxerStreamReadUntilCallback* msg) {
  return *msg->audio_decoder_config_;
}
const ::openscreen::cast::VideoDecoderConfig&
DemuxerStreamReadUntilCallback::_Internal::video_decoder_config(const DemuxerStreamReadUntilCallback* msg) {
  return *msg->video_decoder_config_;
}
DemuxerStreamReadUntilCallback::DemuxerStreamReadUntilCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.DemuxerStreamReadUntilCallback)
}
DemuxerStreamReadUntilCallback::DemuxerStreamReadUntilCallback(const DemuxerStreamReadUntilCallback& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_audio_decoder_config()) {
    audio_decoder_config_ = new ::openscreen::cast::AudioDecoderConfig(*from.audio_decoder_config_);
  } else {
    audio_decoder_config_ = nullptr;
  }
  if (from._internal_has_video_decoder_config()) {
    video_decoder_config_ = new ::openscreen::cast::VideoDecoderConfig(*from.video_decoder_config_);
  } else {
    video_decoder_config_ = nullptr;
  }
  ::memcpy(&status_, &from.status_,
    static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&status_)) + sizeof(count_));
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.DemuxerStreamReadUntilCallback)
}

inline void DemuxerStreamReadUntilCallback::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&audio_decoder_config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&count_) -
    reinterpret_cast<char*>(&audio_decoder_config_)) + sizeof(count_));
}

DemuxerStreamReadUntilCallback::~DemuxerStreamReadUntilCallback() {
  // @@protoc_insertion_point(destructor:openscreen.cast.DemuxerStreamReadUntilCallback)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DemuxerStreamReadUntilCallback::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete audio_decoder_config_;
  if (this != internal_default_instance()) delete video_decoder_config_;
}

void DemuxerStreamReadUntilCallback::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DemuxerStreamReadUntilCallback::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.DemuxerStreamReadUntilCallback)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(audio_decoder_config_ != nullptr);
      audio_decoder_config_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(video_decoder_config_ != nullptr);
      video_decoder_config_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&status_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&count_) -
        reinterpret_cast<char*>(&status_)) + sizeof(count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* DemuxerStreamReadUntilCallback::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .openscreen.cast.DemuxerStreamReadUntilCallback.Status status = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::DemuxerStreamReadUntilCallback_Status_IsValid(val))) {
            _internal_set_status(static_cast<::openscreen::cast::DemuxerStreamReadUntilCallback_Status>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio_decoder_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_video_decoder_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DemuxerStreamReadUntilCallback::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.DemuxerStreamReadUntilCallback)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .openscreen.cast.DemuxerStreamReadUntilCallback.Status status = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_status(), target);
  }

  // optional uint32 count = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::audio_decoder_config(this),
        _Internal::audio_decoder_config(this).GetCachedSize(), target, stream);
  }

  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::video_decoder_config(this),
        _Internal::video_decoder_config(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.DemuxerStreamReadUntilCallback)
  return target;
}

size_t DemuxerStreamReadUntilCallback::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.DemuxerStreamReadUntilCallback)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *audio_decoder_config_);
    }

    // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *video_decoder_config_);
    }

    // optional .openscreen.cast.DemuxerStreamReadUntilCallback.Status status = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_status());
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DemuxerStreamReadUntilCallback::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DemuxerStreamReadUntilCallback*>(
      &from));
}

void DemuxerStreamReadUntilCallback::MergeFrom(const DemuxerStreamReadUntilCallback& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.DemuxerStreamReadUntilCallback)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_audio_decoder_config()->::openscreen::cast::AudioDecoderConfig::MergeFrom(from._internal_audio_decoder_config());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_video_decoder_config()->::openscreen::cast::VideoDecoderConfig::MergeFrom(from._internal_video_decoder_config());
    }
    if (cached_has_bits & 0x00000004u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000008u) {
      count_ = from.count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DemuxerStreamReadUntilCallback::CopyFrom(const DemuxerStreamReadUntilCallback& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.DemuxerStreamReadUntilCallback)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DemuxerStreamReadUntilCallback::IsInitialized() const {
  return true;
}

void DemuxerStreamReadUntilCallback::InternalSwap(DemuxerStreamReadUntilCallback* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DemuxerStreamReadUntilCallback, count_)
      + sizeof(DemuxerStreamReadUntilCallback::count_)
      - PROTOBUF_FIELD_OFFSET(DemuxerStreamReadUntilCallback, audio_decoder_config_)>(
          reinterpret_cast<char*>(&audio_decoder_config_),
          reinterpret_cast<char*>(&other->audio_decoder_config_));
}

std::string DemuxerStreamReadUntilCallback::GetTypeName() const {
  return "openscreen.cast.DemuxerStreamReadUntilCallback";
}


// ===================================================================

class RpcMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<RpcMessage>()._has_bits_);
  static void set_has_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_proc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::openscreen::cast::RendererInitialize& renderer_initialize_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::RendererFlushUntil& renderer_flushuntil_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::AcquireDemuxer& acquire_demuxer_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::RendererClientOnTimeUpdate& rendererclient_ontimeupdate_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::Size& rendererclient_onvideonatualsizechange_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::PipelineStatistics& rendererclient_onstatisticsupdate_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::RendererClientOnBufferingStateChange& rendererclient_onbufferingstatechange_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::RendererClientOnAudioConfigChange& rendererclient_onaudioconfigchange_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::RendererClientOnVideoConfigChange& rendererclient_onvideoconfigchange_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::DemuxerStreamReadUntil& demuxerstream_readuntil_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::DemuxerStreamInitializeCallback& demuxerstream_initializecb_rpc(const RpcMessage* msg);
  static const ::openscreen::cast::DemuxerStreamReadUntilCallback& demuxerstream_readuntilcb_rpc(const RpcMessage* msg);
};

const ::openscreen::cast::RendererInitialize&
RpcMessage::_Internal::renderer_initialize_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.renderer_initialize_rpc_;
}
const ::openscreen::cast::RendererFlushUntil&
RpcMessage::_Internal::renderer_flushuntil_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.renderer_flushuntil_rpc_;
}
const ::openscreen::cast::AcquireDemuxer&
RpcMessage::_Internal::acquire_demuxer_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.acquire_demuxer_rpc_;
}
const ::openscreen::cast::RendererClientOnTimeUpdate&
RpcMessage::_Internal::rendererclient_ontimeupdate_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.rendererclient_ontimeupdate_rpc_;
}
const ::openscreen::cast::Size&
RpcMessage::_Internal::rendererclient_onvideonatualsizechange_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
}
const ::openscreen::cast::PipelineStatistics&
RpcMessage::_Internal::rendererclient_onstatisticsupdate_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
}
const ::openscreen::cast::RendererClientOnBufferingStateChange&
RpcMessage::_Internal::rendererclient_onbufferingstatechange_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
}
const ::openscreen::cast::RendererClientOnAudioConfigChange&
RpcMessage::_Internal::rendererclient_onaudioconfigchange_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
}
const ::openscreen::cast::RendererClientOnVideoConfigChange&
RpcMessage::_Internal::rendererclient_onvideoconfigchange_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
}
const ::openscreen::cast::DemuxerStreamReadUntil&
RpcMessage::_Internal::demuxerstream_readuntil_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.demuxerstream_readuntil_rpc_;
}
const ::openscreen::cast::DemuxerStreamInitializeCallback&
RpcMessage::_Internal::demuxerstream_initializecb_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.demuxerstream_initializecb_rpc_;
}
const ::openscreen::cast::DemuxerStreamReadUntilCallback&
RpcMessage::_Internal::demuxerstream_readuntilcb_rpc(const RpcMessage* msg) {
  return *msg->rpc_oneof_.demuxerstream_readuntilcb_rpc_;
}
void RpcMessage::set_allocated_renderer_initialize_rpc(::openscreen::cast::RendererInitialize* renderer_initialize_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (renderer_initialize_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(renderer_initialize_rpc);
    if (message_arena != submessage_arena) {
      renderer_initialize_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renderer_initialize_rpc, submessage_arena);
    }
    set_has_renderer_initialize_rpc();
    rpc_oneof_.renderer_initialize_rpc_ = renderer_initialize_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.renderer_initialize_rpc)
}
void RpcMessage::set_allocated_renderer_flushuntil_rpc(::openscreen::cast::RendererFlushUntil* renderer_flushuntil_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (renderer_flushuntil_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(renderer_flushuntil_rpc);
    if (message_arena != submessage_arena) {
      renderer_flushuntil_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, renderer_flushuntil_rpc, submessage_arena);
    }
    set_has_renderer_flushuntil_rpc();
    rpc_oneof_.renderer_flushuntil_rpc_ = renderer_flushuntil_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.renderer_flushuntil_rpc)
}
void RpcMessage::set_allocated_acquire_demuxer_rpc(::openscreen::cast::AcquireDemuxer* acquire_demuxer_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (acquire_demuxer_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(acquire_demuxer_rpc);
    if (message_arena != submessage_arena) {
      acquire_demuxer_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, acquire_demuxer_rpc, submessage_arena);
    }
    set_has_acquire_demuxer_rpc();
    rpc_oneof_.acquire_demuxer_rpc_ = acquire_demuxer_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.acquire_demuxer_rpc)
}
void RpcMessage::set_allocated_rendererclient_ontimeupdate_rpc(::openscreen::cast::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (rendererclient_ontimeupdate_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendererclient_ontimeupdate_rpc);
    if (message_arena != submessage_arena) {
      rendererclient_ontimeupdate_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendererclient_ontimeupdate_rpc, submessage_arena);
    }
    set_has_rendererclient_ontimeupdate_rpc();
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = rendererclient_ontimeupdate_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.rendererclient_ontimeupdate_rpc)
}
void RpcMessage::set_allocated_rendererclient_onvideonatualsizechange_rpc(::openscreen::cast::Size* rendererclient_onvideonatualsizechange_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (rendererclient_onvideonatualsizechange_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendererclient_onvideonatualsizechange_rpc);
    if (message_arena != submessage_arena) {
      rendererclient_onvideonatualsizechange_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendererclient_onvideonatualsizechange_rpc, submessage_arena);
    }
    set_has_rendererclient_onvideonatualsizechange_rpc();
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = rendererclient_onvideonatualsizechange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
}
void RpcMessage::set_allocated_rendererclient_onstatisticsupdate_rpc(::openscreen::cast::PipelineStatistics* rendererclient_onstatisticsupdate_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (rendererclient_onstatisticsupdate_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendererclient_onstatisticsupdate_rpc);
    if (message_arena != submessage_arena) {
      rendererclient_onstatisticsupdate_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendererclient_onstatisticsupdate_rpc, submessage_arena);
    }
    set_has_rendererclient_onstatisticsupdate_rpc();
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = rendererclient_onstatisticsupdate_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.rendererclient_onstatisticsupdate_rpc)
}
void RpcMessage::set_allocated_rendererclient_onbufferingstatechange_rpc(::openscreen::cast::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (rendererclient_onbufferingstatechange_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendererclient_onbufferingstatechange_rpc);
    if (message_arena != submessage_arena) {
      rendererclient_onbufferingstatechange_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendererclient_onbufferingstatechange_rpc, submessage_arena);
    }
    set_has_rendererclient_onbufferingstatechange_rpc();
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = rendererclient_onbufferingstatechange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.rendererclient_onbufferingstatechange_rpc)
}
void RpcMessage::set_allocated_rendererclient_onaudioconfigchange_rpc(::openscreen::cast::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (rendererclient_onaudioconfigchange_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendererclient_onaudioconfigchange_rpc);
    if (message_arena != submessage_arena) {
      rendererclient_onaudioconfigchange_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendererclient_onaudioconfigchange_rpc, submessage_arena);
    }
    set_has_rendererclient_onaudioconfigchange_rpc();
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = rendererclient_onaudioconfigchange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.rendererclient_onaudioconfigchange_rpc)
}
void RpcMessage::set_allocated_rendererclient_onvideoconfigchange_rpc(::openscreen::cast::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (rendererclient_onvideoconfigchange_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rendererclient_onvideoconfigchange_rpc);
    if (message_arena != submessage_arena) {
      rendererclient_onvideoconfigchange_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rendererclient_onvideoconfigchange_rpc, submessage_arena);
    }
    set_has_rendererclient_onvideoconfigchange_rpc();
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = rendererclient_onvideoconfigchange_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.rendererclient_onvideoconfigchange_rpc)
}
void RpcMessage::set_allocated_demuxerstream_readuntil_rpc(::openscreen::cast::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (demuxerstream_readuntil_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(demuxerstream_readuntil_rpc);
    if (message_arena != submessage_arena) {
      demuxerstream_readuntil_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, demuxerstream_readuntil_rpc, submessage_arena);
    }
    set_has_demuxerstream_readuntil_rpc();
    rpc_oneof_.demuxerstream_readuntil_rpc_ = demuxerstream_readuntil_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.demuxerstream_readuntil_rpc)
}
void RpcMessage::set_allocated_demuxerstream_initializecb_rpc(::openscreen::cast::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (demuxerstream_initializecb_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(demuxerstream_initializecb_rpc);
    if (message_arena != submessage_arena) {
      demuxerstream_initializecb_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, demuxerstream_initializecb_rpc, submessage_arena);
    }
    set_has_demuxerstream_initializecb_rpc();
    rpc_oneof_.demuxerstream_initializecb_rpc_ = demuxerstream_initializecb_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.demuxerstream_initializecb_rpc)
}
void RpcMessage::set_allocated_demuxerstream_readuntilcb_rpc(::openscreen::cast::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_rpc_oneof();
  if (demuxerstream_readuntilcb_rpc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(demuxerstream_readuntilcb_rpc);
    if (message_arena != submessage_arena) {
      demuxerstream_readuntilcb_rpc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, demuxerstream_readuntilcb_rpc, submessage_arena);
    }
    set_has_demuxerstream_readuntilcb_rpc();
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = demuxerstream_readuntilcb_rpc;
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.demuxerstream_readuntilcb_rpc)
}
RpcMessage::RpcMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:openscreen.cast.RpcMessage)
}
RpcMessage::RpcMessage(const RpcMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&handle_, &from.handle_,
    static_cast<size_t>(reinterpret_cast<char*>(&proc_) -
    reinterpret_cast<char*>(&handle_)) + sizeof(proc_));
  clear_has_rpc_oneof();
  switch (from.rpc_oneof_case()) {
    case kIntegerValue: {
      _internal_set_integer_value(from._internal_integer_value());
      break;
    }
    case kInteger64Value: {
      _internal_set_integer64_value(from._internal_integer64_value());
      break;
    }
    case kDoubleValue: {
      _internal_set_double_value(from._internal_double_value());
      break;
    }
    case kBooleanValue: {
      _internal_set_boolean_value(from._internal_boolean_value());
      break;
    }
    case kStringValue: {
      _internal_set_string_value(from._internal_string_value());
      break;
    }
    case kRendererInitializeRpc: {
      _internal_mutable_renderer_initialize_rpc()->::openscreen::cast::RendererInitialize::MergeFrom(from._internal_renderer_initialize_rpc());
      break;
    }
    case kRendererFlushuntilRpc: {
      _internal_mutable_renderer_flushuntil_rpc()->::openscreen::cast::RendererFlushUntil::MergeFrom(from._internal_renderer_flushuntil_rpc());
      break;
    }
    case kAcquireDemuxerRpc: {
      _internal_mutable_acquire_demuxer_rpc()->::openscreen::cast::AcquireDemuxer::MergeFrom(from._internal_acquire_demuxer_rpc());
      break;
    }
    case kRendererclientOntimeupdateRpc: {
      _internal_mutable_rendererclient_ontimeupdate_rpc()->::openscreen::cast::RendererClientOnTimeUpdate::MergeFrom(from._internal_rendererclient_ontimeupdate_rpc());
      break;
    }
    case kRendererclientOnvideonatualsizechangeRpc: {
      _internal_mutable_rendererclient_onvideonatualsizechange_rpc()->::openscreen::cast::Size::MergeFrom(from._internal_rendererclient_onvideonatualsizechange_rpc());
      break;
    }
    case kRendererclientOnstatisticsupdateRpc: {
      _internal_mutable_rendererclient_onstatisticsupdate_rpc()->::openscreen::cast::PipelineStatistics::MergeFrom(from._internal_rendererclient_onstatisticsupdate_rpc());
      break;
    }
    case kRendererclientOnbufferingstatechangeRpc: {
      _internal_mutable_rendererclient_onbufferingstatechange_rpc()->::openscreen::cast::RendererClientOnBufferingStateChange::MergeFrom(from._internal_rendererclient_onbufferingstatechange_rpc());
      break;
    }
    case kRendererclientOnaudioconfigchangeRpc: {
      _internal_mutable_rendererclient_onaudioconfigchange_rpc()->::openscreen::cast::RendererClientOnAudioConfigChange::MergeFrom(from._internal_rendererclient_onaudioconfigchange_rpc());
      break;
    }
    case kRendererclientOnvideoconfigchangeRpc: {
      _internal_mutable_rendererclient_onvideoconfigchange_rpc()->::openscreen::cast::RendererClientOnVideoConfigChange::MergeFrom(from._internal_rendererclient_onvideoconfigchange_rpc());
      break;
    }
    case kDemuxerstreamReaduntilRpc: {
      _internal_mutable_demuxerstream_readuntil_rpc()->::openscreen::cast::DemuxerStreamReadUntil::MergeFrom(from._internal_demuxerstream_readuntil_rpc());
      break;
    }
    case kDemuxerstreamInitializecbRpc: {
      _internal_mutable_demuxerstream_initializecb_rpc()->::openscreen::cast::DemuxerStreamInitializeCallback::MergeFrom(from._internal_demuxerstream_initializecb_rpc());
      break;
    }
    case kDemuxerstreamReaduntilcbRpc: {
      _internal_mutable_demuxerstream_readuntilcb_rpc()->::openscreen::cast::DemuxerStreamReadUntilCallback::MergeFrom(from._internal_demuxerstream_readuntilcb_rpc());
      break;
    }
    case RPC_ONEOF_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:openscreen.cast.RpcMessage)
}

inline void RpcMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&handle_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&proc_) -
    reinterpret_cast<char*>(&handle_)) + sizeof(proc_));
clear_has_rpc_oneof();
}

RpcMessage::~RpcMessage() {
  // @@protoc_insertion_point(destructor:openscreen.cast.RpcMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RpcMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_rpc_oneof()) {
    clear_rpc_oneof();
  }
}

void RpcMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void RpcMessage::clear_rpc_oneof() {
// @@protoc_insertion_point(one_of_clear_start:openscreen.cast.RpcMessage)
  switch (rpc_oneof_case()) {
    case kIntegerValue: {
      // No need to clear
      break;
    }
    case kInteger64Value: {
      // No need to clear
      break;
    }
    case kDoubleValue: {
      // No need to clear
      break;
    }
    case kBooleanValue: {
      // No need to clear
      break;
    }
    case kStringValue: {
      rpc_oneof_.string_value_.Destroy();
      break;
    }
    case kRendererInitializeRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.renderer_initialize_rpc_;
      }
      break;
    }
    case kRendererFlushuntilRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.renderer_flushuntil_rpc_;
      }
      break;
    }
    case kAcquireDemuxerRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.acquire_demuxer_rpc_;
      }
      break;
    }
    case kRendererclientOntimeupdateRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.rendererclient_ontimeupdate_rpc_;
      }
      break;
    }
    case kRendererclientOnvideonatualsizechangeRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
      }
      break;
    }
    case kRendererclientOnstatisticsupdateRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
      }
      break;
    }
    case kRendererclientOnbufferingstatechangeRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
      }
      break;
    }
    case kRendererclientOnaudioconfigchangeRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
      }
      break;
    }
    case kRendererclientOnvideoconfigchangeRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
      }
      break;
    }
    case kDemuxerstreamReaduntilRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.demuxerstream_readuntil_rpc_;
      }
      break;
    }
    case kDemuxerstreamInitializecbRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.demuxerstream_initializecb_rpc_;
      }
      break;
    }
    case kDemuxerstreamReaduntilcbRpc: {
      if (GetArenaForAllocation() == nullptr) {
        delete rpc_oneof_.demuxerstream_readuntilcb_rpc_;
      }
      break;
    }
    case RPC_ONEOF_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = RPC_ONEOF_NOT_SET;
}


void RpcMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:openscreen.cast.RpcMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&handle_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&proc_) -
        reinterpret_cast<char*>(&handle_)) + sizeof(proc_));
  }
  clear_rpc_oneof();
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* RpcMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 handle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_handle(&has_bits);
          handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .openscreen.cast.RpcMessage.RpcProc proc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::openscreen::cast::RpcMessage_RpcProc_IsValid(val))) {
            _internal_set_proc(static_cast<::openscreen::cast::RpcMessage_RpcProc>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // int32 integer_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _internal_set_integer_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int64 integer64_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _internal_set_integer64_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double double_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _internal_set_double_value(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr));
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // bool boolean_value = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _internal_set_boolean_value(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string string_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_string_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.RendererInitialize renderer_initialize_rpc = 100;
      case 100:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_renderer_initialize_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.RendererFlushUntil renderer_flushuntil_rpc = 101;
      case 101:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_renderer_flushuntil_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.AcquireDemuxer acquire_demuxer_rpc = 103;
      case 103:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_acquire_demuxer_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
      case 200:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendererclient_ontimeupdate_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.Size rendererclient_onvideonatualsizechange_rpc = 201;
      case 201:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendererclient_onvideonatualsizechange_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
      case 202:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendererclient_onstatisticsupdate_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
      case 203:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendererclient_onbufferingstatechange_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
      case 204:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendererclient_onaudioconfigchange_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
      case 205:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_rendererclient_onvideoconfigchange_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
      case 300:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_demuxerstream_readuntil_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
      case 400:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_demuxerstream_initializecb_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .openscreen.cast.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
      case 401:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_demuxerstream_readuntilcb_rpc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RpcMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:openscreen.cast.RpcMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 handle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_handle(), target);
  }

  // optional .openscreen.cast.RpcMessage.RpcProc proc = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_proc(), target);
  }

  switch (rpc_oneof_case()) {
    case kIntegerValue: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_integer_value(), target);
      break;
    }
    case kInteger64Value: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_integer64_value(), target);
      break;
    }
    case kDoubleValue: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_double_value(), target);
      break;
    }
    case kBooleanValue: {
      target = stream->EnsureSpace(target);
      target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_boolean_value(), target);
      break;
    }
    case kStringValue: {
      target = stream->WriteStringMaybeAliased(
          7, this->_internal_string_value(), target);
      break;
    }
    case kRendererInitializeRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(100, _Internal::renderer_initialize_rpc(this),
          _Internal::renderer_initialize_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererFlushuntilRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(101, _Internal::renderer_flushuntil_rpc(this),
          _Internal::renderer_flushuntil_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kAcquireDemuxerRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(103, _Internal::acquire_demuxer_rpc(this),
          _Internal::acquire_demuxer_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererclientOntimeupdateRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(200, _Internal::rendererclient_ontimeupdate_rpc(this),
          _Internal::rendererclient_ontimeupdate_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererclientOnvideonatualsizechangeRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(201, _Internal::rendererclient_onvideonatualsizechange_rpc(this),
          _Internal::rendererclient_onvideonatualsizechange_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererclientOnstatisticsupdateRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(202, _Internal::rendererclient_onstatisticsupdate_rpc(this),
          _Internal::rendererclient_onstatisticsupdate_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererclientOnbufferingstatechangeRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(203, _Internal::rendererclient_onbufferingstatechange_rpc(this),
          _Internal::rendererclient_onbufferingstatechange_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererclientOnaudioconfigchangeRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(204, _Internal::rendererclient_onaudioconfigchange_rpc(this),
          _Internal::rendererclient_onaudioconfigchange_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kRendererclientOnvideoconfigchangeRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(205, _Internal::rendererclient_onvideoconfigchange_rpc(this),
          _Internal::rendererclient_onvideoconfigchange_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kDemuxerstreamReaduntilRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(300, _Internal::demuxerstream_readuntil_rpc(this),
          _Internal::demuxerstream_readuntil_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kDemuxerstreamInitializecbRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(400, _Internal::demuxerstream_initializecb_rpc(this),
          _Internal::demuxerstream_initializecb_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    case kDemuxerstreamReaduntilcbRpc: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(401, _Internal::demuxerstream_readuntilcb_rpc(this),
          _Internal::demuxerstream_readuntilcb_rpc(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:openscreen.cast.RpcMessage)
  return target;
}

size_t RpcMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:openscreen.cast.RpcMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 handle = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_handle());
    }

    // optional .openscreen.cast.RpcMessage.RpcProc proc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_proc());
    }

  }
  switch (rpc_oneof_case()) {
    // int32 integer_value = 3;
    case kIntegerValue: {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_integer_value());
      break;
    }
    // int64 integer64_value = 4;
    case kInteger64Value: {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_integer64_value());
      break;
    }
    // double double_value = 5;
    case kDoubleValue: {
      total_size += 1 + 8;
      break;
    }
    // bool boolean_value = 6;
    case kBooleanValue: {
      total_size += 1 + 1;
      break;
    }
    // string string_value = 7;
    case kStringValue: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_string_value());
      break;
    }
    // .openscreen.cast.RendererInitialize renderer_initialize_rpc = 100;
    case kRendererInitializeRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.renderer_initialize_rpc_);
      break;
    }
    // .openscreen.cast.RendererFlushUntil renderer_flushuntil_rpc = 101;
    case kRendererFlushuntilRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.renderer_flushuntil_rpc_);
      break;
    }
    // .openscreen.cast.AcquireDemuxer acquire_demuxer_rpc = 103;
    case kAcquireDemuxerRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.acquire_demuxer_rpc_);
      break;
    }
    // .openscreen.cast.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
    case kRendererclientOntimeupdateRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.rendererclient_ontimeupdate_rpc_);
      break;
    }
    // .openscreen.cast.Size rendererclient_onvideonatualsizechange_rpc = 201;
    case kRendererclientOnvideonatualsizechangeRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_);
      break;
    }
    // .openscreen.cast.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
    case kRendererclientOnstatisticsupdateRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.rendererclient_onstatisticsupdate_rpc_);
      break;
    }
    // .openscreen.cast.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
    case kRendererclientOnbufferingstatechangeRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.rendererclient_onbufferingstatechange_rpc_);
      break;
    }
    // .openscreen.cast.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
    case kRendererclientOnaudioconfigchangeRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.rendererclient_onaudioconfigchange_rpc_);
      break;
    }
    // .openscreen.cast.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
    case kRendererclientOnvideoconfigchangeRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.rendererclient_onvideoconfigchange_rpc_);
      break;
    }
    // .openscreen.cast.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
    case kDemuxerstreamReaduntilRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.demuxerstream_readuntil_rpc_);
      break;
    }
    // .openscreen.cast.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
    case kDemuxerstreamInitializecbRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.demuxerstream_initializecb_rpc_);
      break;
    }
    // .openscreen.cast.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
    case kDemuxerstreamReaduntilcbRpc: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *rpc_oneof_.demuxerstream_readuntilcb_rpc_);
      break;
    }
    case RPC_ONEOF_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void RpcMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const RpcMessage*>(
      &from));
}

void RpcMessage::MergeFrom(const RpcMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:openscreen.cast.RpcMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      handle_ = from.handle_;
    }
    if (cached_has_bits & 0x00000002u) {
      proc_ = from.proc_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.rpc_oneof_case()) {
    case kIntegerValue: {
      _internal_set_integer_value(from._internal_integer_value());
      break;
    }
    case kInteger64Value: {
      _internal_set_integer64_value(from._internal_integer64_value());
      break;
    }
    case kDoubleValue: {
      _internal_set_double_value(from._internal_double_value());
      break;
    }
    case kBooleanValue: {
      _internal_set_boolean_value(from._internal_boolean_value());
      break;
    }
    case kStringValue: {
      _internal_set_string_value(from._internal_string_value());
      break;
    }
    case kRendererInitializeRpc: {
      _internal_mutable_renderer_initialize_rpc()->::openscreen::cast::RendererInitialize::MergeFrom(from._internal_renderer_initialize_rpc());
      break;
    }
    case kRendererFlushuntilRpc: {
      _internal_mutable_renderer_flushuntil_rpc()->::openscreen::cast::RendererFlushUntil::MergeFrom(from._internal_renderer_flushuntil_rpc());
      break;
    }
    case kAcquireDemuxerRpc: {
      _internal_mutable_acquire_demuxer_rpc()->::openscreen::cast::AcquireDemuxer::MergeFrom(from._internal_acquire_demuxer_rpc());
      break;
    }
    case kRendererclientOntimeupdateRpc: {
      _internal_mutable_rendererclient_ontimeupdate_rpc()->::openscreen::cast::RendererClientOnTimeUpdate::MergeFrom(from._internal_rendererclient_ontimeupdate_rpc());
      break;
    }
    case kRendererclientOnvideonatualsizechangeRpc: {
      _internal_mutable_rendererclient_onvideonatualsizechange_rpc()->::openscreen::cast::Size::MergeFrom(from._internal_rendererclient_onvideonatualsizechange_rpc());
      break;
    }
    case kRendererclientOnstatisticsupdateRpc: {
      _internal_mutable_rendererclient_onstatisticsupdate_rpc()->::openscreen::cast::PipelineStatistics::MergeFrom(from._internal_rendererclient_onstatisticsupdate_rpc());
      break;
    }
    case kRendererclientOnbufferingstatechangeRpc: {
      _internal_mutable_rendererclient_onbufferingstatechange_rpc()->::openscreen::cast::RendererClientOnBufferingStateChange::MergeFrom(from._internal_rendererclient_onbufferingstatechange_rpc());
      break;
    }
    case kRendererclientOnaudioconfigchangeRpc: {
      _internal_mutable_rendererclient_onaudioconfigchange_rpc()->::openscreen::cast::RendererClientOnAudioConfigChange::MergeFrom(from._internal_rendererclient_onaudioconfigchange_rpc());
      break;
    }
    case kRendererclientOnvideoconfigchangeRpc: {
      _internal_mutable_rendererclient_onvideoconfigchange_rpc()->::openscreen::cast::RendererClientOnVideoConfigChange::MergeFrom(from._internal_rendererclient_onvideoconfigchange_rpc());
      break;
    }
    case kDemuxerstreamReaduntilRpc: {
      _internal_mutable_demuxerstream_readuntil_rpc()->::openscreen::cast::DemuxerStreamReadUntil::MergeFrom(from._internal_demuxerstream_readuntil_rpc());
      break;
    }
    case kDemuxerstreamInitializecbRpc: {
      _internal_mutable_demuxerstream_initializecb_rpc()->::openscreen::cast::DemuxerStreamInitializeCallback::MergeFrom(from._internal_demuxerstream_initializecb_rpc());
      break;
    }
    case kDemuxerstreamReaduntilcbRpc: {
      _internal_mutable_demuxerstream_readuntilcb_rpc()->::openscreen::cast::DemuxerStreamReadUntilCallback::MergeFrom(from._internal_demuxerstream_readuntilcb_rpc());
      break;
    }
    case RPC_ONEOF_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void RpcMessage::CopyFrom(const RpcMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:openscreen.cast.RpcMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RpcMessage::IsInitialized() const {
  return true;
}

void RpcMessage::InternalSwap(RpcMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RpcMessage, proc_)
      + sizeof(RpcMessage::proc_)
      - PROTOBUF_FIELD_OFFSET(RpcMessage, handle_)>(
          reinterpret_cast<char*>(&handle_),
          reinterpret_cast<char*>(&other->handle_));
  swap(rpc_oneof_, other->rpc_oneof_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string RpcMessage::GetTypeName() const {
  return "openscreen.cast.RpcMessage";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace cast
}  // namespace openscreen
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::openscreen::cast::DecoderBuffer*
Arena::CreateMaybeMessage< ::openscreen::cast::DecoderBuffer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::DecoderBuffer >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::Size*
Arena::CreateMaybeMessage< ::openscreen::cast::Size >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::Size >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::AudioDecoderConfig*
Arena::CreateMaybeMessage< ::openscreen::cast::AudioDecoderConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::AudioDecoderConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::Rect*
Arena::CreateMaybeMessage< ::openscreen::cast::Rect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::Rect >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::VideoDecoderConfig*
Arena::CreateMaybeMessage< ::openscreen::cast::VideoDecoderConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::VideoDecoderConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::AudioDecoderInfo*
Arena::CreateMaybeMessage< ::openscreen::cast::AudioDecoderInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::AudioDecoderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::VideoDecoderInfo*
Arena::CreateMaybeMessage< ::openscreen::cast::VideoDecoderInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::VideoDecoderInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::PipelineStatistics*
Arena::CreateMaybeMessage< ::openscreen::cast::PipelineStatistics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::PipelineStatistics >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::AcquireDemuxer*
Arena::CreateMaybeMessage< ::openscreen::cast::AcquireDemuxer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::AcquireDemuxer >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RendererInitialize*
Arena::CreateMaybeMessage< ::openscreen::cast::RendererInitialize >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RendererInitialize >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RendererFlushUntil*
Arena::CreateMaybeMessage< ::openscreen::cast::RendererFlushUntil >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RendererFlushUntil >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RendererClientOnTimeUpdate*
Arena::CreateMaybeMessage< ::openscreen::cast::RendererClientOnTimeUpdate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RendererClientOnTimeUpdate >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RendererClientOnBufferingStateChange*
Arena::CreateMaybeMessage< ::openscreen::cast::RendererClientOnBufferingStateChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RendererClientOnBufferingStateChange >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RendererClientOnAudioConfigChange*
Arena::CreateMaybeMessage< ::openscreen::cast::RendererClientOnAudioConfigChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RendererClientOnAudioConfigChange >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RendererClientOnVideoConfigChange*
Arena::CreateMaybeMessage< ::openscreen::cast::RendererClientOnVideoConfigChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RendererClientOnVideoConfigChange >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::DemuxerStreamReadUntil*
Arena::CreateMaybeMessage< ::openscreen::cast::DemuxerStreamReadUntil >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::DemuxerStreamReadUntil >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::DemuxerStreamInitializeCallback*
Arena::CreateMaybeMessage< ::openscreen::cast::DemuxerStreamInitializeCallback >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::DemuxerStreamInitializeCallback >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::DemuxerStreamReadUntilCallback*
Arena::CreateMaybeMessage< ::openscreen::cast::DemuxerStreamReadUntilCallback >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::DemuxerStreamReadUntilCallback >(arena);
}
template<> PROTOBUF_NOINLINE ::openscreen::cast::RpcMessage*
Arena::CreateMaybeMessage< ::openscreen::cast::RpcMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::openscreen::cast::RpcMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
