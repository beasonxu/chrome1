// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: remoting.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_remoting_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_remoting_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_remoting_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_remoting_2eproto {
  static const uint32_t offsets[];
};
namespace openscreen {
namespace cast {
class AcquireDemuxer;
struct AcquireDemuxerDefaultTypeInternal;
extern AcquireDemuxerDefaultTypeInternal _AcquireDemuxer_default_instance_;
class AudioDecoderConfig;
struct AudioDecoderConfigDefaultTypeInternal;
extern AudioDecoderConfigDefaultTypeInternal _AudioDecoderConfig_default_instance_;
class AudioDecoderInfo;
struct AudioDecoderInfoDefaultTypeInternal;
extern AudioDecoderInfoDefaultTypeInternal _AudioDecoderInfo_default_instance_;
class DecoderBuffer;
struct DecoderBufferDefaultTypeInternal;
extern DecoderBufferDefaultTypeInternal _DecoderBuffer_default_instance_;
class DemuxerStreamInitializeCallback;
struct DemuxerStreamInitializeCallbackDefaultTypeInternal;
extern DemuxerStreamInitializeCallbackDefaultTypeInternal _DemuxerStreamInitializeCallback_default_instance_;
class DemuxerStreamReadUntil;
struct DemuxerStreamReadUntilDefaultTypeInternal;
extern DemuxerStreamReadUntilDefaultTypeInternal _DemuxerStreamReadUntil_default_instance_;
class DemuxerStreamReadUntilCallback;
struct DemuxerStreamReadUntilCallbackDefaultTypeInternal;
extern DemuxerStreamReadUntilCallbackDefaultTypeInternal _DemuxerStreamReadUntilCallback_default_instance_;
class PipelineStatistics;
struct PipelineStatisticsDefaultTypeInternal;
extern PipelineStatisticsDefaultTypeInternal _PipelineStatistics_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RendererClientOnAudioConfigChange;
struct RendererClientOnAudioConfigChangeDefaultTypeInternal;
extern RendererClientOnAudioConfigChangeDefaultTypeInternal _RendererClientOnAudioConfigChange_default_instance_;
class RendererClientOnBufferingStateChange;
struct RendererClientOnBufferingStateChangeDefaultTypeInternal;
extern RendererClientOnBufferingStateChangeDefaultTypeInternal _RendererClientOnBufferingStateChange_default_instance_;
class RendererClientOnTimeUpdate;
struct RendererClientOnTimeUpdateDefaultTypeInternal;
extern RendererClientOnTimeUpdateDefaultTypeInternal _RendererClientOnTimeUpdate_default_instance_;
class RendererClientOnVideoConfigChange;
struct RendererClientOnVideoConfigChangeDefaultTypeInternal;
extern RendererClientOnVideoConfigChangeDefaultTypeInternal _RendererClientOnVideoConfigChange_default_instance_;
class RendererFlushUntil;
struct RendererFlushUntilDefaultTypeInternal;
extern RendererFlushUntilDefaultTypeInternal _RendererFlushUntil_default_instance_;
class RendererInitialize;
struct RendererInitializeDefaultTypeInternal;
extern RendererInitializeDefaultTypeInternal _RendererInitialize_default_instance_;
class RpcMessage;
struct RpcMessageDefaultTypeInternal;
extern RpcMessageDefaultTypeInternal _RpcMessage_default_instance_;
class Size;
struct SizeDefaultTypeInternal;
extern SizeDefaultTypeInternal _Size_default_instance_;
class VideoDecoderConfig;
struct VideoDecoderConfigDefaultTypeInternal;
extern VideoDecoderConfigDefaultTypeInternal _VideoDecoderConfig_default_instance_;
class VideoDecoderInfo;
struct VideoDecoderInfoDefaultTypeInternal;
extern VideoDecoderInfoDefaultTypeInternal _VideoDecoderInfo_default_instance_;
}  // namespace cast
}  // namespace openscreen
PROTOBUF_NAMESPACE_OPEN
template<> ::openscreen::cast::AcquireDemuxer* Arena::CreateMaybeMessage<::openscreen::cast::AcquireDemuxer>(Arena*);
template<> ::openscreen::cast::AudioDecoderConfig* Arena::CreateMaybeMessage<::openscreen::cast::AudioDecoderConfig>(Arena*);
template<> ::openscreen::cast::AudioDecoderInfo* Arena::CreateMaybeMessage<::openscreen::cast::AudioDecoderInfo>(Arena*);
template<> ::openscreen::cast::DecoderBuffer* Arena::CreateMaybeMessage<::openscreen::cast::DecoderBuffer>(Arena*);
template<> ::openscreen::cast::DemuxerStreamInitializeCallback* Arena::CreateMaybeMessage<::openscreen::cast::DemuxerStreamInitializeCallback>(Arena*);
template<> ::openscreen::cast::DemuxerStreamReadUntil* Arena::CreateMaybeMessage<::openscreen::cast::DemuxerStreamReadUntil>(Arena*);
template<> ::openscreen::cast::DemuxerStreamReadUntilCallback* Arena::CreateMaybeMessage<::openscreen::cast::DemuxerStreamReadUntilCallback>(Arena*);
template<> ::openscreen::cast::PipelineStatistics* Arena::CreateMaybeMessage<::openscreen::cast::PipelineStatistics>(Arena*);
template<> ::openscreen::cast::Rect* Arena::CreateMaybeMessage<::openscreen::cast::Rect>(Arena*);
template<> ::openscreen::cast::RendererClientOnAudioConfigChange* Arena::CreateMaybeMessage<::openscreen::cast::RendererClientOnAudioConfigChange>(Arena*);
template<> ::openscreen::cast::RendererClientOnBufferingStateChange* Arena::CreateMaybeMessage<::openscreen::cast::RendererClientOnBufferingStateChange>(Arena*);
template<> ::openscreen::cast::RendererClientOnTimeUpdate* Arena::CreateMaybeMessage<::openscreen::cast::RendererClientOnTimeUpdate>(Arena*);
template<> ::openscreen::cast::RendererClientOnVideoConfigChange* Arena::CreateMaybeMessage<::openscreen::cast::RendererClientOnVideoConfigChange>(Arena*);
template<> ::openscreen::cast::RendererFlushUntil* Arena::CreateMaybeMessage<::openscreen::cast::RendererFlushUntil>(Arena*);
template<> ::openscreen::cast::RendererInitialize* Arena::CreateMaybeMessage<::openscreen::cast::RendererInitialize>(Arena*);
template<> ::openscreen::cast::RpcMessage* Arena::CreateMaybeMessage<::openscreen::cast::RpcMessage>(Arena*);
template<> ::openscreen::cast::Size* Arena::CreateMaybeMessage<::openscreen::cast::Size>(Arena*);
template<> ::openscreen::cast::VideoDecoderConfig* Arena::CreateMaybeMessage<::openscreen::cast::VideoDecoderConfig>(Arena*);
template<> ::openscreen::cast::VideoDecoderInfo* Arena::CreateMaybeMessage<::openscreen::cast::VideoDecoderInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace openscreen {
namespace cast {

enum AudioDecoderConfig_Codec : int {
  AudioDecoderConfig_Codec_kUnknownAudioCodec = 0,
  AudioDecoderConfig_Codec_kCodecAAC = 1,
  AudioDecoderConfig_Codec_kCodecMP3 = 2,
  AudioDecoderConfig_Codec_kCodecPCM = 3,
  AudioDecoderConfig_Codec_kCodecVorbis = 4,
  AudioDecoderConfig_Codec_kCodecFLAC = 5,
  AudioDecoderConfig_Codec_kCodecAMR_NB = 6,
  AudioDecoderConfig_Codec_kCodecAMR_WB = 7,
  AudioDecoderConfig_Codec_kCodecPCM_MULAW = 8,
  AudioDecoderConfig_Codec_kCodecGSM_MS = 9,
  AudioDecoderConfig_Codec_kCodecPCM_S16BE = 10,
  AudioDecoderConfig_Codec_kCodecPCM_S24BE = 11,
  AudioDecoderConfig_Codec_kCodecOpus = 12,
  AudioDecoderConfig_Codec_kCodecEAC3 = 13,
  AudioDecoderConfig_Codec_kCodecPCM_ALAW = 14,
  AudioDecoderConfig_Codec_kCodecALAC = 15,
  AudioDecoderConfig_Codec_kCodecAC3 = 16,
  AudioDecoderConfig_Codec_kCodecMpegHAudio = 17,
  AudioDecoderConfig_Codec_kCodecDTS = 18,
  AudioDecoderConfig_Codec_kCodecDTSXP2 = 19
};
bool AudioDecoderConfig_Codec_IsValid(int value);
constexpr AudioDecoderConfig_Codec AudioDecoderConfig_Codec_Codec_MIN = AudioDecoderConfig_Codec_kUnknownAudioCodec;
constexpr AudioDecoderConfig_Codec AudioDecoderConfig_Codec_Codec_MAX = AudioDecoderConfig_Codec_kCodecDTSXP2;
constexpr int AudioDecoderConfig_Codec_Codec_ARRAYSIZE = AudioDecoderConfig_Codec_Codec_MAX + 1;

const std::string& AudioDecoderConfig_Codec_Name(AudioDecoderConfig_Codec value);
template<typename T>
inline const std::string& AudioDecoderConfig_Codec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioDecoderConfig_Codec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioDecoderConfig_Codec_Name.");
  return AudioDecoderConfig_Codec_Name(static_cast<AudioDecoderConfig_Codec>(enum_t_value));
}
bool AudioDecoderConfig_Codec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioDecoderConfig_Codec* value);
enum AudioDecoderConfig_SampleFormat : int {
  AudioDecoderConfig_SampleFormat_kUnknownSampleFormat = 0,
  AudioDecoderConfig_SampleFormat_kSampleFormatU8 = 1,
  AudioDecoderConfig_SampleFormat_kSampleFormatS16 = 2,
  AudioDecoderConfig_SampleFormat_kSampleFormatS32 = 3,
  AudioDecoderConfig_SampleFormat_kSampleFormatF32 = 4,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS16 = 5,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarF32 = 6,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS32 = 7,
  AudioDecoderConfig_SampleFormat_kSampleFormatS24 = 8,
  AudioDecoderConfig_SampleFormat_kSampleFormatAc3 = 9,
  AudioDecoderConfig_SampleFormat_kSampleFormatEac3 = 10,
  AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio = 11,
  AudioDecoderConfig_SampleFormat_kSampleFormatPlanarU8 = 12,
  AudioDecoderConfig_SampleFormat_kSampleFormatDts = 13,
  AudioDecoderConfig_SampleFormat_kSampleFormatDtsxP2 = 14
};
bool AudioDecoderConfig_SampleFormat_IsValid(int value);
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig_SampleFormat_SampleFormat_MIN = AudioDecoderConfig_SampleFormat_kUnknownSampleFormat;
constexpr AudioDecoderConfig_SampleFormat AudioDecoderConfig_SampleFormat_SampleFormat_MAX = AudioDecoderConfig_SampleFormat_kSampleFormatDtsxP2;
constexpr int AudioDecoderConfig_SampleFormat_SampleFormat_ARRAYSIZE = AudioDecoderConfig_SampleFormat_SampleFormat_MAX + 1;

const std::string& AudioDecoderConfig_SampleFormat_Name(AudioDecoderConfig_SampleFormat value);
template<typename T>
inline const std::string& AudioDecoderConfig_SampleFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioDecoderConfig_SampleFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioDecoderConfig_SampleFormat_Name.");
  return AudioDecoderConfig_SampleFormat_Name(static_cast<AudioDecoderConfig_SampleFormat>(enum_t_value));
}
bool AudioDecoderConfig_SampleFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioDecoderConfig_SampleFormat* value);
enum AudioDecoderConfig_ChannelLayout : int {
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE = 0,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_UNSUPPORTED = 1,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_MONO = 2,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO = 3,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_1 = 4,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_SURROUND = 5,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_0 = 6,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_2 = 7,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_QUAD = 8,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0 = 9,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1 = 10,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0_BACK = 11,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1_BACK = 12,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0 = 13,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1 = 14,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE = 15,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_DOWNMIX = 16,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2POINT1 = 17,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_3_1 = 18,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1 = 19,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0 = 20,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0_FRONT = 21,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_HEXAGONAL = 22,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1 = 23,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_BACK = 24,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_FRONT = 25,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0_FRONT = 26,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE_BACK = 27,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_OCTAGONAL = 28,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_DISCRETE = 29,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC = 30,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1_QUAD_SIDE = 31,
  AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM = 32
};
bool AudioDecoderConfig_ChannelLayout_IsValid(int value);
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig_ChannelLayout_ChannelLayout_MIN = AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE;
constexpr AudioDecoderConfig_ChannelLayout AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX = AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM;
constexpr int AudioDecoderConfig_ChannelLayout_ChannelLayout_ARRAYSIZE = AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX + 1;

const std::string& AudioDecoderConfig_ChannelLayout_Name(AudioDecoderConfig_ChannelLayout value);
template<typename T>
inline const std::string& AudioDecoderConfig_ChannelLayout_Name(T enum_t_value) {
  static_assert(::std::is_same<T, AudioDecoderConfig_ChannelLayout>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function AudioDecoderConfig_ChannelLayout_Name.");
  return AudioDecoderConfig_ChannelLayout_Name(static_cast<AudioDecoderConfig_ChannelLayout>(enum_t_value));
}
bool AudioDecoderConfig_ChannelLayout_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, AudioDecoderConfig_ChannelLayout* value);
enum VideoDecoderConfig_Codec : int {
  VideoDecoderConfig_Codec_kUnknownVideoCodec = 0,
  VideoDecoderConfig_Codec_kCodecH264 = 1,
  VideoDecoderConfig_Codec_kCodecVC1 = 2,
  VideoDecoderConfig_Codec_kCodecMPEG2 = 3,
  VideoDecoderConfig_Codec_kCodecMPEG4 = 4,
  VideoDecoderConfig_Codec_kCodecTheora = 5,
  VideoDecoderConfig_Codec_kCodecVP8 = 6,
  VideoDecoderConfig_Codec_kCodecVP9 = 7,
  VideoDecoderConfig_Codec_kCodecHEVC = 8,
  VideoDecoderConfig_Codec_kCodecDolbyVision = 9,
  VideoDecoderConfig_Codec_kCodecAV1 = 10
};
bool VideoDecoderConfig_Codec_IsValid(int value);
constexpr VideoDecoderConfig_Codec VideoDecoderConfig_Codec_Codec_MIN = VideoDecoderConfig_Codec_kUnknownVideoCodec;
constexpr VideoDecoderConfig_Codec VideoDecoderConfig_Codec_Codec_MAX = VideoDecoderConfig_Codec_kCodecAV1;
constexpr int VideoDecoderConfig_Codec_Codec_ARRAYSIZE = VideoDecoderConfig_Codec_Codec_MAX + 1;

const std::string& VideoDecoderConfig_Codec_Name(VideoDecoderConfig_Codec value);
template<typename T>
inline const std::string& VideoDecoderConfig_Codec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_Codec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_Codec_Name.");
  return VideoDecoderConfig_Codec_Name(static_cast<VideoDecoderConfig_Codec>(enum_t_value));
}
bool VideoDecoderConfig_Codec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_Codec* value);
enum VideoDecoderConfig_Profile : int {
  VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN = -1,
  VideoDecoderConfig_Profile_H264PROFILE_BASELINE = 0,
  VideoDecoderConfig_Profile_H264PROFILE_MAIN = 1,
  VideoDecoderConfig_Profile_H264PROFILE_EXTENDED = 2,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH = 3,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH10PROFILE = 4,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH422PROFILE = 5,
  VideoDecoderConfig_Profile_H264PROFILE_HIGH444PREDICTIVEPROFILE = 6,
  VideoDecoderConfig_Profile_H264PROFILE_SCALABLEBASELINE = 7,
  VideoDecoderConfig_Profile_H264PROFILE_SCALABLEHIGH = 8,
  VideoDecoderConfig_Profile_H264PROFILE_STEREOHIGH = 9,
  VideoDecoderConfig_Profile_H264PROFILE_MULTIVIEWHIGH = 10,
  VideoDecoderConfig_Profile_VP8PROFILE_ANY = 11,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE0 = 12,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE1 = 13,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE2 = 14,
  VideoDecoderConfig_Profile_VP9PROFILE_PROFILE3 = 15,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN = 16,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN10 = 17,
  VideoDecoderConfig_Profile_HEVCPROFILE_MAIN_STILL_PICTURE = 18,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE0 = 19,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE4 = 20,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE5 = 21,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE7 = 22,
  VideoDecoderConfig_Profile_THEORAPROFILE_ANY = 23,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_MAIN = 24,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_HIGH = 25,
  VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_PRO = 26,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE8 = 27,
  VideoDecoderConfig_Profile_DOLBYVISION_PROFILE9 = 28,
  VideoDecoderConfig_Profile_HEVCPROFILE_REXT = 29,
  VideoDecoderConfig_Profile_HEVCPROFILE_HIGH_THROUGHPUT = 30,
  VideoDecoderConfig_Profile_HEVCPROFILE_MULTIVIEW_MAIN = 31,
  VideoDecoderConfig_Profile_HEVCPROFILE_SCALABLE_MAIN = 32,
  VideoDecoderConfig_Profile_HEVCPROFILE_3D_MAIN = 33,
  VideoDecoderConfig_Profile_HEVCPROFILE_SCREEN_EXTENDED = 34,
  VideoDecoderConfig_Profile_HEVCPROFILE_SCALABLE_REXT = 35,
  VideoDecoderConfig_Profile_HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED = 36
};
bool VideoDecoderConfig_Profile_IsValid(int value);
constexpr VideoDecoderConfig_Profile VideoDecoderConfig_Profile_Profile_MIN = VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN;
constexpr VideoDecoderConfig_Profile VideoDecoderConfig_Profile_Profile_MAX = VideoDecoderConfig_Profile_HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED;
constexpr int VideoDecoderConfig_Profile_Profile_ARRAYSIZE = VideoDecoderConfig_Profile_Profile_MAX + 1;

const std::string& VideoDecoderConfig_Profile_Name(VideoDecoderConfig_Profile value);
template<typename T>
inline const std::string& VideoDecoderConfig_Profile_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_Profile>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_Profile_Name.");
  return VideoDecoderConfig_Profile_Name(static_cast<VideoDecoderConfig_Profile>(enum_t_value));
}
bool VideoDecoderConfig_Profile_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_Profile* value);
enum VideoDecoderConfig_Format : int {
  VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN = 0,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I420 = 1,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YV12 = 2,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I422 = 3,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I420A = 4,
  VideoDecoderConfig_Format_PIXEL_FORMAT_I444 = 5,
  VideoDecoderConfig_Format_PIXEL_FORMAT_NV12 = 6,
  VideoDecoderConfig_Format_PIXEL_FORMAT_NV21 = 7,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUY2 = 9,
  VideoDecoderConfig_Format_PIXEL_FORMAT_ARGB = 10,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XRGB = 11,
  VideoDecoderConfig_Format_PIXEL_FORMAT_RGB24 = 12,
  VideoDecoderConfig_Format_PIXEL_FORMAT_RGB32 = 13,
  VideoDecoderConfig_Format_PIXEL_FORMAT_MJPEG = 14,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P9 = 16,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P10 = 17,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P9 = 18,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P10 = 19,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P9 = 20,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P10 = 21,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P12 = 22,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P12 = 23,
  VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P12 = 24,
  VideoDecoderConfig_Format_PIXEL_FORMAT_Y16 = 26,
  VideoDecoderConfig_Format_PIXEL_FORMAT_ABGR = 27,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XBGR = 28,
  VideoDecoderConfig_Format_PIXEL_FORMAT_P016LE = 29,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XR30 = 30,
  VideoDecoderConfig_Format_PIXEL_FORMAT_XB30 = 31
};
bool VideoDecoderConfig_Format_IsValid(int value);
constexpr VideoDecoderConfig_Format VideoDecoderConfig_Format_Format_MIN = VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN;
constexpr VideoDecoderConfig_Format VideoDecoderConfig_Format_Format_MAX = VideoDecoderConfig_Format_PIXEL_FORMAT_XB30;
constexpr int VideoDecoderConfig_Format_Format_ARRAYSIZE = VideoDecoderConfig_Format_Format_MAX + 1;

const std::string& VideoDecoderConfig_Format_Name(VideoDecoderConfig_Format value);
template<typename T>
inline const std::string& VideoDecoderConfig_Format_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_Format>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_Format_Name.");
  return VideoDecoderConfig_Format_Name(static_cast<VideoDecoderConfig_Format>(enum_t_value));
}
bool VideoDecoderConfig_Format_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_Format* value);
enum VideoDecoderConfig_ColorSpace : int {
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED = 0,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_JPEG = 1,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_HD_REC709 = 2,
  VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601 = 3
};
bool VideoDecoderConfig_ColorSpace_IsValid(int value);
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig_ColorSpace_ColorSpace_MIN = VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED;
constexpr VideoDecoderConfig_ColorSpace VideoDecoderConfig_ColorSpace_ColorSpace_MAX = VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601;
constexpr int VideoDecoderConfig_ColorSpace_ColorSpace_ARRAYSIZE = VideoDecoderConfig_ColorSpace_ColorSpace_MAX + 1;

const std::string& VideoDecoderConfig_ColorSpace_Name(VideoDecoderConfig_ColorSpace value);
template<typename T>
inline const std::string& VideoDecoderConfig_ColorSpace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VideoDecoderConfig_ColorSpace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VideoDecoderConfig_ColorSpace_Name.");
  return VideoDecoderConfig_ColorSpace_Name(static_cast<VideoDecoderConfig_ColorSpace>(enum_t_value));
}
bool VideoDecoderConfig_ColorSpace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, VideoDecoderConfig_ColorSpace* value);
enum RendererClientOnBufferingStateChange_State : int {
  RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING = 0,
  RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH = 1
};
bool RendererClientOnBufferingStateChange_State_IsValid(int value);
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange_State_State_MIN = RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING;
constexpr RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange_State_State_MAX = RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH;
constexpr int RendererClientOnBufferingStateChange_State_State_ARRAYSIZE = RendererClientOnBufferingStateChange_State_State_MAX + 1;

const std::string& RendererClientOnBufferingStateChange_State_Name(RendererClientOnBufferingStateChange_State value);
template<typename T>
inline const std::string& RendererClientOnBufferingStateChange_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RendererClientOnBufferingStateChange_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RendererClientOnBufferingStateChange_State_Name.");
  return RendererClientOnBufferingStateChange_State_Name(static_cast<RendererClientOnBufferingStateChange_State>(enum_t_value));
}
bool RendererClientOnBufferingStateChange_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RendererClientOnBufferingStateChange_State* value);
enum DemuxerStreamReadUntilCallback_Status : int {
  DemuxerStreamReadUntilCallback_Status_kOk = 0,
  DemuxerStreamReadUntilCallback_Status_kAborted = 1,
  DemuxerStreamReadUntilCallback_Status_kConfigChanged = 2,
  DemuxerStreamReadUntilCallback_Status_kError = 3
};
bool DemuxerStreamReadUntilCallback_Status_IsValid(int value);
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback_Status_Status_MIN = DemuxerStreamReadUntilCallback_Status_kOk;
constexpr DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback_Status_Status_MAX = DemuxerStreamReadUntilCallback_Status_kError;
constexpr int DemuxerStreamReadUntilCallback_Status_Status_ARRAYSIZE = DemuxerStreamReadUntilCallback_Status_Status_MAX + 1;

const std::string& DemuxerStreamReadUntilCallback_Status_Name(DemuxerStreamReadUntilCallback_Status value);
template<typename T>
inline const std::string& DemuxerStreamReadUntilCallback_Status_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DemuxerStreamReadUntilCallback_Status>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DemuxerStreamReadUntilCallback_Status_Name.");
  return DemuxerStreamReadUntilCallback_Status_Name(static_cast<DemuxerStreamReadUntilCallback_Status>(enum_t_value));
}
bool DemuxerStreamReadUntilCallback_Status_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DemuxerStreamReadUntilCallback_Status* value);
enum RpcMessage_RpcProc : int {
  RpcMessage_RpcProc_RPC_INTERNAL = 0,
  RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER = 1,
  RpcMessage_RpcProc_RPC_ACQUIRE_DEMUXER = 5,
  RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER_DONE = 2,
  RpcMessage_RpcProc_RPC_R_INITIALIZE = 1000,
  RpcMessage_RpcProc_RPC_R_FLUSHUNTIL = 1001,
  RpcMessage_RpcProc_RPC_R_STARTPLAYINGFROM = 1002,
  RpcMessage_RpcProc_RPC_R_SETPLAYBACKRATE = 1003,
  RpcMessage_RpcProc_RPC_R_SETVOLUME = 1004,
  RpcMessage_RpcProc_RPC_R_INITIALIZE_CALLBACK = 1100,
  RpcMessage_RpcProc_RPC_R_FLUSHUNTIL_CALLBACK = 1101,
  RpcMessage_RpcProc_RPC_R_SETCDM_CALLBACK = 1102,
  RpcMessage_RpcProc_RPC_RC_ONTIMEUPDATE = 2000,
  RpcMessage_RpcProc_RPC_RC_ONBUFFERINGSTATECHANGE = 2001,
  RpcMessage_RpcProc_RPC_RC_ONENDED = 2002,
  RpcMessage_RpcProc_RPC_RC_ONERROR = 2003,
  RpcMessage_RpcProc_RPC_RC_ONVIDEONATURALSIZECHANGE = 2004,
  RpcMessage_RpcProc_RPC_RC_ONVIDEOOPACITYCHANGE = 2005,
  RpcMessage_RpcProc_RPC_RC_ONSTATISTICSUPDATE = 2006,
  RpcMessage_RpcProc_RPC_RC_ONAUDIOCONFIGCHANGE = 2009,
  RpcMessage_RpcProc_RPC_RC_ONVIDEOCONFIGCHANGE = 2010,
  RpcMessage_RpcProc_RPC_DS_INITIALIZE = 3000,
  RpcMessage_RpcProc_RPC_DS_READUNTIL = 3001,
  RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER = 3002,
  RpcMessage_RpcProc_RPC_DS_ONERROR = 3003,
  RpcMessage_RpcProc_RPC_DS_INITIALIZE_CALLBACK = 3100,
  RpcMessage_RpcProc_RPC_DS_READUNTIL_CALLBACK = 3101,
  RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK = 3102
};
bool RpcMessage_RpcProc_IsValid(int value);
constexpr RpcMessage_RpcProc RpcMessage_RpcProc_RpcProc_MIN = RpcMessage_RpcProc_RPC_INTERNAL;
constexpr RpcMessage_RpcProc RpcMessage_RpcProc_RpcProc_MAX = RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK;
constexpr int RpcMessage_RpcProc_RpcProc_ARRAYSIZE = RpcMessage_RpcProc_RpcProc_MAX + 1;

const std::string& RpcMessage_RpcProc_Name(RpcMessage_RpcProc value);
template<typename T>
inline const std::string& RpcMessage_RpcProc_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RpcMessage_RpcProc>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RpcMessage_RpcProc_Name.");
  return RpcMessage_RpcProc_Name(static_cast<RpcMessage_RpcProc>(enum_t_value));
}
bool RpcMessage_RpcProc_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RpcMessage_RpcProc* value);
// ===================================================================

class DecoderBuffer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.DecoderBuffer) */ {
 public:
  inline DecoderBuffer() : DecoderBuffer(nullptr) {}
  ~DecoderBuffer() override;
  explicit PROTOBUF_CONSTEXPR DecoderBuffer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecoderBuffer(const DecoderBuffer& from);
  DecoderBuffer(DecoderBuffer&& from) noexcept
    : DecoderBuffer() {
    *this = ::std::move(from);
  }

  inline DecoderBuffer& operator=(const DecoderBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecoderBuffer& operator=(DecoderBuffer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DecoderBuffer& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecoderBuffer* internal_default_instance() {
    return reinterpret_cast<const DecoderBuffer*>(
               &_DecoderBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DecoderBuffer& a, DecoderBuffer& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DecoderBuffer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecoderBuffer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecoderBuffer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecoderBuffer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DecoderBuffer& from);
  void MergeFrom(const DecoderBuffer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecoderBuffer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.DecoderBuffer";
  }
  protected:
  explicit DecoderBuffer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSideDataFieldNumber = 8,
    kTimestampUsecFieldNumber = 1,
    kDurationUsecFieldNumber = 2,
    kFrontDiscardUsecFieldNumber = 5,
    kBackDiscardUsecFieldNumber = 6,
    kIsKeyFrameFieldNumber = 3,
    kIsEosFieldNumber = 9,
  };
  // optional bytes side_data = 8;
  bool has_side_data() const;
  private:
  bool _internal_has_side_data() const;
  public:
  void clear_side_data();
  const std::string& side_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_side_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_side_data();
  PROTOBUF_NODISCARD std::string* release_side_data();
  void set_allocated_side_data(std::string* side_data);
  private:
  const std::string& _internal_side_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_side_data(const std::string& value);
  std::string* _internal_mutable_side_data();
  public:

  // optional int64 timestamp_usec = 1;
  bool has_timestamp_usec() const;
  private:
  bool _internal_has_timestamp_usec() const;
  public:
  void clear_timestamp_usec();
  int64_t timestamp_usec() const;
  void set_timestamp_usec(int64_t value);
  private:
  int64_t _internal_timestamp_usec() const;
  void _internal_set_timestamp_usec(int64_t value);
  public:

  // optional int64 duration_usec = 2;
  bool has_duration_usec() const;
  private:
  bool _internal_has_duration_usec() const;
  public:
  void clear_duration_usec();
  int64_t duration_usec() const;
  void set_duration_usec(int64_t value);
  private:
  int64_t _internal_duration_usec() const;
  void _internal_set_duration_usec(int64_t value);
  public:

  // optional int64 front_discard_usec = 5;
  bool has_front_discard_usec() const;
  private:
  bool _internal_has_front_discard_usec() const;
  public:
  void clear_front_discard_usec();
  int64_t front_discard_usec() const;
  void set_front_discard_usec(int64_t value);
  private:
  int64_t _internal_front_discard_usec() const;
  void _internal_set_front_discard_usec(int64_t value);
  public:

  // optional int64 back_discard_usec = 6;
  bool has_back_discard_usec() const;
  private:
  bool _internal_has_back_discard_usec() const;
  public:
  void clear_back_discard_usec();
  int64_t back_discard_usec() const;
  void set_back_discard_usec(int64_t value);
  private:
  int64_t _internal_back_discard_usec() const;
  void _internal_set_back_discard_usec(int64_t value);
  public:

  // optional bool is_key_frame = 3;
  bool has_is_key_frame() const;
  private:
  bool _internal_has_is_key_frame() const;
  public:
  void clear_is_key_frame();
  bool is_key_frame() const;
  void set_is_key_frame(bool value);
  private:
  bool _internal_is_key_frame() const;
  void _internal_set_is_key_frame(bool value);
  public:

  // optional bool is_eos = 9;
  bool has_is_eos() const;
  private:
  bool _internal_has_is_eos() const;
  public:
  void clear_is_eos();
  bool is_eos() const;
  void set_is_eos(bool value);
  private:
  bool _internal_is_eos() const;
  void _internal_set_is_eos(bool value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.DecoderBuffer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr side_data_;
  int64_t timestamp_usec_;
  int64_t duration_usec_;
  int64_t front_discard_usec_;
  int64_t back_discard_usec_;
  bool is_key_frame_;
  bool is_eos_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class Size final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.Size) */ {
 public:
  inline Size() : Size(nullptr) {}
  ~Size() override;
  explicit PROTOBUF_CONSTEXPR Size(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Size(const Size& from);
  Size(Size&& from) noexcept
    : Size() {
    *this = ::std::move(from);
  }

  inline Size& operator=(const Size& from) {
    CopyFrom(from);
    return *this;
  }
  inline Size& operator=(Size&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Size& default_instance() {
    return *internal_default_instance();
  }
  static inline const Size* internal_default_instance() {
    return reinterpret_cast<const Size*>(
               &_Size_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Size& a, Size& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Size* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Size* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Size* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Size>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Size& from);
  void MergeFrom(const Size& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Size* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.Size";
  }
  protected:
  explicit Size(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.Size)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class AudioDecoderConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.AudioDecoderConfig) */ {
 public:
  inline AudioDecoderConfig() : AudioDecoderConfig(nullptr) {}
  ~AudioDecoderConfig() override;
  explicit PROTOBUF_CONSTEXPR AudioDecoderConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioDecoderConfig(const AudioDecoderConfig& from);
  AudioDecoderConfig(AudioDecoderConfig&& from) noexcept
    : AudioDecoderConfig() {
    *this = ::std::move(from);
  }

  inline AudioDecoderConfig& operator=(const AudioDecoderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioDecoderConfig& operator=(AudioDecoderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioDecoderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioDecoderConfig* internal_default_instance() {
    return reinterpret_cast<const AudioDecoderConfig*>(
               &_AudioDecoderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AudioDecoderConfig& a, AudioDecoderConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioDecoderConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioDecoderConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioDecoderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioDecoderConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AudioDecoderConfig& from);
  void MergeFrom(const AudioDecoderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioDecoderConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.AudioDecoderConfig";
  }
  protected:
  explicit AudioDecoderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef AudioDecoderConfig_Codec Codec;
  static constexpr Codec kUnknownAudioCodec =
    AudioDecoderConfig_Codec_kUnknownAudioCodec;
  static constexpr Codec kCodecAAC =
    AudioDecoderConfig_Codec_kCodecAAC;
  static constexpr Codec kCodecMP3 =
    AudioDecoderConfig_Codec_kCodecMP3;
  static constexpr Codec kCodecPCM =
    AudioDecoderConfig_Codec_kCodecPCM;
  static constexpr Codec kCodecVorbis =
    AudioDecoderConfig_Codec_kCodecVorbis;
  static constexpr Codec kCodecFLAC =
    AudioDecoderConfig_Codec_kCodecFLAC;
  static constexpr Codec kCodecAMR_NB =
    AudioDecoderConfig_Codec_kCodecAMR_NB;
  static constexpr Codec kCodecAMR_WB =
    AudioDecoderConfig_Codec_kCodecAMR_WB;
  static constexpr Codec kCodecPCM_MULAW =
    AudioDecoderConfig_Codec_kCodecPCM_MULAW;
  static constexpr Codec kCodecGSM_MS =
    AudioDecoderConfig_Codec_kCodecGSM_MS;
  static constexpr Codec kCodecPCM_S16BE =
    AudioDecoderConfig_Codec_kCodecPCM_S16BE;
  static constexpr Codec kCodecPCM_S24BE =
    AudioDecoderConfig_Codec_kCodecPCM_S24BE;
  static constexpr Codec kCodecOpus =
    AudioDecoderConfig_Codec_kCodecOpus;
  static constexpr Codec kCodecEAC3 =
    AudioDecoderConfig_Codec_kCodecEAC3;
  static constexpr Codec kCodecPCM_ALAW =
    AudioDecoderConfig_Codec_kCodecPCM_ALAW;
  static constexpr Codec kCodecALAC =
    AudioDecoderConfig_Codec_kCodecALAC;
  static constexpr Codec kCodecAC3 =
    AudioDecoderConfig_Codec_kCodecAC3;
  static constexpr Codec kCodecMpegHAudio =
    AudioDecoderConfig_Codec_kCodecMpegHAudio;
  static constexpr Codec kCodecDTS =
    AudioDecoderConfig_Codec_kCodecDTS;
  static constexpr Codec kCodecDTSXP2 =
    AudioDecoderConfig_Codec_kCodecDTSXP2;
  static inline bool Codec_IsValid(int value) {
    return AudioDecoderConfig_Codec_IsValid(value);
  }
  static constexpr Codec Codec_MIN =
    AudioDecoderConfig_Codec_Codec_MIN;
  static constexpr Codec Codec_MAX =
    AudioDecoderConfig_Codec_Codec_MAX;
  static constexpr int Codec_ARRAYSIZE =
    AudioDecoderConfig_Codec_Codec_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Codec_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Codec>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Codec_Name.");
    return AudioDecoderConfig_Codec_Name(enum_t_value);
  }
  static inline bool Codec_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Codec* value) {
    return AudioDecoderConfig_Codec_Parse(name, value);
  }

  typedef AudioDecoderConfig_SampleFormat SampleFormat;
  static constexpr SampleFormat kUnknownSampleFormat =
    AudioDecoderConfig_SampleFormat_kUnknownSampleFormat;
  static constexpr SampleFormat kSampleFormatU8 =
    AudioDecoderConfig_SampleFormat_kSampleFormatU8;
  static constexpr SampleFormat kSampleFormatS16 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS16;
  static constexpr SampleFormat kSampleFormatS32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS32;
  static constexpr SampleFormat kSampleFormatF32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatF32;
  static constexpr SampleFormat kSampleFormatPlanarS16 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS16;
  static constexpr SampleFormat kSampleFormatPlanarF32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarF32;
  static constexpr SampleFormat kSampleFormatPlanarS32 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarS32;
  static constexpr SampleFormat kSampleFormatS24 =
    AudioDecoderConfig_SampleFormat_kSampleFormatS24;
  static constexpr SampleFormat kSampleFormatAc3 =
    AudioDecoderConfig_SampleFormat_kSampleFormatAc3;
  static constexpr SampleFormat kSampleFormatEac3 =
    AudioDecoderConfig_SampleFormat_kSampleFormatEac3;
  static constexpr SampleFormat kSampleFormatMpegHAudio =
    AudioDecoderConfig_SampleFormat_kSampleFormatMpegHAudio;
  static constexpr SampleFormat kSampleFormatPlanarU8 =
    AudioDecoderConfig_SampleFormat_kSampleFormatPlanarU8;
  static constexpr SampleFormat kSampleFormatDts =
    AudioDecoderConfig_SampleFormat_kSampleFormatDts;
  static constexpr SampleFormat kSampleFormatDtsxP2 =
    AudioDecoderConfig_SampleFormat_kSampleFormatDtsxP2;
  static inline bool SampleFormat_IsValid(int value) {
    return AudioDecoderConfig_SampleFormat_IsValid(value);
  }
  static constexpr SampleFormat SampleFormat_MIN =
    AudioDecoderConfig_SampleFormat_SampleFormat_MIN;
  static constexpr SampleFormat SampleFormat_MAX =
    AudioDecoderConfig_SampleFormat_SampleFormat_MAX;
  static constexpr int SampleFormat_ARRAYSIZE =
    AudioDecoderConfig_SampleFormat_SampleFormat_ARRAYSIZE;
  template<typename T>
  static inline const std::string& SampleFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SampleFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SampleFormat_Name.");
    return AudioDecoderConfig_SampleFormat_Name(enum_t_value);
  }
  static inline bool SampleFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SampleFormat* value) {
    return AudioDecoderConfig_SampleFormat_Parse(name, value);
  }

  typedef AudioDecoderConfig_ChannelLayout ChannelLayout;
  static constexpr ChannelLayout CHANNEL_LAYOUT_NONE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_NONE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_UNSUPPORTED =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_UNSUPPORTED;
  static constexpr ChannelLayout CHANNEL_LAYOUT_MONO =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_MONO;
  static constexpr ChannelLayout CHANNEL_LAYOUT_STEREO =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO;
  static constexpr ChannelLayout CHANNEL_LAYOUT_2_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_SURROUND =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_SURROUND;
  static constexpr ChannelLayout CHANNEL_LAYOUT_4_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_2_2 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2_2;
  static constexpr ChannelLayout CHANNEL_LAYOUT_QUAD =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_QUAD;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_0_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_0_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_5_1_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_5_1_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_1_WIDE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_STEREO_DOWNMIX =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_DOWNMIX;
  static constexpr ChannelLayout CHANNEL_LAYOUT_2POINT1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_2POINT1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_3_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_3_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_4_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_0 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_0_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_0_FRONT;
  static constexpr ChannelLayout CHANNEL_LAYOUT_HEXAGONAL =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_HEXAGONAL;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_1 =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_1_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_6_1_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_6_1_FRONT;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_0_FRONT =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_0_FRONT;
  static constexpr ChannelLayout CHANNEL_LAYOUT_7_1_WIDE_BACK =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_7_1_WIDE_BACK;
  static constexpr ChannelLayout CHANNEL_LAYOUT_OCTAGONAL =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_OCTAGONAL;
  static constexpr ChannelLayout CHANNEL_LAYOUT_DISCRETE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_DISCRETE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_STEREO_AND_KEYBOARD_MIC;
  static constexpr ChannelLayout CHANNEL_LAYOUT_4_1_QUAD_SIDE =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_4_1_QUAD_SIDE;
  static constexpr ChannelLayout CHANNEL_LAYOUT_BITSTREAM =
    AudioDecoderConfig_ChannelLayout_CHANNEL_LAYOUT_BITSTREAM;
  static inline bool ChannelLayout_IsValid(int value) {
    return AudioDecoderConfig_ChannelLayout_IsValid(value);
  }
  static constexpr ChannelLayout ChannelLayout_MIN =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_MIN;
  static constexpr ChannelLayout ChannelLayout_MAX =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_MAX;
  static constexpr int ChannelLayout_ARRAYSIZE =
    AudioDecoderConfig_ChannelLayout_ChannelLayout_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ChannelLayout_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChannelLayout>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChannelLayout_Name.");
    return AudioDecoderConfig_ChannelLayout_Name(enum_t_value);
  }
  static inline bool ChannelLayout_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChannelLayout* value) {
    return AudioDecoderConfig_ChannelLayout_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 8,
    kCodecFieldNumber = 1,
    kSampleFormatFieldNumber = 3,
    kChannelLayoutFieldNumber = 4,
    kSamplesPerSecondFieldNumber = 5,
    kSeekPrerollUsecFieldNumber = 6,
    kCodecDelayFieldNumber = 7,
  };
  // optional bytes extra_data = 8;
  bool has_extra_data() const;
  private:
  bool _internal_has_extra_data() const;
  public:
  void clear_extra_data();
  const std::string& extra_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_data();
  PROTOBUF_NODISCARD std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);
  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(const std::string& value);
  std::string* _internal_mutable_extra_data();
  public:

  // optional .openscreen.cast.AudioDecoderConfig.Codec codec = 1;
  bool has_codec() const;
  private:
  bool _internal_has_codec() const;
  public:
  void clear_codec();
  ::openscreen::cast::AudioDecoderConfig_Codec codec() const;
  void set_codec(::openscreen::cast::AudioDecoderConfig_Codec value);
  private:
  ::openscreen::cast::AudioDecoderConfig_Codec _internal_codec() const;
  void _internal_set_codec(::openscreen::cast::AudioDecoderConfig_Codec value);
  public:

  // optional .openscreen.cast.AudioDecoderConfig.SampleFormat sample_format = 3;
  bool has_sample_format() const;
  private:
  bool _internal_has_sample_format() const;
  public:
  void clear_sample_format();
  ::openscreen::cast::AudioDecoderConfig_SampleFormat sample_format() const;
  void set_sample_format(::openscreen::cast::AudioDecoderConfig_SampleFormat value);
  private:
  ::openscreen::cast::AudioDecoderConfig_SampleFormat _internal_sample_format() const;
  void _internal_set_sample_format(::openscreen::cast::AudioDecoderConfig_SampleFormat value);
  public:

  // optional .openscreen.cast.AudioDecoderConfig.ChannelLayout channel_layout = 4;
  bool has_channel_layout() const;
  private:
  bool _internal_has_channel_layout() const;
  public:
  void clear_channel_layout();
  ::openscreen::cast::AudioDecoderConfig_ChannelLayout channel_layout() const;
  void set_channel_layout(::openscreen::cast::AudioDecoderConfig_ChannelLayout value);
  private:
  ::openscreen::cast::AudioDecoderConfig_ChannelLayout _internal_channel_layout() const;
  void _internal_set_channel_layout(::openscreen::cast::AudioDecoderConfig_ChannelLayout value);
  public:

  // optional int32 samples_per_second = 5;
  bool has_samples_per_second() const;
  private:
  bool _internal_has_samples_per_second() const;
  public:
  void clear_samples_per_second();
  int32_t samples_per_second() const;
  void set_samples_per_second(int32_t value);
  private:
  int32_t _internal_samples_per_second() const;
  void _internal_set_samples_per_second(int32_t value);
  public:

  // optional int64 seek_preroll_usec = 6;
  bool has_seek_preroll_usec() const;
  private:
  bool _internal_has_seek_preroll_usec() const;
  public:
  void clear_seek_preroll_usec();
  int64_t seek_preroll_usec() const;
  void set_seek_preroll_usec(int64_t value);
  private:
  int64_t _internal_seek_preroll_usec() const;
  void _internal_set_seek_preroll_usec(int64_t value);
  public:

  // optional int32 codec_delay = 7;
  bool has_codec_delay() const;
  private:
  bool _internal_has_codec_delay() const;
  public:
  void clear_codec_delay();
  int32_t codec_delay() const;
  void set_codec_delay(int32_t value);
  private:
  int32_t _internal_codec_delay() const;
  void _internal_set_codec_delay(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.AudioDecoderConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
  int codec_;
  int sample_format_;
  int channel_layout_;
  int32_t samples_per_second_;
  int64_t seek_preroll_usec_;
  int32_t codec_delay_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.Rect) */ {
 public:
  inline Rect() : Rect(nullptr) {}
  ~Rect() override;
  explicit PROTOBUF_CONSTEXPR Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.Rect";
  }
  protected:
  explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // optional int32 x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  int32_t x() const;
  void set_x(int32_t value);
  private:
  int32_t _internal_x() const;
  void _internal_set_x(int32_t value);
  public:

  // optional int32 y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  int32_t y() const;
  void set_y(int32_t value);
  private:
  int32_t _internal_y() const;
  void _internal_set_y(int32_t value);
  public:

  // optional int32 width = 3;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 4;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t x_;
  int32_t y_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class VideoDecoderConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.VideoDecoderConfig) */ {
 public:
  inline VideoDecoderConfig() : VideoDecoderConfig(nullptr) {}
  ~VideoDecoderConfig() override;
  explicit PROTOBUF_CONSTEXPR VideoDecoderConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoDecoderConfig(const VideoDecoderConfig& from);
  VideoDecoderConfig(VideoDecoderConfig&& from) noexcept
    : VideoDecoderConfig() {
    *this = ::std::move(from);
  }

  inline VideoDecoderConfig& operator=(const VideoDecoderConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoDecoderConfig& operator=(VideoDecoderConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VideoDecoderConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoDecoderConfig* internal_default_instance() {
    return reinterpret_cast<const VideoDecoderConfig*>(
               &_VideoDecoderConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VideoDecoderConfig& a, VideoDecoderConfig& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VideoDecoderConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoDecoderConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoDecoderConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoDecoderConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoDecoderConfig& from);
  void MergeFrom(const VideoDecoderConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoDecoderConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.VideoDecoderConfig";
  }
  protected:
  explicit VideoDecoderConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef VideoDecoderConfig_Codec Codec;
  static constexpr Codec kUnknownVideoCodec =
    VideoDecoderConfig_Codec_kUnknownVideoCodec;
  static constexpr Codec kCodecH264 =
    VideoDecoderConfig_Codec_kCodecH264;
  static constexpr Codec kCodecVC1 =
    VideoDecoderConfig_Codec_kCodecVC1;
  static constexpr Codec kCodecMPEG2 =
    VideoDecoderConfig_Codec_kCodecMPEG2;
  static constexpr Codec kCodecMPEG4 =
    VideoDecoderConfig_Codec_kCodecMPEG4;
  static constexpr Codec kCodecTheora =
    VideoDecoderConfig_Codec_kCodecTheora;
  static constexpr Codec kCodecVP8 =
    VideoDecoderConfig_Codec_kCodecVP8;
  static constexpr Codec kCodecVP9 =
    VideoDecoderConfig_Codec_kCodecVP9;
  static constexpr Codec kCodecHEVC =
    VideoDecoderConfig_Codec_kCodecHEVC;
  static constexpr Codec kCodecDolbyVision =
    VideoDecoderConfig_Codec_kCodecDolbyVision;
  static constexpr Codec kCodecAV1 =
    VideoDecoderConfig_Codec_kCodecAV1;
  static inline bool Codec_IsValid(int value) {
    return VideoDecoderConfig_Codec_IsValid(value);
  }
  static constexpr Codec Codec_MIN =
    VideoDecoderConfig_Codec_Codec_MIN;
  static constexpr Codec Codec_MAX =
    VideoDecoderConfig_Codec_Codec_MAX;
  static constexpr int Codec_ARRAYSIZE =
    VideoDecoderConfig_Codec_Codec_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Codec_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Codec>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Codec_Name.");
    return VideoDecoderConfig_Codec_Name(enum_t_value);
  }
  static inline bool Codec_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Codec* value) {
    return VideoDecoderConfig_Codec_Parse(name, value);
  }

  typedef VideoDecoderConfig_Profile Profile;
  static constexpr Profile VIDEO_CODEC_PROFILE_UNKNOWN =
    VideoDecoderConfig_Profile_VIDEO_CODEC_PROFILE_UNKNOWN;
  static constexpr Profile H264PROFILE_BASELINE =
    VideoDecoderConfig_Profile_H264PROFILE_BASELINE;
  static constexpr Profile H264PROFILE_MAIN =
    VideoDecoderConfig_Profile_H264PROFILE_MAIN;
  static constexpr Profile H264PROFILE_EXTENDED =
    VideoDecoderConfig_Profile_H264PROFILE_EXTENDED;
  static constexpr Profile H264PROFILE_HIGH =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH;
  static constexpr Profile H264PROFILE_HIGH10PROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH10PROFILE;
  static constexpr Profile H264PROFILE_HIGH422PROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH422PROFILE;
  static constexpr Profile H264PROFILE_HIGH444PREDICTIVEPROFILE =
    VideoDecoderConfig_Profile_H264PROFILE_HIGH444PREDICTIVEPROFILE;
  static constexpr Profile H264PROFILE_SCALABLEBASELINE =
    VideoDecoderConfig_Profile_H264PROFILE_SCALABLEBASELINE;
  static constexpr Profile H264PROFILE_SCALABLEHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_SCALABLEHIGH;
  static constexpr Profile H264PROFILE_STEREOHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_STEREOHIGH;
  static constexpr Profile H264PROFILE_MULTIVIEWHIGH =
    VideoDecoderConfig_Profile_H264PROFILE_MULTIVIEWHIGH;
  static constexpr Profile VP8PROFILE_ANY =
    VideoDecoderConfig_Profile_VP8PROFILE_ANY;
  static constexpr Profile VP9PROFILE_PROFILE0 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE0;
  static constexpr Profile VP9PROFILE_PROFILE1 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE1;
  static constexpr Profile VP9PROFILE_PROFILE2 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE2;
  static constexpr Profile VP9PROFILE_PROFILE3 =
    VideoDecoderConfig_Profile_VP9PROFILE_PROFILE3;
  static constexpr Profile HEVCPROFILE_MAIN =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN;
  static constexpr Profile HEVCPROFILE_MAIN10 =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN10;
  static constexpr Profile HEVCPROFILE_MAIN_STILL_PICTURE =
    VideoDecoderConfig_Profile_HEVCPROFILE_MAIN_STILL_PICTURE;
  static constexpr Profile DOLBYVISION_PROFILE0 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE0;
  static constexpr Profile DOLBYVISION_PROFILE4 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE4;
  static constexpr Profile DOLBYVISION_PROFILE5 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE5;
  static constexpr Profile DOLBYVISION_PROFILE7 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE7;
  static constexpr Profile THEORAPROFILE_ANY =
    VideoDecoderConfig_Profile_THEORAPROFILE_ANY;
  static constexpr Profile AV1PROFILE_PROFILE_MAIN =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_MAIN;
  static constexpr Profile AV1PROFILE_PROFILE_HIGH =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_HIGH;
  static constexpr Profile AV1PROFILE_PROFILE_PRO =
    VideoDecoderConfig_Profile_AV1PROFILE_PROFILE_PRO;
  static constexpr Profile DOLBYVISION_PROFILE8 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE8;
  static constexpr Profile DOLBYVISION_PROFILE9 =
    VideoDecoderConfig_Profile_DOLBYVISION_PROFILE9;
  static constexpr Profile HEVCPROFILE_REXT =
    VideoDecoderConfig_Profile_HEVCPROFILE_REXT;
  static constexpr Profile HEVCPROFILE_HIGH_THROUGHPUT =
    VideoDecoderConfig_Profile_HEVCPROFILE_HIGH_THROUGHPUT;
  static constexpr Profile HEVCPROFILE_MULTIVIEW_MAIN =
    VideoDecoderConfig_Profile_HEVCPROFILE_MULTIVIEW_MAIN;
  static constexpr Profile HEVCPROFILE_SCALABLE_MAIN =
    VideoDecoderConfig_Profile_HEVCPROFILE_SCALABLE_MAIN;
  static constexpr Profile HEVCPROFILE_3D_MAIN =
    VideoDecoderConfig_Profile_HEVCPROFILE_3D_MAIN;
  static constexpr Profile HEVCPROFILE_SCREEN_EXTENDED =
    VideoDecoderConfig_Profile_HEVCPROFILE_SCREEN_EXTENDED;
  static constexpr Profile HEVCPROFILE_SCALABLE_REXT =
    VideoDecoderConfig_Profile_HEVCPROFILE_SCALABLE_REXT;
  static constexpr Profile HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED =
    VideoDecoderConfig_Profile_HEVCPROFILE_HIGH_THROUGHPUT_SCREEN_EXTENDED;
  static inline bool Profile_IsValid(int value) {
    return VideoDecoderConfig_Profile_IsValid(value);
  }
  static constexpr Profile Profile_MIN =
    VideoDecoderConfig_Profile_Profile_MIN;
  static constexpr Profile Profile_MAX =
    VideoDecoderConfig_Profile_Profile_MAX;
  static constexpr int Profile_ARRAYSIZE =
    VideoDecoderConfig_Profile_Profile_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Profile_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Profile>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Profile_Name.");
    return VideoDecoderConfig_Profile_Name(enum_t_value);
  }
  static inline bool Profile_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Profile* value) {
    return VideoDecoderConfig_Profile_Parse(name, value);
  }

  typedef VideoDecoderConfig_Format Format;
  static constexpr Format PIXEL_FORMAT_UNKNOWN =
    VideoDecoderConfig_Format_PIXEL_FORMAT_UNKNOWN;
  static constexpr Format PIXEL_FORMAT_I420 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I420;
  static constexpr Format PIXEL_FORMAT_YV12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YV12;
  static constexpr Format PIXEL_FORMAT_I422 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I422;
  static constexpr Format PIXEL_FORMAT_I420A =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I420A;
  static constexpr Format PIXEL_FORMAT_I444 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_I444;
  static constexpr Format PIXEL_FORMAT_NV12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_NV12;
  static constexpr Format PIXEL_FORMAT_NV21 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_NV21;
  static constexpr Format PIXEL_FORMAT_YUY2 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUY2;
  static constexpr Format PIXEL_FORMAT_ARGB =
    VideoDecoderConfig_Format_PIXEL_FORMAT_ARGB;
  static constexpr Format PIXEL_FORMAT_XRGB =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XRGB;
  static constexpr Format PIXEL_FORMAT_RGB24 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_RGB24;
  static constexpr Format PIXEL_FORMAT_RGB32 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_RGB32;
  static constexpr Format PIXEL_FORMAT_MJPEG =
    VideoDecoderConfig_Format_PIXEL_FORMAT_MJPEG;
  static constexpr Format PIXEL_FORMAT_YUV420P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P9;
  static constexpr Format PIXEL_FORMAT_YUV420P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P10;
  static constexpr Format PIXEL_FORMAT_YUV422P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P9;
  static constexpr Format PIXEL_FORMAT_YUV422P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P10;
  static constexpr Format PIXEL_FORMAT_YUV444P9 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P9;
  static constexpr Format PIXEL_FORMAT_YUV444P10 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P10;
  static constexpr Format PIXEL_FORMAT_YUV420P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV420P12;
  static constexpr Format PIXEL_FORMAT_YUV422P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV422P12;
  static constexpr Format PIXEL_FORMAT_YUV444P12 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_YUV444P12;
  static constexpr Format PIXEL_FORMAT_Y16 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_Y16;
  static constexpr Format PIXEL_FORMAT_ABGR =
    VideoDecoderConfig_Format_PIXEL_FORMAT_ABGR;
  static constexpr Format PIXEL_FORMAT_XBGR =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XBGR;
  static constexpr Format PIXEL_FORMAT_P016LE =
    VideoDecoderConfig_Format_PIXEL_FORMAT_P016LE;
  static constexpr Format PIXEL_FORMAT_XR30 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XR30;
  static constexpr Format PIXEL_FORMAT_XB30 =
    VideoDecoderConfig_Format_PIXEL_FORMAT_XB30;
  static inline bool Format_IsValid(int value) {
    return VideoDecoderConfig_Format_IsValid(value);
  }
  static constexpr Format Format_MIN =
    VideoDecoderConfig_Format_Format_MIN;
  static constexpr Format Format_MAX =
    VideoDecoderConfig_Format_Format_MAX;
  static constexpr int Format_ARRAYSIZE =
    VideoDecoderConfig_Format_Format_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Format_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Format>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Format_Name.");
    return VideoDecoderConfig_Format_Name(enum_t_value);
  }
  static inline bool Format_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Format* value) {
    return VideoDecoderConfig_Format_Parse(name, value);
  }

  typedef VideoDecoderConfig_ColorSpace ColorSpace;
  static constexpr ColorSpace COLOR_SPACE_UNSPECIFIED =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_UNSPECIFIED;
  static constexpr ColorSpace COLOR_SPACE_JPEG =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_JPEG;
  static constexpr ColorSpace COLOR_SPACE_HD_REC709 =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_HD_REC709;
  static constexpr ColorSpace COLOR_SPACE_SD_REC601 =
    VideoDecoderConfig_ColorSpace_COLOR_SPACE_SD_REC601;
  static inline bool ColorSpace_IsValid(int value) {
    return VideoDecoderConfig_ColorSpace_IsValid(value);
  }
  static constexpr ColorSpace ColorSpace_MIN =
    VideoDecoderConfig_ColorSpace_ColorSpace_MIN;
  static constexpr ColorSpace ColorSpace_MAX =
    VideoDecoderConfig_ColorSpace_ColorSpace_MAX;
  static constexpr int ColorSpace_ARRAYSIZE =
    VideoDecoderConfig_ColorSpace_ColorSpace_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ColorSpace_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ColorSpace>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ColorSpace_Name.");
    return VideoDecoderConfig_ColorSpace_Name(enum_t_value);
  }
  static inline bool ColorSpace_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ColorSpace* value) {
    return VideoDecoderConfig_ColorSpace_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExtraDataFieldNumber = 9,
    kCodedSizeFieldNumber = 6,
    kVisibleRectFieldNumber = 7,
    kNaturalSizeFieldNumber = 8,
    kCodecFieldNumber = 1,
    kFormatFieldNumber = 4,
    kColorSpaceFieldNumber = 5,
    kProfileFieldNumber = 3,
  };
  // optional bytes extra_data = 9;
  bool has_extra_data() const;
  private:
  bool _internal_has_extra_data() const;
  public:
  void clear_extra_data();
  const std::string& extra_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extra_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extra_data();
  PROTOBUF_NODISCARD std::string* release_extra_data();
  void set_allocated_extra_data(std::string* extra_data);
  private:
  const std::string& _internal_extra_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extra_data(const std::string& value);
  std::string* _internal_mutable_extra_data();
  public:

  // optional .openscreen.cast.Size coded_size = 6;
  bool has_coded_size() const;
  private:
  bool _internal_has_coded_size() const;
  public:
  void clear_coded_size();
  const ::openscreen::cast::Size& coded_size() const;
  PROTOBUF_NODISCARD ::openscreen::cast::Size* release_coded_size();
  ::openscreen::cast::Size* mutable_coded_size();
  void set_allocated_coded_size(::openscreen::cast::Size* coded_size);
  private:
  const ::openscreen::cast::Size& _internal_coded_size() const;
  ::openscreen::cast::Size* _internal_mutable_coded_size();
  public:
  void unsafe_arena_set_allocated_coded_size(
      ::openscreen::cast::Size* coded_size);
  ::openscreen::cast::Size* unsafe_arena_release_coded_size();

  // optional .openscreen.cast.Rect visible_rect = 7;
  bool has_visible_rect() const;
  private:
  bool _internal_has_visible_rect() const;
  public:
  void clear_visible_rect();
  const ::openscreen::cast::Rect& visible_rect() const;
  PROTOBUF_NODISCARD ::openscreen::cast::Rect* release_visible_rect();
  ::openscreen::cast::Rect* mutable_visible_rect();
  void set_allocated_visible_rect(::openscreen::cast::Rect* visible_rect);
  private:
  const ::openscreen::cast::Rect& _internal_visible_rect() const;
  ::openscreen::cast::Rect* _internal_mutable_visible_rect();
  public:
  void unsafe_arena_set_allocated_visible_rect(
      ::openscreen::cast::Rect* visible_rect);
  ::openscreen::cast::Rect* unsafe_arena_release_visible_rect();

  // optional .openscreen.cast.Size natural_size = 8;
  bool has_natural_size() const;
  private:
  bool _internal_has_natural_size() const;
  public:
  void clear_natural_size();
  const ::openscreen::cast::Size& natural_size() const;
  PROTOBUF_NODISCARD ::openscreen::cast::Size* release_natural_size();
  ::openscreen::cast::Size* mutable_natural_size();
  void set_allocated_natural_size(::openscreen::cast::Size* natural_size);
  private:
  const ::openscreen::cast::Size& _internal_natural_size() const;
  ::openscreen::cast::Size* _internal_mutable_natural_size();
  public:
  void unsafe_arena_set_allocated_natural_size(
      ::openscreen::cast::Size* natural_size);
  ::openscreen::cast::Size* unsafe_arena_release_natural_size();

  // optional .openscreen.cast.VideoDecoderConfig.Codec codec = 1;
  bool has_codec() const;
  private:
  bool _internal_has_codec() const;
  public:
  void clear_codec();
  ::openscreen::cast::VideoDecoderConfig_Codec codec() const;
  void set_codec(::openscreen::cast::VideoDecoderConfig_Codec value);
  private:
  ::openscreen::cast::VideoDecoderConfig_Codec _internal_codec() const;
  void _internal_set_codec(::openscreen::cast::VideoDecoderConfig_Codec value);
  public:

  // optional .openscreen.cast.VideoDecoderConfig.Format format = 4;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::openscreen::cast::VideoDecoderConfig_Format format() const;
  void set_format(::openscreen::cast::VideoDecoderConfig_Format value);
  private:
  ::openscreen::cast::VideoDecoderConfig_Format _internal_format() const;
  void _internal_set_format(::openscreen::cast::VideoDecoderConfig_Format value);
  public:

  // optional .openscreen.cast.VideoDecoderConfig.ColorSpace color_space = 5;
  bool has_color_space() const;
  private:
  bool _internal_has_color_space() const;
  public:
  void clear_color_space();
  ::openscreen::cast::VideoDecoderConfig_ColorSpace color_space() const;
  void set_color_space(::openscreen::cast::VideoDecoderConfig_ColorSpace value);
  private:
  ::openscreen::cast::VideoDecoderConfig_ColorSpace _internal_color_space() const;
  void _internal_set_color_space(::openscreen::cast::VideoDecoderConfig_ColorSpace value);
  public:

  // optional .openscreen.cast.VideoDecoderConfig.Profile profile = 3;
  bool has_profile() const;
  private:
  bool _internal_has_profile() const;
  public:
  void clear_profile();
  ::openscreen::cast::VideoDecoderConfig_Profile profile() const;
  void set_profile(::openscreen::cast::VideoDecoderConfig_Profile value);
  private:
  ::openscreen::cast::VideoDecoderConfig_Profile _internal_profile() const;
  void _internal_set_profile(::openscreen::cast::VideoDecoderConfig_Profile value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.VideoDecoderConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extra_data_;
  ::openscreen::cast::Size* coded_size_;
  ::openscreen::cast::Rect* visible_rect_;
  ::openscreen::cast::Size* natural_size_;
  int codec_;
  int format_;
  int color_space_;
  int profile_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class AudioDecoderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.AudioDecoderInfo) */ {
 public:
  inline AudioDecoderInfo() : AudioDecoderInfo(nullptr) {}
  ~AudioDecoderInfo() override;
  explicit PROTOBUF_CONSTEXPR AudioDecoderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AudioDecoderInfo(const AudioDecoderInfo& from);
  AudioDecoderInfo(AudioDecoderInfo&& from) noexcept
    : AudioDecoderInfo() {
    *this = ::std::move(from);
  }

  inline AudioDecoderInfo& operator=(const AudioDecoderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AudioDecoderInfo& operator=(AudioDecoderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AudioDecoderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AudioDecoderInfo* internal_default_instance() {
    return reinterpret_cast<const AudioDecoderInfo*>(
               &_AudioDecoderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AudioDecoderInfo& a, AudioDecoderInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AudioDecoderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AudioDecoderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AudioDecoderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AudioDecoderInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AudioDecoderInfo& from);
  void MergeFrom(const AudioDecoderInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AudioDecoderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.AudioDecoderInfo";
  }
  protected:
  explicit AudioDecoderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoderTypeFieldNumber = 1,
    kIsPlatformDecoderFieldNumber = 2,
  };
  // optional int64 decoder_type = 1;
  bool has_decoder_type() const;
  private:
  bool _internal_has_decoder_type() const;
  public:
  void clear_decoder_type();
  int64_t decoder_type() const;
  void set_decoder_type(int64_t value);
  private:
  int64_t _internal_decoder_type() const;
  void _internal_set_decoder_type(int64_t value);
  public:

  // optional bool is_platform_decoder = 2;
  bool has_is_platform_decoder() const;
  private:
  bool _internal_has_is_platform_decoder() const;
  public:
  void clear_is_platform_decoder();
  bool is_platform_decoder() const;
  void set_is_platform_decoder(bool value);
  private:
  bool _internal_is_platform_decoder() const;
  void _internal_set_is_platform_decoder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.AudioDecoderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t decoder_type_;
  bool is_platform_decoder_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class VideoDecoderInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.VideoDecoderInfo) */ {
 public:
  inline VideoDecoderInfo() : VideoDecoderInfo(nullptr) {}
  ~VideoDecoderInfo() override;
  explicit PROTOBUF_CONSTEXPR VideoDecoderInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VideoDecoderInfo(const VideoDecoderInfo& from);
  VideoDecoderInfo(VideoDecoderInfo&& from) noexcept
    : VideoDecoderInfo() {
    *this = ::std::move(from);
  }

  inline VideoDecoderInfo& operator=(const VideoDecoderInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline VideoDecoderInfo& operator=(VideoDecoderInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const VideoDecoderInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const VideoDecoderInfo* internal_default_instance() {
    return reinterpret_cast<const VideoDecoderInfo*>(
               &_VideoDecoderInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(VideoDecoderInfo& a, VideoDecoderInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(VideoDecoderInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VideoDecoderInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VideoDecoderInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VideoDecoderInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const VideoDecoderInfo& from);
  void MergeFrom(const VideoDecoderInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VideoDecoderInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.VideoDecoderInfo";
  }
  protected:
  explicit VideoDecoderInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDecoderTypeFieldNumber = 1,
    kIsPlatformDecoderFieldNumber = 2,
  };
  // optional int64 decoder_type = 1;
  bool has_decoder_type() const;
  private:
  bool _internal_has_decoder_type() const;
  public:
  void clear_decoder_type();
  int64_t decoder_type() const;
  void set_decoder_type(int64_t value);
  private:
  int64_t _internal_decoder_type() const;
  void _internal_set_decoder_type(int64_t value);
  public:

  // optional bool is_platform_decoder = 2;
  bool has_is_platform_decoder() const;
  private:
  bool _internal_has_is_platform_decoder() const;
  public:
  void clear_is_platform_decoder();
  bool is_platform_decoder() const;
  void set_is_platform_decoder(bool value);
  private:
  bool _internal_is_platform_decoder() const;
  void _internal_set_is_platform_decoder(bool value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.VideoDecoderInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t decoder_type_;
  bool is_platform_decoder_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class PipelineStatistics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.PipelineStatistics) */ {
 public:
  inline PipelineStatistics() : PipelineStatistics(nullptr) {}
  ~PipelineStatistics() override;
  explicit PROTOBUF_CONSTEXPR PipelineStatistics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PipelineStatistics(const PipelineStatistics& from);
  PipelineStatistics(PipelineStatistics&& from) noexcept
    : PipelineStatistics() {
    *this = ::std::move(from);
  }

  inline PipelineStatistics& operator=(const PipelineStatistics& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipelineStatistics& operator=(PipelineStatistics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PipelineStatistics& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipelineStatistics* internal_default_instance() {
    return reinterpret_cast<const PipelineStatistics*>(
               &_PipelineStatistics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PipelineStatistics& a, PipelineStatistics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PipelineStatistics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipelineStatistics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipelineStatistics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PipelineStatistics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PipelineStatistics& from);
  void MergeFrom(const PipelineStatistics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PipelineStatistics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.PipelineStatistics";
  }
  protected:
  explicit PipelineStatistics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderInfoFieldNumber = 8,
    kVideoDecoderInfoFieldNumber = 9,
    kAudioBytesDecodedFieldNumber = 1,
    kVideoBytesDecodedFieldNumber = 2,
    kVideoFramesDecodedFieldNumber = 3,
    kVideoFramesDroppedFieldNumber = 4,
    kAudioMemoryUsageFieldNumber = 5,
    kVideoMemoryUsageFieldNumber = 6,
    kVideoFrameDurationAverageUsecFieldNumber = 7,
  };
  // optional .openscreen.cast.AudioDecoderInfo audio_decoder_info = 8;
  bool has_audio_decoder_info() const;
  private:
  bool _internal_has_audio_decoder_info() const;
  public:
  void clear_audio_decoder_info();
  const ::openscreen::cast::AudioDecoderInfo& audio_decoder_info() const;
  PROTOBUF_NODISCARD ::openscreen::cast::AudioDecoderInfo* release_audio_decoder_info();
  ::openscreen::cast::AudioDecoderInfo* mutable_audio_decoder_info();
  void set_allocated_audio_decoder_info(::openscreen::cast::AudioDecoderInfo* audio_decoder_info);
  private:
  const ::openscreen::cast::AudioDecoderInfo& _internal_audio_decoder_info() const;
  ::openscreen::cast::AudioDecoderInfo* _internal_mutable_audio_decoder_info();
  public:
  void unsafe_arena_set_allocated_audio_decoder_info(
      ::openscreen::cast::AudioDecoderInfo* audio_decoder_info);
  ::openscreen::cast::AudioDecoderInfo* unsafe_arena_release_audio_decoder_info();

  // optional .openscreen.cast.VideoDecoderInfo video_decoder_info = 9;
  bool has_video_decoder_info() const;
  private:
  bool _internal_has_video_decoder_info() const;
  public:
  void clear_video_decoder_info();
  const ::openscreen::cast::VideoDecoderInfo& video_decoder_info() const;
  PROTOBUF_NODISCARD ::openscreen::cast::VideoDecoderInfo* release_video_decoder_info();
  ::openscreen::cast::VideoDecoderInfo* mutable_video_decoder_info();
  void set_allocated_video_decoder_info(::openscreen::cast::VideoDecoderInfo* video_decoder_info);
  private:
  const ::openscreen::cast::VideoDecoderInfo& _internal_video_decoder_info() const;
  ::openscreen::cast::VideoDecoderInfo* _internal_mutable_video_decoder_info();
  public:
  void unsafe_arena_set_allocated_video_decoder_info(
      ::openscreen::cast::VideoDecoderInfo* video_decoder_info);
  ::openscreen::cast::VideoDecoderInfo* unsafe_arena_release_video_decoder_info();

  // optional uint64 audio_bytes_decoded = 1;
  bool has_audio_bytes_decoded() const;
  private:
  bool _internal_has_audio_bytes_decoded() const;
  public:
  void clear_audio_bytes_decoded();
  uint64_t audio_bytes_decoded() const;
  void set_audio_bytes_decoded(uint64_t value);
  private:
  uint64_t _internal_audio_bytes_decoded() const;
  void _internal_set_audio_bytes_decoded(uint64_t value);
  public:

  // optional uint64 video_bytes_decoded = 2;
  bool has_video_bytes_decoded() const;
  private:
  bool _internal_has_video_bytes_decoded() const;
  public:
  void clear_video_bytes_decoded();
  uint64_t video_bytes_decoded() const;
  void set_video_bytes_decoded(uint64_t value);
  private:
  uint64_t _internal_video_bytes_decoded() const;
  void _internal_set_video_bytes_decoded(uint64_t value);
  public:

  // optional uint32 video_frames_decoded = 3;
  bool has_video_frames_decoded() const;
  private:
  bool _internal_has_video_frames_decoded() const;
  public:
  void clear_video_frames_decoded();
  uint32_t video_frames_decoded() const;
  void set_video_frames_decoded(uint32_t value);
  private:
  uint32_t _internal_video_frames_decoded() const;
  void _internal_set_video_frames_decoded(uint32_t value);
  public:

  // optional uint32 video_frames_dropped = 4;
  bool has_video_frames_dropped() const;
  private:
  bool _internal_has_video_frames_dropped() const;
  public:
  void clear_video_frames_dropped();
  uint32_t video_frames_dropped() const;
  void set_video_frames_dropped(uint32_t value);
  private:
  uint32_t _internal_video_frames_dropped() const;
  void _internal_set_video_frames_dropped(uint32_t value);
  public:

  // optional int64 audio_memory_usage = 5;
  bool has_audio_memory_usage() const;
  private:
  bool _internal_has_audio_memory_usage() const;
  public:
  void clear_audio_memory_usage();
  int64_t audio_memory_usage() const;
  void set_audio_memory_usage(int64_t value);
  private:
  int64_t _internal_audio_memory_usage() const;
  void _internal_set_audio_memory_usage(int64_t value);
  public:

  // optional int64 video_memory_usage = 6;
  bool has_video_memory_usage() const;
  private:
  bool _internal_has_video_memory_usage() const;
  public:
  void clear_video_memory_usage();
  int64_t video_memory_usage() const;
  void set_video_memory_usage(int64_t value);
  private:
  int64_t _internal_video_memory_usage() const;
  void _internal_set_video_memory_usage(int64_t value);
  public:

  // optional int64 video_frame_duration_average_usec = 7;
  bool has_video_frame_duration_average_usec() const;
  private:
  bool _internal_has_video_frame_duration_average_usec() const;
  public:
  void clear_video_frame_duration_average_usec();
  int64_t video_frame_duration_average_usec() const;
  void set_video_frame_duration_average_usec(int64_t value);
  private:
  int64_t _internal_video_frame_duration_average_usec() const;
  void _internal_set_video_frame_duration_average_usec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.PipelineStatistics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::openscreen::cast::AudioDecoderInfo* audio_decoder_info_;
  ::openscreen::cast::VideoDecoderInfo* video_decoder_info_;
  uint64_t audio_bytes_decoded_;
  uint64_t video_bytes_decoded_;
  uint32_t video_frames_decoded_;
  uint32_t video_frames_dropped_;
  int64_t audio_memory_usage_;
  int64_t video_memory_usage_;
  int64_t video_frame_duration_average_usec_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class AcquireDemuxer final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.AcquireDemuxer) */ {
 public:
  inline AcquireDemuxer() : AcquireDemuxer(nullptr) {}
  ~AcquireDemuxer() override;
  explicit PROTOBUF_CONSTEXPR AcquireDemuxer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AcquireDemuxer(const AcquireDemuxer& from);
  AcquireDemuxer(AcquireDemuxer&& from) noexcept
    : AcquireDemuxer() {
    *this = ::std::move(from);
  }

  inline AcquireDemuxer& operator=(const AcquireDemuxer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AcquireDemuxer& operator=(AcquireDemuxer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AcquireDemuxer& default_instance() {
    return *internal_default_instance();
  }
  static inline const AcquireDemuxer* internal_default_instance() {
    return reinterpret_cast<const AcquireDemuxer*>(
               &_AcquireDemuxer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AcquireDemuxer& a, AcquireDemuxer& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AcquireDemuxer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AcquireDemuxer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AcquireDemuxer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AcquireDemuxer>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AcquireDemuxer& from);
  void MergeFrom(const AcquireDemuxer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AcquireDemuxer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.AcquireDemuxer";
  }
  protected:
  explicit AcquireDemuxer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDemuxerHandleFieldNumber = 1,
    kVideoDemuxerHandleFieldNumber = 2,
  };
  // optional int32 audio_demuxer_handle = 1;
  bool has_audio_demuxer_handle() const;
  private:
  bool _internal_has_audio_demuxer_handle() const;
  public:
  void clear_audio_demuxer_handle();
  int32_t audio_demuxer_handle() const;
  void set_audio_demuxer_handle(int32_t value);
  private:
  int32_t _internal_audio_demuxer_handle() const;
  void _internal_set_audio_demuxer_handle(int32_t value);
  public:

  // optional int32 video_demuxer_handle = 2;
  bool has_video_demuxer_handle() const;
  private:
  bool _internal_has_video_demuxer_handle() const;
  public:
  void clear_video_demuxer_handle();
  int32_t video_demuxer_handle() const;
  void set_video_demuxer_handle(int32_t value);
  private:
  int32_t _internal_video_demuxer_handle() const;
  void _internal_set_video_demuxer_handle(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.AcquireDemuxer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t audio_demuxer_handle_;
  int32_t video_demuxer_handle_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RendererInitialize final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RendererInitialize) */ {
 public:
  inline RendererInitialize() : RendererInitialize(nullptr) {}
  ~RendererInitialize() override;
  explicit PROTOBUF_CONSTEXPR RendererInitialize(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendererInitialize(const RendererInitialize& from);
  RendererInitialize(RendererInitialize&& from) noexcept
    : RendererInitialize() {
    *this = ::std::move(from);
  }

  inline RendererInitialize& operator=(const RendererInitialize& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererInitialize& operator=(RendererInitialize&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RendererInitialize& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererInitialize* internal_default_instance() {
    return reinterpret_cast<const RendererInitialize*>(
               &_RendererInitialize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RendererInitialize& a, RendererInitialize& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RendererInitialize* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererInitialize* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererInitialize* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendererInitialize>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RendererInitialize& from);
  void MergeFrom(const RendererInitialize& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererInitialize* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RendererInitialize";
  }
  protected:
  explicit RendererInitialize(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientHandleFieldNumber = 1,
    kAudioDemuxerHandleFieldNumber = 2,
    kVideoDemuxerHandleFieldNumber = 3,
    kCallbackHandleFieldNumber = 4,
  };
  // optional int32 client_handle = 1;
  bool has_client_handle() const;
  private:
  bool _internal_has_client_handle() const;
  public:
  void clear_client_handle();
  int32_t client_handle() const;
  void set_client_handle(int32_t value);
  private:
  int32_t _internal_client_handle() const;
  void _internal_set_client_handle(int32_t value);
  public:

  // optional int32 audio_demuxer_handle = 2;
  bool has_audio_demuxer_handle() const;
  private:
  bool _internal_has_audio_demuxer_handle() const;
  public:
  void clear_audio_demuxer_handle();
  int32_t audio_demuxer_handle() const;
  void set_audio_demuxer_handle(int32_t value);
  private:
  int32_t _internal_audio_demuxer_handle() const;
  void _internal_set_audio_demuxer_handle(int32_t value);
  public:

  // optional int32 video_demuxer_handle = 3;
  bool has_video_demuxer_handle() const;
  private:
  bool _internal_has_video_demuxer_handle() const;
  public:
  void clear_video_demuxer_handle();
  int32_t video_demuxer_handle() const;
  void set_video_demuxer_handle(int32_t value);
  private:
  int32_t _internal_video_demuxer_handle() const;
  void _internal_set_video_demuxer_handle(int32_t value);
  public:

  // optional int32 callback_handle = 4;
  bool has_callback_handle() const;
  private:
  bool _internal_has_callback_handle() const;
  public:
  void clear_callback_handle();
  int32_t callback_handle() const;
  void set_callback_handle(int32_t value);
  private:
  int32_t _internal_callback_handle() const;
  void _internal_set_callback_handle(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.RendererInitialize)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t client_handle_;
  int32_t audio_demuxer_handle_;
  int32_t video_demuxer_handle_;
  int32_t callback_handle_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RendererFlushUntil final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RendererFlushUntil) */ {
 public:
  inline RendererFlushUntil() : RendererFlushUntil(nullptr) {}
  ~RendererFlushUntil() override;
  explicit PROTOBUF_CONSTEXPR RendererFlushUntil(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendererFlushUntil(const RendererFlushUntil& from);
  RendererFlushUntil(RendererFlushUntil&& from) noexcept
    : RendererFlushUntil() {
    *this = ::std::move(from);
  }

  inline RendererFlushUntil& operator=(const RendererFlushUntil& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererFlushUntil& operator=(RendererFlushUntil&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RendererFlushUntil& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererFlushUntil* internal_default_instance() {
    return reinterpret_cast<const RendererFlushUntil*>(
               &_RendererFlushUntil_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RendererFlushUntil& a, RendererFlushUntil& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RendererFlushUntil* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererFlushUntil* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererFlushUntil* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendererFlushUntil>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RendererFlushUntil& from);
  void MergeFrom(const RendererFlushUntil& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererFlushUntil* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RendererFlushUntil";
  }
  protected:
  explicit RendererFlushUntil(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioCountFieldNumber = 1,
    kVideoCountFieldNumber = 2,
    kCallbackHandleFieldNumber = 3,
  };
  // optional uint32 audio_count = 1;
  bool has_audio_count() const;
  private:
  bool _internal_has_audio_count() const;
  public:
  void clear_audio_count();
  uint32_t audio_count() const;
  void set_audio_count(uint32_t value);
  private:
  uint32_t _internal_audio_count() const;
  void _internal_set_audio_count(uint32_t value);
  public:

  // optional uint32 video_count = 2;
  bool has_video_count() const;
  private:
  bool _internal_has_video_count() const;
  public:
  void clear_video_count();
  uint32_t video_count() const;
  void set_video_count(uint32_t value);
  private:
  uint32_t _internal_video_count() const;
  void _internal_set_video_count(uint32_t value);
  public:

  // optional int32 callback_handle = 3;
  bool has_callback_handle() const;
  private:
  bool _internal_has_callback_handle() const;
  public:
  void clear_callback_handle();
  int32_t callback_handle() const;
  void set_callback_handle(int32_t value);
  private:
  int32_t _internal_callback_handle() const;
  void _internal_set_callback_handle(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.RendererFlushUntil)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t audio_count_;
  uint32_t video_count_;
  int32_t callback_handle_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnTimeUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RendererClientOnTimeUpdate) */ {
 public:
  inline RendererClientOnTimeUpdate() : RendererClientOnTimeUpdate(nullptr) {}
  ~RendererClientOnTimeUpdate() override;
  explicit PROTOBUF_CONSTEXPR RendererClientOnTimeUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendererClientOnTimeUpdate(const RendererClientOnTimeUpdate& from);
  RendererClientOnTimeUpdate(RendererClientOnTimeUpdate&& from) noexcept
    : RendererClientOnTimeUpdate() {
    *this = ::std::move(from);
  }

  inline RendererClientOnTimeUpdate& operator=(const RendererClientOnTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnTimeUpdate& operator=(RendererClientOnTimeUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RendererClientOnTimeUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererClientOnTimeUpdate* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnTimeUpdate*>(
               &_RendererClientOnTimeUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RendererClientOnTimeUpdate& a, RendererClientOnTimeUpdate& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RendererClientOnTimeUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererClientOnTimeUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererClientOnTimeUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendererClientOnTimeUpdate>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RendererClientOnTimeUpdate& from);
  void MergeFrom(const RendererClientOnTimeUpdate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnTimeUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RendererClientOnTimeUpdate";
  }
  protected:
  explicit RendererClientOnTimeUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeUsecFieldNumber = 1,
    kMaxTimeUsecFieldNumber = 2,
  };
  // optional int64 time_usec = 1;
  bool has_time_usec() const;
  private:
  bool _internal_has_time_usec() const;
  public:
  void clear_time_usec();
  int64_t time_usec() const;
  void set_time_usec(int64_t value);
  private:
  int64_t _internal_time_usec() const;
  void _internal_set_time_usec(int64_t value);
  public:

  // optional int64 max_time_usec = 2;
  bool has_max_time_usec() const;
  private:
  bool _internal_has_max_time_usec() const;
  public:
  void clear_max_time_usec();
  int64_t max_time_usec() const;
  void set_max_time_usec(int64_t value);
  private:
  int64_t _internal_max_time_usec() const;
  void _internal_set_max_time_usec(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.RendererClientOnTimeUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t time_usec_;
  int64_t max_time_usec_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnBufferingStateChange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RendererClientOnBufferingStateChange) */ {
 public:
  inline RendererClientOnBufferingStateChange() : RendererClientOnBufferingStateChange(nullptr) {}
  ~RendererClientOnBufferingStateChange() override;
  explicit PROTOBUF_CONSTEXPR RendererClientOnBufferingStateChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendererClientOnBufferingStateChange(const RendererClientOnBufferingStateChange& from);
  RendererClientOnBufferingStateChange(RendererClientOnBufferingStateChange&& from) noexcept
    : RendererClientOnBufferingStateChange() {
    *this = ::std::move(from);
  }

  inline RendererClientOnBufferingStateChange& operator=(const RendererClientOnBufferingStateChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnBufferingStateChange& operator=(RendererClientOnBufferingStateChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RendererClientOnBufferingStateChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererClientOnBufferingStateChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnBufferingStateChange*>(
               &_RendererClientOnBufferingStateChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(RendererClientOnBufferingStateChange& a, RendererClientOnBufferingStateChange& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RendererClientOnBufferingStateChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererClientOnBufferingStateChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererClientOnBufferingStateChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendererClientOnBufferingStateChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RendererClientOnBufferingStateChange& from);
  void MergeFrom(const RendererClientOnBufferingStateChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnBufferingStateChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RendererClientOnBufferingStateChange";
  }
  protected:
  explicit RendererClientOnBufferingStateChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RendererClientOnBufferingStateChange_State State;
  static constexpr State BUFFERING_HAVE_NOTHING =
    RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_NOTHING;
  static constexpr State BUFFERING_HAVE_ENOUGH =
    RendererClientOnBufferingStateChange_State_BUFFERING_HAVE_ENOUGH;
  static inline bool State_IsValid(int value) {
    return RendererClientOnBufferingStateChange_State_IsValid(value);
  }
  static constexpr State State_MIN =
    RendererClientOnBufferingStateChange_State_State_MIN;
  static constexpr State State_MAX =
    RendererClientOnBufferingStateChange_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    RendererClientOnBufferingStateChange_State_State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return RendererClientOnBufferingStateChange_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return RendererClientOnBufferingStateChange_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // optional .openscreen.cast.RendererClientOnBufferingStateChange.State state = 1;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  ::openscreen::cast::RendererClientOnBufferingStateChange_State state() const;
  void set_state(::openscreen::cast::RendererClientOnBufferingStateChange_State value);
  private:
  ::openscreen::cast::RendererClientOnBufferingStateChange_State _internal_state() const;
  void _internal_set_state(::openscreen::cast::RendererClientOnBufferingStateChange_State value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.RendererClientOnBufferingStateChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int state_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnAudioConfigChange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RendererClientOnAudioConfigChange) */ {
 public:
  inline RendererClientOnAudioConfigChange() : RendererClientOnAudioConfigChange(nullptr) {}
  ~RendererClientOnAudioConfigChange() override;
  explicit PROTOBUF_CONSTEXPR RendererClientOnAudioConfigChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendererClientOnAudioConfigChange(const RendererClientOnAudioConfigChange& from);
  RendererClientOnAudioConfigChange(RendererClientOnAudioConfigChange&& from) noexcept
    : RendererClientOnAudioConfigChange() {
    *this = ::std::move(from);
  }

  inline RendererClientOnAudioConfigChange& operator=(const RendererClientOnAudioConfigChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnAudioConfigChange& operator=(RendererClientOnAudioConfigChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RendererClientOnAudioConfigChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererClientOnAudioConfigChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnAudioConfigChange*>(
               &_RendererClientOnAudioConfigChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(RendererClientOnAudioConfigChange& a, RendererClientOnAudioConfigChange& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RendererClientOnAudioConfigChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererClientOnAudioConfigChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererClientOnAudioConfigChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendererClientOnAudioConfigChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RendererClientOnAudioConfigChange& from);
  void MergeFrom(const RendererClientOnAudioConfigChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnAudioConfigChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RendererClientOnAudioConfigChange";
  }
  protected:
  explicit RendererClientOnAudioConfigChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderConfigFieldNumber = 1,
  };
  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 1;
  bool has_audio_decoder_config() const;
  private:
  bool _internal_has_audio_decoder_config() const;
  public:
  void clear_audio_decoder_config();
  const ::openscreen::cast::AudioDecoderConfig& audio_decoder_config() const;
  PROTOBUF_NODISCARD ::openscreen::cast::AudioDecoderConfig* release_audio_decoder_config();
  ::openscreen::cast::AudioDecoderConfig* mutable_audio_decoder_config();
  void set_allocated_audio_decoder_config(::openscreen::cast::AudioDecoderConfig* audio_decoder_config);
  private:
  const ::openscreen::cast::AudioDecoderConfig& _internal_audio_decoder_config() const;
  ::openscreen::cast::AudioDecoderConfig* _internal_mutable_audio_decoder_config();
  public:
  void unsafe_arena_set_allocated_audio_decoder_config(
      ::openscreen::cast::AudioDecoderConfig* audio_decoder_config);
  ::openscreen::cast::AudioDecoderConfig* unsafe_arena_release_audio_decoder_config();

  // @@protoc_insertion_point(class_scope:openscreen.cast.RendererClientOnAudioConfigChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::openscreen::cast::AudioDecoderConfig* audio_decoder_config_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RendererClientOnVideoConfigChange final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RendererClientOnVideoConfigChange) */ {
 public:
  inline RendererClientOnVideoConfigChange() : RendererClientOnVideoConfigChange(nullptr) {}
  ~RendererClientOnVideoConfigChange() override;
  explicit PROTOBUF_CONSTEXPR RendererClientOnVideoConfigChange(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RendererClientOnVideoConfigChange(const RendererClientOnVideoConfigChange& from);
  RendererClientOnVideoConfigChange(RendererClientOnVideoConfigChange&& from) noexcept
    : RendererClientOnVideoConfigChange() {
    *this = ::std::move(from);
  }

  inline RendererClientOnVideoConfigChange& operator=(const RendererClientOnVideoConfigChange& from) {
    CopyFrom(from);
    return *this;
  }
  inline RendererClientOnVideoConfigChange& operator=(RendererClientOnVideoConfigChange&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RendererClientOnVideoConfigChange& default_instance() {
    return *internal_default_instance();
  }
  static inline const RendererClientOnVideoConfigChange* internal_default_instance() {
    return reinterpret_cast<const RendererClientOnVideoConfigChange*>(
               &_RendererClientOnVideoConfigChange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RendererClientOnVideoConfigChange& a, RendererClientOnVideoConfigChange& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RendererClientOnVideoConfigChange* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RendererClientOnVideoConfigChange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RendererClientOnVideoConfigChange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RendererClientOnVideoConfigChange>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RendererClientOnVideoConfigChange& from);
  void MergeFrom(const RendererClientOnVideoConfigChange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RendererClientOnVideoConfigChange* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RendererClientOnVideoConfigChange";
  }
  protected:
  explicit RendererClientOnVideoConfigChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoDecoderConfigFieldNumber = 1,
  };
  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 1;
  bool has_video_decoder_config() const;
  private:
  bool _internal_has_video_decoder_config() const;
  public:
  void clear_video_decoder_config();
  const ::openscreen::cast::VideoDecoderConfig& video_decoder_config() const;
  PROTOBUF_NODISCARD ::openscreen::cast::VideoDecoderConfig* release_video_decoder_config();
  ::openscreen::cast::VideoDecoderConfig* mutable_video_decoder_config();
  void set_allocated_video_decoder_config(::openscreen::cast::VideoDecoderConfig* video_decoder_config);
  private:
  const ::openscreen::cast::VideoDecoderConfig& _internal_video_decoder_config() const;
  ::openscreen::cast::VideoDecoderConfig* _internal_mutable_video_decoder_config();
  public:
  void unsafe_arena_set_allocated_video_decoder_config(
      ::openscreen::cast::VideoDecoderConfig* video_decoder_config);
  ::openscreen::cast::VideoDecoderConfig* unsafe_arena_release_video_decoder_config();

  // @@protoc_insertion_point(class_scope:openscreen.cast.RendererClientOnVideoConfigChange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::openscreen::cast::VideoDecoderConfig* video_decoder_config_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class DemuxerStreamReadUntil final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.DemuxerStreamReadUntil) */ {
 public:
  inline DemuxerStreamReadUntil() : DemuxerStreamReadUntil(nullptr) {}
  ~DemuxerStreamReadUntil() override;
  explicit PROTOBUF_CONSTEXPR DemuxerStreamReadUntil(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DemuxerStreamReadUntil(const DemuxerStreamReadUntil& from);
  DemuxerStreamReadUntil(DemuxerStreamReadUntil&& from) noexcept
    : DemuxerStreamReadUntil() {
    *this = ::std::move(from);
  }

  inline DemuxerStreamReadUntil& operator=(const DemuxerStreamReadUntil& from) {
    CopyFrom(from);
    return *this;
  }
  inline DemuxerStreamReadUntil& operator=(DemuxerStreamReadUntil&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DemuxerStreamReadUntil& default_instance() {
    return *internal_default_instance();
  }
  static inline const DemuxerStreamReadUntil* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamReadUntil*>(
               &_DemuxerStreamReadUntil_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DemuxerStreamReadUntil& a, DemuxerStreamReadUntil& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DemuxerStreamReadUntil* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DemuxerStreamReadUntil* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DemuxerStreamReadUntil* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DemuxerStreamReadUntil>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DemuxerStreamReadUntil& from);
  void MergeFrom(const DemuxerStreamReadUntil& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamReadUntil* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.DemuxerStreamReadUntil";
  }
  protected:
  explicit DemuxerStreamReadUntil(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCallbackHandleFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional int32 callback_handle = 1;
  bool has_callback_handle() const;
  private:
  bool _internal_has_callback_handle() const;
  public:
  void clear_callback_handle();
  int32_t callback_handle() const;
  void set_callback_handle(int32_t value);
  private:
  int32_t _internal_callback_handle() const;
  void _internal_set_callback_handle(int32_t value);
  public:

  // optional uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.DemuxerStreamReadUntil)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t callback_handle_;
  uint32_t count_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class DemuxerStreamInitializeCallback final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.DemuxerStreamInitializeCallback) */ {
 public:
  inline DemuxerStreamInitializeCallback() : DemuxerStreamInitializeCallback(nullptr) {}
  ~DemuxerStreamInitializeCallback() override;
  explicit PROTOBUF_CONSTEXPR DemuxerStreamInitializeCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DemuxerStreamInitializeCallback(const DemuxerStreamInitializeCallback& from);
  DemuxerStreamInitializeCallback(DemuxerStreamInitializeCallback&& from) noexcept
    : DemuxerStreamInitializeCallback() {
    *this = ::std::move(from);
  }

  inline DemuxerStreamInitializeCallback& operator=(const DemuxerStreamInitializeCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DemuxerStreamInitializeCallback& operator=(DemuxerStreamInitializeCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DemuxerStreamInitializeCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const DemuxerStreamInitializeCallback* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamInitializeCallback*>(
               &_DemuxerStreamInitializeCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(DemuxerStreamInitializeCallback& a, DemuxerStreamInitializeCallback& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DemuxerStreamInitializeCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DemuxerStreamInitializeCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DemuxerStreamInitializeCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DemuxerStreamInitializeCallback>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DemuxerStreamInitializeCallback& from);
  void MergeFrom(const DemuxerStreamInitializeCallback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamInitializeCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.DemuxerStreamInitializeCallback";
  }
  protected:
  explicit DemuxerStreamInitializeCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderConfigFieldNumber = 2,
    kVideoDecoderConfigFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 2;
  bool has_audio_decoder_config() const;
  private:
  bool _internal_has_audio_decoder_config() const;
  public:
  void clear_audio_decoder_config();
  const ::openscreen::cast::AudioDecoderConfig& audio_decoder_config() const;
  PROTOBUF_NODISCARD ::openscreen::cast::AudioDecoderConfig* release_audio_decoder_config();
  ::openscreen::cast::AudioDecoderConfig* mutable_audio_decoder_config();
  void set_allocated_audio_decoder_config(::openscreen::cast::AudioDecoderConfig* audio_decoder_config);
  private:
  const ::openscreen::cast::AudioDecoderConfig& _internal_audio_decoder_config() const;
  ::openscreen::cast::AudioDecoderConfig* _internal_mutable_audio_decoder_config();
  public:
  void unsafe_arena_set_allocated_audio_decoder_config(
      ::openscreen::cast::AudioDecoderConfig* audio_decoder_config);
  ::openscreen::cast::AudioDecoderConfig* unsafe_arena_release_audio_decoder_config();

  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 3;
  bool has_video_decoder_config() const;
  private:
  bool _internal_has_video_decoder_config() const;
  public:
  void clear_video_decoder_config();
  const ::openscreen::cast::VideoDecoderConfig& video_decoder_config() const;
  PROTOBUF_NODISCARD ::openscreen::cast::VideoDecoderConfig* release_video_decoder_config();
  ::openscreen::cast::VideoDecoderConfig* mutable_video_decoder_config();
  void set_allocated_video_decoder_config(::openscreen::cast::VideoDecoderConfig* video_decoder_config);
  private:
  const ::openscreen::cast::VideoDecoderConfig& _internal_video_decoder_config() const;
  ::openscreen::cast::VideoDecoderConfig* _internal_mutable_video_decoder_config();
  public:
  void unsafe_arena_set_allocated_video_decoder_config(
      ::openscreen::cast::VideoDecoderConfig* video_decoder_config);
  ::openscreen::cast::VideoDecoderConfig* unsafe_arena_release_video_decoder_config();

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.DemuxerStreamInitializeCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::openscreen::cast::AudioDecoderConfig* audio_decoder_config_;
  ::openscreen::cast::VideoDecoderConfig* video_decoder_config_;
  int32_t type_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class DemuxerStreamReadUntilCallback final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.DemuxerStreamReadUntilCallback) */ {
 public:
  inline DemuxerStreamReadUntilCallback() : DemuxerStreamReadUntilCallback(nullptr) {}
  ~DemuxerStreamReadUntilCallback() override;
  explicit PROTOBUF_CONSTEXPR DemuxerStreamReadUntilCallback(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DemuxerStreamReadUntilCallback(const DemuxerStreamReadUntilCallback& from);
  DemuxerStreamReadUntilCallback(DemuxerStreamReadUntilCallback&& from) noexcept
    : DemuxerStreamReadUntilCallback() {
    *this = ::std::move(from);
  }

  inline DemuxerStreamReadUntilCallback& operator=(const DemuxerStreamReadUntilCallback& from) {
    CopyFrom(from);
    return *this;
  }
  inline DemuxerStreamReadUntilCallback& operator=(DemuxerStreamReadUntilCallback&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DemuxerStreamReadUntilCallback& default_instance() {
    return *internal_default_instance();
  }
  static inline const DemuxerStreamReadUntilCallback* internal_default_instance() {
    return reinterpret_cast<const DemuxerStreamReadUntilCallback*>(
               &_DemuxerStreamReadUntilCallback_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DemuxerStreamReadUntilCallback& a, DemuxerStreamReadUntilCallback& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DemuxerStreamReadUntilCallback* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DemuxerStreamReadUntilCallback* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DemuxerStreamReadUntilCallback* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DemuxerStreamReadUntilCallback>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DemuxerStreamReadUntilCallback& from);
  void MergeFrom(const DemuxerStreamReadUntilCallback& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DemuxerStreamReadUntilCallback* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.DemuxerStreamReadUntilCallback";
  }
  protected:
  explicit DemuxerStreamReadUntilCallback(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DemuxerStreamReadUntilCallback_Status Status;
  static constexpr Status kOk =
    DemuxerStreamReadUntilCallback_Status_kOk;
  static constexpr Status kAborted =
    DemuxerStreamReadUntilCallback_Status_kAborted;
  static constexpr Status kConfigChanged =
    DemuxerStreamReadUntilCallback_Status_kConfigChanged;
  static constexpr Status kError =
    DemuxerStreamReadUntilCallback_Status_kError;
  static inline bool Status_IsValid(int value) {
    return DemuxerStreamReadUntilCallback_Status_IsValid(value);
  }
  static constexpr Status Status_MIN =
    DemuxerStreamReadUntilCallback_Status_Status_MIN;
  static constexpr Status Status_MAX =
    DemuxerStreamReadUntilCallback_Status_Status_MAX;
  static constexpr int Status_ARRAYSIZE =
    DemuxerStreamReadUntilCallback_Status_Status_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Status_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Status>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Status_Name.");
    return DemuxerStreamReadUntilCallback_Status_Name(enum_t_value);
  }
  static inline bool Status_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Status* value) {
    return DemuxerStreamReadUntilCallback_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAudioDecoderConfigFieldNumber = 3,
    kVideoDecoderConfigFieldNumber = 4,
    kStatusFieldNumber = 1,
    kCountFieldNumber = 2,
  };
  // optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 3;
  bool has_audio_decoder_config() const;
  private:
  bool _internal_has_audio_decoder_config() const;
  public:
  void clear_audio_decoder_config();
  const ::openscreen::cast::AudioDecoderConfig& audio_decoder_config() const;
  PROTOBUF_NODISCARD ::openscreen::cast::AudioDecoderConfig* release_audio_decoder_config();
  ::openscreen::cast::AudioDecoderConfig* mutable_audio_decoder_config();
  void set_allocated_audio_decoder_config(::openscreen::cast::AudioDecoderConfig* audio_decoder_config);
  private:
  const ::openscreen::cast::AudioDecoderConfig& _internal_audio_decoder_config() const;
  ::openscreen::cast::AudioDecoderConfig* _internal_mutable_audio_decoder_config();
  public:
  void unsafe_arena_set_allocated_audio_decoder_config(
      ::openscreen::cast::AudioDecoderConfig* audio_decoder_config);
  ::openscreen::cast::AudioDecoderConfig* unsafe_arena_release_audio_decoder_config();

  // optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 4;
  bool has_video_decoder_config() const;
  private:
  bool _internal_has_video_decoder_config() const;
  public:
  void clear_video_decoder_config();
  const ::openscreen::cast::VideoDecoderConfig& video_decoder_config() const;
  PROTOBUF_NODISCARD ::openscreen::cast::VideoDecoderConfig* release_video_decoder_config();
  ::openscreen::cast::VideoDecoderConfig* mutable_video_decoder_config();
  void set_allocated_video_decoder_config(::openscreen::cast::VideoDecoderConfig* video_decoder_config);
  private:
  const ::openscreen::cast::VideoDecoderConfig& _internal_video_decoder_config() const;
  ::openscreen::cast::VideoDecoderConfig* _internal_mutable_video_decoder_config();
  public:
  void unsafe_arena_set_allocated_video_decoder_config(
      ::openscreen::cast::VideoDecoderConfig* video_decoder_config);
  ::openscreen::cast::VideoDecoderConfig* unsafe_arena_release_video_decoder_config();

  // optional .openscreen.cast.DemuxerStreamReadUntilCallback.Status status = 1;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  ::openscreen::cast::DemuxerStreamReadUntilCallback_Status status() const;
  void set_status(::openscreen::cast::DemuxerStreamReadUntilCallback_Status value);
  private:
  ::openscreen::cast::DemuxerStreamReadUntilCallback_Status _internal_status() const;
  void _internal_set_status(::openscreen::cast::DemuxerStreamReadUntilCallback_Status value);
  public:

  // optional uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:openscreen.cast.DemuxerStreamReadUntilCallback)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::openscreen::cast::AudioDecoderConfig* audio_decoder_config_;
  ::openscreen::cast::VideoDecoderConfig* video_decoder_config_;
  int status_;
  uint32_t count_;
  friend struct ::TableStruct_remoting_2eproto;
};
// -------------------------------------------------------------------

class RpcMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:openscreen.cast.RpcMessage) */ {
 public:
  inline RpcMessage() : RpcMessage(nullptr) {}
  ~RpcMessage() override;
  explicit PROTOBUF_CONSTEXPR RpcMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RpcMessage(const RpcMessage& from);
  RpcMessage(RpcMessage&& from) noexcept
    : RpcMessage() {
    *this = ::std::move(from);
  }

  inline RpcMessage& operator=(const RpcMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline RpcMessage& operator=(RpcMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const RpcMessage& default_instance() {
    return *internal_default_instance();
  }
  enum RpcOneofCase {
    kIntegerValue = 3,
    kInteger64Value = 4,
    kDoubleValue = 5,
    kBooleanValue = 6,
    kStringValue = 7,
    kRendererInitializeRpc = 100,
    kRendererFlushuntilRpc = 101,
    kAcquireDemuxerRpc = 103,
    kRendererclientOntimeupdateRpc = 200,
    kRendererclientOnvideonatualsizechangeRpc = 201,
    kRendererclientOnstatisticsupdateRpc = 202,
    kRendererclientOnbufferingstatechangeRpc = 203,
    kRendererclientOnaudioconfigchangeRpc = 204,
    kRendererclientOnvideoconfigchangeRpc = 205,
    kDemuxerstreamReaduntilRpc = 300,
    kDemuxerstreamInitializecbRpc = 400,
    kDemuxerstreamReaduntilcbRpc = 401,
    RPC_ONEOF_NOT_SET = 0,
  };

  static inline const RpcMessage* internal_default_instance() {
    return reinterpret_cast<const RpcMessage*>(
               &_RpcMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RpcMessage& a, RpcMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RpcMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RpcMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RpcMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RpcMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RpcMessage& from);
  void MergeFrom(const RpcMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RpcMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "openscreen.cast.RpcMessage";
  }
  protected:
  explicit RpcMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RpcMessage_RpcProc RpcProc;
  static constexpr RpcProc RPC_INTERNAL =
    RpcMessage_RpcProc_RPC_INTERNAL;
  static constexpr RpcProc RPC_ACQUIRE_RENDERER =
    RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER;
  static constexpr RpcProc RPC_ACQUIRE_DEMUXER =
    RpcMessage_RpcProc_RPC_ACQUIRE_DEMUXER;
  static constexpr RpcProc RPC_ACQUIRE_RENDERER_DONE =
    RpcMessage_RpcProc_RPC_ACQUIRE_RENDERER_DONE;
  static constexpr RpcProc RPC_R_INITIALIZE =
    RpcMessage_RpcProc_RPC_R_INITIALIZE;
  static constexpr RpcProc RPC_R_FLUSHUNTIL =
    RpcMessage_RpcProc_RPC_R_FLUSHUNTIL;
  static constexpr RpcProc RPC_R_STARTPLAYINGFROM =
    RpcMessage_RpcProc_RPC_R_STARTPLAYINGFROM;
  static constexpr RpcProc RPC_R_SETPLAYBACKRATE =
    RpcMessage_RpcProc_RPC_R_SETPLAYBACKRATE;
  static constexpr RpcProc RPC_R_SETVOLUME =
    RpcMessage_RpcProc_RPC_R_SETVOLUME;
  static constexpr RpcProc RPC_R_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_R_INITIALIZE_CALLBACK;
  static constexpr RpcProc RPC_R_FLUSHUNTIL_CALLBACK =
    RpcMessage_RpcProc_RPC_R_FLUSHUNTIL_CALLBACK;
  static constexpr RpcProc RPC_R_SETCDM_CALLBACK =
    RpcMessage_RpcProc_RPC_R_SETCDM_CALLBACK;
  static constexpr RpcProc RPC_RC_ONTIMEUPDATE =
    RpcMessage_RpcProc_RPC_RC_ONTIMEUPDATE;
  static constexpr RpcProc RPC_RC_ONBUFFERINGSTATECHANGE =
    RpcMessage_RpcProc_RPC_RC_ONBUFFERINGSTATECHANGE;
  static constexpr RpcProc RPC_RC_ONENDED =
    RpcMessage_RpcProc_RPC_RC_ONENDED;
  static constexpr RpcProc RPC_RC_ONERROR =
    RpcMessage_RpcProc_RPC_RC_ONERROR;
  static constexpr RpcProc RPC_RC_ONVIDEONATURALSIZECHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEONATURALSIZECHANGE;
  static constexpr RpcProc RPC_RC_ONVIDEOOPACITYCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEOOPACITYCHANGE;
  static constexpr RpcProc RPC_RC_ONSTATISTICSUPDATE =
    RpcMessage_RpcProc_RPC_RC_ONSTATISTICSUPDATE;
  static constexpr RpcProc RPC_RC_ONAUDIOCONFIGCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONAUDIOCONFIGCHANGE;
  static constexpr RpcProc RPC_RC_ONVIDEOCONFIGCHANGE =
    RpcMessage_RpcProc_RPC_RC_ONVIDEOCONFIGCHANGE;
  static constexpr RpcProc RPC_DS_INITIALIZE =
    RpcMessage_RpcProc_RPC_DS_INITIALIZE;
  static constexpr RpcProc RPC_DS_READUNTIL =
    RpcMessage_RpcProc_RPC_DS_READUNTIL;
  static constexpr RpcProc RPC_DS_ENABLEBITSTREAMCONVERTER =
    RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER;
  static constexpr RpcProc RPC_DS_ONERROR =
    RpcMessage_RpcProc_RPC_DS_ONERROR;
  static constexpr RpcProc RPC_DS_INITIALIZE_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_INITIALIZE_CALLBACK;
  static constexpr RpcProc RPC_DS_READUNTIL_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_READUNTIL_CALLBACK;
  static constexpr RpcProc RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK =
    RpcMessage_RpcProc_RPC_DS_ENABLEBITSTREAMCONVERTER_CALLBACK;
  static inline bool RpcProc_IsValid(int value) {
    return RpcMessage_RpcProc_IsValid(value);
  }
  static constexpr RpcProc RpcProc_MIN =
    RpcMessage_RpcProc_RpcProc_MIN;
  static constexpr RpcProc RpcProc_MAX =
    RpcMessage_RpcProc_RpcProc_MAX;
  static constexpr int RpcProc_ARRAYSIZE =
    RpcMessage_RpcProc_RpcProc_ARRAYSIZE;
  template<typename T>
  static inline const std::string& RpcProc_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RpcProc>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RpcProc_Name.");
    return RpcMessage_RpcProc_Name(enum_t_value);
  }
  static inline bool RpcProc_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RpcProc* value) {
    return RpcMessage_RpcProc_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kProcFieldNumber = 2,
    kIntegerValueFieldNumber = 3,
    kInteger64ValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kBooleanValueFieldNumber = 6,
    kStringValueFieldNumber = 7,
    kRendererInitializeRpcFieldNumber = 100,
    kRendererFlushuntilRpcFieldNumber = 101,
    kAcquireDemuxerRpcFieldNumber = 103,
    kRendererclientOntimeupdateRpcFieldNumber = 200,
    kRendererclientOnvideonatualsizechangeRpcFieldNumber = 201,
    kRendererclientOnstatisticsupdateRpcFieldNumber = 202,
    kRendererclientOnbufferingstatechangeRpcFieldNumber = 203,
    kRendererclientOnaudioconfigchangeRpcFieldNumber = 204,
    kRendererclientOnvideoconfigchangeRpcFieldNumber = 205,
    kDemuxerstreamReaduntilRpcFieldNumber = 300,
    kDemuxerstreamInitializecbRpcFieldNumber = 400,
    kDemuxerstreamReaduntilcbRpcFieldNumber = 401,
  };
  // optional int32 handle = 1;
  bool has_handle() const;
  private:
  bool _internal_has_handle() const;
  public:
  void clear_handle();
  int32_t handle() const;
  void set_handle(int32_t value);
  private:
  int32_t _internal_handle() const;
  void _internal_set_handle(int32_t value);
  public:

  // optional .openscreen.cast.RpcMessage.RpcProc proc = 2;
  bool has_proc() const;
  private:
  bool _internal_has_proc() const;
  public:
  void clear_proc();
  ::openscreen::cast::RpcMessage_RpcProc proc() const;
  void set_proc(::openscreen::cast::RpcMessage_RpcProc value);
  private:
  ::openscreen::cast::RpcMessage_RpcProc _internal_proc() const;
  void _internal_set_proc(::openscreen::cast::RpcMessage_RpcProc value);
  public:

  // int32 integer_value = 3;
  bool has_integer_value() const;
  private:
  bool _internal_has_integer_value() const;
  public:
  void clear_integer_value();
  int32_t integer_value() const;
  void set_integer_value(int32_t value);
  private:
  int32_t _internal_integer_value() const;
  void _internal_set_integer_value(int32_t value);
  public:

  // int64 integer64_value = 4;
  bool has_integer64_value() const;
  private:
  bool _internal_has_integer64_value() const;
  public:
  void clear_integer64_value();
  int64_t integer64_value() const;
  void set_integer64_value(int64_t value);
  private:
  int64_t _internal_integer64_value() const;
  void _internal_set_integer64_value(int64_t value);
  public:

  // double double_value = 5;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // bool boolean_value = 6;
  bool has_boolean_value() const;
  private:
  bool _internal_has_boolean_value() const;
  public:
  void clear_boolean_value();
  bool boolean_value() const;
  void set_boolean_value(bool value);
  private:
  bool _internal_boolean_value() const;
  void _internal_set_boolean_value(bool value);
  public:

  // string string_value = 7;
  bool has_string_value() const;
  private:
  bool _internal_has_string_value() const;
  public:
  void clear_string_value();
  const std::string& string_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_string_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_string_value();
  PROTOBUF_NODISCARD std::string* release_string_value();
  void set_allocated_string_value(std::string* string_value);
  private:
  const std::string& _internal_string_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_string_value(const std::string& value);
  std::string* _internal_mutable_string_value();
  public:

  // .openscreen.cast.RendererInitialize renderer_initialize_rpc = 100;
  bool has_renderer_initialize_rpc() const;
  private:
  bool _internal_has_renderer_initialize_rpc() const;
  public:
  void clear_renderer_initialize_rpc();
  const ::openscreen::cast::RendererInitialize& renderer_initialize_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::RendererInitialize* release_renderer_initialize_rpc();
  ::openscreen::cast::RendererInitialize* mutable_renderer_initialize_rpc();
  void set_allocated_renderer_initialize_rpc(::openscreen::cast::RendererInitialize* renderer_initialize_rpc);
  private:
  const ::openscreen::cast::RendererInitialize& _internal_renderer_initialize_rpc() const;
  ::openscreen::cast::RendererInitialize* _internal_mutable_renderer_initialize_rpc();
  public:
  void unsafe_arena_set_allocated_renderer_initialize_rpc(
      ::openscreen::cast::RendererInitialize* renderer_initialize_rpc);
  ::openscreen::cast::RendererInitialize* unsafe_arena_release_renderer_initialize_rpc();

  // .openscreen.cast.RendererFlushUntil renderer_flushuntil_rpc = 101;
  bool has_renderer_flushuntil_rpc() const;
  private:
  bool _internal_has_renderer_flushuntil_rpc() const;
  public:
  void clear_renderer_flushuntil_rpc();
  const ::openscreen::cast::RendererFlushUntil& renderer_flushuntil_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::RendererFlushUntil* release_renderer_flushuntil_rpc();
  ::openscreen::cast::RendererFlushUntil* mutable_renderer_flushuntil_rpc();
  void set_allocated_renderer_flushuntil_rpc(::openscreen::cast::RendererFlushUntil* renderer_flushuntil_rpc);
  private:
  const ::openscreen::cast::RendererFlushUntil& _internal_renderer_flushuntil_rpc() const;
  ::openscreen::cast::RendererFlushUntil* _internal_mutable_renderer_flushuntil_rpc();
  public:
  void unsafe_arena_set_allocated_renderer_flushuntil_rpc(
      ::openscreen::cast::RendererFlushUntil* renderer_flushuntil_rpc);
  ::openscreen::cast::RendererFlushUntil* unsafe_arena_release_renderer_flushuntil_rpc();

  // .openscreen.cast.AcquireDemuxer acquire_demuxer_rpc = 103;
  bool has_acquire_demuxer_rpc() const;
  private:
  bool _internal_has_acquire_demuxer_rpc() const;
  public:
  void clear_acquire_demuxer_rpc();
  const ::openscreen::cast::AcquireDemuxer& acquire_demuxer_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::AcquireDemuxer* release_acquire_demuxer_rpc();
  ::openscreen::cast::AcquireDemuxer* mutable_acquire_demuxer_rpc();
  void set_allocated_acquire_demuxer_rpc(::openscreen::cast::AcquireDemuxer* acquire_demuxer_rpc);
  private:
  const ::openscreen::cast::AcquireDemuxer& _internal_acquire_demuxer_rpc() const;
  ::openscreen::cast::AcquireDemuxer* _internal_mutable_acquire_demuxer_rpc();
  public:
  void unsafe_arena_set_allocated_acquire_demuxer_rpc(
      ::openscreen::cast::AcquireDemuxer* acquire_demuxer_rpc);
  ::openscreen::cast::AcquireDemuxer* unsafe_arena_release_acquire_demuxer_rpc();

  // .openscreen.cast.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
  bool has_rendererclient_ontimeupdate_rpc() const;
  private:
  bool _internal_has_rendererclient_ontimeupdate_rpc() const;
  public:
  void clear_rendererclient_ontimeupdate_rpc();
  const ::openscreen::cast::RendererClientOnTimeUpdate& rendererclient_ontimeupdate_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::RendererClientOnTimeUpdate* release_rendererclient_ontimeupdate_rpc();
  ::openscreen::cast::RendererClientOnTimeUpdate* mutable_rendererclient_ontimeupdate_rpc();
  void set_allocated_rendererclient_ontimeupdate_rpc(::openscreen::cast::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc);
  private:
  const ::openscreen::cast::RendererClientOnTimeUpdate& _internal_rendererclient_ontimeupdate_rpc() const;
  ::openscreen::cast::RendererClientOnTimeUpdate* _internal_mutable_rendererclient_ontimeupdate_rpc();
  public:
  void unsafe_arena_set_allocated_rendererclient_ontimeupdate_rpc(
      ::openscreen::cast::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc);
  ::openscreen::cast::RendererClientOnTimeUpdate* unsafe_arena_release_rendererclient_ontimeupdate_rpc();

  // .openscreen.cast.Size rendererclient_onvideonatualsizechange_rpc = 201;
  bool has_rendererclient_onvideonatualsizechange_rpc() const;
  private:
  bool _internal_has_rendererclient_onvideonatualsizechange_rpc() const;
  public:
  void clear_rendererclient_onvideonatualsizechange_rpc();
  const ::openscreen::cast::Size& rendererclient_onvideonatualsizechange_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::Size* release_rendererclient_onvideonatualsizechange_rpc();
  ::openscreen::cast::Size* mutable_rendererclient_onvideonatualsizechange_rpc();
  void set_allocated_rendererclient_onvideonatualsizechange_rpc(::openscreen::cast::Size* rendererclient_onvideonatualsizechange_rpc);
  private:
  const ::openscreen::cast::Size& _internal_rendererclient_onvideonatualsizechange_rpc() const;
  ::openscreen::cast::Size* _internal_mutable_rendererclient_onvideonatualsizechange_rpc();
  public:
  void unsafe_arena_set_allocated_rendererclient_onvideonatualsizechange_rpc(
      ::openscreen::cast::Size* rendererclient_onvideonatualsizechange_rpc);
  ::openscreen::cast::Size* unsafe_arena_release_rendererclient_onvideonatualsizechange_rpc();

  // .openscreen.cast.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
  bool has_rendererclient_onstatisticsupdate_rpc() const;
  private:
  bool _internal_has_rendererclient_onstatisticsupdate_rpc() const;
  public:
  void clear_rendererclient_onstatisticsupdate_rpc();
  const ::openscreen::cast::PipelineStatistics& rendererclient_onstatisticsupdate_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::PipelineStatistics* release_rendererclient_onstatisticsupdate_rpc();
  ::openscreen::cast::PipelineStatistics* mutable_rendererclient_onstatisticsupdate_rpc();
  void set_allocated_rendererclient_onstatisticsupdate_rpc(::openscreen::cast::PipelineStatistics* rendererclient_onstatisticsupdate_rpc);
  private:
  const ::openscreen::cast::PipelineStatistics& _internal_rendererclient_onstatisticsupdate_rpc() const;
  ::openscreen::cast::PipelineStatistics* _internal_mutable_rendererclient_onstatisticsupdate_rpc();
  public:
  void unsafe_arena_set_allocated_rendererclient_onstatisticsupdate_rpc(
      ::openscreen::cast::PipelineStatistics* rendererclient_onstatisticsupdate_rpc);
  ::openscreen::cast::PipelineStatistics* unsafe_arena_release_rendererclient_onstatisticsupdate_rpc();

  // .openscreen.cast.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
  bool has_rendererclient_onbufferingstatechange_rpc() const;
  private:
  bool _internal_has_rendererclient_onbufferingstatechange_rpc() const;
  public:
  void clear_rendererclient_onbufferingstatechange_rpc();
  const ::openscreen::cast::RendererClientOnBufferingStateChange& rendererclient_onbufferingstatechange_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::RendererClientOnBufferingStateChange* release_rendererclient_onbufferingstatechange_rpc();
  ::openscreen::cast::RendererClientOnBufferingStateChange* mutable_rendererclient_onbufferingstatechange_rpc();
  void set_allocated_rendererclient_onbufferingstatechange_rpc(::openscreen::cast::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc);
  private:
  const ::openscreen::cast::RendererClientOnBufferingStateChange& _internal_rendererclient_onbufferingstatechange_rpc() const;
  ::openscreen::cast::RendererClientOnBufferingStateChange* _internal_mutable_rendererclient_onbufferingstatechange_rpc();
  public:
  void unsafe_arena_set_allocated_rendererclient_onbufferingstatechange_rpc(
      ::openscreen::cast::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc);
  ::openscreen::cast::RendererClientOnBufferingStateChange* unsafe_arena_release_rendererclient_onbufferingstatechange_rpc();

  // .openscreen.cast.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
  bool has_rendererclient_onaudioconfigchange_rpc() const;
  private:
  bool _internal_has_rendererclient_onaudioconfigchange_rpc() const;
  public:
  void clear_rendererclient_onaudioconfigchange_rpc();
  const ::openscreen::cast::RendererClientOnAudioConfigChange& rendererclient_onaudioconfigchange_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::RendererClientOnAudioConfigChange* release_rendererclient_onaudioconfigchange_rpc();
  ::openscreen::cast::RendererClientOnAudioConfigChange* mutable_rendererclient_onaudioconfigchange_rpc();
  void set_allocated_rendererclient_onaudioconfigchange_rpc(::openscreen::cast::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc);
  private:
  const ::openscreen::cast::RendererClientOnAudioConfigChange& _internal_rendererclient_onaudioconfigchange_rpc() const;
  ::openscreen::cast::RendererClientOnAudioConfigChange* _internal_mutable_rendererclient_onaudioconfigchange_rpc();
  public:
  void unsafe_arena_set_allocated_rendererclient_onaudioconfigchange_rpc(
      ::openscreen::cast::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc);
  ::openscreen::cast::RendererClientOnAudioConfigChange* unsafe_arena_release_rendererclient_onaudioconfigchange_rpc();

  // .openscreen.cast.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
  bool has_rendererclient_onvideoconfigchange_rpc() const;
  private:
  bool _internal_has_rendererclient_onvideoconfigchange_rpc() const;
  public:
  void clear_rendererclient_onvideoconfigchange_rpc();
  const ::openscreen::cast::RendererClientOnVideoConfigChange& rendererclient_onvideoconfigchange_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::RendererClientOnVideoConfigChange* release_rendererclient_onvideoconfigchange_rpc();
  ::openscreen::cast::RendererClientOnVideoConfigChange* mutable_rendererclient_onvideoconfigchange_rpc();
  void set_allocated_rendererclient_onvideoconfigchange_rpc(::openscreen::cast::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc);
  private:
  const ::openscreen::cast::RendererClientOnVideoConfigChange& _internal_rendererclient_onvideoconfigchange_rpc() const;
  ::openscreen::cast::RendererClientOnVideoConfigChange* _internal_mutable_rendererclient_onvideoconfigchange_rpc();
  public:
  void unsafe_arena_set_allocated_rendererclient_onvideoconfigchange_rpc(
      ::openscreen::cast::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc);
  ::openscreen::cast::RendererClientOnVideoConfigChange* unsafe_arena_release_rendererclient_onvideoconfigchange_rpc();

  // .openscreen.cast.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
  bool has_demuxerstream_readuntil_rpc() const;
  private:
  bool _internal_has_demuxerstream_readuntil_rpc() const;
  public:
  void clear_demuxerstream_readuntil_rpc();
  const ::openscreen::cast::DemuxerStreamReadUntil& demuxerstream_readuntil_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::DemuxerStreamReadUntil* release_demuxerstream_readuntil_rpc();
  ::openscreen::cast::DemuxerStreamReadUntil* mutable_demuxerstream_readuntil_rpc();
  void set_allocated_demuxerstream_readuntil_rpc(::openscreen::cast::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc);
  private:
  const ::openscreen::cast::DemuxerStreamReadUntil& _internal_demuxerstream_readuntil_rpc() const;
  ::openscreen::cast::DemuxerStreamReadUntil* _internal_mutable_demuxerstream_readuntil_rpc();
  public:
  void unsafe_arena_set_allocated_demuxerstream_readuntil_rpc(
      ::openscreen::cast::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc);
  ::openscreen::cast::DemuxerStreamReadUntil* unsafe_arena_release_demuxerstream_readuntil_rpc();

  // .openscreen.cast.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
  bool has_demuxerstream_initializecb_rpc() const;
  private:
  bool _internal_has_demuxerstream_initializecb_rpc() const;
  public:
  void clear_demuxerstream_initializecb_rpc();
  const ::openscreen::cast::DemuxerStreamInitializeCallback& demuxerstream_initializecb_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::DemuxerStreamInitializeCallback* release_demuxerstream_initializecb_rpc();
  ::openscreen::cast::DemuxerStreamInitializeCallback* mutable_demuxerstream_initializecb_rpc();
  void set_allocated_demuxerstream_initializecb_rpc(::openscreen::cast::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc);
  private:
  const ::openscreen::cast::DemuxerStreamInitializeCallback& _internal_demuxerstream_initializecb_rpc() const;
  ::openscreen::cast::DemuxerStreamInitializeCallback* _internal_mutable_demuxerstream_initializecb_rpc();
  public:
  void unsafe_arena_set_allocated_demuxerstream_initializecb_rpc(
      ::openscreen::cast::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc);
  ::openscreen::cast::DemuxerStreamInitializeCallback* unsafe_arena_release_demuxerstream_initializecb_rpc();

  // .openscreen.cast.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
  bool has_demuxerstream_readuntilcb_rpc() const;
  private:
  bool _internal_has_demuxerstream_readuntilcb_rpc() const;
  public:
  void clear_demuxerstream_readuntilcb_rpc();
  const ::openscreen::cast::DemuxerStreamReadUntilCallback& demuxerstream_readuntilcb_rpc() const;
  PROTOBUF_NODISCARD ::openscreen::cast::DemuxerStreamReadUntilCallback* release_demuxerstream_readuntilcb_rpc();
  ::openscreen::cast::DemuxerStreamReadUntilCallback* mutable_demuxerstream_readuntilcb_rpc();
  void set_allocated_demuxerstream_readuntilcb_rpc(::openscreen::cast::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc);
  private:
  const ::openscreen::cast::DemuxerStreamReadUntilCallback& _internal_demuxerstream_readuntilcb_rpc() const;
  ::openscreen::cast::DemuxerStreamReadUntilCallback* _internal_mutable_demuxerstream_readuntilcb_rpc();
  public:
  void unsafe_arena_set_allocated_demuxerstream_readuntilcb_rpc(
      ::openscreen::cast::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc);
  ::openscreen::cast::DemuxerStreamReadUntilCallback* unsafe_arena_release_demuxerstream_readuntilcb_rpc();

  void clear_rpc_oneof();
  RpcOneofCase rpc_oneof_case() const;
  // @@protoc_insertion_point(class_scope:openscreen.cast.RpcMessage)
 private:
  class _Internal;
  void set_has_integer_value();
  void set_has_integer64_value();
  void set_has_double_value();
  void set_has_boolean_value();
  void set_has_string_value();
  void set_has_renderer_initialize_rpc();
  void set_has_renderer_flushuntil_rpc();
  void set_has_acquire_demuxer_rpc();
  void set_has_rendererclient_ontimeupdate_rpc();
  void set_has_rendererclient_onvideonatualsizechange_rpc();
  void set_has_rendererclient_onstatisticsupdate_rpc();
  void set_has_rendererclient_onbufferingstatechange_rpc();
  void set_has_rendererclient_onaudioconfigchange_rpc();
  void set_has_rendererclient_onvideoconfigchange_rpc();
  void set_has_demuxerstream_readuntil_rpc();
  void set_has_demuxerstream_initializecb_rpc();
  void set_has_demuxerstream_readuntilcb_rpc();

  inline bool has_rpc_oneof() const;
  inline void clear_has_rpc_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t handle_;
  int proc_;
  union RpcOneofUnion {
    constexpr RpcOneofUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    int32_t integer_value_;
    int64_t integer64_value_;
    double double_value_;
    bool boolean_value_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr string_value_;
    ::openscreen::cast::RendererInitialize* renderer_initialize_rpc_;
    ::openscreen::cast::RendererFlushUntil* renderer_flushuntil_rpc_;
    ::openscreen::cast::AcquireDemuxer* acquire_demuxer_rpc_;
    ::openscreen::cast::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc_;
    ::openscreen::cast::Size* rendererclient_onvideonatualsizechange_rpc_;
    ::openscreen::cast::PipelineStatistics* rendererclient_onstatisticsupdate_rpc_;
    ::openscreen::cast::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc_;
    ::openscreen::cast::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc_;
    ::openscreen::cast::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc_;
    ::openscreen::cast::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc_;
    ::openscreen::cast::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc_;
    ::openscreen::cast::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc_;
  } rpc_oneof_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_remoting_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DecoderBuffer

// optional int64 timestamp_usec = 1;
inline bool DecoderBuffer::_internal_has_timestamp_usec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DecoderBuffer::has_timestamp_usec() const {
  return _internal_has_timestamp_usec();
}
inline void DecoderBuffer::clear_timestamp_usec() {
  timestamp_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t DecoderBuffer::_internal_timestamp_usec() const {
  return timestamp_usec_;
}
inline int64_t DecoderBuffer::timestamp_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.timestamp_usec)
  return _internal_timestamp_usec();
}
inline void DecoderBuffer::_internal_set_timestamp_usec(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_usec_ = value;
}
inline void DecoderBuffer::set_timestamp_usec(int64_t value) {
  _internal_set_timestamp_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.timestamp_usec)
}

// optional int64 duration_usec = 2;
inline bool DecoderBuffer::_internal_has_duration_usec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DecoderBuffer::has_duration_usec() const {
  return _internal_has_duration_usec();
}
inline void DecoderBuffer::clear_duration_usec() {
  duration_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t DecoderBuffer::_internal_duration_usec() const {
  return duration_usec_;
}
inline int64_t DecoderBuffer::duration_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.duration_usec)
  return _internal_duration_usec();
}
inline void DecoderBuffer::_internal_set_duration_usec(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  duration_usec_ = value;
}
inline void DecoderBuffer::set_duration_usec(int64_t value) {
  _internal_set_duration_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.duration_usec)
}

// optional bool is_key_frame = 3;
inline bool DecoderBuffer::_internal_has_is_key_frame() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DecoderBuffer::has_is_key_frame() const {
  return _internal_has_is_key_frame();
}
inline void DecoderBuffer::clear_is_key_frame() {
  is_key_frame_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool DecoderBuffer::_internal_is_key_frame() const {
  return is_key_frame_;
}
inline bool DecoderBuffer::is_key_frame() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.is_key_frame)
  return _internal_is_key_frame();
}
inline void DecoderBuffer::_internal_set_is_key_frame(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_key_frame_ = value;
}
inline void DecoderBuffer::set_is_key_frame(bool value) {
  _internal_set_is_key_frame(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.is_key_frame)
}

// optional int64 front_discard_usec = 5;
inline bool DecoderBuffer::_internal_has_front_discard_usec() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DecoderBuffer::has_front_discard_usec() const {
  return _internal_has_front_discard_usec();
}
inline void DecoderBuffer::clear_front_discard_usec() {
  front_discard_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t DecoderBuffer::_internal_front_discard_usec() const {
  return front_discard_usec_;
}
inline int64_t DecoderBuffer::front_discard_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.front_discard_usec)
  return _internal_front_discard_usec();
}
inline void DecoderBuffer::_internal_set_front_discard_usec(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  front_discard_usec_ = value;
}
inline void DecoderBuffer::set_front_discard_usec(int64_t value) {
  _internal_set_front_discard_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.front_discard_usec)
}

// optional int64 back_discard_usec = 6;
inline bool DecoderBuffer::_internal_has_back_discard_usec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DecoderBuffer::has_back_discard_usec() const {
  return _internal_has_back_discard_usec();
}
inline void DecoderBuffer::clear_back_discard_usec() {
  back_discard_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t DecoderBuffer::_internal_back_discard_usec() const {
  return back_discard_usec_;
}
inline int64_t DecoderBuffer::back_discard_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.back_discard_usec)
  return _internal_back_discard_usec();
}
inline void DecoderBuffer::_internal_set_back_discard_usec(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  back_discard_usec_ = value;
}
inline void DecoderBuffer::set_back_discard_usec(int64_t value) {
  _internal_set_back_discard_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.back_discard_usec)
}

// optional bytes side_data = 8;
inline bool DecoderBuffer::_internal_has_side_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DecoderBuffer::has_side_data() const {
  return _internal_has_side_data();
}
inline void DecoderBuffer::clear_side_data() {
  side_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DecoderBuffer::side_data() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.side_data)
  return _internal_side_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DecoderBuffer::set_side_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 side_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.side_data)
}
inline std::string* DecoderBuffer::mutable_side_data() {
  std::string* _s = _internal_mutable_side_data();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.DecoderBuffer.side_data)
  return _s;
}
inline const std::string& DecoderBuffer::_internal_side_data() const {
  return side_data_.Get();
}
inline void DecoderBuffer::_internal_set_side_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  side_data_.Set(value, GetArenaForAllocation());
}
inline std::string* DecoderBuffer::_internal_mutable_side_data() {
  _has_bits_[0] |= 0x00000001u;
  return side_data_.Mutable(GetArenaForAllocation());
}
inline std::string* DecoderBuffer::release_side_data() {
  // @@protoc_insertion_point(field_release:openscreen.cast.DecoderBuffer.side_data)
  if (!_internal_has_side_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = side_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (side_data_.IsDefault()) {
    side_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DecoderBuffer::set_allocated_side_data(std::string* side_data) {
  if (side_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  side_data_.SetAllocated(side_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (side_data_.IsDefault()) {
    side_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.DecoderBuffer.side_data)
}

// optional bool is_eos = 9;
inline bool DecoderBuffer::_internal_has_is_eos() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool DecoderBuffer::has_is_eos() const {
  return _internal_has_is_eos();
}
inline void DecoderBuffer::clear_is_eos() {
  is_eos_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool DecoderBuffer::_internal_is_eos() const {
  return is_eos_;
}
inline bool DecoderBuffer::is_eos() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DecoderBuffer.is_eos)
  return _internal_is_eos();
}
inline void DecoderBuffer::_internal_set_is_eos(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_eos_ = value;
}
inline void DecoderBuffer::set_is_eos(bool value) {
  _internal_set_is_eos(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DecoderBuffer.is_eos)
}

// -------------------------------------------------------------------

// Size

// optional int32 width = 1;
inline bool Size::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Size::has_width() const {
  return _internal_has_width();
}
inline void Size::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Size::_internal_width() const {
  return width_;
}
inline int32_t Size::width() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.Size.width)
  return _internal_width();
}
inline void Size::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void Size::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.Size.width)
}

// optional int32 height = 2;
inline bool Size::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Size::has_height() const {
  return _internal_has_height();
}
inline void Size::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Size::_internal_height() const {
  return height_;
}
inline int32_t Size::height() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.Size.height)
  return _internal_height();
}
inline void Size::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void Size::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.Size.height)
}

// -------------------------------------------------------------------

// AudioDecoderConfig

// optional .openscreen.cast.AudioDecoderConfig.Codec codec = 1;
inline bool AudioDecoderConfig::_internal_has_codec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_codec() const {
  return _internal_has_codec();
}
inline void AudioDecoderConfig::clear_codec() {
  codec_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::openscreen::cast::AudioDecoderConfig_Codec AudioDecoderConfig::_internal_codec() const {
  return static_cast< ::openscreen::cast::AudioDecoderConfig_Codec >(codec_);
}
inline ::openscreen::cast::AudioDecoderConfig_Codec AudioDecoderConfig::codec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.codec)
  return _internal_codec();
}
inline void AudioDecoderConfig::_internal_set_codec(::openscreen::cast::AudioDecoderConfig_Codec value) {
  assert(::openscreen::cast::AudioDecoderConfig_Codec_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  codec_ = value;
}
inline void AudioDecoderConfig::set_codec(::openscreen::cast::AudioDecoderConfig_Codec value) {
  _internal_set_codec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.codec)
}

// optional .openscreen.cast.AudioDecoderConfig.SampleFormat sample_format = 3;
inline bool AudioDecoderConfig::_internal_has_sample_format() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_sample_format() const {
  return _internal_has_sample_format();
}
inline void AudioDecoderConfig::clear_sample_format() {
  sample_format_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::openscreen::cast::AudioDecoderConfig_SampleFormat AudioDecoderConfig::_internal_sample_format() const {
  return static_cast< ::openscreen::cast::AudioDecoderConfig_SampleFormat >(sample_format_);
}
inline ::openscreen::cast::AudioDecoderConfig_SampleFormat AudioDecoderConfig::sample_format() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.sample_format)
  return _internal_sample_format();
}
inline void AudioDecoderConfig::_internal_set_sample_format(::openscreen::cast::AudioDecoderConfig_SampleFormat value) {
  assert(::openscreen::cast::AudioDecoderConfig_SampleFormat_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  sample_format_ = value;
}
inline void AudioDecoderConfig::set_sample_format(::openscreen::cast::AudioDecoderConfig_SampleFormat value) {
  _internal_set_sample_format(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.sample_format)
}

// optional .openscreen.cast.AudioDecoderConfig.ChannelLayout channel_layout = 4;
inline bool AudioDecoderConfig::_internal_has_channel_layout() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_channel_layout() const {
  return _internal_has_channel_layout();
}
inline void AudioDecoderConfig::clear_channel_layout() {
  channel_layout_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::openscreen::cast::AudioDecoderConfig_ChannelLayout AudioDecoderConfig::_internal_channel_layout() const {
  return static_cast< ::openscreen::cast::AudioDecoderConfig_ChannelLayout >(channel_layout_);
}
inline ::openscreen::cast::AudioDecoderConfig_ChannelLayout AudioDecoderConfig::channel_layout() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.channel_layout)
  return _internal_channel_layout();
}
inline void AudioDecoderConfig::_internal_set_channel_layout(::openscreen::cast::AudioDecoderConfig_ChannelLayout value) {
  assert(::openscreen::cast::AudioDecoderConfig_ChannelLayout_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  channel_layout_ = value;
}
inline void AudioDecoderConfig::set_channel_layout(::openscreen::cast::AudioDecoderConfig_ChannelLayout value) {
  _internal_set_channel_layout(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.channel_layout)
}

// optional int32 samples_per_second = 5;
inline bool AudioDecoderConfig::_internal_has_samples_per_second() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_samples_per_second() const {
  return _internal_has_samples_per_second();
}
inline void AudioDecoderConfig::clear_samples_per_second() {
  samples_per_second_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t AudioDecoderConfig::_internal_samples_per_second() const {
  return samples_per_second_;
}
inline int32_t AudioDecoderConfig::samples_per_second() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.samples_per_second)
  return _internal_samples_per_second();
}
inline void AudioDecoderConfig::_internal_set_samples_per_second(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  samples_per_second_ = value;
}
inline void AudioDecoderConfig::set_samples_per_second(int32_t value) {
  _internal_set_samples_per_second(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.samples_per_second)
}

// optional int64 seek_preroll_usec = 6;
inline bool AudioDecoderConfig::_internal_has_seek_preroll_usec() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_seek_preroll_usec() const {
  return _internal_has_seek_preroll_usec();
}
inline void AudioDecoderConfig::clear_seek_preroll_usec() {
  seek_preroll_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t AudioDecoderConfig::_internal_seek_preroll_usec() const {
  return seek_preroll_usec_;
}
inline int64_t AudioDecoderConfig::seek_preroll_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.seek_preroll_usec)
  return _internal_seek_preroll_usec();
}
inline void AudioDecoderConfig::_internal_set_seek_preroll_usec(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  seek_preroll_usec_ = value;
}
inline void AudioDecoderConfig::set_seek_preroll_usec(int64_t value) {
  _internal_set_seek_preroll_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.seek_preroll_usec)
}

// optional int32 codec_delay = 7;
inline bool AudioDecoderConfig::_internal_has_codec_delay() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_codec_delay() const {
  return _internal_has_codec_delay();
}
inline void AudioDecoderConfig::clear_codec_delay() {
  codec_delay_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t AudioDecoderConfig::_internal_codec_delay() const {
  return codec_delay_;
}
inline int32_t AudioDecoderConfig::codec_delay() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.codec_delay)
  return _internal_codec_delay();
}
inline void AudioDecoderConfig::_internal_set_codec_delay(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  codec_delay_ = value;
}
inline void AudioDecoderConfig::set_codec_delay(int32_t value) {
  _internal_set_codec_delay(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.codec_delay)
}

// optional bytes extra_data = 8;
inline bool AudioDecoderConfig::_internal_has_extra_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioDecoderConfig::has_extra_data() const {
  return _internal_has_extra_data();
}
inline void AudioDecoderConfig::clear_extra_data() {
  extra_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AudioDecoderConfig::extra_data() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderConfig.extra_data)
  return _internal_extra_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AudioDecoderConfig::set_extra_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 extra_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderConfig.extra_data)
}
inline std::string* AudioDecoderConfig::mutable_extra_data() {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.AudioDecoderConfig.extra_data)
  return _s;
}
inline const std::string& AudioDecoderConfig::_internal_extra_data() const {
  return extra_data_.Get();
}
inline void AudioDecoderConfig::_internal_set_extra_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.Set(value, GetArenaForAllocation());
}
inline std::string* AudioDecoderConfig::_internal_mutable_extra_data() {
  _has_bits_[0] |= 0x00000001u;
  return extra_data_.Mutable(GetArenaForAllocation());
}
inline std::string* AudioDecoderConfig::release_extra_data() {
  // @@protoc_insertion_point(field_release:openscreen.cast.AudioDecoderConfig.extra_data)
  if (!_internal_has_extra_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = extra_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_data_.IsDefault()) {
    extra_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AudioDecoderConfig::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_data_.SetAllocated(extra_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_data_.IsDefault()) {
    extra_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.AudioDecoderConfig.extra_data)
}

// -------------------------------------------------------------------

// Rect

// optional int32 x = 1;
inline bool Rect::_internal_has_x() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Rect::has_x() const {
  return _internal_has_x();
}
inline void Rect::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Rect::_internal_x() const {
  return x_;
}
inline int32_t Rect::x() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.Rect.x)
  return _internal_x();
}
inline void Rect::_internal_set_x(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  x_ = value;
}
inline void Rect::set_x(int32_t value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.Rect.x)
}

// optional int32 y = 2;
inline bool Rect::_internal_has_y() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Rect::has_y() const {
  return _internal_has_y();
}
inline void Rect::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Rect::_internal_y() const {
  return y_;
}
inline int32_t Rect::y() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.Rect.y)
  return _internal_y();
}
inline void Rect::_internal_set_y(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  y_ = value;
}
inline void Rect::set_y(int32_t value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.Rect.y)
}

// optional int32 width = 3;
inline bool Rect::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Rect::has_width() const {
  return _internal_has_width();
}
inline void Rect::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t Rect::_internal_width() const {
  return width_;
}
inline int32_t Rect::width() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.Rect.width)
  return _internal_width();
}
inline void Rect::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void Rect::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.Rect.width)
}

// optional int32 height = 4;
inline bool Rect::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Rect::has_height() const {
  return _internal_has_height();
}
inline void Rect::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t Rect::_internal_height() const {
  return height_;
}
inline int32_t Rect::height() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.Rect.height)
  return _internal_height();
}
inline void Rect::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
}
inline void Rect::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.Rect.height)
}

// -------------------------------------------------------------------

// VideoDecoderConfig

// optional .openscreen.cast.VideoDecoderConfig.Codec codec = 1;
inline bool VideoDecoderConfig::_internal_has_codec() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool VideoDecoderConfig::has_codec() const {
  return _internal_has_codec();
}
inline void VideoDecoderConfig::clear_codec() {
  codec_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::openscreen::cast::VideoDecoderConfig_Codec VideoDecoderConfig::_internal_codec() const {
  return static_cast< ::openscreen::cast::VideoDecoderConfig_Codec >(codec_);
}
inline ::openscreen::cast::VideoDecoderConfig_Codec VideoDecoderConfig::codec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.codec)
  return _internal_codec();
}
inline void VideoDecoderConfig::_internal_set_codec(::openscreen::cast::VideoDecoderConfig_Codec value) {
  assert(::openscreen::cast::VideoDecoderConfig_Codec_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  codec_ = value;
}
inline void VideoDecoderConfig::set_codec(::openscreen::cast::VideoDecoderConfig_Codec value) {
  _internal_set_codec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderConfig.codec)
}

// optional .openscreen.cast.VideoDecoderConfig.Profile profile = 3;
inline bool VideoDecoderConfig::_internal_has_profile() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool VideoDecoderConfig::has_profile() const {
  return _internal_has_profile();
}
inline void VideoDecoderConfig::clear_profile() {
  profile_ = -1;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::openscreen::cast::VideoDecoderConfig_Profile VideoDecoderConfig::_internal_profile() const {
  return static_cast< ::openscreen::cast::VideoDecoderConfig_Profile >(profile_);
}
inline ::openscreen::cast::VideoDecoderConfig_Profile VideoDecoderConfig::profile() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.profile)
  return _internal_profile();
}
inline void VideoDecoderConfig::_internal_set_profile(::openscreen::cast::VideoDecoderConfig_Profile value) {
  assert(::openscreen::cast::VideoDecoderConfig_Profile_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  profile_ = value;
}
inline void VideoDecoderConfig::set_profile(::openscreen::cast::VideoDecoderConfig_Profile value) {
  _internal_set_profile(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderConfig.profile)
}

// optional .openscreen.cast.VideoDecoderConfig.Format format = 4;
inline bool VideoDecoderConfig::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool VideoDecoderConfig::has_format() const {
  return _internal_has_format();
}
inline void VideoDecoderConfig::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::openscreen::cast::VideoDecoderConfig_Format VideoDecoderConfig::_internal_format() const {
  return static_cast< ::openscreen::cast::VideoDecoderConfig_Format >(format_);
}
inline ::openscreen::cast::VideoDecoderConfig_Format VideoDecoderConfig::format() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.format)
  return _internal_format();
}
inline void VideoDecoderConfig::_internal_set_format(::openscreen::cast::VideoDecoderConfig_Format value) {
  assert(::openscreen::cast::VideoDecoderConfig_Format_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  format_ = value;
}
inline void VideoDecoderConfig::set_format(::openscreen::cast::VideoDecoderConfig_Format value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderConfig.format)
}

// optional .openscreen.cast.VideoDecoderConfig.ColorSpace color_space = 5;
inline bool VideoDecoderConfig::_internal_has_color_space() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool VideoDecoderConfig::has_color_space() const {
  return _internal_has_color_space();
}
inline void VideoDecoderConfig::clear_color_space() {
  color_space_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::openscreen::cast::VideoDecoderConfig_ColorSpace VideoDecoderConfig::_internal_color_space() const {
  return static_cast< ::openscreen::cast::VideoDecoderConfig_ColorSpace >(color_space_);
}
inline ::openscreen::cast::VideoDecoderConfig_ColorSpace VideoDecoderConfig::color_space() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.color_space)
  return _internal_color_space();
}
inline void VideoDecoderConfig::_internal_set_color_space(::openscreen::cast::VideoDecoderConfig_ColorSpace value) {
  assert(::openscreen::cast::VideoDecoderConfig_ColorSpace_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  color_space_ = value;
}
inline void VideoDecoderConfig::set_color_space(::openscreen::cast::VideoDecoderConfig_ColorSpace value) {
  _internal_set_color_space(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderConfig.color_space)
}

// optional .openscreen.cast.Size coded_size = 6;
inline bool VideoDecoderConfig::_internal_has_coded_size() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || coded_size_ != nullptr);
  return value;
}
inline bool VideoDecoderConfig::has_coded_size() const {
  return _internal_has_coded_size();
}
inline void VideoDecoderConfig::clear_coded_size() {
  if (coded_size_ != nullptr) coded_size_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::openscreen::cast::Size& VideoDecoderConfig::_internal_coded_size() const {
  const ::openscreen::cast::Size* p = coded_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::Size&>(
      ::openscreen::cast::_Size_default_instance_);
}
inline const ::openscreen::cast::Size& VideoDecoderConfig::coded_size() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.coded_size)
  return _internal_coded_size();
}
inline void VideoDecoderConfig::unsafe_arena_set_allocated_coded_size(
    ::openscreen::cast::Size* coded_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(coded_size_);
  }
  coded_size_ = coded_size;
  if (coded_size) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.VideoDecoderConfig.coded_size)
}
inline ::openscreen::cast::Size* VideoDecoderConfig::release_coded_size() {
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::Size* temp = coded_size_;
  coded_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::Size* VideoDecoderConfig::unsafe_arena_release_coded_size() {
  // @@protoc_insertion_point(field_release:openscreen.cast.VideoDecoderConfig.coded_size)
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::Size* temp = coded_size_;
  coded_size_ = nullptr;
  return temp;
}
inline ::openscreen::cast::Size* VideoDecoderConfig::_internal_mutable_coded_size() {
  _has_bits_[0] |= 0x00000002u;
  if (coded_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::Size>(GetArenaForAllocation());
    coded_size_ = p;
  }
  return coded_size_;
}
inline ::openscreen::cast::Size* VideoDecoderConfig::mutable_coded_size() {
  ::openscreen::cast::Size* _msg = _internal_mutable_coded_size();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.VideoDecoderConfig.coded_size)
  return _msg;
}
inline void VideoDecoderConfig::set_allocated_coded_size(::openscreen::cast::Size* coded_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete coded_size_;
  }
  if (coded_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(coded_size);
    if (message_arena != submessage_arena) {
      coded_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, coded_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coded_size_ = coded_size;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.VideoDecoderConfig.coded_size)
}

// optional .openscreen.cast.Rect visible_rect = 7;
inline bool VideoDecoderConfig::_internal_has_visible_rect() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || visible_rect_ != nullptr);
  return value;
}
inline bool VideoDecoderConfig::has_visible_rect() const {
  return _internal_has_visible_rect();
}
inline void VideoDecoderConfig::clear_visible_rect() {
  if (visible_rect_ != nullptr) visible_rect_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::openscreen::cast::Rect& VideoDecoderConfig::_internal_visible_rect() const {
  const ::openscreen::cast::Rect* p = visible_rect_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::Rect&>(
      ::openscreen::cast::_Rect_default_instance_);
}
inline const ::openscreen::cast::Rect& VideoDecoderConfig::visible_rect() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.visible_rect)
  return _internal_visible_rect();
}
inline void VideoDecoderConfig::unsafe_arena_set_allocated_visible_rect(
    ::openscreen::cast::Rect* visible_rect) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(visible_rect_);
  }
  visible_rect_ = visible_rect;
  if (visible_rect) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.VideoDecoderConfig.visible_rect)
}
inline ::openscreen::cast::Rect* VideoDecoderConfig::release_visible_rect() {
  _has_bits_[0] &= ~0x00000004u;
  ::openscreen::cast::Rect* temp = visible_rect_;
  visible_rect_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::Rect* VideoDecoderConfig::unsafe_arena_release_visible_rect() {
  // @@protoc_insertion_point(field_release:openscreen.cast.VideoDecoderConfig.visible_rect)
  _has_bits_[0] &= ~0x00000004u;
  ::openscreen::cast::Rect* temp = visible_rect_;
  visible_rect_ = nullptr;
  return temp;
}
inline ::openscreen::cast::Rect* VideoDecoderConfig::_internal_mutable_visible_rect() {
  _has_bits_[0] |= 0x00000004u;
  if (visible_rect_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::Rect>(GetArenaForAllocation());
    visible_rect_ = p;
  }
  return visible_rect_;
}
inline ::openscreen::cast::Rect* VideoDecoderConfig::mutable_visible_rect() {
  ::openscreen::cast::Rect* _msg = _internal_mutable_visible_rect();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.VideoDecoderConfig.visible_rect)
  return _msg;
}
inline void VideoDecoderConfig::set_allocated_visible_rect(::openscreen::cast::Rect* visible_rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete visible_rect_;
  }
  if (visible_rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(visible_rect);
    if (message_arena != submessage_arena) {
      visible_rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, visible_rect, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  visible_rect_ = visible_rect;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.VideoDecoderConfig.visible_rect)
}

// optional .openscreen.cast.Size natural_size = 8;
inline bool VideoDecoderConfig::_internal_has_natural_size() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || natural_size_ != nullptr);
  return value;
}
inline bool VideoDecoderConfig::has_natural_size() const {
  return _internal_has_natural_size();
}
inline void VideoDecoderConfig::clear_natural_size() {
  if (natural_size_ != nullptr) natural_size_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::openscreen::cast::Size& VideoDecoderConfig::_internal_natural_size() const {
  const ::openscreen::cast::Size* p = natural_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::Size&>(
      ::openscreen::cast::_Size_default_instance_);
}
inline const ::openscreen::cast::Size& VideoDecoderConfig::natural_size() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.natural_size)
  return _internal_natural_size();
}
inline void VideoDecoderConfig::unsafe_arena_set_allocated_natural_size(
    ::openscreen::cast::Size* natural_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(natural_size_);
  }
  natural_size_ = natural_size;
  if (natural_size) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.VideoDecoderConfig.natural_size)
}
inline ::openscreen::cast::Size* VideoDecoderConfig::release_natural_size() {
  _has_bits_[0] &= ~0x00000008u;
  ::openscreen::cast::Size* temp = natural_size_;
  natural_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::Size* VideoDecoderConfig::unsafe_arena_release_natural_size() {
  // @@protoc_insertion_point(field_release:openscreen.cast.VideoDecoderConfig.natural_size)
  _has_bits_[0] &= ~0x00000008u;
  ::openscreen::cast::Size* temp = natural_size_;
  natural_size_ = nullptr;
  return temp;
}
inline ::openscreen::cast::Size* VideoDecoderConfig::_internal_mutable_natural_size() {
  _has_bits_[0] |= 0x00000008u;
  if (natural_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::Size>(GetArenaForAllocation());
    natural_size_ = p;
  }
  return natural_size_;
}
inline ::openscreen::cast::Size* VideoDecoderConfig::mutable_natural_size() {
  ::openscreen::cast::Size* _msg = _internal_mutable_natural_size();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.VideoDecoderConfig.natural_size)
  return _msg;
}
inline void VideoDecoderConfig::set_allocated_natural_size(::openscreen::cast::Size* natural_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete natural_size_;
  }
  if (natural_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(natural_size);
    if (message_arena != submessage_arena) {
      natural_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, natural_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  natural_size_ = natural_size;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.VideoDecoderConfig.natural_size)
}

// optional bytes extra_data = 9;
inline bool VideoDecoderConfig::_internal_has_extra_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoDecoderConfig::has_extra_data() const {
  return _internal_has_extra_data();
}
inline void VideoDecoderConfig::clear_extra_data() {
  extra_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& VideoDecoderConfig::extra_data() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderConfig.extra_data)
  return _internal_extra_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VideoDecoderConfig::set_extra_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 extra_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderConfig.extra_data)
}
inline std::string* VideoDecoderConfig::mutable_extra_data() {
  std::string* _s = _internal_mutable_extra_data();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.VideoDecoderConfig.extra_data)
  return _s;
}
inline const std::string& VideoDecoderConfig::_internal_extra_data() const {
  return extra_data_.Get();
}
inline void VideoDecoderConfig::_internal_set_extra_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extra_data_.Set(value, GetArenaForAllocation());
}
inline std::string* VideoDecoderConfig::_internal_mutable_extra_data() {
  _has_bits_[0] |= 0x00000001u;
  return extra_data_.Mutable(GetArenaForAllocation());
}
inline std::string* VideoDecoderConfig::release_extra_data() {
  // @@protoc_insertion_point(field_release:openscreen.cast.VideoDecoderConfig.extra_data)
  if (!_internal_has_extra_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = extra_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_data_.IsDefault()) {
    extra_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void VideoDecoderConfig::set_allocated_extra_data(std::string* extra_data) {
  if (extra_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extra_data_.SetAllocated(extra_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extra_data_.IsDefault()) {
    extra_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.VideoDecoderConfig.extra_data)
}

// -------------------------------------------------------------------

// AudioDecoderInfo

// optional int64 decoder_type = 1;
inline bool AudioDecoderInfo::_internal_has_decoder_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AudioDecoderInfo::has_decoder_type() const {
  return _internal_has_decoder_type();
}
inline void AudioDecoderInfo::clear_decoder_type() {
  decoder_type_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t AudioDecoderInfo::_internal_decoder_type() const {
  return decoder_type_;
}
inline int64_t AudioDecoderInfo::decoder_type() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderInfo.decoder_type)
  return _internal_decoder_type();
}
inline void AudioDecoderInfo::_internal_set_decoder_type(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  decoder_type_ = value;
}
inline void AudioDecoderInfo::set_decoder_type(int64_t value) {
  _internal_set_decoder_type(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderInfo.decoder_type)
}

// optional bool is_platform_decoder = 2;
inline bool AudioDecoderInfo::_internal_has_is_platform_decoder() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AudioDecoderInfo::has_is_platform_decoder() const {
  return _internal_has_is_platform_decoder();
}
inline void AudioDecoderInfo::clear_is_platform_decoder() {
  is_platform_decoder_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool AudioDecoderInfo::_internal_is_platform_decoder() const {
  return is_platform_decoder_;
}
inline bool AudioDecoderInfo::is_platform_decoder() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AudioDecoderInfo.is_platform_decoder)
  return _internal_is_platform_decoder();
}
inline void AudioDecoderInfo::_internal_set_is_platform_decoder(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_platform_decoder_ = value;
}
inline void AudioDecoderInfo::set_is_platform_decoder(bool value) {
  _internal_set_is_platform_decoder(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AudioDecoderInfo.is_platform_decoder)
}

// -------------------------------------------------------------------

// VideoDecoderInfo

// optional int64 decoder_type = 1;
inline bool VideoDecoderInfo::_internal_has_decoder_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool VideoDecoderInfo::has_decoder_type() const {
  return _internal_has_decoder_type();
}
inline void VideoDecoderInfo::clear_decoder_type() {
  decoder_type_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t VideoDecoderInfo::_internal_decoder_type() const {
  return decoder_type_;
}
inline int64_t VideoDecoderInfo::decoder_type() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderInfo.decoder_type)
  return _internal_decoder_type();
}
inline void VideoDecoderInfo::_internal_set_decoder_type(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  decoder_type_ = value;
}
inline void VideoDecoderInfo::set_decoder_type(int64_t value) {
  _internal_set_decoder_type(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderInfo.decoder_type)
}

// optional bool is_platform_decoder = 2;
inline bool VideoDecoderInfo::_internal_has_is_platform_decoder() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool VideoDecoderInfo::has_is_platform_decoder() const {
  return _internal_has_is_platform_decoder();
}
inline void VideoDecoderInfo::clear_is_platform_decoder() {
  is_platform_decoder_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool VideoDecoderInfo::_internal_is_platform_decoder() const {
  return is_platform_decoder_;
}
inline bool VideoDecoderInfo::is_platform_decoder() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.VideoDecoderInfo.is_platform_decoder)
  return _internal_is_platform_decoder();
}
inline void VideoDecoderInfo::_internal_set_is_platform_decoder(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_platform_decoder_ = value;
}
inline void VideoDecoderInfo::set_is_platform_decoder(bool value) {
  _internal_set_is_platform_decoder(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.VideoDecoderInfo.is_platform_decoder)
}

// -------------------------------------------------------------------

// PipelineStatistics

// optional uint64 audio_bytes_decoded = 1;
inline bool PipelineStatistics::_internal_has_audio_bytes_decoded() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PipelineStatistics::has_audio_bytes_decoded() const {
  return _internal_has_audio_bytes_decoded();
}
inline void PipelineStatistics::clear_audio_bytes_decoded() {
  audio_bytes_decoded_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t PipelineStatistics::_internal_audio_bytes_decoded() const {
  return audio_bytes_decoded_;
}
inline uint64_t PipelineStatistics::audio_bytes_decoded() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.audio_bytes_decoded)
  return _internal_audio_bytes_decoded();
}
inline void PipelineStatistics::_internal_set_audio_bytes_decoded(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  audio_bytes_decoded_ = value;
}
inline void PipelineStatistics::set_audio_bytes_decoded(uint64_t value) {
  _internal_set_audio_bytes_decoded(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.audio_bytes_decoded)
}

// optional uint64 video_bytes_decoded = 2;
inline bool PipelineStatistics::_internal_has_video_bytes_decoded() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PipelineStatistics::has_video_bytes_decoded() const {
  return _internal_has_video_bytes_decoded();
}
inline void PipelineStatistics::clear_video_bytes_decoded() {
  video_bytes_decoded_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t PipelineStatistics::_internal_video_bytes_decoded() const {
  return video_bytes_decoded_;
}
inline uint64_t PipelineStatistics::video_bytes_decoded() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.video_bytes_decoded)
  return _internal_video_bytes_decoded();
}
inline void PipelineStatistics::_internal_set_video_bytes_decoded(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  video_bytes_decoded_ = value;
}
inline void PipelineStatistics::set_video_bytes_decoded(uint64_t value) {
  _internal_set_video_bytes_decoded(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.video_bytes_decoded)
}

// optional uint32 video_frames_decoded = 3;
inline bool PipelineStatistics::_internal_has_video_frames_decoded() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PipelineStatistics::has_video_frames_decoded() const {
  return _internal_has_video_frames_decoded();
}
inline void PipelineStatistics::clear_video_frames_decoded() {
  video_frames_decoded_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PipelineStatistics::_internal_video_frames_decoded() const {
  return video_frames_decoded_;
}
inline uint32_t PipelineStatistics::video_frames_decoded() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.video_frames_decoded)
  return _internal_video_frames_decoded();
}
inline void PipelineStatistics::_internal_set_video_frames_decoded(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  video_frames_decoded_ = value;
}
inline void PipelineStatistics::set_video_frames_decoded(uint32_t value) {
  _internal_set_video_frames_decoded(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.video_frames_decoded)
}

// optional uint32 video_frames_dropped = 4;
inline bool PipelineStatistics::_internal_has_video_frames_dropped() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PipelineStatistics::has_video_frames_dropped() const {
  return _internal_has_video_frames_dropped();
}
inline void PipelineStatistics::clear_video_frames_dropped() {
  video_frames_dropped_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t PipelineStatistics::_internal_video_frames_dropped() const {
  return video_frames_dropped_;
}
inline uint32_t PipelineStatistics::video_frames_dropped() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.video_frames_dropped)
  return _internal_video_frames_dropped();
}
inline void PipelineStatistics::_internal_set_video_frames_dropped(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  video_frames_dropped_ = value;
}
inline void PipelineStatistics::set_video_frames_dropped(uint32_t value) {
  _internal_set_video_frames_dropped(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.video_frames_dropped)
}

// optional int64 audio_memory_usage = 5;
inline bool PipelineStatistics::_internal_has_audio_memory_usage() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool PipelineStatistics::has_audio_memory_usage() const {
  return _internal_has_audio_memory_usage();
}
inline void PipelineStatistics::clear_audio_memory_usage() {
  audio_memory_usage_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t PipelineStatistics::_internal_audio_memory_usage() const {
  return audio_memory_usage_;
}
inline int64_t PipelineStatistics::audio_memory_usage() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.audio_memory_usage)
  return _internal_audio_memory_usage();
}
inline void PipelineStatistics::_internal_set_audio_memory_usage(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  audio_memory_usage_ = value;
}
inline void PipelineStatistics::set_audio_memory_usage(int64_t value) {
  _internal_set_audio_memory_usage(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.audio_memory_usage)
}

// optional int64 video_memory_usage = 6;
inline bool PipelineStatistics::_internal_has_video_memory_usage() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool PipelineStatistics::has_video_memory_usage() const {
  return _internal_has_video_memory_usage();
}
inline void PipelineStatistics::clear_video_memory_usage() {
  video_memory_usage_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline int64_t PipelineStatistics::_internal_video_memory_usage() const {
  return video_memory_usage_;
}
inline int64_t PipelineStatistics::video_memory_usage() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.video_memory_usage)
  return _internal_video_memory_usage();
}
inline void PipelineStatistics::_internal_set_video_memory_usage(int64_t value) {
  _has_bits_[0] |= 0x00000080u;
  video_memory_usage_ = value;
}
inline void PipelineStatistics::set_video_memory_usage(int64_t value) {
  _internal_set_video_memory_usage(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.video_memory_usage)
}

// optional int64 video_frame_duration_average_usec = 7;
inline bool PipelineStatistics::_internal_has_video_frame_duration_average_usec() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool PipelineStatistics::has_video_frame_duration_average_usec() const {
  return _internal_has_video_frame_duration_average_usec();
}
inline void PipelineStatistics::clear_video_frame_duration_average_usec() {
  video_frame_duration_average_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000100u;
}
inline int64_t PipelineStatistics::_internal_video_frame_duration_average_usec() const {
  return video_frame_duration_average_usec_;
}
inline int64_t PipelineStatistics::video_frame_duration_average_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.video_frame_duration_average_usec)
  return _internal_video_frame_duration_average_usec();
}
inline void PipelineStatistics::_internal_set_video_frame_duration_average_usec(int64_t value) {
  _has_bits_[0] |= 0x00000100u;
  video_frame_duration_average_usec_ = value;
}
inline void PipelineStatistics::set_video_frame_duration_average_usec(int64_t value) {
  _internal_set_video_frame_duration_average_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.PipelineStatistics.video_frame_duration_average_usec)
}

// optional .openscreen.cast.AudioDecoderInfo audio_decoder_info = 8;
inline bool PipelineStatistics::_internal_has_audio_decoder_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || audio_decoder_info_ != nullptr);
  return value;
}
inline bool PipelineStatistics::has_audio_decoder_info() const {
  return _internal_has_audio_decoder_info();
}
inline void PipelineStatistics::clear_audio_decoder_info() {
  if (audio_decoder_info_ != nullptr) audio_decoder_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::openscreen::cast::AudioDecoderInfo& PipelineStatistics::_internal_audio_decoder_info() const {
  const ::openscreen::cast::AudioDecoderInfo* p = audio_decoder_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::AudioDecoderInfo&>(
      ::openscreen::cast::_AudioDecoderInfo_default_instance_);
}
inline const ::openscreen::cast::AudioDecoderInfo& PipelineStatistics::audio_decoder_info() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.audio_decoder_info)
  return _internal_audio_decoder_info();
}
inline void PipelineStatistics::unsafe_arena_set_allocated_audio_decoder_info(
    ::openscreen::cast::AudioDecoderInfo* audio_decoder_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_decoder_info_);
  }
  audio_decoder_info_ = audio_decoder_info;
  if (audio_decoder_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.PipelineStatistics.audio_decoder_info)
}
inline ::openscreen::cast::AudioDecoderInfo* PipelineStatistics::release_audio_decoder_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderInfo* temp = audio_decoder_info_;
  audio_decoder_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::AudioDecoderInfo* PipelineStatistics::unsafe_arena_release_audio_decoder_info() {
  // @@protoc_insertion_point(field_release:openscreen.cast.PipelineStatistics.audio_decoder_info)
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderInfo* temp = audio_decoder_info_;
  audio_decoder_info_ = nullptr;
  return temp;
}
inline ::openscreen::cast::AudioDecoderInfo* PipelineStatistics::_internal_mutable_audio_decoder_info() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::AudioDecoderInfo>(GetArenaForAllocation());
    audio_decoder_info_ = p;
  }
  return audio_decoder_info_;
}
inline ::openscreen::cast::AudioDecoderInfo* PipelineStatistics::mutable_audio_decoder_info() {
  ::openscreen::cast::AudioDecoderInfo* _msg = _internal_mutable_audio_decoder_info();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.PipelineStatistics.audio_decoder_info)
  return _msg;
}
inline void PipelineStatistics::set_allocated_audio_decoder_info(::openscreen::cast::AudioDecoderInfo* audio_decoder_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_decoder_info_;
  }
  if (audio_decoder_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_decoder_info);
    if (message_arena != submessage_arena) {
      audio_decoder_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_info_ = audio_decoder_info;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.PipelineStatistics.audio_decoder_info)
}

// optional .openscreen.cast.VideoDecoderInfo video_decoder_info = 9;
inline bool PipelineStatistics::_internal_has_video_decoder_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || video_decoder_info_ != nullptr);
  return value;
}
inline bool PipelineStatistics::has_video_decoder_info() const {
  return _internal_has_video_decoder_info();
}
inline void PipelineStatistics::clear_video_decoder_info() {
  if (video_decoder_info_ != nullptr) video_decoder_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::openscreen::cast::VideoDecoderInfo& PipelineStatistics::_internal_video_decoder_info() const {
  const ::openscreen::cast::VideoDecoderInfo* p = video_decoder_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::VideoDecoderInfo&>(
      ::openscreen::cast::_VideoDecoderInfo_default_instance_);
}
inline const ::openscreen::cast::VideoDecoderInfo& PipelineStatistics::video_decoder_info() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.PipelineStatistics.video_decoder_info)
  return _internal_video_decoder_info();
}
inline void PipelineStatistics::unsafe_arena_set_allocated_video_decoder_info(
    ::openscreen::cast::VideoDecoderInfo* video_decoder_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_decoder_info_);
  }
  video_decoder_info_ = video_decoder_info;
  if (video_decoder_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.PipelineStatistics.video_decoder_info)
}
inline ::openscreen::cast::VideoDecoderInfo* PipelineStatistics::release_video_decoder_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::VideoDecoderInfo* temp = video_decoder_info_;
  video_decoder_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::VideoDecoderInfo* PipelineStatistics::unsafe_arena_release_video_decoder_info() {
  // @@protoc_insertion_point(field_release:openscreen.cast.PipelineStatistics.video_decoder_info)
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::VideoDecoderInfo* temp = video_decoder_info_;
  video_decoder_info_ = nullptr;
  return temp;
}
inline ::openscreen::cast::VideoDecoderInfo* PipelineStatistics::_internal_mutable_video_decoder_info() {
  _has_bits_[0] |= 0x00000002u;
  if (video_decoder_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::VideoDecoderInfo>(GetArenaForAllocation());
    video_decoder_info_ = p;
  }
  return video_decoder_info_;
}
inline ::openscreen::cast::VideoDecoderInfo* PipelineStatistics::mutable_video_decoder_info() {
  ::openscreen::cast::VideoDecoderInfo* _msg = _internal_mutable_video_decoder_info();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.PipelineStatistics.video_decoder_info)
  return _msg;
}
inline void PipelineStatistics::set_allocated_video_decoder_info(::openscreen::cast::VideoDecoderInfo* video_decoder_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete video_decoder_info_;
  }
  if (video_decoder_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_decoder_info);
    if (message_arena != submessage_arena) {
      video_decoder_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_decoder_info_ = video_decoder_info;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.PipelineStatistics.video_decoder_info)
}

// -------------------------------------------------------------------

// AcquireDemuxer

// optional int32 audio_demuxer_handle = 1;
inline bool AcquireDemuxer::_internal_has_audio_demuxer_handle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AcquireDemuxer::has_audio_demuxer_handle() const {
  return _internal_has_audio_demuxer_handle();
}
inline void AcquireDemuxer::clear_audio_demuxer_handle() {
  audio_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t AcquireDemuxer::_internal_audio_demuxer_handle() const {
  return audio_demuxer_handle_;
}
inline int32_t AcquireDemuxer::audio_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AcquireDemuxer.audio_demuxer_handle)
  return _internal_audio_demuxer_handle();
}
inline void AcquireDemuxer::_internal_set_audio_demuxer_handle(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  audio_demuxer_handle_ = value;
}
inline void AcquireDemuxer::set_audio_demuxer_handle(int32_t value) {
  _internal_set_audio_demuxer_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AcquireDemuxer.audio_demuxer_handle)
}

// optional int32 video_demuxer_handle = 2;
inline bool AcquireDemuxer::_internal_has_video_demuxer_handle() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool AcquireDemuxer::has_video_demuxer_handle() const {
  return _internal_has_video_demuxer_handle();
}
inline void AcquireDemuxer::clear_video_demuxer_handle() {
  video_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t AcquireDemuxer::_internal_video_demuxer_handle() const {
  return video_demuxer_handle_;
}
inline int32_t AcquireDemuxer::video_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.AcquireDemuxer.video_demuxer_handle)
  return _internal_video_demuxer_handle();
}
inline void AcquireDemuxer::_internal_set_video_demuxer_handle(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  video_demuxer_handle_ = value;
}
inline void AcquireDemuxer::set_video_demuxer_handle(int32_t value) {
  _internal_set_video_demuxer_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.AcquireDemuxer.video_demuxer_handle)
}

// -------------------------------------------------------------------

// RendererInitialize

// optional int32 client_handle = 1;
inline bool RendererInitialize::_internal_has_client_handle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RendererInitialize::has_client_handle() const {
  return _internal_has_client_handle();
}
inline void RendererInitialize::clear_client_handle() {
  client_handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t RendererInitialize::_internal_client_handle() const {
  return client_handle_;
}
inline int32_t RendererInitialize::client_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererInitialize.client_handle)
  return _internal_client_handle();
}
inline void RendererInitialize::_internal_set_client_handle(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  client_handle_ = value;
}
inline void RendererInitialize::set_client_handle(int32_t value) {
  _internal_set_client_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererInitialize.client_handle)
}

// optional int32 audio_demuxer_handle = 2;
inline bool RendererInitialize::_internal_has_audio_demuxer_handle() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RendererInitialize::has_audio_demuxer_handle() const {
  return _internal_has_audio_demuxer_handle();
}
inline void RendererInitialize::clear_audio_demuxer_handle() {
  audio_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t RendererInitialize::_internal_audio_demuxer_handle() const {
  return audio_demuxer_handle_;
}
inline int32_t RendererInitialize::audio_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererInitialize.audio_demuxer_handle)
  return _internal_audio_demuxer_handle();
}
inline void RendererInitialize::_internal_set_audio_demuxer_handle(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  audio_demuxer_handle_ = value;
}
inline void RendererInitialize::set_audio_demuxer_handle(int32_t value) {
  _internal_set_audio_demuxer_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererInitialize.audio_demuxer_handle)
}

// optional int32 video_demuxer_handle = 3;
inline bool RendererInitialize::_internal_has_video_demuxer_handle() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RendererInitialize::has_video_demuxer_handle() const {
  return _internal_has_video_demuxer_handle();
}
inline void RendererInitialize::clear_video_demuxer_handle() {
  video_demuxer_handle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t RendererInitialize::_internal_video_demuxer_handle() const {
  return video_demuxer_handle_;
}
inline int32_t RendererInitialize::video_demuxer_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererInitialize.video_demuxer_handle)
  return _internal_video_demuxer_handle();
}
inline void RendererInitialize::_internal_set_video_demuxer_handle(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  video_demuxer_handle_ = value;
}
inline void RendererInitialize::set_video_demuxer_handle(int32_t value) {
  _internal_set_video_demuxer_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererInitialize.video_demuxer_handle)
}

// optional int32 callback_handle = 4;
inline bool RendererInitialize::_internal_has_callback_handle() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool RendererInitialize::has_callback_handle() const {
  return _internal_has_callback_handle();
}
inline void RendererInitialize::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t RendererInitialize::_internal_callback_handle() const {
  return callback_handle_;
}
inline int32_t RendererInitialize::callback_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererInitialize.callback_handle)
  return _internal_callback_handle();
}
inline void RendererInitialize::_internal_set_callback_handle(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  callback_handle_ = value;
}
inline void RendererInitialize::set_callback_handle(int32_t value) {
  _internal_set_callback_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererInitialize.callback_handle)
}

// -------------------------------------------------------------------

// RendererFlushUntil

// optional uint32 audio_count = 1;
inline bool RendererFlushUntil::_internal_has_audio_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RendererFlushUntil::has_audio_count() const {
  return _internal_has_audio_count();
}
inline void RendererFlushUntil::clear_audio_count() {
  audio_count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RendererFlushUntil::_internal_audio_count() const {
  return audio_count_;
}
inline uint32_t RendererFlushUntil::audio_count() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererFlushUntil.audio_count)
  return _internal_audio_count();
}
inline void RendererFlushUntil::_internal_set_audio_count(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  audio_count_ = value;
}
inline void RendererFlushUntil::set_audio_count(uint32_t value) {
  _internal_set_audio_count(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererFlushUntil.audio_count)
}

// optional uint32 video_count = 2;
inline bool RendererFlushUntil::_internal_has_video_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RendererFlushUntil::has_video_count() const {
  return _internal_has_video_count();
}
inline void RendererFlushUntil::clear_video_count() {
  video_count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t RendererFlushUntil::_internal_video_count() const {
  return video_count_;
}
inline uint32_t RendererFlushUntil::video_count() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererFlushUntil.video_count)
  return _internal_video_count();
}
inline void RendererFlushUntil::_internal_set_video_count(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  video_count_ = value;
}
inline void RendererFlushUntil::set_video_count(uint32_t value) {
  _internal_set_video_count(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererFlushUntil.video_count)
}

// optional int32 callback_handle = 3;
inline bool RendererFlushUntil::_internal_has_callback_handle() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool RendererFlushUntil::has_callback_handle() const {
  return _internal_has_callback_handle();
}
inline void RendererFlushUntil::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t RendererFlushUntil::_internal_callback_handle() const {
  return callback_handle_;
}
inline int32_t RendererFlushUntil::callback_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererFlushUntil.callback_handle)
  return _internal_callback_handle();
}
inline void RendererFlushUntil::_internal_set_callback_handle(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  callback_handle_ = value;
}
inline void RendererFlushUntil::set_callback_handle(int32_t value) {
  _internal_set_callback_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererFlushUntil.callback_handle)
}

// -------------------------------------------------------------------

// RendererClientOnTimeUpdate

// optional int64 time_usec = 1;
inline bool RendererClientOnTimeUpdate::_internal_has_time_usec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RendererClientOnTimeUpdate::has_time_usec() const {
  return _internal_has_time_usec();
}
inline void RendererClientOnTimeUpdate::clear_time_usec() {
  time_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t RendererClientOnTimeUpdate::_internal_time_usec() const {
  return time_usec_;
}
inline int64_t RendererClientOnTimeUpdate::time_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererClientOnTimeUpdate.time_usec)
  return _internal_time_usec();
}
inline void RendererClientOnTimeUpdate::_internal_set_time_usec(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  time_usec_ = value;
}
inline void RendererClientOnTimeUpdate::set_time_usec(int64_t value) {
  _internal_set_time_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererClientOnTimeUpdate.time_usec)
}

// optional int64 max_time_usec = 2;
inline bool RendererClientOnTimeUpdate::_internal_has_max_time_usec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RendererClientOnTimeUpdate::has_max_time_usec() const {
  return _internal_has_max_time_usec();
}
inline void RendererClientOnTimeUpdate::clear_max_time_usec() {
  max_time_usec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t RendererClientOnTimeUpdate::_internal_max_time_usec() const {
  return max_time_usec_;
}
inline int64_t RendererClientOnTimeUpdate::max_time_usec() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererClientOnTimeUpdate.max_time_usec)
  return _internal_max_time_usec();
}
inline void RendererClientOnTimeUpdate::_internal_set_max_time_usec(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  max_time_usec_ = value;
}
inline void RendererClientOnTimeUpdate::set_max_time_usec(int64_t value) {
  _internal_set_max_time_usec(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererClientOnTimeUpdate.max_time_usec)
}

// -------------------------------------------------------------------

// RendererClientOnBufferingStateChange

// optional .openscreen.cast.RendererClientOnBufferingStateChange.State state = 1;
inline bool RendererClientOnBufferingStateChange::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RendererClientOnBufferingStateChange::has_state() const {
  return _internal_has_state();
}
inline void RendererClientOnBufferingStateChange::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::openscreen::cast::RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::_internal_state() const {
  return static_cast< ::openscreen::cast::RendererClientOnBufferingStateChange_State >(state_);
}
inline ::openscreen::cast::RendererClientOnBufferingStateChange_State RendererClientOnBufferingStateChange::state() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererClientOnBufferingStateChange.state)
  return _internal_state();
}
inline void RendererClientOnBufferingStateChange::_internal_set_state(::openscreen::cast::RendererClientOnBufferingStateChange_State value) {
  assert(::openscreen::cast::RendererClientOnBufferingStateChange_State_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  state_ = value;
}
inline void RendererClientOnBufferingStateChange::set_state(::openscreen::cast::RendererClientOnBufferingStateChange_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RendererClientOnBufferingStateChange.state)
}

// -------------------------------------------------------------------

// RendererClientOnAudioConfigChange

// optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 1;
inline bool RendererClientOnAudioConfigChange::_internal_has_audio_decoder_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || audio_decoder_config_ != nullptr);
  return value;
}
inline bool RendererClientOnAudioConfigChange::has_audio_decoder_config() const {
  return _internal_has_audio_decoder_config();
}
inline void RendererClientOnAudioConfigChange::clear_audio_decoder_config() {
  if (audio_decoder_config_ != nullptr) audio_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::openscreen::cast::AudioDecoderConfig& RendererClientOnAudioConfigChange::_internal_audio_decoder_config() const {
  const ::openscreen::cast::AudioDecoderConfig* p = audio_decoder_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::AudioDecoderConfig&>(
      ::openscreen::cast::_AudioDecoderConfig_default_instance_);
}
inline const ::openscreen::cast::AudioDecoderConfig& RendererClientOnAudioConfigChange::audio_decoder_config() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererClientOnAudioConfigChange.audio_decoder_config)
  return _internal_audio_decoder_config();
}
inline void RendererClientOnAudioConfigChange::unsafe_arena_set_allocated_audio_decoder_config(
    ::openscreen::cast::AudioDecoderConfig* audio_decoder_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_decoder_config_);
  }
  audio_decoder_config_ = audio_decoder_config;
  if (audio_decoder_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RendererClientOnAudioConfigChange.audio_decoder_config)
}
inline ::openscreen::cast::AudioDecoderConfig* RendererClientOnAudioConfigChange::release_audio_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::AudioDecoderConfig* RendererClientOnAudioConfigChange::unsafe_arena_release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RendererClientOnAudioConfigChange.audio_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
  return temp;
}
inline ::openscreen::cast::AudioDecoderConfig* RendererClientOnAudioConfigChange::_internal_mutable_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::AudioDecoderConfig>(GetArenaForAllocation());
    audio_decoder_config_ = p;
  }
  return audio_decoder_config_;
}
inline ::openscreen::cast::AudioDecoderConfig* RendererClientOnAudioConfigChange::mutable_audio_decoder_config() {
  ::openscreen::cast::AudioDecoderConfig* _msg = _internal_mutable_audio_decoder_config();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RendererClientOnAudioConfigChange.audio_decoder_config)
  return _msg;
}
inline void RendererClientOnAudioConfigChange::set_allocated_audio_decoder_config(::openscreen::cast::AudioDecoderConfig* audio_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_decoder_config_;
  }
  if (audio_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_decoder_config);
    if (message_arena != submessage_arena) {
      audio_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_config_ = audio_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RendererClientOnAudioConfigChange.audio_decoder_config)
}

// -------------------------------------------------------------------

// RendererClientOnVideoConfigChange

// optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 1;
inline bool RendererClientOnVideoConfigChange::_internal_has_video_decoder_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || video_decoder_config_ != nullptr);
  return value;
}
inline bool RendererClientOnVideoConfigChange::has_video_decoder_config() const {
  return _internal_has_video_decoder_config();
}
inline void RendererClientOnVideoConfigChange::clear_video_decoder_config() {
  if (video_decoder_config_ != nullptr) video_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::openscreen::cast::VideoDecoderConfig& RendererClientOnVideoConfigChange::_internal_video_decoder_config() const {
  const ::openscreen::cast::VideoDecoderConfig* p = video_decoder_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::VideoDecoderConfig&>(
      ::openscreen::cast::_VideoDecoderConfig_default_instance_);
}
inline const ::openscreen::cast::VideoDecoderConfig& RendererClientOnVideoConfigChange::video_decoder_config() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RendererClientOnVideoConfigChange.video_decoder_config)
  return _internal_video_decoder_config();
}
inline void RendererClientOnVideoConfigChange::unsafe_arena_set_allocated_video_decoder_config(
    ::openscreen::cast::VideoDecoderConfig* video_decoder_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_decoder_config_);
  }
  video_decoder_config_ = video_decoder_config;
  if (video_decoder_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RendererClientOnVideoConfigChange.video_decoder_config)
}
inline ::openscreen::cast::VideoDecoderConfig* RendererClientOnVideoConfigChange::release_video_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::VideoDecoderConfig* RendererClientOnVideoConfigChange::unsafe_arena_release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RendererClientOnVideoConfigChange.video_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
  return temp;
}
inline ::openscreen::cast::VideoDecoderConfig* RendererClientOnVideoConfigChange::_internal_mutable_video_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (video_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::VideoDecoderConfig>(GetArenaForAllocation());
    video_decoder_config_ = p;
  }
  return video_decoder_config_;
}
inline ::openscreen::cast::VideoDecoderConfig* RendererClientOnVideoConfigChange::mutable_video_decoder_config() {
  ::openscreen::cast::VideoDecoderConfig* _msg = _internal_mutable_video_decoder_config();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RendererClientOnVideoConfigChange.video_decoder_config)
  return _msg;
}
inline void RendererClientOnVideoConfigChange::set_allocated_video_decoder_config(::openscreen::cast::VideoDecoderConfig* video_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete video_decoder_config_;
  }
  if (video_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_decoder_config);
    if (message_arena != submessage_arena) {
      video_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  video_decoder_config_ = video_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RendererClientOnVideoConfigChange.video_decoder_config)
}

// -------------------------------------------------------------------

// DemuxerStreamReadUntil

// optional int32 callback_handle = 1;
inline bool DemuxerStreamReadUntil::_internal_has_callback_handle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DemuxerStreamReadUntil::has_callback_handle() const {
  return _internal_has_callback_handle();
}
inline void DemuxerStreamReadUntil::clear_callback_handle() {
  callback_handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t DemuxerStreamReadUntil::_internal_callback_handle() const {
  return callback_handle_;
}
inline int32_t DemuxerStreamReadUntil::callback_handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamReadUntil.callback_handle)
  return _internal_callback_handle();
}
inline void DemuxerStreamReadUntil::_internal_set_callback_handle(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  callback_handle_ = value;
}
inline void DemuxerStreamReadUntil::set_callback_handle(int32_t value) {
  _internal_set_callback_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DemuxerStreamReadUntil.callback_handle)
}

// optional uint32 count = 2;
inline bool DemuxerStreamReadUntil::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DemuxerStreamReadUntil::has_count() const {
  return _internal_has_count();
}
inline void DemuxerStreamReadUntil::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t DemuxerStreamReadUntil::_internal_count() const {
  return count_;
}
inline uint32_t DemuxerStreamReadUntil::count() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamReadUntil.count)
  return _internal_count();
}
inline void DemuxerStreamReadUntil::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void DemuxerStreamReadUntil::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DemuxerStreamReadUntil.count)
}

// -------------------------------------------------------------------

// DemuxerStreamInitializeCallback

// optional int32 type = 1;
inline bool DemuxerStreamInitializeCallback::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DemuxerStreamInitializeCallback::has_type() const {
  return _internal_has_type();
}
inline void DemuxerStreamInitializeCallback::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t DemuxerStreamInitializeCallback::_internal_type() const {
  return type_;
}
inline int32_t DemuxerStreamInitializeCallback::type() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamInitializeCallback.type)
  return _internal_type();
}
inline void DemuxerStreamInitializeCallback::_internal_set_type(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void DemuxerStreamInitializeCallback::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DemuxerStreamInitializeCallback.type)
}

// optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 2;
inline bool DemuxerStreamInitializeCallback::_internal_has_audio_decoder_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || audio_decoder_config_ != nullptr);
  return value;
}
inline bool DemuxerStreamInitializeCallback::has_audio_decoder_config() const {
  return _internal_has_audio_decoder_config();
}
inline void DemuxerStreamInitializeCallback::clear_audio_decoder_config() {
  if (audio_decoder_config_ != nullptr) audio_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::openscreen::cast::AudioDecoderConfig& DemuxerStreamInitializeCallback::_internal_audio_decoder_config() const {
  const ::openscreen::cast::AudioDecoderConfig* p = audio_decoder_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::AudioDecoderConfig&>(
      ::openscreen::cast::_AudioDecoderConfig_default_instance_);
}
inline const ::openscreen::cast::AudioDecoderConfig& DemuxerStreamInitializeCallback::audio_decoder_config() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamInitializeCallback.audio_decoder_config)
  return _internal_audio_decoder_config();
}
inline void DemuxerStreamInitializeCallback::unsafe_arena_set_allocated_audio_decoder_config(
    ::openscreen::cast::AudioDecoderConfig* audio_decoder_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_decoder_config_);
  }
  audio_decoder_config_ = audio_decoder_config;
  if (audio_decoder_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.DemuxerStreamInitializeCallback.audio_decoder_config)
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamInitializeCallback::release_audio_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamInitializeCallback::unsafe_arena_release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:openscreen.cast.DemuxerStreamInitializeCallback.audio_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
  return temp;
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamInitializeCallback::_internal_mutable_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::AudioDecoderConfig>(GetArenaForAllocation());
    audio_decoder_config_ = p;
  }
  return audio_decoder_config_;
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamInitializeCallback::mutable_audio_decoder_config() {
  ::openscreen::cast::AudioDecoderConfig* _msg = _internal_mutable_audio_decoder_config();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.DemuxerStreamInitializeCallback.audio_decoder_config)
  return _msg;
}
inline void DemuxerStreamInitializeCallback::set_allocated_audio_decoder_config(::openscreen::cast::AudioDecoderConfig* audio_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_decoder_config_;
  }
  if (audio_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_decoder_config);
    if (message_arena != submessage_arena) {
      audio_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_config_ = audio_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.DemuxerStreamInitializeCallback.audio_decoder_config)
}

// optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 3;
inline bool DemuxerStreamInitializeCallback::_internal_has_video_decoder_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || video_decoder_config_ != nullptr);
  return value;
}
inline bool DemuxerStreamInitializeCallback::has_video_decoder_config() const {
  return _internal_has_video_decoder_config();
}
inline void DemuxerStreamInitializeCallback::clear_video_decoder_config() {
  if (video_decoder_config_ != nullptr) video_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::openscreen::cast::VideoDecoderConfig& DemuxerStreamInitializeCallback::_internal_video_decoder_config() const {
  const ::openscreen::cast::VideoDecoderConfig* p = video_decoder_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::VideoDecoderConfig&>(
      ::openscreen::cast::_VideoDecoderConfig_default_instance_);
}
inline const ::openscreen::cast::VideoDecoderConfig& DemuxerStreamInitializeCallback::video_decoder_config() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamInitializeCallback.video_decoder_config)
  return _internal_video_decoder_config();
}
inline void DemuxerStreamInitializeCallback::unsafe_arena_set_allocated_video_decoder_config(
    ::openscreen::cast::VideoDecoderConfig* video_decoder_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_decoder_config_);
  }
  video_decoder_config_ = video_decoder_config;
  if (video_decoder_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.DemuxerStreamInitializeCallback.video_decoder_config)
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamInitializeCallback::release_video_decoder_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamInitializeCallback::unsafe_arena_release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:openscreen.cast.DemuxerStreamInitializeCallback.video_decoder_config)
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
  return temp;
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamInitializeCallback::_internal_mutable_video_decoder_config() {
  _has_bits_[0] |= 0x00000002u;
  if (video_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::VideoDecoderConfig>(GetArenaForAllocation());
    video_decoder_config_ = p;
  }
  return video_decoder_config_;
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamInitializeCallback::mutable_video_decoder_config() {
  ::openscreen::cast::VideoDecoderConfig* _msg = _internal_mutable_video_decoder_config();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.DemuxerStreamInitializeCallback.video_decoder_config)
  return _msg;
}
inline void DemuxerStreamInitializeCallback::set_allocated_video_decoder_config(::openscreen::cast::VideoDecoderConfig* video_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete video_decoder_config_;
  }
  if (video_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_decoder_config);
    if (message_arena != submessage_arena) {
      video_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_decoder_config_ = video_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.DemuxerStreamInitializeCallback.video_decoder_config)
}

// -------------------------------------------------------------------

// DemuxerStreamReadUntilCallback

// optional .openscreen.cast.DemuxerStreamReadUntilCallback.Status status = 1;
inline bool DemuxerStreamReadUntilCallback::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DemuxerStreamReadUntilCallback::has_status() const {
  return _internal_has_status();
}
inline void DemuxerStreamReadUntilCallback::clear_status() {
  status_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::openscreen::cast::DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::_internal_status() const {
  return static_cast< ::openscreen::cast::DemuxerStreamReadUntilCallback_Status >(status_);
}
inline ::openscreen::cast::DemuxerStreamReadUntilCallback_Status DemuxerStreamReadUntilCallback::status() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamReadUntilCallback.status)
  return _internal_status();
}
inline void DemuxerStreamReadUntilCallback::_internal_set_status(::openscreen::cast::DemuxerStreamReadUntilCallback_Status value) {
  assert(::openscreen::cast::DemuxerStreamReadUntilCallback_Status_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  status_ = value;
}
inline void DemuxerStreamReadUntilCallback::set_status(::openscreen::cast::DemuxerStreamReadUntilCallback_Status value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DemuxerStreamReadUntilCallback.status)
}

// optional uint32 count = 2;
inline bool DemuxerStreamReadUntilCallback::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DemuxerStreamReadUntilCallback::has_count() const {
  return _internal_has_count();
}
inline void DemuxerStreamReadUntilCallback::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t DemuxerStreamReadUntilCallback::_internal_count() const {
  return count_;
}
inline uint32_t DemuxerStreamReadUntilCallback::count() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamReadUntilCallback.count)
  return _internal_count();
}
inline void DemuxerStreamReadUntilCallback::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  count_ = value;
}
inline void DemuxerStreamReadUntilCallback::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.DemuxerStreamReadUntilCallback.count)
}

// optional .openscreen.cast.AudioDecoderConfig audio_decoder_config = 3;
inline bool DemuxerStreamReadUntilCallback::_internal_has_audio_decoder_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || audio_decoder_config_ != nullptr);
  return value;
}
inline bool DemuxerStreamReadUntilCallback::has_audio_decoder_config() const {
  return _internal_has_audio_decoder_config();
}
inline void DemuxerStreamReadUntilCallback::clear_audio_decoder_config() {
  if (audio_decoder_config_ != nullptr) audio_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::openscreen::cast::AudioDecoderConfig& DemuxerStreamReadUntilCallback::_internal_audio_decoder_config() const {
  const ::openscreen::cast::AudioDecoderConfig* p = audio_decoder_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::AudioDecoderConfig&>(
      ::openscreen::cast::_AudioDecoderConfig_default_instance_);
}
inline const ::openscreen::cast::AudioDecoderConfig& DemuxerStreamReadUntilCallback::audio_decoder_config() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamReadUntilCallback.audio_decoder_config)
  return _internal_audio_decoder_config();
}
inline void DemuxerStreamReadUntilCallback::unsafe_arena_set_allocated_audio_decoder_config(
    ::openscreen::cast::AudioDecoderConfig* audio_decoder_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_decoder_config_);
  }
  audio_decoder_config_ = audio_decoder_config;
  if (audio_decoder_config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.DemuxerStreamReadUntilCallback.audio_decoder_config)
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamReadUntilCallback::release_audio_decoder_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamReadUntilCallback::unsafe_arena_release_audio_decoder_config() {
  // @@protoc_insertion_point(field_release:openscreen.cast.DemuxerStreamReadUntilCallback.audio_decoder_config)
  _has_bits_[0] &= ~0x00000001u;
  ::openscreen::cast::AudioDecoderConfig* temp = audio_decoder_config_;
  audio_decoder_config_ = nullptr;
  return temp;
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamReadUntilCallback::_internal_mutable_audio_decoder_config() {
  _has_bits_[0] |= 0x00000001u;
  if (audio_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::AudioDecoderConfig>(GetArenaForAllocation());
    audio_decoder_config_ = p;
  }
  return audio_decoder_config_;
}
inline ::openscreen::cast::AudioDecoderConfig* DemuxerStreamReadUntilCallback::mutable_audio_decoder_config() {
  ::openscreen::cast::AudioDecoderConfig* _msg = _internal_mutable_audio_decoder_config();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.DemuxerStreamReadUntilCallback.audio_decoder_config)
  return _msg;
}
inline void DemuxerStreamReadUntilCallback::set_allocated_audio_decoder_config(::openscreen::cast::AudioDecoderConfig* audio_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete audio_decoder_config_;
  }
  if (audio_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(audio_decoder_config);
    if (message_arena != submessage_arena) {
      audio_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  audio_decoder_config_ = audio_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.DemuxerStreamReadUntilCallback.audio_decoder_config)
}

// optional .openscreen.cast.VideoDecoderConfig video_decoder_config = 4;
inline bool DemuxerStreamReadUntilCallback::_internal_has_video_decoder_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || video_decoder_config_ != nullptr);
  return value;
}
inline bool DemuxerStreamReadUntilCallback::has_video_decoder_config() const {
  return _internal_has_video_decoder_config();
}
inline void DemuxerStreamReadUntilCallback::clear_video_decoder_config() {
  if (video_decoder_config_ != nullptr) video_decoder_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::openscreen::cast::VideoDecoderConfig& DemuxerStreamReadUntilCallback::_internal_video_decoder_config() const {
  const ::openscreen::cast::VideoDecoderConfig* p = video_decoder_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::openscreen::cast::VideoDecoderConfig&>(
      ::openscreen::cast::_VideoDecoderConfig_default_instance_);
}
inline const ::openscreen::cast::VideoDecoderConfig& DemuxerStreamReadUntilCallback::video_decoder_config() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.DemuxerStreamReadUntilCallback.video_decoder_config)
  return _internal_video_decoder_config();
}
inline void DemuxerStreamReadUntilCallback::unsafe_arena_set_allocated_video_decoder_config(
    ::openscreen::cast::VideoDecoderConfig* video_decoder_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(video_decoder_config_);
  }
  video_decoder_config_ = video_decoder_config;
  if (video_decoder_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.DemuxerStreamReadUntilCallback.video_decoder_config)
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamReadUntilCallback::release_video_decoder_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamReadUntilCallback::unsafe_arena_release_video_decoder_config() {
  // @@protoc_insertion_point(field_release:openscreen.cast.DemuxerStreamReadUntilCallback.video_decoder_config)
  _has_bits_[0] &= ~0x00000002u;
  ::openscreen::cast::VideoDecoderConfig* temp = video_decoder_config_;
  video_decoder_config_ = nullptr;
  return temp;
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamReadUntilCallback::_internal_mutable_video_decoder_config() {
  _has_bits_[0] |= 0x00000002u;
  if (video_decoder_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::openscreen::cast::VideoDecoderConfig>(GetArenaForAllocation());
    video_decoder_config_ = p;
  }
  return video_decoder_config_;
}
inline ::openscreen::cast::VideoDecoderConfig* DemuxerStreamReadUntilCallback::mutable_video_decoder_config() {
  ::openscreen::cast::VideoDecoderConfig* _msg = _internal_mutable_video_decoder_config();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.DemuxerStreamReadUntilCallback.video_decoder_config)
  return _msg;
}
inline void DemuxerStreamReadUntilCallback::set_allocated_video_decoder_config(::openscreen::cast::VideoDecoderConfig* video_decoder_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete video_decoder_config_;
  }
  if (video_decoder_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(video_decoder_config);
    if (message_arena != submessage_arena) {
      video_decoder_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, video_decoder_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  video_decoder_config_ = video_decoder_config;
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.DemuxerStreamReadUntilCallback.video_decoder_config)
}

// -------------------------------------------------------------------

// RpcMessage

// optional int32 handle = 1;
inline bool RpcMessage::_internal_has_handle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RpcMessage::has_handle() const {
  return _internal_has_handle();
}
inline void RpcMessage::clear_handle() {
  handle_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t RpcMessage::_internal_handle() const {
  return handle_;
}
inline int32_t RpcMessage::handle() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.handle)
  return _internal_handle();
}
inline void RpcMessage::_internal_set_handle(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  handle_ = value;
}
inline void RpcMessage::set_handle(int32_t value) {
  _internal_set_handle(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.handle)
}

// optional .openscreen.cast.RpcMessage.RpcProc proc = 2;
inline bool RpcMessage::_internal_has_proc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool RpcMessage::has_proc() const {
  return _internal_has_proc();
}
inline void RpcMessage::clear_proc() {
  proc_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::openscreen::cast::RpcMessage_RpcProc RpcMessage::_internal_proc() const {
  return static_cast< ::openscreen::cast::RpcMessage_RpcProc >(proc_);
}
inline ::openscreen::cast::RpcMessage_RpcProc RpcMessage::proc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.proc)
  return _internal_proc();
}
inline void RpcMessage::_internal_set_proc(::openscreen::cast::RpcMessage_RpcProc value) {
  assert(::openscreen::cast::RpcMessage_RpcProc_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  proc_ = value;
}
inline void RpcMessage::set_proc(::openscreen::cast::RpcMessage_RpcProc value) {
  _internal_set_proc(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.proc)
}

// int32 integer_value = 3;
inline bool RpcMessage::_internal_has_integer_value() const {
  return rpc_oneof_case() == kIntegerValue;
}
inline bool RpcMessage::has_integer_value() const {
  return _internal_has_integer_value();
}
inline void RpcMessage::set_has_integer_value() {
  _oneof_case_[0] = kIntegerValue;
}
inline void RpcMessage::clear_integer_value() {
  if (_internal_has_integer_value()) {
    rpc_oneof_.integer_value_ = 0;
    clear_has_rpc_oneof();
  }
}
inline int32_t RpcMessage::_internal_integer_value() const {
  if (_internal_has_integer_value()) {
    return rpc_oneof_.integer_value_;
  }
  return 0;
}
inline void RpcMessage::_internal_set_integer_value(int32_t value) {
  if (!_internal_has_integer_value()) {
    clear_rpc_oneof();
    set_has_integer_value();
  }
  rpc_oneof_.integer_value_ = value;
}
inline int32_t RpcMessage::integer_value() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.integer_value)
  return _internal_integer_value();
}
inline void RpcMessage::set_integer_value(int32_t value) {
  _internal_set_integer_value(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.integer_value)
}

// int64 integer64_value = 4;
inline bool RpcMessage::_internal_has_integer64_value() const {
  return rpc_oneof_case() == kInteger64Value;
}
inline bool RpcMessage::has_integer64_value() const {
  return _internal_has_integer64_value();
}
inline void RpcMessage::set_has_integer64_value() {
  _oneof_case_[0] = kInteger64Value;
}
inline void RpcMessage::clear_integer64_value() {
  if (_internal_has_integer64_value()) {
    rpc_oneof_.integer64_value_ = int64_t{0};
    clear_has_rpc_oneof();
  }
}
inline int64_t RpcMessage::_internal_integer64_value() const {
  if (_internal_has_integer64_value()) {
    return rpc_oneof_.integer64_value_;
  }
  return int64_t{0};
}
inline void RpcMessage::_internal_set_integer64_value(int64_t value) {
  if (!_internal_has_integer64_value()) {
    clear_rpc_oneof();
    set_has_integer64_value();
  }
  rpc_oneof_.integer64_value_ = value;
}
inline int64_t RpcMessage::integer64_value() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.integer64_value)
  return _internal_integer64_value();
}
inline void RpcMessage::set_integer64_value(int64_t value) {
  _internal_set_integer64_value(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.integer64_value)
}

// double double_value = 5;
inline bool RpcMessage::_internal_has_double_value() const {
  return rpc_oneof_case() == kDoubleValue;
}
inline bool RpcMessage::has_double_value() const {
  return _internal_has_double_value();
}
inline void RpcMessage::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void RpcMessage::clear_double_value() {
  if (_internal_has_double_value()) {
    rpc_oneof_.double_value_ = 0;
    clear_has_rpc_oneof();
  }
}
inline double RpcMessage::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return rpc_oneof_.double_value_;
  }
  return 0;
}
inline void RpcMessage::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_rpc_oneof();
    set_has_double_value();
  }
  rpc_oneof_.double_value_ = value;
}
inline double RpcMessage::double_value() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.double_value)
  return _internal_double_value();
}
inline void RpcMessage::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.double_value)
}

// bool boolean_value = 6;
inline bool RpcMessage::_internal_has_boolean_value() const {
  return rpc_oneof_case() == kBooleanValue;
}
inline bool RpcMessage::has_boolean_value() const {
  return _internal_has_boolean_value();
}
inline void RpcMessage::set_has_boolean_value() {
  _oneof_case_[0] = kBooleanValue;
}
inline void RpcMessage::clear_boolean_value() {
  if (_internal_has_boolean_value()) {
    rpc_oneof_.boolean_value_ = false;
    clear_has_rpc_oneof();
  }
}
inline bool RpcMessage::_internal_boolean_value() const {
  if (_internal_has_boolean_value()) {
    return rpc_oneof_.boolean_value_;
  }
  return false;
}
inline void RpcMessage::_internal_set_boolean_value(bool value) {
  if (!_internal_has_boolean_value()) {
    clear_rpc_oneof();
    set_has_boolean_value();
  }
  rpc_oneof_.boolean_value_ = value;
}
inline bool RpcMessage::boolean_value() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.boolean_value)
  return _internal_boolean_value();
}
inline void RpcMessage::set_boolean_value(bool value) {
  _internal_set_boolean_value(value);
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.boolean_value)
}

// string string_value = 7;
inline bool RpcMessage::_internal_has_string_value() const {
  return rpc_oneof_case() == kStringValue;
}
inline bool RpcMessage::has_string_value() const {
  return _internal_has_string_value();
}
inline void RpcMessage::set_has_string_value() {
  _oneof_case_[0] = kStringValue;
}
inline void RpcMessage::clear_string_value() {
  if (_internal_has_string_value()) {
    rpc_oneof_.string_value_.Destroy();
    clear_has_rpc_oneof();
  }
}
inline const std::string& RpcMessage::string_value() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.string_value)
  return _internal_string_value();
}
template <typename ArgT0, typename... ArgT>
inline void RpcMessage::set_string_value(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.InitDefault();
  }
  rpc_oneof_.string_value_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:openscreen.cast.RpcMessage.string_value)
}
inline std::string* RpcMessage::mutable_string_value() {
  std::string* _s = _internal_mutable_string_value();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.string_value)
  return _s;
}
inline const std::string& RpcMessage::_internal_string_value() const {
  if (_internal_has_string_value()) {
    return rpc_oneof_.string_value_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RpcMessage::_internal_set_string_value(const std::string& value) {
  if (!_internal_has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.InitDefault();
  }
  rpc_oneof_.string_value_.Set(value, GetArenaForAllocation());
}
inline std::string* RpcMessage::_internal_mutable_string_value() {
  if (!_internal_has_string_value()) {
    clear_rpc_oneof();
    set_has_string_value();
    rpc_oneof_.string_value_.InitDefault();
  }
  return rpc_oneof_.string_value_.Mutable(      GetArenaForAllocation());
}
inline std::string* RpcMessage::release_string_value() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.string_value)
  if (_internal_has_string_value()) {
    clear_has_rpc_oneof();
    return rpc_oneof_.string_value_.Release();
  } else {
    return nullptr;
  }
}
inline void RpcMessage::set_allocated_string_value(std::string* string_value) {
  if (has_rpc_oneof()) {
    clear_rpc_oneof();
  }
  if (string_value != nullptr) {
    set_has_string_value();
    rpc_oneof_.string_value_.InitAllocated(string_value, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:openscreen.cast.RpcMessage.string_value)
}

// .openscreen.cast.RendererInitialize renderer_initialize_rpc = 100;
inline bool RpcMessage::_internal_has_renderer_initialize_rpc() const {
  return rpc_oneof_case() == kRendererInitializeRpc;
}
inline bool RpcMessage::has_renderer_initialize_rpc() const {
  return _internal_has_renderer_initialize_rpc();
}
inline void RpcMessage::set_has_renderer_initialize_rpc() {
  _oneof_case_[0] = kRendererInitializeRpc;
}
inline void RpcMessage::clear_renderer_initialize_rpc() {
  if (_internal_has_renderer_initialize_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.renderer_initialize_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::RendererInitialize* RpcMessage::release_renderer_initialize_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.renderer_initialize_rpc)
  if (_internal_has_renderer_initialize_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererInitialize* temp = rpc_oneof_.renderer_initialize_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.renderer_initialize_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::RendererInitialize& RpcMessage::_internal_renderer_initialize_rpc() const {
  return _internal_has_renderer_initialize_rpc()
      ? *rpc_oneof_.renderer_initialize_rpc_
      : reinterpret_cast< ::openscreen::cast::RendererInitialize&>(::openscreen::cast::_RendererInitialize_default_instance_);
}
inline const ::openscreen::cast::RendererInitialize& RpcMessage::renderer_initialize_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.renderer_initialize_rpc)
  return _internal_renderer_initialize_rpc();
}
inline ::openscreen::cast::RendererInitialize* RpcMessage::unsafe_arena_release_renderer_initialize_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.renderer_initialize_rpc)
  if (_internal_has_renderer_initialize_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererInitialize* temp = rpc_oneof_.renderer_initialize_rpc_;
    rpc_oneof_.renderer_initialize_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_renderer_initialize_rpc(::openscreen::cast::RendererInitialize* renderer_initialize_rpc) {
  clear_rpc_oneof();
  if (renderer_initialize_rpc) {
    set_has_renderer_initialize_rpc();
    rpc_oneof_.renderer_initialize_rpc_ = renderer_initialize_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.renderer_initialize_rpc)
}
inline ::openscreen::cast::RendererInitialize* RpcMessage::_internal_mutable_renderer_initialize_rpc() {
  if (!_internal_has_renderer_initialize_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_initialize_rpc();
    rpc_oneof_.renderer_initialize_rpc_ = CreateMaybeMessage< ::openscreen::cast::RendererInitialize >(GetArenaForAllocation());
  }
  return rpc_oneof_.renderer_initialize_rpc_;
}
inline ::openscreen::cast::RendererInitialize* RpcMessage::mutable_renderer_initialize_rpc() {
  ::openscreen::cast::RendererInitialize* _msg = _internal_mutable_renderer_initialize_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.renderer_initialize_rpc)
  return _msg;
}

// .openscreen.cast.RendererFlushUntil renderer_flushuntil_rpc = 101;
inline bool RpcMessage::_internal_has_renderer_flushuntil_rpc() const {
  return rpc_oneof_case() == kRendererFlushuntilRpc;
}
inline bool RpcMessage::has_renderer_flushuntil_rpc() const {
  return _internal_has_renderer_flushuntil_rpc();
}
inline void RpcMessage::set_has_renderer_flushuntil_rpc() {
  _oneof_case_[0] = kRendererFlushuntilRpc;
}
inline void RpcMessage::clear_renderer_flushuntil_rpc() {
  if (_internal_has_renderer_flushuntil_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.renderer_flushuntil_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::RendererFlushUntil* RpcMessage::release_renderer_flushuntil_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.renderer_flushuntil_rpc)
  if (_internal_has_renderer_flushuntil_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererFlushUntil* temp = rpc_oneof_.renderer_flushuntil_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.renderer_flushuntil_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::RendererFlushUntil& RpcMessage::_internal_renderer_flushuntil_rpc() const {
  return _internal_has_renderer_flushuntil_rpc()
      ? *rpc_oneof_.renderer_flushuntil_rpc_
      : reinterpret_cast< ::openscreen::cast::RendererFlushUntil&>(::openscreen::cast::_RendererFlushUntil_default_instance_);
}
inline const ::openscreen::cast::RendererFlushUntil& RpcMessage::renderer_flushuntil_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.renderer_flushuntil_rpc)
  return _internal_renderer_flushuntil_rpc();
}
inline ::openscreen::cast::RendererFlushUntil* RpcMessage::unsafe_arena_release_renderer_flushuntil_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.renderer_flushuntil_rpc)
  if (_internal_has_renderer_flushuntil_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererFlushUntil* temp = rpc_oneof_.renderer_flushuntil_rpc_;
    rpc_oneof_.renderer_flushuntil_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_renderer_flushuntil_rpc(::openscreen::cast::RendererFlushUntil* renderer_flushuntil_rpc) {
  clear_rpc_oneof();
  if (renderer_flushuntil_rpc) {
    set_has_renderer_flushuntil_rpc();
    rpc_oneof_.renderer_flushuntil_rpc_ = renderer_flushuntil_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.renderer_flushuntil_rpc)
}
inline ::openscreen::cast::RendererFlushUntil* RpcMessage::_internal_mutable_renderer_flushuntil_rpc() {
  if (!_internal_has_renderer_flushuntil_rpc()) {
    clear_rpc_oneof();
    set_has_renderer_flushuntil_rpc();
    rpc_oneof_.renderer_flushuntil_rpc_ = CreateMaybeMessage< ::openscreen::cast::RendererFlushUntil >(GetArenaForAllocation());
  }
  return rpc_oneof_.renderer_flushuntil_rpc_;
}
inline ::openscreen::cast::RendererFlushUntil* RpcMessage::mutable_renderer_flushuntil_rpc() {
  ::openscreen::cast::RendererFlushUntil* _msg = _internal_mutable_renderer_flushuntil_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.renderer_flushuntil_rpc)
  return _msg;
}

// .openscreen.cast.AcquireDemuxer acquire_demuxer_rpc = 103;
inline bool RpcMessage::_internal_has_acquire_demuxer_rpc() const {
  return rpc_oneof_case() == kAcquireDemuxerRpc;
}
inline bool RpcMessage::has_acquire_demuxer_rpc() const {
  return _internal_has_acquire_demuxer_rpc();
}
inline void RpcMessage::set_has_acquire_demuxer_rpc() {
  _oneof_case_[0] = kAcquireDemuxerRpc;
}
inline void RpcMessage::clear_acquire_demuxer_rpc() {
  if (_internal_has_acquire_demuxer_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.acquire_demuxer_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::AcquireDemuxer* RpcMessage::release_acquire_demuxer_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.acquire_demuxer_rpc)
  if (_internal_has_acquire_demuxer_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::AcquireDemuxer* temp = rpc_oneof_.acquire_demuxer_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.acquire_demuxer_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::AcquireDemuxer& RpcMessage::_internal_acquire_demuxer_rpc() const {
  return _internal_has_acquire_demuxer_rpc()
      ? *rpc_oneof_.acquire_demuxer_rpc_
      : reinterpret_cast< ::openscreen::cast::AcquireDemuxer&>(::openscreen::cast::_AcquireDemuxer_default_instance_);
}
inline const ::openscreen::cast::AcquireDemuxer& RpcMessage::acquire_demuxer_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.acquire_demuxer_rpc)
  return _internal_acquire_demuxer_rpc();
}
inline ::openscreen::cast::AcquireDemuxer* RpcMessage::unsafe_arena_release_acquire_demuxer_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.acquire_demuxer_rpc)
  if (_internal_has_acquire_demuxer_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::AcquireDemuxer* temp = rpc_oneof_.acquire_demuxer_rpc_;
    rpc_oneof_.acquire_demuxer_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_acquire_demuxer_rpc(::openscreen::cast::AcquireDemuxer* acquire_demuxer_rpc) {
  clear_rpc_oneof();
  if (acquire_demuxer_rpc) {
    set_has_acquire_demuxer_rpc();
    rpc_oneof_.acquire_demuxer_rpc_ = acquire_demuxer_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.acquire_demuxer_rpc)
}
inline ::openscreen::cast::AcquireDemuxer* RpcMessage::_internal_mutable_acquire_demuxer_rpc() {
  if (!_internal_has_acquire_demuxer_rpc()) {
    clear_rpc_oneof();
    set_has_acquire_demuxer_rpc();
    rpc_oneof_.acquire_demuxer_rpc_ = CreateMaybeMessage< ::openscreen::cast::AcquireDemuxer >(GetArenaForAllocation());
  }
  return rpc_oneof_.acquire_demuxer_rpc_;
}
inline ::openscreen::cast::AcquireDemuxer* RpcMessage::mutable_acquire_demuxer_rpc() {
  ::openscreen::cast::AcquireDemuxer* _msg = _internal_mutable_acquire_demuxer_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.acquire_demuxer_rpc)
  return _msg;
}

// .openscreen.cast.RendererClientOnTimeUpdate rendererclient_ontimeupdate_rpc = 200;
inline bool RpcMessage::_internal_has_rendererclient_ontimeupdate_rpc() const {
  return rpc_oneof_case() == kRendererclientOntimeupdateRpc;
}
inline bool RpcMessage::has_rendererclient_ontimeupdate_rpc() const {
  return _internal_has_rendererclient_ontimeupdate_rpc();
}
inline void RpcMessage::set_has_rendererclient_ontimeupdate_rpc() {
  _oneof_case_[0] = kRendererclientOntimeupdateRpc;
}
inline void RpcMessage::clear_rendererclient_ontimeupdate_rpc() {
  if (_internal_has_rendererclient_ontimeupdate_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::RendererClientOnTimeUpdate* RpcMessage::release_rendererclient_ontimeupdate_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.rendererclient_ontimeupdate_rpc)
  if (_internal_has_rendererclient_ontimeupdate_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnTimeUpdate* temp = rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::RendererClientOnTimeUpdate& RpcMessage::_internal_rendererclient_ontimeupdate_rpc() const {
  return _internal_has_rendererclient_ontimeupdate_rpc()
      ? *rpc_oneof_.rendererclient_ontimeupdate_rpc_
      : reinterpret_cast< ::openscreen::cast::RendererClientOnTimeUpdate&>(::openscreen::cast::_RendererClientOnTimeUpdate_default_instance_);
}
inline const ::openscreen::cast::RendererClientOnTimeUpdate& RpcMessage::rendererclient_ontimeupdate_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.rendererclient_ontimeupdate_rpc)
  return _internal_rendererclient_ontimeupdate_rpc();
}
inline ::openscreen::cast::RendererClientOnTimeUpdate* RpcMessage::unsafe_arena_release_rendererclient_ontimeupdate_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.rendererclient_ontimeupdate_rpc)
  if (_internal_has_rendererclient_ontimeupdate_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnTimeUpdate* temp = rpc_oneof_.rendererclient_ontimeupdate_rpc_;
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_rendererclient_ontimeupdate_rpc(::openscreen::cast::RendererClientOnTimeUpdate* rendererclient_ontimeupdate_rpc) {
  clear_rpc_oneof();
  if (rendererclient_ontimeupdate_rpc) {
    set_has_rendererclient_ontimeupdate_rpc();
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = rendererclient_ontimeupdate_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.rendererclient_ontimeupdate_rpc)
}
inline ::openscreen::cast::RendererClientOnTimeUpdate* RpcMessage::_internal_mutable_rendererclient_ontimeupdate_rpc() {
  if (!_internal_has_rendererclient_ontimeupdate_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_ontimeupdate_rpc();
    rpc_oneof_.rendererclient_ontimeupdate_rpc_ = CreateMaybeMessage< ::openscreen::cast::RendererClientOnTimeUpdate >(GetArenaForAllocation());
  }
  return rpc_oneof_.rendererclient_ontimeupdate_rpc_;
}
inline ::openscreen::cast::RendererClientOnTimeUpdate* RpcMessage::mutable_rendererclient_ontimeupdate_rpc() {
  ::openscreen::cast::RendererClientOnTimeUpdate* _msg = _internal_mutable_rendererclient_ontimeupdate_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.rendererclient_ontimeupdate_rpc)
  return _msg;
}

// .openscreen.cast.Size rendererclient_onvideonatualsizechange_rpc = 201;
inline bool RpcMessage::_internal_has_rendererclient_onvideonatualsizechange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnvideonatualsizechangeRpc;
}
inline bool RpcMessage::has_rendererclient_onvideonatualsizechange_rpc() const {
  return _internal_has_rendererclient_onvideonatualsizechange_rpc();
}
inline void RpcMessage::set_has_rendererclient_onvideonatualsizechange_rpc() {
  _oneof_case_[0] = kRendererclientOnvideonatualsizechangeRpc;
}
inline void RpcMessage::clear_rendererclient_onvideonatualsizechange_rpc() {
  if (_internal_has_rendererclient_onvideonatualsizechange_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::Size* RpcMessage::release_rendererclient_onvideonatualsizechange_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  if (_internal_has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::Size* temp = rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::Size& RpcMessage::_internal_rendererclient_onvideonatualsizechange_rpc() const {
  return _internal_has_rendererclient_onvideonatualsizechange_rpc()
      ? *rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_
      : reinterpret_cast< ::openscreen::cast::Size&>(::openscreen::cast::_Size_default_instance_);
}
inline const ::openscreen::cast::Size& RpcMessage::rendererclient_onvideonatualsizechange_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  return _internal_rendererclient_onvideonatualsizechange_rpc();
}
inline ::openscreen::cast::Size* RpcMessage::unsafe_arena_release_rendererclient_onvideonatualsizechange_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  if (_internal_has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::Size* temp = rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_rendererclient_onvideonatualsizechange_rpc(::openscreen::cast::Size* rendererclient_onvideonatualsizechange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onvideonatualsizechange_rpc) {
    set_has_rendererclient_onvideonatualsizechange_rpc();
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = rendererclient_onvideonatualsizechange_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
}
inline ::openscreen::cast::Size* RpcMessage::_internal_mutable_rendererclient_onvideonatualsizechange_rpc() {
  if (!_internal_has_rendererclient_onvideonatualsizechange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onvideonatualsizechange_rpc();
    rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_ = CreateMaybeMessage< ::openscreen::cast::Size >(GetArenaForAllocation());
  }
  return rpc_oneof_.rendererclient_onvideonatualsizechange_rpc_;
}
inline ::openscreen::cast::Size* RpcMessage::mutable_rendererclient_onvideonatualsizechange_rpc() {
  ::openscreen::cast::Size* _msg = _internal_mutable_rendererclient_onvideonatualsizechange_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.rendererclient_onvideonatualsizechange_rpc)
  return _msg;
}

// .openscreen.cast.PipelineStatistics rendererclient_onstatisticsupdate_rpc = 202;
inline bool RpcMessage::_internal_has_rendererclient_onstatisticsupdate_rpc() const {
  return rpc_oneof_case() == kRendererclientOnstatisticsupdateRpc;
}
inline bool RpcMessage::has_rendererclient_onstatisticsupdate_rpc() const {
  return _internal_has_rendererclient_onstatisticsupdate_rpc();
}
inline void RpcMessage::set_has_rendererclient_onstatisticsupdate_rpc() {
  _oneof_case_[0] = kRendererclientOnstatisticsupdateRpc;
}
inline void RpcMessage::clear_rendererclient_onstatisticsupdate_rpc() {
  if (_internal_has_rendererclient_onstatisticsupdate_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::PipelineStatistics* RpcMessage::release_rendererclient_onstatisticsupdate_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  if (_internal_has_rendererclient_onstatisticsupdate_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::PipelineStatistics* temp = rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::PipelineStatistics& RpcMessage::_internal_rendererclient_onstatisticsupdate_rpc() const {
  return _internal_has_rendererclient_onstatisticsupdate_rpc()
      ? *rpc_oneof_.rendererclient_onstatisticsupdate_rpc_
      : reinterpret_cast< ::openscreen::cast::PipelineStatistics&>(::openscreen::cast::_PipelineStatistics_default_instance_);
}
inline const ::openscreen::cast::PipelineStatistics& RpcMessage::rendererclient_onstatisticsupdate_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  return _internal_rendererclient_onstatisticsupdate_rpc();
}
inline ::openscreen::cast::PipelineStatistics* RpcMessage::unsafe_arena_release_rendererclient_onstatisticsupdate_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  if (_internal_has_rendererclient_onstatisticsupdate_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::PipelineStatistics* temp = rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_rendererclient_onstatisticsupdate_rpc(::openscreen::cast::PipelineStatistics* rendererclient_onstatisticsupdate_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onstatisticsupdate_rpc) {
    set_has_rendererclient_onstatisticsupdate_rpc();
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = rendererclient_onstatisticsupdate_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.rendererclient_onstatisticsupdate_rpc)
}
inline ::openscreen::cast::PipelineStatistics* RpcMessage::_internal_mutable_rendererclient_onstatisticsupdate_rpc() {
  if (!_internal_has_rendererclient_onstatisticsupdate_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onstatisticsupdate_rpc();
    rpc_oneof_.rendererclient_onstatisticsupdate_rpc_ = CreateMaybeMessage< ::openscreen::cast::PipelineStatistics >(GetArenaForAllocation());
  }
  return rpc_oneof_.rendererclient_onstatisticsupdate_rpc_;
}
inline ::openscreen::cast::PipelineStatistics* RpcMessage::mutable_rendererclient_onstatisticsupdate_rpc() {
  ::openscreen::cast::PipelineStatistics* _msg = _internal_mutable_rendererclient_onstatisticsupdate_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.rendererclient_onstatisticsupdate_rpc)
  return _msg;
}

// .openscreen.cast.RendererClientOnBufferingStateChange rendererclient_onbufferingstatechange_rpc = 203;
inline bool RpcMessage::_internal_has_rendererclient_onbufferingstatechange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnbufferingstatechangeRpc;
}
inline bool RpcMessage::has_rendererclient_onbufferingstatechange_rpc() const {
  return _internal_has_rendererclient_onbufferingstatechange_rpc();
}
inline void RpcMessage::set_has_rendererclient_onbufferingstatechange_rpc() {
  _oneof_case_[0] = kRendererclientOnbufferingstatechangeRpc;
}
inline void RpcMessage::clear_rendererclient_onbufferingstatechange_rpc() {
  if (_internal_has_rendererclient_onbufferingstatechange_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::RendererClientOnBufferingStateChange* RpcMessage::release_rendererclient_onbufferingstatechange_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  if (_internal_has_rendererclient_onbufferingstatechange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnBufferingStateChange* temp = rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::RendererClientOnBufferingStateChange& RpcMessage::_internal_rendererclient_onbufferingstatechange_rpc() const {
  return _internal_has_rendererclient_onbufferingstatechange_rpc()
      ? *rpc_oneof_.rendererclient_onbufferingstatechange_rpc_
      : reinterpret_cast< ::openscreen::cast::RendererClientOnBufferingStateChange&>(::openscreen::cast::_RendererClientOnBufferingStateChange_default_instance_);
}
inline const ::openscreen::cast::RendererClientOnBufferingStateChange& RpcMessage::rendererclient_onbufferingstatechange_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  return _internal_rendererclient_onbufferingstatechange_rpc();
}
inline ::openscreen::cast::RendererClientOnBufferingStateChange* RpcMessage::unsafe_arena_release_rendererclient_onbufferingstatechange_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  if (_internal_has_rendererclient_onbufferingstatechange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnBufferingStateChange* temp = rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_rendererclient_onbufferingstatechange_rpc(::openscreen::cast::RendererClientOnBufferingStateChange* rendererclient_onbufferingstatechange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onbufferingstatechange_rpc) {
    set_has_rendererclient_onbufferingstatechange_rpc();
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = rendererclient_onbufferingstatechange_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.rendererclient_onbufferingstatechange_rpc)
}
inline ::openscreen::cast::RendererClientOnBufferingStateChange* RpcMessage::_internal_mutable_rendererclient_onbufferingstatechange_rpc() {
  if (!_internal_has_rendererclient_onbufferingstatechange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onbufferingstatechange_rpc();
    rpc_oneof_.rendererclient_onbufferingstatechange_rpc_ = CreateMaybeMessage< ::openscreen::cast::RendererClientOnBufferingStateChange >(GetArenaForAllocation());
  }
  return rpc_oneof_.rendererclient_onbufferingstatechange_rpc_;
}
inline ::openscreen::cast::RendererClientOnBufferingStateChange* RpcMessage::mutable_rendererclient_onbufferingstatechange_rpc() {
  ::openscreen::cast::RendererClientOnBufferingStateChange* _msg = _internal_mutable_rendererclient_onbufferingstatechange_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.rendererclient_onbufferingstatechange_rpc)
  return _msg;
}

// .openscreen.cast.RendererClientOnAudioConfigChange rendererclient_onaudioconfigchange_rpc = 204;
inline bool RpcMessage::_internal_has_rendererclient_onaudioconfigchange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnaudioconfigchangeRpc;
}
inline bool RpcMessage::has_rendererclient_onaudioconfigchange_rpc() const {
  return _internal_has_rendererclient_onaudioconfigchange_rpc();
}
inline void RpcMessage::set_has_rendererclient_onaudioconfigchange_rpc() {
  _oneof_case_[0] = kRendererclientOnaudioconfigchangeRpc;
}
inline void RpcMessage::clear_rendererclient_onaudioconfigchange_rpc() {
  if (_internal_has_rendererclient_onaudioconfigchange_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::RendererClientOnAudioConfigChange* RpcMessage::release_rendererclient_onaudioconfigchange_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  if (_internal_has_rendererclient_onaudioconfigchange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnAudioConfigChange* temp = rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::RendererClientOnAudioConfigChange& RpcMessage::_internal_rendererclient_onaudioconfigchange_rpc() const {
  return _internal_has_rendererclient_onaudioconfigchange_rpc()
      ? *rpc_oneof_.rendererclient_onaudioconfigchange_rpc_
      : reinterpret_cast< ::openscreen::cast::RendererClientOnAudioConfigChange&>(::openscreen::cast::_RendererClientOnAudioConfigChange_default_instance_);
}
inline const ::openscreen::cast::RendererClientOnAudioConfigChange& RpcMessage::rendererclient_onaudioconfigchange_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  return _internal_rendererclient_onaudioconfigchange_rpc();
}
inline ::openscreen::cast::RendererClientOnAudioConfigChange* RpcMessage::unsafe_arena_release_rendererclient_onaudioconfigchange_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  if (_internal_has_rendererclient_onaudioconfigchange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnAudioConfigChange* temp = rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_rendererclient_onaudioconfigchange_rpc(::openscreen::cast::RendererClientOnAudioConfigChange* rendererclient_onaudioconfigchange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onaudioconfigchange_rpc) {
    set_has_rendererclient_onaudioconfigchange_rpc();
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = rendererclient_onaudioconfigchange_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.rendererclient_onaudioconfigchange_rpc)
}
inline ::openscreen::cast::RendererClientOnAudioConfigChange* RpcMessage::_internal_mutable_rendererclient_onaudioconfigchange_rpc() {
  if (!_internal_has_rendererclient_onaudioconfigchange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onaudioconfigchange_rpc();
    rpc_oneof_.rendererclient_onaudioconfigchange_rpc_ = CreateMaybeMessage< ::openscreen::cast::RendererClientOnAudioConfigChange >(GetArenaForAllocation());
  }
  return rpc_oneof_.rendererclient_onaudioconfigchange_rpc_;
}
inline ::openscreen::cast::RendererClientOnAudioConfigChange* RpcMessage::mutable_rendererclient_onaudioconfigchange_rpc() {
  ::openscreen::cast::RendererClientOnAudioConfigChange* _msg = _internal_mutable_rendererclient_onaudioconfigchange_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.rendererclient_onaudioconfigchange_rpc)
  return _msg;
}

// .openscreen.cast.RendererClientOnVideoConfigChange rendererclient_onvideoconfigchange_rpc = 205;
inline bool RpcMessage::_internal_has_rendererclient_onvideoconfigchange_rpc() const {
  return rpc_oneof_case() == kRendererclientOnvideoconfigchangeRpc;
}
inline bool RpcMessage::has_rendererclient_onvideoconfigchange_rpc() const {
  return _internal_has_rendererclient_onvideoconfigchange_rpc();
}
inline void RpcMessage::set_has_rendererclient_onvideoconfigchange_rpc() {
  _oneof_case_[0] = kRendererclientOnvideoconfigchangeRpc;
}
inline void RpcMessage::clear_rendererclient_onvideoconfigchange_rpc() {
  if (_internal_has_rendererclient_onvideoconfigchange_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::RendererClientOnVideoConfigChange* RpcMessage::release_rendererclient_onvideoconfigchange_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  if (_internal_has_rendererclient_onvideoconfigchange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnVideoConfigChange* temp = rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::RendererClientOnVideoConfigChange& RpcMessage::_internal_rendererclient_onvideoconfigchange_rpc() const {
  return _internal_has_rendererclient_onvideoconfigchange_rpc()
      ? *rpc_oneof_.rendererclient_onvideoconfigchange_rpc_
      : reinterpret_cast< ::openscreen::cast::RendererClientOnVideoConfigChange&>(::openscreen::cast::_RendererClientOnVideoConfigChange_default_instance_);
}
inline const ::openscreen::cast::RendererClientOnVideoConfigChange& RpcMessage::rendererclient_onvideoconfigchange_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  return _internal_rendererclient_onvideoconfigchange_rpc();
}
inline ::openscreen::cast::RendererClientOnVideoConfigChange* RpcMessage::unsafe_arena_release_rendererclient_onvideoconfigchange_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  if (_internal_has_rendererclient_onvideoconfigchange_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::RendererClientOnVideoConfigChange* temp = rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_rendererclient_onvideoconfigchange_rpc(::openscreen::cast::RendererClientOnVideoConfigChange* rendererclient_onvideoconfigchange_rpc) {
  clear_rpc_oneof();
  if (rendererclient_onvideoconfigchange_rpc) {
    set_has_rendererclient_onvideoconfigchange_rpc();
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = rendererclient_onvideoconfigchange_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.rendererclient_onvideoconfigchange_rpc)
}
inline ::openscreen::cast::RendererClientOnVideoConfigChange* RpcMessage::_internal_mutable_rendererclient_onvideoconfigchange_rpc() {
  if (!_internal_has_rendererclient_onvideoconfigchange_rpc()) {
    clear_rpc_oneof();
    set_has_rendererclient_onvideoconfigchange_rpc();
    rpc_oneof_.rendererclient_onvideoconfigchange_rpc_ = CreateMaybeMessage< ::openscreen::cast::RendererClientOnVideoConfigChange >(GetArenaForAllocation());
  }
  return rpc_oneof_.rendererclient_onvideoconfigchange_rpc_;
}
inline ::openscreen::cast::RendererClientOnVideoConfigChange* RpcMessage::mutable_rendererclient_onvideoconfigchange_rpc() {
  ::openscreen::cast::RendererClientOnVideoConfigChange* _msg = _internal_mutable_rendererclient_onvideoconfigchange_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.rendererclient_onvideoconfigchange_rpc)
  return _msg;
}

// .openscreen.cast.DemuxerStreamReadUntil demuxerstream_readuntil_rpc = 300;
inline bool RpcMessage::_internal_has_demuxerstream_readuntil_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamReaduntilRpc;
}
inline bool RpcMessage::has_demuxerstream_readuntil_rpc() const {
  return _internal_has_demuxerstream_readuntil_rpc();
}
inline void RpcMessage::set_has_demuxerstream_readuntil_rpc() {
  _oneof_case_[0] = kDemuxerstreamReaduntilRpc;
}
inline void RpcMessage::clear_demuxerstream_readuntil_rpc() {
  if (_internal_has_demuxerstream_readuntil_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.demuxerstream_readuntil_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::DemuxerStreamReadUntil* RpcMessage::release_demuxerstream_readuntil_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.demuxerstream_readuntil_rpc)
  if (_internal_has_demuxerstream_readuntil_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::DemuxerStreamReadUntil* temp = rpc_oneof_.demuxerstream_readuntil_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.demuxerstream_readuntil_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::DemuxerStreamReadUntil& RpcMessage::_internal_demuxerstream_readuntil_rpc() const {
  return _internal_has_demuxerstream_readuntil_rpc()
      ? *rpc_oneof_.demuxerstream_readuntil_rpc_
      : reinterpret_cast< ::openscreen::cast::DemuxerStreamReadUntil&>(::openscreen::cast::_DemuxerStreamReadUntil_default_instance_);
}
inline const ::openscreen::cast::DemuxerStreamReadUntil& RpcMessage::demuxerstream_readuntil_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.demuxerstream_readuntil_rpc)
  return _internal_demuxerstream_readuntil_rpc();
}
inline ::openscreen::cast::DemuxerStreamReadUntil* RpcMessage::unsafe_arena_release_demuxerstream_readuntil_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.demuxerstream_readuntil_rpc)
  if (_internal_has_demuxerstream_readuntil_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::DemuxerStreamReadUntil* temp = rpc_oneof_.demuxerstream_readuntil_rpc_;
    rpc_oneof_.demuxerstream_readuntil_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_demuxerstream_readuntil_rpc(::openscreen::cast::DemuxerStreamReadUntil* demuxerstream_readuntil_rpc) {
  clear_rpc_oneof();
  if (demuxerstream_readuntil_rpc) {
    set_has_demuxerstream_readuntil_rpc();
    rpc_oneof_.demuxerstream_readuntil_rpc_ = demuxerstream_readuntil_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.demuxerstream_readuntil_rpc)
}
inline ::openscreen::cast::DemuxerStreamReadUntil* RpcMessage::_internal_mutable_demuxerstream_readuntil_rpc() {
  if (!_internal_has_demuxerstream_readuntil_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_readuntil_rpc();
    rpc_oneof_.demuxerstream_readuntil_rpc_ = CreateMaybeMessage< ::openscreen::cast::DemuxerStreamReadUntil >(GetArenaForAllocation());
  }
  return rpc_oneof_.demuxerstream_readuntil_rpc_;
}
inline ::openscreen::cast::DemuxerStreamReadUntil* RpcMessage::mutable_demuxerstream_readuntil_rpc() {
  ::openscreen::cast::DemuxerStreamReadUntil* _msg = _internal_mutable_demuxerstream_readuntil_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.demuxerstream_readuntil_rpc)
  return _msg;
}

// .openscreen.cast.DemuxerStreamInitializeCallback demuxerstream_initializecb_rpc = 400;
inline bool RpcMessage::_internal_has_demuxerstream_initializecb_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamInitializecbRpc;
}
inline bool RpcMessage::has_demuxerstream_initializecb_rpc() const {
  return _internal_has_demuxerstream_initializecb_rpc();
}
inline void RpcMessage::set_has_demuxerstream_initializecb_rpc() {
  _oneof_case_[0] = kDemuxerstreamInitializecbRpc;
}
inline void RpcMessage::clear_demuxerstream_initializecb_rpc() {
  if (_internal_has_demuxerstream_initializecb_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.demuxerstream_initializecb_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::DemuxerStreamInitializeCallback* RpcMessage::release_demuxerstream_initializecb_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.demuxerstream_initializecb_rpc)
  if (_internal_has_demuxerstream_initializecb_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::DemuxerStreamInitializeCallback* temp = rpc_oneof_.demuxerstream_initializecb_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.demuxerstream_initializecb_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::DemuxerStreamInitializeCallback& RpcMessage::_internal_demuxerstream_initializecb_rpc() const {
  return _internal_has_demuxerstream_initializecb_rpc()
      ? *rpc_oneof_.demuxerstream_initializecb_rpc_
      : reinterpret_cast< ::openscreen::cast::DemuxerStreamInitializeCallback&>(::openscreen::cast::_DemuxerStreamInitializeCallback_default_instance_);
}
inline const ::openscreen::cast::DemuxerStreamInitializeCallback& RpcMessage::demuxerstream_initializecb_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.demuxerstream_initializecb_rpc)
  return _internal_demuxerstream_initializecb_rpc();
}
inline ::openscreen::cast::DemuxerStreamInitializeCallback* RpcMessage::unsafe_arena_release_demuxerstream_initializecb_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.demuxerstream_initializecb_rpc)
  if (_internal_has_demuxerstream_initializecb_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::DemuxerStreamInitializeCallback* temp = rpc_oneof_.demuxerstream_initializecb_rpc_;
    rpc_oneof_.demuxerstream_initializecb_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_demuxerstream_initializecb_rpc(::openscreen::cast::DemuxerStreamInitializeCallback* demuxerstream_initializecb_rpc) {
  clear_rpc_oneof();
  if (demuxerstream_initializecb_rpc) {
    set_has_demuxerstream_initializecb_rpc();
    rpc_oneof_.demuxerstream_initializecb_rpc_ = demuxerstream_initializecb_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.demuxerstream_initializecb_rpc)
}
inline ::openscreen::cast::DemuxerStreamInitializeCallback* RpcMessage::_internal_mutable_demuxerstream_initializecb_rpc() {
  if (!_internal_has_demuxerstream_initializecb_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_initializecb_rpc();
    rpc_oneof_.demuxerstream_initializecb_rpc_ = CreateMaybeMessage< ::openscreen::cast::DemuxerStreamInitializeCallback >(GetArenaForAllocation());
  }
  return rpc_oneof_.demuxerstream_initializecb_rpc_;
}
inline ::openscreen::cast::DemuxerStreamInitializeCallback* RpcMessage::mutable_demuxerstream_initializecb_rpc() {
  ::openscreen::cast::DemuxerStreamInitializeCallback* _msg = _internal_mutable_demuxerstream_initializecb_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.demuxerstream_initializecb_rpc)
  return _msg;
}

// .openscreen.cast.DemuxerStreamReadUntilCallback demuxerstream_readuntilcb_rpc = 401;
inline bool RpcMessage::_internal_has_demuxerstream_readuntilcb_rpc() const {
  return rpc_oneof_case() == kDemuxerstreamReaduntilcbRpc;
}
inline bool RpcMessage::has_demuxerstream_readuntilcb_rpc() const {
  return _internal_has_demuxerstream_readuntilcb_rpc();
}
inline void RpcMessage::set_has_demuxerstream_readuntilcb_rpc() {
  _oneof_case_[0] = kDemuxerstreamReaduntilcbRpc;
}
inline void RpcMessage::clear_demuxerstream_readuntilcb_rpc() {
  if (_internal_has_demuxerstream_readuntilcb_rpc()) {
    if (GetArenaForAllocation() == nullptr) {
      delete rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    }
    clear_has_rpc_oneof();
  }
}
inline ::openscreen::cast::DemuxerStreamReadUntilCallback* RpcMessage::release_demuxerstream_readuntilcb_rpc() {
  // @@protoc_insertion_point(field_release:openscreen.cast.RpcMessage.demuxerstream_readuntilcb_rpc)
  if (_internal_has_demuxerstream_readuntilcb_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::DemuxerStreamReadUntilCallback* temp = rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::openscreen::cast::DemuxerStreamReadUntilCallback& RpcMessage::_internal_demuxerstream_readuntilcb_rpc() const {
  return _internal_has_demuxerstream_readuntilcb_rpc()
      ? *rpc_oneof_.demuxerstream_readuntilcb_rpc_
      : reinterpret_cast< ::openscreen::cast::DemuxerStreamReadUntilCallback&>(::openscreen::cast::_DemuxerStreamReadUntilCallback_default_instance_);
}
inline const ::openscreen::cast::DemuxerStreamReadUntilCallback& RpcMessage::demuxerstream_readuntilcb_rpc() const {
  // @@protoc_insertion_point(field_get:openscreen.cast.RpcMessage.demuxerstream_readuntilcb_rpc)
  return _internal_demuxerstream_readuntilcb_rpc();
}
inline ::openscreen::cast::DemuxerStreamReadUntilCallback* RpcMessage::unsafe_arena_release_demuxerstream_readuntilcb_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:openscreen.cast.RpcMessage.demuxerstream_readuntilcb_rpc)
  if (_internal_has_demuxerstream_readuntilcb_rpc()) {
    clear_has_rpc_oneof();
    ::openscreen::cast::DemuxerStreamReadUntilCallback* temp = rpc_oneof_.demuxerstream_readuntilcb_rpc_;
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RpcMessage::unsafe_arena_set_allocated_demuxerstream_readuntilcb_rpc(::openscreen::cast::DemuxerStreamReadUntilCallback* demuxerstream_readuntilcb_rpc) {
  clear_rpc_oneof();
  if (demuxerstream_readuntilcb_rpc) {
    set_has_demuxerstream_readuntilcb_rpc();
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = demuxerstream_readuntilcb_rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:openscreen.cast.RpcMessage.demuxerstream_readuntilcb_rpc)
}
inline ::openscreen::cast::DemuxerStreamReadUntilCallback* RpcMessage::_internal_mutable_demuxerstream_readuntilcb_rpc() {
  if (!_internal_has_demuxerstream_readuntilcb_rpc()) {
    clear_rpc_oneof();
    set_has_demuxerstream_readuntilcb_rpc();
    rpc_oneof_.demuxerstream_readuntilcb_rpc_ = CreateMaybeMessage< ::openscreen::cast::DemuxerStreamReadUntilCallback >(GetArenaForAllocation());
  }
  return rpc_oneof_.demuxerstream_readuntilcb_rpc_;
}
inline ::openscreen::cast::DemuxerStreamReadUntilCallback* RpcMessage::mutable_demuxerstream_readuntilcb_rpc() {
  ::openscreen::cast::DemuxerStreamReadUntilCallback* _msg = _internal_mutable_demuxerstream_readuntilcb_rpc();
  // @@protoc_insertion_point(field_mutable:openscreen.cast.RpcMessage.demuxerstream_readuntilcb_rpc)
  return _msg;
}

inline bool RpcMessage::has_rpc_oneof() const {
  return rpc_oneof_case() != RPC_ONEOF_NOT_SET;
}
inline void RpcMessage::clear_has_rpc_oneof() {
  _oneof_case_[0] = RPC_ONEOF_NOT_SET;
}
inline RpcMessage::RpcOneofCase RpcMessage::rpc_oneof_case() const {
  return RpcMessage::RpcOneofCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace cast
}  // namespace openscreen

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::openscreen::cast::AudioDecoderConfig_Codec> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::AudioDecoderConfig_SampleFormat> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::AudioDecoderConfig_ChannelLayout> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::VideoDecoderConfig_Codec> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::VideoDecoderConfig_Profile> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::VideoDecoderConfig_Format> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::VideoDecoderConfig_ColorSpace> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::RendererClientOnBufferingStateChange_State> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::DemuxerStreamReadUntilCallback_Status> : ::std::true_type {};
template <> struct is_proto_enum< ::openscreen::cast::RpcMessage_RpcProc> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_remoting_2eproto
