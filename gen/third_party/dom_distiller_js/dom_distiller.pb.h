// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dom_distiller.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dom_5fdistiller_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dom_5fdistiller_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dom_5fdistiller_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dom_5fdistiller_2eproto {
  static const uint32_t offsets[];
};
namespace dom_distiller {
namespace proto {
class DebugInfo;
struct DebugInfoDefaultTypeInternal;
extern DebugInfoDefaultTypeInternal _DebugInfo_default_instance_;
class DistilledContent;
struct DistilledContentDefaultTypeInternal;
extern DistilledContentDefaultTypeInternal _DistilledContent_default_instance_;
class DomDistillerOptions;
struct DomDistillerOptionsDefaultTypeInternal;
extern DomDistillerOptionsDefaultTypeInternal _DomDistillerOptions_default_instance_;
class DomDistillerResult;
struct DomDistillerResultDefaultTypeInternal;
extern DomDistillerResultDefaultTypeInternal _DomDistillerResult_default_instance_;
class DomDistillerResult_ContentImage;
struct DomDistillerResult_ContentImageDefaultTypeInternal;
extern DomDistillerResult_ContentImageDefaultTypeInternal _DomDistillerResult_ContentImage_default_instance_;
class MarkupArticle;
struct MarkupArticleDefaultTypeInternal;
extern MarkupArticleDefaultTypeInternal _MarkupArticle_default_instance_;
class MarkupImage;
struct MarkupImageDefaultTypeInternal;
extern MarkupImageDefaultTypeInternal _MarkupImage_default_instance_;
class MarkupInfo;
struct MarkupInfoDefaultTypeInternal;
extern MarkupInfoDefaultTypeInternal _MarkupInfo_default_instance_;
class PaginationInfo;
struct PaginationInfoDefaultTypeInternal;
extern PaginationInfoDefaultTypeInternal _PaginationInfo_default_instance_;
class StatisticsInfo;
struct StatisticsInfoDefaultTypeInternal;
extern StatisticsInfoDefaultTypeInternal _StatisticsInfo_default_instance_;
class TimingEntry;
struct TimingEntryDefaultTypeInternal;
extern TimingEntryDefaultTypeInternal _TimingEntry_default_instance_;
class TimingInfo;
struct TimingInfoDefaultTypeInternal;
extern TimingInfoDefaultTypeInternal _TimingInfo_default_instance_;
}  // namespace proto
}  // namespace dom_distiller
PROTOBUF_NAMESPACE_OPEN
template<> ::dom_distiller::proto::DebugInfo* Arena::CreateMaybeMessage<::dom_distiller::proto::DebugInfo>(Arena*);
template<> ::dom_distiller::proto::DistilledContent* Arena::CreateMaybeMessage<::dom_distiller::proto::DistilledContent>(Arena*);
template<> ::dom_distiller::proto::DomDistillerOptions* Arena::CreateMaybeMessage<::dom_distiller::proto::DomDistillerOptions>(Arena*);
template<> ::dom_distiller::proto::DomDistillerResult* Arena::CreateMaybeMessage<::dom_distiller::proto::DomDistillerResult>(Arena*);
template<> ::dom_distiller::proto::DomDistillerResult_ContentImage* Arena::CreateMaybeMessage<::dom_distiller::proto::DomDistillerResult_ContentImage>(Arena*);
template<> ::dom_distiller::proto::MarkupArticle* Arena::CreateMaybeMessage<::dom_distiller::proto::MarkupArticle>(Arena*);
template<> ::dom_distiller::proto::MarkupImage* Arena::CreateMaybeMessage<::dom_distiller::proto::MarkupImage>(Arena*);
template<> ::dom_distiller::proto::MarkupInfo* Arena::CreateMaybeMessage<::dom_distiller::proto::MarkupInfo>(Arena*);
template<> ::dom_distiller::proto::PaginationInfo* Arena::CreateMaybeMessage<::dom_distiller::proto::PaginationInfo>(Arena*);
template<> ::dom_distiller::proto::StatisticsInfo* Arena::CreateMaybeMessage<::dom_distiller::proto::StatisticsInfo>(Arena*);
template<> ::dom_distiller::proto::TimingEntry* Arena::CreateMaybeMessage<::dom_distiller::proto::TimingEntry>(Arena*);
template<> ::dom_distiller::proto::TimingInfo* Arena::CreateMaybeMessage<::dom_distiller::proto::TimingInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dom_distiller {
namespace proto {

// ===================================================================

class DistilledContent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.DistilledContent) */ {
 public:
  inline DistilledContent() : DistilledContent(nullptr) {}
  ~DistilledContent() override;
  explicit PROTOBUF_CONSTEXPR DistilledContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DistilledContent(const DistilledContent& from);
  DistilledContent(DistilledContent&& from) noexcept
    : DistilledContent() {
    *this = ::std::move(from);
  }

  inline DistilledContent& operator=(const DistilledContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline DistilledContent& operator=(DistilledContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DistilledContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const DistilledContent* internal_default_instance() {
    return reinterpret_cast<const DistilledContent*>(
               &_DistilledContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DistilledContent& a, DistilledContent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DistilledContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DistilledContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DistilledContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DistilledContent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DistilledContent& from);
  void MergeFrom(const DistilledContent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DistilledContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.DistilledContent";
  }
  protected:
  explicit DistilledContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHtmlFieldNumber = 1,
  };
  // optional string html = 1;
  bool has_html() const;
  private:
  bool _internal_has_html() const;
  public:
  void clear_html();
  const std::string& html() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_html(ArgT0&& arg0, ArgT... args);
  std::string* mutable_html();
  PROTOBUF_NODISCARD std::string* release_html();
  void set_allocated_html(std::string* html);
  private:
  const std::string& _internal_html() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_html(const std::string& value);
  std::string* _internal_mutable_html();
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.DistilledContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr html_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class PaginationInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.PaginationInfo) */ {
 public:
  inline PaginationInfo() : PaginationInfo(nullptr) {}
  ~PaginationInfo() override;
  explicit PROTOBUF_CONSTEXPR PaginationInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaginationInfo(const PaginationInfo& from);
  PaginationInfo(PaginationInfo&& from) noexcept
    : PaginationInfo() {
    *this = ::std::move(from);
  }

  inline PaginationInfo& operator=(const PaginationInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaginationInfo& operator=(PaginationInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PaginationInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaginationInfo* internal_default_instance() {
    return reinterpret_cast<const PaginationInfo*>(
               &_PaginationInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PaginationInfo& a, PaginationInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PaginationInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaginationInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaginationInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaginationInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PaginationInfo& from);
  void MergeFrom(const PaginationInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PaginationInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.PaginationInfo";
  }
  protected:
  explicit PaginationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNextPageFieldNumber = 1,
    kPrevPageFieldNumber = 2,
    kCanonicalPageFieldNumber = 3,
  };
  // optional string next_page = 1;
  bool has_next_page() const;
  private:
  bool _internal_has_next_page() const;
  public:
  void clear_next_page();
  const std::string& next_page() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page();
  PROTOBUF_NODISCARD std::string* release_next_page();
  void set_allocated_next_page(std::string* next_page);
  private:
  const std::string& _internal_next_page() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page(const std::string& value);
  std::string* _internal_mutable_next_page();
  public:

  // optional string prev_page = 2;
  bool has_prev_page() const;
  private:
  bool _internal_has_prev_page() const;
  public:
  void clear_prev_page();
  const std::string& prev_page() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_prev_page(ArgT0&& arg0, ArgT... args);
  std::string* mutable_prev_page();
  PROTOBUF_NODISCARD std::string* release_prev_page();
  void set_allocated_prev_page(std::string* prev_page);
  private:
  const std::string& _internal_prev_page() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_prev_page(const std::string& value);
  std::string* _internal_mutable_prev_page();
  public:

  // optional string canonical_page = 3;
  bool has_canonical_page() const;
  private:
  bool _internal_has_canonical_page() const;
  public:
  void clear_canonical_page();
  const std::string& canonical_page() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_canonical_page(ArgT0&& arg0, ArgT... args);
  std::string* mutable_canonical_page();
  PROTOBUF_NODISCARD std::string* release_canonical_page();
  void set_allocated_canonical_page(std::string* canonical_page);
  private:
  const std::string& _internal_canonical_page() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_canonical_page(const std::string& value);
  std::string* _internal_mutable_canonical_page();
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.PaginationInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr prev_page_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr canonical_page_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class MarkupArticle final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.MarkupArticle) */ {
 public:
  inline MarkupArticle() : MarkupArticle(nullptr) {}
  ~MarkupArticle() override;
  explicit PROTOBUF_CONSTEXPR MarkupArticle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkupArticle(const MarkupArticle& from);
  MarkupArticle(MarkupArticle&& from) noexcept
    : MarkupArticle() {
    *this = ::std::move(from);
  }

  inline MarkupArticle& operator=(const MarkupArticle& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkupArticle& operator=(MarkupArticle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MarkupArticle& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkupArticle* internal_default_instance() {
    return reinterpret_cast<const MarkupArticle*>(
               &_MarkupArticle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MarkupArticle& a, MarkupArticle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MarkupArticle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkupArticle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkupArticle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkupArticle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MarkupArticle& from);
  void MergeFrom(const MarkupArticle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MarkupArticle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.MarkupArticle";
  }
  protected:
  explicit MarkupArticle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorsFieldNumber = 5,
    kPublishedTimeFieldNumber = 1,
    kModifiedTimeFieldNumber = 2,
    kExpirationTimeFieldNumber = 3,
    kSectionFieldNumber = 4,
  };
  // repeated string authors = 5;
  int authors_size() const;
  private:
  int _internal_authors_size() const;
  public:
  void clear_authors();
  const std::string& authors(int index) const;
  std::string* mutable_authors(int index);
  void set_authors(int index, const std::string& value);
  void set_authors(int index, std::string&& value);
  void set_authors(int index, const char* value);
  void set_authors(int index, const char* value, size_t size);
  std::string* add_authors();
  void add_authors(const std::string& value);
  void add_authors(std::string&& value);
  void add_authors(const char* value);
  void add_authors(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& authors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_authors();
  private:
  const std::string& _internal_authors(int index) const;
  std::string* _internal_add_authors();
  public:

  // optional string published_time = 1;
  bool has_published_time() const;
  private:
  bool _internal_has_published_time() const;
  public:
  void clear_published_time();
  const std::string& published_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_published_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_published_time();
  PROTOBUF_NODISCARD std::string* release_published_time();
  void set_allocated_published_time(std::string* published_time);
  private:
  const std::string& _internal_published_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_published_time(const std::string& value);
  std::string* _internal_mutable_published_time();
  public:

  // optional string modified_time = 2;
  bool has_modified_time() const;
  private:
  bool _internal_has_modified_time() const;
  public:
  void clear_modified_time();
  const std::string& modified_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_modified_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_modified_time();
  PROTOBUF_NODISCARD std::string* release_modified_time();
  void set_allocated_modified_time(std::string* modified_time);
  private:
  const std::string& _internal_modified_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_modified_time(const std::string& value);
  std::string* _internal_mutable_modified_time();
  public:

  // optional string expiration_time = 3;
  bool has_expiration_time() const;
  private:
  bool _internal_has_expiration_time() const;
  public:
  void clear_expiration_time();
  const std::string& expiration_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_expiration_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_expiration_time();
  PROTOBUF_NODISCARD std::string* release_expiration_time();
  void set_allocated_expiration_time(std::string* expiration_time);
  private:
  const std::string& _internal_expiration_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_expiration_time(const std::string& value);
  std::string* _internal_mutable_expiration_time();
  public:

  // optional string section = 4;
  bool has_section() const;
  private:
  bool _internal_has_section() const;
  public:
  void clear_section();
  const std::string& section() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_section(ArgT0&& arg0, ArgT... args);
  std::string* mutable_section();
  PROTOBUF_NODISCARD std::string* release_section();
  void set_allocated_section(std::string* section);
  private:
  const std::string& _internal_section() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_section(const std::string& value);
  std::string* _internal_mutable_section();
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.MarkupArticle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> authors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr published_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr modified_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr expiration_time_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr section_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class MarkupImage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.MarkupImage) */ {
 public:
  inline MarkupImage() : MarkupImage(nullptr) {}
  ~MarkupImage() override;
  explicit PROTOBUF_CONSTEXPR MarkupImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkupImage(const MarkupImage& from);
  MarkupImage(MarkupImage&& from) noexcept
    : MarkupImage() {
    *this = ::std::move(from);
  }

  inline MarkupImage& operator=(const MarkupImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkupImage& operator=(MarkupImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MarkupImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkupImage* internal_default_instance() {
    return reinterpret_cast<const MarkupImage*>(
               &_MarkupImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(MarkupImage& a, MarkupImage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MarkupImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkupImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkupImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkupImage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MarkupImage& from);
  void MergeFrom(const MarkupImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MarkupImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.MarkupImage";
  }
  protected:
  explicit MarkupImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kSecureUrlFieldNumber = 2,
    kTypeFieldNumber = 3,
    kCaptionFieldNumber = 4,
    kWidthFieldNumber = 5,
    kHeightFieldNumber = 6,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string secure_url = 2;
  bool has_secure_url() const;
  private:
  bool _internal_has_secure_url() const;
  public:
  void clear_secure_url();
  const std::string& secure_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_secure_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_secure_url();
  PROTOBUF_NODISCARD std::string* release_secure_url();
  void set_allocated_secure_url(std::string* secure_url);
  private:
  const std::string& _internal_secure_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_secure_url(const std::string& value);
  std::string* _internal_mutable_secure_url();
  public:

  // optional string type = 3;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string caption = 4;
  bool has_caption() const;
  private:
  bool _internal_has_caption() const;
  public:
  void clear_caption();
  const std::string& caption() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_caption(ArgT0&& arg0, ArgT... args);
  std::string* mutable_caption();
  PROTOBUF_NODISCARD std::string* release_caption();
  void set_allocated_caption(std::string* caption);
  private:
  const std::string& _internal_caption() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_caption(const std::string& value);
  std::string* _internal_mutable_caption();
  public:

  // optional int32 width = 5;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 6;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.MarkupImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr secure_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr caption_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class MarkupInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.MarkupInfo) */ {
 public:
  inline MarkupInfo() : MarkupInfo(nullptr) {}
  ~MarkupInfo() override;
  explicit PROTOBUF_CONSTEXPR MarkupInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MarkupInfo(const MarkupInfo& from);
  MarkupInfo(MarkupInfo&& from) noexcept
    : MarkupInfo() {
    *this = ::std::move(from);
  }

  inline MarkupInfo& operator=(const MarkupInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline MarkupInfo& operator=(MarkupInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const MarkupInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const MarkupInfo* internal_default_instance() {
    return reinterpret_cast<const MarkupInfo*>(
               &_MarkupInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(MarkupInfo& a, MarkupInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(MarkupInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MarkupInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MarkupInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MarkupInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const MarkupInfo& from);
  void MergeFrom(const MarkupInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MarkupInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.MarkupInfo";
  }
  protected:
  explicit MarkupInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 9,
    kTitleFieldNumber = 1,
    kTypeFieldNumber = 2,
    kUrlFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kPublisherFieldNumber = 5,
    kCopyrightFieldNumber = 6,
    kAuthorFieldNumber = 7,
    kArticleFieldNumber = 8,
  };
  // repeated .dom_distiller.proto.MarkupImage images = 9;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::dom_distiller::proto::MarkupImage* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::MarkupImage >*
      mutable_images();
  private:
  const ::dom_distiller::proto::MarkupImage& _internal_images(int index) const;
  ::dom_distiller::proto::MarkupImage* _internal_add_images();
  public:
  const ::dom_distiller::proto::MarkupImage& images(int index) const;
  ::dom_distiller::proto::MarkupImage* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::MarkupImage >&
      images() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string url = 3;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string publisher = 5;
  bool has_publisher() const;
  private:
  bool _internal_has_publisher() const;
  public:
  void clear_publisher();
  const std::string& publisher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publisher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* publisher);
  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(const std::string& value);
  std::string* _internal_mutable_publisher();
  public:

  // optional string copyright = 6;
  bool has_copyright() const;
  private:
  bool _internal_has_copyright() const;
  public:
  void clear_copyright();
  const std::string& copyright() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_copyright(ArgT0&& arg0, ArgT... args);
  std::string* mutable_copyright();
  PROTOBUF_NODISCARD std::string* release_copyright();
  void set_allocated_copyright(std::string* copyright);
  private:
  const std::string& _internal_copyright() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_copyright(const std::string& value);
  std::string* _internal_mutable_copyright();
  public:

  // optional string author = 7;
  bool has_author() const;
  private:
  bool _internal_has_author() const;
  public:
  void clear_author();
  const std::string& author() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_author(ArgT0&& arg0, ArgT... args);
  std::string* mutable_author();
  PROTOBUF_NODISCARD std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // optional .dom_distiller.proto.MarkupArticle article = 8;
  bool has_article() const;
  private:
  bool _internal_has_article() const;
  public:
  void clear_article();
  const ::dom_distiller::proto::MarkupArticle& article() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::MarkupArticle* release_article();
  ::dom_distiller::proto::MarkupArticle* mutable_article();
  void set_allocated_article(::dom_distiller::proto::MarkupArticle* article);
  private:
  const ::dom_distiller::proto::MarkupArticle& _internal_article() const;
  ::dom_distiller::proto::MarkupArticle* _internal_mutable_article();
  public:
  void unsafe_arena_set_allocated_article(
      ::dom_distiller::proto::MarkupArticle* article);
  ::dom_distiller::proto::MarkupArticle* unsafe_arena_release_article();

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.MarkupInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::MarkupImage > images_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publisher_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr copyright_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
  ::dom_distiller::proto::MarkupArticle* article_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class TimingEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.TimingEntry) */ {
 public:
  inline TimingEntry() : TimingEntry(nullptr) {}
  ~TimingEntry() override;
  explicit PROTOBUF_CONSTEXPR TimingEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimingEntry(const TimingEntry& from);
  TimingEntry(TimingEntry&& from) noexcept
    : TimingEntry() {
    *this = ::std::move(from);
  }

  inline TimingEntry& operator=(const TimingEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimingEntry& operator=(TimingEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimingEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimingEntry* internal_default_instance() {
    return reinterpret_cast<const TimingEntry*>(
               &_TimingEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(TimingEntry& a, TimingEntry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TimingEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimingEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimingEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimingEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimingEntry& from);
  void MergeFrom(const TimingEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimingEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.TimingEntry";
  }
  protected:
  explicit TimingEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kTimeFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional double time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  double time() const;
  void set_time(double value);
  private:
  double _internal_time() const;
  void _internal_set_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.TimingEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  double time_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class TimingInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.TimingInfo) */ {
 public:
  inline TimingInfo() : TimingInfo(nullptr) {}
  ~TimingInfo() override;
  explicit PROTOBUF_CONSTEXPR TimingInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TimingInfo(const TimingInfo& from);
  TimingInfo(TimingInfo&& from) noexcept
    : TimingInfo() {
    *this = ::std::move(from);
  }

  inline TimingInfo& operator=(const TimingInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TimingInfo& operator=(TimingInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TimingInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TimingInfo* internal_default_instance() {
    return reinterpret_cast<const TimingInfo*>(
               &_TimingInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(TimingInfo& a, TimingInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TimingInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TimingInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TimingInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TimingInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TimingInfo& from);
  void MergeFrom(const TimingInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TimingInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.TimingInfo";
  }
  protected:
  explicit TimingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOtherTimesFieldNumber = 6,
    kMarkupParsingTimeFieldNumber = 1,
    kDocumentConstructionTimeFieldNumber = 2,
    kArticleProcessingTimeFieldNumber = 3,
    kFormattingTimeFieldNumber = 4,
    kTotalTimeFieldNumber = 5,
  };
  // repeated .dom_distiller.proto.TimingEntry other_times = 6;
  int other_times_size() const;
  private:
  int _internal_other_times_size() const;
  public:
  void clear_other_times();
  ::dom_distiller::proto::TimingEntry* mutable_other_times(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::TimingEntry >*
      mutable_other_times();
  private:
  const ::dom_distiller::proto::TimingEntry& _internal_other_times(int index) const;
  ::dom_distiller::proto::TimingEntry* _internal_add_other_times();
  public:
  const ::dom_distiller::proto::TimingEntry& other_times(int index) const;
  ::dom_distiller::proto::TimingEntry* add_other_times();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::TimingEntry >&
      other_times() const;

  // optional double markup_parsing_time = 1;
  bool has_markup_parsing_time() const;
  private:
  bool _internal_has_markup_parsing_time() const;
  public:
  void clear_markup_parsing_time();
  double markup_parsing_time() const;
  void set_markup_parsing_time(double value);
  private:
  double _internal_markup_parsing_time() const;
  void _internal_set_markup_parsing_time(double value);
  public:

  // optional double document_construction_time = 2;
  bool has_document_construction_time() const;
  private:
  bool _internal_has_document_construction_time() const;
  public:
  void clear_document_construction_time();
  double document_construction_time() const;
  void set_document_construction_time(double value);
  private:
  double _internal_document_construction_time() const;
  void _internal_set_document_construction_time(double value);
  public:

  // optional double article_processing_time = 3;
  bool has_article_processing_time() const;
  private:
  bool _internal_has_article_processing_time() const;
  public:
  void clear_article_processing_time();
  double article_processing_time() const;
  void set_article_processing_time(double value);
  private:
  double _internal_article_processing_time() const;
  void _internal_set_article_processing_time(double value);
  public:

  // optional double formatting_time = 4;
  bool has_formatting_time() const;
  private:
  bool _internal_has_formatting_time() const;
  public:
  void clear_formatting_time();
  double formatting_time() const;
  void set_formatting_time(double value);
  private:
  double _internal_formatting_time() const;
  void _internal_set_formatting_time(double value);
  public:

  // optional double total_time = 5;
  bool has_total_time() const;
  private:
  bool _internal_has_total_time() const;
  public:
  void clear_total_time();
  double total_time() const;
  void set_total_time(double value);
  private:
  double _internal_total_time() const;
  void _internal_set_total_time(double value);
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.TimingInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::TimingEntry > other_times_;
  double markup_parsing_time_;
  double document_construction_time_;
  double article_processing_time_;
  double formatting_time_;
  double total_time_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class DebugInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.DebugInfo) */ {
 public:
  inline DebugInfo() : DebugInfo(nullptr) {}
  ~DebugInfo() override;
  explicit PROTOBUF_CONSTEXPR DebugInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugInfo(const DebugInfo& from);
  DebugInfo(DebugInfo&& from) noexcept
    : DebugInfo() {
    *this = ::std::move(from);
  }

  inline DebugInfo& operator=(const DebugInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugInfo& operator=(DebugInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DebugInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugInfo* internal_default_instance() {
    return reinterpret_cast<const DebugInfo*>(
               &_DebugInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DebugInfo& a, DebugInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DebugInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DebugInfo& from);
  void MergeFrom(const DebugInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DebugInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.DebugInfo";
  }
  protected:
  explicit DebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogFieldNumber = 1,
  };
  // optional string log = 1;
  bool has_log() const;
  private:
  bool _internal_has_log() const;
  public:
  void clear_log();
  const std::string& log() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_log(ArgT0&& arg0, ArgT... args);
  std::string* mutable_log();
  PROTOBUF_NODISCARD std::string* release_log();
  void set_allocated_log(std::string* log);
  private:
  const std::string& _internal_log() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_log(const std::string& value);
  std::string* _internal_mutable_log();
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.DebugInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr log_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class StatisticsInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.StatisticsInfo) */ {
 public:
  inline StatisticsInfo() : StatisticsInfo(nullptr) {}
  ~StatisticsInfo() override;
  explicit PROTOBUF_CONSTEXPR StatisticsInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatisticsInfo(const StatisticsInfo& from);
  StatisticsInfo(StatisticsInfo&& from) noexcept
    : StatisticsInfo() {
    *this = ::std::move(from);
  }

  inline StatisticsInfo& operator=(const StatisticsInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatisticsInfo& operator=(StatisticsInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const StatisticsInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatisticsInfo* internal_default_instance() {
    return reinterpret_cast<const StatisticsInfo*>(
               &_StatisticsInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StatisticsInfo& a, StatisticsInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StatisticsInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatisticsInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatisticsInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatisticsInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StatisticsInfo& from);
  void MergeFrom(const StatisticsInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StatisticsInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.StatisticsInfo";
  }
  protected:
  explicit StatisticsInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordCountFieldNumber = 1,
  };
  // optional int32 word_count = 1;
  bool has_word_count() const;
  private:
  bool _internal_has_word_count() const;
  public:
  void clear_word_count();
  int32_t word_count() const;
  void set_word_count(int32_t value);
  private:
  int32_t _internal_word_count() const;
  void _internal_set_word_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.StatisticsInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t word_count_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class DomDistillerResult_ContentImage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.DomDistillerResult.ContentImage) */ {
 public:
  inline DomDistillerResult_ContentImage() : DomDistillerResult_ContentImage(nullptr) {}
  ~DomDistillerResult_ContentImage() override;
  explicit PROTOBUF_CONSTEXPR DomDistillerResult_ContentImage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DomDistillerResult_ContentImage(const DomDistillerResult_ContentImage& from);
  DomDistillerResult_ContentImage(DomDistillerResult_ContentImage&& from) noexcept
    : DomDistillerResult_ContentImage() {
    *this = ::std::move(from);
  }

  inline DomDistillerResult_ContentImage& operator=(const DomDistillerResult_ContentImage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DomDistillerResult_ContentImage& operator=(DomDistillerResult_ContentImage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DomDistillerResult_ContentImage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DomDistillerResult_ContentImage* internal_default_instance() {
    return reinterpret_cast<const DomDistillerResult_ContentImage*>(
               &_DomDistillerResult_ContentImage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(DomDistillerResult_ContentImage& a, DomDistillerResult_ContentImage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DomDistillerResult_ContentImage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DomDistillerResult_ContentImage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DomDistillerResult_ContentImage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DomDistillerResult_ContentImage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DomDistillerResult_ContentImage& from);
  void MergeFrom(const DomDistillerResult_ContentImage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DomDistillerResult_ContentImage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.DomDistillerResult.ContentImage";
  }
  protected:
  explicit DomDistillerResult_ContentImage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.DomDistillerResult.ContentImage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class DomDistillerResult final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.DomDistillerResult) */ {
 public:
  inline DomDistillerResult() : DomDistillerResult(nullptr) {}
  ~DomDistillerResult() override;
  explicit PROTOBUF_CONSTEXPR DomDistillerResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DomDistillerResult(const DomDistillerResult& from);
  DomDistillerResult(DomDistillerResult&& from) noexcept
    : DomDistillerResult() {
    *this = ::std::move(from);
  }

  inline DomDistillerResult& operator=(const DomDistillerResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline DomDistillerResult& operator=(DomDistillerResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DomDistillerResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const DomDistillerResult* internal_default_instance() {
    return reinterpret_cast<const DomDistillerResult*>(
               &_DomDistillerResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(DomDistillerResult& a, DomDistillerResult& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DomDistillerResult* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DomDistillerResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DomDistillerResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DomDistillerResult>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DomDistillerResult& from);
  void MergeFrom(const DomDistillerResult& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DomDistillerResult* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.DomDistillerResult";
  }
  protected:
  explicit DomDistillerResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef DomDistillerResult_ContentImage ContentImage;

  // accessors -------------------------------------------------------

  enum : int {
    kContentImagesFieldNumber = 10,
    kTitleFieldNumber = 1,
    kTextDirectionFieldNumber = 9,
    kDistilledContentFieldNumber = 2,
    kPaginationInfoFieldNumber = 3,
    kMarkupInfoFieldNumber = 5,
    kTimingInfoFieldNumber = 6,
    kDebugInfoFieldNumber = 7,
    kStatisticsInfoFieldNumber = 8,
  };
  // repeated .dom_distiller.proto.DomDistillerResult.ContentImage content_images = 10;
  int content_images_size() const;
  private:
  int _internal_content_images_size() const;
  public:
  void clear_content_images();
  ::dom_distiller::proto::DomDistillerResult_ContentImage* mutable_content_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::DomDistillerResult_ContentImage >*
      mutable_content_images();
  private:
  const ::dom_distiller::proto::DomDistillerResult_ContentImage& _internal_content_images(int index) const;
  ::dom_distiller::proto::DomDistillerResult_ContentImage* _internal_add_content_images();
  public:
  const ::dom_distiller::proto::DomDistillerResult_ContentImage& content_images(int index) const;
  ::dom_distiller::proto::DomDistillerResult_ContentImage* add_content_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::DomDistillerResult_ContentImage >&
      content_images() const;

  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string text_direction = 9;
  bool has_text_direction() const;
  private:
  bool _internal_has_text_direction() const;
  public:
  void clear_text_direction();
  const std::string& text_direction() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_direction(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_direction();
  PROTOBUF_NODISCARD std::string* release_text_direction();
  void set_allocated_text_direction(std::string* text_direction);
  private:
  const std::string& _internal_text_direction() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_direction(const std::string& value);
  std::string* _internal_mutable_text_direction();
  public:

  // optional .dom_distiller.proto.DistilledContent distilled_content = 2;
  bool has_distilled_content() const;
  private:
  bool _internal_has_distilled_content() const;
  public:
  void clear_distilled_content();
  const ::dom_distiller::proto::DistilledContent& distilled_content() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::DistilledContent* release_distilled_content();
  ::dom_distiller::proto::DistilledContent* mutable_distilled_content();
  void set_allocated_distilled_content(::dom_distiller::proto::DistilledContent* distilled_content);
  private:
  const ::dom_distiller::proto::DistilledContent& _internal_distilled_content() const;
  ::dom_distiller::proto::DistilledContent* _internal_mutable_distilled_content();
  public:
  void unsafe_arena_set_allocated_distilled_content(
      ::dom_distiller::proto::DistilledContent* distilled_content);
  ::dom_distiller::proto::DistilledContent* unsafe_arena_release_distilled_content();

  // optional .dom_distiller.proto.PaginationInfo pagination_info = 3;
  bool has_pagination_info() const;
  private:
  bool _internal_has_pagination_info() const;
  public:
  void clear_pagination_info();
  const ::dom_distiller::proto::PaginationInfo& pagination_info() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::PaginationInfo* release_pagination_info();
  ::dom_distiller::proto::PaginationInfo* mutable_pagination_info();
  void set_allocated_pagination_info(::dom_distiller::proto::PaginationInfo* pagination_info);
  private:
  const ::dom_distiller::proto::PaginationInfo& _internal_pagination_info() const;
  ::dom_distiller::proto::PaginationInfo* _internal_mutable_pagination_info();
  public:
  void unsafe_arena_set_allocated_pagination_info(
      ::dom_distiller::proto::PaginationInfo* pagination_info);
  ::dom_distiller::proto::PaginationInfo* unsafe_arena_release_pagination_info();

  // optional .dom_distiller.proto.MarkupInfo markup_info = 5;
  bool has_markup_info() const;
  private:
  bool _internal_has_markup_info() const;
  public:
  void clear_markup_info();
  const ::dom_distiller::proto::MarkupInfo& markup_info() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::MarkupInfo* release_markup_info();
  ::dom_distiller::proto::MarkupInfo* mutable_markup_info();
  void set_allocated_markup_info(::dom_distiller::proto::MarkupInfo* markup_info);
  private:
  const ::dom_distiller::proto::MarkupInfo& _internal_markup_info() const;
  ::dom_distiller::proto::MarkupInfo* _internal_mutable_markup_info();
  public:
  void unsafe_arena_set_allocated_markup_info(
      ::dom_distiller::proto::MarkupInfo* markup_info);
  ::dom_distiller::proto::MarkupInfo* unsafe_arena_release_markup_info();

  // optional .dom_distiller.proto.TimingInfo timing_info = 6;
  bool has_timing_info() const;
  private:
  bool _internal_has_timing_info() const;
  public:
  void clear_timing_info();
  const ::dom_distiller::proto::TimingInfo& timing_info() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::TimingInfo* release_timing_info();
  ::dom_distiller::proto::TimingInfo* mutable_timing_info();
  void set_allocated_timing_info(::dom_distiller::proto::TimingInfo* timing_info);
  private:
  const ::dom_distiller::proto::TimingInfo& _internal_timing_info() const;
  ::dom_distiller::proto::TimingInfo* _internal_mutable_timing_info();
  public:
  void unsafe_arena_set_allocated_timing_info(
      ::dom_distiller::proto::TimingInfo* timing_info);
  ::dom_distiller::proto::TimingInfo* unsafe_arena_release_timing_info();

  // optional .dom_distiller.proto.DebugInfo debug_info = 7;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const ::dom_distiller::proto::DebugInfo& debug_info() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::DebugInfo* release_debug_info();
  ::dom_distiller::proto::DebugInfo* mutable_debug_info();
  void set_allocated_debug_info(::dom_distiller::proto::DebugInfo* debug_info);
  private:
  const ::dom_distiller::proto::DebugInfo& _internal_debug_info() const;
  ::dom_distiller::proto::DebugInfo* _internal_mutable_debug_info();
  public:
  void unsafe_arena_set_allocated_debug_info(
      ::dom_distiller::proto::DebugInfo* debug_info);
  ::dom_distiller::proto::DebugInfo* unsafe_arena_release_debug_info();

  // optional .dom_distiller.proto.StatisticsInfo statistics_info = 8;
  bool has_statistics_info() const;
  private:
  bool _internal_has_statistics_info() const;
  public:
  void clear_statistics_info();
  const ::dom_distiller::proto::StatisticsInfo& statistics_info() const;
  PROTOBUF_NODISCARD ::dom_distiller::proto::StatisticsInfo* release_statistics_info();
  ::dom_distiller::proto::StatisticsInfo* mutable_statistics_info();
  void set_allocated_statistics_info(::dom_distiller::proto::StatisticsInfo* statistics_info);
  private:
  const ::dom_distiller::proto::StatisticsInfo& _internal_statistics_info() const;
  ::dom_distiller::proto::StatisticsInfo* _internal_mutable_statistics_info();
  public:
  void unsafe_arena_set_allocated_statistics_info(
      ::dom_distiller::proto::StatisticsInfo* statistics_info);
  ::dom_distiller::proto::StatisticsInfo* unsafe_arena_release_statistics_info();

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.DomDistillerResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::DomDistillerResult_ContentImage > content_images_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_direction_;
  ::dom_distiller::proto::DistilledContent* distilled_content_;
  ::dom_distiller::proto::PaginationInfo* pagination_info_;
  ::dom_distiller::proto::MarkupInfo* markup_info_;
  ::dom_distiller::proto::TimingInfo* timing_info_;
  ::dom_distiller::proto::DebugInfo* debug_info_;
  ::dom_distiller::proto::StatisticsInfo* statistics_info_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// -------------------------------------------------------------------

class DomDistillerOptions final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:dom_distiller.proto.DomDistillerOptions) */ {
 public:
  inline DomDistillerOptions() : DomDistillerOptions(nullptr) {}
  ~DomDistillerOptions() override;
  explicit PROTOBUF_CONSTEXPR DomDistillerOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DomDistillerOptions(const DomDistillerOptions& from);
  DomDistillerOptions(DomDistillerOptions&& from) noexcept
    : DomDistillerOptions() {
    *this = ::std::move(from);
  }

  inline DomDistillerOptions& operator=(const DomDistillerOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DomDistillerOptions& operator=(DomDistillerOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DomDistillerOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DomDistillerOptions* internal_default_instance() {
    return reinterpret_cast<const DomDistillerOptions*>(
               &_DomDistillerOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(DomDistillerOptions& a, DomDistillerOptions& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DomDistillerOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DomDistillerOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DomDistillerOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DomDistillerOptions>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DomDistillerOptions& from);
  void MergeFrom(const DomDistillerOptions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DomDistillerOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dom_distiller.proto.DomDistillerOptions";
  }
  protected:
  explicit DomDistillerOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOriginalUrlFieldNumber = 3,
    kPaginationAlgoFieldNumber = 4,
    kExtractTextOnlyFieldNumber = 1,
    kDebugLevelFieldNumber = 2,
  };
  // optional string original_url = 3;
  bool has_original_url() const;
  private:
  bool _internal_has_original_url() const;
  public:
  void clear_original_url();
  const std::string& original_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_url();
  PROTOBUF_NODISCARD std::string* release_original_url();
  void set_allocated_original_url(std::string* original_url);
  private:
  const std::string& _internal_original_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_url(const std::string& value);
  std::string* _internal_mutable_original_url();
  public:

  // optional string pagination_algo = 4;
  bool has_pagination_algo() const;
  private:
  bool _internal_has_pagination_algo() const;
  public:
  void clear_pagination_algo();
  const std::string& pagination_algo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pagination_algo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pagination_algo();
  PROTOBUF_NODISCARD std::string* release_pagination_algo();
  void set_allocated_pagination_algo(std::string* pagination_algo);
  private:
  const std::string& _internal_pagination_algo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pagination_algo(const std::string& value);
  std::string* _internal_mutable_pagination_algo();
  public:

  // optional bool extract_text_only = 1;
  bool has_extract_text_only() const;
  private:
  bool _internal_has_extract_text_only() const;
  public:
  void clear_extract_text_only();
  bool extract_text_only() const;
  void set_extract_text_only(bool value);
  private:
  bool _internal_extract_text_only() const;
  void _internal_set_extract_text_only(bool value);
  public:

  // optional int32 debug_level = 2;
  bool has_debug_level() const;
  private:
  bool _internal_has_debug_level() const;
  public:
  void clear_debug_level();
  int32_t debug_level() const;
  void set_debug_level(int32_t value);
  private:
  int32_t _internal_debug_level() const;
  void _internal_set_debug_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:dom_distiller.proto.DomDistillerOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pagination_algo_;
  bool extract_text_only_;
  int32_t debug_level_;
  friend struct ::TableStruct_dom_5fdistiller_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DistilledContent

// optional string html = 1;
inline bool DistilledContent::_internal_has_html() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DistilledContent::has_html() const {
  return _internal_has_html();
}
inline void DistilledContent::clear_html() {
  html_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DistilledContent::html() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DistilledContent.html)
  return _internal_html();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DistilledContent::set_html(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 html_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DistilledContent.html)
}
inline std::string* DistilledContent::mutable_html() {
  std::string* _s = _internal_mutable_html();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DistilledContent.html)
  return _s;
}
inline const std::string& DistilledContent::_internal_html() const {
  return html_.Get();
}
inline void DistilledContent::_internal_set_html(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  html_.Set(value, GetArenaForAllocation());
}
inline std::string* DistilledContent::_internal_mutable_html() {
  _has_bits_[0] |= 0x00000001u;
  return html_.Mutable(GetArenaForAllocation());
}
inline std::string* DistilledContent::release_html() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DistilledContent.html)
  if (!_internal_has_html()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = html_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (html_.IsDefault()) {
    html_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DistilledContent::set_allocated_html(std::string* html) {
  if (html != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  html_.SetAllocated(html, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (html_.IsDefault()) {
    html_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DistilledContent.html)
}

// -------------------------------------------------------------------

// PaginationInfo

// optional string next_page = 1;
inline bool PaginationInfo::_internal_has_next_page() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaginationInfo::has_next_page() const {
  return _internal_has_next_page();
}
inline void PaginationInfo::clear_next_page() {
  next_page_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaginationInfo::next_page() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.PaginationInfo.next_page)
  return _internal_next_page();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationInfo::set_next_page(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 next_page_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.PaginationInfo.next_page)
}
inline std::string* PaginationInfo::mutable_next_page() {
  std::string* _s = _internal_mutable_next_page();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.PaginationInfo.next_page)
  return _s;
}
inline const std::string& PaginationInfo::_internal_next_page() const {
  return next_page_.Get();
}
inline void PaginationInfo::_internal_set_next_page(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  next_page_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginationInfo::_internal_mutable_next_page() {
  _has_bits_[0] |= 0x00000001u;
  return next_page_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginationInfo::release_next_page() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.PaginationInfo.next_page)
  if (!_internal_has_next_page()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = next_page_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_.IsDefault()) {
    next_page_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaginationInfo::set_allocated_next_page(std::string* next_page) {
  if (next_page != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  next_page_.SetAllocated(next_page, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_.IsDefault()) {
    next_page_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.PaginationInfo.next_page)
}

// optional string prev_page = 2;
inline bool PaginationInfo::_internal_has_prev_page() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaginationInfo::has_prev_page() const {
  return _internal_has_prev_page();
}
inline void PaginationInfo::clear_prev_page() {
  prev_page_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaginationInfo::prev_page() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.PaginationInfo.prev_page)
  return _internal_prev_page();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationInfo::set_prev_page(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 prev_page_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.PaginationInfo.prev_page)
}
inline std::string* PaginationInfo::mutable_prev_page() {
  std::string* _s = _internal_mutable_prev_page();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.PaginationInfo.prev_page)
  return _s;
}
inline const std::string& PaginationInfo::_internal_prev_page() const {
  return prev_page_.Get();
}
inline void PaginationInfo::_internal_set_prev_page(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  prev_page_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginationInfo::_internal_mutable_prev_page() {
  _has_bits_[0] |= 0x00000002u;
  return prev_page_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginationInfo::release_prev_page() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.PaginationInfo.prev_page)
  if (!_internal_has_prev_page()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = prev_page_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prev_page_.IsDefault()) {
    prev_page_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaginationInfo::set_allocated_prev_page(std::string* prev_page) {
  if (prev_page != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  prev_page_.SetAllocated(prev_page, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (prev_page_.IsDefault()) {
    prev_page_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.PaginationInfo.prev_page)
}

// optional string canonical_page = 3;
inline bool PaginationInfo::_internal_has_canonical_page() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaginationInfo::has_canonical_page() const {
  return _internal_has_canonical_page();
}
inline void PaginationInfo::clear_canonical_page() {
  canonical_page_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PaginationInfo::canonical_page() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.PaginationInfo.canonical_page)
  return _internal_canonical_page();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaginationInfo::set_canonical_page(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 canonical_page_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.PaginationInfo.canonical_page)
}
inline std::string* PaginationInfo::mutable_canonical_page() {
  std::string* _s = _internal_mutable_canonical_page();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.PaginationInfo.canonical_page)
  return _s;
}
inline const std::string& PaginationInfo::_internal_canonical_page() const {
  return canonical_page_.Get();
}
inline void PaginationInfo::_internal_set_canonical_page(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  canonical_page_.Set(value, GetArenaForAllocation());
}
inline std::string* PaginationInfo::_internal_mutable_canonical_page() {
  _has_bits_[0] |= 0x00000004u;
  return canonical_page_.Mutable(GetArenaForAllocation());
}
inline std::string* PaginationInfo::release_canonical_page() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.PaginationInfo.canonical_page)
  if (!_internal_has_canonical_page()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = canonical_page_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (canonical_page_.IsDefault()) {
    canonical_page_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaginationInfo::set_allocated_canonical_page(std::string* canonical_page) {
  if (canonical_page != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  canonical_page_.SetAllocated(canonical_page, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (canonical_page_.IsDefault()) {
    canonical_page_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.PaginationInfo.canonical_page)
}

// -------------------------------------------------------------------

// MarkupArticle

// optional string published_time = 1;
inline bool MarkupArticle::_internal_has_published_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarkupArticle::has_published_time() const {
  return _internal_has_published_time();
}
inline void MarkupArticle::clear_published_time() {
  published_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MarkupArticle::published_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupArticle.published_time)
  return _internal_published_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupArticle::set_published_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 published_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupArticle.published_time)
}
inline std::string* MarkupArticle::mutable_published_time() {
  std::string* _s = _internal_mutable_published_time();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupArticle.published_time)
  return _s;
}
inline const std::string& MarkupArticle::_internal_published_time() const {
  return published_time_.Get();
}
inline void MarkupArticle::_internal_set_published_time(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  published_time_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupArticle::_internal_mutable_published_time() {
  _has_bits_[0] |= 0x00000001u;
  return published_time_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupArticle::release_published_time() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupArticle.published_time)
  if (!_internal_has_published_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = published_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (published_time_.IsDefault()) {
    published_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupArticle::set_allocated_published_time(std::string* published_time) {
  if (published_time != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  published_time_.SetAllocated(published_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (published_time_.IsDefault()) {
    published_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupArticle.published_time)
}

// optional string modified_time = 2;
inline bool MarkupArticle::_internal_has_modified_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MarkupArticle::has_modified_time() const {
  return _internal_has_modified_time();
}
inline void MarkupArticle::clear_modified_time() {
  modified_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MarkupArticle::modified_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupArticle.modified_time)
  return _internal_modified_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupArticle::set_modified_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 modified_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupArticle.modified_time)
}
inline std::string* MarkupArticle::mutable_modified_time() {
  std::string* _s = _internal_mutable_modified_time();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupArticle.modified_time)
  return _s;
}
inline const std::string& MarkupArticle::_internal_modified_time() const {
  return modified_time_.Get();
}
inline void MarkupArticle::_internal_set_modified_time(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  modified_time_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupArticle::_internal_mutable_modified_time() {
  _has_bits_[0] |= 0x00000002u;
  return modified_time_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupArticle::release_modified_time() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupArticle.modified_time)
  if (!_internal_has_modified_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = modified_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (modified_time_.IsDefault()) {
    modified_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupArticle::set_allocated_modified_time(std::string* modified_time) {
  if (modified_time != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  modified_time_.SetAllocated(modified_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (modified_time_.IsDefault()) {
    modified_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupArticle.modified_time)
}

// optional string expiration_time = 3;
inline bool MarkupArticle::_internal_has_expiration_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MarkupArticle::has_expiration_time() const {
  return _internal_has_expiration_time();
}
inline void MarkupArticle::clear_expiration_time() {
  expiration_time_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MarkupArticle::expiration_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupArticle.expiration_time)
  return _internal_expiration_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupArticle::set_expiration_time(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 expiration_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupArticle.expiration_time)
}
inline std::string* MarkupArticle::mutable_expiration_time() {
  std::string* _s = _internal_mutable_expiration_time();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupArticle.expiration_time)
  return _s;
}
inline const std::string& MarkupArticle::_internal_expiration_time() const {
  return expiration_time_.Get();
}
inline void MarkupArticle::_internal_set_expiration_time(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  expiration_time_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupArticle::_internal_mutable_expiration_time() {
  _has_bits_[0] |= 0x00000004u;
  return expiration_time_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupArticle::release_expiration_time() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupArticle.expiration_time)
  if (!_internal_has_expiration_time()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = expiration_time_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (expiration_time_.IsDefault()) {
    expiration_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupArticle::set_allocated_expiration_time(std::string* expiration_time) {
  if (expiration_time != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  expiration_time_.SetAllocated(expiration_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (expiration_time_.IsDefault()) {
    expiration_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupArticle.expiration_time)
}

// optional string section = 4;
inline bool MarkupArticle::_internal_has_section() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MarkupArticle::has_section() const {
  return _internal_has_section();
}
inline void MarkupArticle::clear_section() {
  section_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MarkupArticle::section() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupArticle.section)
  return _internal_section();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupArticle::set_section(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 section_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupArticle.section)
}
inline std::string* MarkupArticle::mutable_section() {
  std::string* _s = _internal_mutable_section();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupArticle.section)
  return _s;
}
inline const std::string& MarkupArticle::_internal_section() const {
  return section_.Get();
}
inline void MarkupArticle::_internal_set_section(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  section_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupArticle::_internal_mutable_section() {
  _has_bits_[0] |= 0x00000008u;
  return section_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupArticle::release_section() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupArticle.section)
  if (!_internal_has_section()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = section_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (section_.IsDefault()) {
    section_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupArticle::set_allocated_section(std::string* section) {
  if (section != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  section_.SetAllocated(section, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (section_.IsDefault()) {
    section_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupArticle.section)
}

// repeated string authors = 5;
inline int MarkupArticle::_internal_authors_size() const {
  return authors_.size();
}
inline int MarkupArticle::authors_size() const {
  return _internal_authors_size();
}
inline void MarkupArticle::clear_authors() {
  authors_.Clear();
}
inline std::string* MarkupArticle::add_authors() {
  std::string* _s = _internal_add_authors();
  // @@protoc_insertion_point(field_add_mutable:dom_distiller.proto.MarkupArticle.authors)
  return _s;
}
inline const std::string& MarkupArticle::_internal_authors(int index) const {
  return authors_.Get(index);
}
inline const std::string& MarkupArticle::authors(int index) const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupArticle.authors)
  return _internal_authors(index);
}
inline std::string* MarkupArticle::mutable_authors(int index) {
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupArticle.authors)
  return authors_.Mutable(index);
}
inline void MarkupArticle::set_authors(int index, const std::string& value) {
  authors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupArticle.authors)
}
inline void MarkupArticle::set_authors(int index, std::string&& value) {
  authors_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupArticle.authors)
}
inline void MarkupArticle::set_authors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  authors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:dom_distiller.proto.MarkupArticle.authors)
}
inline void MarkupArticle::set_authors(int index, const char* value, size_t size) {
  authors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:dom_distiller.proto.MarkupArticle.authors)
}
inline std::string* MarkupArticle::_internal_add_authors() {
  return authors_.Add();
}
inline void MarkupArticle::add_authors(const std::string& value) {
  authors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:dom_distiller.proto.MarkupArticle.authors)
}
inline void MarkupArticle::add_authors(std::string&& value) {
  authors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:dom_distiller.proto.MarkupArticle.authors)
}
inline void MarkupArticle::add_authors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  authors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:dom_distiller.proto.MarkupArticle.authors)
}
inline void MarkupArticle::add_authors(const char* value, size_t size) {
  authors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:dom_distiller.proto.MarkupArticle.authors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
MarkupArticle::authors() const {
  // @@protoc_insertion_point(field_list:dom_distiller.proto.MarkupArticle.authors)
  return authors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
MarkupArticle::mutable_authors() {
  // @@protoc_insertion_point(field_mutable_list:dom_distiller.proto.MarkupArticle.authors)
  return &authors_;
}

// -------------------------------------------------------------------

// MarkupImage

// optional string url = 1;
inline bool MarkupImage::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarkupImage::has_url() const {
  return _internal_has_url();
}
inline void MarkupImage::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MarkupImage::url() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupImage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupImage::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupImage.url)
}
inline std::string* MarkupImage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupImage.url)
  return _s;
}
inline const std::string& MarkupImage::_internal_url() const {
  return url_.Get();
}
inline void MarkupImage::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupImage::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupImage::release_url() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupImage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupImage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupImage.url)
}

// optional string secure_url = 2;
inline bool MarkupImage::_internal_has_secure_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MarkupImage::has_secure_url() const {
  return _internal_has_secure_url();
}
inline void MarkupImage::clear_secure_url() {
  secure_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MarkupImage::secure_url() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupImage.secure_url)
  return _internal_secure_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupImage::set_secure_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 secure_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupImage.secure_url)
}
inline std::string* MarkupImage::mutable_secure_url() {
  std::string* _s = _internal_mutable_secure_url();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupImage.secure_url)
  return _s;
}
inline const std::string& MarkupImage::_internal_secure_url() const {
  return secure_url_.Get();
}
inline void MarkupImage::_internal_set_secure_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  secure_url_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupImage::_internal_mutable_secure_url() {
  _has_bits_[0] |= 0x00000002u;
  return secure_url_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupImage::release_secure_url() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupImage.secure_url)
  if (!_internal_has_secure_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = secure_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secure_url_.IsDefault()) {
    secure_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupImage::set_allocated_secure_url(std::string* secure_url) {
  if (secure_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  secure_url_.SetAllocated(secure_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (secure_url_.IsDefault()) {
    secure_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupImage.secure_url)
}

// optional string type = 3;
inline bool MarkupImage::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MarkupImage::has_type() const {
  return _internal_has_type();
}
inline void MarkupImage::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MarkupImage::type() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupImage.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupImage::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupImage.type)
}
inline std::string* MarkupImage::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupImage.type)
  return _s;
}
inline const std::string& MarkupImage::_internal_type() const {
  return type_.Get();
}
inline void MarkupImage::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupImage::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000004u;
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupImage::release_type() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupImage.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupImage::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupImage.type)
}

// optional string caption = 4;
inline bool MarkupImage::_internal_has_caption() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MarkupImage::has_caption() const {
  return _internal_has_caption();
}
inline void MarkupImage::clear_caption() {
  caption_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MarkupImage::caption() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupImage.caption)
  return _internal_caption();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupImage::set_caption(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 caption_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupImage.caption)
}
inline std::string* MarkupImage::mutable_caption() {
  std::string* _s = _internal_mutable_caption();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupImage.caption)
  return _s;
}
inline const std::string& MarkupImage::_internal_caption() const {
  return caption_.Get();
}
inline void MarkupImage::_internal_set_caption(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  caption_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupImage::_internal_mutable_caption() {
  _has_bits_[0] |= 0x00000008u;
  return caption_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupImage::release_caption() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupImage.caption)
  if (!_internal_has_caption()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = caption_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (caption_.IsDefault()) {
    caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupImage::set_allocated_caption(std::string* caption) {
  if (caption != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  caption_.SetAllocated(caption, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (caption_.IsDefault()) {
    caption_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupImage.caption)
}

// optional int32 width = 5;
inline bool MarkupImage::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MarkupImage::has_width() const {
  return _internal_has_width();
}
inline void MarkupImage::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t MarkupImage::_internal_width() const {
  return width_;
}
inline int32_t MarkupImage::width() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupImage.width)
  return _internal_width();
}
inline void MarkupImage::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  width_ = value;
}
inline void MarkupImage::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupImage.width)
}

// optional int32 height = 6;
inline bool MarkupImage::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MarkupImage::has_height() const {
  return _internal_has_height();
}
inline void MarkupImage::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t MarkupImage::_internal_height() const {
  return height_;
}
inline int32_t MarkupImage::height() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupImage.height)
  return _internal_height();
}
inline void MarkupImage::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  height_ = value;
}
inline void MarkupImage::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupImage.height)
}

// -------------------------------------------------------------------

// MarkupInfo

// optional string title = 1;
inline bool MarkupInfo::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool MarkupInfo::has_title() const {
  return _internal_has_title();
}
inline void MarkupInfo::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& MarkupInfo::title() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.title)
}
inline std::string* MarkupInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.title)
  return _s;
}
inline const std::string& MarkupInfo::_internal_title() const {
  return title_.Get();
}
inline void MarkupInfo::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_title() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.title)
}

// optional string type = 2;
inline bool MarkupInfo::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool MarkupInfo::has_type() const {
  return _internal_has_type();
}
inline void MarkupInfo::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& MarkupInfo::type() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.type)
}
inline std::string* MarkupInfo::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.type)
  return _s;
}
inline const std::string& MarkupInfo::_internal_type() const {
  return type_.Get();
}
inline void MarkupInfo::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_type() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault()) {
    type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.type)
}

// optional string url = 3;
inline bool MarkupInfo::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool MarkupInfo::has_url() const {
  return _internal_has_url();
}
inline void MarkupInfo::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& MarkupInfo::url() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.url)
}
inline std::string* MarkupInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.url)
  return _s;
}
inline const std::string& MarkupInfo::_internal_url() const {
  return url_.Get();
}
inline void MarkupInfo::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000004u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_url() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.url)
}

// optional string description = 4;
inline bool MarkupInfo::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool MarkupInfo::has_description() const {
  return _internal_has_description();
}
inline void MarkupInfo::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& MarkupInfo::description() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.description)
}
inline std::string* MarkupInfo::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.description)
  return _s;
}
inline const std::string& MarkupInfo::_internal_description() const {
  return description_.Get();
}
inline void MarkupInfo::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  description_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000008u;
  return description_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_description() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  description_.SetAllocated(description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault()) {
    description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.description)
}

// optional string publisher = 5;
inline bool MarkupInfo::_internal_has_publisher() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool MarkupInfo::has_publisher() const {
  return _internal_has_publisher();
}
inline void MarkupInfo::clear_publisher() {
  publisher_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& MarkupInfo::publisher() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.publisher)
  return _internal_publisher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_publisher(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 publisher_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.publisher)
}
inline std::string* MarkupInfo::mutable_publisher() {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.publisher)
  return _s;
}
inline const std::string& MarkupInfo::_internal_publisher() const {
  return publisher_.Get();
}
inline void MarkupInfo::_internal_set_publisher(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  publisher_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_publisher() {
  _has_bits_[0] |= 0x00000010u;
  return publisher_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_publisher() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.publisher)
  if (!_internal_has_publisher()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = publisher_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publisher_.IsDefault()) {
    publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_publisher(std::string* publisher) {
  if (publisher != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  publisher_.SetAllocated(publisher, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publisher_.IsDefault()) {
    publisher_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.publisher)
}

// optional string copyright = 6;
inline bool MarkupInfo::_internal_has_copyright() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool MarkupInfo::has_copyright() const {
  return _internal_has_copyright();
}
inline void MarkupInfo::clear_copyright() {
  copyright_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& MarkupInfo::copyright() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.copyright)
  return _internal_copyright();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_copyright(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 copyright_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.copyright)
}
inline std::string* MarkupInfo::mutable_copyright() {
  std::string* _s = _internal_mutable_copyright();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.copyright)
  return _s;
}
inline const std::string& MarkupInfo::_internal_copyright() const {
  return copyright_.Get();
}
inline void MarkupInfo::_internal_set_copyright(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  copyright_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_copyright() {
  _has_bits_[0] |= 0x00000020u;
  return copyright_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_copyright() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.copyright)
  if (!_internal_has_copyright()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = copyright_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (copyright_.IsDefault()) {
    copyright_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_copyright(std::string* copyright) {
  if (copyright != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  copyright_.SetAllocated(copyright, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (copyright_.IsDefault()) {
    copyright_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.copyright)
}

// optional string author = 7;
inline bool MarkupInfo::_internal_has_author() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool MarkupInfo::has_author() const {
  return _internal_has_author();
}
inline void MarkupInfo::clear_author() {
  author_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& MarkupInfo::author() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.author)
  return _internal_author();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MarkupInfo::set_author(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 author_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.MarkupInfo.author)
}
inline std::string* MarkupInfo::mutable_author() {
  std::string* _s = _internal_mutable_author();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.author)
  return _s;
}
inline const std::string& MarkupInfo::_internal_author() const {
  return author_.Get();
}
inline void MarkupInfo::_internal_set_author(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  author_.Set(value, GetArenaForAllocation());
}
inline std::string* MarkupInfo::_internal_mutable_author() {
  _has_bits_[0] |= 0x00000040u;
  return author_.Mutable(GetArenaForAllocation());
}
inline std::string* MarkupInfo::release_author() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.author)
  if (!_internal_has_author()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = author_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (author_.IsDefault()) {
    author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void MarkupInfo::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  author_.SetAllocated(author, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (author_.IsDefault()) {
    author_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.author)
}

// optional .dom_distiller.proto.MarkupArticle article = 8;
inline bool MarkupInfo::_internal_has_article() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || article_ != nullptr);
  return value;
}
inline bool MarkupInfo::has_article() const {
  return _internal_has_article();
}
inline void MarkupInfo::clear_article() {
  if (article_ != nullptr) article_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::dom_distiller::proto::MarkupArticle& MarkupInfo::_internal_article() const {
  const ::dom_distiller::proto::MarkupArticle* p = article_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::MarkupArticle&>(
      ::dom_distiller::proto::_MarkupArticle_default_instance_);
}
inline const ::dom_distiller::proto::MarkupArticle& MarkupInfo::article() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.article)
  return _internal_article();
}
inline void MarkupInfo::unsafe_arena_set_allocated_article(
    ::dom_distiller::proto::MarkupArticle* article) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(article_);
  }
  article_ = article;
  if (article) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.MarkupInfo.article)
}
inline ::dom_distiller::proto::MarkupArticle* MarkupInfo::release_article() {
  _has_bits_[0] &= ~0x00000080u;
  ::dom_distiller::proto::MarkupArticle* temp = article_;
  article_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::MarkupArticle* MarkupInfo::unsafe_arena_release_article() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.MarkupInfo.article)
  _has_bits_[0] &= ~0x00000080u;
  ::dom_distiller::proto::MarkupArticle* temp = article_;
  article_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::MarkupArticle* MarkupInfo::_internal_mutable_article() {
  _has_bits_[0] |= 0x00000080u;
  if (article_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::MarkupArticle>(GetArenaForAllocation());
    article_ = p;
  }
  return article_;
}
inline ::dom_distiller::proto::MarkupArticle* MarkupInfo::mutable_article() {
  ::dom_distiller::proto::MarkupArticle* _msg = _internal_mutable_article();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.article)
  return _msg;
}
inline void MarkupInfo::set_allocated_article(::dom_distiller::proto::MarkupArticle* article) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete article_;
  }
  if (article) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(article);
    if (message_arena != submessage_arena) {
      article = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, article, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  article_ = article;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.MarkupInfo.article)
}

// repeated .dom_distiller.proto.MarkupImage images = 9;
inline int MarkupInfo::_internal_images_size() const {
  return images_.size();
}
inline int MarkupInfo::images_size() const {
  return _internal_images_size();
}
inline void MarkupInfo::clear_images() {
  images_.Clear();
}
inline ::dom_distiller::proto::MarkupImage* MarkupInfo::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.MarkupInfo.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::MarkupImage >*
MarkupInfo::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:dom_distiller.proto.MarkupInfo.images)
  return &images_;
}
inline const ::dom_distiller::proto::MarkupImage& MarkupInfo::_internal_images(int index) const {
  return images_.Get(index);
}
inline const ::dom_distiller::proto::MarkupImage& MarkupInfo::images(int index) const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.MarkupInfo.images)
  return _internal_images(index);
}
inline ::dom_distiller::proto::MarkupImage* MarkupInfo::_internal_add_images() {
  return images_.Add();
}
inline ::dom_distiller::proto::MarkupImage* MarkupInfo::add_images() {
  ::dom_distiller::proto::MarkupImage* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:dom_distiller.proto.MarkupInfo.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::MarkupImage >&
MarkupInfo::images() const {
  // @@protoc_insertion_point(field_list:dom_distiller.proto.MarkupInfo.images)
  return images_;
}

// -------------------------------------------------------------------

// TimingEntry

// optional string name = 1;
inline bool TimingEntry::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimingEntry::has_name() const {
  return _internal_has_name();
}
inline void TimingEntry::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TimingEntry::name() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TimingEntry::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingEntry.name)
}
inline std::string* TimingEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.TimingEntry.name)
  return _s;
}
inline const std::string& TimingEntry::_internal_name() const {
  return name_.Get();
}
inline void TimingEntry::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* TimingEntry::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* TimingEntry::release_name() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.TimingEntry.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TimingEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.TimingEntry.name)
}

// optional double time = 2;
inline bool TimingEntry::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimingEntry::has_time() const {
  return _internal_has_time();
}
inline void TimingEntry::clear_time() {
  time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TimingEntry::_internal_time() const {
  return time_;
}
inline double TimingEntry::time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingEntry.time)
  return _internal_time();
}
inline void TimingEntry::_internal_set_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  time_ = value;
}
inline void TimingEntry::set_time(double value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingEntry.time)
}

// -------------------------------------------------------------------

// TimingInfo

// optional double markup_parsing_time = 1;
inline bool TimingInfo::_internal_has_markup_parsing_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TimingInfo::has_markup_parsing_time() const {
  return _internal_has_markup_parsing_time();
}
inline void TimingInfo::clear_markup_parsing_time() {
  markup_parsing_time_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double TimingInfo::_internal_markup_parsing_time() const {
  return markup_parsing_time_;
}
inline double TimingInfo::markup_parsing_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingInfo.markup_parsing_time)
  return _internal_markup_parsing_time();
}
inline void TimingInfo::_internal_set_markup_parsing_time(double value) {
  _has_bits_[0] |= 0x00000001u;
  markup_parsing_time_ = value;
}
inline void TimingInfo::set_markup_parsing_time(double value) {
  _internal_set_markup_parsing_time(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingInfo.markup_parsing_time)
}

// optional double document_construction_time = 2;
inline bool TimingInfo::_internal_has_document_construction_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TimingInfo::has_document_construction_time() const {
  return _internal_has_document_construction_time();
}
inline void TimingInfo::clear_document_construction_time() {
  document_construction_time_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline double TimingInfo::_internal_document_construction_time() const {
  return document_construction_time_;
}
inline double TimingInfo::document_construction_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingInfo.document_construction_time)
  return _internal_document_construction_time();
}
inline void TimingInfo::_internal_set_document_construction_time(double value) {
  _has_bits_[0] |= 0x00000002u;
  document_construction_time_ = value;
}
inline void TimingInfo::set_document_construction_time(double value) {
  _internal_set_document_construction_time(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingInfo.document_construction_time)
}

// optional double article_processing_time = 3;
inline bool TimingInfo::_internal_has_article_processing_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TimingInfo::has_article_processing_time() const {
  return _internal_has_article_processing_time();
}
inline void TimingInfo::clear_article_processing_time() {
  article_processing_time_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline double TimingInfo::_internal_article_processing_time() const {
  return article_processing_time_;
}
inline double TimingInfo::article_processing_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingInfo.article_processing_time)
  return _internal_article_processing_time();
}
inline void TimingInfo::_internal_set_article_processing_time(double value) {
  _has_bits_[0] |= 0x00000004u;
  article_processing_time_ = value;
}
inline void TimingInfo::set_article_processing_time(double value) {
  _internal_set_article_processing_time(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingInfo.article_processing_time)
}

// optional double formatting_time = 4;
inline bool TimingInfo::_internal_has_formatting_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TimingInfo::has_formatting_time() const {
  return _internal_has_formatting_time();
}
inline void TimingInfo::clear_formatting_time() {
  formatting_time_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline double TimingInfo::_internal_formatting_time() const {
  return formatting_time_;
}
inline double TimingInfo::formatting_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingInfo.formatting_time)
  return _internal_formatting_time();
}
inline void TimingInfo::_internal_set_formatting_time(double value) {
  _has_bits_[0] |= 0x00000008u;
  formatting_time_ = value;
}
inline void TimingInfo::set_formatting_time(double value) {
  _internal_set_formatting_time(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingInfo.formatting_time)
}

// optional double total_time = 5;
inline bool TimingInfo::_internal_has_total_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TimingInfo::has_total_time() const {
  return _internal_has_total_time();
}
inline void TimingInfo::clear_total_time() {
  total_time_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline double TimingInfo::_internal_total_time() const {
  return total_time_;
}
inline double TimingInfo::total_time() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingInfo.total_time)
  return _internal_total_time();
}
inline void TimingInfo::_internal_set_total_time(double value) {
  _has_bits_[0] |= 0x00000010u;
  total_time_ = value;
}
inline void TimingInfo::set_total_time(double value) {
  _internal_set_total_time(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.TimingInfo.total_time)
}

// repeated .dom_distiller.proto.TimingEntry other_times = 6;
inline int TimingInfo::_internal_other_times_size() const {
  return other_times_.size();
}
inline int TimingInfo::other_times_size() const {
  return _internal_other_times_size();
}
inline void TimingInfo::clear_other_times() {
  other_times_.Clear();
}
inline ::dom_distiller::proto::TimingEntry* TimingInfo::mutable_other_times(int index) {
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.TimingInfo.other_times)
  return other_times_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::TimingEntry >*
TimingInfo::mutable_other_times() {
  // @@protoc_insertion_point(field_mutable_list:dom_distiller.proto.TimingInfo.other_times)
  return &other_times_;
}
inline const ::dom_distiller::proto::TimingEntry& TimingInfo::_internal_other_times(int index) const {
  return other_times_.Get(index);
}
inline const ::dom_distiller::proto::TimingEntry& TimingInfo::other_times(int index) const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.TimingInfo.other_times)
  return _internal_other_times(index);
}
inline ::dom_distiller::proto::TimingEntry* TimingInfo::_internal_add_other_times() {
  return other_times_.Add();
}
inline ::dom_distiller::proto::TimingEntry* TimingInfo::add_other_times() {
  ::dom_distiller::proto::TimingEntry* _add = _internal_add_other_times();
  // @@protoc_insertion_point(field_add:dom_distiller.proto.TimingInfo.other_times)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::TimingEntry >&
TimingInfo::other_times() const {
  // @@protoc_insertion_point(field_list:dom_distiller.proto.TimingInfo.other_times)
  return other_times_;
}

// -------------------------------------------------------------------

// DebugInfo

// optional string log = 1;
inline bool DebugInfo::_internal_has_log() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DebugInfo::has_log() const {
  return _internal_has_log();
}
inline void DebugInfo::clear_log() {
  log_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DebugInfo::log() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DebugInfo.log)
  return _internal_log();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DebugInfo::set_log(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 log_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DebugInfo.log)
}
inline std::string* DebugInfo::mutable_log() {
  std::string* _s = _internal_mutable_log();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DebugInfo.log)
  return _s;
}
inline const std::string& DebugInfo::_internal_log() const {
  return log_.Get();
}
inline void DebugInfo::_internal_set_log(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  log_.Set(value, GetArenaForAllocation());
}
inline std::string* DebugInfo::_internal_mutable_log() {
  _has_bits_[0] |= 0x00000001u;
  return log_.Mutable(GetArenaForAllocation());
}
inline std::string* DebugInfo::release_log() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DebugInfo.log)
  if (!_internal_has_log()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = log_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_.IsDefault()) {
    log_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DebugInfo::set_allocated_log(std::string* log) {
  if (log != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  log_.SetAllocated(log, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (log_.IsDefault()) {
    log_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DebugInfo.log)
}

// -------------------------------------------------------------------

// StatisticsInfo

// optional int32 word_count = 1;
inline bool StatisticsInfo::_internal_has_word_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StatisticsInfo::has_word_count() const {
  return _internal_has_word_count();
}
inline void StatisticsInfo::clear_word_count() {
  word_count_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t StatisticsInfo::_internal_word_count() const {
  return word_count_;
}
inline int32_t StatisticsInfo::word_count() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.StatisticsInfo.word_count)
  return _internal_word_count();
}
inline void StatisticsInfo::_internal_set_word_count(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  word_count_ = value;
}
inline void StatisticsInfo::set_word_count(int32_t value) {
  _internal_set_word_count(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.StatisticsInfo.word_count)
}

// -------------------------------------------------------------------

// DomDistillerResult_ContentImage

// optional string url = 1;
inline bool DomDistillerResult_ContentImage::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DomDistillerResult_ContentImage::has_url() const {
  return _internal_has_url();
}
inline void DomDistillerResult_ContentImage::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DomDistillerResult_ContentImage::url() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.ContentImage.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DomDistillerResult_ContentImage::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerResult.ContentImage.url)
}
inline std::string* DomDistillerResult_ContentImage::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.ContentImage.url)
  return _s;
}
inline const std::string& DomDistillerResult_ContentImage::_internal_url() const {
  return url_.Get();
}
inline void DomDistillerResult_ContentImage::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* DomDistillerResult_ContentImage::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* DomDistillerResult_ContentImage::release_url() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.ContentImage.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DomDistillerResult_ContentImage::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.ContentImage.url)
}

// -------------------------------------------------------------------

// DomDistillerResult

// optional string title = 1;
inline bool DomDistillerResult::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DomDistillerResult::has_title() const {
  return _internal_has_title();
}
inline void DomDistillerResult::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DomDistillerResult::title() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DomDistillerResult::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerResult.title)
}
inline std::string* DomDistillerResult::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.title)
  return _s;
}
inline const std::string& DomDistillerResult::_internal_title() const {
  return title_.Get();
}
inline void DomDistillerResult::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* DomDistillerResult::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* DomDistillerResult::release_title() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DomDistillerResult::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.title)
}

// optional .dom_distiller.proto.DistilledContent distilled_content = 2;
inline bool DomDistillerResult::_internal_has_distilled_content() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || distilled_content_ != nullptr);
  return value;
}
inline bool DomDistillerResult::has_distilled_content() const {
  return _internal_has_distilled_content();
}
inline void DomDistillerResult::clear_distilled_content() {
  if (distilled_content_ != nullptr) distilled_content_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::dom_distiller::proto::DistilledContent& DomDistillerResult::_internal_distilled_content() const {
  const ::dom_distiller::proto::DistilledContent* p = distilled_content_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::DistilledContent&>(
      ::dom_distiller::proto::_DistilledContent_default_instance_);
}
inline const ::dom_distiller::proto::DistilledContent& DomDistillerResult::distilled_content() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.distilled_content)
  return _internal_distilled_content();
}
inline void DomDistillerResult::unsafe_arena_set_allocated_distilled_content(
    ::dom_distiller::proto::DistilledContent* distilled_content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(distilled_content_);
  }
  distilled_content_ = distilled_content;
  if (distilled_content) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.DomDistillerResult.distilled_content)
}
inline ::dom_distiller::proto::DistilledContent* DomDistillerResult::release_distilled_content() {
  _has_bits_[0] &= ~0x00000004u;
  ::dom_distiller::proto::DistilledContent* temp = distilled_content_;
  distilled_content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::DistilledContent* DomDistillerResult::unsafe_arena_release_distilled_content() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.distilled_content)
  _has_bits_[0] &= ~0x00000004u;
  ::dom_distiller::proto::DistilledContent* temp = distilled_content_;
  distilled_content_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::DistilledContent* DomDistillerResult::_internal_mutable_distilled_content() {
  _has_bits_[0] |= 0x00000004u;
  if (distilled_content_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::DistilledContent>(GetArenaForAllocation());
    distilled_content_ = p;
  }
  return distilled_content_;
}
inline ::dom_distiller::proto::DistilledContent* DomDistillerResult::mutable_distilled_content() {
  ::dom_distiller::proto::DistilledContent* _msg = _internal_mutable_distilled_content();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.distilled_content)
  return _msg;
}
inline void DomDistillerResult::set_allocated_distilled_content(::dom_distiller::proto::DistilledContent* distilled_content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete distilled_content_;
  }
  if (distilled_content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(distilled_content);
    if (message_arena != submessage_arena) {
      distilled_content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, distilled_content, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  distilled_content_ = distilled_content;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.distilled_content)
}

// optional .dom_distiller.proto.PaginationInfo pagination_info = 3;
inline bool DomDistillerResult::_internal_has_pagination_info() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || pagination_info_ != nullptr);
  return value;
}
inline bool DomDistillerResult::has_pagination_info() const {
  return _internal_has_pagination_info();
}
inline void DomDistillerResult::clear_pagination_info() {
  if (pagination_info_ != nullptr) pagination_info_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::dom_distiller::proto::PaginationInfo& DomDistillerResult::_internal_pagination_info() const {
  const ::dom_distiller::proto::PaginationInfo* p = pagination_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::PaginationInfo&>(
      ::dom_distiller::proto::_PaginationInfo_default_instance_);
}
inline const ::dom_distiller::proto::PaginationInfo& DomDistillerResult::pagination_info() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.pagination_info)
  return _internal_pagination_info();
}
inline void DomDistillerResult::unsafe_arena_set_allocated_pagination_info(
    ::dom_distiller::proto::PaginationInfo* pagination_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pagination_info_);
  }
  pagination_info_ = pagination_info;
  if (pagination_info) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.DomDistillerResult.pagination_info)
}
inline ::dom_distiller::proto::PaginationInfo* DomDistillerResult::release_pagination_info() {
  _has_bits_[0] &= ~0x00000008u;
  ::dom_distiller::proto::PaginationInfo* temp = pagination_info_;
  pagination_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::PaginationInfo* DomDistillerResult::unsafe_arena_release_pagination_info() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.pagination_info)
  _has_bits_[0] &= ~0x00000008u;
  ::dom_distiller::proto::PaginationInfo* temp = pagination_info_;
  pagination_info_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::PaginationInfo* DomDistillerResult::_internal_mutable_pagination_info() {
  _has_bits_[0] |= 0x00000008u;
  if (pagination_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::PaginationInfo>(GetArenaForAllocation());
    pagination_info_ = p;
  }
  return pagination_info_;
}
inline ::dom_distiller::proto::PaginationInfo* DomDistillerResult::mutable_pagination_info() {
  ::dom_distiller::proto::PaginationInfo* _msg = _internal_mutable_pagination_info();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.pagination_info)
  return _msg;
}
inline void DomDistillerResult::set_allocated_pagination_info(::dom_distiller::proto::PaginationInfo* pagination_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pagination_info_;
  }
  if (pagination_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pagination_info);
    if (message_arena != submessage_arena) {
      pagination_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pagination_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  pagination_info_ = pagination_info;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.pagination_info)
}

// optional .dom_distiller.proto.MarkupInfo markup_info = 5;
inline bool DomDistillerResult::_internal_has_markup_info() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || markup_info_ != nullptr);
  return value;
}
inline bool DomDistillerResult::has_markup_info() const {
  return _internal_has_markup_info();
}
inline void DomDistillerResult::clear_markup_info() {
  if (markup_info_ != nullptr) markup_info_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::dom_distiller::proto::MarkupInfo& DomDistillerResult::_internal_markup_info() const {
  const ::dom_distiller::proto::MarkupInfo* p = markup_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::MarkupInfo&>(
      ::dom_distiller::proto::_MarkupInfo_default_instance_);
}
inline const ::dom_distiller::proto::MarkupInfo& DomDistillerResult::markup_info() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.markup_info)
  return _internal_markup_info();
}
inline void DomDistillerResult::unsafe_arena_set_allocated_markup_info(
    ::dom_distiller::proto::MarkupInfo* markup_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(markup_info_);
  }
  markup_info_ = markup_info;
  if (markup_info) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.DomDistillerResult.markup_info)
}
inline ::dom_distiller::proto::MarkupInfo* DomDistillerResult::release_markup_info() {
  _has_bits_[0] &= ~0x00000010u;
  ::dom_distiller::proto::MarkupInfo* temp = markup_info_;
  markup_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::MarkupInfo* DomDistillerResult::unsafe_arena_release_markup_info() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.markup_info)
  _has_bits_[0] &= ~0x00000010u;
  ::dom_distiller::proto::MarkupInfo* temp = markup_info_;
  markup_info_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::MarkupInfo* DomDistillerResult::_internal_mutable_markup_info() {
  _has_bits_[0] |= 0x00000010u;
  if (markup_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::MarkupInfo>(GetArenaForAllocation());
    markup_info_ = p;
  }
  return markup_info_;
}
inline ::dom_distiller::proto::MarkupInfo* DomDistillerResult::mutable_markup_info() {
  ::dom_distiller::proto::MarkupInfo* _msg = _internal_mutable_markup_info();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.markup_info)
  return _msg;
}
inline void DomDistillerResult::set_allocated_markup_info(::dom_distiller::proto::MarkupInfo* markup_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete markup_info_;
  }
  if (markup_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(markup_info);
    if (message_arena != submessage_arena) {
      markup_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, markup_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  markup_info_ = markup_info;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.markup_info)
}

// optional .dom_distiller.proto.TimingInfo timing_info = 6;
inline bool DomDistillerResult::_internal_has_timing_info() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || timing_info_ != nullptr);
  return value;
}
inline bool DomDistillerResult::has_timing_info() const {
  return _internal_has_timing_info();
}
inline void DomDistillerResult::clear_timing_info() {
  if (timing_info_ != nullptr) timing_info_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::dom_distiller::proto::TimingInfo& DomDistillerResult::_internal_timing_info() const {
  const ::dom_distiller::proto::TimingInfo* p = timing_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::TimingInfo&>(
      ::dom_distiller::proto::_TimingInfo_default_instance_);
}
inline const ::dom_distiller::proto::TimingInfo& DomDistillerResult::timing_info() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.timing_info)
  return _internal_timing_info();
}
inline void DomDistillerResult::unsafe_arena_set_allocated_timing_info(
    ::dom_distiller::proto::TimingInfo* timing_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timing_info_);
  }
  timing_info_ = timing_info;
  if (timing_info) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.DomDistillerResult.timing_info)
}
inline ::dom_distiller::proto::TimingInfo* DomDistillerResult::release_timing_info() {
  _has_bits_[0] &= ~0x00000020u;
  ::dom_distiller::proto::TimingInfo* temp = timing_info_;
  timing_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::TimingInfo* DomDistillerResult::unsafe_arena_release_timing_info() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.timing_info)
  _has_bits_[0] &= ~0x00000020u;
  ::dom_distiller::proto::TimingInfo* temp = timing_info_;
  timing_info_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::TimingInfo* DomDistillerResult::_internal_mutable_timing_info() {
  _has_bits_[0] |= 0x00000020u;
  if (timing_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::TimingInfo>(GetArenaForAllocation());
    timing_info_ = p;
  }
  return timing_info_;
}
inline ::dom_distiller::proto::TimingInfo* DomDistillerResult::mutable_timing_info() {
  ::dom_distiller::proto::TimingInfo* _msg = _internal_mutable_timing_info();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.timing_info)
  return _msg;
}
inline void DomDistillerResult::set_allocated_timing_info(::dom_distiller::proto::TimingInfo* timing_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timing_info_;
  }
  if (timing_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(timing_info);
    if (message_arena != submessage_arena) {
      timing_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timing_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  timing_info_ = timing_info;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.timing_info)
}

// optional .dom_distiller.proto.DebugInfo debug_info = 7;
inline bool DomDistillerResult::_internal_has_debug_info() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || debug_info_ != nullptr);
  return value;
}
inline bool DomDistillerResult::has_debug_info() const {
  return _internal_has_debug_info();
}
inline void DomDistillerResult::clear_debug_info() {
  if (debug_info_ != nullptr) debug_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::dom_distiller::proto::DebugInfo& DomDistillerResult::_internal_debug_info() const {
  const ::dom_distiller::proto::DebugInfo* p = debug_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::DebugInfo&>(
      ::dom_distiller::proto::_DebugInfo_default_instance_);
}
inline const ::dom_distiller::proto::DebugInfo& DomDistillerResult::debug_info() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.debug_info)
  return _internal_debug_info();
}
inline void DomDistillerResult::unsafe_arena_set_allocated_debug_info(
    ::dom_distiller::proto::DebugInfo* debug_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_info_);
  }
  debug_info_ = debug_info;
  if (debug_info) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.DomDistillerResult.debug_info)
}
inline ::dom_distiller::proto::DebugInfo* DomDistillerResult::release_debug_info() {
  _has_bits_[0] &= ~0x00000040u;
  ::dom_distiller::proto::DebugInfo* temp = debug_info_;
  debug_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::DebugInfo* DomDistillerResult::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.debug_info)
  _has_bits_[0] &= ~0x00000040u;
  ::dom_distiller::proto::DebugInfo* temp = debug_info_;
  debug_info_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::DebugInfo* DomDistillerResult::_internal_mutable_debug_info() {
  _has_bits_[0] |= 0x00000040u;
  if (debug_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::DebugInfo>(GetArenaForAllocation());
    debug_info_ = p;
  }
  return debug_info_;
}
inline ::dom_distiller::proto::DebugInfo* DomDistillerResult::mutable_debug_info() {
  ::dom_distiller::proto::DebugInfo* _msg = _internal_mutable_debug_info();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.debug_info)
  return _msg;
}
inline void DomDistillerResult::set_allocated_debug_info(::dom_distiller::proto::DebugInfo* debug_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete debug_info_;
  }
  if (debug_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(debug_info);
    if (message_arena != submessage_arena) {
      debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  debug_info_ = debug_info;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.debug_info)
}

// optional .dom_distiller.proto.StatisticsInfo statistics_info = 8;
inline bool DomDistillerResult::_internal_has_statistics_info() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || statistics_info_ != nullptr);
  return value;
}
inline bool DomDistillerResult::has_statistics_info() const {
  return _internal_has_statistics_info();
}
inline void DomDistillerResult::clear_statistics_info() {
  if (statistics_info_ != nullptr) statistics_info_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::dom_distiller::proto::StatisticsInfo& DomDistillerResult::_internal_statistics_info() const {
  const ::dom_distiller::proto::StatisticsInfo* p = statistics_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::dom_distiller::proto::StatisticsInfo&>(
      ::dom_distiller::proto::_StatisticsInfo_default_instance_);
}
inline const ::dom_distiller::proto::StatisticsInfo& DomDistillerResult::statistics_info() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.statistics_info)
  return _internal_statistics_info();
}
inline void DomDistillerResult::unsafe_arena_set_allocated_statistics_info(
    ::dom_distiller::proto::StatisticsInfo* statistics_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(statistics_info_);
  }
  statistics_info_ = statistics_info;
  if (statistics_info) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:dom_distiller.proto.DomDistillerResult.statistics_info)
}
inline ::dom_distiller::proto::StatisticsInfo* DomDistillerResult::release_statistics_info() {
  _has_bits_[0] &= ~0x00000080u;
  ::dom_distiller::proto::StatisticsInfo* temp = statistics_info_;
  statistics_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::dom_distiller::proto::StatisticsInfo* DomDistillerResult::unsafe_arena_release_statistics_info() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.statistics_info)
  _has_bits_[0] &= ~0x00000080u;
  ::dom_distiller::proto::StatisticsInfo* temp = statistics_info_;
  statistics_info_ = nullptr;
  return temp;
}
inline ::dom_distiller::proto::StatisticsInfo* DomDistillerResult::_internal_mutable_statistics_info() {
  _has_bits_[0] |= 0x00000080u;
  if (statistics_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::dom_distiller::proto::StatisticsInfo>(GetArenaForAllocation());
    statistics_info_ = p;
  }
  return statistics_info_;
}
inline ::dom_distiller::proto::StatisticsInfo* DomDistillerResult::mutable_statistics_info() {
  ::dom_distiller::proto::StatisticsInfo* _msg = _internal_mutable_statistics_info();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.statistics_info)
  return _msg;
}
inline void DomDistillerResult::set_allocated_statistics_info(::dom_distiller::proto::StatisticsInfo* statistics_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete statistics_info_;
  }
  if (statistics_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(statistics_info);
    if (message_arena != submessage_arena) {
      statistics_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, statistics_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  statistics_info_ = statistics_info;
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.statistics_info)
}

// optional string text_direction = 9;
inline bool DomDistillerResult::_internal_has_text_direction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DomDistillerResult::has_text_direction() const {
  return _internal_has_text_direction();
}
inline void DomDistillerResult::clear_text_direction() {
  text_direction_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DomDistillerResult::text_direction() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.text_direction)
  return _internal_text_direction();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DomDistillerResult::set_text_direction(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 text_direction_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerResult.text_direction)
}
inline std::string* DomDistillerResult::mutable_text_direction() {
  std::string* _s = _internal_mutable_text_direction();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.text_direction)
  return _s;
}
inline const std::string& DomDistillerResult::_internal_text_direction() const {
  return text_direction_.Get();
}
inline void DomDistillerResult::_internal_set_text_direction(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  text_direction_.Set(value, GetArenaForAllocation());
}
inline std::string* DomDistillerResult::_internal_mutable_text_direction() {
  _has_bits_[0] |= 0x00000002u;
  return text_direction_.Mutable(GetArenaForAllocation());
}
inline std::string* DomDistillerResult::release_text_direction() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerResult.text_direction)
  if (!_internal_has_text_direction()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = text_direction_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_direction_.IsDefault()) {
    text_direction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DomDistillerResult::set_allocated_text_direction(std::string* text_direction) {
  if (text_direction != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  text_direction_.SetAllocated(text_direction, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_direction_.IsDefault()) {
    text_direction_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerResult.text_direction)
}

// repeated .dom_distiller.proto.DomDistillerResult.ContentImage content_images = 10;
inline int DomDistillerResult::_internal_content_images_size() const {
  return content_images_.size();
}
inline int DomDistillerResult::content_images_size() const {
  return _internal_content_images_size();
}
inline void DomDistillerResult::clear_content_images() {
  content_images_.Clear();
}
inline ::dom_distiller::proto::DomDistillerResult_ContentImage* DomDistillerResult::mutable_content_images(int index) {
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerResult.content_images)
  return content_images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::DomDistillerResult_ContentImage >*
DomDistillerResult::mutable_content_images() {
  // @@protoc_insertion_point(field_mutable_list:dom_distiller.proto.DomDistillerResult.content_images)
  return &content_images_;
}
inline const ::dom_distiller::proto::DomDistillerResult_ContentImage& DomDistillerResult::_internal_content_images(int index) const {
  return content_images_.Get(index);
}
inline const ::dom_distiller::proto::DomDistillerResult_ContentImage& DomDistillerResult::content_images(int index) const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerResult.content_images)
  return _internal_content_images(index);
}
inline ::dom_distiller::proto::DomDistillerResult_ContentImage* DomDistillerResult::_internal_add_content_images() {
  return content_images_.Add();
}
inline ::dom_distiller::proto::DomDistillerResult_ContentImage* DomDistillerResult::add_content_images() {
  ::dom_distiller::proto::DomDistillerResult_ContentImage* _add = _internal_add_content_images();
  // @@protoc_insertion_point(field_add:dom_distiller.proto.DomDistillerResult.content_images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dom_distiller::proto::DomDistillerResult_ContentImage >&
DomDistillerResult::content_images() const {
  // @@protoc_insertion_point(field_list:dom_distiller.proto.DomDistillerResult.content_images)
  return content_images_;
}

// -------------------------------------------------------------------

// DomDistillerOptions

// optional bool extract_text_only = 1;
inline bool DomDistillerOptions::_internal_has_extract_text_only() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DomDistillerOptions::has_extract_text_only() const {
  return _internal_has_extract_text_only();
}
inline void DomDistillerOptions::clear_extract_text_only() {
  extract_text_only_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool DomDistillerOptions::_internal_extract_text_only() const {
  return extract_text_only_;
}
inline bool DomDistillerOptions::extract_text_only() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerOptions.extract_text_only)
  return _internal_extract_text_only();
}
inline void DomDistillerOptions::_internal_set_extract_text_only(bool value) {
  _has_bits_[0] |= 0x00000004u;
  extract_text_only_ = value;
}
inline void DomDistillerOptions::set_extract_text_only(bool value) {
  _internal_set_extract_text_only(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerOptions.extract_text_only)
}

// optional int32 debug_level = 2;
inline bool DomDistillerOptions::_internal_has_debug_level() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DomDistillerOptions::has_debug_level() const {
  return _internal_has_debug_level();
}
inline void DomDistillerOptions::clear_debug_level() {
  debug_level_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t DomDistillerOptions::_internal_debug_level() const {
  return debug_level_;
}
inline int32_t DomDistillerOptions::debug_level() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerOptions.debug_level)
  return _internal_debug_level();
}
inline void DomDistillerOptions::_internal_set_debug_level(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  debug_level_ = value;
}
inline void DomDistillerOptions::set_debug_level(int32_t value) {
  _internal_set_debug_level(value);
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerOptions.debug_level)
}

// optional string original_url = 3;
inline bool DomDistillerOptions::_internal_has_original_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DomDistillerOptions::has_original_url() const {
  return _internal_has_original_url();
}
inline void DomDistillerOptions::clear_original_url() {
  original_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DomDistillerOptions::original_url() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerOptions.original_url)
  return _internal_original_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DomDistillerOptions::set_original_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 original_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerOptions.original_url)
}
inline std::string* DomDistillerOptions::mutable_original_url() {
  std::string* _s = _internal_mutable_original_url();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerOptions.original_url)
  return _s;
}
inline const std::string& DomDistillerOptions::_internal_original_url() const {
  return original_url_.Get();
}
inline void DomDistillerOptions::_internal_set_original_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  original_url_.Set(value, GetArenaForAllocation());
}
inline std::string* DomDistillerOptions::_internal_mutable_original_url() {
  _has_bits_[0] |= 0x00000001u;
  return original_url_.Mutable(GetArenaForAllocation());
}
inline std::string* DomDistillerOptions::release_original_url() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerOptions.original_url)
  if (!_internal_has_original_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = original_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (original_url_.IsDefault()) {
    original_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DomDistillerOptions::set_allocated_original_url(std::string* original_url) {
  if (original_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  original_url_.SetAllocated(original_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (original_url_.IsDefault()) {
    original_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerOptions.original_url)
}

// optional string pagination_algo = 4;
inline bool DomDistillerOptions::_internal_has_pagination_algo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DomDistillerOptions::has_pagination_algo() const {
  return _internal_has_pagination_algo();
}
inline void DomDistillerOptions::clear_pagination_algo() {
  pagination_algo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DomDistillerOptions::pagination_algo() const {
  // @@protoc_insertion_point(field_get:dom_distiller.proto.DomDistillerOptions.pagination_algo)
  return _internal_pagination_algo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DomDistillerOptions::set_pagination_algo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 pagination_algo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:dom_distiller.proto.DomDistillerOptions.pagination_algo)
}
inline std::string* DomDistillerOptions::mutable_pagination_algo() {
  std::string* _s = _internal_mutable_pagination_algo();
  // @@protoc_insertion_point(field_mutable:dom_distiller.proto.DomDistillerOptions.pagination_algo)
  return _s;
}
inline const std::string& DomDistillerOptions::_internal_pagination_algo() const {
  return pagination_algo_.Get();
}
inline void DomDistillerOptions::_internal_set_pagination_algo(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pagination_algo_.Set(value, GetArenaForAllocation());
}
inline std::string* DomDistillerOptions::_internal_mutable_pagination_algo() {
  _has_bits_[0] |= 0x00000002u;
  return pagination_algo_.Mutable(GetArenaForAllocation());
}
inline std::string* DomDistillerOptions::release_pagination_algo() {
  // @@protoc_insertion_point(field_release:dom_distiller.proto.DomDistillerOptions.pagination_algo)
  if (!_internal_has_pagination_algo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = pagination_algo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pagination_algo_.IsDefault()) {
    pagination_algo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DomDistillerOptions::set_allocated_pagination_algo(std::string* pagination_algo) {
  if (pagination_algo != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pagination_algo_.SetAllocated(pagination_algo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pagination_algo_.IsDefault()) {
    pagination_algo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:dom_distiller.proto.DomDistillerOptions.pagination_algo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace dom_distiller

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dom_5fdistiller_2eproto
