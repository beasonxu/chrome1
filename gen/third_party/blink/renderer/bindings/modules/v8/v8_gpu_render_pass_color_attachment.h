// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#ifndef THIRD_PARTY_BLINK_RENDERER_BINDINGS_MODULES_V8_V8_GPU_RENDER_PASS_COLOR_ATTACHMENT_H_
#define THIRD_PARTY_BLINK_RENDERER_BINDINGS_MODULES_V8_V8_GPU_RENDER_PASS_COLOR_ATTACHMENT_H_

#include "base/containers/span.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_gpu_load_op.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_gpu_store_op.h"
#include "third_party/blink/renderer/modules/modules_export.h"
#include "third_party/blink/renderer/platform/bindings/dictionary_base.h"
#include "third_party/blink/renderer/platform/heap/collection_support/heap_vector.h"
#include "third_party/blink/renderer/platform/heap/member.h"

namespace blink {

class ExceptionState;
class GPUColorDict;
class GPUTextureView;
class V8UnionDoubleSequenceOrGPUColorDict;
class V8UnionDoubleSequenceOrGPUColorDictOrGPULoadOp;

class MODULES_EXPORT GPURenderPassColorAttachment : public bindings::DictionaryBase {
  
  public:
static GPURenderPassColorAttachment* Create() {
  return MakeGarbageCollected<GPURenderPassColorAttachment>();
}
static GPURenderPassColorAttachment* Create(v8::Isolate* isolate) {
  return MakeGarbageCollected<GPURenderPassColorAttachment>(isolate);
}
static GPURenderPassColorAttachment* Create(v8::Isolate* isolate, v8::Local<v8::Value> v8_value, ExceptionState& exception_state);

explicit  GPURenderPassColorAttachment();
explicit  GPURenderPassColorAttachment(v8::Isolate* isolate);

bool hasClearValue() const {
  return has_clear_value_;
}
V8UnionDoubleSequenceOrGPUColorDict* clearValue() const {
  DCHECK(hasClearValue());
return member_clear_value_;
}
V8UnionDoubleSequenceOrGPUColorDict* getClearValueOr(V8UnionDoubleSequenceOrGPUColorDict* fallback_value) const {
  if (!hasClearValue()) {
  return fallback_value;
}
return member_clear_value_;
}
void setClearValue(V8UnionDoubleSequenceOrGPUColorDict* value) {
  member_clear_value_ = value;
has_clear_value_ = true;
DCHECK(member_clear_value_);
}

bool hasLoadOp() const {
  return has_load_op_;
}
V8GPULoadOp loadOp() const {
  DCHECK(hasLoadOp());
return member_load_op_;
}
V8GPULoadOp getLoadOpOr(V8GPULoadOp fallback_value) const {
  if (!hasLoadOp()) {
  return fallback_value;
}
return member_load_op_;
}
void setLoadOp(V8GPULoadOp value) {
  member_load_op_ = value;
has_load_op_ = true;
}
void setLoadOp(V8GPULoadOp::Enum value) {
  member_load_op_ = V8GPULoadOp(value);
has_load_op_ = true;
}

bool hasLoadValue() const {
  return has_load_value_;
}
V8UnionDoubleSequenceOrGPUColorDictOrGPULoadOp* loadValue() const {
  DCHECK(hasLoadValue());
return member_load_value_;
}
V8UnionDoubleSequenceOrGPUColorDictOrGPULoadOp* getLoadValueOr(V8UnionDoubleSequenceOrGPUColorDictOrGPULoadOp* fallback_value) const {
  if (!hasLoadValue()) {
  return fallback_value;
}
return member_load_value_;
}
void setLoadValue(V8UnionDoubleSequenceOrGPUColorDictOrGPULoadOp* value) {
  member_load_value_ = value;
has_load_value_ = true;
DCHECK(member_load_value_);
}

bool hasResolveTarget() const {
  return has_resolve_target_;
}
GPUTextureView* resolveTarget() const {
  DCHECK(hasResolveTarget());
return member_resolve_target_;
}
GPUTextureView* getResolveTargetOr(GPUTextureView* fallback_value) const {
  if (!hasResolveTarget()) {
  return fallback_value;
}
return member_resolve_target_;
}
void setResolveTarget(GPUTextureView* value) {
  member_resolve_target_ = value;
has_resolve_target_ = true;
DCHECK(member_resolve_target_);
}

bool hasStoreOp() const {
  return has_store_op_;
}
V8GPUStoreOp storeOp() const {
  DCHECK(hasStoreOp());
return member_store_op_;
}
V8GPUStoreOp getStoreOpOr(V8GPUStoreOp fallback_value) const {
  if (!hasStoreOp()) {
  return fallback_value;
}
return member_store_op_;
}
void setStoreOp(V8GPUStoreOp value) {
  member_store_op_ = value;
has_store_op_ = true;
}
void setStoreOp(V8GPUStoreOp::Enum value) {
  member_store_op_ = V8GPUStoreOp(value);
has_store_op_ = true;
}

bool hasView() const {
  return true;
}
GPUTextureView* view() const {
  return member_view_;
}
void setView(GPUTextureView* value) {
  member_view_ = value;
DCHECK(member_view_);
}


// Obsolete accessor functions
void setLoadOp(const String& value) {
  member_load_op_ = V8GPULoadOp::Create(value).value();
has_load_op_ = true;
}
void setStoreOp(const String& value) {
  member_store_op_ = V8GPUStoreOp::Create(value).value();
has_store_op_ = true;
}

void Trace(Visitor* visitor) const override;


  protected:
bool FillV8ObjectWithMembers(ScriptState* script_state, v8::Local<v8::Object> v8_dictionary) const override;

void FillMembersFromV8Object(v8::Isolate* isolate, v8::Local<v8::Object> v8_dictionary, ExceptionState& exception_state);


  private:
static const base::span<const v8::Eternal<v8::Name>> GetV8OwnMemberNames(v8::Isolate* isolate);

bool has_clear_value_ = false;
bool has_load_op_ = false;
bool has_load_value_ = false;
bool has_resolve_target_ = false;
bool has_store_op_ = false;

Member<V8UnionDoubleSequenceOrGPUColorDict> member_clear_value_;
V8GPULoadOp member_load_op_{static_cast<V8GPULoadOp::Enum>(0)};
Member<V8UnionDoubleSequenceOrGPUColorDictOrGPULoadOp> member_load_value_;
Member<GPUTextureView> member_resolve_target_;
V8GPUStoreOp member_store_op_{static_cast<V8GPUStoreOp::Enum>(0)};
Member<GPUTextureView> member_view_;


  
};


}  // namespace blink

#endif  // THIRD_PARTY_BLINK_RENDERER_BINDINGS_MODULES_V8_V8_GPU_RENDER_PASS_COLOR_ATTACHMENT_H_
