// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_worker_global_scope.h"

#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_blob.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_event_handler_non_null.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_font_face_set.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_function.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_canvas_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_image_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_video_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_bitmap.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_bitmap_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_data.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_offscreen_canvas.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_performance.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_request.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_request_init.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_structured_serialize_options.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_svg_image_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_trusted_type_policy_factory.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_request_usvstring.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_void_function.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_worker_location.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_worker_navigator.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_cache_storage.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_crypto.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_idb_factory.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_native_io_file_manager.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_scheduler.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_union_blob_htmlcanvaselement_htmlimageelement_htmlvideoelement_imagebitmap_imagedata_offscreencanvas_svgimageelement_videoframe.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_video_frame.h"
#include "third_party/blink/renderer/core/css/font_face_set.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/fetch/global_fetch.h"
#include "third_party/blink/renderer/core/fetch/request.h"
#include "third_party/blink/renderer/core/fileapi/blob.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/frame/window_or_worker_global_scope.h"
#include "third_party/blink/renderer/core/html/canvas/html_canvas_element.h"
#include "third_party/blink/renderer/core/html/canvas/image_data.h"
#include "third_party/blink/renderer/core/html/html_image_element.h"
#include "third_party/blink/renderer/core/html/media/html_video_element.h"
#include "third_party/blink/renderer/core/imagebitmap/image_bitmap.h"
#include "third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h"
#include "third_party/blink/renderer/core/svg/svg_image_element.h"
#include "third_party/blink/renderer/core/timing/performance.h"
#include "third_party/blink/renderer/core/timing/worker_global_scope_performance.h"
#include "third_party/blink/renderer/core/trustedtypes/trusted_type_policy_factory.h"
#include "third_party/blink/renderer/core/workers/worker_global_scope.h"
#include "third_party/blink/renderer/core/workers/worker_location.h"
#include "third_party/blink/renderer/core/workers/worker_navigator.h"
#include "third_party/blink/renderer/modules/cache_storage/cache_storage.h"
#include "third_party/blink/renderer/modules/cache_storage/global_cache_storage.h"
#include "third_party/blink/renderer/modules/canvas/imagebitmap/image_bitmap_factories.h"
#include "third_party/blink/renderer/modules/crypto/crypto.h"
#include "third_party/blink/renderer/modules/crypto/worker_global_scope_crypto.h"
#include "third_party/blink/renderer/modules/indexeddb/global_indexed_db.h"
#include "third_party/blink/renderer/modules/indexeddb/idb_factory.h"
#include "third_party/blink/renderer/modules/native_io/global_native_io.h"
#include "third_party/blink/renderer/modules/native_io/native_io_file_manager.h"
#include "third_party/blink/renderer/modules/scheduler/dom_scheduler.h"
#include "third_party/blink/renderer/modules/webcodecs/video_frame.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
#include "third_party/blink/renderer/platform/scheduler/public/cooperative_scheduling_manager.h"

namespace blink {



void V8WorkerGlobalScope::Impl::Init() {
  V8WorkerGlobalScope::install_interface_template_func_ = InstallInterfaceTemplate;
V8WorkerGlobalScope::install_unconditional_props_func_ = InstallUnconditionalProperties;
V8WorkerGlobalScope::install_context_independent_props_func_ = InstallContextIndependentProperties;
V8WorkerGlobalScope::install_context_dependent_props_func_ = InstallContextDependentProperties;
}

namespace  {

namespace v8_worker_global_scope {

void SelfAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_self_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.self.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->self();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void LocationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_location_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.location.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->location();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void OnerrorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onerror_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onerror.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onerror();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnerrorAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onerror_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onerror.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kOnErrorEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnerror(event_handler);
}

void OnlanguagechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onlanguagechange_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onlanguagechange.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onlanguagechange();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnlanguagechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onlanguagechange_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onlanguagechange.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnlanguagechange(event_handler);
}

void OntimezonechangeAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_ontimezonechange_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.ontimezonechange.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->ontimezonechange();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OntimezonechangeAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_ontimezonechange_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.ontimezonechange.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOntimezonechange(event_handler);
}

void NavigatorAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_navigator_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.navigator.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->navigator();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void OnrejectionhandledAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onrejectionhandled_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onrejectionhandled.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onrejectionhandled();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnrejectionhandledAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onrejectionhandled_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onrejectionhandled.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnrejectionhandled(event_handler);
}

void OnunhandledrejectionAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onunhandledrejection_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onunhandledrejection.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->onunhandledrejection();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, blink_receiver);
}

void OnunhandledrejectionAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_onunhandledrejection_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.onunhandledrejection.set");

v8::Local<v8::Value> v8_property_value = info[0];
EventListener* event_handler = JSEventHandler::CreateOrNull(
    v8_property_value,
    JSEventHandler::HandlerType::kEventHandler);
v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
blink_receiver->setOnunhandledrejection(event_handler);
}

void IsSecureContextAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_isSecureContext_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.isSecureContext.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->isSecureContextForBindings();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}


void OriginAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_origin_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.origin.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->origin();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void OriginAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_origin_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.origin.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "origin";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "WorkerGlobalScope";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [Replaceable]
bool did_create;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
v8::Local<v8::Value> v8_property_value = info[0];
if (!v8_receiver->CreateDataProperty(current_context, V8AtomicString(isolate, property_name), v8_property_value).To(&did_create)) {
  return;
}
}

void FontsAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_fonts_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.fonts.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->fonts();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void TrustedTypesAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_trustedTypes_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.trustedTypes.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->trustedTypes();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void PerformanceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_performance_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.performance.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = WorkerGlobalScopePerformance::performance(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void PerformanceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_performance_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.performance.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "performance";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "WorkerGlobalScope";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [Replaceable]
bool did_create;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
v8::Local<v8::Value> v8_property_value = info[0];
if (!v8_receiver->CreateDataProperty(current_context, V8AtomicString(isolate, property_name), v8_property_value).To(&did_create)) {
  return;
}
}

void CachesAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_caches_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.caches.get");
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kGlobalCacheStorage);


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeGet;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "caches";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
auto&& return_value = GlobalCacheStorage::caches(*blink_receiver, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void CryptoAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_crypto_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.crypto.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = WorkerGlobalScopeCrypto::crypto(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void IndexedDBAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_indexedDB_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.indexedDB.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = GlobalIndexedDB::indexedDB(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void StorageFoundationAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_storageFoundation_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.storageFoundation.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = GlobalNativeIO::storageFoundation(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}


void CrossOriginIsolatedAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_crossOriginIsolated_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.crossOriginIsolated.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = WindowOrWorkerGlobalScope::crossOriginIsolated(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}


void CrossOriginEmbedderPolicyAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_crossOriginEmbedderPolicy_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.crossOriginEmbedderPolicy.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = WindowOrWorkerGlobalScope::crossOriginEmbedderPolicy(*blink_receiver);
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}


void SchedulerAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_scheduler_Getter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.scheduler.get");


v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& return_value = DOMScheduler::scheduler(*blink_receiver);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void SchedulerAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_scheduler_Setter");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.scheduler.set");

v8::Isolate* isolate = info.GetIsolate();
const char* const property_name = "scheduler";
if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "WorkerGlobalScope";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}

// [Replaceable]
bool did_create;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
v8::Local<v8::Value> v8_property_value = info[0];
if (!v8_receiver->CreateDataProperty(current_context, V8AtomicString(isolate, property_name), v8_property_value).To(&did_create)) {
  return;
}
}

void AtobOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_atob");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.atob");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "atob";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_atob = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = WindowOrWorkerGlobalScope::atob(*blink_receiver, arg1_atob, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void BtoaOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_btoa");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.btoa");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "btoa";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_btoa = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = WindowOrWorkerGlobalScope::btoa(*blink_receiver, arg1_btoa, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void ClearIntervalOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_clearInterval");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.clearInterval");







v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLLong>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_handle{0};
if (!info[0]->IsUndefined()) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "clearInterval";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_handle = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
WindowOrWorkerGlobalScope::clearInterval(*blink_receiver, arg1_handle);

}

void ClearTimeoutOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_clearTimeout");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.clearTimeout");







v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLLong>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_handle{0};
if (!info[0]->IsUndefined()) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "clearTimeout";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_handle = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
WindowOrWorkerGlobalScope::clearTimeout(*blink_receiver, arg1_handle);

}

void CreateImageBitmapOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  // Promise returning function: Convert a TypeError to a reject promise.
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "createImageBitmap";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);
if (!V8WorkerGlobalScope::HasInstance(isolate, v8_receiver)) {
  exception_state.ThrowTypeError("Illegal invocation");
return;
}



if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_image_bitmap = NativeValueTraits<V8UnionBlobOrHTMLCanvasElementOrHTMLImageElementOrHTMLVideoElementOrImageBitmapOrImageDataOrOffscreenCanvasOrSVGImageElementOrVideoFrame>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<ImageBitmapOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
if (info[1]->IsUndefined()) {
  arg2_options = ImageBitmapOptions::Create();
} else {
  arg2_options = NativeValueTraits<ImageBitmapOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = ImageBitmapFactories::createImageBitmap(script_state, *blink_receiver, arg1_image_bitmap, arg2_options, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value.V8Value());
}

void CreateImageBitmapOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  // Promise returning function: Convert a TypeError to a reject promise.
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "createImageBitmap";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);
if (!V8WorkerGlobalScope::HasInstance(isolate, v8_receiver)) {
  exception_state.ThrowTypeError("Illegal invocation");
return;
}



if (UNLIKELY(info.Length() < 5)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(5, info.Length()));
return;
}



v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_image_bitmap = NativeValueTraits<V8UnionBlobOrHTMLCanvasElementOrHTMLImageElementOrHTMLVideoElementOrImageBitmapOrImageDataOrOffscreenCanvasOrSVGImageElementOrVideoFrame>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_sx = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_sy = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_sw = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_sh = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<ImageBitmapOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg6_options;
if (info[5]->IsUndefined()) {
  arg6_options = ImageBitmapOptions::Create();
} else {
  arg6_options = NativeValueTraits<ImageBitmapOptions>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = ImageBitmapFactories::createImageBitmap(script_state, *blink_receiver, arg1_image_bitmap, arg2_sx, arg3_sy, arg4_sw, arg5_sh, arg6_options, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value.V8Value());
}

void CreateImageBitmapOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_createImageBitmap");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.createImageBitmap");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 6);
if (arg_count == 6) {
  return CreateImageBitmapOperationOverload2(info);
}
if (arg_count == 5) {
  return CreateImageBitmapOperationOverload2(info);
}
if (arg_count == 2) {
  return CreateImageBitmapOperationOverload1(info);
}
if (arg_count == 1) {
  return CreateImageBitmapOperationOverload1(info);
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "createImageBitmap";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void FetchOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_fetch");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.fetch");

// Promise returning function: Convert a TypeError to a reject promise.
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "fetch";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);
if (!V8WorkerGlobalScope::HasInstance(isolate, v8_receiver)) {
  exception_state.ThrowTypeError("Illegal invocation");
return;
}



if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_input = NativeValueTraits<V8UnionRequestOrUSVString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<RequestInit>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_init;
if (info[1]->IsUndefined()) {
  arg2_init = RequestInit::Create();
} else {
  arg2_init = NativeValueTraits<RequestInit>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = GlobalFetch::fetch(script_state, *blink_receiver, arg1_input, arg2_init, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value.V8Value());
}

void ImportScriptsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_importScripts");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.importScripts");







v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "importScripts";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
auto&& arg1_urls = bindings::VariadicArgumentsToNativeValues<IDLUSVStringStringContextTrustedScriptURL>(isolate, info, 0, exception_state, execution_context_of_document_tree);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->importScripts(arg1_urls);

}

void QueueMicrotaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_queueMicrotask");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.queueMicrotask");




if (UNLIKELY(info.Length() < 1)) {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "queueMicrotask";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<V8VoidFunction>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_callback;
if (LIKELY(info[0]->IsFunction())) {
  arg1_callback = V8VoidFunction::Create(info[0].As<v8::Function>());
} else {
  v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "queueMicrotask";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_callback = NativeValueTraits<V8VoidFunction>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
blink_receiver->queueMicrotask(arg1_callback);

}

void ReportErrorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_reportError");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.reportError");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "reportError";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_e = NativeValueTraits<IDLAny>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
WindowOrWorkerGlobalScope::reportError(script_state, *blink_receiver, arg1_e);

}

void SetIntervalOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "setInterval";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_handler = NativeValueTraits<V8Function>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<IDLLong>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_timeout{0};
if (!info[1]->IsUndefined()) {
  arg2_timeout = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& arg3_arguments = bindings::VariadicArgumentsToNativeValues<IDLAny>(isolate, info, 2, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = WindowOrWorkerGlobalScope::setInterval(script_state, *blink_receiver, arg1_handler, arg2_timeout, arg3_arguments);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void SetIntervalOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "setInterval";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
auto&& arg1_handler = NativeValueTraits<IDLStringStringContextTrustedScript>::ArgumentValue(isolate, 0, info[0], exception_state, execution_context_of_document_tree);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<IDLLong>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_timeout{0};
if (!info[1]->IsUndefined()) {
  arg2_timeout = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& arg3_arguments = bindings::VariadicArgumentsToNativeValues<IDLAny>(isolate, info, 2, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = WindowOrWorkerGlobalScope::setInterval(script_state, *blink_receiver, arg1_handler, arg2_timeout, arg3_arguments);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void SetIntervalOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_setInterval");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.setInterval");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
do {  // Dummy loop for use of 'break'.
  v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope())) {
  if (arg_count == 3) {
  if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  if (info[0]->IsFunction()) {
  return SetIntervalOperationOverload1(info);
}
}
if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  return SetIntervalOperationOverload2(info);
}
break;
}
}
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope())) {
  if (arg_count == 2) {
  if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  if (info[0]->IsFunction()) {
  return SetIntervalOperationOverload1(info);
}
}
if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  return SetIntervalOperationOverload2(info);
}
break;
}
}
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope())) {
  if (arg_count == 1) {
  if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  if (info[0]->IsFunction()) {
  return SetIntervalOperationOverload1(info);
}
}
if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  return SetIntervalOperationOverload2(info);
}
break;
}
}
} while (false);

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "setInterval";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void SetTimeoutOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "setTimeout";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_handler = NativeValueTraits<V8Function>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<IDLLong>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_timeout{0};
if (!info[1]->IsUndefined()) {
  arg2_timeout = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& arg3_arguments = bindings::VariadicArgumentsToNativeValues<IDLAny>(isolate, info, 2, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = WindowOrWorkerGlobalScope::setTimeout(script_state, *blink_receiver, arg1_handler, arg2_timeout, arg3_arguments);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void SetTimeoutOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "setTimeout";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
ExecutionContext* execution_context_of_document_tree = bindings::ExecutionContextFromV8Wrappable(blink_receiver);
auto&& arg1_handler = NativeValueTraits<IDLStringStringContextTrustedScript>::ArgumentValue(isolate, 0, info[0], exception_state, execution_context_of_document_tree);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<IDLLong>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_timeout{0};
if (!info[1]->IsUndefined()) {
  arg2_timeout = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& arg3_arguments = bindings::VariadicArgumentsToNativeValues<IDLAny>(isolate, info, 2, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = WindowOrWorkerGlobalScope::setTimeout(script_state, *blink_receiver, arg1_handler, arg2_timeout, arg3_arguments);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void SetTimeoutOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_setTimeout");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.setTimeout");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
do {  // Dummy loop for use of 'break'.
  v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope())) {
  if (arg_count == 3) {
  if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  if (info[0]->IsFunction()) {
  return SetTimeoutOperationOverload1(info);
}
}
if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  return SetTimeoutOperationOverload2(info);
}
break;
}
}
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope())) {
  if (arg_count == 2) {
  if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  if (info[0]->IsFunction()) {
  return SetTimeoutOperationOverload1(info);
}
}
if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  return SetTimeoutOperationOverload2(info);
}
break;
}
}
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope())) {
  if (arg_count == 1) {
  if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  if (info[0]->IsFunction()) {
  return SetTimeoutOperationOverload1(info);
}
}
if (execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) {
  return SetTimeoutOperationOverload2(info);
}
break;
}
}
} while (false);

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "setTimeout";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void StructuredCloneOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WorkerGlobalScope_structuredClone");
BLINK_BINDINGS_TRACE_EVENT("WorkerGlobalScope.structuredClone");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WorkerGlobalScope";
const char* const property_name = "structuredClone";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WorkerGlobalScope* blink_receiver = V8WorkerGlobalScope::ToWrappableUnsafe(v8_receiver);
auto&& arg1_value = NativeValueTraits<IDLAny>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
decltype(NativeValueTraits<StructuredSerializeOptions>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg2_options;
if (info[1]->IsUndefined()) {
  arg2_options = StructuredSerializeOptions::Create();
} else {
  arg2_options = NativeValueTraits<StructuredSerializeOptions>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = WindowOrWorkerGlobalScope::structuredClone(script_state, *blink_receiver, arg1_value, arg2_options, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}


}  // namespace v8_worker_global_scope

using namespace v8_worker_global_scope;

}  // namespace 

void V8WorkerGlobalScope::Impl::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template) {
  const WrapperTypeInfo* const wrapper_type_info = V8WorkerGlobalScope::GetWrapperTypeInfo();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
v8::Local<v8::FunctionTemplate> parent_interface_template = wrapper_type_info->parent_class->GetV8ClassTemplate(isolate, world).As<v8::FunctionTemplate>();
bindings::SetupIDLInterfaceTemplate(isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);








// [Global] - prototype object in the prototype chain of global objects
// 3.7.1. [[SetPrototypeOf]]
// https://webidl.spec.whatwg.org/#platform-object-setprototypeof
prototype_object_template->SetImmutableProto();

v8::Local<v8::Template> instance_template = instance_object_template;
v8::Local<v8::Template> prototype_template = prototype_object_template;
InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8WorkerGlobalScope::Impl::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template) {
  using bindings::IDLMemberInstaller;

v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
{
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"self", SelfAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"location", LocationAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onerror", OnerrorAttributeGetCallback, OnerrorAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onlanguagechange", OnlanguagechangeAttributeGetCallback, OnlanguagechangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"navigator", NavigatorAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onrejectionhandled", OnrejectionhandledAttributeGetCallback, OnrejectionhandledAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"onunhandledrejection", OnunhandledrejectionAttributeGetCallback, OnunhandledrejectionAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"isSecureContext", IsSecureContextAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"origin", OriginAttributeGetCallback, OriginAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"fonts", FontsAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"trustedTypes", TrustedTypesAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"performance", PerformanceAttributeGetCallback, PerformanceAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"crypto", CryptoAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"indexedDB", IndexedDBAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}





{
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"createImageBitmap", CreateImageBitmapOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"fetch", FetchOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"importScripts", ImportScriptsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"queueMicrotask", QueueMicrotaskOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}



}

void V8WorkerGlobalScope::Impl::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template) {
  using bindings::IDLMemberInstaller;

if (RuntimeEnabledFeatures::TimeZoneChangeEventEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"ontimezonechange", OntimezonechangeAttributeGetCallback, OntimezonechangeAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}






}

void V8WorkerGlobalScope::Impl::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object, v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template, FeatureSelector feature_selector) {
  using bindings::IDLMemberInstaller;

ScriptState* script_state = ScriptState::From(context);
ExecutionContext* execution_context = ExecutionContext::From(script_state);
const bool is_in_secure_context = execution_context->IsSecureContext();
if (is_in_secure_context && feature_selector.IsAll()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"caches", CachesAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
}
if (is_in_secure_context && ((feature_selector.IsAll() && RuntimeEnabledFeatures::StorageFoundationAPIEnabled(execution_context)) || feature_selector.IsAnyOf(OriginTrialFeature::kStorageFoundationAPI))) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"storageFoundation", StorageFoundationAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
}
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) && feature_selector.IsAll()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"crossOriginIsolated", CrossOriginIsolatedAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"scheduler", SchedulerAttributeGetCallback, SchedulerAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
}
if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) && (feature_selector.IsAll() && RuntimeEnabledFeatures::CoepReflectionEnabled())) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"crossOriginEmbedderPolicy", CrossOriginEmbedderPolicyAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_object, prototype_object, interface_object, signature, kAttributeTable);
}




if ((execution_context->IsWindow() || execution_context->IsWorkerGlobalScope()) && feature_selector.IsAll()) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"atob", AtobOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"btoa", BtoaOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"clearInterval", ClearIntervalOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"clearTimeout", ClearTimeoutOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"reportError", ReportErrorOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setInterval", SetIntervalOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"setTimeout", SetTimeoutOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"structuredClone", StructuredCloneOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_object, prototype_object, interface_object, signature, kOperationTable);
}


}


}  // namespace blink
