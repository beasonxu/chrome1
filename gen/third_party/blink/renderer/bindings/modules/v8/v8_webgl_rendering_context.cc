// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_rendering_context.h"

#include "base/dcheck_is_on.h"
#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_ctype_traits.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_canvas_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_image_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_html_video_element.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_bitmap.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_image_data.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_offscreen_canvas.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_predefined_color_space.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_set_return_value_for_core.h"
#include "third_party/blink/renderer/bindings/core/v8/v8_union_htmlcanvaselement_offscreencanvas.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_video_frame.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_active_info.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_buffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_context_attributes.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_framebuffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_program.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_renderbuffer.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_shader.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_shader_precision_format.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_texture.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_webgl_uniform_location.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/core/frame/dactyloscoper.h"
#include "third_party/blink/renderer/core/frame/web_feature.h"
#include "third_party/blink/renderer/core/html/canvas/html_canvas_element.h"
#include "third_party/blink/renderer/core/html/canvas/image_data.h"
#include "third_party/blink/renderer/core/html/html_image_element.h"
#include "third_party/blink/renderer/core/html/media/html_video_element.h"
#include "third_party/blink/renderer/core/imagebitmap/image_bitmap.h"
#include "third_party/blink/renderer/core/offscreencanvas/offscreen_canvas.h"
#include "third_party/blink/renderer/core/typed_arrays/nadc_typed_array_view.h"
#include "third_party/blink/renderer/modules/webcodecs/video_frame.h"
#include "third_party/blink/renderer/modules/webgl/webgl_active_info.h"
#include "third_party/blink/renderer/modules/webgl/webgl_buffer.h"
#include "third_party/blink/renderer/modules/webgl/webgl_framebuffer.h"
#include "third_party/blink/renderer/modules/webgl/webgl_program.h"
#include "third_party/blink/renderer/modules/webgl/webgl_renderbuffer.h"
#include "third_party/blink/renderer/modules/webgl/webgl_rendering_context.h"
#include "third_party/blink/renderer/modules/webgl/webgl_shader.h"
#include "third_party/blink/renderer/modules/webgl/webgl_shader_precision_format.h"
#include "third_party/blink/renderer/modules/webgl/webgl_texture.h"
#include "third_party/blink/renderer/modules/webgl/webgl_uniform_location.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/idl_member_installer.h"
#include "third_party/blink/renderer/platform/bindings/no_alloc_direct_call_exception_state.h"
#include "third_party/blink/renderer/platform/bindings/runtime_call_stats.h"
#include "third_party/blink/renderer/platform/bindings/v8_binding.h"
#include "third_party/blink/renderer/platform/bindings/wrapper_type_info.h"
#include "third_party/blink/renderer/platform/heap/thread_state_scopes.h"
#include "third_party/blink/renderer/platform/instrumentation/use_counter.h"
#include "third_party/blink/renderer/platform/scheduler/public/cooperative_scheduling_manager.h"

namespace blink {



bool V8WebGLRenderingContext::IsExposed(ExecutionContext* execution_context) {
  
return execution_context->IsWindow() || execution_context->IsWorkerGlobalScope();
}

// Construction of WrapperTypeInfo may require non-trivial initialization due
// to cross-component address resolution in order to load the pointer to the
// parent interface's WrapperTypeInfo.  We ignore this issue because the issue
// happens only on component builds and the official release builds
// (statically-linked builds) are never affected by this issue.
#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wglobal-constructors"
#endif

const WrapperTypeInfo V8WebGLRenderingContext::wrapper_type_info_{
    gin::kEmbedderBlink,
    V8WebGLRenderingContext::InstallInterfaceTemplate,
    V8WebGLRenderingContext::InstallContextDependentProperties,
    "WebGLRenderingContext",
    nullptr,
    WrapperTypeInfo::kWrapperTypeObjectPrototype,
    WrapperTypeInfo::kObjectClassId,
    WrapperTypeInfo::kInheritFromActiveScriptWrappable,
    WrapperTypeInfo::kIdlInterface,
};

#if defined(COMPONENT_BUILD) && defined(WIN32) && defined(__clang__)
#pragma clang diagnostic pop
#endif

const WrapperTypeInfo& WebGLRenderingContext::wrapper_type_info_ =
    V8WebGLRenderingContext::wrapper_type_info_;

// [ActiveScriptWrappable]
static_assert(
    std::is_base_of<ActiveScriptWrappableBase, WebGLRenderingContext>::value,
    "WebGLRenderingContext does not inherit from ActiveScriptWrappable<> despite "
    "the IDL has [ActiveScriptWrappable] extended attribute.");
static_assert(
    !std::is_same<decltype(&WebGLRenderingContext::HasPendingActivity),
                  decltype(&ScriptWrappable::HasPendingActivity)>::value,
    "WebGLRenderingContext is not overriding hasPendingActivity() despite "
    "the IDL has [ActiveScriptWrappable] extended attribute.");

namespace  {

namespace v8_webgl_rendering_context {

void CanvasAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_canvas_Getter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.canvas.get");


v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getHTMLOrOffscreenCanvas();
if (!ToV8Traits<V8UnionHTMLCanvasElementOrOffscreenCanvas>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}


void DrawingBufferWidthAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferWidth_Getter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferWidth.get");


v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->drawingBufferWidth();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void DrawingBufferHeightAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferHeight_Getter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferHeight.get");


v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->drawingBufferHeight();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}


void DrawingBufferFormatAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferFormat_Getter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferFormat.get");


v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->drawingBufferFormat();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}


void DrawingBufferColorSpaceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferColorSpace_Getter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferColorSpace.get");


v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->drawingBufferColorSpace();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void DrawingBufferColorSpaceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferColorSpace_Setter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferColorSpace.set");



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Value> v8_property_value = info[0];
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "drawingBufferColorSpace";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
// https://webidl.spec.whatwg.org/#dfn-attribute-setter
// step 4.6.1. Let S be ? ToString(V).
const auto&& arg1_value_string =
    NativeValueTraits<IDLString>::NativeValue(
        isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException()))
  return;
// step 4.6.2. If S is not one of the enumeration's values, then return
//   undefined.
const auto arg1_value_maybe_enum = V8PredefinedColorSpace::Create(arg1_value_string);
if (!arg1_value_maybe_enum) {
  bindings::ReportInvalidEnumSetToAttribute(
      isolate, arg1_value_string, "PredefinedColorSpace", exception_state);
  return;  // Return undefined.
}
const auto arg1_value = arg1_value_maybe_enum.value();

blink_receiver->setDrawingBufferColorSpace(arg1_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void UnpackColorSpaceAttributeGetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_unpackColorSpace_Getter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.unpackColorSpace.get");


v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->unpackColorSpace();
v8::Isolate* isolate = info.GetIsolate();
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNonNullable);
}

void UnpackColorSpaceAttributeSetCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  
RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_unpackColorSpace_Setter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.unpackColorSpace.set");



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Value> v8_property_value = info[0];
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kAttributeSet;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "unpackColorSpace";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
// https://webidl.spec.whatwg.org/#dfn-attribute-setter
// step 4.6.1. Let S be ? ToString(V).
const auto&& arg1_value_string =
    NativeValueTraits<IDLString>::NativeValue(
        isolate, v8_property_value, exception_state);
if (UNLIKELY(exception_state.HadException()))
  return;
// step 4.6.2. If S is not one of the enumeration's values, then return
//   undefined.
const auto arg1_value_maybe_enum = V8PredefinedColorSpace::Create(arg1_value_string);
if (!arg1_value_maybe_enum) {
  bindings::ReportInvalidEnumSetToAttribute(
      isolate, arg1_value_string, "PredefinedColorSpace", exception_state);
  return;  // Return undefined.
}
const auto arg1_value = arg1_value_maybe_enum.value();

blink_receiver->setUnpackColorSpace(arg1_value, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}









































































































































































































































































































void ActiveTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_activeTexture");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.activeTexture");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "activeTexture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_texture = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->activeTexture(arg1_texture);

}

void AttachShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_attachShader");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.attachShader");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "attachShader";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->attachShader(arg1_program, arg2_shader);

}

void BindAttribLocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindAttribLocation");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindAttribLocation");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindAttribLocation";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindAttribLocation(arg1_program, arg2_index, arg3_name);

}

void BindBufferOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_target, v8::Local<v8::Value> v8_arg2_buffer, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_target = v8_arg1_target;
v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindBuffer";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg2_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 1, v8_arg2_buffer, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindBuffer(arg1_target, arg2_buffer);
}

#if DCHECK_IS_ON()
void BindBufferOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindBuffer";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->bindBuffer(arg1_target, arg2_buffer);
});

}
#endif  // DCHECK_IS_ON()

void BindBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindBuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindBuffer");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindBuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
BindBufferOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindBuffer(arg1_target, arg2_buffer);

}

void BindFramebufferOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_target, v8::Local<v8::Value> v8_arg2_framebuffer, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_target = v8_arg1_target;
v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindFramebuffer";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg2_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 1, v8_arg2_framebuffer, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindFramebuffer(arg1_target, arg2_framebuffer);
}

#if DCHECK_IS_ON()
void BindFramebufferOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindFramebuffer";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->bindFramebuffer(arg1_target, arg2_framebuffer);
});

}
#endif  // DCHECK_IS_ON()

void BindFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindFramebuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindFramebuffer");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindFramebuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
BindFramebufferOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindFramebuffer(arg1_target, arg2_framebuffer);

}

void BindRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindRenderbuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindRenderbuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindRenderbuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindRenderbuffer(arg1_target, arg2_renderbuffer);

}

void BindTextureOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_target, v8::Local<v8::Value> v8_arg2_texture, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_target = v8_arg1_target;
v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindTexture";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg2_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 1, v8_arg2_texture, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindTexture(arg1_target, arg2_texture);
}

#if DCHECK_IS_ON()
void BindTextureOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindTexture";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->bindTexture(arg1_target, arg2_texture);
});

}
#endif  // DCHECK_IS_ON()

void BindTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bindTexture");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bindTexture");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bindTexture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
BindTextureOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bindTexture(arg1_target, arg2_texture);

}

void BlendColorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendColor");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendColor");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "blendColor";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_red = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_green = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_blue = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_alpha = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->blendColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);

}

void BlendEquationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendEquation");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendEquation");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "blendEquation";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->blendEquation(arg1_mode);

}

void BlendEquationSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendEquationSeparate");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendEquationSeparate");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "blendEquationSeparate";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_mode_rgb = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_mode_alpha = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->blendEquationSeparate(arg1_mode_rgb, arg2_mode_alpha);

}

void BlendFuncOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendFunc");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendFunc");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "blendFunc";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_sfactor = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_dfactor = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->blendFunc(arg1_sfactor, arg2_dfactor);

}

void BlendFuncSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_blendFuncSeparate");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.blendFuncSeparate");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "blendFuncSeparate";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_src_rgb = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_dst_rgb = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_src_alpha = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_dst_alpha = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->blendFuncSeparate(arg1_src_rgb, arg2_dst_rgb, arg3_src_alpha, arg4_dst_alpha);

}

void BufferDataOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_size = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_usage = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bufferData(arg1_target, arg2_size, arg3_usage);

}

void BufferDataOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_data = NativeValueTraits<MaybeShared<DOMArrayBufferView>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_usage = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bufferData(arg1_target, arg2_data, arg3_usage);

}

void BufferDataOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_data = NativeValueTraits<IDLNullable<DOMArrayBufferBase>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_usage = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bufferData(arg1_target, arg2_data, arg3_usage);

}

void BufferDataOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bufferData");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bufferData");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
if (arg_count == 3) {
  if (info[1]->IsNullOrUndefined()) {
  return BufferDataOperationOverload3(info);
}
if (info[1]->IsArrayBuffer() || info[1]->IsSharedArrayBuffer()) {
  return BufferDataOperationOverload3(info);
}
if (info[1]->IsArrayBufferView()) {
  return BufferDataOperationOverload2(info);
}
if (info[1]->IsNumber()) {
  return BufferDataOperationOverload1(info);
}
return BufferDataOperationOverload1(info);
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void BufferSubDataOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferSubData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_data = NativeValueTraits<FlexibleArrayBufferView>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bufferSubData(arg1_target, arg2_offset, arg3_data);

}

void BufferSubDataOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferSubData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_data = NativeValueTraits<DOMArrayBufferBase>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->bufferSubData(arg1_target, arg2_offset, arg3_data);

}

void BufferSubDataOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_bufferSubData");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.bufferSubData");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 3) {
  if (info[2]->IsArrayBuffer() || info[2]->IsSharedArrayBuffer()) {
  return BufferSubDataOperationOverload2(info);
}
if (info[2]->IsArrayBufferView()) {
  return BufferSubDataOperationOverload1(info);
}
break;
}
} while (false);

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "bufferSubData";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void CheckFramebufferStatusOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_checkFramebufferStatus");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.checkFramebufferStatus");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "checkFramebufferStatus";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->checkFramebufferStatus(arg1_target);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void ClearOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_mask, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_mask = v8_arg1_mask;
blink_receiver->clear(arg1_mask);
}

#if DCHECK_IS_ON()
void ClearOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clear";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->clear(arg1_mask);
});

}
#endif  // DCHECK_IS_ON()

void ClearOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clear");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clear");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clear";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ClearOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->clear(arg1_mask);

}

void ClearColorOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, float v8_arg1_red, float v8_arg2_green, float v8_arg3_blue, float v8_arg4_alpha, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_red = v8_arg1_red;
auto&& arg2_green = v8_arg2_green;
auto&& arg3_blue = v8_arg3_blue;
auto&& arg4_alpha = v8_arg4_alpha;
blink_receiver->clearColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

#if DCHECK_IS_ON()
void ClearColorOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clearColor";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_red = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_green = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_blue = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_alpha = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->clearColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);
});

}
#endif  // DCHECK_IS_ON()

void ClearColorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clearColor");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clearColor");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clearColor";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ClearColorOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_red = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_green = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_blue = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_alpha = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->clearColor(arg1_red, arg2_green, arg3_blue, arg4_alpha);

}

void ClearDepthOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, float v8_arg1_depth, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_depth = v8_arg1_depth;
blink_receiver->clearDepth(arg1_depth);
}

#if DCHECK_IS_ON()
void ClearDepthOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clearDepth";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_depth = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->clearDepth(arg1_depth);
});

}
#endif  // DCHECK_IS_ON()

void ClearDepthOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clearDepth");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clearDepth");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clearDepth";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ClearDepthOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_depth = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->clearDepth(arg1_depth);

}

void ClearStencilOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, int32_t v8_arg1_s, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_s = v8_arg1_s;
blink_receiver->clearStencil(arg1_s);
}

#if DCHECK_IS_ON()
void ClearStencilOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clearStencil";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_s = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->clearStencil(arg1_s);
});

}
#endif  // DCHECK_IS_ON()

void ClearStencilOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_clearStencil");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.clearStencil");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "clearStencil";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ClearStencilOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_s = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->clearStencil(arg1_s);

}

void ColorMaskOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, bool v8_arg1_red, bool v8_arg2_green, bool v8_arg3_blue, bool v8_arg4_alpha, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_red = v8_arg1_red;
auto&& arg2_green = v8_arg2_green;
auto&& arg3_blue = v8_arg3_blue;
auto&& arg4_alpha = v8_arg4_alpha;
blink_receiver->colorMask(arg1_red, arg2_green, arg3_blue, arg4_alpha);
}

#if DCHECK_IS_ON()
void ColorMaskOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "colorMask";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_red = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_green = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_blue = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_alpha = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->colorMask(arg1_red, arg2_green, arg3_blue, arg4_alpha);
});

}
#endif  // DCHECK_IS_ON()

void ColorMaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_colorMask");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.colorMask");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "colorMask";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ColorMaskOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_red = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_green = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_blue = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_alpha = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->colorMask(arg1_red, arg2_green, arg3_blue, arg4_alpha);

}

void CommitOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_commit");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.commit");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink_receiver->commit();

}

void CompileShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_compileShader");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.compileShader");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "compileShader";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->compileShader(arg1_shader);

}

void CompressedTexImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_compressedTexImage2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.compressedTexImage2D");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "compressedTexImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_border = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_data = NativeValueTraits<MaybeShared<DOMArrayBufferView>>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->compressedTexImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_width, arg5_height, arg6_border, arg7_data);

}

void CompressedTexSubImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_compressedTexSubImage2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.compressedTexSubImage2D");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "compressedTexSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 8)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(8, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg8_data = NativeValueTraits<MaybeShared<DOMArrayBufferView>>::ArgumentValue(isolate, 7, info[7], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->compressedTexSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_width, arg6_height, arg7_format, arg8_data);

}

void CopyTexImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_copyTexImage2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.copyTexImage2D");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "copyTexImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 8)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(8, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg8_border = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 7, info[7], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->copyTexImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_x, arg5_y, arg6_width, arg7_height, arg8_border);

}

void CopyTexSubImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_copyTexSubImage2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.copyTexSubImage2D");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "copyTexSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 8)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(8, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg8_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 7, info[7], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->copyTexSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_x, arg6_y, arg7_width, arg8_height);

}

void CreateBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createBuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createBuffer");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->createBuffer();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createFramebuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createFramebuffer");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->createFramebuffer();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createProgram");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createProgram");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->createProgram();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createRenderbuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createRenderbuffer");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->createRenderbuffer();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createShader");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createShader");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "createShader";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->createShader(arg1_type);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CreateTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_createTexture");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.createTexture");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->createTexture();
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void CullFaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_cullFace");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.cullFace");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "cullFace";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->cullFace(arg1_mode);

}

void DeleteBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteBuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteBuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "deleteBuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->deleteBuffer(arg1_buffer);

}

void DeleteFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteFramebuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteFramebuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "deleteFramebuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->deleteFramebuffer(arg1_framebuffer);

}

void DeleteProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteProgram");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteProgram");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "deleteProgram";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<IDLNullable<WebGLProgram>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->deleteProgram(arg1_program);

}

void DeleteRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteRenderbuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteRenderbuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "deleteRenderbuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->deleteRenderbuffer(arg1_renderbuffer);

}

void DeleteShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteShader");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteShader");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "deleteShader";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<IDLNullable<WebGLShader>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->deleteShader(arg1_shader);

}

void DeleteTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_deleteTexture");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.deleteTexture");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "deleteTexture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->deleteTexture(arg1_texture);

}

void DepthFuncOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_depthFunc");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.depthFunc");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "depthFunc";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_func = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->depthFunc(arg1_func);

}

void DepthMaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_depthMask");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.depthMask");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "depthMask";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_flag = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->depthMask(arg1_flag);

}

void DepthRangeOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_depthRange");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.depthRange");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "depthRange";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_z_near = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_z_far = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->depthRange(arg1_z_near, arg2_z_far);

}

void DetachShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_detachShader");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.detachShader");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "detachShader";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->detachShader(arg1_program, arg2_shader);

}

void DisableOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_disable");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.disable");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "disable";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_cap = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->disable(arg1_cap);

}

void DisableVertexAttribArrayOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_index, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_index = v8_arg1_index;
blink_receiver->disableVertexAttribArray(arg1_index);
}

#if DCHECK_IS_ON()
void DisableVertexAttribArrayOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "disableVertexAttribArray";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->disableVertexAttribArray(arg1_index);
});

}
#endif  // DCHECK_IS_ON()

void DisableVertexAttribArrayOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_disableVertexAttribArray");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.disableVertexAttribArray");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "disableVertexAttribArray";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
DisableVertexAttribArrayOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->disableVertexAttribArray(arg1_index);

}

void DrawArraysOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_mode, int32_t v8_arg2_first, int32_t v8_arg3_count, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_mode = v8_arg1_mode;
auto&& arg2_first = v8_arg2_first;
auto&& arg3_count = v8_arg3_count;
blink_receiver->drawArrays(arg1_mode, arg2_first, arg3_count);
}

#if DCHECK_IS_ON()
void DrawArraysOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "drawArrays";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_first = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_count = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->drawArrays(arg1_mode, arg2_first, arg3_count);
});

}
#endif  // DCHECK_IS_ON()

void DrawArraysOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawArrays");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawArrays");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "drawArrays";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
DrawArraysOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_first = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_count = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->drawArrays(arg1_mode, arg2_first, arg3_count);

}

void DrawElementsOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_mode, int32_t v8_arg2_count, uint32_t v8_arg3_type, int64_t v8_arg4_offset, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_mode = v8_arg1_mode;
auto&& arg2_count = v8_arg2_count;
auto&& arg3_type = v8_arg3_type;
auto&& arg4_offset = v8_arg4_offset;
blink_receiver->drawElements(arg1_mode, arg2_count, arg3_type, arg4_offset);
}

#if DCHECK_IS_ON()
void DrawElementsOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "drawElements";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_count = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->drawElements(arg1_mode, arg2_count, arg3_type, arg4_offset);
});

}
#endif  // DCHECK_IS_ON()

void DrawElementsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawElements");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawElements");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "drawElements";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
DrawElementsOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_count = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->drawElements(arg1_mode, arg2_count, arg3_type, arg4_offset);

}

void DrawingBufferStorageOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_drawingBufferStorage");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.drawingBufferStorage");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "drawingBufferStorage";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_sizedformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->drawingBufferStorage(arg1_sizedformat, arg2_width, arg3_height);

}

void EnableOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_enable");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.enable");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "enable";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_cap = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->enable(arg1_cap);

}

void EnableVertexAttribArrayOperationNoAllocDirectCallArg1(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_index, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_index = v8_arg1_index;
blink_receiver->enableVertexAttribArray(arg1_index);
}

#if DCHECK_IS_ON()
void EnableVertexAttribArrayOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "enableVertexAttribArray";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->enableVertexAttribArray(arg1_index);
});

}
#endif  // DCHECK_IS_ON()

void EnableVertexAttribArrayOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_enableVertexAttribArray");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.enableVertexAttribArray");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "enableVertexAttribArray";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
EnableVertexAttribArrayOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->enableVertexAttribArray(arg1_index);

}

void FinishOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_finish");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.finish");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink_receiver->finish();

}

void FlushOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_flush");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.flush");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink_receiver->flush();

}

void FramebufferRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_framebufferRenderbuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.framebufferRenderbuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "framebufferRenderbuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_attachment = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_renderbuffertarget = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->framebufferRenderbuffer(arg1_target, arg2_attachment, arg3_renderbuffertarget, arg4_renderbuffer);

}

void FramebufferTexture2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_framebufferTexture2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.framebufferTexture2D");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "framebufferTexture2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 5)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(5, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_attachment = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_textarget = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->framebufferTexture2D(arg1_target, arg2_attachment, arg3_textarget, arg4_texture, arg5_level);

}

void FrontFaceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_frontFace");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.frontFace");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "frontFace";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->frontFace(arg1_mode);

}

void GenerateMipmapOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_generateMipmap");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.generateMipmap");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "generateMipmap";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->generateMipmap(arg1_target);

}

void GetActiveAttribOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getActiveAttrib");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getActiveAttrib");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getActiveAttrib";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getActiveAttrib(arg1_program, arg2_index);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetActiveUniformOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getActiveUniform");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getActiveUniform");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getActiveUniform";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getActiveUniform(arg1_program, arg2_index);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetAttachedShadersOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getAttachedShaders");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getAttachedShaders");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getAttachedShaders";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getAttachedShaders(arg1_program);
if (!ToV8Traits<IDLNullable<IDLSequence<WebGLShader>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetAttribLocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getAttribLocation");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getAttribLocation");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getAttribLocation";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getAttribLocation(arg1_program, arg2_name);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int32_t>());
}

void GetBufferParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getBufferParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getBufferParameter");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getBufferParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getBufferParameter(script_state, arg1_target, arg2_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetContextAttributesOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getContextAttributes");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getContextAttributes");







v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getContextAttributes();
if (!ToV8Traits<IDLNullable<WebGLContextAttributes>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetErrorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getError");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getError");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getError();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<uint32_t>());
}

void GetExtensionOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getExtension");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getExtension");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetExtension_Method);


if (UNLIKELY(info.Length() < 1)) {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getExtension";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
decltype(NativeValueTraits<IDLString>::NativeValue(std::declval<v8::Isolate*>(), std::declval<v8::Local<v8::Value>>(), std::declval<ExceptionState&>())) arg1_name;
if (LIKELY(info[0]->IsString())) {
  arg1_name.Init(info[0].As<v8::String>());
} else {
  const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getExtension";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
arg1_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
}
auto&& return_value = blink_receiver->getExtension(script_state, arg1_name);
if (!ToV8Traits<IDLNullable<IDLObject>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
// [HighEntropy]
Dactyloscoper::Record(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetExtension_Method);
}

void GetFramebufferAttachmentParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getFramebufferAttachmentParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getFramebufferAttachmentParameter");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getFramebufferAttachmentParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_attachment = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getFramebufferAttachmentParameter(script_state, arg1_target, arg2_attachment, arg3_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getParameter");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextGetParameter);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getParameter(script_state, arg1_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
// [HighEntropy]
Dactyloscoper::Record(current_execution_context, WebFeature::kWebGLRenderingContextGetParameter);
}

void GetProgramInfoLogOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getProgramInfoLog");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getProgramInfoLog");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getProgramInfoLog";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getProgramInfoLog(arg1_program);
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetProgramParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getProgramParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getProgramParameter");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getProgramParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getProgramParameter(script_state, arg1_program, arg2_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetRenderbufferParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getRenderbufferParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getRenderbufferParameter");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextGetRenderbufferParameter);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getRenderbufferParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getRenderbufferParameter(script_state, arg1_target, arg2_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
// [HighEntropy]
Dactyloscoper::Record(current_execution_context, WebFeature::kWebGLRenderingContextGetRenderbufferParameter);
}

void GetShaderInfoLogOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderInfoLog");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderInfoLog");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getShaderInfoLog";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getShaderInfoLog(arg1_shader);
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetShaderParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderParameter");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getShaderParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getShaderParameter(script_state, arg1_shader, arg2_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetShaderPrecisionFormatOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderPrecisionFormat");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderPrecisionFormat");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextGetShaderPrecisionFormat);


const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getShaderPrecisionFormat";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shadertype = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_precisiontype = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getShaderPrecisionFormat(arg1_shadertype, arg2_precisiontype);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
// [HighEntropy]
Dactyloscoper::Record(current_execution_context, WebFeature::kWebGLRenderingContextGetShaderPrecisionFormat);
}

void GetShaderSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getShaderSource");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getShaderSource");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getShaderSource";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getShaderSource(arg1_shader);
bindings::V8SetReturnValue(info, return_value, isolate, bindings::V8ReturnValue::kNullable);
}

void GetSupportedExtensionsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getSupportedExtensions");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getSupportedExtensions");


v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetSupportedExtensions_Method);





v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->getSupportedExtensions();
if (!ToV8Traits<IDLNullable<IDLSequence<IDLString>>>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
// [HighEntropy=Direct]
Dactyloscoper::RecordDirectSurface(current_execution_context, WebFeature::kV8WebGLRenderingContext_GetSupportedExtensions_Method, return_value);
}

void GetTexParameterOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getTexParameter");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getTexParameter");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getTexParameter";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getTexParameter(script_state, arg1_target, arg2_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetUniformOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getUniform");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getUniform");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getUniform";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_location = NativeValueTraits<WebGLUniformLocation>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getUniform(script_state, arg1_program, arg2_location);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetUniformLocationOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getUniformLocation");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getUniformLocation");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getUniformLocation";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_name = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getUniformLocation(arg1_program, arg2_name);
bindings::V8SetReturnValue(info, return_value, blink_receiver);
}

void GetVertexAttribOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getVertexAttrib");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getVertexAttrib");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getVertexAttrib";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Value> v8_return_value;
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getVertexAttrib(script_state, arg1_index, arg2_pname);
if (!ToV8Traits<IDLAny>::ToV8(script_state, return_value).ToLocal(&v8_return_value)) {
  return;
}
bindings::V8SetReturnValue(info, v8_return_value);
}

void GetVertexAttribOffsetOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_getVertexAttribOffset");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.getVertexAttribOffset");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "getVertexAttribOffset";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_index = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->getVertexAttribOffset(arg1_index, arg2_pname);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<int64_t>());
}

void HintOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_hint");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.hint");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "hint";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_mode = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->hint(arg1_target, arg2_mode);

}

void IsBufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isBuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isBuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isBuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_buffer = NativeValueTraits<IDLNullable<WebGLBuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isBuffer(arg1_buffer);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsContextLostOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isContextLost");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isContextLost");







v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& return_value = blink_receiver->isContextLost();
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsEnabledOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isEnabled");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isEnabled");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isEnabled";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_cap = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isEnabled(arg1_cap);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsFramebufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isFramebuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isFramebuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isFramebuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_framebuffer = NativeValueTraits<IDLNullable<WebGLFramebuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isFramebuffer(arg1_framebuffer);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isProgram");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isProgram");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isProgram";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<IDLNullable<WebGLProgram>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isProgram(arg1_program);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsRenderbufferOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isRenderbuffer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isRenderbuffer");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isRenderbuffer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_renderbuffer = NativeValueTraits<IDLNullable<WebGLRenderbuffer>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isRenderbuffer(arg1_renderbuffer);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsShaderOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isShader");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isShader");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isShader";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<IDLNullable<WebGLShader>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isShader(arg1_shader);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void IsTextureOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_isTexture");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.isTexture");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "isTexture";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_texture = NativeValueTraits<IDLNullable<WebGLTexture>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& return_value = blink_receiver->isTexture(arg1_texture);
bindings::V8SetReturnValue(info, return_value, bindings::V8ReturnValue::PrimitiveType<bool>());
}

void LineWidthOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_lineWidth");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.lineWidth");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "lineWidth";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_width = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->lineWidth(arg1_width);

}

void LinkProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_linkProgram");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.linkProgram");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "linkProgram";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->linkProgram(arg1_program);

}

void MakeXRCompatibleOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_makeXRCompatible");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.makeXRCompatible");

// Promise returning function: Convert a TypeError to a reject promise.
v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "makeXRCompatible";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
ExceptionToRejectPromiseScope reject_promise_scope(info, exception_state);
if (!V8WebGLRenderingContext::HasInstance(isolate, v8_receiver)) {
  exception_state.ThrowTypeError("Illegal invocation");
return;
}

v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
ExecutionContext* current_execution_context = ExecutionContext::From(current_context);
// [Measure], [MeasureAs]
UseCounter::Count(current_execution_context, WebFeature::kWebGLRenderingContextMakeXRCompatible);





WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ScriptState* receiver_script_state = ScriptState::From(receiver_context);
ScriptState* script_state = receiver_script_state;
auto&& return_value = blink_receiver->makeXRCompatible(script_state, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
bindings::V8SetReturnValue(info, return_value.V8Value());
// [HighEntropy]
Dactyloscoper::Record(current_execution_context, WebFeature::kWebGLRenderingContextMakeXRCompatible);
}

void PixelStoreiOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_pixelStorei");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.pixelStorei");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "pixelStorei";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_param = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->pixelStorei(arg1_pname, arg2_param);

}

void PolygonOffsetOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_polygonOffset");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.polygonOffset");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "polygonOffset";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_factor = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_units = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->polygonOffset(arg1_factor, arg2_units);

}

void ReadPixelsOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_readPixels");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.readPixels");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "readPixels";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_pixels = NativeValueTraits<IDLNullable<MaybeShared<DOMArrayBufferView>>>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->readPixels(arg1_x, arg2_y, arg3_width, arg4_height, arg5_format, arg6_type, arg7_pixels);

}

void RenderbufferStorageOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_renderbufferStorage");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.renderbufferStorage");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "renderbufferStorage";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_internalformat = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->renderbufferStorage(arg1_target, arg2_internalformat, arg3_width, arg4_height);

}

void SampleCoverageOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_sampleCoverage");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.sampleCoverage");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "sampleCoverage";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_value = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_invert = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->sampleCoverage(arg1_value, arg2_invert);

}

void ScissorOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, int32_t v8_arg1_x, int32_t v8_arg2_y, int32_t v8_arg3_width, int32_t v8_arg4_height, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_x = v8_arg1_x;
auto&& arg2_y = v8_arg2_y;
auto&& arg3_width = v8_arg3_width;
auto&& arg4_height = v8_arg4_height;
blink_receiver->scissor(arg1_x, arg2_y, arg3_width, arg4_height);
}

#if DCHECK_IS_ON()
void ScissorOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "scissor";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->scissor(arg1_x, arg2_y, arg3_width, arg4_height);
});

}
#endif  // DCHECK_IS_ON()

void ScissorOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_scissor");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.scissor");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "scissor";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ScissorOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->scissor(arg1_x, arg2_y, arg3_width, arg4_height);

}

void ShaderSourceOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_shaderSource");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.shaderSource");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "shaderSource";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_shader = NativeValueTraits<WebGLShader>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_string = NativeValueTraits<IDLString>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->shaderSource(arg1_shader, arg2_string);

}

void StencilFuncOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilFunc");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilFunc");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "stencilFunc";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_func = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_ref = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->stencilFunc(arg1_func, arg2_ref, arg3_mask);

}

void StencilFuncSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilFuncSeparate");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilFuncSeparate");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "stencilFuncSeparate";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_face = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_func = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_ref = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->stencilFuncSeparate(arg1_face, arg2_func, arg3_ref, arg4_mask);

}

void StencilMaskOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilMask");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilMask");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "stencilMask";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->stencilMask(arg1_mask);

}

void StencilMaskSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilMaskSeparate");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilMaskSeparate");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "stencilMaskSeparate";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_face = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_mask = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->stencilMaskSeparate(arg1_face, arg2_mask);

}

void StencilOpOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilOp");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilOp");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "stencilOp";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_fail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_zfail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_zpass = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->stencilOp(arg1_fail, arg2_zfail, arg3_zpass);

}

void StencilOpSeparateOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_stencilOpSeparate");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.stencilOpSeparate");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "stencilOpSeparate";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_face = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_fail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_zfail = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_zpass = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->stencilOpSeparate(arg1_face, arg2_fail, arg3_zfail, arg4_zpass);

}

void TexImage2DOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 9)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(9, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_border = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg8_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 7, info[7], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg9_pixels = NativeValueTraits<IDLNullable<MaybeShared<DOMArrayBufferView>>>::ArgumentValue(isolate, 8, info[8], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_width, arg5_height, arg6_border, arg7_format, arg8_type, arg9_pixels);

}

void TexImage2DOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_pixels = NativeValueTraits<ImageData>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_pixels);

}

void TexImage2DOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_image = NativeValueTraits<HTMLImageElement>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(execution_context, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_image, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexImage2DOperationOverload4(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_canvas = NativeValueTraits<HTMLCanvasElement>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(execution_context, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_canvas, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexImage2DOperationOverload5(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_offscreen_canvas = NativeValueTraits<OffscreenCanvas>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(execution_context, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_offscreen_canvas, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexImage2DOperationOverload6(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_video = NativeValueTraits<HTMLVideoElement>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(execution_context, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_video, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexImage2DOperationOverload7(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_bitmap = NativeValueTraits<ImageBitmap>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_bitmap, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexImage2DOperationOverload8(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_internalformat = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_frame = NativeValueTraits<VideoFrame>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texImage2D(execution_context, arg1_target, arg2_level, arg3_internalformat, arg4_format, arg5_type, arg6_frame, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texImage2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texImage2D");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 9);
v8::Isolate* isolate = info.GetIsolate();
do {  // Dummy loop for use of 'break'.
  if (arg_count == 9) {
  return TexImage2DOperationOverload1(info);
}
if (arg_count == 6) {
  if (V8HTMLVideoElement::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload6(info);
}
if (V8HTMLImageElement::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload3(info);
}
if (V8HTMLCanvasElement::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload4(info);
}
if (V8OffscreenCanvas::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload5(info);
}
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
if (RuntimeEnabledFeatures::WebCodecsEnabled(execution_context)) {
  if (V8VideoFrame::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload8(info);
}
}
if (V8ImageData::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload2(info);
}
if (V8ImageBitmap::HasInstance(isolate, info[5])) {
  return TexImage2DOperationOverload7(info);
}
break;
}
} while (false);

const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void TexParameterfOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texParameterf");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texParameterf");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texParameterf";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_param = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texParameterf(arg1_target, arg2_pname, arg3_param);

}

void TexParameteriOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texParameteri");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texParameteri");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texParameteri";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_pname = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_param = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texParameteri(arg1_target, arg2_pname, arg3_param);

}

void TexSubImage2DOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 9)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(9, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg8_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 7, info[7], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg9_pixels = NativeValueTraits<IDLNullable<MaybeShared<DOMArrayBufferView>>>::ArgumentValue(isolate, 8, info[8], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_width, arg6_height, arg7_format, arg8_type, arg9_pixels);

}

void TexSubImage2DOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_pixels = NativeValueTraits<ImageData>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_pixels);

}

void TexSubImage2DOperationOverload3(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_image = NativeValueTraits<HTMLImageElement>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(execution_context, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_image, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexSubImage2DOperationOverload4(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_canvas = NativeValueTraits<HTMLCanvasElement>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(execution_context, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_canvas, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexSubImage2DOperationOverload5(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_offscreen_canvas = NativeValueTraits<OffscreenCanvas>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(execution_context, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_offscreen_canvas, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexSubImage2DOperationOverload6(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_video = NativeValueTraits<HTMLVideoElement>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(execution_context, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_video, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexSubImage2DOperationOverload7(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_bitmap = NativeValueTraits<ImageBitmap>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_bitmap, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexSubImage2DOperationOverload8(const v8::FunctionCallbackInfo<v8::Value>& info) {
  


v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
auto&& arg1_target = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_level = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_xoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_yoffset = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_format = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg7_frame = NativeValueTraits<VideoFrame>::ArgumentValue(isolate, 6, info[6], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->texSubImage2D(execution_context, arg1_target, arg2_level, arg3_xoffset, arg4_yoffset, arg5_format, arg6_type, arg7_frame, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}

}

void TexSubImage2DOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_texSubImage2D");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.texSubImage2D");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 9);
v8::Isolate* isolate = info.GetIsolate();
do {  // Dummy loop for use of 'break'.
  if (arg_count == 9) {
  return TexSubImage2DOperationOverload1(info);
}
if (arg_count == 7) {
  if (V8HTMLVideoElement::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload6(info);
}
if (V8HTMLImageElement::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload3(info);
}
if (V8HTMLCanvasElement::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload4(info);
}
if (V8OffscreenCanvas::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload5(info);
}
v8::Local<v8::Object> v8_receiver = info.This();
v8::Local<v8::Context> receiver_context = v8_receiver->GetCreationContextChecked();
ExecutionContext* receiver_execution_context = ExecutionContext::From(receiver_context);
ExecutionContext* execution_context = receiver_execution_context;
if (RuntimeEnabledFeatures::WebCodecsEnabled(execution_context)) {
  if (V8VideoFrame::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload8(info);
}
}
if (V8ImageData::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload2(info);
}
if (V8ImageBitmap::HasInstance(isolate, info[6])) {
  return TexSubImage2DOperationOverload7(info);
}
break;
}
} while (false);

const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "texSubImage2D";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 7)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(7, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform1FOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
blink_receiver->uniform1f(arg1_location, arg2_x);
}

#if DCHECK_IS_ON()
void Uniform1FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform1f(arg1_location, arg2_x);
});

}
#endif  // DCHECK_IS_ON()

void Uniform1FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform1FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform1f(arg1_location, arg2_x);

}

void Uniform1FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<float>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform1fv(arg1_location, arg2_v);
}

void Uniform1FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform1fv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform1FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform1fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform1FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform1fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform1FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform1FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform1fv(arg1_location, arg2_v);

}

void Uniform1FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform1FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform1fv(arg1_location, arg2_v);

}

void Uniform1FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return Uniform1FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform1FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform1IOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
blink_receiver->uniform1i(arg1_location, arg2_x);
}

#if DCHECK_IS_ON()
void Uniform1IOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform1i(arg1_location, arg2_x);
});

}
#endif  // DCHECK_IS_ON()

void Uniform1IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1i");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1i");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1i";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform1IOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform1i(arg1_location, arg2_x);

}

void Uniform1IvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<int32_t>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform1iv(arg1_location, arg2_v);
}

void Uniform1IvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLLong>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLLong>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform1iv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform1IvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform1iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform1IvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform1iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform1IvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform1IvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform1iv(arg1_location, arg2_v);

}

void Uniform1IvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform1IvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform1iv(arg1_location, arg2_v);

}

void Uniform1IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform1iv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform1iv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform1iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsInt32Array()) {
  return Uniform1IvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform1IvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform2FOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, float v8_arg3_y, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
blink_receiver->uniform2f(arg1_location, arg2_x, arg3_y);
}

#if DCHECK_IS_ON()
void Uniform2FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform2f(arg1_location, arg2_x, arg3_y);
});

}
#endif  // DCHECK_IS_ON()

void Uniform2FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform2FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform2f(arg1_location, arg2_x, arg3_y);

}

void Uniform2FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<float>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform2fv(arg1_location, arg2_v);
}

void Uniform2FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform2fv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform2FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform2fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform2FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform2fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform2FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform2FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform2fv(arg1_location, arg2_v);

}

void Uniform2FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform2FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform2fv(arg1_location, arg2_v);

}

void Uniform2FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return Uniform2FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform2FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform2IOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x, int32_t v8_arg3_y, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
blink_receiver->uniform2i(arg1_location, arg2_x, arg3_y);
}

#if DCHECK_IS_ON()
void Uniform2IOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform2i(arg1_location, arg2_x, arg3_y);
});

}
#endif  // DCHECK_IS_ON()

void Uniform2IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2i");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2i");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2i";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform2IOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform2i(arg1_location, arg2_x, arg3_y);

}

void Uniform2IvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<int32_t>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform2iv(arg1_location, arg2_v);
}

void Uniform2IvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLLong>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLLong>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform2iv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform2IvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform2iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform2IvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform2iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform2IvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform2IvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform2iv(arg1_location, arg2_v);

}

void Uniform2IvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform2IvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform2iv(arg1_location, arg2_v);

}

void Uniform2IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform2iv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform2iv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform2iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsInt32Array()) {
  return Uniform2IvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform2IvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform3FOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, float v8_arg3_y, float v8_arg4_z, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
auto&& arg4_z = v8_arg4_z;
blink_receiver->uniform3f(arg1_location, arg2_x, arg3_y, arg4_z);
}

#if DCHECK_IS_ON()
void Uniform3FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform3f(arg1_location, arg2_x, arg3_y, arg4_z);
});

}
#endif  // DCHECK_IS_ON()

void Uniform3FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform3FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform3f(arg1_location, arg2_x, arg3_y, arg4_z);

}

void Uniform3FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<float>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform3fv(arg1_location, arg2_v);
}

void Uniform3FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform3fv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform3FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform3fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform3FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform3fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform3FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform3FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform3fv(arg1_location, arg2_v);

}

void Uniform3FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform3FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform3fv(arg1_location, arg2_v);

}

void Uniform3FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return Uniform3FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform3FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform3IOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x, int32_t v8_arg3_y, int32_t v8_arg4_z, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
auto&& arg4_z = v8_arg4_z;
blink_receiver->uniform3i(arg1_location, arg2_x, arg3_y, arg4_z);
}

#if DCHECK_IS_ON()
void Uniform3IOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform3i(arg1_location, arg2_x, arg3_y, arg4_z);
});

}
#endif  // DCHECK_IS_ON()

void Uniform3IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3i");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3i");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3i";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform3IOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform3i(arg1_location, arg2_x, arg3_y, arg4_z);

}

void Uniform3IvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<int32_t>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform3iv(arg1_location, arg2_v);
}

void Uniform3IvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLLong>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLLong>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform3iv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform3IvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform3iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform3IvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform3iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform3IvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform3IvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform3iv(arg1_location, arg2_v);

}

void Uniform3IvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform3IvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform3iv(arg1_location, arg2_v);

}

void Uniform3IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform3iv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform3iv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform3iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsInt32Array()) {
  return Uniform3IvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform3IvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform4FOperationNoAllocDirectCallArg5(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, float v8_arg2_x, float v8_arg3_y, float v8_arg4_z, float v8_arg5_w, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
auto&& arg4_z = v8_arg4_z;
auto&& arg5_w = v8_arg5_w;
blink_receiver->uniform4f(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
}

#if DCHECK_IS_ON()
void Uniform4FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_w = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform4f(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
});

}
#endif  // DCHECK_IS_ON()

void Uniform4FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 5)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(5, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform4FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_w = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform4f(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);

}

void Uniform4FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<float>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform4fv(arg1_location, arg2_v);
}

void Uniform4FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform4fv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform4FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform4fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform4FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform4fv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform4FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform4FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleFloat32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform4fv(arg1_location, arg2_v);

}

void Uniform4FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform4FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform4fv(arg1_location, arg2_v);

}

void Uniform4FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return Uniform4FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform4FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void Uniform4IOperationNoAllocDirectCallArg5(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, int32_t v8_arg2_x, int32_t v8_arg3_y, int32_t v8_arg4_z, int32_t v8_arg5_w, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
auto&& arg4_z = v8_arg4_z;
auto&& arg5_w = v8_arg5_w;
blink_receiver->uniform4i(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
}

#if DCHECK_IS_ON()
void Uniform4IOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4i";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_w = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform4i(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);
});

}
#endif  // DCHECK_IS_ON()

void Uniform4IOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4i");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4i");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4i";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 5)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(5, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform4IOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_w = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform4i(arg1_location, arg2_x, arg3_y, arg4_z, arg5_w);

}

void Uniform4IvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, const v8::FastApiTypedArray<int32_t>& v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto& arg2_v = v8_arg2_v;
blink_receiver->uniform4iv(arg1_location, arg2_v);
}

void Uniform4IvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, v8::Local<v8::Array> v8_arg2_v, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
typename NativeValueTraits<IDLSequence<IDLLong>>::ImplType arg2_v(v8_arg2_v->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLLong>::kCTypeInfo.GetId()>(v8_arg2_v, arg2_v.data(),arg2_v.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniform4iv(arg1_location, arg2_v);
}

#if DCHECK_IS_ON()
void Uniform4IvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform4iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void Uniform4IvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniform4iv(arg1_location, arg2_v);
});

}
#endif  // DCHECK_IS_ON()

void Uniform4IvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform4IvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<FlexibleInt32Array>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform4iv(arg1_location, arg2_v);

}

void Uniform4IvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
Uniform4IvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_v = NativeValueTraits<IDLSequence<IDLLong>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniform4iv(arg1_location, arg2_v);

}

void Uniform4IvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniform4iv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniform4iv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniform4iv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsInt32Array()) {
  return Uniform4IvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return Uniform4IvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void UniformMatrix2FvOperationNoAllocDirectCallOverload1Arg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose, const v8::FastApiTypedArray<float>& v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = v8_arg2_transpose;
auto& arg3_array = v8_arg3_array;
blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix2FvOperationNoAllocDirectCallOverload2Arg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose, v8::Local<v8::Array> v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = v8_arg2_transpose;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg3_array(v8_arg3_array->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg3_array, arg3_array.data(),arg3_array.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);
}

#if DCHECK_IS_ON()
void UniformMatrix2FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void UniformMatrix2FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);
});

}
#endif  // DCHECK_IS_ON()

void UniformMatrix2FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
UniformMatrix2FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);

}

void UniformMatrix2FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
UniformMatrix2FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniformMatrix2fv(arg1_location, arg2_transpose, arg3_array);

}

void UniformMatrix2FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniformMatrix2fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniformMatrix2fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 3) {
  if (info[2]->IsFloat32Array()) {
  return UniformMatrix2FvOperationOverload1(info);
}
if (info[2]->IsArray() || bindings::IsEsIterableObject(isolate, info[2], exception_state)) {
  return UniformMatrix2FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void UniformMatrix3FvOperationNoAllocDirectCallOverload1Arg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose, const v8::FastApiTypedArray<float>& v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = v8_arg2_transpose;
auto& arg3_array = v8_arg3_array;
blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix3FvOperationNoAllocDirectCallOverload2Arg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose, v8::Local<v8::Array> v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = v8_arg2_transpose;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg3_array(v8_arg3_array->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg3_array, arg3_array.data(),arg3_array.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);
}

#if DCHECK_IS_ON()
void UniformMatrix3FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void UniformMatrix3FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);
});

}
#endif  // DCHECK_IS_ON()

void UniformMatrix3FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
UniformMatrix3FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);

}

void UniformMatrix3FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
UniformMatrix3FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniformMatrix3fv(arg1_location, arg2_transpose, arg3_array);

}

void UniformMatrix3FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniformMatrix3fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniformMatrix3fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 3) {
  if (info[2]->IsFloat32Array()) {
  return UniformMatrix3FvOperationOverload1(info);
}
if (info[2]->IsArray() || bindings::IsEsIterableObject(isolate, info[2], exception_state)) {
  return UniformMatrix3FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void UniformMatrix4FvOperationNoAllocDirectCallOverload1Arg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose, const v8::FastApiTypedArray<float>& v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = v8_arg2_transpose;
auto& arg3_array = v8_arg3_array;
blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);
}

void UniformMatrix4FvOperationNoAllocDirectCallOverload2Arg3(v8::Local<v8::Object> v8_arg0_receiver, v8::Local<v8::Value> v8_arg1_location, bool v8_arg2_transpose, v8::Local<v8::Array> v8_arg3_array, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

v8::Isolate* isolate = v8_receiver->GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, v8_arg1_location, exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = v8_arg2_transpose;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg3_array(v8_arg3_array->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg3_array, arg3_array.data(),arg3_array.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);
}

#if DCHECK_IS_ON()
void UniformMatrix4FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void UniformMatrix4FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);
});

}
#endif  // DCHECK_IS_ON()

void UniformMatrix4FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
UniformMatrix4FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);

}

void UniformMatrix4FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
UniformMatrix4FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_location = NativeValueTraits<IDLNullable<WebGLUniformLocation>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_transpose = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_array = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->uniformMatrix4fv(arg1_location, arg2_transpose, arg3_array);

}

void UniformMatrix4FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_uniformMatrix4fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.uniformMatrix4fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 3);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "uniformMatrix4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 3) {
  if (info[2]->IsFloat32Array()) {
  return UniformMatrix4FvOperationOverload1(info);
}
if (info[2]->IsArray() || bindings::IsEsIterableObject(isolate, info[2], exception_state)) {
  return UniformMatrix4FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void UseProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_useProgram");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.useProgram");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "useProgram";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<IDLNullable<WebGLProgram>>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->useProgram(arg1_program);

}

void ValidateProgramOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_validateProgram");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.validateProgram");




v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "validateProgram";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 1)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));
return;
}



v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
auto&& arg1_program = NativeValueTraits<WebGLProgram>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->validateProgram(arg1_program);

}

void VertexAttrib1FOperationNoAllocDirectCallArg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto&& arg2_x = v8_arg2_x;
blink_receiver->vertexAttrib1f(arg1_indx, arg2_x);
}

#if DCHECK_IS_ON()
void VertexAttrib1FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib1f(arg1_indx, arg2_x);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib1FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib1f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib1f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib1FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib1f(arg1_indx, arg2_x);

}

void VertexAttrib1FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, const v8::FastApiTypedArray<float>& v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto& arg2_values = v8_arg2_values;
blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);
}

void VertexAttrib1FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Array> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_values(v8_arg2_values->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_values, arg2_values.data(),arg2_values.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);
}

#if DCHECK_IS_ON()
void VertexAttrib1FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void VertexAttrib1FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib1FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib1FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);

}

void VertexAttrib1FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib1FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib1fv(arg1_indx, arg2_values);

}

void VertexAttrib1FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib1fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib1fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib1fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return VertexAttrib1FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return VertexAttrib1FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void VertexAttrib2FOperationNoAllocDirectCallArg3(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, float v8_arg3_y, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
blink_receiver->vertexAttrib2f(arg1_indx, arg2_x, arg3_y);
}

#if DCHECK_IS_ON()
void VertexAttrib2FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib2f(arg1_indx, arg2_x, arg3_y);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib2FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib2f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib2f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 3)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(3, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib2FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib2f(arg1_indx, arg2_x, arg3_y);

}

void VertexAttrib2FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, const v8::FastApiTypedArray<float>& v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto& arg2_values = v8_arg2_values;
blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);
}

void VertexAttrib2FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Array> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_values(v8_arg2_values->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_values, arg2_values.data(),arg2_values.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);
}

#if DCHECK_IS_ON()
void VertexAttrib2FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void VertexAttrib2FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib2FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib2FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);

}

void VertexAttrib2FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib2FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib2fv(arg1_indx, arg2_values);

}

void VertexAttrib2FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib2fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib2fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib2fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return VertexAttrib2FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return VertexAttrib2FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void VertexAttrib3FOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, float v8_arg3_y, float v8_arg4_z, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
auto&& arg4_z = v8_arg4_z;
blink_receiver->vertexAttrib3f(arg1_indx, arg2_x, arg3_y, arg4_z);
}

#if DCHECK_IS_ON()
void VertexAttrib3FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib3f(arg1_indx, arg2_x, arg3_y, arg4_z);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib3FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib3f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib3f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib3FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib3f(arg1_indx, arg2_x, arg3_y, arg4_z);

}

void VertexAttrib3FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, const v8::FastApiTypedArray<float>& v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto& arg2_values = v8_arg2_values;
blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);
}

void VertexAttrib3FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Array> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_values(v8_arg2_values->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_values, arg2_values.data(),arg2_values.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);
}

#if DCHECK_IS_ON()
void VertexAttrib3FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void VertexAttrib3FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib3FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib3FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);

}

void VertexAttrib3FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib3FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib3fv(arg1_indx, arg2_values);

}

void VertexAttrib3FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib3fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib3fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib3fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return VertexAttrib3FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return VertexAttrib3FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void VertexAttrib4FOperationNoAllocDirectCallArg5(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, float v8_arg2_x, float v8_arg3_y, float v8_arg4_z, float v8_arg5_w, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto&& arg2_x = v8_arg2_x;
auto&& arg3_y = v8_arg3_y;
auto&& arg4_z = v8_arg4_z;
auto&& arg5_w = v8_arg5_w;
blink_receiver->vertexAttrib4f(arg1_indx, arg2_x, arg3_y, arg4_z, arg5_w);
}

#if DCHECK_IS_ON()
void VertexAttrib4FOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4f";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_w = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib4f(arg1_indx, arg2_x, arg3_y, arg4_z, arg5_w);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib4FOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib4f");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib4f");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4f";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 5)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(5, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib4FOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_x = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_y = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_z = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_w = NativeValueTraits<IDLUnrestrictedFloat>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib4f(arg1_indx, arg2_x, arg3_y, arg4_z, arg5_w);

}

void VertexAttrib4FvOperationNoAllocDirectCallOverload1Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, const v8::FastApiTypedArray<float>& v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto& arg2_values = v8_arg2_values;
blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);
}

void VertexAttrib4FvOperationNoAllocDirectCallOverload2Arg2(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, v8::Local<v8::Array> v8_arg2_values, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
typename NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ImplType arg2_values(v8_arg2_values->Length());
if (!v8::TryToCopyAndConvertArrayToCppBuffer<V8CTypeTraits<IDLUnrestrictedFloat>::kCTypeInfo.GetId()>(v8_arg2_values, arg2_values.data(),arg2_values.size())) {
  v8_arg_callback_options.fallback = true;
return;
}
blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);
}

#if DCHECK_IS_ON()
void VertexAttrib4FvOperationNoAllocDirectCallForTestingOverload1(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

#if DCHECK_IS_ON()
void VertexAttrib4FvOperationNoAllocDirectCallForTestingOverload2(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4fv";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttrib4FvOperationOverload1(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib4FvOperationNoAllocDirectCallForTestingOverload1(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<MaybeShared<DOMFloat32Array>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);

}

void VertexAttrib4FvOperationOverload2(const v8::FunctionCallbackInfo<v8::Value>& info) {
  

// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttrib4FvOperationNoAllocDirectCallForTestingOverload2(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_values = NativeValueTraits<IDLSequence<IDLUnrestrictedFloat>>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttrib4fv(arg1_indx, arg2_values);

}

void VertexAttrib4FvOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttrib4fv");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttrib4fv");

scheduler::CooperativeSchedulingManager::Instance()->Safepoint();

const int arg_count = std::min(info.Length(), 2);
v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttrib4fv";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
do {  // Dummy loop for use of 'break'.
  if (arg_count == 2) {
  if (info[1]->IsFloat32Array()) {
  return VertexAttrib4FvOperationOverload1(info);
}
if (info[1]->IsArray() || bindings::IsEsIterableObject(isolate, info[1], exception_state)) {
  return VertexAttrib4FvOperationOverload2(info);
}
if (UNLIKELY(exception_state.HadException())) {
  return;
}
break;
}
} while (false);

if (UNLIKELY(info.Length() < 2)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(2, info.Length()));
return;
}
exception_state.ThrowTypeError("Overload resolution failed.");
return;
}

void VertexAttribPointerOperationNoAllocDirectCallArg6(v8::Local<v8::Object> v8_arg0_receiver, uint32_t v8_arg1_indx, int32_t v8_arg2_size, uint32_t v8_arg3_type, bool v8_arg4_normalized, int32_t v8_arg5_stride, int64_t v8_arg6_offset, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_indx = v8_arg1_indx;
auto&& arg2_size = v8_arg2_size;
auto&& arg3_type = v8_arg3_type;
auto&& arg4_normalized = v8_arg4_normalized;
auto&& arg5_stride = v8_arg5_stride;
auto&& arg6_offset = v8_arg6_offset;
blink_receiver->vertexAttribPointer(arg1_indx, arg2_size, arg3_type, arg4_normalized, arg5_stride, arg6_offset);
}

#if DCHECK_IS_ON()
void VertexAttribPointerOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttribPointer";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_normalized = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_stride = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->vertexAttribPointer(arg1_indx, arg2_size, arg3_type, arg4_normalized, arg5_stride, arg6_offset);
});

}
#endif  // DCHECK_IS_ON()

void VertexAttribPointerOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_vertexAttribPointer");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.vertexAttribPointer");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "vertexAttribPointer";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 6)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(6, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
VertexAttribPointerOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_indx = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_size = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_type = NativeValueTraits<IDLUnsignedLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_normalized = NativeValueTraits<IDLBoolean>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg5_stride = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 4, info[4], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg6_offset = NativeValueTraits<IDLLongLong>::ArgumentValue(isolate, 5, info[5], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->vertexAttribPointer(arg1_indx, arg2_size, arg3_type, arg4_normalized, arg5_stride, arg6_offset);

}

void ViewportOperationNoAllocDirectCallArg4(v8::Local<v8::Object> v8_arg0_receiver, int32_t v8_arg1_x, int32_t v8_arg2_y, int32_t v8_arg3_width, int32_t v8_arg4_height, v8::FastApiCallbackOptions& v8_arg_callback_options) {
  ThreadState::NoAllocationScope thread_no_alloc_scope(ThreadState::Current());
v8::Local<v8::Object> v8_receiver = v8_arg0_receiver;
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
blink::NoAllocDirectCallScope no_alloc_direct_call_scope(blink_receiver, &v8_arg_callback_options);

auto&& arg1_x = v8_arg1_x;
auto&& arg2_y = v8_arg2_y;
auto&& arg3_width = v8_arg3_width;
auto&& arg4_height = v8_arg4_height;
blink_receiver->viewport(arg1_x, arg2_y, arg3_width, arg4_height);
}

#if DCHECK_IS_ON()
void ViewportOperationNoAllocDirectCallForTesting(const v8::FunctionCallbackInfo<v8::Value>& info, v8::FastApiCallbackOptions& v8_fast_api_callback_options) {
  v8::Isolate* isolate = info.GetIsolate();
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "viewport";
NoAllocDirectCallExceptionState exception_state(blink_receiver, isolate, exception_state_context_type, class_like_name, property_name);
auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
({
ThreadState::NoAllocationScope nadc_no_allocation_scope(ThreadState::Current());
v8::Isolate::DisallowJavascriptExecutionScope nadc_disallow_js_exec_scope(isolate, v8::Isolate::DisallowJavascriptExecutionScope::CRASH_ON_FAILURE);
blink::NoAllocDirectCallScope nadc_nadc_scope(blink_receiver, &v8_fast_api_callback_options);
blink_receiver->viewport(arg1_x, arg2_y, arg3_width, arg4_height);
});

}
#endif  // DCHECK_IS_ON()

void ViewportOperationCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {
  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), "Blink_WebGLRenderingContext_viewport");
BLINK_BINDINGS_TRACE_EVENT("WebGLRenderingContext.viewport");



// [NoAllocDirectCall]
v8::Local<v8::Object> v8_receiver = info.This();
WebGLRenderingContext* blink_receiver = V8WebGLRenderingContext::ToWrappableUnsafe(v8_receiver);
if (UNLIKELY(blink_receiver->HasDeferredActions())) {
  blink_receiver->FlushDeferredActions();
return;
}

v8::Isolate* isolate = info.GetIsolate();
const ExceptionState::ContextType exception_state_context_type = ExceptionContext::Context::kOperationInvoke;
const char* const class_like_name = "WebGLRenderingContext";
const char* const property_name = "viewport";
ExceptionState exception_state(isolate, exception_state_context_type, class_like_name, property_name);
if (UNLIKELY(info.Length() < 4)) {
  exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(4, info.Length()));
return;
}


#if DCHECK_IS_ON()
// [NoAllocDirectCall]
if (RuntimeEnabledFeatures::FakeNoAllocDirectCallForTestingEnabled()) {
  v8::FastApiCallbackOptions v8_fast_api_callback_options = v8::FastApiCallbackOptions::CreateForTesting(isolate);
ViewportOperationNoAllocDirectCallForTesting(info, v8_fast_api_callback_options);
if (blink_receiver->HasDeferredActions()) {
  blink_receiver->FlushDeferredActions();
return;
}
if (!v8_fast_api_callback_options.fallback) {
  return;
}
}
#endif  // DCHECK_IS_ON()

auto&& arg1_x = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 0, info[0], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg2_y = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 1, info[1], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg3_width = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 2, info[2], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
auto&& arg4_height = NativeValueTraits<IDLLong>::ArgumentValue(isolate, 3, info[3], exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return;
}
blink_receiver->viewport(arg1_x, arg2_y, arg3_width, arg4_height);

}


}  // namespace v8_webgl_rendering_context

using namespace v8_webgl_rendering_context;

}  // namespace 

void V8WebGLRenderingContext::InstallInterfaceTemplate(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> interface_template) {
  const WrapperTypeInfo* const wrapper_type_info = V8WebGLRenderingContext::GetWrapperTypeInfo();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::ObjectTemplate> instance_object_template = interface_function_template->InstanceTemplate();
v8::Local<v8::ObjectTemplate> prototype_object_template = interface_function_template->PrototypeTemplate();
v8::Local<v8::FunctionTemplate> parent_interface_template;
bindings::SetupIDLInterfaceTemplate(isolate, wrapper_type_info, instance_object_template, prototype_object_template, interface_function_template, parent_interface_template);








v8::Local<v8::Template> instance_template = instance_object_template;
v8::Local<v8::Template> prototype_template = prototype_object_template;
InstallUnconditionalProperties(isolate, world, instance_template, prototype_template, interface_template);
InstallContextIndependentProperties(isolate, world, instance_template, prototype_template, interface_template);
}

void V8WebGLRenderingContext::InstallUnconditionalProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template) {
  using bindings::IDLMemberInstaller;

v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
{
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"canvas", CanvasAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"drawingBufferWidth", DrawingBufferWidthAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"drawingBufferHeight", DrawingBufferHeightAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}



{
  static const IDLMemberInstaller::ConstantValueConfig kConstantValueTable[] = {
{"DEPTH_BUFFER_BIT", V8WebGLRenderingContext::Constant::kDepthBufferBit},
{"STENCIL_BUFFER_BIT", V8WebGLRenderingContext::Constant::kStencilBufferBit},
{"COLOR_BUFFER_BIT", V8WebGLRenderingContext::Constant::kColorBufferBit},
{"POINTS", V8WebGLRenderingContext::Constant::kPoints},
{"LINES", V8WebGLRenderingContext::Constant::kLines},
{"LINE_LOOP", V8WebGLRenderingContext::Constant::kLineLoop},
{"LINE_STRIP", V8WebGLRenderingContext::Constant::kLineStrip},
{"TRIANGLES", V8WebGLRenderingContext::Constant::kTriangles},
{"TRIANGLE_STRIP", V8WebGLRenderingContext::Constant::kTriangleStrip},
{"TRIANGLE_FAN", V8WebGLRenderingContext::Constant::kTriangleFan},
{"ZERO", V8WebGLRenderingContext::Constant::kZero},
{"ONE", V8WebGLRenderingContext::Constant::kOne},
{"SRC_COLOR", V8WebGLRenderingContext::Constant::kSrcColor},
{"ONE_MINUS_SRC_COLOR", V8WebGLRenderingContext::Constant::kOneMinusSrcColor},
{"SRC_ALPHA", V8WebGLRenderingContext::Constant::kSrcAlpha},
{"ONE_MINUS_SRC_ALPHA", V8WebGLRenderingContext::Constant::kOneMinusSrcAlpha},
{"DST_ALPHA", V8WebGLRenderingContext::Constant::kDstAlpha},
{"ONE_MINUS_DST_ALPHA", V8WebGLRenderingContext::Constant::kOneMinusDstAlpha},
{"DST_COLOR", V8WebGLRenderingContext::Constant::kDstColor},
{"ONE_MINUS_DST_COLOR", V8WebGLRenderingContext::Constant::kOneMinusDstColor},
{"SRC_ALPHA_SATURATE", V8WebGLRenderingContext::Constant::kSrcAlphaSaturate},
{"FUNC_ADD", V8WebGLRenderingContext::Constant::kFuncAdd},
{"BLEND_EQUATION", V8WebGLRenderingContext::Constant::kBlendEquation},
{"BLEND_EQUATION_RGB", V8WebGLRenderingContext::Constant::kBlendEquationRgb},
{"BLEND_EQUATION_ALPHA", V8WebGLRenderingContext::Constant::kBlendEquationAlpha},
{"FUNC_SUBTRACT", V8WebGLRenderingContext::Constant::kFuncSubtract},
{"FUNC_REVERSE_SUBTRACT", V8WebGLRenderingContext::Constant::kFuncReverseSubtract},
{"BLEND_DST_RGB", V8WebGLRenderingContext::Constant::kBlendDstRgb},
{"BLEND_SRC_RGB", V8WebGLRenderingContext::Constant::kBlendSrcRgb},
{"BLEND_DST_ALPHA", V8WebGLRenderingContext::Constant::kBlendDstAlpha},
{"BLEND_SRC_ALPHA", V8WebGLRenderingContext::Constant::kBlendSrcAlpha},
{"CONSTANT_COLOR", V8WebGLRenderingContext::Constant::kConstantColor},
{"ONE_MINUS_CONSTANT_COLOR", V8WebGLRenderingContext::Constant::kOneMinusConstantColor},
{"CONSTANT_ALPHA", V8WebGLRenderingContext::Constant::kConstantAlpha},
{"ONE_MINUS_CONSTANT_ALPHA", V8WebGLRenderingContext::Constant::kOneMinusConstantAlpha},
{"BLEND_COLOR", V8WebGLRenderingContext::Constant::kBlendColor},
{"ARRAY_BUFFER", V8WebGLRenderingContext::Constant::kArrayBuffer},
{"ELEMENT_ARRAY_BUFFER", V8WebGLRenderingContext::Constant::kElementArrayBuffer},
{"ARRAY_BUFFER_BINDING", V8WebGLRenderingContext::Constant::kArrayBufferBinding},
{"ELEMENT_ARRAY_BUFFER_BINDING", V8WebGLRenderingContext::Constant::kElementArrayBufferBinding},
{"STREAM_DRAW", V8WebGLRenderingContext::Constant::kStreamDraw},
{"STATIC_DRAW", V8WebGLRenderingContext::Constant::kStaticDraw},
{"DYNAMIC_DRAW", V8WebGLRenderingContext::Constant::kDynamicDraw},
{"BUFFER_SIZE", V8WebGLRenderingContext::Constant::kBufferSize},
{"BUFFER_USAGE", V8WebGLRenderingContext::Constant::kBufferUsage},
{"CURRENT_VERTEX_ATTRIB", V8WebGLRenderingContext::Constant::kCurrentVertexAttrib},
{"FRONT", V8WebGLRenderingContext::Constant::kFront},
{"BACK", V8WebGLRenderingContext::Constant::kBack},
{"FRONT_AND_BACK", V8WebGLRenderingContext::Constant::kFrontAndBack},
{"TEXTURE_2D", V8WebGLRenderingContext::Constant::kTexture2d},
{"CULL_FACE", V8WebGLRenderingContext::Constant::kCullFace},
{"BLEND", V8WebGLRenderingContext::Constant::kBlend},
{"DITHER", V8WebGLRenderingContext::Constant::kDither},
{"STENCIL_TEST", V8WebGLRenderingContext::Constant::kStencilTest},
{"DEPTH_TEST", V8WebGLRenderingContext::Constant::kDepthTest},
{"SCISSOR_TEST", V8WebGLRenderingContext::Constant::kScissorTest},
{"POLYGON_OFFSET_FILL", V8WebGLRenderingContext::Constant::kPolygonOffsetFill},
{"SAMPLE_ALPHA_TO_COVERAGE", V8WebGLRenderingContext::Constant::kSampleAlphaToCoverage},
{"SAMPLE_COVERAGE", V8WebGLRenderingContext::Constant::kSampleCoverage},
{"NO_ERROR", V8WebGLRenderingContext::Constant::kNoError},
{"INVALID_ENUM", V8WebGLRenderingContext::Constant::kInvalidEnum},
{"INVALID_VALUE", V8WebGLRenderingContext::Constant::kInvalidValue},
{"INVALID_OPERATION", V8WebGLRenderingContext::Constant::kInvalidOperation},
{"OUT_OF_MEMORY", V8WebGLRenderingContext::Constant::kOutOfMemory},
{"CW", V8WebGLRenderingContext::Constant::kCw},
{"CCW", V8WebGLRenderingContext::Constant::kCcw},
{"LINE_WIDTH", V8WebGLRenderingContext::Constant::kLineWidth},
{"ALIASED_POINT_SIZE_RANGE", V8WebGLRenderingContext::Constant::kAliasedPointSizeRange},
{"ALIASED_LINE_WIDTH_RANGE", V8WebGLRenderingContext::Constant::kAliasedLineWidthRange},
{"CULL_FACE_MODE", V8WebGLRenderingContext::Constant::kCullFaceMode},
{"FRONT_FACE", V8WebGLRenderingContext::Constant::kFrontFace},
{"DEPTH_RANGE", V8WebGLRenderingContext::Constant::kDepthRange},
{"DEPTH_WRITEMASK", V8WebGLRenderingContext::Constant::kDepthWritemask},
{"DEPTH_CLEAR_VALUE", V8WebGLRenderingContext::Constant::kDepthClearValue},
{"DEPTH_FUNC", V8WebGLRenderingContext::Constant::kDepthFunc},
{"STENCIL_CLEAR_VALUE", V8WebGLRenderingContext::Constant::kStencilClearValue},
{"STENCIL_FUNC", V8WebGLRenderingContext::Constant::kStencilFunc},
{"STENCIL_FAIL", V8WebGLRenderingContext::Constant::kStencilFail},
{"STENCIL_PASS_DEPTH_FAIL", V8WebGLRenderingContext::Constant::kStencilPassDepthFail},
{"STENCIL_PASS_DEPTH_PASS", V8WebGLRenderingContext::Constant::kStencilPassDepthPass},
{"STENCIL_REF", V8WebGLRenderingContext::Constant::kStencilRef},
{"STENCIL_VALUE_MASK", V8WebGLRenderingContext::Constant::kStencilValueMask},
{"STENCIL_WRITEMASK", V8WebGLRenderingContext::Constant::kStencilWritemask},
{"STENCIL_BACK_FUNC", V8WebGLRenderingContext::Constant::kStencilBackFunc},
{"STENCIL_BACK_FAIL", V8WebGLRenderingContext::Constant::kStencilBackFail},
{"STENCIL_BACK_PASS_DEPTH_FAIL", V8WebGLRenderingContext::Constant::kStencilBackPassDepthFail},
{"STENCIL_BACK_PASS_DEPTH_PASS", V8WebGLRenderingContext::Constant::kStencilBackPassDepthPass},
{"STENCIL_BACK_REF", V8WebGLRenderingContext::Constant::kStencilBackRef},
{"STENCIL_BACK_VALUE_MASK", V8WebGLRenderingContext::Constant::kStencilBackValueMask},
{"STENCIL_BACK_WRITEMASK", V8WebGLRenderingContext::Constant::kStencilBackWritemask},
{"VIEWPORT", V8WebGLRenderingContext::Constant::kViewport},
{"SCISSOR_BOX", V8WebGLRenderingContext::Constant::kScissorBox},
{"COLOR_CLEAR_VALUE", V8WebGLRenderingContext::Constant::kColorClearValue},
{"COLOR_WRITEMASK", V8WebGLRenderingContext::Constant::kColorWritemask},
{"UNPACK_ALIGNMENT", V8WebGLRenderingContext::Constant::kUnpackAlignment},
{"PACK_ALIGNMENT", V8WebGLRenderingContext::Constant::kPackAlignment},
{"MAX_TEXTURE_SIZE", V8WebGLRenderingContext::Constant::kMaxTextureSize},
{"MAX_VIEWPORT_DIMS", V8WebGLRenderingContext::Constant::kMaxViewportDims},
{"SUBPIXEL_BITS", V8WebGLRenderingContext::Constant::kSubpixelBits},
{"RED_BITS", V8WebGLRenderingContext::Constant::kRedBits},
{"GREEN_BITS", V8WebGLRenderingContext::Constant::kGreenBits},
{"BLUE_BITS", V8WebGLRenderingContext::Constant::kBlueBits},
{"ALPHA_BITS", V8WebGLRenderingContext::Constant::kAlphaBits},
{"DEPTH_BITS", V8WebGLRenderingContext::Constant::kDepthBits},
{"STENCIL_BITS", V8WebGLRenderingContext::Constant::kStencilBits},
{"POLYGON_OFFSET_UNITS", V8WebGLRenderingContext::Constant::kPolygonOffsetUnits},
{"POLYGON_OFFSET_FACTOR", V8WebGLRenderingContext::Constant::kPolygonOffsetFactor},
{"TEXTURE_BINDING_2D", V8WebGLRenderingContext::Constant::kTextureBinding2d},
{"SAMPLE_BUFFERS", V8WebGLRenderingContext::Constant::kSampleBuffers},
{"SAMPLES", V8WebGLRenderingContext::Constant::kSamples},
{"SAMPLE_COVERAGE_VALUE", V8WebGLRenderingContext::Constant::kSampleCoverageValue},
{"SAMPLE_COVERAGE_INVERT", V8WebGLRenderingContext::Constant::kSampleCoverageInvert},
{"COMPRESSED_TEXTURE_FORMATS", V8WebGLRenderingContext::Constant::kCompressedTextureFormats},
{"DONT_CARE", V8WebGLRenderingContext::Constant::kDontCare},
{"FASTEST", V8WebGLRenderingContext::Constant::kFastest},
{"NICEST", V8WebGLRenderingContext::Constant::kNicest},
{"GENERATE_MIPMAP_HINT", V8WebGLRenderingContext::Constant::kGenerateMipmapHint},
{"BYTE", V8WebGLRenderingContext::Constant::kByte},
{"UNSIGNED_BYTE", V8WebGLRenderingContext::Constant::kUnsignedByte},
{"SHORT", V8WebGLRenderingContext::Constant::kShort},
{"UNSIGNED_SHORT", V8WebGLRenderingContext::Constant::kUnsignedShort},
{"INT", V8WebGLRenderingContext::Constant::kInt},
{"UNSIGNED_INT", V8WebGLRenderingContext::Constant::kUnsignedInt},
{"FLOAT", V8WebGLRenderingContext::Constant::kFloat},
{"DEPTH_COMPONENT", V8WebGLRenderingContext::Constant::kDepthComponent},
{"ALPHA", V8WebGLRenderingContext::Constant::kAlpha},
{"RGB", V8WebGLRenderingContext::Constant::kRgb},
{"RGBA", V8WebGLRenderingContext::Constant::kRgba},
{"LUMINANCE", V8WebGLRenderingContext::Constant::kLuminance},
{"LUMINANCE_ALPHA", V8WebGLRenderingContext::Constant::kLuminanceAlpha},
{"UNSIGNED_SHORT_4_4_4_4", V8WebGLRenderingContext::Constant::kUnsignedShort4444},
{"UNSIGNED_SHORT_5_5_5_1", V8WebGLRenderingContext::Constant::kUnsignedShort5551},
{"UNSIGNED_SHORT_5_6_5", V8WebGLRenderingContext::Constant::kUnsignedShort565},
{"FRAGMENT_SHADER", V8WebGLRenderingContext::Constant::kFragmentShader},
{"VERTEX_SHADER", V8WebGLRenderingContext::Constant::kVertexShader},
{"MAX_VERTEX_ATTRIBS", V8WebGLRenderingContext::Constant::kMaxVertexAttribs},
{"MAX_VERTEX_UNIFORM_VECTORS", V8WebGLRenderingContext::Constant::kMaxVertexUniformVectors},
{"MAX_VARYING_VECTORS", V8WebGLRenderingContext::Constant::kMaxVaryingVectors},
{"MAX_COMBINED_TEXTURE_IMAGE_UNITS", V8WebGLRenderingContext::Constant::kMaxCombinedTextureImageUnits},
{"MAX_VERTEX_TEXTURE_IMAGE_UNITS", V8WebGLRenderingContext::Constant::kMaxVertexTextureImageUnits},
{"MAX_TEXTURE_IMAGE_UNITS", V8WebGLRenderingContext::Constant::kMaxTextureImageUnits},
{"MAX_FRAGMENT_UNIFORM_VECTORS", V8WebGLRenderingContext::Constant::kMaxFragmentUniformVectors},
{"SHADER_TYPE", V8WebGLRenderingContext::Constant::kShaderType},
{"DELETE_STATUS", V8WebGLRenderingContext::Constant::kDeleteStatus},
{"LINK_STATUS", V8WebGLRenderingContext::Constant::kLinkStatus},
{"VALIDATE_STATUS", V8WebGLRenderingContext::Constant::kValidateStatus},
{"ATTACHED_SHADERS", V8WebGLRenderingContext::Constant::kAttachedShaders},
{"ACTIVE_UNIFORMS", V8WebGLRenderingContext::Constant::kActiveUniforms},
{"ACTIVE_ATTRIBUTES", V8WebGLRenderingContext::Constant::kActiveAttributes},
{"SHADING_LANGUAGE_VERSION", V8WebGLRenderingContext::Constant::kShadingLanguageVersion},
{"CURRENT_PROGRAM", V8WebGLRenderingContext::Constant::kCurrentProgram},
{"NEVER", V8WebGLRenderingContext::Constant::kNever},
{"LESS", V8WebGLRenderingContext::Constant::kLess},
{"EQUAL", V8WebGLRenderingContext::Constant::kEqual},
{"LEQUAL", V8WebGLRenderingContext::Constant::kLequal},
{"GREATER", V8WebGLRenderingContext::Constant::kGreater},
{"NOTEQUAL", V8WebGLRenderingContext::Constant::kNotequal},
{"GEQUAL", V8WebGLRenderingContext::Constant::kGequal},
{"ALWAYS", V8WebGLRenderingContext::Constant::kAlways},
{"KEEP", V8WebGLRenderingContext::Constant::kKeep},
{"REPLACE", V8WebGLRenderingContext::Constant::kReplace},
{"INCR", V8WebGLRenderingContext::Constant::kIncr},
{"DECR", V8WebGLRenderingContext::Constant::kDecr},
{"INVERT", V8WebGLRenderingContext::Constant::kInvert},
{"INCR_WRAP", V8WebGLRenderingContext::Constant::kIncrWrap},
{"DECR_WRAP", V8WebGLRenderingContext::Constant::kDecrWrap},
{"VENDOR", V8WebGLRenderingContext::Constant::kVendor},
{"RENDERER", V8WebGLRenderingContext::Constant::kRenderer},
{"VERSION", V8WebGLRenderingContext::Constant::kVersion},
{"NEAREST", V8WebGLRenderingContext::Constant::kNearest},
{"LINEAR", V8WebGLRenderingContext::Constant::kLinear},
{"NEAREST_MIPMAP_NEAREST", V8WebGLRenderingContext::Constant::kNearestMipmapNearest},
{"LINEAR_MIPMAP_NEAREST", V8WebGLRenderingContext::Constant::kLinearMipmapNearest},
{"NEAREST_MIPMAP_LINEAR", V8WebGLRenderingContext::Constant::kNearestMipmapLinear},
{"LINEAR_MIPMAP_LINEAR", V8WebGLRenderingContext::Constant::kLinearMipmapLinear},
{"TEXTURE_MAG_FILTER", V8WebGLRenderingContext::Constant::kTextureMagFilter},
{"TEXTURE_MIN_FILTER", V8WebGLRenderingContext::Constant::kTextureMinFilter},
{"TEXTURE_WRAP_S", V8WebGLRenderingContext::Constant::kTextureWrapS},
{"TEXTURE_WRAP_T", V8WebGLRenderingContext::Constant::kTextureWrapT},
{"TEXTURE", V8WebGLRenderingContext::Constant::kTexture},
{"TEXTURE_CUBE_MAP", V8WebGLRenderingContext::Constant::kTextureCubeMap},
{"TEXTURE_BINDING_CUBE_MAP", V8WebGLRenderingContext::Constant::kTextureBindingCubeMap},
{"TEXTURE_CUBE_MAP_POSITIVE_X", V8WebGLRenderingContext::Constant::kTextureCubeMapPositiveX},
{"TEXTURE_CUBE_MAP_NEGATIVE_X", V8WebGLRenderingContext::Constant::kTextureCubeMapNegativeX},
{"TEXTURE_CUBE_MAP_POSITIVE_Y", V8WebGLRenderingContext::Constant::kTextureCubeMapPositiveY},
{"TEXTURE_CUBE_MAP_NEGATIVE_Y", V8WebGLRenderingContext::Constant::kTextureCubeMapNegativeY},
{"TEXTURE_CUBE_MAP_POSITIVE_Z", V8WebGLRenderingContext::Constant::kTextureCubeMapPositiveZ},
{"TEXTURE_CUBE_MAP_NEGATIVE_Z", V8WebGLRenderingContext::Constant::kTextureCubeMapNegativeZ},
{"MAX_CUBE_MAP_TEXTURE_SIZE", V8WebGLRenderingContext::Constant::kMaxCubeMapTextureSize},
{"TEXTURE0", V8WebGLRenderingContext::Constant::kTexture0},
{"TEXTURE1", V8WebGLRenderingContext::Constant::kTexture1},
{"TEXTURE2", V8WebGLRenderingContext::Constant::kTexture2},
{"TEXTURE3", V8WebGLRenderingContext::Constant::kTexture3},
{"TEXTURE4", V8WebGLRenderingContext::Constant::kTexture4},
{"TEXTURE5", V8WebGLRenderingContext::Constant::kTexture5},
{"TEXTURE6", V8WebGLRenderingContext::Constant::kTexture6},
{"TEXTURE7", V8WebGLRenderingContext::Constant::kTexture7},
{"TEXTURE8", V8WebGLRenderingContext::Constant::kTexture8},
{"TEXTURE9", V8WebGLRenderingContext::Constant::kTexture9},
{"TEXTURE10", V8WebGLRenderingContext::Constant::kTexture10},
{"TEXTURE11", V8WebGLRenderingContext::Constant::kTexture11},
{"TEXTURE12", V8WebGLRenderingContext::Constant::kTexture12},
{"TEXTURE13", V8WebGLRenderingContext::Constant::kTexture13},
{"TEXTURE14", V8WebGLRenderingContext::Constant::kTexture14},
{"TEXTURE15", V8WebGLRenderingContext::Constant::kTexture15},
{"TEXTURE16", V8WebGLRenderingContext::Constant::kTexture16},
{"TEXTURE17", V8WebGLRenderingContext::Constant::kTexture17},
{"TEXTURE18", V8WebGLRenderingContext::Constant::kTexture18},
{"TEXTURE19", V8WebGLRenderingContext::Constant::kTexture19},
{"TEXTURE20", V8WebGLRenderingContext::Constant::kTexture20},
{"TEXTURE21", V8WebGLRenderingContext::Constant::kTexture21},
{"TEXTURE22", V8WebGLRenderingContext::Constant::kTexture22},
{"TEXTURE23", V8WebGLRenderingContext::Constant::kTexture23},
{"TEXTURE24", V8WebGLRenderingContext::Constant::kTexture24},
{"TEXTURE25", V8WebGLRenderingContext::Constant::kTexture25},
{"TEXTURE26", V8WebGLRenderingContext::Constant::kTexture26},
{"TEXTURE27", V8WebGLRenderingContext::Constant::kTexture27},
{"TEXTURE28", V8WebGLRenderingContext::Constant::kTexture28},
{"TEXTURE29", V8WebGLRenderingContext::Constant::kTexture29},
{"TEXTURE30", V8WebGLRenderingContext::Constant::kTexture30},
{"TEXTURE31", V8WebGLRenderingContext::Constant::kTexture31},
{"ACTIVE_TEXTURE", V8WebGLRenderingContext::Constant::kActiveTexture},
{"REPEAT", V8WebGLRenderingContext::Constant::kRepeat},
{"CLAMP_TO_EDGE", V8WebGLRenderingContext::Constant::kClampToEdge},
{"MIRRORED_REPEAT", V8WebGLRenderingContext::Constant::kMirroredRepeat},
{"FLOAT_VEC2", V8WebGLRenderingContext::Constant::kFloatVec2},
{"FLOAT_VEC3", V8WebGLRenderingContext::Constant::kFloatVec3},
{"FLOAT_VEC4", V8WebGLRenderingContext::Constant::kFloatVec4},
{"INT_VEC2", V8WebGLRenderingContext::Constant::kIntVec2},
{"INT_VEC3", V8WebGLRenderingContext::Constant::kIntVec3},
{"INT_VEC4", V8WebGLRenderingContext::Constant::kIntVec4},
{"BOOL", V8WebGLRenderingContext::Constant::kBool},
{"BOOL_VEC2", V8WebGLRenderingContext::Constant::kBoolVec2},
{"BOOL_VEC3", V8WebGLRenderingContext::Constant::kBoolVec3},
{"BOOL_VEC4", V8WebGLRenderingContext::Constant::kBoolVec4},
{"FLOAT_MAT2", V8WebGLRenderingContext::Constant::kFloatMat2},
{"FLOAT_MAT3", V8WebGLRenderingContext::Constant::kFloatMat3},
{"FLOAT_MAT4", V8WebGLRenderingContext::Constant::kFloatMat4},
{"SAMPLER_2D", V8WebGLRenderingContext::Constant::kSampler2d},
{"SAMPLER_CUBE", V8WebGLRenderingContext::Constant::kSamplerCube},
{"VERTEX_ATTRIB_ARRAY_ENABLED", V8WebGLRenderingContext::Constant::kVertexAttribArrayEnabled},
{"VERTEX_ATTRIB_ARRAY_SIZE", V8WebGLRenderingContext::Constant::kVertexAttribArraySize},
{"VERTEX_ATTRIB_ARRAY_STRIDE", V8WebGLRenderingContext::Constant::kVertexAttribArrayStride},
{"VERTEX_ATTRIB_ARRAY_TYPE", V8WebGLRenderingContext::Constant::kVertexAttribArrayType},
{"VERTEX_ATTRIB_ARRAY_NORMALIZED", V8WebGLRenderingContext::Constant::kVertexAttribArrayNormalized},
{"VERTEX_ATTRIB_ARRAY_POINTER", V8WebGLRenderingContext::Constant::kVertexAttribArrayPointer},
{"VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", V8WebGLRenderingContext::Constant::kVertexAttribArrayBufferBinding},
{"IMPLEMENTATION_COLOR_READ_TYPE", V8WebGLRenderingContext::Constant::kImplementationColorReadType},
{"IMPLEMENTATION_COLOR_READ_FORMAT", V8WebGLRenderingContext::Constant::kImplementationColorReadFormat},
{"COMPILE_STATUS", V8WebGLRenderingContext::Constant::kCompileStatus},
{"LOW_FLOAT", V8WebGLRenderingContext::Constant::kLowFloat},
{"MEDIUM_FLOAT", V8WebGLRenderingContext::Constant::kMediumFloat},
{"HIGH_FLOAT", V8WebGLRenderingContext::Constant::kHighFloat},
{"LOW_INT", V8WebGLRenderingContext::Constant::kLowInt},
{"MEDIUM_INT", V8WebGLRenderingContext::Constant::kMediumInt},
{"HIGH_INT", V8WebGLRenderingContext::Constant::kHighInt},
{"FRAMEBUFFER", V8WebGLRenderingContext::Constant::kFramebuffer},
{"RENDERBUFFER", V8WebGLRenderingContext::Constant::kRenderbuffer},
{"RGBA4", V8WebGLRenderingContext::Constant::kRgba4},
{"RGB5_A1", V8WebGLRenderingContext::Constant::kRgb5A1},
{"RGB565", V8WebGLRenderingContext::Constant::kRgb565},
{"DEPTH_COMPONENT16", V8WebGLRenderingContext::Constant::kDepthComponent16},
{"STENCIL_INDEX8", V8WebGLRenderingContext::Constant::kStencilIndex8},
{"DEPTH_STENCIL", V8WebGLRenderingContext::Constant::kDepthStencil},
{"RENDERBUFFER_WIDTH", V8WebGLRenderingContext::Constant::kRenderbufferWidth},
{"RENDERBUFFER_HEIGHT", V8WebGLRenderingContext::Constant::kRenderbufferHeight},
{"RENDERBUFFER_INTERNAL_FORMAT", V8WebGLRenderingContext::Constant::kRenderbufferInternalFormat},
{"RENDERBUFFER_RED_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferRedSize},
{"RENDERBUFFER_GREEN_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferGreenSize},
{"RENDERBUFFER_BLUE_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferBlueSize},
{"RENDERBUFFER_ALPHA_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferAlphaSize},
{"RENDERBUFFER_DEPTH_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferDepthSize},
{"RENDERBUFFER_STENCIL_SIZE", V8WebGLRenderingContext::Constant::kRenderbufferStencilSize},
{"FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", V8WebGLRenderingContext::Constant::kFramebufferAttachmentObjectType},
{"FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", V8WebGLRenderingContext::Constant::kFramebufferAttachmentObjectName},
{"FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", V8WebGLRenderingContext::Constant::kFramebufferAttachmentTextureLevel},
{"FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", V8WebGLRenderingContext::Constant::kFramebufferAttachmentTextureCubeMapFace},
{"COLOR_ATTACHMENT0", V8WebGLRenderingContext::Constant::kColorAttachment0},
{"DEPTH_ATTACHMENT", V8WebGLRenderingContext::Constant::kDepthAttachment},
{"STENCIL_ATTACHMENT", V8WebGLRenderingContext::Constant::kStencilAttachment},
{"DEPTH_STENCIL_ATTACHMENT", V8WebGLRenderingContext::Constant::kDepthStencilAttachment},
{"NONE", V8WebGLRenderingContext::Constant::kNone},
{"FRAMEBUFFER_COMPLETE", V8WebGLRenderingContext::Constant::kFramebufferComplete},
{"FRAMEBUFFER_INCOMPLETE_ATTACHMENT", V8WebGLRenderingContext::Constant::kFramebufferIncompleteAttachment},
{"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", V8WebGLRenderingContext::Constant::kFramebufferIncompleteMissingAttachment},
{"FRAMEBUFFER_INCOMPLETE_DIMENSIONS", V8WebGLRenderingContext::Constant::kFramebufferIncompleteDimensions},
{"FRAMEBUFFER_UNSUPPORTED", V8WebGLRenderingContext::Constant::kFramebufferUnsupported},
{"FRAMEBUFFER_BINDING", V8WebGLRenderingContext::Constant::kFramebufferBinding},
{"RENDERBUFFER_BINDING", V8WebGLRenderingContext::Constant::kRenderbufferBinding},
{"MAX_RENDERBUFFER_SIZE", V8WebGLRenderingContext::Constant::kMaxRenderbufferSize},
{"INVALID_FRAMEBUFFER_OPERATION", V8WebGLRenderingContext::Constant::kInvalidFramebufferOperation},
{"UNPACK_FLIP_Y_WEBGL", V8WebGLRenderingContext::Constant::kUnpackFlipYWebgl},
{"UNPACK_PREMULTIPLY_ALPHA_WEBGL", V8WebGLRenderingContext::Constant::kUnpackPremultiplyAlphaWebgl},
{"CONTEXT_LOST_WEBGL", V8WebGLRenderingContext::Constant::kContextLostWebgl},
{"UNPACK_COLORSPACE_CONVERSION_WEBGL", V8WebGLRenderingContext::Constant::kUnpackColorspaceConversionWebgl},
{"BROWSER_DEFAULT_WEBGL", V8WebGLRenderingContext::Constant::kBrowserDefaultWebgl},
};
IDLMemberInstaller::InstallConstants(isolate, world, instance_template, prototype_template, interface_template, signature, kConstantValueTable);
}



{
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"activeTexture", ActiveTextureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"attachShader", AttachShaderOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"bindAttribLocation", BindAttribLocationOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"bindRenderbuffer", BindRenderbufferOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"blendColor", BlendColorOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"blendEquation", BlendEquationOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"blendEquationSeparate", BlendEquationSeparateOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"blendFunc", BlendFuncOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"blendFuncSeparate", BlendFuncSeparateOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"bufferData", BufferDataOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"bufferSubData", BufferSubDataOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"checkFramebufferStatus", CheckFramebufferStatusOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"compileShader", CompileShaderOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"compressedTexImage2D", CompressedTexImage2DOperationCallback, 7, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"compressedTexSubImage2D", CompressedTexSubImage2DOperationCallback, 8, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"copyTexImage2D", CopyTexImage2DOperationCallback, 8, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"copyTexSubImage2D", CopyTexSubImage2DOperationCallback, 8, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"createBuffer", CreateBufferOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"createFramebuffer", CreateFramebufferOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"createProgram", CreateProgramOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"createRenderbuffer", CreateRenderbufferOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"createShader", CreateShaderOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"createTexture", CreateTextureOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"cullFace", CullFaceOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"deleteBuffer", DeleteBufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"deleteFramebuffer", DeleteFramebufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"deleteProgram", DeleteProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"deleteRenderbuffer", DeleteRenderbufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"deleteShader", DeleteShaderOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"deleteTexture", DeleteTextureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"depthFunc", DepthFuncOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"depthMask", DepthMaskOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"depthRange", DepthRangeOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"detachShader", DetachShaderOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"disable", DisableOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"enable", EnableOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"finish", FinishOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"flush", FlushOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"framebufferRenderbuffer", FramebufferRenderbufferOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"framebufferTexture2D", FramebufferTexture2DOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"frontFace", FrontFaceOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"generateMipmap", GenerateMipmapOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getActiveAttrib", GetActiveAttribOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getActiveUniform", GetActiveUniformOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getAttachedShaders", GetAttachedShadersOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getAttribLocation", GetAttribLocationOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getBufferParameter", GetBufferParameterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getContextAttributes", GetContextAttributesOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getError", GetErrorOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getExtension", GetExtensionOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getFramebufferAttachmentParameter", GetFramebufferAttachmentParameterOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getParameter", GetParameterOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getProgramInfoLog", GetProgramInfoLogOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getProgramParameter", GetProgramParameterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getRenderbufferParameter", GetRenderbufferParameterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getShaderInfoLog", GetShaderInfoLogOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getShaderParameter", GetShaderParameterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getShaderPrecisionFormat", GetShaderPrecisionFormatOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getShaderSource", GetShaderSourceOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getSupportedExtensions", GetSupportedExtensionsOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getTexParameter", GetTexParameterOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getUniform", GetUniformOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getUniformLocation", GetUniformLocationOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getVertexAttrib", GetVertexAttribOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"getVertexAttribOffset", GetVertexAttribOffsetOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"hint", HintOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isBuffer", IsBufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isContextLost", IsContextLostOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isEnabled", IsEnabledOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isFramebuffer", IsFramebufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isProgram", IsProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isRenderbuffer", IsRenderbufferOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isShader", IsShaderOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"isTexture", IsTextureOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"lineWidth", LineWidthOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"linkProgram", LinkProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"pixelStorei", PixelStoreiOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"polygonOffset", PolygonOffsetOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"readPixels", ReadPixelsOperationCallback, 7, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"renderbufferStorage", RenderbufferStorageOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"sampleCoverage", SampleCoverageOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"shaderSource", ShaderSourceOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"stencilFunc", StencilFuncOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"stencilFuncSeparate", StencilFuncSeparateOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"stencilMask", StencilMaskOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"stencilMaskSeparate", StencilMaskSeparateOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"stencilOp", StencilOpOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"stencilOpSeparate", StencilOpSeparateOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"texImage2D", TexImage2DOperationCallback, 6, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"texParameterf", TexParameterfOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"texParameteri", TexParameteriOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"texSubImage2D", TexSubImage2DOperationCallback, 7, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"useProgram", UseProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
{"validateProgram", ValidateProgramOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}


{
  static const v8::CFunction kNoAllocDirectCallOverloadsOfBindBuffer[] = {
v8::CFunctionBuilder().Fn(BindBufferOperationNoAllocDirectCallArg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfBindFramebuffer[] = {
v8::CFunctionBuilder().Fn(BindFramebufferOperationNoAllocDirectCallArg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfBindTexture[] = {
v8::CFunctionBuilder().Fn(BindTextureOperationNoAllocDirectCallArg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfClear[] = {
v8::CFunctionBuilder().Fn(ClearOperationNoAllocDirectCallArg1).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfClearColor[] = {
v8::CFunctionBuilder().Fn(ClearColorOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfClearDepth[] = {
v8::CFunctionBuilder().Fn(ClearDepthOperationNoAllocDirectCallArg1).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfClearStencil[] = {
v8::CFunctionBuilder().Fn(ClearStencilOperationNoAllocDirectCallArg1).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfColorMask[] = {
v8::CFunctionBuilder().Fn(ColorMaskOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfDisableVertexAttribArray[] = {
v8::CFunctionBuilder().Fn(DisableVertexAttribArrayOperationNoAllocDirectCallArg1).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfDrawArrays[] = {
v8::CFunctionBuilder().Fn(DrawArraysOperationNoAllocDirectCallArg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfDrawElements[] = {
v8::CFunctionBuilder().Fn(DrawElementsOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfEnableVertexAttribArray[] = {
v8::CFunctionBuilder().Fn(EnableVertexAttribArrayOperationNoAllocDirectCallArg1).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfScissor[] = {
v8::CFunctionBuilder().Fn(ScissorOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1F[] = {
v8::CFunctionBuilder().Fn(Uniform1FOperationNoAllocDirectCallArg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1Fv[] = {
v8::CFunctionBuilder().Fn(Uniform1FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform1FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1I[] = {
v8::CFunctionBuilder().Fn(Uniform1IOperationNoAllocDirectCallArg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform1Iv[] = {
v8::CFunctionBuilder().Fn(Uniform1IvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform1IvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2F[] = {
v8::CFunctionBuilder().Fn(Uniform2FOperationNoAllocDirectCallArg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2Fv[] = {
v8::CFunctionBuilder().Fn(Uniform2FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform2FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2I[] = {
v8::CFunctionBuilder().Fn(Uniform2IOperationNoAllocDirectCallArg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform2Iv[] = {
v8::CFunctionBuilder().Fn(Uniform2IvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform2IvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3F[] = {
v8::CFunctionBuilder().Fn(Uniform3FOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3Fv[] = {
v8::CFunctionBuilder().Fn(Uniform3FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform3FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3I[] = {
v8::CFunctionBuilder().Fn(Uniform3IOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform3Iv[] = {
v8::CFunctionBuilder().Fn(Uniform3IvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform3IvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4F[] = {
v8::CFunctionBuilder().Fn(Uniform4FOperationNoAllocDirectCallArg5).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4Fv[] = {
v8::CFunctionBuilder().Fn(Uniform4FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform4FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4I[] = {
v8::CFunctionBuilder().Fn(Uniform4IOperationNoAllocDirectCallArg5).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniform4Iv[] = {
v8::CFunctionBuilder().Fn(Uniform4IvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(Uniform4IvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniformMatrix2Fv[] = {
v8::CFunctionBuilder().Fn(UniformMatrix2FvOperationNoAllocDirectCallOverload1Arg3).Build(),
v8::CFunctionBuilder().Fn(UniformMatrix2FvOperationNoAllocDirectCallOverload2Arg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniformMatrix3Fv[] = {
v8::CFunctionBuilder().Fn(UniformMatrix3FvOperationNoAllocDirectCallOverload1Arg3).Build(),
v8::CFunctionBuilder().Fn(UniformMatrix3FvOperationNoAllocDirectCallOverload2Arg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfUniformMatrix4Fv[] = {
v8::CFunctionBuilder().Fn(UniformMatrix4FvOperationNoAllocDirectCallOverload1Arg3).Build(),
v8::CFunctionBuilder().Fn(UniformMatrix4FvOperationNoAllocDirectCallOverload2Arg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib1F[] = {
v8::CFunctionBuilder().Fn(VertexAttrib1FOperationNoAllocDirectCallArg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib1Fv[] = {
v8::CFunctionBuilder().Fn(VertexAttrib1FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(VertexAttrib1FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib2F[] = {
v8::CFunctionBuilder().Fn(VertexAttrib2FOperationNoAllocDirectCallArg3).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib2Fv[] = {
v8::CFunctionBuilder().Fn(VertexAttrib2FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(VertexAttrib2FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib3F[] = {
v8::CFunctionBuilder().Fn(VertexAttrib3FOperationNoAllocDirectCallArg4).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib3Fv[] = {
v8::CFunctionBuilder().Fn(VertexAttrib3FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(VertexAttrib3FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib4F[] = {
v8::CFunctionBuilder().Fn(VertexAttrib4FOperationNoAllocDirectCallArg5).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttrib4Fv[] = {
v8::CFunctionBuilder().Fn(VertexAttrib4FvOperationNoAllocDirectCallOverload1Arg2).Build(),
v8::CFunctionBuilder().Fn(VertexAttrib4FvOperationNoAllocDirectCallOverload2Arg2).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfVertexAttribPointer[] = {
v8::CFunctionBuilder().Fn(VertexAttribPointerOperationNoAllocDirectCallArg6).Build(),
};
static const v8::CFunction kNoAllocDirectCallOverloadsOfViewport[] = {
v8::CFunctionBuilder().Fn(ViewportOperationNoAllocDirectCallArg4).Build(),
};

static const IDLMemberInstaller::NoAllocDirectCallOperationConfig kOperationTable[] = {
{{"bindBuffer", BindBufferOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfBindBuffer, std::size(kNoAllocDirectCallOverloadsOfBindBuffer)}, 
{{"bindFramebuffer", BindFramebufferOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfBindFramebuffer, std::size(kNoAllocDirectCallOverloadsOfBindFramebuffer)}, 
{{"bindTexture", BindTextureOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfBindTexture, std::size(kNoAllocDirectCallOverloadsOfBindTexture)}, 
{{"clear", ClearOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfClear, std::size(kNoAllocDirectCallOverloadsOfClear)}, 
{{"clearColor", ClearColorOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfClearColor, std::size(kNoAllocDirectCallOverloadsOfClearColor)}, 
{{"clearDepth", ClearDepthOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfClearDepth, std::size(kNoAllocDirectCallOverloadsOfClearDepth)}, 
{{"clearStencil", ClearStencilOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfClearStencil, std::size(kNoAllocDirectCallOverloadsOfClearStencil)}, 
{{"colorMask", ColorMaskOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfColorMask, std::size(kNoAllocDirectCallOverloadsOfColorMask)}, 
{{"disableVertexAttribArray", DisableVertexAttribArrayOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfDisableVertexAttribArray, std::size(kNoAllocDirectCallOverloadsOfDisableVertexAttribArray)}, 
{{"drawArrays", DrawArraysOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfDrawArrays, std::size(kNoAllocDirectCallOverloadsOfDrawArrays)}, 
{{"drawElements", DrawElementsOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfDrawElements, std::size(kNoAllocDirectCallOverloadsOfDrawElements)}, 
{{"enableVertexAttribArray", EnableVertexAttribArrayOperationCallback, 1, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfEnableVertexAttribArray, std::size(kNoAllocDirectCallOverloadsOfEnableVertexAttribArray)}, 
{{"scissor", ScissorOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfScissor, std::size(kNoAllocDirectCallOverloadsOfScissor)}, 
{{"uniform1f", Uniform1FOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform1F, std::size(kNoAllocDirectCallOverloadsOfUniform1F)}, 
{{"uniform1fv", Uniform1FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform1Fv, std::size(kNoAllocDirectCallOverloadsOfUniform1Fv)}, 
{{"uniform1i", Uniform1IOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform1I, std::size(kNoAllocDirectCallOverloadsOfUniform1I)}, 
{{"uniform1iv", Uniform1IvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform1Iv, std::size(kNoAllocDirectCallOverloadsOfUniform1Iv)}, 
{{"uniform2f", Uniform2FOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform2F, std::size(kNoAllocDirectCallOverloadsOfUniform2F)}, 
{{"uniform2fv", Uniform2FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform2Fv, std::size(kNoAllocDirectCallOverloadsOfUniform2Fv)}, 
{{"uniform2i", Uniform2IOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform2I, std::size(kNoAllocDirectCallOverloadsOfUniform2I)}, 
{{"uniform2iv", Uniform2IvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform2Iv, std::size(kNoAllocDirectCallOverloadsOfUniform2Iv)}, 
{{"uniform3f", Uniform3FOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform3F, std::size(kNoAllocDirectCallOverloadsOfUniform3F)}, 
{{"uniform3fv", Uniform3FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform3Fv, std::size(kNoAllocDirectCallOverloadsOfUniform3Fv)}, 
{{"uniform3i", Uniform3IOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform3I, std::size(kNoAllocDirectCallOverloadsOfUniform3I)}, 
{{"uniform3iv", Uniform3IvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform3Iv, std::size(kNoAllocDirectCallOverloadsOfUniform3Iv)}, 
{{"uniform4f", Uniform4FOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform4F, std::size(kNoAllocDirectCallOverloadsOfUniform4F)}, 
{{"uniform4fv", Uniform4FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform4Fv, std::size(kNoAllocDirectCallOverloadsOfUniform4Fv)}, 
{{"uniform4i", Uniform4IOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform4I, std::size(kNoAllocDirectCallOverloadsOfUniform4I)}, 
{{"uniform4iv", Uniform4IvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniform4Iv, std::size(kNoAllocDirectCallOverloadsOfUniform4Iv)}, 
{{"uniformMatrix2fv", UniformMatrix2FvOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniformMatrix2Fv, std::size(kNoAllocDirectCallOverloadsOfUniformMatrix2Fv)}, 
{{"uniformMatrix3fv", UniformMatrix3FvOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniformMatrix3Fv, std::size(kNoAllocDirectCallOverloadsOfUniformMatrix3Fv)}, 
{{"uniformMatrix4fv", UniformMatrix4FvOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfUniformMatrix4Fv, std::size(kNoAllocDirectCallOverloadsOfUniformMatrix4Fv)}, 
{{"vertexAttrib1f", VertexAttrib1FOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib1F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib1F)}, 
{{"vertexAttrib1fv", VertexAttrib1FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib1Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib1Fv)}, 
{{"vertexAttrib2f", VertexAttrib2FOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib2F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib2F)}, 
{{"vertexAttrib2fv", VertexAttrib2FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib2Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib2Fv)}, 
{{"vertexAttrib3f", VertexAttrib3FOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib3F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib3F)}, 
{{"vertexAttrib3fv", VertexAttrib3FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib3Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib3Fv)}, 
{{"vertexAttrib4f", VertexAttrib4FOperationCallback, 5, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib4F, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib4F)}, 
{{"vertexAttrib4fv", VertexAttrib4FvOperationCallback, 2, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttrib4Fv, std::size(kNoAllocDirectCallOverloadsOfVertexAttrib4Fv)}, 
{{"vertexAttribPointer", VertexAttribPointerOperationCallback, 6, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfVertexAttribPointer, std::size(kNoAllocDirectCallOverloadsOfVertexAttribPointer)}, 
{{"viewport", ViewportOperationCallback, 4, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, kNoAllocDirectCallOverloadsOfViewport, std::size(kNoAllocDirectCallOverloadsOfViewport)}, 
};
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}


}

void V8WebGLRenderingContext::InstallContextIndependentProperties(v8::Isolate* isolate, const DOMWrapperWorld& world, v8::Local<v8::Template> instance_template, v8::Local<v8::Template> prototype_template, v8::Local<v8::Template> interface_template) {
  using bindings::IDLMemberInstaller;

if (RuntimeEnabledFeatures::CanvasColorManagementV2Enabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"drawingBufferFormat", DrawingBufferFormatAttributeGetCallback, nullptr, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}
if (RuntimeEnabledFeatures::WebGLColorManagementEnabled()) {
  static const IDLMemberInstaller::AttributeConfig kAttributeTable[] = {
{"drawingBufferColorSpace", DrawingBufferColorSpaceAttributeGetCallback, DrawingBufferColorSpaceAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
{"unpackColorSpace", UnpackColorSpaceAttributeGetCallback, UnpackColorSpaceAttributeSetCallback, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasNoSideEffect), unsigned(V8PrivateProperty::CachedAccessor::kNone)},
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallAttributes(isolate, world, instance_template, prototype_template, interface_template, signature, kAttributeTable);
}




if (RuntimeEnabledFeatures::OffscreenCanvasCommitEnabled()) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"commit", CommitOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}
if (RuntimeEnabledFeatures::CanvasColorManagementV2Enabled()) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"drawingBufferStorage", DrawingBufferStorageOperationCallback, 3, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_template, prototype_template, interface_template, signature, kOperationTable);
}


}

void V8WebGLRenderingContext::InstallContextDependentProperties(v8::Local<v8::Context> context, const DOMWrapperWorld& world, v8::Local<v8::Object> instance_object, v8::Local<v8::Object> prototype_object, v8::Local<v8::Object> interface_object, v8::Local<v8::Template> interface_template, FeatureSelector feature_selector) {
  using bindings::IDLMemberInstaller;





ScriptState* script_state = ScriptState::From(context);
ExecutionContext* execution_context = ExecutionContext::From(script_state);
const bool is_in_secure_context = execution_context->IsSecureContext();
if (is_in_secure_context && (feature_selector.IsAll() && RuntimeEnabledFeatures::WebXREnabled())) {
  static const IDLMemberInstaller::OperationConfig kOperationTable[] = {
{"makeXRCompatible", MakeXRCompatibleOperationCallback, 0, unsigned(v8::None), unsigned(IDLMemberInstaller::FlagLocation::kPrototype), unsigned(IDLMemberInstaller::FlagWorld::kAllWorlds), unsigned(IDLMemberInstaller::FlagReceiverCheck::kDoNotCheck), unsigned(IDLMemberInstaller::FlagCrossOriginCheck::kCheck), unsigned(v8::SideEffectType::kHasSideEffect)}, 
};
v8::Isolate* isolate = context->GetIsolate();
v8::Local<v8::FunctionTemplate> interface_function_template = interface_template.As<v8::FunctionTemplate>();
v8::Local<v8::Signature> signature = v8::Signature::New(isolate, interface_function_template);
IDLMemberInstaller::InstallOperations(isolate, world, instance_object, prototype_object, interface_object, signature, kOperationTable);
}


}


}  // namespace blink
