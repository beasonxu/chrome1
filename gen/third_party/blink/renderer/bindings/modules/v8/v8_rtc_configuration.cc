// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

// DO NOT EDIT: This file is auto-generated by
// //third_party/blink/renderer/bindings/scripts/generate_bindings.py
//
// Use the GN flag `blink_enable_generated_code_formatting=true` to enable
// formatting of the generated files.

#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_configuration.h"

#include "third_party/blink/renderer/bindings/core/v8/generated_code_helper.h"
#include "third_party/blink/renderer/bindings/core/v8/native_value_traits_impl.h"
#include "third_party/blink/renderer/bindings/core/v8/to_v8_traits.h"
#include "third_party/blink/renderer/bindings/modules/v8/v8_rtc_ice_server.h"
#include "third_party/blink/renderer/core/execution_context/execution_context.h"
#include "third_party/blink/renderer/modules/peerconnection/rtc_certificate.h"
#include "third_party/blink/renderer/platform/bindings/exception_messages.h"
#include "third_party/blink/renderer/platform/bindings/exception_state.h"
#include "third_party/blink/renderer/platform/bindings/v8_per_isolate_data.h"

namespace blink {



RTCConfiguration* RTCConfiguration::Create(v8::Isolate* isolate, v8::Local<v8::Value> v8_value, ExceptionState& exception_state) {
  RTCConfiguration* dictionary = MakeGarbageCollected<RTCConfiguration>(isolate);
if (v8_value->IsNullOrUndefined()) {
  return dictionary;
}
if (!v8_value->IsObject()) {
  const char* const class_like_name = "RTCConfiguration";
exception_state.ThrowTypeError(ExceptionMessages::ValueNotOfType(class_like_name));
return nullptr;
}
dictionary->FillMembersFromV8Object(isolate, v8_value.As<v8::Object>(), exception_state);
if (UNLIKELY(exception_state.HadException())) {
  return nullptr;
}
return dictionary;
}

 RTCConfiguration::RTCConfiguration() {
  
}

 RTCConfiguration::RTCConfiguration(v8::Isolate* isolate) {
  
}








HeapVector<Member<RTCCertificate>> RTCConfiguration::getCertificatesOr(const HeapVector<Member<RTCCertificate>>& fallback_value) const {
  if (!hasCertificates()) {
  return fallback_value;
}
return member_certificates_;
}

HeapVector<Member<RTCCertificate>> RTCConfiguration::getCertificatesOr(HeapVector<Member<RTCCertificate>>&& fallback_value) const {
  if (!hasCertificates()) {
  return std::move(fallback_value);
}
return member_certificates_;
}

void RTCConfiguration::setCertificates(const HeapVector<Member<RTCCertificate>>& value) {
  member_certificates_ = value;
has_certificates_ = true;
}

void RTCConfiguration::setCertificates(HeapVector<Member<RTCCertificate>>&& value) {
  member_certificates_ = std::move(value);
has_certificates_ = true;
}














HeapVector<Member<RTCIceServer>> RTCConfiguration::getIceServersOr(const HeapVector<Member<RTCIceServer>>& fallback_value) const {
  if (!hasIceServers()) {
  return fallback_value;
}
return member_ice_servers_;
}

HeapVector<Member<RTCIceServer>> RTCConfiguration::getIceServersOr(HeapVector<Member<RTCIceServer>>&& fallback_value) const {
  if (!hasIceServers()) {
  return std::move(fallback_value);
}
return member_ice_servers_;
}

void RTCConfiguration::setIceServers(const HeapVector<Member<RTCIceServer>>& value) {
  member_ice_servers_ = value;
has_ice_servers_ = true;
}

void RTCConfiguration::setIceServers(HeapVector<Member<RTCIceServer>>&& value) {
  member_ice_servers_ = std::move(value);
has_ice_servers_ = true;
}



















































void RTCConfiguration::Trace(Visitor* visitor) const {
  TraceIfNeeded<V8RTCBundlePolicy>::Trace(visitor, member_bundle_policy_);
TraceIfNeeded<HeapVector<Member<RTCCertificate>>>::Trace(visitor, member_certificates_);
TraceIfNeeded<bool>::Trace(visitor, member_encoded_insertable_streams_);
TraceIfNeeded<uint8_t>::Trace(visitor, member_ice_candidate_pool_size_);
TraceIfNeeded<HeapVector<Member<RTCIceServer>>>::Trace(visitor, member_ice_servers_);
TraceIfNeeded<V8RTCIceTransportPolicy>::Trace(visitor, member_ice_transport_policy_);
TraceIfNeeded<V8RTCIceTransportPolicy>::Trace(visitor, member_ice_transports_);
TraceIfNeeded<bool>::Trace(visitor, member_rtc_audio_jitter_buffer_fast_accelerate_);
TraceIfNeeded<int32_t>::Trace(visitor, member_rtc_audio_jitter_buffer_max_packets_);
TraceIfNeeded<int32_t>::Trace(visitor, member_rtc_audio_jitter_buffer_min_delay_ms_);
TraceIfNeeded<V8RTCRtcpMuxPolicy>::Trace(visitor, member_rtcp_mux_policy_);
TraceIfNeeded<V8SdpSemantics>::Trace(visitor, member_sdp_semantics_);
bindings::DictionaryBase::Trace(visitor);
}

bool RTCConfiguration::FillV8ObjectWithMembers(ScriptState* script_state, v8::Local<v8::Object> v8_dictionary) const {
  v8::Local<v8::Value> v8_value;
v8::Isolate* isolate = script_state->GetIsolate();
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
const auto& v8_own_member_names = GetV8OwnMemberNames(isolate);
bool was_property_created;
if (hasBundlePolicy()) {
  if (!ToV8Traits<V8RTCBundlePolicy>::ToV8(script_state, member_bundle_policy_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[0].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (hasCertificates()) {
  if (!ToV8Traits<IDLSequence<RTCCertificate>>::ToV8(script_state, member_certificates_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[1].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (hasEncodedInsertableStreams()) {
  if (!ToV8Traits<IDLBoolean>::ToV8(script_state, member_encoded_insertable_streams_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[2].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (hasIceCandidatePoolSize()) {
  if (!ToV8Traits<IDLOctetEnforceRange>::ToV8(script_state, member_ice_candidate_pool_size_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[3].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (hasIceServers()) {
  if (!ToV8Traits<IDLSequence<RTCIceServer>>::ToV8(script_state, member_ice_servers_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[4].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (hasIceTransportPolicy()) {
  if (!ToV8Traits<V8RTCIceTransportPolicy>::ToV8(script_state, member_ice_transport_policy_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[5].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (hasIceTransports()) {
  if (!ToV8Traits<V8RTCIceTransportPolicy>::ToV8(script_state, member_ice_transports_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[6].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
ExecutionContext* execution_context = ExecutionContext::From(current_context);
if (RuntimeEnabledFeatures::RtcAudioJitterBufferMaxPacketsEnabled(execution_context)) {
  if (hasRtcAudioJitterBufferFastAccelerate()) {
  if (!ToV8Traits<IDLBoolean>::ToV8(script_state, member_rtc_audio_jitter_buffer_fast_accelerate_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[7].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
}
if (RuntimeEnabledFeatures::RtcAudioJitterBufferMaxPacketsEnabled(execution_context)) {
  if (hasRtcAudioJitterBufferMaxPackets()) {
  if (!ToV8Traits<IDLLong>::ToV8(script_state, member_rtc_audio_jitter_buffer_max_packets_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[8].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
}
if (RuntimeEnabledFeatures::RtcAudioJitterBufferMaxPacketsEnabled(execution_context)) {
  if (hasRtcAudioJitterBufferMinDelayMs()) {
  if (!ToV8Traits<IDLLong>::ToV8(script_state, member_rtc_audio_jitter_buffer_min_delay_ms_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[9].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
}
if (hasRtcpMuxPolicy()) {
  if (!ToV8Traits<V8RTCRtcpMuxPolicy>::ToV8(script_state, member_rtcp_mux_policy_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[10].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
if (RuntimeEnabledFeatures::RTCUnifiedPlanEnabled()) {
  if (hasSdpSemantics()) {
  if (!ToV8Traits<V8SdpSemantics>::ToV8(script_state, member_sdp_semantics_).ToLocal(&v8_value)) {
  return false;
}
if (!v8_dictionary->CreateDataProperty(current_context, v8_own_member_names[11].Get(isolate), v8_value).To(&was_property_created)) {
  return false;
}
}
}
return true;
}

void RTCConfiguration::FillMembersFromV8Object(v8::Isolate* isolate, v8::Local<v8::Object> v8_dictionary, ExceptionState& exception_state) {
  const char* const class_like_name = "RTCConfiguration";
ExceptionState::ContextScope exception_context_scope(ExceptionContext(ExceptionContext::Context::kDictionaryMemberGet, class_like_name, ""), exception_state);
exception_context_scope.ChangePropertyNameAsOptimizationHack("bundlePolicy");
constexpr bool is_optional = false;
v8::Local<v8::Context> current_context = isolate->GetCurrentContext();
const auto& v8_own_member_names = GetV8OwnMemberNames(isolate);
bool fallback_presence_var;
v8::TryCatch try_block(isolate);
if (!bindings::GetDictionaryMemberFromV8Object<V8RTCBundlePolicy, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[0].Get(isolate), fallback_presence_var, member_bundle_policy_, try_block, exception_state)) {
  return;
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("certificates");
if (!bindings::GetDictionaryMemberFromV8Object<IDLSequence<RTCCertificate>, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[1].Get(isolate), has_certificates_, member_certificates_, try_block, exception_state)) {
  return;
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("encodedInsertableStreams");
if (!bindings::GetDictionaryMemberFromV8Object<IDLBoolean, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[2].Get(isolate), fallback_presence_var, member_encoded_insertable_streams_, try_block, exception_state)) {
  return;
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("iceCandidatePoolSize");
if (!bindings::GetDictionaryMemberFromV8Object<IDLOctetEnforceRange, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[3].Get(isolate), fallback_presence_var, member_ice_candidate_pool_size_, try_block, exception_state)) {
  return;
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("iceServers");
if (!bindings::GetDictionaryMemberFromV8Object<IDLSequence<RTCIceServer>, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[4].Get(isolate), has_ice_servers_, member_ice_servers_, try_block, exception_state)) {
  return;
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("iceTransportPolicy");
if (!bindings::GetDictionaryMemberFromV8Object<V8RTCIceTransportPolicy, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[5].Get(isolate), has_ice_transport_policy_, member_ice_transport_policy_, try_block, exception_state)) {
  return;
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("iceTransports");
if (!bindings::GetDictionaryMemberFromV8Object<V8RTCIceTransportPolicy, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[6].Get(isolate), has_ice_transports_, member_ice_transports_, try_block, exception_state)) {
  return;
}
ExecutionContext* execution_context = ExecutionContext::From(current_context);
if (RuntimeEnabledFeatures::RtcAudioJitterBufferMaxPacketsEnabled(execution_context)) {
  exception_context_scope.ChangePropertyNameAsOptimizationHack("rtcAudioJitterBufferFastAccelerate");
if (!bindings::GetDictionaryMemberFromV8Object<IDLBoolean, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[7].Get(isolate), has_rtc_audio_jitter_buffer_fast_accelerate_, member_rtc_audio_jitter_buffer_fast_accelerate_, try_block, exception_state)) {
  return;
}
}
if (RuntimeEnabledFeatures::RtcAudioJitterBufferMaxPacketsEnabled(execution_context)) {
  exception_context_scope.ChangePropertyNameAsOptimizationHack("rtcAudioJitterBufferMaxPackets");
if (!bindings::GetDictionaryMemberFromV8Object<IDLLong, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[8].Get(isolate), has_rtc_audio_jitter_buffer_max_packets_, member_rtc_audio_jitter_buffer_max_packets_, try_block, exception_state)) {
  return;
}
}
if (RuntimeEnabledFeatures::RtcAudioJitterBufferMaxPacketsEnabled(execution_context)) {
  exception_context_scope.ChangePropertyNameAsOptimizationHack("rtcAudioJitterBufferMinDelayMs");
if (!bindings::GetDictionaryMemberFromV8Object<IDLLong, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[9].Get(isolate), has_rtc_audio_jitter_buffer_min_delay_ms_, member_rtc_audio_jitter_buffer_min_delay_ms_, try_block, exception_state)) {
  return;
}
}
exception_context_scope.ChangePropertyNameAsOptimizationHack("rtcpMuxPolicy");
if (!bindings::GetDictionaryMemberFromV8Object<V8RTCRtcpMuxPolicy, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[10].Get(isolate), fallback_presence_var, member_rtcp_mux_policy_, try_block, exception_state)) {
  return;
}
if (RuntimeEnabledFeatures::RTCUnifiedPlanEnabled()) {
  exception_context_scope.ChangePropertyNameAsOptimizationHack("sdpSemantics");
if (!bindings::GetDictionaryMemberFromV8Object<V8SdpSemantics, is_optional>(isolate, current_context, v8_dictionary, v8_own_member_names[11].Get(isolate), has_sdp_semantics_, member_sdp_semantics_, try_block, exception_state)) {
  return;
}
}
}

const base::span<const v8::Eternal<v8::Name>> RTCConfiguration::GetV8OwnMemberNames(v8::Isolate* isolate) {
  static const char* const kOwnMemberNames[] = {
"bundlePolicy",
"certificates",
"encodedInsertableStreams",
"iceCandidatePoolSize",
"iceServers",
"iceTransportPolicy",
"iceTransports",
"rtcAudioJitterBufferFastAccelerate",
"rtcAudioJitterBufferMaxPackets",
"rtcAudioJitterBufferMinDelayMs",
"rtcpMuxPolicy",
"sdpSemantics",
};
return V8PerIsolateData::From(isolate)->FindOrCreateEternalNameCache(kOwnMemberNames, kOwnMemberNames);
}


}  // namespace blink
