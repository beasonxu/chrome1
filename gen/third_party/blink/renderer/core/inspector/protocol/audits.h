// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Audits_h
#define blink_protocol_Audits_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/network.h"

namespace blink {
namespace protocol {
namespace Audits {
class AffectedCookie;
class AffectedRequest;
class AffectedFrame;
using CookieExclusionReason = String;
using CookieWarningReason = String;
using CookieOperation = String;
class CookieIssueDetails;
using MixedContentResolutionStatus = String;
using MixedContentResourceType = String;
class MixedContentIssueDetails;
using BlockedByResponseReason = String;
class BlockedByResponseIssueDetails;
using HeavyAdResolutionStatus = String;
using HeavyAdReason = String;
class HeavyAdIssueDetails;
using ContentSecurityPolicyViolationType = String;
class SourceCodeLocation;
class ContentSecurityPolicyIssueDetails;
using SharedArrayBufferIssueType = String;
class SharedArrayBufferIssueDetails;
using TwaQualityEnforcementViolationType = String;
class TrustedWebActivityIssueDetails;
class LowTextContrastIssueDetails;
class CorsIssueDetails;
using AttributionReportingIssueType = String;
class AttributionReportingIssueDetails;
class QuirksModeIssueDetails;
class NavigatorUserAgentIssueDetails;
using GenericIssueErrorType = String;
class GenericIssueDetails;
using DeprecationIssueType = String;
class DeprecationIssueDetails;
using ClientHintIssueReason = String;
class FederatedAuthRequestIssueDetails;
using FederatedAuthRequestIssueReason = String;
class ClientHintIssueDetails;
using InspectorIssueCode = String;
class InspectorIssueDetails;
using IssueId = String;
class InspectorIssue;

// ------------- Forward and enum declarations.

namespace CookieExclusionReasonEnum {
CORE_EXPORT extern const char ExcludeSameSiteUnspecifiedTreatedAsLax[];
CORE_EXPORT extern const char ExcludeSameSiteNoneInsecure[];
CORE_EXPORT extern const char ExcludeSameSiteLax[];
CORE_EXPORT extern const char ExcludeSameSiteStrict[];
CORE_EXPORT extern const char ExcludeInvalidSameParty[];
CORE_EXPORT extern const char ExcludeSamePartyCrossPartyContext[];
CORE_EXPORT extern const char ExcludeDomainNonASCII[];
} // namespace CookieExclusionReasonEnum

namespace CookieWarningReasonEnum {
CORE_EXPORT extern const char WarnSameSiteUnspecifiedCrossSiteContext[];
CORE_EXPORT extern const char WarnSameSiteNoneInsecure[];
CORE_EXPORT extern const char WarnSameSiteUnspecifiedLaxAllowUnsafe[];
CORE_EXPORT extern const char WarnSameSiteStrictLaxDowngradeStrict[];
CORE_EXPORT extern const char WarnSameSiteStrictCrossDowngradeStrict[];
CORE_EXPORT extern const char WarnSameSiteStrictCrossDowngradeLax[];
CORE_EXPORT extern const char WarnSameSiteLaxCrossDowngradeStrict[];
CORE_EXPORT extern const char WarnSameSiteLaxCrossDowngradeLax[];
CORE_EXPORT extern const char WarnAttributeValueExceedsMaxSize[];
CORE_EXPORT extern const char WarnDomainNonASCII[];
} // namespace CookieWarningReasonEnum

namespace CookieOperationEnum {
CORE_EXPORT extern const char SetCookie[];
CORE_EXPORT extern const char ReadCookie[];
} // namespace CookieOperationEnum

namespace MixedContentResolutionStatusEnum {
CORE_EXPORT extern const char MixedContentBlocked[];
CORE_EXPORT extern const char MixedContentAutomaticallyUpgraded[];
CORE_EXPORT extern const char MixedContentWarning[];
} // namespace MixedContentResolutionStatusEnum

namespace MixedContentResourceTypeEnum {
CORE_EXPORT extern const char AttributionSrc[];
CORE_EXPORT extern const char Audio[];
CORE_EXPORT extern const char Beacon[];
CORE_EXPORT extern const char CSPReport[];
CORE_EXPORT extern const char Download[];
CORE_EXPORT extern const char EventSource[];
CORE_EXPORT extern const char Favicon[];
CORE_EXPORT extern const char Font[];
CORE_EXPORT extern const char Form[];
CORE_EXPORT extern const char Frame[];
CORE_EXPORT extern const char Image[];
CORE_EXPORT extern const char Import[];
CORE_EXPORT extern const char Manifest[];
CORE_EXPORT extern const char Ping[];
CORE_EXPORT extern const char PluginData[];
CORE_EXPORT extern const char PluginResource[];
CORE_EXPORT extern const char Prefetch[];
CORE_EXPORT extern const char Resource[];
CORE_EXPORT extern const char Script[];
CORE_EXPORT extern const char ServiceWorker[];
CORE_EXPORT extern const char SharedWorker[];
CORE_EXPORT extern const char Stylesheet[];
CORE_EXPORT extern const char Track[];
CORE_EXPORT extern const char Video[];
CORE_EXPORT extern const char Worker[];
CORE_EXPORT extern const char XMLHttpRequest[];
CORE_EXPORT extern const char XSLT[];
} // namespace MixedContentResourceTypeEnum

namespace BlockedByResponseReasonEnum {
CORE_EXPORT extern const char CoepFrameResourceNeedsCoepHeader[];
CORE_EXPORT extern const char CoopSandboxedIFrameCannotNavigateToCoopPage[];
CORE_EXPORT extern const char CorpNotSameOrigin[];
CORE_EXPORT extern const char CorpNotSameOriginAfterDefaultedToSameOriginByCoep[];
CORE_EXPORT extern const char CorpNotSameSite[];
} // namespace BlockedByResponseReasonEnum

namespace HeavyAdResolutionStatusEnum {
CORE_EXPORT extern const char HeavyAdBlocked[];
CORE_EXPORT extern const char HeavyAdWarning[];
} // namespace HeavyAdResolutionStatusEnum

namespace HeavyAdReasonEnum {
CORE_EXPORT extern const char NetworkTotalLimit[];
CORE_EXPORT extern const char CpuTotalLimit[];
CORE_EXPORT extern const char CpuPeakLimit[];
} // namespace HeavyAdReasonEnum

namespace ContentSecurityPolicyViolationTypeEnum {
CORE_EXPORT extern const char KInlineViolation[];
CORE_EXPORT extern const char KEvalViolation[];
CORE_EXPORT extern const char KURLViolation[];
CORE_EXPORT extern const char KTrustedTypesSinkViolation[];
CORE_EXPORT extern const char KTrustedTypesPolicyViolation[];
CORE_EXPORT extern const char KWasmEvalViolation[];
} // namespace ContentSecurityPolicyViolationTypeEnum

namespace SharedArrayBufferIssueTypeEnum {
CORE_EXPORT extern const char TransferIssue[];
CORE_EXPORT extern const char CreationIssue[];
} // namespace SharedArrayBufferIssueTypeEnum

namespace TwaQualityEnforcementViolationTypeEnum {
CORE_EXPORT extern const char KHttpError[];
CORE_EXPORT extern const char KUnavailableOffline[];
CORE_EXPORT extern const char KDigitalAssetLinks[];
} // namespace TwaQualityEnforcementViolationTypeEnum

namespace AttributionReportingIssueTypeEnum {
CORE_EXPORT extern const char PermissionPolicyDisabled[];
CORE_EXPORT extern const char UntrustworthyReportingOrigin[];
CORE_EXPORT extern const char InsecureContext[];
CORE_EXPORT extern const char InvalidHeader[];
CORE_EXPORT extern const char InvalidRegisterTriggerHeader[];
CORE_EXPORT extern const char InvalidEligibleHeader[];
CORE_EXPORT extern const char TooManyConcurrentRequests[];
CORE_EXPORT extern const char SourceAndTriggerHeaders[];
CORE_EXPORT extern const char SourceIgnored[];
CORE_EXPORT extern const char TriggerIgnored[];
} // namespace AttributionReportingIssueTypeEnum

namespace GenericIssueErrorTypeEnum {
CORE_EXPORT extern const char CrossOriginPortalPostMessageError[];
} // namespace GenericIssueErrorTypeEnum

namespace DeprecationIssueTypeEnum {
CORE_EXPORT extern const char AuthorizationCoveredByWildcard[];
CORE_EXPORT extern const char CanRequestURLHTTPContainingNewline[];
CORE_EXPORT extern const char ChromeLoadTimesConnectionInfo[];
CORE_EXPORT extern const char ChromeLoadTimesFirstPaintAfterLoadTime[];
CORE_EXPORT extern const char ChromeLoadTimesWasAlternateProtocolAvailable[];
CORE_EXPORT extern const char CookieWithTruncatingChar[];
CORE_EXPORT extern const char CrossOriginAccessBasedOnDocumentDomain[];
CORE_EXPORT extern const char CrossOriginWindowAlert[];
CORE_EXPORT extern const char CrossOriginWindowConfirm[];
CORE_EXPORT extern const char CSSSelectorInternalMediaControlsOverlayCastButton[];
CORE_EXPORT extern const char DeprecationExample[];
CORE_EXPORT extern const char DocumentDomainSettingWithoutOriginAgentClusterHeader[];
CORE_EXPORT extern const char EventPath[];
CORE_EXPORT extern const char ExpectCTHeader[];
CORE_EXPORT extern const char GeolocationInsecureOrigin[];
CORE_EXPORT extern const char GeolocationInsecureOriginDeprecatedNotRemoved[];
CORE_EXPORT extern const char GetUserMediaInsecureOrigin[];
CORE_EXPORT extern const char HostCandidateAttributeGetter[];
CORE_EXPORT extern const char IdentityInCanMakePaymentEvent[];
CORE_EXPORT extern const char InsecurePrivateNetworkSubresourceRequest[];
CORE_EXPORT extern const char LegacyConstraintGoogIPv6[];
CORE_EXPORT extern const char LocalCSSFileExtensionRejected[];
CORE_EXPORT extern const char MediaSourceAbortRemove[];
CORE_EXPORT extern const char MediaSourceDurationTruncatingBuffered[];
CORE_EXPORT extern const char NavigateEventRestoreScroll[];
CORE_EXPORT extern const char NavigateEventTransitionWhile[];
CORE_EXPORT extern const char NoSysexWebMIDIWithoutPermission[];
CORE_EXPORT extern const char NotificationInsecureOrigin[];
CORE_EXPORT extern const char NotificationPermissionRequestedIframe[];
CORE_EXPORT extern const char ObsoleteWebRtcCipherSuite[];
CORE_EXPORT extern const char OpenWebDatabaseInsecureContext[];
CORE_EXPORT extern const char OverflowVisibleOnReplacedElement[];
CORE_EXPORT extern const char PersistentQuotaType[];
CORE_EXPORT extern const char PictureSourceSrc[];
CORE_EXPORT extern const char PrefixedCancelAnimationFrame[];
CORE_EXPORT extern const char PrefixedRequestAnimationFrame[];
CORE_EXPORT extern const char PrefixedStorageInfo[];
CORE_EXPORT extern const char PrefixedVideoDisplayingFullscreen[];
CORE_EXPORT extern const char PrefixedVideoEnterFullscreen[];
CORE_EXPORT extern const char PrefixedVideoEnterFullScreen[];
CORE_EXPORT extern const char PrefixedVideoExitFullscreen[];
CORE_EXPORT extern const char PrefixedVideoExitFullScreen[];
CORE_EXPORT extern const char PrefixedVideoSupportsFullscreen[];
CORE_EXPORT extern const char RangeExpand[];
CORE_EXPORT extern const char RequestedSubresourceWithEmbeddedCredentials[];
CORE_EXPORT extern const char RTCConstraintEnableDtlsSrtpFalse[];
CORE_EXPORT extern const char RTCConstraintEnableDtlsSrtpTrue[];
CORE_EXPORT extern const char RTCPeerConnectionComplexPlanBSdpUsingDefaultSdpSemantics[];
CORE_EXPORT extern const char RTCPeerConnectionSdpSemanticsPlanB[];
CORE_EXPORT extern const char RtcpMuxPolicyNegotiate[];
CORE_EXPORT extern const char SharedArrayBufferConstructedWithoutIsolation[];
CORE_EXPORT extern const char TextToSpeech_DisallowedByAutoplay[];
CORE_EXPORT extern const char V8SharedArrayBufferConstructedInExtensionWithoutIsolation[];
CORE_EXPORT extern const char XHRJSONEncodingDetection[];
CORE_EXPORT extern const char XMLHttpRequestSynchronousInNonWorkerOutsideBeforeUnload[];
CORE_EXPORT extern const char XRSupportsSession[];
} // namespace DeprecationIssueTypeEnum

namespace ClientHintIssueReasonEnum {
CORE_EXPORT extern const char MetaTagAllowListInvalidOrigin[];
CORE_EXPORT extern const char MetaTagModifiedHTML[];
} // namespace ClientHintIssueReasonEnum

namespace FederatedAuthRequestIssueReasonEnum {
CORE_EXPORT extern const char ApprovalDeclined[];
CORE_EXPORT extern const char TooManyRequests[];
CORE_EXPORT extern const char ManifestListHttpNotFound[];
CORE_EXPORT extern const char ManifestListNoResponse[];
CORE_EXPORT extern const char ManifestListInvalidResponse[];
CORE_EXPORT extern const char ManifestNotInManifestList[];
CORE_EXPORT extern const char ManifestListTooBig[];
CORE_EXPORT extern const char ManifestHttpNotFound[];
CORE_EXPORT extern const char ManifestNoResponse[];
CORE_EXPORT extern const char ManifestInvalidResponse[];
CORE_EXPORT extern const char ClientMetadataHttpNotFound[];
CORE_EXPORT extern const char ClientMetadataNoResponse[];
CORE_EXPORT extern const char ClientMetadataInvalidResponse[];
CORE_EXPORT extern const char DisabledInSettings[];
CORE_EXPORT extern const char ErrorFetchingSignin[];
CORE_EXPORT extern const char InvalidSigninResponse[];
CORE_EXPORT extern const char AccountsHttpNotFound[];
CORE_EXPORT extern const char AccountsNoResponse[];
CORE_EXPORT extern const char AccountsInvalidResponse[];
CORE_EXPORT extern const char IdTokenHttpNotFound[];
CORE_EXPORT extern const char IdTokenNoResponse[];
CORE_EXPORT extern const char IdTokenInvalidResponse[];
CORE_EXPORT extern const char IdTokenInvalidRequest[];
CORE_EXPORT extern const char ErrorIdToken[];
CORE_EXPORT extern const char Canceled[];
} // namespace FederatedAuthRequestIssueReasonEnum

namespace InspectorIssueCodeEnum {
CORE_EXPORT extern const char CookieIssue[];
CORE_EXPORT extern const char MixedContentIssue[];
CORE_EXPORT extern const char BlockedByResponseIssue[];
CORE_EXPORT extern const char HeavyAdIssue[];
CORE_EXPORT extern const char ContentSecurityPolicyIssue[];
CORE_EXPORT extern const char SharedArrayBufferIssue[];
CORE_EXPORT extern const char TrustedWebActivityIssue[];
CORE_EXPORT extern const char LowTextContrastIssue[];
CORE_EXPORT extern const char CorsIssue[];
CORE_EXPORT extern const char AttributionReportingIssue[];
CORE_EXPORT extern const char QuirksModeIssue[];
CORE_EXPORT extern const char NavigatorUserAgentIssue[];
CORE_EXPORT extern const char GenericIssue[];
CORE_EXPORT extern const char DeprecationIssue[];
CORE_EXPORT extern const char ClientHintIssue[];
CORE_EXPORT extern const char FederatedAuthRequestIssue[];
} // namespace InspectorIssueCodeEnum

namespace GetEncodedResponse {
namespace EncodingEnum {
CORE_EXPORT extern const char* Webp;
CORE_EXPORT extern const char* Jpeg;
CORE_EXPORT extern const char* Png;
} // EncodingEnum
} // GetEncodedResponse

// ------------- Type and builder declarations.

class CORE_EXPORT AffectedCookie : public ::crdtp::ProtocolObject<AffectedCookie> {
public:
    ~AffectedCookie() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getPath() { return m_path; }
    void setPath(const String& value) { m_path = value; }

    String getDomain() { return m_domain; }
    void setDomain(const String& value) { m_domain = value; }

    template<int STATE>
    class AffectedCookieBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            PathSet = 1 << 2,
            DomainSet = 1 << 3,
            AllFieldsSet = (NameSet | PathSet | DomainSet | 0)};


        AffectedCookieBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        AffectedCookieBuilder<STATE | PathSet>& setPath(const String& value)
        {
            static_assert(!(STATE & PathSet), "property path should not be set yet");
            m_result->setPath(value);
            return castState<PathSet>();
        }

        AffectedCookieBuilder<STATE | DomainSet>& setDomain(const String& value)
        {
            static_assert(!(STATE & DomainSet), "property domain should not be set yet");
            m_result->setDomain(value);
            return castState<DomainSet>();
        }

        std::unique_ptr<AffectedCookie> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedCookie;
        AffectedCookieBuilder() : m_result(new AffectedCookie()) { }

        template<int STEP> AffectedCookieBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedCookieBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedCookie> m_result;
    };

    static AffectedCookieBuilder<0> create()
    {
        return AffectedCookieBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AffectedCookie()
    {
    }

    String m_name;
    String m_path;
    String m_domain;
};


class CORE_EXPORT AffectedRequest : public ::crdtp::ProtocolObject<AffectedRequest> {
public:
    ~AffectedRequest() override { }

    String getRequestId() { return m_requestId; }
    void setRequestId(const String& value) { m_requestId = value; }

    bool hasUrl() { return m_url.isJust(); }
    String getUrl(const String& defaultValue) { return m_url.isJust() ? m_url.fromJust() : defaultValue; }
    void setUrl(const String& value) { m_url = value; }

    template<int STATE>
    class AffectedRequestBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestIdSet = 1 << 1,
            AllFieldsSet = (RequestIdSet | 0)};


        AffectedRequestBuilder<STATE | RequestIdSet>& setRequestId(const String& value)
        {
            static_assert(!(STATE & RequestIdSet), "property requestId should not be set yet");
            m_result->setRequestId(value);
            return castState<RequestIdSet>();
        }

        AffectedRequestBuilder<STATE>& setUrl(const String& value)
        {
            m_result->setUrl(value);
            return *this;
        }

        std::unique_ptr<AffectedRequest> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedRequest;
        AffectedRequestBuilder() : m_result(new AffectedRequest()) { }

        template<int STEP> AffectedRequestBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedRequestBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedRequest> m_result;
    };

    static AffectedRequestBuilder<0> create()
    {
        return AffectedRequestBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AffectedRequest()
    {
    }

    String m_requestId;
    Maybe<String> m_url;
};


class CORE_EXPORT AffectedFrame : public ::crdtp::ProtocolObject<AffectedFrame> {
public:
    ~AffectedFrame() override { }

    String getFrameId() { return m_frameId; }
    void setFrameId(const String& value) { m_frameId = value; }

    template<int STATE>
    class AffectedFrameBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FrameIdSet = 1 << 1,
            AllFieldsSet = (FrameIdSet | 0)};


        AffectedFrameBuilder<STATE | FrameIdSet>& setFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setFrameId(value);
            return castState<FrameIdSet>();
        }

        std::unique_ptr<AffectedFrame> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AffectedFrame;
        AffectedFrameBuilder() : m_result(new AffectedFrame()) { }

        template<int STEP> AffectedFrameBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AffectedFrameBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AffectedFrame> m_result;
    };

    static AffectedFrameBuilder<0> create()
    {
        return AffectedFrameBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AffectedFrame()
    {
    }

    String m_frameId;
};


class CORE_EXPORT CookieIssueDetails : public ::crdtp::ProtocolObject<CookieIssueDetails> {
public:
    ~CookieIssueDetails() override { }

    bool hasCookie() { return m_cookie.isJust(); }
    protocol::Audits::AffectedCookie* getCookie(protocol::Audits::AffectedCookie* defaultValue) { return m_cookie.isJust() ? m_cookie.fromJust() : defaultValue; }
    void setCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value) { m_cookie = std::move(value); }

    bool hasRawCookieLine() { return m_rawCookieLine.isJust(); }
    String getRawCookieLine(const String& defaultValue) { return m_rawCookieLine.isJust() ? m_rawCookieLine.fromJust() : defaultValue; }
    void setRawCookieLine(const String& value) { m_rawCookieLine = value; }

    protocol::Array<String>* getCookieWarningReasons() { return m_cookieWarningReasons.get(); }
    void setCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieWarningReasons = std::move(value); }

    protocol::Array<String>* getCookieExclusionReasons() { return m_cookieExclusionReasons.get(); }
    void setCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value) { m_cookieExclusionReasons = std::move(value); }

    String getOperation() { return m_operation; }
    void setOperation(const String& value) { m_operation = value; }

    bool hasSiteForCookies() { return m_siteForCookies.isJust(); }
    String getSiteForCookies(const String& defaultValue) { return m_siteForCookies.isJust() ? m_siteForCookies.fromJust() : defaultValue; }
    void setSiteForCookies(const String& value) { m_siteForCookies = value; }

    bool hasCookieUrl() { return m_cookieUrl.isJust(); }
    String getCookieUrl(const String& defaultValue) { return m_cookieUrl.isJust() ? m_cookieUrl.fromJust() : defaultValue; }
    void setCookieUrl(const String& value) { m_cookieUrl = value; }

    bool hasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* getRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    template<int STATE>
    class CookieIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CookieWarningReasonsSet = 1 << 1,
            CookieExclusionReasonsSet = 1 << 2,
            OperationSet = 1 << 3,
            AllFieldsSet = (CookieWarningReasonsSet | CookieExclusionReasonsSet | OperationSet | 0)};


        CookieIssueDetailsBuilder<STATE>& setCookie(std::unique_ptr<protocol::Audits::AffectedCookie> value)
        {
            m_result->setCookie(std::move(value));
            return *this;
        }

        CookieIssueDetailsBuilder<STATE>& setRawCookieLine(const String& value)
        {
            m_result->setRawCookieLine(value);
            return *this;
        }

        CookieIssueDetailsBuilder<STATE | CookieWarningReasonsSet>& setCookieWarningReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieWarningReasonsSet), "property cookieWarningReasons should not be set yet");
            m_result->setCookieWarningReasons(std::move(value));
            return castState<CookieWarningReasonsSet>();
        }

        CookieIssueDetailsBuilder<STATE | CookieExclusionReasonsSet>& setCookieExclusionReasons(std::unique_ptr<protocol::Array<String>> value)
        {
            static_assert(!(STATE & CookieExclusionReasonsSet), "property cookieExclusionReasons should not be set yet");
            m_result->setCookieExclusionReasons(std::move(value));
            return castState<CookieExclusionReasonsSet>();
        }

        CookieIssueDetailsBuilder<STATE | OperationSet>& setOperation(const String& value)
        {
            static_assert(!(STATE & OperationSet), "property operation should not be set yet");
            m_result->setOperation(value);
            return castState<OperationSet>();
        }

        CookieIssueDetailsBuilder<STATE>& setSiteForCookies(const String& value)
        {
            m_result->setSiteForCookies(value);
            return *this;
        }

        CookieIssueDetailsBuilder<STATE>& setCookieUrl(const String& value)
        {
            m_result->setCookieUrl(value);
            return *this;
        }

        CookieIssueDetailsBuilder<STATE>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->setRequest(std::move(value));
            return *this;
        }

        std::unique_ptr<CookieIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CookieIssueDetails;
        CookieIssueDetailsBuilder() : m_result(new CookieIssueDetails()) { }

        template<int STEP> CookieIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CookieIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::CookieIssueDetails> m_result;
    };

    static CookieIssueDetailsBuilder<0> create()
    {
        return CookieIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    CookieIssueDetails()
    {
    }

    Maybe<protocol::Audits::AffectedCookie> m_cookie;
    Maybe<String> m_rawCookieLine;
    std::unique_ptr<protocol::Array<String>> m_cookieWarningReasons;
    std::unique_ptr<protocol::Array<String>> m_cookieExclusionReasons;
    String m_operation;
    Maybe<String> m_siteForCookies;
    Maybe<String> m_cookieUrl;
    Maybe<protocol::Audits::AffectedRequest> m_request;
};


class CORE_EXPORT MixedContentIssueDetails : public ::crdtp::ProtocolObject<MixedContentIssueDetails> {
public:
    ~MixedContentIssueDetails() override { }

    bool hasResourceType() { return m_resourceType.isJust(); }
    String getResourceType(const String& defaultValue) { return m_resourceType.isJust() ? m_resourceType.fromJust() : defaultValue; }
    void setResourceType(const String& value) { m_resourceType = value; }

    String getResolutionStatus() { return m_resolutionStatus; }
    void setResolutionStatus(const String& value) { m_resolutionStatus = value; }

    String getInsecureURL() { return m_insecureURL; }
    void setInsecureURL(const String& value) { m_insecureURL = value; }

    String getMainResourceURL() { return m_mainResourceURL; }
    void setMainResourceURL(const String& value) { m_mainResourceURL = value; }

    bool hasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* getRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool hasFrame() { return m_frame.isJust(); }
    protocol::Audits::AffectedFrame* getFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_frame.isJust() ? m_frame.fromJust() : defaultValue; }
    void setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    template<int STATE>
    class MixedContentIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ResolutionStatusSet = 1 << 1,
            InsecureURLSet = 1 << 2,
            MainResourceURLSet = 1 << 3,
            AllFieldsSet = (ResolutionStatusSet | InsecureURLSet | MainResourceURLSet | 0)};


        MixedContentIssueDetailsBuilder<STATE>& setResourceType(const String& value)
        {
            m_result->setResourceType(value);
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE | ResolutionStatusSet>& setResolutionStatus(const String& value)
        {
            static_assert(!(STATE & ResolutionStatusSet), "property resolutionStatus should not be set yet");
            m_result->setResolutionStatus(value);
            return castState<ResolutionStatusSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | InsecureURLSet>& setInsecureURL(const String& value)
        {
            static_assert(!(STATE & InsecureURLSet), "property insecureURL should not be set yet");
            m_result->setInsecureURL(value);
            return castState<InsecureURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE | MainResourceURLSet>& setMainResourceURL(const String& value)
        {
            static_assert(!(STATE & MainResourceURLSet), "property mainResourceURL should not be set yet");
            m_result->setMainResourceURL(value);
            return castState<MainResourceURLSet>();
        }

        MixedContentIssueDetailsBuilder<STATE>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->setRequest(std::move(value));
            return *this;
        }

        MixedContentIssueDetailsBuilder<STATE>& setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setFrame(std::move(value));
            return *this;
        }

        std::unique_ptr<MixedContentIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class MixedContentIssueDetails;
        MixedContentIssueDetailsBuilder() : m_result(new MixedContentIssueDetails()) { }

        template<int STEP> MixedContentIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<MixedContentIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::MixedContentIssueDetails> m_result;
    };

    static MixedContentIssueDetailsBuilder<0> create()
    {
        return MixedContentIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    MixedContentIssueDetails()
    {
    }

    Maybe<String> m_resourceType;
    String m_resolutionStatus;
    String m_insecureURL;
    String m_mainResourceURL;
    Maybe<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_frame;
};


class CORE_EXPORT BlockedByResponseIssueDetails : public ::crdtp::ProtocolObject<BlockedByResponseIssueDetails> {
public:
    ~BlockedByResponseIssueDetails() override { }

    protocol::Audits::AffectedRequest* getRequest() { return m_request.get(); }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool hasParentFrame() { return m_parentFrame.isJust(); }
    protocol::Audits::AffectedFrame* getParentFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_parentFrame.isJust() ? m_parentFrame.fromJust() : defaultValue; }
    void setParentFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_parentFrame = std::move(value); }

    bool hasBlockedFrame() { return m_blockedFrame.isJust(); }
    protocol::Audits::AffectedFrame* getBlockedFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_blockedFrame.isJust() ? m_blockedFrame.fromJust() : defaultValue; }
    void setBlockedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_blockedFrame = std::move(value); }

    String getReason() { return m_reason; }
    void setReason(const String& value) { m_reason = value; }

    template<int STATE>
    class BlockedByResponseIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RequestSet = 1 << 1,
            ReasonSet = 1 << 2,
            AllFieldsSet = (RequestSet | ReasonSet | 0)};


        BlockedByResponseIssueDetailsBuilder<STATE | RequestSet>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->setRequest(std::move(value));
            return castState<RequestSet>();
        }

        BlockedByResponseIssueDetailsBuilder<STATE>& setParentFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setParentFrame(std::move(value));
            return *this;
        }

        BlockedByResponseIssueDetailsBuilder<STATE>& setBlockedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setBlockedFrame(std::move(value));
            return *this;
        }

        BlockedByResponseIssueDetailsBuilder<STATE | ReasonSet>& setReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->setReason(value);
            return castState<ReasonSet>();
        }

        std::unique_ptr<BlockedByResponseIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BlockedByResponseIssueDetails;
        BlockedByResponseIssueDetailsBuilder() : m_result(new BlockedByResponseIssueDetails()) { }

        template<int STEP> BlockedByResponseIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BlockedByResponseIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> m_result;
    };

    static BlockedByResponseIssueDetailsBuilder<0> create()
    {
        return BlockedByResponseIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BlockedByResponseIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::AffectedFrame> m_parentFrame;
    Maybe<protocol::Audits::AffectedFrame> m_blockedFrame;
    String m_reason;
};


class CORE_EXPORT HeavyAdIssueDetails : public ::crdtp::ProtocolObject<HeavyAdIssueDetails> {
public:
    ~HeavyAdIssueDetails() override { }

    String getResolution() { return m_resolution; }
    void setResolution(const String& value) { m_resolution = value; }

    String getReason() { return m_reason; }
    void setReason(const String& value) { m_reason = value; }

    protocol::Audits::AffectedFrame* getFrame() { return m_frame.get(); }
    void setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frame = std::move(value); }

    template<int STATE>
    class HeavyAdIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ResolutionSet = 1 << 1,
            ReasonSet = 1 << 2,
            FrameSet = 1 << 3,
            AllFieldsSet = (ResolutionSet | ReasonSet | FrameSet | 0)};


        HeavyAdIssueDetailsBuilder<STATE | ResolutionSet>& setResolution(const String& value)
        {
            static_assert(!(STATE & ResolutionSet), "property resolution should not be set yet");
            m_result->setResolution(value);
            return castState<ResolutionSet>();
        }

        HeavyAdIssueDetailsBuilder<STATE | ReasonSet>& setReason(const String& value)
        {
            static_assert(!(STATE & ReasonSet), "property reason should not be set yet");
            m_result->setReason(value);
            return castState<ReasonSet>();
        }

        HeavyAdIssueDetailsBuilder<STATE | FrameSet>& setFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            static_assert(!(STATE & FrameSet), "property frame should not be set yet");
            m_result->setFrame(std::move(value));
            return castState<FrameSet>();
        }

        std::unique_ptr<HeavyAdIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HeavyAdIssueDetails;
        HeavyAdIssueDetailsBuilder() : m_result(new HeavyAdIssueDetails()) { }

        template<int STEP> HeavyAdIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HeavyAdIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::HeavyAdIssueDetails> m_result;
    };

    static HeavyAdIssueDetailsBuilder<0> create()
    {
        return HeavyAdIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    HeavyAdIssueDetails()
    {
    }

    String m_resolution;
    String m_reason;
    std::unique_ptr<protocol::Audits::AffectedFrame> m_frame;
};


class CORE_EXPORT SourceCodeLocation : public ::crdtp::ProtocolObject<SourceCodeLocation> {
public:
    ~SourceCodeLocation() override { }

    bool hasScriptId() { return m_scriptId.isJust(); }
    String getScriptId(const String& defaultValue) { return m_scriptId.isJust() ? m_scriptId.fromJust() : defaultValue; }
    void setScriptId(const String& value) { m_scriptId = value; }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    int getLineNumber() { return m_lineNumber; }
    void setLineNumber(int value) { m_lineNumber = value; }

    int getColumnNumber() { return m_columnNumber; }
    void setColumnNumber(int value) { m_columnNumber = value; }

    template<int STATE>
    class SourceCodeLocationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            LineNumberSet = 1 << 2,
            ColumnNumberSet = 1 << 3,
            AllFieldsSet = (UrlSet | LineNumberSet | ColumnNumberSet | 0)};


        SourceCodeLocationBuilder<STATE>& setScriptId(const String& value)
        {
            m_result->setScriptId(value);
            return *this;
        }

        SourceCodeLocationBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        SourceCodeLocationBuilder<STATE | LineNumberSet>& setLineNumber(int value)
        {
            static_assert(!(STATE & LineNumberSet), "property lineNumber should not be set yet");
            m_result->setLineNumber(value);
            return castState<LineNumberSet>();
        }

        SourceCodeLocationBuilder<STATE | ColumnNumberSet>& setColumnNumber(int value)
        {
            static_assert(!(STATE & ColumnNumberSet), "property columnNumber should not be set yet");
            m_result->setColumnNumber(value);
            return castState<ColumnNumberSet>();
        }

        std::unique_ptr<SourceCodeLocation> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SourceCodeLocation;
        SourceCodeLocationBuilder() : m_result(new SourceCodeLocation()) { }

        template<int STEP> SourceCodeLocationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SourceCodeLocationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::SourceCodeLocation> m_result;
    };

    static SourceCodeLocationBuilder<0> create()
    {
        return SourceCodeLocationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SourceCodeLocation()
    {
          m_lineNumber = 0;
          m_columnNumber = 0;
    }

    Maybe<String> m_scriptId;
    String m_url;
    int m_lineNumber;
    int m_columnNumber;
};


class CORE_EXPORT ContentSecurityPolicyIssueDetails : public ::crdtp::ProtocolObject<ContentSecurityPolicyIssueDetails> {
public:
    ~ContentSecurityPolicyIssueDetails() override { }

    bool hasBlockedURL() { return m_blockedURL.isJust(); }
    String getBlockedURL(const String& defaultValue) { return m_blockedURL.isJust() ? m_blockedURL.fromJust() : defaultValue; }
    void setBlockedURL(const String& value) { m_blockedURL = value; }

    String getViolatedDirective() { return m_violatedDirective; }
    void setViolatedDirective(const String& value) { m_violatedDirective = value; }

    bool getIsReportOnly() { return m_isReportOnly; }
    void setIsReportOnly(bool value) { m_isReportOnly = value; }

    String getContentSecurityPolicyViolationType() { return m_contentSecurityPolicyViolationType; }
    void setContentSecurityPolicyViolationType(const String& value) { m_contentSecurityPolicyViolationType = value; }

    bool hasFrameAncestor() { return m_frameAncestor.isJust(); }
    protocol::Audits::AffectedFrame* getFrameAncestor(protocol::Audits::AffectedFrame* defaultValue) { return m_frameAncestor.isJust() ? m_frameAncestor.fromJust() : defaultValue; }
    void setFrameAncestor(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_frameAncestor = std::move(value); }

    bool hasSourceCodeLocation() { return m_sourceCodeLocation.isJust(); }
    protocol::Audits::SourceCodeLocation* getSourceCodeLocation(protocol::Audits::SourceCodeLocation* defaultValue) { return m_sourceCodeLocation.isJust() ? m_sourceCodeLocation.fromJust() : defaultValue; }
    void setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    bool hasViolatingNodeId() { return m_violatingNodeId.isJust(); }
    int getViolatingNodeId(int defaultValue) { return m_violatingNodeId.isJust() ? m_violatingNodeId.fromJust() : defaultValue; }
    void setViolatingNodeId(int value) { m_violatingNodeId = value; }

    template<int STATE>
    class ContentSecurityPolicyIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViolatedDirectiveSet = 1 << 1,
            IsReportOnlySet = 1 << 2,
            ContentSecurityPolicyViolationTypeSet = 1 << 3,
            AllFieldsSet = (ViolatedDirectiveSet | IsReportOnlySet | ContentSecurityPolicyViolationTypeSet | 0)};


        ContentSecurityPolicyIssueDetailsBuilder<STATE>& setBlockedURL(const String& value)
        {
            m_result->setBlockedURL(value);
            return *this;
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE | ViolatedDirectiveSet>& setViolatedDirective(const String& value)
        {
            static_assert(!(STATE & ViolatedDirectiveSet), "property violatedDirective should not be set yet");
            m_result->setViolatedDirective(value);
            return castState<ViolatedDirectiveSet>();
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE | IsReportOnlySet>& setIsReportOnly(bool value)
        {
            static_assert(!(STATE & IsReportOnlySet), "property isReportOnly should not be set yet");
            m_result->setIsReportOnly(value);
            return castState<IsReportOnlySet>();
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE | ContentSecurityPolicyViolationTypeSet>& setContentSecurityPolicyViolationType(const String& value)
        {
            static_assert(!(STATE & ContentSecurityPolicyViolationTypeSet), "property contentSecurityPolicyViolationType should not be set yet");
            m_result->setContentSecurityPolicyViolationType(value);
            return castState<ContentSecurityPolicyViolationTypeSet>();
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE>& setFrameAncestor(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setFrameAncestor(std::move(value));
            return *this;
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE>& setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            m_result->setSourceCodeLocation(std::move(value));
            return *this;
        }

        ContentSecurityPolicyIssueDetailsBuilder<STATE>& setViolatingNodeId(int value)
        {
            m_result->setViolatingNodeId(value);
            return *this;
        }

        std::unique_ptr<ContentSecurityPolicyIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContentSecurityPolicyIssueDetails;
        ContentSecurityPolicyIssueDetailsBuilder() : m_result(new ContentSecurityPolicyIssueDetails()) { }

        template<int STEP> ContentSecurityPolicyIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContentSecurityPolicyIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::ContentSecurityPolicyIssueDetails> m_result;
    };

    static ContentSecurityPolicyIssueDetailsBuilder<0> create()
    {
        return ContentSecurityPolicyIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ContentSecurityPolicyIssueDetails()
    {
          m_isReportOnly = false;
    }

    Maybe<String> m_blockedURL;
    String m_violatedDirective;
    bool m_isReportOnly;
    String m_contentSecurityPolicyViolationType;
    Maybe<protocol::Audits::AffectedFrame> m_frameAncestor;
    Maybe<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    Maybe<int> m_violatingNodeId;
};


class CORE_EXPORT SharedArrayBufferIssueDetails : public ::crdtp::ProtocolObject<SharedArrayBufferIssueDetails> {
public:
    ~SharedArrayBufferIssueDetails() override { }

    protocol::Audits::SourceCodeLocation* getSourceCodeLocation() { return m_sourceCodeLocation.get(); }
    void setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    bool getIsWarning() { return m_isWarning; }
    void setIsWarning(bool value) { m_isWarning = value; }

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    template<int STATE>
    class SharedArrayBufferIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SourceCodeLocationSet = 1 << 1,
            IsWarningSet = 1 << 2,
            TypeSet = 1 << 3,
            AllFieldsSet = (SourceCodeLocationSet | IsWarningSet | TypeSet | 0)};


        SharedArrayBufferIssueDetailsBuilder<STATE | SourceCodeLocationSet>& setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            static_assert(!(STATE & SourceCodeLocationSet), "property sourceCodeLocation should not be set yet");
            m_result->setSourceCodeLocation(std::move(value));
            return castState<SourceCodeLocationSet>();
        }

        SharedArrayBufferIssueDetailsBuilder<STATE | IsWarningSet>& setIsWarning(bool value)
        {
            static_assert(!(STATE & IsWarningSet), "property isWarning should not be set yet");
            m_result->setIsWarning(value);
            return castState<IsWarningSet>();
        }

        SharedArrayBufferIssueDetailsBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        std::unique_ptr<SharedArrayBufferIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SharedArrayBufferIssueDetails;
        SharedArrayBufferIssueDetailsBuilder() : m_result(new SharedArrayBufferIssueDetails()) { }

        template<int STEP> SharedArrayBufferIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SharedArrayBufferIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::SharedArrayBufferIssueDetails> m_result;
    };

    static SharedArrayBufferIssueDetailsBuilder<0> create()
    {
        return SharedArrayBufferIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SharedArrayBufferIssueDetails()
    {
          m_isWarning = false;
    }

    std::unique_ptr<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    bool m_isWarning;
    String m_type;
};


class CORE_EXPORT TrustedWebActivityIssueDetails : public ::crdtp::ProtocolObject<TrustedWebActivityIssueDetails> {
public:
    ~TrustedWebActivityIssueDetails() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    String getViolationType() { return m_violationType; }
    void setViolationType(const String& value) { m_violationType = value; }

    bool hasHttpStatusCode() { return m_httpStatusCode.isJust(); }
    int getHttpStatusCode(int defaultValue) { return m_httpStatusCode.isJust() ? m_httpStatusCode.fromJust() : defaultValue; }
    void setHttpStatusCode(int value) { m_httpStatusCode = value; }

    bool hasPackageName() { return m_packageName.isJust(); }
    String getPackageName(const String& defaultValue) { return m_packageName.isJust() ? m_packageName.fromJust() : defaultValue; }
    void setPackageName(const String& value) { m_packageName = value; }

    bool hasSignature() { return m_signature.isJust(); }
    String getSignature(const String& defaultValue) { return m_signature.isJust() ? m_signature.fromJust() : defaultValue; }
    void setSignature(const String& value) { m_signature = value; }

    template<int STATE>
    class TrustedWebActivityIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            ViolationTypeSet = 1 << 2,
            AllFieldsSet = (UrlSet | ViolationTypeSet | 0)};


        TrustedWebActivityIssueDetailsBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        TrustedWebActivityIssueDetailsBuilder<STATE | ViolationTypeSet>& setViolationType(const String& value)
        {
            static_assert(!(STATE & ViolationTypeSet), "property violationType should not be set yet");
            m_result->setViolationType(value);
            return castState<ViolationTypeSet>();
        }

        TrustedWebActivityIssueDetailsBuilder<STATE>& setHttpStatusCode(int value)
        {
            m_result->setHttpStatusCode(value);
            return *this;
        }

        TrustedWebActivityIssueDetailsBuilder<STATE>& setPackageName(const String& value)
        {
            m_result->setPackageName(value);
            return *this;
        }

        TrustedWebActivityIssueDetailsBuilder<STATE>& setSignature(const String& value)
        {
            m_result->setSignature(value);
            return *this;
        }

        std::unique_ptr<TrustedWebActivityIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class TrustedWebActivityIssueDetails;
        TrustedWebActivityIssueDetailsBuilder() : m_result(new TrustedWebActivityIssueDetails()) { }

        template<int STEP> TrustedWebActivityIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<TrustedWebActivityIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::TrustedWebActivityIssueDetails> m_result;
    };

    static TrustedWebActivityIssueDetailsBuilder<0> create()
    {
        return TrustedWebActivityIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    TrustedWebActivityIssueDetails()
    {
    }

    String m_url;
    String m_violationType;
    Maybe<int> m_httpStatusCode;
    Maybe<String> m_packageName;
    Maybe<String> m_signature;
};


class CORE_EXPORT LowTextContrastIssueDetails : public ::crdtp::ProtocolObject<LowTextContrastIssueDetails> {
public:
    ~LowTextContrastIssueDetails() override { }

    int getViolatingNodeId() { return m_violatingNodeId; }
    void setViolatingNodeId(int value) { m_violatingNodeId = value; }

    String getViolatingNodeSelector() { return m_violatingNodeSelector; }
    void setViolatingNodeSelector(const String& value) { m_violatingNodeSelector = value; }

    double getContrastRatio() { return m_contrastRatio; }
    void setContrastRatio(double value) { m_contrastRatio = value; }

    double getThresholdAA() { return m_thresholdAA; }
    void setThresholdAA(double value) { m_thresholdAA = value; }

    double getThresholdAAA() { return m_thresholdAAA; }
    void setThresholdAAA(double value) { m_thresholdAAA = value; }

    String getFontSize() { return m_fontSize; }
    void setFontSize(const String& value) { m_fontSize = value; }

    String getFontWeight() { return m_fontWeight; }
    void setFontWeight(const String& value) { m_fontWeight = value; }

    template<int STATE>
    class LowTextContrastIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViolatingNodeIdSet = 1 << 1,
            ViolatingNodeSelectorSet = 1 << 2,
            ContrastRatioSet = 1 << 3,
            ThresholdAASet = 1 << 4,
            ThresholdAAASet = 1 << 5,
            FontSizeSet = 1 << 6,
            FontWeightSet = 1 << 7,
            AllFieldsSet = (ViolatingNodeIdSet | ViolatingNodeSelectorSet | ContrastRatioSet | ThresholdAASet | ThresholdAAASet | FontSizeSet | FontWeightSet | 0)};


        LowTextContrastIssueDetailsBuilder<STATE | ViolatingNodeIdSet>& setViolatingNodeId(int value)
        {
            static_assert(!(STATE & ViolatingNodeIdSet), "property violatingNodeId should not be set yet");
            m_result->setViolatingNodeId(value);
            return castState<ViolatingNodeIdSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ViolatingNodeSelectorSet>& setViolatingNodeSelector(const String& value)
        {
            static_assert(!(STATE & ViolatingNodeSelectorSet), "property violatingNodeSelector should not be set yet");
            m_result->setViolatingNodeSelector(value);
            return castState<ViolatingNodeSelectorSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ContrastRatioSet>& setContrastRatio(double value)
        {
            static_assert(!(STATE & ContrastRatioSet), "property contrastRatio should not be set yet");
            m_result->setContrastRatio(value);
            return castState<ContrastRatioSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ThresholdAASet>& setThresholdAA(double value)
        {
            static_assert(!(STATE & ThresholdAASet), "property thresholdAA should not be set yet");
            m_result->setThresholdAA(value);
            return castState<ThresholdAASet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | ThresholdAAASet>& setThresholdAAA(double value)
        {
            static_assert(!(STATE & ThresholdAAASet), "property thresholdAAA should not be set yet");
            m_result->setThresholdAAA(value);
            return castState<ThresholdAAASet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | FontSizeSet>& setFontSize(const String& value)
        {
            static_assert(!(STATE & FontSizeSet), "property fontSize should not be set yet");
            m_result->setFontSize(value);
            return castState<FontSizeSet>();
        }

        LowTextContrastIssueDetailsBuilder<STATE | FontWeightSet>& setFontWeight(const String& value)
        {
            static_assert(!(STATE & FontWeightSet), "property fontWeight should not be set yet");
            m_result->setFontWeight(value);
            return castState<FontWeightSet>();
        }

        std::unique_ptr<LowTextContrastIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LowTextContrastIssueDetails;
        LowTextContrastIssueDetailsBuilder() : m_result(new LowTextContrastIssueDetails()) { }

        template<int STEP> LowTextContrastIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LowTextContrastIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::LowTextContrastIssueDetails> m_result;
    };

    static LowTextContrastIssueDetailsBuilder<0> create()
    {
        return LowTextContrastIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LowTextContrastIssueDetails()
    {
          m_violatingNodeId = 0;
          m_contrastRatio = 0;
          m_thresholdAA = 0;
          m_thresholdAAA = 0;
    }

    int m_violatingNodeId;
    String m_violatingNodeSelector;
    double m_contrastRatio;
    double m_thresholdAA;
    double m_thresholdAAA;
    String m_fontSize;
    String m_fontWeight;
};


class CORE_EXPORT CorsIssueDetails : public ::crdtp::ProtocolObject<CorsIssueDetails> {
public:
    ~CorsIssueDetails() override { }

    protocol::Network::CorsErrorStatus* getCorsErrorStatus() { return m_corsErrorStatus.get(); }
    void setCorsErrorStatus(std::unique_ptr<protocol::Network::CorsErrorStatus> value) { m_corsErrorStatus = std::move(value); }

    bool getIsWarning() { return m_isWarning; }
    void setIsWarning(bool value) { m_isWarning = value; }

    protocol::Audits::AffectedRequest* getRequest() { return m_request.get(); }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool hasLocation() { return m_location.isJust(); }
    protocol::Audits::SourceCodeLocation* getLocation(protocol::Audits::SourceCodeLocation* defaultValue) { return m_location.isJust() ? m_location.fromJust() : defaultValue; }
    void setLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_location = std::move(value); }

    bool hasInitiatorOrigin() { return m_initiatorOrigin.isJust(); }
    String getInitiatorOrigin(const String& defaultValue) { return m_initiatorOrigin.isJust() ? m_initiatorOrigin.fromJust() : defaultValue; }
    void setInitiatorOrigin(const String& value) { m_initiatorOrigin = value; }

    bool hasResourceIPAddressSpace() { return m_resourceIPAddressSpace.isJust(); }
    String getResourceIPAddressSpace(const String& defaultValue) { return m_resourceIPAddressSpace.isJust() ? m_resourceIPAddressSpace.fromJust() : defaultValue; }
    void setResourceIPAddressSpace(const String& value) { m_resourceIPAddressSpace = value; }

    bool hasClientSecurityState() { return m_clientSecurityState.isJust(); }
    protocol::Network::ClientSecurityState* getClientSecurityState(protocol::Network::ClientSecurityState* defaultValue) { return m_clientSecurityState.isJust() ? m_clientSecurityState.fromJust() : defaultValue; }
    void setClientSecurityState(std::unique_ptr<protocol::Network::ClientSecurityState> value) { m_clientSecurityState = std::move(value); }

    template<int STATE>
    class CorsIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CorsErrorStatusSet = 1 << 1,
            IsWarningSet = 1 << 2,
            RequestSet = 1 << 3,
            AllFieldsSet = (CorsErrorStatusSet | IsWarningSet | RequestSet | 0)};


        CorsIssueDetailsBuilder<STATE | CorsErrorStatusSet>& setCorsErrorStatus(std::unique_ptr<protocol::Network::CorsErrorStatus> value)
        {
            static_assert(!(STATE & CorsErrorStatusSet), "property corsErrorStatus should not be set yet");
            m_result->setCorsErrorStatus(std::move(value));
            return castState<CorsErrorStatusSet>();
        }

        CorsIssueDetailsBuilder<STATE | IsWarningSet>& setIsWarning(bool value)
        {
            static_assert(!(STATE & IsWarningSet), "property isWarning should not be set yet");
            m_result->setIsWarning(value);
            return castState<IsWarningSet>();
        }

        CorsIssueDetailsBuilder<STATE | RequestSet>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            static_assert(!(STATE & RequestSet), "property request should not be set yet");
            m_result->setRequest(std::move(value));
            return castState<RequestSet>();
        }

        CorsIssueDetailsBuilder<STATE>& setLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            m_result->setLocation(std::move(value));
            return *this;
        }

        CorsIssueDetailsBuilder<STATE>& setInitiatorOrigin(const String& value)
        {
            m_result->setInitiatorOrigin(value);
            return *this;
        }

        CorsIssueDetailsBuilder<STATE>& setResourceIPAddressSpace(const String& value)
        {
            m_result->setResourceIPAddressSpace(value);
            return *this;
        }

        CorsIssueDetailsBuilder<STATE>& setClientSecurityState(std::unique_ptr<protocol::Network::ClientSecurityState> value)
        {
            m_result->setClientSecurityState(std::move(value));
            return *this;
        }

        std::unique_ptr<CorsIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class CorsIssueDetails;
        CorsIssueDetailsBuilder() : m_result(new CorsIssueDetails()) { }

        template<int STEP> CorsIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<CorsIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::CorsIssueDetails> m_result;
    };

    static CorsIssueDetailsBuilder<0> create()
    {
        return CorsIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    CorsIssueDetails()
    {
          m_isWarning = false;
    }

    std::unique_ptr<protocol::Network::CorsErrorStatus> m_corsErrorStatus;
    bool m_isWarning;
    std::unique_ptr<protocol::Audits::AffectedRequest> m_request;
    Maybe<protocol::Audits::SourceCodeLocation> m_location;
    Maybe<String> m_initiatorOrigin;
    Maybe<String> m_resourceIPAddressSpace;
    Maybe<protocol::Network::ClientSecurityState> m_clientSecurityState;
};


class CORE_EXPORT AttributionReportingIssueDetails : public ::crdtp::ProtocolObject<AttributionReportingIssueDetails> {
public:
    ~AttributionReportingIssueDetails() override { }

    String getViolationType() { return m_violationType; }
    void setViolationType(const String& value) { m_violationType = value; }

    bool hasRequest() { return m_request.isJust(); }
    protocol::Audits::AffectedRequest* getRequest(protocol::Audits::AffectedRequest* defaultValue) { return m_request.isJust() ? m_request.fromJust() : defaultValue; }
    void setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value) { m_request = std::move(value); }

    bool hasViolatingNodeId() { return m_violatingNodeId.isJust(); }
    int getViolatingNodeId(int defaultValue) { return m_violatingNodeId.isJust() ? m_violatingNodeId.fromJust() : defaultValue; }
    void setViolatingNodeId(int value) { m_violatingNodeId = value; }

    bool hasInvalidParameter() { return m_invalidParameter.isJust(); }
    String getInvalidParameter(const String& defaultValue) { return m_invalidParameter.isJust() ? m_invalidParameter.fromJust() : defaultValue; }
    void setInvalidParameter(const String& value) { m_invalidParameter = value; }

    template<int STATE>
    class AttributionReportingIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ViolationTypeSet = 1 << 1,
            AllFieldsSet = (ViolationTypeSet | 0)};


        AttributionReportingIssueDetailsBuilder<STATE | ViolationTypeSet>& setViolationType(const String& value)
        {
            static_assert(!(STATE & ViolationTypeSet), "property violationType should not be set yet");
            m_result->setViolationType(value);
            return castState<ViolationTypeSet>();
        }

        AttributionReportingIssueDetailsBuilder<STATE>& setRequest(std::unique_ptr<protocol::Audits::AffectedRequest> value)
        {
            m_result->setRequest(std::move(value));
            return *this;
        }

        AttributionReportingIssueDetailsBuilder<STATE>& setViolatingNodeId(int value)
        {
            m_result->setViolatingNodeId(value);
            return *this;
        }

        AttributionReportingIssueDetailsBuilder<STATE>& setInvalidParameter(const String& value)
        {
            m_result->setInvalidParameter(value);
            return *this;
        }

        std::unique_ptr<AttributionReportingIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class AttributionReportingIssueDetails;
        AttributionReportingIssueDetailsBuilder() : m_result(new AttributionReportingIssueDetails()) { }

        template<int STEP> AttributionReportingIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<AttributionReportingIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::AttributionReportingIssueDetails> m_result;
    };

    static AttributionReportingIssueDetailsBuilder<0> create()
    {
        return AttributionReportingIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    AttributionReportingIssueDetails()
    {
    }

    String m_violationType;
    Maybe<protocol::Audits::AffectedRequest> m_request;
    Maybe<int> m_violatingNodeId;
    Maybe<String> m_invalidParameter;
};


class CORE_EXPORT QuirksModeIssueDetails : public ::crdtp::ProtocolObject<QuirksModeIssueDetails> {
public:
    ~QuirksModeIssueDetails() override { }

    bool getIsLimitedQuirksMode() { return m_isLimitedQuirksMode; }
    void setIsLimitedQuirksMode(bool value) { m_isLimitedQuirksMode = value; }

    int getDocumentNodeId() { return m_documentNodeId; }
    void setDocumentNodeId(int value) { m_documentNodeId = value; }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    String getFrameId() { return m_frameId; }
    void setFrameId(const String& value) { m_frameId = value; }

    String getLoaderId() { return m_loaderId; }
    void setLoaderId(const String& value) { m_loaderId = value; }

    template<int STATE>
    class QuirksModeIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IsLimitedQuirksModeSet = 1 << 1,
            DocumentNodeIdSet = 1 << 2,
            UrlSet = 1 << 3,
            FrameIdSet = 1 << 4,
            LoaderIdSet = 1 << 5,
            AllFieldsSet = (IsLimitedQuirksModeSet | DocumentNodeIdSet | UrlSet | FrameIdSet | LoaderIdSet | 0)};


        QuirksModeIssueDetailsBuilder<STATE | IsLimitedQuirksModeSet>& setIsLimitedQuirksMode(bool value)
        {
            static_assert(!(STATE & IsLimitedQuirksModeSet), "property isLimitedQuirksMode should not be set yet");
            m_result->setIsLimitedQuirksMode(value);
            return castState<IsLimitedQuirksModeSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | DocumentNodeIdSet>& setDocumentNodeId(int value)
        {
            static_assert(!(STATE & DocumentNodeIdSet), "property documentNodeId should not be set yet");
            m_result->setDocumentNodeId(value);
            return castState<DocumentNodeIdSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | FrameIdSet>& setFrameId(const String& value)
        {
            static_assert(!(STATE & FrameIdSet), "property frameId should not be set yet");
            m_result->setFrameId(value);
            return castState<FrameIdSet>();
        }

        QuirksModeIssueDetailsBuilder<STATE | LoaderIdSet>& setLoaderId(const String& value)
        {
            static_assert(!(STATE & LoaderIdSet), "property loaderId should not be set yet");
            m_result->setLoaderId(value);
            return castState<LoaderIdSet>();
        }

        std::unique_ptr<QuirksModeIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class QuirksModeIssueDetails;
        QuirksModeIssueDetailsBuilder() : m_result(new QuirksModeIssueDetails()) { }

        template<int STEP> QuirksModeIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<QuirksModeIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::QuirksModeIssueDetails> m_result;
    };

    static QuirksModeIssueDetailsBuilder<0> create()
    {
        return QuirksModeIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    QuirksModeIssueDetails()
    {
          m_isLimitedQuirksMode = false;
          m_documentNodeId = 0;
    }

    bool m_isLimitedQuirksMode;
    int m_documentNodeId;
    String m_url;
    String m_frameId;
    String m_loaderId;
};


class CORE_EXPORT NavigatorUserAgentIssueDetails : public ::crdtp::ProtocolObject<NavigatorUserAgentIssueDetails> {
public:
    ~NavigatorUserAgentIssueDetails() override { }

    String getUrl() { return m_url; }
    void setUrl(const String& value) { m_url = value; }

    bool hasLocation() { return m_location.isJust(); }
    protocol::Audits::SourceCodeLocation* getLocation(protocol::Audits::SourceCodeLocation* defaultValue) { return m_location.isJust() ? m_location.fromJust() : defaultValue; }
    void setLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_location = std::move(value); }

    template<int STATE>
    class NavigatorUserAgentIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            UrlSet = 1 << 1,
            AllFieldsSet = (UrlSet | 0)};


        NavigatorUserAgentIssueDetailsBuilder<STATE | UrlSet>& setUrl(const String& value)
        {
            static_assert(!(STATE & UrlSet), "property url should not be set yet");
            m_result->setUrl(value);
            return castState<UrlSet>();
        }

        NavigatorUserAgentIssueDetailsBuilder<STATE>& setLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            m_result->setLocation(std::move(value));
            return *this;
        }

        std::unique_ptr<NavigatorUserAgentIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class NavigatorUserAgentIssueDetails;
        NavigatorUserAgentIssueDetailsBuilder() : m_result(new NavigatorUserAgentIssueDetails()) { }

        template<int STEP> NavigatorUserAgentIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<NavigatorUserAgentIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::NavigatorUserAgentIssueDetails> m_result;
    };

    static NavigatorUserAgentIssueDetailsBuilder<0> create()
    {
        return NavigatorUserAgentIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    NavigatorUserAgentIssueDetails()
    {
    }

    String m_url;
    Maybe<protocol::Audits::SourceCodeLocation> m_location;
};


class CORE_EXPORT GenericIssueDetails : public ::crdtp::ProtocolObject<GenericIssueDetails> {
public:
    ~GenericIssueDetails() override { }

    String getErrorType() { return m_errorType; }
    void setErrorType(const String& value) { m_errorType = value; }

    bool hasFrameId() { return m_frameId.isJust(); }
    String getFrameId(const String& defaultValue) { return m_frameId.isJust() ? m_frameId.fromJust() : defaultValue; }
    void setFrameId(const String& value) { m_frameId = value; }

    template<int STATE>
    class GenericIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ErrorTypeSet = 1 << 1,
            AllFieldsSet = (ErrorTypeSet | 0)};


        GenericIssueDetailsBuilder<STATE | ErrorTypeSet>& setErrorType(const String& value)
        {
            static_assert(!(STATE & ErrorTypeSet), "property errorType should not be set yet");
            m_result->setErrorType(value);
            return castState<ErrorTypeSet>();
        }

        GenericIssueDetailsBuilder<STATE>& setFrameId(const String& value)
        {
            m_result->setFrameId(value);
            return *this;
        }

        std::unique_ptr<GenericIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GenericIssueDetails;
        GenericIssueDetailsBuilder() : m_result(new GenericIssueDetails()) { }

        template<int STEP> GenericIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GenericIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::GenericIssueDetails> m_result;
    };

    static GenericIssueDetailsBuilder<0> create()
    {
        return GenericIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    GenericIssueDetails()
    {
    }

    String m_errorType;
    Maybe<String> m_frameId;
};


class CORE_EXPORT DeprecationIssueDetails : public ::crdtp::ProtocolObject<DeprecationIssueDetails> {
public:
    ~DeprecationIssueDetails() override { }

    bool hasAffectedFrame() { return m_affectedFrame.isJust(); }
    protocol::Audits::AffectedFrame* getAffectedFrame(protocol::Audits::AffectedFrame* defaultValue) { return m_affectedFrame.isJust() ? m_affectedFrame.fromJust() : defaultValue; }
    void setAffectedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value) { m_affectedFrame = std::move(value); }

    protocol::Audits::SourceCodeLocation* getSourceCodeLocation() { return m_sourceCodeLocation.get(); }
    void setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    String getType() { return m_type; }
    void setType(const String& value) { m_type = value; }

    template<int STATE>
    class DeprecationIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SourceCodeLocationSet = 1 << 1,
            TypeSet = 1 << 2,
            AllFieldsSet = (SourceCodeLocationSet | TypeSet | 0)};


        DeprecationIssueDetailsBuilder<STATE>& setAffectedFrame(std::unique_ptr<protocol::Audits::AffectedFrame> value)
        {
            m_result->setAffectedFrame(std::move(value));
            return *this;
        }

        DeprecationIssueDetailsBuilder<STATE | SourceCodeLocationSet>& setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            static_assert(!(STATE & SourceCodeLocationSet), "property sourceCodeLocation should not be set yet");
            m_result->setSourceCodeLocation(std::move(value));
            return castState<SourceCodeLocationSet>();
        }

        DeprecationIssueDetailsBuilder<STATE | TypeSet>& setType(const String& value)
        {
            static_assert(!(STATE & TypeSet), "property type should not be set yet");
            m_result->setType(value);
            return castState<TypeSet>();
        }

        std::unique_ptr<DeprecationIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class DeprecationIssueDetails;
        DeprecationIssueDetailsBuilder() : m_result(new DeprecationIssueDetails()) { }

        template<int STEP> DeprecationIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<DeprecationIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::DeprecationIssueDetails> m_result;
    };

    static DeprecationIssueDetailsBuilder<0> create()
    {
        return DeprecationIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    DeprecationIssueDetails()
    {
    }

    Maybe<protocol::Audits::AffectedFrame> m_affectedFrame;
    std::unique_ptr<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    String m_type;
};


class CORE_EXPORT FederatedAuthRequestIssueDetails : public ::crdtp::ProtocolObject<FederatedAuthRequestIssueDetails> {
public:
    ~FederatedAuthRequestIssueDetails() override { }

    String getFederatedAuthRequestIssueReason() { return m_federatedAuthRequestIssueReason; }
    void setFederatedAuthRequestIssueReason(const String& value) { m_federatedAuthRequestIssueReason = value; }

    template<int STATE>
    class FederatedAuthRequestIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FederatedAuthRequestIssueReasonSet = 1 << 1,
            AllFieldsSet = (FederatedAuthRequestIssueReasonSet | 0)};


        FederatedAuthRequestIssueDetailsBuilder<STATE | FederatedAuthRequestIssueReasonSet>& setFederatedAuthRequestIssueReason(const String& value)
        {
            static_assert(!(STATE & FederatedAuthRequestIssueReasonSet), "property federatedAuthRequestIssueReason should not be set yet");
            m_result->setFederatedAuthRequestIssueReason(value);
            return castState<FederatedAuthRequestIssueReasonSet>();
        }

        std::unique_ptr<FederatedAuthRequestIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FederatedAuthRequestIssueDetails;
        FederatedAuthRequestIssueDetailsBuilder() : m_result(new FederatedAuthRequestIssueDetails()) { }

        template<int STEP> FederatedAuthRequestIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FederatedAuthRequestIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::FederatedAuthRequestIssueDetails> m_result;
    };

    static FederatedAuthRequestIssueDetailsBuilder<0> create()
    {
        return FederatedAuthRequestIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FederatedAuthRequestIssueDetails()
    {
    }

    String m_federatedAuthRequestIssueReason;
};


class CORE_EXPORT ClientHintIssueDetails : public ::crdtp::ProtocolObject<ClientHintIssueDetails> {
public:
    ~ClientHintIssueDetails() override { }

    protocol::Audits::SourceCodeLocation* getSourceCodeLocation() { return m_sourceCodeLocation.get(); }
    void setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value) { m_sourceCodeLocation = std::move(value); }

    String getClientHintIssueReason() { return m_clientHintIssueReason; }
    void setClientHintIssueReason(const String& value) { m_clientHintIssueReason = value; }

    template<int STATE>
    class ClientHintIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            SourceCodeLocationSet = 1 << 1,
            ClientHintIssueReasonSet = 1 << 2,
            AllFieldsSet = (SourceCodeLocationSet | ClientHintIssueReasonSet | 0)};


        ClientHintIssueDetailsBuilder<STATE | SourceCodeLocationSet>& setSourceCodeLocation(std::unique_ptr<protocol::Audits::SourceCodeLocation> value)
        {
            static_assert(!(STATE & SourceCodeLocationSet), "property sourceCodeLocation should not be set yet");
            m_result->setSourceCodeLocation(std::move(value));
            return castState<SourceCodeLocationSet>();
        }

        ClientHintIssueDetailsBuilder<STATE | ClientHintIssueReasonSet>& setClientHintIssueReason(const String& value)
        {
            static_assert(!(STATE & ClientHintIssueReasonSet), "property clientHintIssueReason should not be set yet");
            m_result->setClientHintIssueReason(value);
            return castState<ClientHintIssueReasonSet>();
        }

        std::unique_ptr<ClientHintIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ClientHintIssueDetails;
        ClientHintIssueDetailsBuilder() : m_result(new ClientHintIssueDetails()) { }

        template<int STEP> ClientHintIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ClientHintIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::ClientHintIssueDetails> m_result;
    };

    static ClientHintIssueDetailsBuilder<0> create()
    {
        return ClientHintIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ClientHintIssueDetails()
    {
    }

    std::unique_ptr<protocol::Audits::SourceCodeLocation> m_sourceCodeLocation;
    String m_clientHintIssueReason;
};


class CORE_EXPORT InspectorIssueDetails : public ::crdtp::ProtocolObject<InspectorIssueDetails> {
public:
    ~InspectorIssueDetails() override { }

    bool hasCookieIssueDetails() { return m_cookieIssueDetails.isJust(); }
    protocol::Audits::CookieIssueDetails* getCookieIssueDetails(protocol::Audits::CookieIssueDetails* defaultValue) { return m_cookieIssueDetails.isJust() ? m_cookieIssueDetails.fromJust() : defaultValue; }
    void setCookieIssueDetails(std::unique_ptr<protocol::Audits::CookieIssueDetails> value) { m_cookieIssueDetails = std::move(value); }

    bool hasMixedContentIssueDetails() { return m_mixedContentIssueDetails.isJust(); }
    protocol::Audits::MixedContentIssueDetails* getMixedContentIssueDetails(protocol::Audits::MixedContentIssueDetails* defaultValue) { return m_mixedContentIssueDetails.isJust() ? m_mixedContentIssueDetails.fromJust() : defaultValue; }
    void setMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value) { m_mixedContentIssueDetails = std::move(value); }

    bool hasBlockedByResponseIssueDetails() { return m_blockedByResponseIssueDetails.isJust(); }
    protocol::Audits::BlockedByResponseIssueDetails* getBlockedByResponseIssueDetails(protocol::Audits::BlockedByResponseIssueDetails* defaultValue) { return m_blockedByResponseIssueDetails.isJust() ? m_blockedByResponseIssueDetails.fromJust() : defaultValue; }
    void setBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value) { m_blockedByResponseIssueDetails = std::move(value); }

    bool hasHeavyAdIssueDetails() { return m_heavyAdIssueDetails.isJust(); }
    protocol::Audits::HeavyAdIssueDetails* getHeavyAdIssueDetails(protocol::Audits::HeavyAdIssueDetails* defaultValue) { return m_heavyAdIssueDetails.isJust() ? m_heavyAdIssueDetails.fromJust() : defaultValue; }
    void setHeavyAdIssueDetails(std::unique_ptr<protocol::Audits::HeavyAdIssueDetails> value) { m_heavyAdIssueDetails = std::move(value); }

    bool hasContentSecurityPolicyIssueDetails() { return m_contentSecurityPolicyIssueDetails.isJust(); }
    protocol::Audits::ContentSecurityPolicyIssueDetails* getContentSecurityPolicyIssueDetails(protocol::Audits::ContentSecurityPolicyIssueDetails* defaultValue) { return m_contentSecurityPolicyIssueDetails.isJust() ? m_contentSecurityPolicyIssueDetails.fromJust() : defaultValue; }
    void setContentSecurityPolicyIssueDetails(std::unique_ptr<protocol::Audits::ContentSecurityPolicyIssueDetails> value) { m_contentSecurityPolicyIssueDetails = std::move(value); }

    bool hasSharedArrayBufferIssueDetails() { return m_sharedArrayBufferIssueDetails.isJust(); }
    protocol::Audits::SharedArrayBufferIssueDetails* getSharedArrayBufferIssueDetails(protocol::Audits::SharedArrayBufferIssueDetails* defaultValue) { return m_sharedArrayBufferIssueDetails.isJust() ? m_sharedArrayBufferIssueDetails.fromJust() : defaultValue; }
    void setSharedArrayBufferIssueDetails(std::unique_ptr<protocol::Audits::SharedArrayBufferIssueDetails> value) { m_sharedArrayBufferIssueDetails = std::move(value); }

    bool hasTwaQualityEnforcementDetails() { return m_twaQualityEnforcementDetails.isJust(); }
    protocol::Audits::TrustedWebActivityIssueDetails* getTwaQualityEnforcementDetails(protocol::Audits::TrustedWebActivityIssueDetails* defaultValue) { return m_twaQualityEnforcementDetails.isJust() ? m_twaQualityEnforcementDetails.fromJust() : defaultValue; }
    void setTwaQualityEnforcementDetails(std::unique_ptr<protocol::Audits::TrustedWebActivityIssueDetails> value) { m_twaQualityEnforcementDetails = std::move(value); }

    bool hasLowTextContrastIssueDetails() { return m_lowTextContrastIssueDetails.isJust(); }
    protocol::Audits::LowTextContrastIssueDetails* getLowTextContrastIssueDetails(protocol::Audits::LowTextContrastIssueDetails* defaultValue) { return m_lowTextContrastIssueDetails.isJust() ? m_lowTextContrastIssueDetails.fromJust() : defaultValue; }
    void setLowTextContrastIssueDetails(std::unique_ptr<protocol::Audits::LowTextContrastIssueDetails> value) { m_lowTextContrastIssueDetails = std::move(value); }

    bool hasCorsIssueDetails() { return m_corsIssueDetails.isJust(); }
    protocol::Audits::CorsIssueDetails* getCorsIssueDetails(protocol::Audits::CorsIssueDetails* defaultValue) { return m_corsIssueDetails.isJust() ? m_corsIssueDetails.fromJust() : defaultValue; }
    void setCorsIssueDetails(std::unique_ptr<protocol::Audits::CorsIssueDetails> value) { m_corsIssueDetails = std::move(value); }

    bool hasAttributionReportingIssueDetails() { return m_attributionReportingIssueDetails.isJust(); }
    protocol::Audits::AttributionReportingIssueDetails* getAttributionReportingIssueDetails(protocol::Audits::AttributionReportingIssueDetails* defaultValue) { return m_attributionReportingIssueDetails.isJust() ? m_attributionReportingIssueDetails.fromJust() : defaultValue; }
    void setAttributionReportingIssueDetails(std::unique_ptr<protocol::Audits::AttributionReportingIssueDetails> value) { m_attributionReportingIssueDetails = std::move(value); }

    bool hasQuirksModeIssueDetails() { return m_quirksModeIssueDetails.isJust(); }
    protocol::Audits::QuirksModeIssueDetails* getQuirksModeIssueDetails(protocol::Audits::QuirksModeIssueDetails* defaultValue) { return m_quirksModeIssueDetails.isJust() ? m_quirksModeIssueDetails.fromJust() : defaultValue; }
    void setQuirksModeIssueDetails(std::unique_ptr<protocol::Audits::QuirksModeIssueDetails> value) { m_quirksModeIssueDetails = std::move(value); }

    bool hasNavigatorUserAgentIssueDetails() { return m_navigatorUserAgentIssueDetails.isJust(); }
    protocol::Audits::NavigatorUserAgentIssueDetails* getNavigatorUserAgentIssueDetails(protocol::Audits::NavigatorUserAgentIssueDetails* defaultValue) { return m_navigatorUserAgentIssueDetails.isJust() ? m_navigatorUserAgentIssueDetails.fromJust() : defaultValue; }
    void setNavigatorUserAgentIssueDetails(std::unique_ptr<protocol::Audits::NavigatorUserAgentIssueDetails> value) { m_navigatorUserAgentIssueDetails = std::move(value); }

    bool hasGenericIssueDetails() { return m_genericIssueDetails.isJust(); }
    protocol::Audits::GenericIssueDetails* getGenericIssueDetails(protocol::Audits::GenericIssueDetails* defaultValue) { return m_genericIssueDetails.isJust() ? m_genericIssueDetails.fromJust() : defaultValue; }
    void setGenericIssueDetails(std::unique_ptr<protocol::Audits::GenericIssueDetails> value) { m_genericIssueDetails = std::move(value); }

    bool hasDeprecationIssueDetails() { return m_deprecationIssueDetails.isJust(); }
    protocol::Audits::DeprecationIssueDetails* getDeprecationIssueDetails(protocol::Audits::DeprecationIssueDetails* defaultValue) { return m_deprecationIssueDetails.isJust() ? m_deprecationIssueDetails.fromJust() : defaultValue; }
    void setDeprecationIssueDetails(std::unique_ptr<protocol::Audits::DeprecationIssueDetails> value) { m_deprecationIssueDetails = std::move(value); }

    bool hasClientHintIssueDetails() { return m_clientHintIssueDetails.isJust(); }
    protocol::Audits::ClientHintIssueDetails* getClientHintIssueDetails(protocol::Audits::ClientHintIssueDetails* defaultValue) { return m_clientHintIssueDetails.isJust() ? m_clientHintIssueDetails.fromJust() : defaultValue; }
    void setClientHintIssueDetails(std::unique_ptr<protocol::Audits::ClientHintIssueDetails> value) { m_clientHintIssueDetails = std::move(value); }

    bool hasFederatedAuthRequestIssueDetails() { return m_federatedAuthRequestIssueDetails.isJust(); }
    protocol::Audits::FederatedAuthRequestIssueDetails* getFederatedAuthRequestIssueDetails(protocol::Audits::FederatedAuthRequestIssueDetails* defaultValue) { return m_federatedAuthRequestIssueDetails.isJust() ? m_federatedAuthRequestIssueDetails.fromJust() : defaultValue; }
    void setFederatedAuthRequestIssueDetails(std::unique_ptr<protocol::Audits::FederatedAuthRequestIssueDetails> value) { m_federatedAuthRequestIssueDetails = std::move(value); }

    template<int STATE>
    class InspectorIssueDetailsBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        InspectorIssueDetailsBuilder<STATE>& setCookieIssueDetails(std::unique_ptr<protocol::Audits::CookieIssueDetails> value)
        {
            m_result->setCookieIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setMixedContentIssueDetails(std::unique_ptr<protocol::Audits::MixedContentIssueDetails> value)
        {
            m_result->setMixedContentIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setBlockedByResponseIssueDetails(std::unique_ptr<protocol::Audits::BlockedByResponseIssueDetails> value)
        {
            m_result->setBlockedByResponseIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setHeavyAdIssueDetails(std::unique_ptr<protocol::Audits::HeavyAdIssueDetails> value)
        {
            m_result->setHeavyAdIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setContentSecurityPolicyIssueDetails(std::unique_ptr<protocol::Audits::ContentSecurityPolicyIssueDetails> value)
        {
            m_result->setContentSecurityPolicyIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setSharedArrayBufferIssueDetails(std::unique_ptr<protocol::Audits::SharedArrayBufferIssueDetails> value)
        {
            m_result->setSharedArrayBufferIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setTwaQualityEnforcementDetails(std::unique_ptr<protocol::Audits::TrustedWebActivityIssueDetails> value)
        {
            m_result->setTwaQualityEnforcementDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setLowTextContrastIssueDetails(std::unique_ptr<protocol::Audits::LowTextContrastIssueDetails> value)
        {
            m_result->setLowTextContrastIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setCorsIssueDetails(std::unique_ptr<protocol::Audits::CorsIssueDetails> value)
        {
            m_result->setCorsIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setAttributionReportingIssueDetails(std::unique_ptr<protocol::Audits::AttributionReportingIssueDetails> value)
        {
            m_result->setAttributionReportingIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setQuirksModeIssueDetails(std::unique_ptr<protocol::Audits::QuirksModeIssueDetails> value)
        {
            m_result->setQuirksModeIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setNavigatorUserAgentIssueDetails(std::unique_ptr<protocol::Audits::NavigatorUserAgentIssueDetails> value)
        {
            m_result->setNavigatorUserAgentIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setGenericIssueDetails(std::unique_ptr<protocol::Audits::GenericIssueDetails> value)
        {
            m_result->setGenericIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setDeprecationIssueDetails(std::unique_ptr<protocol::Audits::DeprecationIssueDetails> value)
        {
            m_result->setDeprecationIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setClientHintIssueDetails(std::unique_ptr<protocol::Audits::ClientHintIssueDetails> value)
        {
            m_result->setClientHintIssueDetails(std::move(value));
            return *this;
        }

        InspectorIssueDetailsBuilder<STATE>& setFederatedAuthRequestIssueDetails(std::unique_ptr<protocol::Audits::FederatedAuthRequestIssueDetails> value)
        {
            m_result->setFederatedAuthRequestIssueDetails(std::move(value));
            return *this;
        }

        std::unique_ptr<InspectorIssueDetails> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssueDetails;
        InspectorIssueDetailsBuilder() : m_result(new InspectorIssueDetails()) { }

        template<int STEP> InspectorIssueDetailsBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueDetailsBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_result;
    };

    static InspectorIssueDetailsBuilder<0> create()
    {
        return InspectorIssueDetailsBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InspectorIssueDetails()
    {
    }

    Maybe<protocol::Audits::CookieIssueDetails> m_cookieIssueDetails;
    Maybe<protocol::Audits::MixedContentIssueDetails> m_mixedContentIssueDetails;
    Maybe<protocol::Audits::BlockedByResponseIssueDetails> m_blockedByResponseIssueDetails;
    Maybe<protocol::Audits::HeavyAdIssueDetails> m_heavyAdIssueDetails;
    Maybe<protocol::Audits::ContentSecurityPolicyIssueDetails> m_contentSecurityPolicyIssueDetails;
    Maybe<protocol::Audits::SharedArrayBufferIssueDetails> m_sharedArrayBufferIssueDetails;
    Maybe<protocol::Audits::TrustedWebActivityIssueDetails> m_twaQualityEnforcementDetails;
    Maybe<protocol::Audits::LowTextContrastIssueDetails> m_lowTextContrastIssueDetails;
    Maybe<protocol::Audits::CorsIssueDetails> m_corsIssueDetails;
    Maybe<protocol::Audits::AttributionReportingIssueDetails> m_attributionReportingIssueDetails;
    Maybe<protocol::Audits::QuirksModeIssueDetails> m_quirksModeIssueDetails;
    Maybe<protocol::Audits::NavigatorUserAgentIssueDetails> m_navigatorUserAgentIssueDetails;
    Maybe<protocol::Audits::GenericIssueDetails> m_genericIssueDetails;
    Maybe<protocol::Audits::DeprecationIssueDetails> m_deprecationIssueDetails;
    Maybe<protocol::Audits::ClientHintIssueDetails> m_clientHintIssueDetails;
    Maybe<protocol::Audits::FederatedAuthRequestIssueDetails> m_federatedAuthRequestIssueDetails;
};


class CORE_EXPORT InspectorIssue : public ::crdtp::ProtocolObject<InspectorIssue> {
public:
    ~InspectorIssue() override { }

    String getCode() { return m_code; }
    void setCode(const String& value) { m_code = value; }

    protocol::Audits::InspectorIssueDetails* getDetails() { return m_details.get(); }
    void setDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value) { m_details = std::move(value); }

    bool hasIssueId() { return m_issueId.isJust(); }
    String getIssueId(const String& defaultValue) { return m_issueId.isJust() ? m_issueId.fromJust() : defaultValue; }
    void setIssueId(const String& value) { m_issueId = value; }

    template<int STATE>
    class InspectorIssueBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            CodeSet = 1 << 1,
            DetailsSet = 1 << 2,
            AllFieldsSet = (CodeSet | DetailsSet | 0)};


        InspectorIssueBuilder<STATE | CodeSet>& setCode(const String& value)
        {
            static_assert(!(STATE & CodeSet), "property code should not be set yet");
            m_result->setCode(value);
            return castState<CodeSet>();
        }

        InspectorIssueBuilder<STATE | DetailsSet>& setDetails(std::unique_ptr<protocol::Audits::InspectorIssueDetails> value)
        {
            static_assert(!(STATE & DetailsSet), "property details should not be set yet");
            m_result->setDetails(std::move(value));
            return castState<DetailsSet>();
        }

        InspectorIssueBuilder<STATE>& setIssueId(const String& value)
        {
            m_result->setIssueId(value);
            return *this;
        }

        std::unique_ptr<InspectorIssue> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class InspectorIssue;
        InspectorIssueBuilder() : m_result(new InspectorIssue()) { }

        template<int STEP> InspectorIssueBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<InspectorIssueBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Audits::InspectorIssue> m_result;
    };

    static InspectorIssueBuilder<0> create()
    {
        return InspectorIssueBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    InspectorIssue()
    {
    }

    String m_code;
    std::unique_ptr<protocol::Audits::InspectorIssueDetails> m_details;
    Maybe<String> m_issueId;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse getEncodedResponse(const String& in_requestId, const String& in_encoding, Maybe<double> in_quality, Maybe<bool> in_sizeOnly, Maybe<Binary>* out_body, int* out_originalSize, int* out_encodedSize) = 0;
    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse checkContrast(Maybe<bool> in_reportAAA) = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void issueAdded(std::unique_ptr<protocol::Audits::InspectorIssue> issue);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Audits
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Audits_h)
