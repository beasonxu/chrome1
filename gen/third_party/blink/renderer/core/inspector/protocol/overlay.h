// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Overlay_h
#define blink_protocol_Overlay_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.
#include "third_party/blink/renderer/core/inspector/protocol/dom.h"
#include "third_party/blink/renderer/core/inspector/protocol/page.h"
#include "third_party/blink/renderer/core/inspector/protocol/runtime.h"

namespace blink {
namespace protocol {
namespace Overlay {
class SourceOrderConfig;
class GridHighlightConfig;
class FlexContainerHighlightConfig;
class FlexItemHighlightConfig;
class LineStyle;
class BoxStyle;
using ContrastAlgorithm = String;
class HighlightConfig;
using ColorFormat = String;
class GridNodeHighlightConfig;
class FlexNodeHighlightConfig;
class ScrollSnapContainerHighlightConfig;
class ScrollSnapHighlightConfig;
class HingeConfig;
class ContainerQueryHighlightConfig;
class ContainerQueryContainerHighlightConfig;
class IsolatedElementHighlightConfig;
class IsolationModeHighlightConfig;
using InspectMode = String;

// ------------- Forward and enum declarations.

namespace ContrastAlgorithmEnum {
CORE_EXPORT extern const char Aa[];
CORE_EXPORT extern const char Aaa[];
CORE_EXPORT extern const char Apca[];
} // namespace ContrastAlgorithmEnum

namespace ColorFormatEnum {
CORE_EXPORT extern const char Rgb[];
CORE_EXPORT extern const char Hsl[];
CORE_EXPORT extern const char Hwb[];
CORE_EXPORT extern const char Hex[];
} // namespace ColorFormatEnum

namespace InspectModeEnum {
CORE_EXPORT extern const char SearchForNode[];
CORE_EXPORT extern const char SearchForUAShadowDOM[];
CORE_EXPORT extern const char CaptureAreaScreenshot[];
CORE_EXPORT extern const char ShowDistances[];
CORE_EXPORT extern const char None[];
} // namespace InspectModeEnum

// ------------- Type and builder declarations.

class CORE_EXPORT SourceOrderConfig : public ::crdtp::ProtocolObject<SourceOrderConfig> {
public:
    ~SourceOrderConfig() override { }

    protocol::DOM::RGBA* getParentOutlineColor() { return m_parentOutlineColor.get(); }
    void setParentOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_parentOutlineColor = std::move(value); }

    protocol::DOM::RGBA* getChildOutlineColor() { return m_childOutlineColor.get(); }
    void setChildOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_childOutlineColor = std::move(value); }

    template<int STATE>
    class SourceOrderConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ParentOutlineColorSet = 1 << 1,
            ChildOutlineColorSet = 1 << 2,
            AllFieldsSet = (ParentOutlineColorSet | ChildOutlineColorSet | 0)};


        SourceOrderConfigBuilder<STATE | ParentOutlineColorSet>& setParentOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            static_assert(!(STATE & ParentOutlineColorSet), "property parentOutlineColor should not be set yet");
            m_result->setParentOutlineColor(std::move(value));
            return castState<ParentOutlineColorSet>();
        }

        SourceOrderConfigBuilder<STATE | ChildOutlineColorSet>& setChildOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            static_assert(!(STATE & ChildOutlineColorSet), "property childOutlineColor should not be set yet");
            m_result->setChildOutlineColor(std::move(value));
            return castState<ChildOutlineColorSet>();
        }

        std::unique_ptr<SourceOrderConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class SourceOrderConfig;
        SourceOrderConfigBuilder() : m_result(new SourceOrderConfig()) { }

        template<int STEP> SourceOrderConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<SourceOrderConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::SourceOrderConfig> m_result;
    };

    static SourceOrderConfigBuilder<0> create()
    {
        return SourceOrderConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    SourceOrderConfig()
    {
    }

    std::unique_ptr<protocol::DOM::RGBA> m_parentOutlineColor;
    std::unique_ptr<protocol::DOM::RGBA> m_childOutlineColor;
};


class CORE_EXPORT GridHighlightConfig : public ::crdtp::ProtocolObject<GridHighlightConfig> {
public:
    ~GridHighlightConfig() override { }

    bool hasShowGridExtensionLines() { return m_showGridExtensionLines.isJust(); }
    bool getShowGridExtensionLines(bool defaultValue) { return m_showGridExtensionLines.isJust() ? m_showGridExtensionLines.fromJust() : defaultValue; }
    void setShowGridExtensionLines(bool value) { m_showGridExtensionLines = value; }

    bool hasShowPositiveLineNumbers() { return m_showPositiveLineNumbers.isJust(); }
    bool getShowPositiveLineNumbers(bool defaultValue) { return m_showPositiveLineNumbers.isJust() ? m_showPositiveLineNumbers.fromJust() : defaultValue; }
    void setShowPositiveLineNumbers(bool value) { m_showPositiveLineNumbers = value; }

    bool hasShowNegativeLineNumbers() { return m_showNegativeLineNumbers.isJust(); }
    bool getShowNegativeLineNumbers(bool defaultValue) { return m_showNegativeLineNumbers.isJust() ? m_showNegativeLineNumbers.fromJust() : defaultValue; }
    void setShowNegativeLineNumbers(bool value) { m_showNegativeLineNumbers = value; }

    bool hasShowAreaNames() { return m_showAreaNames.isJust(); }
    bool getShowAreaNames(bool defaultValue) { return m_showAreaNames.isJust() ? m_showAreaNames.fromJust() : defaultValue; }
    void setShowAreaNames(bool value) { m_showAreaNames = value; }

    bool hasShowLineNames() { return m_showLineNames.isJust(); }
    bool getShowLineNames(bool defaultValue) { return m_showLineNames.isJust() ? m_showLineNames.fromJust() : defaultValue; }
    void setShowLineNames(bool value) { m_showLineNames = value; }

    bool hasShowTrackSizes() { return m_showTrackSizes.isJust(); }
    bool getShowTrackSizes(bool defaultValue) { return m_showTrackSizes.isJust() ? m_showTrackSizes.fromJust() : defaultValue; }
    void setShowTrackSizes(bool value) { m_showTrackSizes = value; }

    bool hasGridBorderColor() { return m_gridBorderColor.isJust(); }
    protocol::DOM::RGBA* getGridBorderColor(protocol::DOM::RGBA* defaultValue) { return m_gridBorderColor.isJust() ? m_gridBorderColor.fromJust() : defaultValue; }
    void setGridBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_gridBorderColor = std::move(value); }

    bool hasCellBorderColor() { return m_cellBorderColor.isJust(); }
    protocol::DOM::RGBA* getCellBorderColor(protocol::DOM::RGBA* defaultValue) { return m_cellBorderColor.isJust() ? m_cellBorderColor.fromJust() : defaultValue; }
    void setCellBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_cellBorderColor = std::move(value); }

    bool hasRowLineColor() { return m_rowLineColor.isJust(); }
    protocol::DOM::RGBA* getRowLineColor(protocol::DOM::RGBA* defaultValue) { return m_rowLineColor.isJust() ? m_rowLineColor.fromJust() : defaultValue; }
    void setRowLineColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_rowLineColor = std::move(value); }

    bool hasColumnLineColor() { return m_columnLineColor.isJust(); }
    protocol::DOM::RGBA* getColumnLineColor(protocol::DOM::RGBA* defaultValue) { return m_columnLineColor.isJust() ? m_columnLineColor.fromJust() : defaultValue; }
    void setColumnLineColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_columnLineColor = std::move(value); }

    bool hasGridBorderDash() { return m_gridBorderDash.isJust(); }
    bool getGridBorderDash(bool defaultValue) { return m_gridBorderDash.isJust() ? m_gridBorderDash.fromJust() : defaultValue; }
    void setGridBorderDash(bool value) { m_gridBorderDash = value; }

    bool hasCellBorderDash() { return m_cellBorderDash.isJust(); }
    bool getCellBorderDash(bool defaultValue) { return m_cellBorderDash.isJust() ? m_cellBorderDash.fromJust() : defaultValue; }
    void setCellBorderDash(bool value) { m_cellBorderDash = value; }

    bool hasRowLineDash() { return m_rowLineDash.isJust(); }
    bool getRowLineDash(bool defaultValue) { return m_rowLineDash.isJust() ? m_rowLineDash.fromJust() : defaultValue; }
    void setRowLineDash(bool value) { m_rowLineDash = value; }

    bool hasColumnLineDash() { return m_columnLineDash.isJust(); }
    bool getColumnLineDash(bool defaultValue) { return m_columnLineDash.isJust() ? m_columnLineDash.fromJust() : defaultValue; }
    void setColumnLineDash(bool value) { m_columnLineDash = value; }

    bool hasRowGapColor() { return m_rowGapColor.isJust(); }
    protocol::DOM::RGBA* getRowGapColor(protocol::DOM::RGBA* defaultValue) { return m_rowGapColor.isJust() ? m_rowGapColor.fromJust() : defaultValue; }
    void setRowGapColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_rowGapColor = std::move(value); }

    bool hasRowHatchColor() { return m_rowHatchColor.isJust(); }
    protocol::DOM::RGBA* getRowHatchColor(protocol::DOM::RGBA* defaultValue) { return m_rowHatchColor.isJust() ? m_rowHatchColor.fromJust() : defaultValue; }
    void setRowHatchColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_rowHatchColor = std::move(value); }

    bool hasColumnGapColor() { return m_columnGapColor.isJust(); }
    protocol::DOM::RGBA* getColumnGapColor(protocol::DOM::RGBA* defaultValue) { return m_columnGapColor.isJust() ? m_columnGapColor.fromJust() : defaultValue; }
    void setColumnGapColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_columnGapColor = std::move(value); }

    bool hasColumnHatchColor() { return m_columnHatchColor.isJust(); }
    protocol::DOM::RGBA* getColumnHatchColor(protocol::DOM::RGBA* defaultValue) { return m_columnHatchColor.isJust() ? m_columnHatchColor.fromJust() : defaultValue; }
    void setColumnHatchColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_columnHatchColor = std::move(value); }

    bool hasAreaBorderColor() { return m_areaBorderColor.isJust(); }
    protocol::DOM::RGBA* getAreaBorderColor(protocol::DOM::RGBA* defaultValue) { return m_areaBorderColor.isJust() ? m_areaBorderColor.fromJust() : defaultValue; }
    void setAreaBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_areaBorderColor = std::move(value); }

    bool hasGridBackgroundColor() { return m_gridBackgroundColor.isJust(); }
    protocol::DOM::RGBA* getGridBackgroundColor(protocol::DOM::RGBA* defaultValue) { return m_gridBackgroundColor.isJust() ? m_gridBackgroundColor.fromJust() : defaultValue; }
    void setGridBackgroundColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_gridBackgroundColor = std::move(value); }

    template<int STATE>
    class GridHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        GridHighlightConfigBuilder<STATE>& setShowGridExtensionLines(bool value)
        {
            m_result->setShowGridExtensionLines(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowPositiveLineNumbers(bool value)
        {
            m_result->setShowPositiveLineNumbers(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowNegativeLineNumbers(bool value)
        {
            m_result->setShowNegativeLineNumbers(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowAreaNames(bool value)
        {
            m_result->setShowAreaNames(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowLineNames(bool value)
        {
            m_result->setShowLineNames(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setShowTrackSizes(bool value)
        {
            m_result->setShowTrackSizes(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setGridBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setCellBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setCellBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowLineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowLineColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnLineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnLineColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBorderDash(bool value)
        {
            m_result->setGridBorderDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setCellBorderDash(bool value)
        {
            m_result->setCellBorderDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowLineDash(bool value)
        {
            m_result->setRowLineDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnLineDash(bool value)
        {
            m_result->setColumnLineDash(value);
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowGapColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setRowHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setRowHatchColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnGapColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnGapColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setColumnHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColumnHatchColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setAreaBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setAreaBorderColor(std::move(value));
            return *this;
        }

        GridHighlightConfigBuilder<STATE>& setGridBackgroundColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setGridBackgroundColor(std::move(value));
            return *this;
        }

        std::unique_ptr<GridHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GridHighlightConfig;
        GridHighlightConfigBuilder() : m_result(new GridHighlightConfig()) { }

        template<int STEP> GridHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GridHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::GridHighlightConfig> m_result;
    };

    static GridHighlightConfigBuilder<0> create()
    {
        return GridHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    GridHighlightConfig()
    {
    }

    Maybe<bool> m_showGridExtensionLines;
    Maybe<bool> m_showPositiveLineNumbers;
    Maybe<bool> m_showNegativeLineNumbers;
    Maybe<bool> m_showAreaNames;
    Maybe<bool> m_showLineNames;
    Maybe<bool> m_showTrackSizes;
    Maybe<protocol::DOM::RGBA> m_gridBorderColor;
    Maybe<protocol::DOM::RGBA> m_cellBorderColor;
    Maybe<protocol::DOM::RGBA> m_rowLineColor;
    Maybe<protocol::DOM::RGBA> m_columnLineColor;
    Maybe<bool> m_gridBorderDash;
    Maybe<bool> m_cellBorderDash;
    Maybe<bool> m_rowLineDash;
    Maybe<bool> m_columnLineDash;
    Maybe<protocol::DOM::RGBA> m_rowGapColor;
    Maybe<protocol::DOM::RGBA> m_rowHatchColor;
    Maybe<protocol::DOM::RGBA> m_columnGapColor;
    Maybe<protocol::DOM::RGBA> m_columnHatchColor;
    Maybe<protocol::DOM::RGBA> m_areaBorderColor;
    Maybe<protocol::DOM::RGBA> m_gridBackgroundColor;
};


class CORE_EXPORT FlexContainerHighlightConfig : public ::crdtp::ProtocolObject<FlexContainerHighlightConfig> {
public:
    ~FlexContainerHighlightConfig() override { }

    bool hasContainerBorder() { return m_containerBorder.isJust(); }
    protocol::Overlay::LineStyle* getContainerBorder(protocol::Overlay::LineStyle* defaultValue) { return m_containerBorder.isJust() ? m_containerBorder.fromJust() : defaultValue; }
    void setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_containerBorder = std::move(value); }

    bool hasLineSeparator() { return m_lineSeparator.isJust(); }
    protocol::Overlay::LineStyle* getLineSeparator(protocol::Overlay::LineStyle* defaultValue) { return m_lineSeparator.isJust() ? m_lineSeparator.fromJust() : defaultValue; }
    void setLineSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_lineSeparator = std::move(value); }

    bool hasItemSeparator() { return m_itemSeparator.isJust(); }
    protocol::Overlay::LineStyle* getItemSeparator(protocol::Overlay::LineStyle* defaultValue) { return m_itemSeparator.isJust() ? m_itemSeparator.fromJust() : defaultValue; }
    void setItemSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_itemSeparator = std::move(value); }

    bool hasMainDistributedSpace() { return m_mainDistributedSpace.isJust(); }
    protocol::Overlay::BoxStyle* getMainDistributedSpace(protocol::Overlay::BoxStyle* defaultValue) { return m_mainDistributedSpace.isJust() ? m_mainDistributedSpace.fromJust() : defaultValue; }
    void setMainDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value) { m_mainDistributedSpace = std::move(value); }

    bool hasCrossDistributedSpace() { return m_crossDistributedSpace.isJust(); }
    protocol::Overlay::BoxStyle* getCrossDistributedSpace(protocol::Overlay::BoxStyle* defaultValue) { return m_crossDistributedSpace.isJust() ? m_crossDistributedSpace.fromJust() : defaultValue; }
    void setCrossDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value) { m_crossDistributedSpace = std::move(value); }

    bool hasRowGapSpace() { return m_rowGapSpace.isJust(); }
    protocol::Overlay::BoxStyle* getRowGapSpace(protocol::Overlay::BoxStyle* defaultValue) { return m_rowGapSpace.isJust() ? m_rowGapSpace.fromJust() : defaultValue; }
    void setRowGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value) { m_rowGapSpace = std::move(value); }

    bool hasColumnGapSpace() { return m_columnGapSpace.isJust(); }
    protocol::Overlay::BoxStyle* getColumnGapSpace(protocol::Overlay::BoxStyle* defaultValue) { return m_columnGapSpace.isJust() ? m_columnGapSpace.fromJust() : defaultValue; }
    void setColumnGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value) { m_columnGapSpace = std::move(value); }

    bool hasCrossAlignment() { return m_crossAlignment.isJust(); }
    protocol::Overlay::LineStyle* getCrossAlignment(protocol::Overlay::LineStyle* defaultValue) { return m_crossAlignment.isJust() ? m_crossAlignment.fromJust() : defaultValue; }
    void setCrossAlignment(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_crossAlignment = std::move(value); }

    template<int STATE>
    class FlexContainerHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        FlexContainerHighlightConfigBuilder<STATE>& setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setContainerBorder(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setLineSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setLineSeparator(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setItemSeparator(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setItemSeparator(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setMainDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setMainDistributedSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setCrossDistributedSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setCrossDistributedSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setRowGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setRowGapSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setColumnGapSpace(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setColumnGapSpace(std::move(value));
            return *this;
        }

        FlexContainerHighlightConfigBuilder<STATE>& setCrossAlignment(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setCrossAlignment(std::move(value));
            return *this;
        }

        std::unique_ptr<FlexContainerHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FlexContainerHighlightConfig;
        FlexContainerHighlightConfigBuilder() : m_result(new FlexContainerHighlightConfig()) { }

        template<int STEP> FlexContainerHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FlexContainerHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> m_result;
    };

    static FlexContainerHighlightConfigBuilder<0> create()
    {
        return FlexContainerHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FlexContainerHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::LineStyle> m_containerBorder;
    Maybe<protocol::Overlay::LineStyle> m_lineSeparator;
    Maybe<protocol::Overlay::LineStyle> m_itemSeparator;
    Maybe<protocol::Overlay::BoxStyle> m_mainDistributedSpace;
    Maybe<protocol::Overlay::BoxStyle> m_crossDistributedSpace;
    Maybe<protocol::Overlay::BoxStyle> m_rowGapSpace;
    Maybe<protocol::Overlay::BoxStyle> m_columnGapSpace;
    Maybe<protocol::Overlay::LineStyle> m_crossAlignment;
};


class CORE_EXPORT FlexItemHighlightConfig : public ::crdtp::ProtocolObject<FlexItemHighlightConfig> {
public:
    ~FlexItemHighlightConfig() override { }

    bool hasBaseSizeBox() { return m_baseSizeBox.isJust(); }
    protocol::Overlay::BoxStyle* getBaseSizeBox(protocol::Overlay::BoxStyle* defaultValue) { return m_baseSizeBox.isJust() ? m_baseSizeBox.fromJust() : defaultValue; }
    void setBaseSizeBox(std::unique_ptr<protocol::Overlay::BoxStyle> value) { m_baseSizeBox = std::move(value); }

    bool hasBaseSizeBorder() { return m_baseSizeBorder.isJust(); }
    protocol::Overlay::LineStyle* getBaseSizeBorder(protocol::Overlay::LineStyle* defaultValue) { return m_baseSizeBorder.isJust() ? m_baseSizeBorder.fromJust() : defaultValue; }
    void setBaseSizeBorder(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_baseSizeBorder = std::move(value); }

    bool hasFlexibilityArrow() { return m_flexibilityArrow.isJust(); }
    protocol::Overlay::LineStyle* getFlexibilityArrow(protocol::Overlay::LineStyle* defaultValue) { return m_flexibilityArrow.isJust() ? m_flexibilityArrow.fromJust() : defaultValue; }
    void setFlexibilityArrow(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_flexibilityArrow = std::move(value); }

    template<int STATE>
    class FlexItemHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        FlexItemHighlightConfigBuilder<STATE>& setBaseSizeBox(std::unique_ptr<protocol::Overlay::BoxStyle> value)
        {
            m_result->setBaseSizeBox(std::move(value));
            return *this;
        }

        FlexItemHighlightConfigBuilder<STATE>& setBaseSizeBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setBaseSizeBorder(std::move(value));
            return *this;
        }

        FlexItemHighlightConfigBuilder<STATE>& setFlexibilityArrow(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setFlexibilityArrow(std::move(value));
            return *this;
        }

        std::unique_ptr<FlexItemHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FlexItemHighlightConfig;
        FlexItemHighlightConfigBuilder() : m_result(new FlexItemHighlightConfig()) { }

        template<int STEP> FlexItemHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FlexItemHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::FlexItemHighlightConfig> m_result;
    };

    static FlexItemHighlightConfigBuilder<0> create()
    {
        return FlexItemHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FlexItemHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::BoxStyle> m_baseSizeBox;
    Maybe<protocol::Overlay::LineStyle> m_baseSizeBorder;
    Maybe<protocol::Overlay::LineStyle> m_flexibilityArrow;
};


class CORE_EXPORT LineStyle : public ::crdtp::ProtocolObject<LineStyle> {
public:
    ~LineStyle() override { }

    bool hasColor() { return m_color.isJust(); }
    protocol::DOM::RGBA* getColor(protocol::DOM::RGBA* defaultValue) { return m_color.isJust() ? m_color.fromJust() : defaultValue; }
    void setColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_color = std::move(value); }

    struct CORE_EXPORT PatternEnum {
        static const char* Dashed;
        static const char* Dotted;
    }; // PatternEnum

    bool hasPattern() { return m_pattern.isJust(); }
    String getPattern(const String& defaultValue) { return m_pattern.isJust() ? m_pattern.fromJust() : defaultValue; }
    void setPattern(const String& value) { m_pattern = value; }

    template<int STATE>
    class LineStyleBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        LineStyleBuilder<STATE>& setColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setColor(std::move(value));
            return *this;
        }

        LineStyleBuilder<STATE>& setPattern(const String& value)
        {
            m_result->setPattern(value);
            return *this;
        }

        std::unique_ptr<LineStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class LineStyle;
        LineStyleBuilder() : m_result(new LineStyle()) { }

        template<int STEP> LineStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<LineStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::LineStyle> m_result;
    };

    static LineStyleBuilder<0> create()
    {
        return LineStyleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    LineStyle()
    {
    }

    Maybe<protocol::DOM::RGBA> m_color;
    Maybe<String> m_pattern;
};


class CORE_EXPORT BoxStyle : public ::crdtp::ProtocolObject<BoxStyle> {
public:
    ~BoxStyle() override { }

    bool hasFillColor() { return m_fillColor.isJust(); }
    protocol::DOM::RGBA* getFillColor(protocol::DOM::RGBA* defaultValue) { return m_fillColor.isJust() ? m_fillColor.fromJust() : defaultValue; }
    void setFillColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_fillColor = std::move(value); }

    bool hasHatchColor() { return m_hatchColor.isJust(); }
    protocol::DOM::RGBA* getHatchColor(protocol::DOM::RGBA* defaultValue) { return m_hatchColor.isJust() ? m_hatchColor.fromJust() : defaultValue; }
    void setHatchColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_hatchColor = std::move(value); }

    template<int STATE>
    class BoxStyleBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        BoxStyleBuilder<STATE>& setFillColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setFillColor(std::move(value));
            return *this;
        }

        BoxStyleBuilder<STATE>& setHatchColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setHatchColor(std::move(value));
            return *this;
        }

        std::unique_ptr<BoxStyle> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class BoxStyle;
        BoxStyleBuilder() : m_result(new BoxStyle()) { }

        template<int STEP> BoxStyleBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<BoxStyleBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::BoxStyle> m_result;
    };

    static BoxStyleBuilder<0> create()
    {
        return BoxStyleBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    BoxStyle()
    {
    }

    Maybe<protocol::DOM::RGBA> m_fillColor;
    Maybe<protocol::DOM::RGBA> m_hatchColor;
};


class CORE_EXPORT HighlightConfig : public ::crdtp::ProtocolObject<HighlightConfig> {
public:
    ~HighlightConfig() override { }

    bool hasShowInfo() { return m_showInfo.isJust(); }
    bool getShowInfo(bool defaultValue) { return m_showInfo.isJust() ? m_showInfo.fromJust() : defaultValue; }
    void setShowInfo(bool value) { m_showInfo = value; }

    bool hasShowStyles() { return m_showStyles.isJust(); }
    bool getShowStyles(bool defaultValue) { return m_showStyles.isJust() ? m_showStyles.fromJust() : defaultValue; }
    void setShowStyles(bool value) { m_showStyles = value; }

    bool hasShowRulers() { return m_showRulers.isJust(); }
    bool getShowRulers(bool defaultValue) { return m_showRulers.isJust() ? m_showRulers.fromJust() : defaultValue; }
    void setShowRulers(bool value) { m_showRulers = value; }

    bool hasShowAccessibilityInfo() { return m_showAccessibilityInfo.isJust(); }
    bool getShowAccessibilityInfo(bool defaultValue) { return m_showAccessibilityInfo.isJust() ? m_showAccessibilityInfo.fromJust() : defaultValue; }
    void setShowAccessibilityInfo(bool value) { m_showAccessibilityInfo = value; }

    bool hasShowExtensionLines() { return m_showExtensionLines.isJust(); }
    bool getShowExtensionLines(bool defaultValue) { return m_showExtensionLines.isJust() ? m_showExtensionLines.fromJust() : defaultValue; }
    void setShowExtensionLines(bool value) { m_showExtensionLines = value; }

    bool hasContentColor() { return m_contentColor.isJust(); }
    protocol::DOM::RGBA* getContentColor(protocol::DOM::RGBA* defaultValue) { return m_contentColor.isJust() ? m_contentColor.fromJust() : defaultValue; }
    void setContentColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_contentColor = std::move(value); }

    bool hasPaddingColor() { return m_paddingColor.isJust(); }
    protocol::DOM::RGBA* getPaddingColor(protocol::DOM::RGBA* defaultValue) { return m_paddingColor.isJust() ? m_paddingColor.fromJust() : defaultValue; }
    void setPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_paddingColor = std::move(value); }

    bool hasBorderColor() { return m_borderColor.isJust(); }
    protocol::DOM::RGBA* getBorderColor(protocol::DOM::RGBA* defaultValue) { return m_borderColor.isJust() ? m_borderColor.fromJust() : defaultValue; }
    void setBorderColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_borderColor = std::move(value); }

    bool hasMarginColor() { return m_marginColor.isJust(); }
    protocol::DOM::RGBA* getMarginColor(protocol::DOM::RGBA* defaultValue) { return m_marginColor.isJust() ? m_marginColor.fromJust() : defaultValue; }
    void setMarginColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_marginColor = std::move(value); }

    bool hasEventTargetColor() { return m_eventTargetColor.isJust(); }
    protocol::DOM::RGBA* getEventTargetColor(protocol::DOM::RGBA* defaultValue) { return m_eventTargetColor.isJust() ? m_eventTargetColor.fromJust() : defaultValue; }
    void setEventTargetColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_eventTargetColor = std::move(value); }

    bool hasShapeColor() { return m_shapeColor.isJust(); }
    protocol::DOM::RGBA* getShapeColor(protocol::DOM::RGBA* defaultValue) { return m_shapeColor.isJust() ? m_shapeColor.fromJust() : defaultValue; }
    void setShapeColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_shapeColor = std::move(value); }

    bool hasShapeMarginColor() { return m_shapeMarginColor.isJust(); }
    protocol::DOM::RGBA* getShapeMarginColor(protocol::DOM::RGBA* defaultValue) { return m_shapeMarginColor.isJust() ? m_shapeMarginColor.fromJust() : defaultValue; }
    void setShapeMarginColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_shapeMarginColor = std::move(value); }

    bool hasCssGridColor() { return m_cssGridColor.isJust(); }
    protocol::DOM::RGBA* getCssGridColor(protocol::DOM::RGBA* defaultValue) { return m_cssGridColor.isJust() ? m_cssGridColor.fromJust() : defaultValue; }
    void setCssGridColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_cssGridColor = std::move(value); }

    bool hasColorFormat() { return m_colorFormat.isJust(); }
    String getColorFormat(const String& defaultValue) { return m_colorFormat.isJust() ? m_colorFormat.fromJust() : defaultValue; }
    void setColorFormat(const String& value) { m_colorFormat = value; }

    bool hasGridHighlightConfig() { return m_gridHighlightConfig.isJust(); }
    protocol::Overlay::GridHighlightConfig* getGridHighlightConfig(protocol::Overlay::GridHighlightConfig* defaultValue) { return m_gridHighlightConfig.isJust() ? m_gridHighlightConfig.fromJust() : defaultValue; }
    void setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value) { m_gridHighlightConfig = std::move(value); }

    bool hasFlexContainerHighlightConfig() { return m_flexContainerHighlightConfig.isJust(); }
    protocol::Overlay::FlexContainerHighlightConfig* getFlexContainerHighlightConfig(protocol::Overlay::FlexContainerHighlightConfig* defaultValue) { return m_flexContainerHighlightConfig.isJust() ? m_flexContainerHighlightConfig.fromJust() : defaultValue; }
    void setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value) { m_flexContainerHighlightConfig = std::move(value); }

    bool hasFlexItemHighlightConfig() { return m_flexItemHighlightConfig.isJust(); }
    protocol::Overlay::FlexItemHighlightConfig* getFlexItemHighlightConfig(protocol::Overlay::FlexItemHighlightConfig* defaultValue) { return m_flexItemHighlightConfig.isJust() ? m_flexItemHighlightConfig.fromJust() : defaultValue; }
    void setFlexItemHighlightConfig(std::unique_ptr<protocol::Overlay::FlexItemHighlightConfig> value) { m_flexItemHighlightConfig = std::move(value); }

    bool hasContrastAlgorithm() { return m_contrastAlgorithm.isJust(); }
    String getContrastAlgorithm(const String& defaultValue) { return m_contrastAlgorithm.isJust() ? m_contrastAlgorithm.fromJust() : defaultValue; }
    void setContrastAlgorithm(const String& value) { m_contrastAlgorithm = value; }

    bool hasContainerQueryContainerHighlightConfig() { return m_containerQueryContainerHighlightConfig.isJust(); }
    protocol::Overlay::ContainerQueryContainerHighlightConfig* getContainerQueryContainerHighlightConfig(protocol::Overlay::ContainerQueryContainerHighlightConfig* defaultValue) { return m_containerQueryContainerHighlightConfig.isJust() ? m_containerQueryContainerHighlightConfig.fromJust() : defaultValue; }
    void setContainerQueryContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value) { m_containerQueryContainerHighlightConfig = std::move(value); }

    template<int STATE>
    class HighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        HighlightConfigBuilder<STATE>& setShowInfo(bool value)
        {
            m_result->setShowInfo(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowStyles(bool value)
        {
            m_result->setShowStyles(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowRulers(bool value)
        {
            m_result->setShowRulers(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowAccessibilityInfo(bool value)
        {
            m_result->setShowAccessibilityInfo(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShowExtensionLines(bool value)
        {
            m_result->setShowExtensionLines(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setContentColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setPaddingColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setBorderColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setBorderColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setMarginColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setEventTargetColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setEventTargetColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShapeColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setShapeColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setShapeMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setShapeMarginColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setCssGridColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setCssGridColor(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setColorFormat(const String& value)
        {
            m_result->setColorFormat(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
        {
            m_result->setGridHighlightConfig(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value)
        {
            m_result->setFlexContainerHighlightConfig(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setFlexItemHighlightConfig(std::unique_ptr<protocol::Overlay::FlexItemHighlightConfig> value)
        {
            m_result->setFlexItemHighlightConfig(std::move(value));
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContrastAlgorithm(const String& value)
        {
            m_result->setContrastAlgorithm(value);
            return *this;
        }

        HighlightConfigBuilder<STATE>& setContainerQueryContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value)
        {
            m_result->setContainerQueryContainerHighlightConfig(std::move(value));
            return *this;
        }

        std::unique_ptr<HighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HighlightConfig;
        HighlightConfigBuilder() : m_result(new HighlightConfig()) { }

        template<int STEP> HighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::HighlightConfig> m_result;
    };

    static HighlightConfigBuilder<0> create()
    {
        return HighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    HighlightConfig()
    {
    }

    Maybe<bool> m_showInfo;
    Maybe<bool> m_showStyles;
    Maybe<bool> m_showRulers;
    Maybe<bool> m_showAccessibilityInfo;
    Maybe<bool> m_showExtensionLines;
    Maybe<protocol::DOM::RGBA> m_contentColor;
    Maybe<protocol::DOM::RGBA> m_paddingColor;
    Maybe<protocol::DOM::RGBA> m_borderColor;
    Maybe<protocol::DOM::RGBA> m_marginColor;
    Maybe<protocol::DOM::RGBA> m_eventTargetColor;
    Maybe<protocol::DOM::RGBA> m_shapeColor;
    Maybe<protocol::DOM::RGBA> m_shapeMarginColor;
    Maybe<protocol::DOM::RGBA> m_cssGridColor;
    Maybe<String> m_colorFormat;
    Maybe<protocol::Overlay::GridHighlightConfig> m_gridHighlightConfig;
    Maybe<protocol::Overlay::FlexContainerHighlightConfig> m_flexContainerHighlightConfig;
    Maybe<protocol::Overlay::FlexItemHighlightConfig> m_flexItemHighlightConfig;
    Maybe<String> m_contrastAlgorithm;
    Maybe<protocol::Overlay::ContainerQueryContainerHighlightConfig> m_containerQueryContainerHighlightConfig;
};


class CORE_EXPORT GridNodeHighlightConfig : public ::crdtp::ProtocolObject<GridNodeHighlightConfig> {
public:
    ~GridNodeHighlightConfig() override { }

    protocol::Overlay::GridHighlightConfig* getGridHighlightConfig() { return m_gridHighlightConfig.get(); }
    void setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value) { m_gridHighlightConfig = std::move(value); }

    int getNodeId() { return m_nodeId; }
    void setNodeId(int value) { m_nodeId = value; }

    template<int STATE>
    class GridNodeHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            GridHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (GridHighlightConfigSet | NodeIdSet | 0)};


        GridNodeHighlightConfigBuilder<STATE | GridHighlightConfigSet>& setGridHighlightConfig(std::unique_ptr<protocol::Overlay::GridHighlightConfig> value)
        {
            static_assert(!(STATE & GridHighlightConfigSet), "property gridHighlightConfig should not be set yet");
            m_result->setGridHighlightConfig(std::move(value));
            return castState<GridHighlightConfigSet>();
        }

        GridNodeHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<GridNodeHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class GridNodeHighlightConfig;
        GridNodeHighlightConfigBuilder() : m_result(new GridNodeHighlightConfig()) { }

        template<int STEP> GridNodeHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<GridNodeHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::GridNodeHighlightConfig> m_result;
    };

    static GridNodeHighlightConfigBuilder<0> create()
    {
        return GridNodeHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    GridNodeHighlightConfig()
    {
          m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::GridHighlightConfig> m_gridHighlightConfig;
    int m_nodeId;
};


class CORE_EXPORT FlexNodeHighlightConfig : public ::crdtp::ProtocolObject<FlexNodeHighlightConfig> {
public:
    ~FlexNodeHighlightConfig() override { }

    protocol::Overlay::FlexContainerHighlightConfig* getFlexContainerHighlightConfig() { return m_flexContainerHighlightConfig.get(); }
    void setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value) { m_flexContainerHighlightConfig = std::move(value); }

    int getNodeId() { return m_nodeId; }
    void setNodeId(int value) { m_nodeId = value; }

    template<int STATE>
    class FlexNodeHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FlexContainerHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (FlexContainerHighlightConfigSet | NodeIdSet | 0)};


        FlexNodeHighlightConfigBuilder<STATE | FlexContainerHighlightConfigSet>& setFlexContainerHighlightConfig(std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> value)
        {
            static_assert(!(STATE & FlexContainerHighlightConfigSet), "property flexContainerHighlightConfig should not be set yet");
            m_result->setFlexContainerHighlightConfig(std::move(value));
            return castState<FlexContainerHighlightConfigSet>();
        }

        FlexNodeHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<FlexNodeHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class FlexNodeHighlightConfig;
        FlexNodeHighlightConfigBuilder() : m_result(new FlexNodeHighlightConfig()) { }

        template<int STEP> FlexNodeHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<FlexNodeHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::FlexNodeHighlightConfig> m_result;
    };

    static FlexNodeHighlightConfigBuilder<0> create()
    {
        return FlexNodeHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    FlexNodeHighlightConfig()
    {
          m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::FlexContainerHighlightConfig> m_flexContainerHighlightConfig;
    int m_nodeId;
};


class CORE_EXPORT ScrollSnapContainerHighlightConfig : public ::crdtp::ProtocolObject<ScrollSnapContainerHighlightConfig> {
public:
    ~ScrollSnapContainerHighlightConfig() override { }

    bool hasSnapportBorder() { return m_snapportBorder.isJust(); }
    protocol::Overlay::LineStyle* getSnapportBorder(protocol::Overlay::LineStyle* defaultValue) { return m_snapportBorder.isJust() ? m_snapportBorder.fromJust() : defaultValue; }
    void setSnapportBorder(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_snapportBorder = std::move(value); }

    bool hasSnapAreaBorder() { return m_snapAreaBorder.isJust(); }
    protocol::Overlay::LineStyle* getSnapAreaBorder(protocol::Overlay::LineStyle* defaultValue) { return m_snapAreaBorder.isJust() ? m_snapAreaBorder.fromJust() : defaultValue; }
    void setSnapAreaBorder(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_snapAreaBorder = std::move(value); }

    bool hasScrollMarginColor() { return m_scrollMarginColor.isJust(); }
    protocol::DOM::RGBA* getScrollMarginColor(protocol::DOM::RGBA* defaultValue) { return m_scrollMarginColor.isJust() ? m_scrollMarginColor.fromJust() : defaultValue; }
    void setScrollMarginColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_scrollMarginColor = std::move(value); }

    bool hasScrollPaddingColor() { return m_scrollPaddingColor.isJust(); }
    protocol::DOM::RGBA* getScrollPaddingColor(protocol::DOM::RGBA* defaultValue) { return m_scrollPaddingColor.isJust() ? m_scrollPaddingColor.fromJust() : defaultValue; }
    void setScrollPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_scrollPaddingColor = std::move(value); }

    template<int STATE>
    class ScrollSnapContainerHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        ScrollSnapContainerHighlightConfigBuilder<STATE>& setSnapportBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setSnapportBorder(std::move(value));
            return *this;
        }

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setSnapAreaBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setSnapAreaBorder(std::move(value));
            return *this;
        }

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setScrollMarginColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setScrollMarginColor(std::move(value));
            return *this;
        }

        ScrollSnapContainerHighlightConfigBuilder<STATE>& setScrollPaddingColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setScrollPaddingColor(std::move(value));
            return *this;
        }

        std::unique_ptr<ScrollSnapContainerHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScrollSnapContainerHighlightConfig;
        ScrollSnapContainerHighlightConfigBuilder() : m_result(new ScrollSnapContainerHighlightConfig()) { }

        template<int STEP> ScrollSnapContainerHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScrollSnapContainerHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> m_result;
    };

    static ScrollSnapContainerHighlightConfigBuilder<0> create()
    {
        return ScrollSnapContainerHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ScrollSnapContainerHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::LineStyle> m_snapportBorder;
    Maybe<protocol::Overlay::LineStyle> m_snapAreaBorder;
    Maybe<protocol::DOM::RGBA> m_scrollMarginColor;
    Maybe<protocol::DOM::RGBA> m_scrollPaddingColor;
};


class CORE_EXPORT ScrollSnapHighlightConfig : public ::crdtp::ProtocolObject<ScrollSnapHighlightConfig> {
public:
    ~ScrollSnapHighlightConfig() override { }

    protocol::Overlay::ScrollSnapContainerHighlightConfig* getScrollSnapContainerHighlightConfig() { return m_scrollSnapContainerHighlightConfig.get(); }
    void setScrollSnapContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> value) { m_scrollSnapContainerHighlightConfig = std::move(value); }

    int getNodeId() { return m_nodeId; }
    void setNodeId(int value) { m_nodeId = value; }

    template<int STATE>
    class ScrollSnapHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ScrollSnapContainerHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (ScrollSnapContainerHighlightConfigSet | NodeIdSet | 0)};


        ScrollSnapHighlightConfigBuilder<STATE | ScrollSnapContainerHighlightConfigSet>& setScrollSnapContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> value)
        {
            static_assert(!(STATE & ScrollSnapContainerHighlightConfigSet), "property scrollSnapContainerHighlightConfig should not be set yet");
            m_result->setScrollSnapContainerHighlightConfig(std::move(value));
            return castState<ScrollSnapContainerHighlightConfigSet>();
        }

        ScrollSnapHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<ScrollSnapHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ScrollSnapHighlightConfig;
        ScrollSnapHighlightConfigBuilder() : m_result(new ScrollSnapHighlightConfig()) { }

        template<int STEP> ScrollSnapHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ScrollSnapHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ScrollSnapHighlightConfig> m_result;
    };

    static ScrollSnapHighlightConfigBuilder<0> create()
    {
        return ScrollSnapHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ScrollSnapHighlightConfig()
    {
          m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::ScrollSnapContainerHighlightConfig> m_scrollSnapContainerHighlightConfig;
    int m_nodeId;
};


class CORE_EXPORT HingeConfig : public ::crdtp::ProtocolObject<HingeConfig> {
public:
    ~HingeConfig() override { }

    protocol::DOM::Rect* getRect() { return m_rect.get(); }
    void setRect(std::unique_ptr<protocol::DOM::Rect> value) { m_rect = std::move(value); }

    bool hasContentColor() { return m_contentColor.isJust(); }
    protocol::DOM::RGBA* getContentColor(protocol::DOM::RGBA* defaultValue) { return m_contentColor.isJust() ? m_contentColor.fromJust() : defaultValue; }
    void setContentColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_contentColor = std::move(value); }

    bool hasOutlineColor() { return m_outlineColor.isJust(); }
    protocol::DOM::RGBA* getOutlineColor(protocol::DOM::RGBA* defaultValue) { return m_outlineColor.isJust() ? m_outlineColor.fromJust() : defaultValue; }
    void setOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_outlineColor = std::move(value); }

    template<int STATE>
    class HingeConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            RectSet = 1 << 1,
            AllFieldsSet = (RectSet | 0)};


        HingeConfigBuilder<STATE | RectSet>& setRect(std::unique_ptr<protocol::DOM::Rect> value)
        {
            static_assert(!(STATE & RectSet), "property rect should not be set yet");
            m_result->setRect(std::move(value));
            return castState<RectSet>();
        }

        HingeConfigBuilder<STATE>& setContentColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setContentColor(std::move(value));
            return *this;
        }

        HingeConfigBuilder<STATE>& setOutlineColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setOutlineColor(std::move(value));
            return *this;
        }

        std::unique_ptr<HingeConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class HingeConfig;
        HingeConfigBuilder() : m_result(new HingeConfig()) { }

        template<int STEP> HingeConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<HingeConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::HingeConfig> m_result;
    };

    static HingeConfigBuilder<0> create()
    {
        return HingeConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    HingeConfig()
    {
    }

    std::unique_ptr<protocol::DOM::Rect> m_rect;
    Maybe<protocol::DOM::RGBA> m_contentColor;
    Maybe<protocol::DOM::RGBA> m_outlineColor;
};


class CORE_EXPORT ContainerQueryHighlightConfig : public ::crdtp::ProtocolObject<ContainerQueryHighlightConfig> {
public:
    ~ContainerQueryHighlightConfig() override { }

    protocol::Overlay::ContainerQueryContainerHighlightConfig* getContainerQueryContainerHighlightConfig() { return m_containerQueryContainerHighlightConfig.get(); }
    void setContainerQueryContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value) { m_containerQueryContainerHighlightConfig = std::move(value); }

    int getNodeId() { return m_nodeId; }
    void setNodeId(int value) { m_nodeId = value; }

    template<int STATE>
    class ContainerQueryHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ContainerQueryContainerHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (ContainerQueryContainerHighlightConfigSet | NodeIdSet | 0)};


        ContainerQueryHighlightConfigBuilder<STATE | ContainerQueryContainerHighlightConfigSet>& setContainerQueryContainerHighlightConfig(std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> value)
        {
            static_assert(!(STATE & ContainerQueryContainerHighlightConfigSet), "property containerQueryContainerHighlightConfig should not be set yet");
            m_result->setContainerQueryContainerHighlightConfig(std::move(value));
            return castState<ContainerQueryContainerHighlightConfigSet>();
        }

        ContainerQueryHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<ContainerQueryHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContainerQueryHighlightConfig;
        ContainerQueryHighlightConfigBuilder() : m_result(new ContainerQueryHighlightConfig()) { }

        template<int STEP> ContainerQueryHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContainerQueryHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ContainerQueryHighlightConfig> m_result;
    };

    static ContainerQueryHighlightConfigBuilder<0> create()
    {
        return ContainerQueryHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ContainerQueryHighlightConfig()
    {
          m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> m_containerQueryContainerHighlightConfig;
    int m_nodeId;
};


class CORE_EXPORT ContainerQueryContainerHighlightConfig : public ::crdtp::ProtocolObject<ContainerQueryContainerHighlightConfig> {
public:
    ~ContainerQueryContainerHighlightConfig() override { }

    bool hasContainerBorder() { return m_containerBorder.isJust(); }
    protocol::Overlay::LineStyle* getContainerBorder(protocol::Overlay::LineStyle* defaultValue) { return m_containerBorder.isJust() ? m_containerBorder.fromJust() : defaultValue; }
    void setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_containerBorder = std::move(value); }

    bool hasDescendantBorder() { return m_descendantBorder.isJust(); }
    protocol::Overlay::LineStyle* getDescendantBorder(protocol::Overlay::LineStyle* defaultValue) { return m_descendantBorder.isJust() ? m_descendantBorder.fromJust() : defaultValue; }
    void setDescendantBorder(std::unique_ptr<protocol::Overlay::LineStyle> value) { m_descendantBorder = std::move(value); }

    template<int STATE>
    class ContainerQueryContainerHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        ContainerQueryContainerHighlightConfigBuilder<STATE>& setContainerBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setContainerBorder(std::move(value));
            return *this;
        }

        ContainerQueryContainerHighlightConfigBuilder<STATE>& setDescendantBorder(std::unique_ptr<protocol::Overlay::LineStyle> value)
        {
            m_result->setDescendantBorder(std::move(value));
            return *this;
        }

        std::unique_ptr<ContainerQueryContainerHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class ContainerQueryContainerHighlightConfig;
        ContainerQueryContainerHighlightConfigBuilder() : m_result(new ContainerQueryContainerHighlightConfig()) { }

        template<int STEP> ContainerQueryContainerHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<ContainerQueryContainerHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::ContainerQueryContainerHighlightConfig> m_result;
    };

    static ContainerQueryContainerHighlightConfigBuilder<0> create()
    {
        return ContainerQueryContainerHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    ContainerQueryContainerHighlightConfig()
    {
    }

    Maybe<protocol::Overlay::LineStyle> m_containerBorder;
    Maybe<protocol::Overlay::LineStyle> m_descendantBorder;
};


class CORE_EXPORT IsolatedElementHighlightConfig : public ::crdtp::ProtocolObject<IsolatedElementHighlightConfig> {
public:
    ~IsolatedElementHighlightConfig() override { }

    protocol::Overlay::IsolationModeHighlightConfig* getIsolationModeHighlightConfig() { return m_isolationModeHighlightConfig.get(); }
    void setIsolationModeHighlightConfig(std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> value) { m_isolationModeHighlightConfig = std::move(value); }

    int getNodeId() { return m_nodeId; }
    void setNodeId(int value) { m_nodeId = value; }

    template<int STATE>
    class IsolatedElementHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            IsolationModeHighlightConfigSet = 1 << 1,
            NodeIdSet = 1 << 2,
            AllFieldsSet = (IsolationModeHighlightConfigSet | NodeIdSet | 0)};


        IsolatedElementHighlightConfigBuilder<STATE | IsolationModeHighlightConfigSet>& setIsolationModeHighlightConfig(std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> value)
        {
            static_assert(!(STATE & IsolationModeHighlightConfigSet), "property isolationModeHighlightConfig should not be set yet");
            m_result->setIsolationModeHighlightConfig(std::move(value));
            return castState<IsolationModeHighlightConfigSet>();
        }

        IsolatedElementHighlightConfigBuilder<STATE | NodeIdSet>& setNodeId(int value)
        {
            static_assert(!(STATE & NodeIdSet), "property nodeId should not be set yet");
            m_result->setNodeId(value);
            return castState<NodeIdSet>();
        }

        std::unique_ptr<IsolatedElementHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class IsolatedElementHighlightConfig;
        IsolatedElementHighlightConfigBuilder() : m_result(new IsolatedElementHighlightConfig()) { }

        template<int STEP> IsolatedElementHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<IsolatedElementHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::IsolatedElementHighlightConfig> m_result;
    };

    static IsolatedElementHighlightConfigBuilder<0> create()
    {
        return IsolatedElementHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    IsolatedElementHighlightConfig()
    {
          m_nodeId = 0;
    }

    std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> m_isolationModeHighlightConfig;
    int m_nodeId;
};


class CORE_EXPORT IsolationModeHighlightConfig : public ::crdtp::ProtocolObject<IsolationModeHighlightConfig> {
public:
    ~IsolationModeHighlightConfig() override { }

    bool hasResizerColor() { return m_resizerColor.isJust(); }
    protocol::DOM::RGBA* getResizerColor(protocol::DOM::RGBA* defaultValue) { return m_resizerColor.isJust() ? m_resizerColor.fromJust() : defaultValue; }
    void setResizerColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_resizerColor = std::move(value); }

    bool hasResizerHandleColor() { return m_resizerHandleColor.isJust(); }
    protocol::DOM::RGBA* getResizerHandleColor(protocol::DOM::RGBA* defaultValue) { return m_resizerHandleColor.isJust() ? m_resizerHandleColor.fromJust() : defaultValue; }
    void setResizerHandleColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_resizerHandleColor = std::move(value); }

    bool hasMaskColor() { return m_maskColor.isJust(); }
    protocol::DOM::RGBA* getMaskColor(protocol::DOM::RGBA* defaultValue) { return m_maskColor.isJust() ? m_maskColor.fromJust() : defaultValue; }
    void setMaskColor(std::unique_ptr<protocol::DOM::RGBA> value) { m_maskColor = std::move(value); }

    template<int STATE>
    class IsolationModeHighlightConfigBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            AllFieldsSet = (0)};


        IsolationModeHighlightConfigBuilder<STATE>& setResizerColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setResizerColor(std::move(value));
            return *this;
        }

        IsolationModeHighlightConfigBuilder<STATE>& setResizerHandleColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setResizerHandleColor(std::move(value));
            return *this;
        }

        IsolationModeHighlightConfigBuilder<STATE>& setMaskColor(std::unique_ptr<protocol::DOM::RGBA> value)
        {
            m_result->setMaskColor(std::move(value));
            return *this;
        }

        std::unique_ptr<IsolationModeHighlightConfig> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class IsolationModeHighlightConfig;
        IsolationModeHighlightConfigBuilder() : m_result(new IsolationModeHighlightConfig()) { }

        template<int STEP> IsolationModeHighlightConfigBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<IsolationModeHighlightConfigBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Overlay::IsolationModeHighlightConfig> m_result;
    };

    static IsolationModeHighlightConfigBuilder<0> create()
    {
        return IsolationModeHighlightConfigBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    IsolationModeHighlightConfig()
    {
    }

    Maybe<protocol::DOM::RGBA> m_resizerColor;
    Maybe<protocol::DOM::RGBA> m_resizerHandleColor;
    Maybe<protocol::DOM::RGBA> m_maskColor;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse disable() = 0;
    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse getHighlightObjectForTest(int in_nodeId, Maybe<bool> in_includeDistance, Maybe<bool> in_includeStyle, Maybe<String> in_colorFormat, Maybe<bool> in_showAccessibilityInfo, std::unique_ptr<protocol::DictionaryValue>* out_highlight) = 0;
    virtual DispatchResponse getGridHighlightObjectsForTest(std::unique_ptr<protocol::Array<int>> in_nodeIds, std::unique_ptr<protocol::DictionaryValue>* out_highlights) = 0;
    virtual DispatchResponse getSourceOrderHighlightObjectForTest(int in_nodeId, std::unique_ptr<protocol::DictionaryValue>* out_highlight) = 0;
    virtual DispatchResponse hideHighlight() = 0;
    virtual DispatchResponse highlightFrame(const String& in_frameId, Maybe<protocol::DOM::RGBA> in_contentColor, Maybe<protocol::DOM::RGBA> in_contentOutlineColor) = 0;
    virtual DispatchResponse highlightNode(std::unique_ptr<protocol::Overlay::HighlightConfig> in_highlightConfig, Maybe<int> in_nodeId, Maybe<int> in_backendNodeId, Maybe<String> in_objectId, Maybe<String> in_selector) = 0;
    virtual DispatchResponse highlightQuad(std::unique_ptr<protocol::Array<double>> in_quad, Maybe<protocol::DOM::RGBA> in_color, Maybe<protocol::DOM::RGBA> in_outlineColor) = 0;
    virtual DispatchResponse highlightRect(int in_x, int in_y, int in_width, int in_height, Maybe<protocol::DOM::RGBA> in_color, Maybe<protocol::DOM::RGBA> in_outlineColor) = 0;
    virtual DispatchResponse highlightSourceOrder(std::unique_ptr<protocol::Overlay::SourceOrderConfig> in_sourceOrderConfig, Maybe<int> in_nodeId, Maybe<int> in_backendNodeId, Maybe<String> in_objectId) = 0;
    virtual DispatchResponse setInspectMode(const String& in_mode, Maybe<protocol::Overlay::HighlightConfig> in_highlightConfig) = 0;
    virtual DispatchResponse setShowAdHighlights(bool in_show) = 0;
    virtual DispatchResponse setPausedInDebuggerMessage(Maybe<String> in_message) = 0;
    virtual DispatchResponse setShowDebugBorders(bool in_show) = 0;
    virtual DispatchResponse setShowFPSCounter(bool in_show) = 0;
    virtual DispatchResponse setShowGridOverlays(std::unique_ptr<protocol::Array<protocol::Overlay::GridNodeHighlightConfig>> in_gridNodeHighlightConfigs) = 0;
    virtual DispatchResponse setShowFlexOverlays(std::unique_ptr<protocol::Array<protocol::Overlay::FlexNodeHighlightConfig>> in_flexNodeHighlightConfigs) = 0;
    virtual DispatchResponse setShowScrollSnapOverlays(std::unique_ptr<protocol::Array<protocol::Overlay::ScrollSnapHighlightConfig>> in_scrollSnapHighlightConfigs) = 0;
    virtual DispatchResponse setShowContainerQueryOverlays(std::unique_ptr<protocol::Array<protocol::Overlay::ContainerQueryHighlightConfig>> in_containerQueryHighlightConfigs) = 0;
    virtual DispatchResponse setShowPaintRects(bool in_result) = 0;
    virtual DispatchResponse setShowLayoutShiftRegions(bool in_result) = 0;
    virtual DispatchResponse setShowScrollBottleneckRects(bool in_show) = 0;
    virtual DispatchResponse setShowHitTestBorders(bool in_show) = 0;
    virtual DispatchResponse setShowWebVitals(bool in_show) = 0;
    virtual DispatchResponse setShowViewportSizeOnResize(bool in_show) = 0;
    virtual DispatchResponse setShowHinge(Maybe<protocol::Overlay::HingeConfig> in_hingeConfig) = 0;
    virtual DispatchResponse setShowIsolatedElements(std::unique_ptr<protocol::Array<protocol::Overlay::IsolatedElementHighlightConfig>> in_isolatedElementHighlightConfigs) = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void inspectNodeRequested(int backendNodeId);
    void nodeHighlightRequested(int nodeId);
    void screenshotRequested(std::unique_ptr<protocol::Page::Viewport> viewport);
    void inspectModeCanceled();

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Overlay
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Overlay_h)
