// This file is generated by TypeBuilder_h.template.

// Copyright (c) 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef blink_protocol_Media_h
#define blink_protocol_Media_h

#include "third_party/blink/renderer/core/core_export.h"
#include "third_party/blink/renderer/core/inspector/protocol/protocol.h"
// For each imported domain we generate a ValueConversions struct instead of a full domain definition
// and include Domain::API version from there.

namespace blink {
namespace protocol {
namespace Media {
using PlayerId = String;
using Timestamp = double;
class PlayerMessage;
class PlayerProperty;
class PlayerEvent;
class PlayerErrorSourceLocation;
class PlayerError;

// ------------- Forward and enum declarations.

// ------------- Type and builder declarations.

class CORE_EXPORT PlayerMessage : public ::crdtp::ProtocolObject<PlayerMessage> {
public:
    ~PlayerMessage() override { }

    struct CORE_EXPORT LevelEnum {
        static const char* Error;
        static const char* Warning;
        static const char* Info;
        static const char* Debug;
    }; // LevelEnum

    String getLevel() { return m_level; }
    void setLevel(const String& value) { m_level = value; }

    String getMessage() { return m_message; }
    void setMessage(const String& value) { m_message = value; }

    template<int STATE>
    class PlayerMessageBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            LevelSet = 1 << 1,
            MessageSet = 1 << 2,
            AllFieldsSet = (LevelSet | MessageSet | 0)};


        PlayerMessageBuilder<STATE | LevelSet>& setLevel(const String& value)
        {
            static_assert(!(STATE & LevelSet), "property level should not be set yet");
            m_result->setLevel(value);
            return castState<LevelSet>();
        }

        PlayerMessageBuilder<STATE | MessageSet>& setMessage(const String& value)
        {
            static_assert(!(STATE & MessageSet), "property message should not be set yet");
            m_result->setMessage(value);
            return castState<MessageSet>();
        }

        std::unique_ptr<PlayerMessage> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerMessage;
        PlayerMessageBuilder() : m_result(new PlayerMessage()) { }

        template<int STEP> PlayerMessageBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerMessageBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerMessage> m_result;
    };

    static PlayerMessageBuilder<0> create()
    {
        return PlayerMessageBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PlayerMessage()
    {
    }

    String m_level;
    String m_message;
};


class CORE_EXPORT PlayerProperty : public ::crdtp::ProtocolObject<PlayerProperty> {
public:
    ~PlayerProperty() override { }

    String getName() { return m_name; }
    void setName(const String& value) { m_name = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    template<int STATE>
    class PlayerPropertyBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            NameSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (NameSet | ValueSet | 0)};


        PlayerPropertyBuilder<STATE | NameSet>& setName(const String& value)
        {
            static_assert(!(STATE & NameSet), "property name should not be set yet");
            m_result->setName(value);
            return castState<NameSet>();
        }

        PlayerPropertyBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<PlayerProperty> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerProperty;
        PlayerPropertyBuilder() : m_result(new PlayerProperty()) { }

        template<int STEP> PlayerPropertyBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerPropertyBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerProperty> m_result;
    };

    static PlayerPropertyBuilder<0> create()
    {
        return PlayerPropertyBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PlayerProperty()
    {
    }

    String m_name;
    String m_value;
};


class CORE_EXPORT PlayerEvent : public ::crdtp::ProtocolObject<PlayerEvent> {
public:
    ~PlayerEvent() override { }

    double getTimestamp() { return m_timestamp; }
    void setTimestamp(double value) { m_timestamp = value; }

    String getValue() { return m_value; }
    void setValue(const String& value) { m_value = value; }

    template<int STATE>
    class PlayerEventBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            TimestampSet = 1 << 1,
            ValueSet = 1 << 2,
            AllFieldsSet = (TimestampSet | ValueSet | 0)};


        PlayerEventBuilder<STATE | TimestampSet>& setTimestamp(double value)
        {
            static_assert(!(STATE & TimestampSet), "property timestamp should not be set yet");
            m_result->setTimestamp(value);
            return castState<TimestampSet>();
        }

        PlayerEventBuilder<STATE | ValueSet>& setValue(const String& value)
        {
            static_assert(!(STATE & ValueSet), "property value should not be set yet");
            m_result->setValue(value);
            return castState<ValueSet>();
        }

        std::unique_ptr<PlayerEvent> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerEvent;
        PlayerEventBuilder() : m_result(new PlayerEvent()) { }

        template<int STEP> PlayerEventBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerEventBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerEvent> m_result;
    };

    static PlayerEventBuilder<0> create()
    {
        return PlayerEventBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PlayerEvent()
    {
          m_timestamp = 0;
    }

    double m_timestamp;
    String m_value;
};


class CORE_EXPORT PlayerErrorSourceLocation : public ::crdtp::ProtocolObject<PlayerErrorSourceLocation> {
public:
    ~PlayerErrorSourceLocation() override { }

    String getFile() { return m_file; }
    void setFile(const String& value) { m_file = value; }

    int getLine() { return m_line; }
    void setLine(int value) { m_line = value; }

    template<int STATE>
    class PlayerErrorSourceLocationBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            FileSet = 1 << 1,
            LineSet = 1 << 2,
            AllFieldsSet = (FileSet | LineSet | 0)};


        PlayerErrorSourceLocationBuilder<STATE | FileSet>& setFile(const String& value)
        {
            static_assert(!(STATE & FileSet), "property file should not be set yet");
            m_result->setFile(value);
            return castState<FileSet>();
        }

        PlayerErrorSourceLocationBuilder<STATE | LineSet>& setLine(int value)
        {
            static_assert(!(STATE & LineSet), "property line should not be set yet");
            m_result->setLine(value);
            return castState<LineSet>();
        }

        std::unique_ptr<PlayerErrorSourceLocation> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerErrorSourceLocation;
        PlayerErrorSourceLocationBuilder() : m_result(new PlayerErrorSourceLocation()) { }

        template<int STEP> PlayerErrorSourceLocationBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerErrorSourceLocationBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerErrorSourceLocation> m_result;
    };

    static PlayerErrorSourceLocationBuilder<0> create()
    {
        return PlayerErrorSourceLocationBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PlayerErrorSourceLocation()
    {
          m_line = 0;
    }

    String m_file;
    int m_line;
};


class CORE_EXPORT PlayerError : public ::crdtp::ProtocolObject<PlayerError> {
public:
    ~PlayerError() override { }

    String getErrorType() { return m_errorType; }
    void setErrorType(const String& value) { m_errorType = value; }

    int getCode() { return m_code; }
    void setCode(int value) { m_code = value; }

    protocol::Array<protocol::Media::PlayerErrorSourceLocation>* getStack() { return m_stack.get(); }
    void setStack(std::unique_ptr<protocol::Array<protocol::Media::PlayerErrorSourceLocation>> value) { m_stack = std::move(value); }

    protocol::Array<protocol::Media::PlayerError>* getCause() { return m_cause.get(); }
    void setCause(std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> value) { m_cause = std::move(value); }

    protocol::DictionaryValue* getData() { return m_data.get(); }
    void setData(std::unique_ptr<protocol::DictionaryValue> value) { m_data = std::move(value); }

    template<int STATE>
    class PlayerErrorBuilder {
    public:
        enum {
            NoFieldsSet = 0,
            ErrorTypeSet = 1 << 1,
            CodeSet = 1 << 2,
            StackSet = 1 << 3,
            CauseSet = 1 << 4,
            DataSet = 1 << 5,
            AllFieldsSet = (ErrorTypeSet | CodeSet | StackSet | CauseSet | DataSet | 0)};


        PlayerErrorBuilder<STATE | ErrorTypeSet>& setErrorType(const String& value)
        {
            static_assert(!(STATE & ErrorTypeSet), "property errorType should not be set yet");
            m_result->setErrorType(value);
            return castState<ErrorTypeSet>();
        }

        PlayerErrorBuilder<STATE | CodeSet>& setCode(int value)
        {
            static_assert(!(STATE & CodeSet), "property code should not be set yet");
            m_result->setCode(value);
            return castState<CodeSet>();
        }

        PlayerErrorBuilder<STATE | StackSet>& setStack(std::unique_ptr<protocol::Array<protocol::Media::PlayerErrorSourceLocation>> value)
        {
            static_assert(!(STATE & StackSet), "property stack should not be set yet");
            m_result->setStack(std::move(value));
            return castState<StackSet>();
        }

        PlayerErrorBuilder<STATE | CauseSet>& setCause(std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> value)
        {
            static_assert(!(STATE & CauseSet), "property cause should not be set yet");
            m_result->setCause(std::move(value));
            return castState<CauseSet>();
        }

        PlayerErrorBuilder<STATE | DataSet>& setData(std::unique_ptr<protocol::DictionaryValue> value)
        {
            static_assert(!(STATE & DataSet), "property data should not be set yet");
            m_result->setData(std::move(value));
            return castState<DataSet>();
        }

        std::unique_ptr<PlayerError> build()
        {
            static_assert(STATE == AllFieldsSet, "state should be AllFieldsSet");
            return std::move(m_result);
        }

    private:
        friend class PlayerError;
        PlayerErrorBuilder() : m_result(new PlayerError()) { }

        template<int STEP> PlayerErrorBuilder<STATE | STEP>& castState()
        {
            return *reinterpret_cast<PlayerErrorBuilder<STATE | STEP>*>(this);
        }

        std::unique_ptr<protocol::Media::PlayerError> m_result;
    };

    static PlayerErrorBuilder<0> create()
    {
        return PlayerErrorBuilder<0>();
    }

private:
    DECLARE_SERIALIZATION_SUPPORT();

    PlayerError()
    {
          m_code = 0;
    }

    String m_errorType;
    int m_code;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerErrorSourceLocation>> m_stack;
    std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> m_cause;
    std::unique_ptr<protocol::DictionaryValue> m_data;
};


// ------------- Backend interface.

class CORE_EXPORT Backend {
public:
    virtual ~Backend() { }

    virtual DispatchResponse enable() = 0;
    virtual DispatchResponse disable() = 0;

};

// ------------- Frontend interface.

class CORE_EXPORT Frontend {
public:
  explicit Frontend(FrontendChannel* frontend_channel) : frontend_channel_(frontend_channel) {}
    void playerPropertiesChanged(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerProperty>> properties);
    void playerEventsAdded(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerEvent>> events);
    void playerMessagesLogged(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerMessage>> messages);
    void playerErrorsRaised(const String& playerId, std::unique_ptr<protocol::Array<protocol::Media::PlayerError>> errors);
    void playersCreated(std::unique_ptr<protocol::Array<String>> players);

  void flush();
  void sendRawNotification(std::unique_ptr<Serializable>);
 private:
  FrontendChannel* frontend_channel_;
};

// ------------- Dispatcher.

class CORE_EXPORT Dispatcher {
public:
    static void wire(UberDispatcher*, Backend*);

private:
    Dispatcher() { }
};

// ------------- Metainfo.

class CORE_EXPORT Metainfo {
public:
    using BackendClass = Backend;
    using FrontendClass = Frontend;
    using DispatcherClass = Dispatcher;
    static const char domainName[];
    static const char commandPrefix[];
    static const char version[];
};

} // namespace Media
} // namespace blink
} // namespace protocol

#endif // !defined(blink_protocol_Media_h)
