// third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/push_messaging/push_messaging_status.mojom-params-data.h"
namespace blink {
namespace mojom {

static NOINLINE const char* PushEventStatusToStringHelper(PushEventStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PushEventStatus::SUCCESS:
      return "SUCCESS";
    case PushEventStatus::UNKNOWN_APP_ID:
      return "UNKNOWN_APP_ID";
    case PushEventStatus::PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case PushEventStatus::NO_SERVICE_WORKER:
      return "NO_SERVICE_WORKER";
    case PushEventStatus::SERVICE_WORKER_ERROR:
      return "SERVICE_WORKER_ERROR";
    case PushEventStatus::EVENT_WAITUNTIL_REJECTED:
      return "EVENT_WAITUNTIL_REJECTED";
    case PushEventStatus::TIMEOUT:
      return "TIMEOUT";
    case PushEventStatus::PERMISSION_REVOKED_ABUSIVE:
      return "PERMISSION_REVOKED_ABUSIVE";
    case PushEventStatus::NO_APP_LEVEL_PERMISSION_IGNORE:
      return "NO_APP_LEVEL_PERMISSION_IGNORE";
    case PushEventStatus::NO_APP_LEVEL_PERMISSION_UNSUBSCRIBE:
      return "NO_APP_LEVEL_PERMISSION_UNSUBSCRIBE";
    case PushEventStatus::PERMISSION_REVOKED_DISRUPTIVE:
      return "PERMISSION_REVOKED_DISRUPTIVE";
    default:
      return nullptr;
  }
}

std::string PushEventStatusToString(PushEventStatus value) {
  const char *str = PushEventStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PushEventStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PushEventStatus value) {
  return os << PushEventStatusToString(value);
}

static NOINLINE const char* PushGetRegistrationStatusToStringHelper(PushGetRegistrationStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PushGetRegistrationStatus::SUCCESS:
      return "SUCCESS";
    case PushGetRegistrationStatus::SERVICE_NOT_AVAILABLE:
      return "SERVICE_NOT_AVAILABLE";
    case PushGetRegistrationStatus::STORAGE_ERROR:
      return "STORAGE_ERROR";
    case PushGetRegistrationStatus::REGISTRATION_NOT_FOUND:
      return "REGISTRATION_NOT_FOUND";
    case PushGetRegistrationStatus::INCOGNITO_REGISTRATION_NOT_FOUND:
      return "INCOGNITO_REGISTRATION_NOT_FOUND";
    case PushGetRegistrationStatus::STORAGE_CORRUPT:
      return "STORAGE_CORRUPT";
    case PushGetRegistrationStatus::RENDERER_SHUTDOWN:
      return "RENDERER_SHUTDOWN";
    case PushGetRegistrationStatus::NO_LIVE_SERVICE_WORKER:
      return "NO_LIVE_SERVICE_WORKER";
    default:
      return nullptr;
  }
}

std::string PushGetRegistrationStatusToString(PushGetRegistrationStatus value) {
  const char *str = PushGetRegistrationStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PushGetRegistrationStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PushGetRegistrationStatus value) {
  return os << PushGetRegistrationStatusToString(value);
}

static NOINLINE const char* PushRegistrationStatusToStringHelper(PushRegistrationStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PushRegistrationStatus::SUCCESS_FROM_PUSH_SERVICE:
      return "SUCCESS_FROM_PUSH_SERVICE";
    case PushRegistrationStatus::NO_SERVICE_WORKER:
      return "NO_SERVICE_WORKER";
    case PushRegistrationStatus::SERVICE_NOT_AVAILABLE:
      return "SERVICE_NOT_AVAILABLE";
    case PushRegistrationStatus::LIMIT_REACHED:
      return "LIMIT_REACHED";
    case PushRegistrationStatus::PERMISSION_DENIED:
      return "PERMISSION_DENIED";
    case PushRegistrationStatus::SERVICE_ERROR:
      return "SERVICE_ERROR";
    case PushRegistrationStatus::NO_SENDER_ID:
      return "NO_SENDER_ID";
    case PushRegistrationStatus::STORAGE_ERROR:
      return "STORAGE_ERROR";
    case PushRegistrationStatus::SUCCESS_FROM_CACHE:
      return "SUCCESS_FROM_CACHE";
    case PushRegistrationStatus::NETWORK_ERROR:
      return "NETWORK_ERROR";
    case PushRegistrationStatus::INCOGNITO_PERMISSION_DENIED:
      return "INCOGNITO_PERMISSION_DENIED";
    case PushRegistrationStatus::PUBLIC_KEY_UNAVAILABLE:
      return "PUBLIC_KEY_UNAVAILABLE";
    case PushRegistrationStatus::MANIFEST_EMPTY_OR_MISSING:
      return "MANIFEST_EMPTY_OR_MISSING";
    case PushRegistrationStatus::SENDER_ID_MISMATCH:
      return "SENDER_ID_MISMATCH";
    case PushRegistrationStatus::STORAGE_CORRUPT:
      return "STORAGE_CORRUPT";
    case PushRegistrationStatus::RENDERER_SHUTDOWN:
      return "RENDERER_SHUTDOWN";
    case PushRegistrationStatus::SUCCESS_NEW_SUBSCRIPTION_FROM_PUSH_SERVICE:
      return "SUCCESS_NEW_SUBSCRIPTION_FROM_PUSH_SERVICE";
    case PushRegistrationStatus::UNSUPPORTED_GCM_SENDER_ID:
      return "UNSUPPORTED_GCM_SENDER_ID";
    default:
      return nullptr;
  }
}

std::string PushRegistrationStatusToString(PushRegistrationStatus value) {
  const char *str = PushRegistrationStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PushRegistrationStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PushRegistrationStatus value) {
  return os << PushRegistrationStatusToString(value);
}

static NOINLINE const char* PushUnregistrationReasonToStringHelper(PushUnregistrationReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PushUnregistrationReason::UNKNOWN:
      return "UNKNOWN";
    case PushUnregistrationReason::JAVASCRIPT_API:
      return "JAVASCRIPT_API";
    case PushUnregistrationReason::PERMISSION_REVOKED:
      return "PERMISSION_REVOKED";
    case PushUnregistrationReason::DELIVERY_UNKNOWN_APP_ID:
      return "DELIVERY_UNKNOWN_APP_ID";
    case PushUnregistrationReason::DELIVERY_PERMISSION_DENIED:
      return "DELIVERY_PERMISSION_DENIED";
    case PushUnregistrationReason::DELIVERY_NO_SERVICE_WORKER:
      return "DELIVERY_NO_SERVICE_WORKER";
    case PushUnregistrationReason::GCM_STORE_RESET:
      return "GCM_STORE_RESET";
    case PushUnregistrationReason::SERVICE_WORKER_UNREGISTERED:
      return "SERVICE_WORKER_UNREGISTERED";
    case PushUnregistrationReason::SUBSCRIBE_STORAGE_CORRUPT:
      return "SUBSCRIBE_STORAGE_CORRUPT";
    case PushUnregistrationReason::GET_SUBSCRIPTION_STORAGE_CORRUPT:
      return "GET_SUBSCRIPTION_STORAGE_CORRUPT";
    case PushUnregistrationReason::SERVICE_WORKER_DATABASE_WIPED:
      return "SERVICE_WORKER_DATABASE_WIPED";
    case PushUnregistrationReason::SUBSCRIPTION_EXPIRED:
      return "SUBSCRIPTION_EXPIRED";
    case PushUnregistrationReason::REFRESH_FINISHED:
      return "REFRESH_FINISHED";
    case PushUnregistrationReason::PERMISSION_REVOKED_ABUSIVE:
      return "PERMISSION_REVOKED_ABUSIVE";
    case PushUnregistrationReason::NO_APP_LEVEL_PERMISSION:
      return "NO_APP_LEVEL_PERMISSION";
    case PushUnregistrationReason::PERMISSION_REVOKED_DISRUPTIVE:
      return "PERMISSION_REVOKED_DISRUPTIVE";
    default:
      return nullptr;
  }
}

std::string PushUnregistrationReasonToString(PushUnregistrationReason value) {
  const char *str = PushUnregistrationReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PushUnregistrationReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PushUnregistrationReason value) {
  return os << PushUnregistrationReasonToString(value);
}

static NOINLINE const char* PushUnregistrationStatusToStringHelper(PushUnregistrationStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PushUnregistrationStatus::SUCCESS_UNREGISTERED:
      return "SUCCESS_UNREGISTERED";
    case PushUnregistrationStatus::SUCCESS_WAS_NOT_REGISTERED:
      return "SUCCESS_WAS_NOT_REGISTERED";
    case PushUnregistrationStatus::PENDING_NETWORK_ERROR:
      return "PENDING_NETWORK_ERROR";
    case PushUnregistrationStatus::NO_SERVICE_WORKER:
      return "NO_SERVICE_WORKER";
    case PushUnregistrationStatus::SERVICE_NOT_AVAILABLE:
      return "SERVICE_NOT_AVAILABLE";
    case PushUnregistrationStatus::PENDING_SERVICE_ERROR:
      return "PENDING_SERVICE_ERROR";
    case PushUnregistrationStatus::STORAGE_ERROR:
      return "STORAGE_ERROR";
    case PushUnregistrationStatus::NETWORK_ERROR:
      return "NETWORK_ERROR";
    default:
      return nullptr;
  }
}

std::string PushUnregistrationStatusToString(PushUnregistrationStatus value) {
  const char *str = PushUnregistrationStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PushUnregistrationStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PushUnregistrationStatus value) {
  return os << PushUnregistrationStatusToString(value);
}

static NOINLINE const char* PushUserVisibleStatusToStringHelper(PushUserVisibleStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case PushUserVisibleStatus::REQUIRED_AND_SHOWN:
      return "REQUIRED_AND_SHOWN";
    case PushUserVisibleStatus::NOT_REQUIRED_BUT_SHOWN:
      return "NOT_REQUIRED_BUT_SHOWN";
    case PushUserVisibleStatus::NOT_REQUIRED_AND_NOT_SHOWN:
      return "NOT_REQUIRED_AND_NOT_SHOWN";
    case PushUserVisibleStatus::REQUIRED_BUT_NOT_SHOWN_USED_GRACE:
      return "REQUIRED_BUT_NOT_SHOWN_USED_GRACE";
    case PushUserVisibleStatus::REQUIRED_BUT_NOT_SHOWN_GRACE_EXCEEDED:
      return "REQUIRED_BUT_NOT_SHOWN_GRACE_EXCEEDED";
    default:
      return nullptr;
  }
}

std::string PushUserVisibleStatusToString(PushUserVisibleStatus value) {
  const char *str = PushUserVisibleStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown PushUserVisibleStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, PushUserVisibleStatus value) {
  return os << PushUserVisibleStatusToString(value);
}

namespace internal {

}  // namespace internal
}  // namespace mojom
}  // namespace blink

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::PushEventStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::PushEventStatus value) {
  return std::move(context).WriteString(::blink::mojom::PushEventStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::PushGetRegistrationStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::PushGetRegistrationStatus value) {
  return std::move(context).WriteString(::blink::mojom::PushGetRegistrationStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::PushRegistrationStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::PushRegistrationStatus value) {
  return std::move(context).WriteString(::blink::mojom::PushRegistrationStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::PushUnregistrationReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::PushUnregistrationReason value) {
  return std::move(context).WriteString(::blink::mojom::PushUnregistrationReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::PushUnregistrationStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::PushUnregistrationStatus value) {
  return std::move(context).WriteString(::blink::mojom::PushUnregistrationStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::PushUserVisibleStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::PushUserVisibleStatus value) {
  return std::move(context).WriteString(::blink::mojom::PushUserVisibleStatusToString(value));
}

} // namespace perfetto