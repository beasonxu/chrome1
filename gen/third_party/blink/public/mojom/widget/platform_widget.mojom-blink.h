// third_party/blink/public/mojom/widget/platform_widget.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_WIDGET_PLATFORM_WIDGET_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_WIDGET_PLATFORM_WIDGET_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/widget/platform_widget.mojom-shared.h"
#include "third_party/blink/public/mojom/widget/platform_widget.mojom-blink-forward.h"
#include "cc/mojom/render_frame_metadata.mojom-blink-forward.h"
#include "mojo/public/mojom/base/string16.mojom-blink.h"
#include "mojo/public/mojom/base/text_direction.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink-forward.h"
#include "services/viz/public/mojom/compositing/compositor_frame_sink.mojom-blink-forward.h"
#include "ui/base/cursor/mojom/cursor.mojom-blink.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-blink.h"
#include "third_party/blink/public/mojom/input/input_handler.mojom-blink-forward.h"
#include "third_party/blink/public/mojom/widget/visual_properties.mojom-blink.h"
#include "third_party/blink/public/mojom/widget/record_content_to_visible_time_request.mojom-blink-forward.h"
#include "ui/base/ime/mojom/text_input_state.mojom-blink-forward.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/renderer/platform/platform_export.h"




namespace blink {
namespace mojom {
namespace blink {

class WidgetCompositorProxy;

template <typename ImplRefTraits>
class WidgetCompositorStub;

class WidgetCompositorRequestValidator;
class WidgetCompositorResponseValidator;


class PLATFORM_EXPORT WidgetCompositor
    : public WidgetCompositorInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = WidgetCompositorInterfaceBase;
  using Proxy_ = WidgetCompositorProxy;

  template <typename ImplRefTraits>
  using Stub_ = WidgetCompositorStub<ImplRefTraits>;

  using RequestValidator_ = WidgetCompositorRequestValidator;
  using ResponseValidator_ = WidgetCompositorResponseValidator;
  enum MethodMinVersions : uint32_t {
    kVisualStateRequestMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct VisualStateRequest_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~WidgetCompositor() = default;


  using VisualStateRequestCallback = base::OnceCallback<void()>;
  
  virtual void VisualStateRequest(VisualStateRequestCallback callback) = 0;
};

class WidgetHostProxy;

template <typename ImplRefTraits>
class WidgetHostStub;

class WidgetHostRequestValidator;


class PLATFORM_EXPORT WidgetHost
    : public WidgetHostInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = WidgetHostInterfaceBase;
  using Proxy_ = WidgetHostProxy;

  template <typename ImplRefTraits>
  using Stub_ = WidgetHostStub<ImplRefTraits>;

  using RequestValidator_ = WidgetHostRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kSetCursorMinVersion = 0,
    kUpdateTooltipUnderCursorMinVersion = 0,
    kUpdateTooltipFromKeyboardMinVersion = 0,
    kClearKeyboardTriggeredTooltipMinVersion = 0,
    kTextInputStateChangedMinVersion = 0,
    kSelectionBoundsChangedMinVersion = 0,
    kCreateFrameSinkMinVersion = 0,
    kRegisterRenderFrameMetadataObserverMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct SetCursor_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateTooltipUnderCursor_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateTooltipFromKeyboard_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ClearKeyboardTriggeredTooltip_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct TextInputStateChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SelectionBoundsChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateFrameSink_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct RegisterRenderFrameMetadataObserver_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~WidgetHost() = default;

  
  virtual void SetCursor(const ::ui::Cursor& cursor) = 0;

  
  virtual void UpdateTooltipUnderCursor(const ::WTF::String& tooltip_text, ::base::i18n::TextDirection text_direction_hint) = 0;

  
  virtual void UpdateTooltipFromKeyboard(const ::WTF::String& tooltip_text, ::base::i18n::TextDirection text_direction_hint, const ::gfx::Rect& bounds) = 0;

  
  virtual void ClearKeyboardTriggeredTooltip() = 0;

  
  virtual void TextInputStateChanged(::ui::mojom::blink::TextInputStatePtr state) = 0;

  
  virtual void SelectionBoundsChanged(const ::gfx::Rect& anchor_rect, ::base::i18n::TextDirection anchor_dir, const ::gfx::Rect& focus_rect, ::base::i18n::TextDirection focus_dir, const ::gfx::Rect& bounding_box_rect, bool is_anchor_first) = 0;

  
  virtual void CreateFrameSink(::mojo::PendingReceiver<::viz::mojom::blink::CompositorFrameSink> compositor_frame_sink_receiver, ::mojo::PendingRemote<::viz::mojom::blink::CompositorFrameSinkClient> compositor_frame_sink_client) = 0;

  
  virtual void RegisterRenderFrameMetadataObserver(::mojo::PendingReceiver<::cc::mojom::blink::RenderFrameMetadataObserverClient> render_frame_metadata_observer_client_receiver, ::mojo::PendingRemote<::cc::mojom::blink::RenderFrameMetadataObserver> render_frame_metadata_observer) = 0;
};

class WidgetProxy;

template <typename ImplRefTraits>
class WidgetStub;

class WidgetRequestValidator;
class WidgetResponseValidator;


class PLATFORM_EXPORT Widget
    : public WidgetInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = WidgetInterfaceBase;
  using Proxy_ = WidgetProxy;

  template <typename ImplRefTraits>
  using Stub_ = WidgetStub<ImplRefTraits>;

  using RequestValidator_ = WidgetRequestValidator;
  using ResponseValidator_ = WidgetResponseValidator;
  enum MethodMinVersions : uint32_t {
    kForceRedrawMinVersion = 0,
    kGetWidgetInputHandlerMinVersion = 0,
    kUpdateVisualPropertiesMinVersion = 0,
    kUpdateScreenRectsMinVersion = 0,
    kWasHiddenMinVersion = 0,
    kWasShownMinVersion = 0,
    kRequestPresentationTimeForNextFrameMinVersion = 0,
    kCancelPresentationTimeRequestMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct ForceRedraw_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetWidgetInputHandler_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateVisualProperties_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateScreenRects_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct WasHidden_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct WasShown_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct RequestPresentationTimeForNextFrame_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CancelPresentationTimeRequest_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~Widget() = default;


  using ForceRedrawCallback = base::OnceCallback<void()>;
  
  virtual void ForceRedraw(ForceRedrawCallback callback) = 0;

  
  virtual void GetWidgetInputHandler(::mojo::PendingReceiver<::blink::mojom::blink::WidgetInputHandler> request, ::mojo::PendingRemote<::blink::mojom::blink::WidgetInputHandlerHost> host) = 0;

  
  virtual void UpdateVisualProperties(const ::blink::VisualProperties& visual_properties) = 0;


  using UpdateScreenRectsCallback = base::OnceCallback<void()>;
  
  virtual void UpdateScreenRects(const ::gfx::Rect& widget_screen_rect, const ::gfx::Rect& window_screen_rect, UpdateScreenRectsCallback callback) = 0;

  
  virtual void WasHidden() = 0;

  
  virtual void WasShown(bool was_evicted, ::blink::mojom::blink::RecordContentToVisibleTimeRequestPtr record_tab_switch_time_request) = 0;

  
  virtual void RequestPresentationTimeForNextFrame(::blink::mojom::blink::RecordContentToVisibleTimeRequestPtr visible_time_request) = 0;

  
  virtual void CancelPresentationTimeRequest() = 0;
};



class PLATFORM_EXPORT WidgetCompositorProxy
    : public WidgetCompositor {
 public:
  using InterfaceType = WidgetCompositor;

  explicit WidgetCompositorProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void VisualStateRequest(VisualStateRequestCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class PLATFORM_EXPORT WidgetHostProxy
    : public WidgetHost {
 public:
  using InterfaceType = WidgetHost;

  explicit WidgetHostProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SetCursor(const ::ui::Cursor& cursor) final;
  
  void UpdateTooltipUnderCursor(const ::WTF::String& tooltip_text, ::base::i18n::TextDirection text_direction_hint) final;
  
  void UpdateTooltipFromKeyboard(const ::WTF::String& tooltip_text, ::base::i18n::TextDirection text_direction_hint, const ::gfx::Rect& bounds) final;
  
  void ClearKeyboardTriggeredTooltip() final;
  
  void TextInputStateChanged(::ui::mojom::blink::TextInputStatePtr state) final;
  
  void SelectionBoundsChanged(const ::gfx::Rect& anchor_rect, ::base::i18n::TextDirection anchor_dir, const ::gfx::Rect& focus_rect, ::base::i18n::TextDirection focus_dir, const ::gfx::Rect& bounding_box_rect, bool is_anchor_first) final;
  
  void CreateFrameSink(::mojo::PendingReceiver<::viz::mojom::blink::CompositorFrameSink> compositor_frame_sink_receiver, ::mojo::PendingRemote<::viz::mojom::blink::CompositorFrameSinkClient> compositor_frame_sink_client) final;
  
  void RegisterRenderFrameMetadataObserver(::mojo::PendingReceiver<::cc::mojom::blink::RenderFrameMetadataObserverClient> render_frame_metadata_observer_client_receiver, ::mojo::PendingRemote<::cc::mojom::blink::RenderFrameMetadataObserver> render_frame_metadata_observer) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class PLATFORM_EXPORT WidgetProxy
    : public Widget {
 public:
  using InterfaceType = Widget;

  explicit WidgetProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void ForceRedraw(ForceRedrawCallback callback) final;
  
  void GetWidgetInputHandler(::mojo::PendingReceiver<::blink::mojom::blink::WidgetInputHandler> request, ::mojo::PendingRemote<::blink::mojom::blink::WidgetInputHandlerHost> host) final;
  
  void UpdateVisualProperties(const ::blink::VisualProperties& visual_properties) final;
  
  void UpdateScreenRects(const ::gfx::Rect& widget_screen_rect, const ::gfx::Rect& window_screen_rect, UpdateScreenRectsCallback callback) final;
  
  void WasHidden() final;
  
  void WasShown(bool was_evicted, ::blink::mojom::blink::RecordContentToVisibleTimeRequestPtr record_tab_switch_time_request) final;
  
  void RequestPresentationTimeForNextFrame(::blink::mojom::blink::RecordContentToVisibleTimeRequestPtr visible_time_request) final;
  
  void CancelPresentationTimeRequest() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class PLATFORM_EXPORT WidgetCompositorStubDispatch {
 public:
  static bool Accept(WidgetCompositor* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      WidgetCompositor* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<WidgetCompositor>>
class WidgetCompositorStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WidgetCompositorStub() = default;
  ~WidgetCompositorStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetCompositorStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetCompositorStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class PLATFORM_EXPORT WidgetHostStubDispatch {
 public:
  static bool Accept(WidgetHost* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      WidgetHost* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<WidgetHost>>
class WidgetHostStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WidgetHostStub() = default;
  ~WidgetHostStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetHostStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetHostStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class PLATFORM_EXPORT WidgetStubDispatch {
 public:
  static bool Accept(Widget* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Widget* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Widget>>
class WidgetStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WidgetStub() = default;
  ~WidgetStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WidgetStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class PLATFORM_EXPORT WidgetCompositorRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class PLATFORM_EXPORT WidgetHostRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class PLATFORM_EXPORT WidgetRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class PLATFORM_EXPORT WidgetCompositorResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class PLATFORM_EXPORT WidgetResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





}  // namespace blink
}  // namespace mojom
}  // namespace blink

namespace mojo {

}  // namespace mojo

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_WIDGET_PLATFORM_WIDGET_MOJOM_BLINK_H_