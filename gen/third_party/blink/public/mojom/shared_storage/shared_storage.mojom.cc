// third_party/blink/public/mojom/shared_storage/shared_storage.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/shared_storage/shared_storage.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/shared_storage/shared_storage.mojom-params-data.h"
#include "third_party/blink/public/mojom/shared_storage/shared_storage.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/shared_storage/shared_storage.mojom-import-headers.h"
#include "third_party/blink/public/mojom/shared_storage/shared_storage.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_SHARED_STORAGE_SHARED_STORAGE_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_SHARED_STORAGE_SHARED_STORAGE_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace mojom {
SharedStorageKeyArgument::SharedStorageKeyArgument()
    : data() {}

SharedStorageKeyArgument::SharedStorageKeyArgument(
    const ::std::u16string& data_in)
    : data(std::move(data_in)) {}

SharedStorageKeyArgument::~SharedStorageKeyArgument() = default;

void SharedStorageKeyArgument::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedStorageKeyArgument::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SharedStorageValueArgument::SharedStorageValueArgument()
    : data() {}

SharedStorageValueArgument::SharedStorageValueArgument(
    const ::std::u16string& data_in)
    : data(std::move(data_in)) {}

SharedStorageValueArgument::~SharedStorageValueArgument() = default;

void SharedStorageValueArgument::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::std::u16string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedStorageValueArgument::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SharedStorageUrlWithMetadata::SharedStorageUrlWithMetadata()
    : url(),
      reporting_metadata() {}

SharedStorageUrlWithMetadata::SharedStorageUrlWithMetadata(
    const ::GURL& url_in,
    const base::flat_map<std::string, ::GURL>& reporting_metadata_in)
    : url(std::move(url_in)),
      reporting_metadata(std::move(reporting_metadata_in)) {}

SharedStorageUrlWithMetadata::~SharedStorageUrlWithMetadata() = default;

void SharedStorageUrlWithMetadata::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_metadata"), this->reporting_metadata,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, ::GURL>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedStorageUrlWithMetadata::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char SharedStorageDocumentService::Name_[] = "blink.mojom.SharedStorageDocumentService";

SharedStorageDocumentService::IPCStableHashFunction SharedStorageDocumentService::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name: {
      return &SharedStorageDocumentService::AddModuleOnWorklet_Sym::IPCStableHash;
    }
    case internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name: {
      return &SharedStorageDocumentService::RunOperationOnWorklet_Sym::IPCStableHash;
    }
    case internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name: {
      return &SharedStorageDocumentService::RunURLSelectionOperationOnWorklet_Sym::IPCStableHash;
    }
    case internal::kSharedStorageDocumentService_SharedStorageSet_Name: {
      return &SharedStorageDocumentService::SharedStorageSet_Sym::IPCStableHash;
    }
    case internal::kSharedStorageDocumentService_SharedStorageAppend_Name: {
      return &SharedStorageDocumentService::SharedStorageAppend_Sym::IPCStableHash;
    }
    case internal::kSharedStorageDocumentService_SharedStorageDelete_Name: {
      return &SharedStorageDocumentService::SharedStorageDelete_Sym::IPCStableHash;
    }
    case internal::kSharedStorageDocumentService_SharedStorageClear_Name: {
      return &SharedStorageDocumentService::SharedStorageClear_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SharedStorageDocumentService::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::AddModuleOnWorklet";
      case internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::RunOperationOnWorklet";
      case internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::RunURLSelectionOperationOnWorklet";
      case internal::kSharedStorageDocumentService_SharedStorageSet_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::SharedStorageSet";
      case internal::kSharedStorageDocumentService_SharedStorageAppend_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::SharedStorageAppend";
      case internal::kSharedStorageDocumentService_SharedStorageDelete_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::SharedStorageDelete";
      case internal::kSharedStorageDocumentService_SharedStorageClear_Name:
            return "Receive blink::mojom::SharedStorageDocumentService::SharedStorageClear";
    }
  } else {
    switch (message.name()) {
      case internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::AddModuleOnWorklet";
      case internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::RunOperationOnWorklet";
      case internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::RunURLSelectionOperationOnWorklet";
      case internal::kSharedStorageDocumentService_SharedStorageSet_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::SharedStorageSet";
      case internal::kSharedStorageDocumentService_SharedStorageAppend_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::SharedStorageAppend";
      case internal::kSharedStorageDocumentService_SharedStorageDelete_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::SharedStorageDelete";
      case internal::kSharedStorageDocumentService_SharedStorageClear_Name:
            return "Receive reply blink::mojom::SharedStorageDocumentService::SharedStorageClear";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SharedStorageDocumentService::AddModuleOnWorklet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::AddModuleOnWorklet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SharedStorageDocumentService::RunOperationOnWorklet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::RunOperationOnWorklet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SharedStorageDocumentService::RunURLSelectionOperationOnWorklet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::RunURLSelectionOperationOnWorklet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SharedStorageDocumentService::SharedStorageSet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::SharedStorageSet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SharedStorageDocumentService::SharedStorageAppend_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::SharedStorageAppend");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SharedStorageDocumentService::SharedStorageDelete_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::SharedStorageDelete");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SharedStorageDocumentService::SharedStorageClear_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SharedStorageDocumentService::SharedStorageClear");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback(
      SharedStorageDocumentService::AddModuleOnWorkletCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback(const SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback&) = delete;
  SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback& operator=(const SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::AddModuleOnWorkletCallback callback_;
};

class SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback(
      SharedStorageDocumentService::RunOperationOnWorkletCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback(const SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback&) = delete;
  SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback& operator=(const SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::RunOperationOnWorkletCallback callback_;
};

class SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback(
      SharedStorageDocumentService::RunURLSelectionOperationOnWorkletCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback(const SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback&) = delete;
  SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback& operator=(const SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::RunURLSelectionOperationOnWorkletCallback callback_;
};

class SharedStorageDocumentService_SharedStorageSet_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_SharedStorageSet_ForwardToCallback(
      SharedStorageDocumentService::SharedStorageSetCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_SharedStorageSet_ForwardToCallback(const SharedStorageDocumentService_SharedStorageSet_ForwardToCallback&) = delete;
  SharedStorageDocumentService_SharedStorageSet_ForwardToCallback& operator=(const SharedStorageDocumentService_SharedStorageSet_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::SharedStorageSetCallback callback_;
};

class SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback(
      SharedStorageDocumentService::SharedStorageAppendCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback(const SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback&) = delete;
  SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback& operator=(const SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::SharedStorageAppendCallback callback_;
};

class SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback(
      SharedStorageDocumentService::SharedStorageDeleteCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback(const SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback&) = delete;
  SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback& operator=(const SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::SharedStorageDeleteCallback callback_;
};

class SharedStorageDocumentService_SharedStorageClear_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SharedStorageDocumentService_SharedStorageClear_ForwardToCallback(
      SharedStorageDocumentService::SharedStorageClearCallback callback
      ) : callback_(std::move(callback)) {
  }

  SharedStorageDocumentService_SharedStorageClear_ForwardToCallback(const SharedStorageDocumentService_SharedStorageClear_ForwardToCallback&) = delete;
  SharedStorageDocumentService_SharedStorageClear_ForwardToCallback& operator=(const SharedStorageDocumentService_SharedStorageClear_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SharedStorageDocumentService::SharedStorageClearCallback callback_;
};

SharedStorageDocumentServiceProxy::SharedStorageDocumentServiceProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SharedStorageDocumentServiceProxy::AddModuleOnWorklet(
    const ::GURL& in_script_source_url, AddModuleOnWorkletCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SharedStorageDocumentService::AddModuleOnWorklet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("script_source_url"), in_script_source_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_AddModuleOnWorklet_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->script_source_url)::BaseType> script_source_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_script_source_url, script_source_url_fragment);
  params->script_source_url.Set(
      script_source_url_fragment.is_null() ? nullptr : script_source_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->script_source_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null script_source_url in SharedStorageDocumentService.AddModuleOnWorklet request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("AddModuleOnWorklet");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SharedStorageDocumentServiceProxy::RunOperationOnWorklet(
    const std::string& in_name, const std::vector<uint8_t>& in_serialized_data, RunOperationOnWorkletCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SharedStorageDocumentService::RunOperationOnWorklet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("serialized_data"), in_serialized_data,
                        "<value of type const std::vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_RunOperationOnWorklet_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in SharedStorageDocumentService.RunOperationOnWorklet request");
  mojo::internal::MessageFragment<
      typename decltype(params->serialized_data)::BaseType>
      serialized_data_fragment(params.message());
  const mojo::internal::ContainerValidateParams serialized_data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_serialized_data, serialized_data_fragment, &serialized_data_validate_params);
  params->serialized_data.Set(
      serialized_data_fragment.is_null() ? nullptr : serialized_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->serialized_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null serialized_data in SharedStorageDocumentService.RunOperationOnWorklet request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("RunOperationOnWorklet");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SharedStorageDocumentServiceProxy::RunURLSelectionOperationOnWorklet(
    const std::string& in_name, std::vector<SharedStorageUrlWithMetadataPtr> in_urls_with_metadata, const std::vector<uint8_t>& in_serialized_data, RunURLSelectionOperationOnWorkletCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SharedStorageDocumentService::RunURLSelectionOperationOnWorklet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("name"), in_name,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("urls_with_metadata"), in_urls_with_metadata,
                        "<value of type std::vector<SharedStorageUrlWithMetadataPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("serialized_data"), in_serialized_data,
                        "<value of type const std::vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->name)::BaseType> name_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_name, name_fragment);
  params->name.Set(
      name_fragment.is_null() ? nullptr : name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null name in SharedStorageDocumentService.RunURLSelectionOperationOnWorklet request");
  mojo::internal::MessageFragment<
      typename decltype(params->urls_with_metadata)::BaseType>
      urls_with_metadata_fragment(params.message());
  const mojo::internal::ContainerValidateParams urls_with_metadata_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::SharedStorageUrlWithMetadataDataView>>(
      in_urls_with_metadata, urls_with_metadata_fragment, &urls_with_metadata_validate_params);
  params->urls_with_metadata.Set(
      urls_with_metadata_fragment.is_null() ? nullptr : urls_with_metadata_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->urls_with_metadata.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null urls_with_metadata in SharedStorageDocumentService.RunURLSelectionOperationOnWorklet request");
  mojo::internal::MessageFragment<
      typename decltype(params->serialized_data)::BaseType>
      serialized_data_fragment(params.message());
  const mojo::internal::ContainerValidateParams serialized_data_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_serialized_data, serialized_data_fragment, &serialized_data_validate_params);
  params->serialized_data.Set(
      serialized_data_fragment.is_null() ? nullptr : serialized_data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->serialized_data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null serialized_data in SharedStorageDocumentService.RunURLSelectionOperationOnWorklet request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("RunURLSelectionOperationOnWorklet");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SharedStorageDocumentServiceProxy::SharedStorageSet(
    const ::std::u16string& in_key, const ::std::u16string& in_value, bool in_ignore_if_present, SharedStorageSetCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SharedStorageDocumentService::SharedStorageSet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("ignore_if_present"), in_ignore_if_present,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageSet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageSet_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SharedStorageKeyArgumentDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in SharedStorageDocumentService.SharedStorageSet request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SharedStorageValueArgumentDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in SharedStorageDocumentService.SharedStorageSet request");
  params->ignore_if_present = in_ignore_if_present;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageSet");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_SharedStorageSet_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SharedStorageDocumentServiceProxy::SharedStorageAppend(
    const ::std::u16string& in_key, const ::std::u16string& in_value, SharedStorageAppendCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SharedStorageDocumentService::SharedStorageAppend", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageAppend_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageAppend_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SharedStorageKeyArgumentDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in SharedStorageDocumentService.SharedStorageAppend request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SharedStorageValueArgumentDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in SharedStorageDocumentService.SharedStorageAppend request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageAppend");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SharedStorageDocumentServiceProxy::SharedStorageDelete(
    const ::std::u16string& in_key, SharedStorageDeleteCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SharedStorageDocumentService::SharedStorageDelete", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const ::std::u16string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageDelete_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageDelete_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SharedStorageKeyArgumentDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in SharedStorageDocumentService.SharedStorageDelete request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageDelete");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SharedStorageDocumentServiceProxy::SharedStorageClear(
    SharedStorageClearCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::SharedStorageDocumentService::SharedStorageClear");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageClear_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageClear_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageClear");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SharedStorageDocumentService_SharedStorageClear_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::AddModuleOnWorkletCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder> proxy(
        new SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::AddModuleOnWorkletCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message);
};

bool SharedStorageDocumentService_AddModuleOnWorklet_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_AddModuleOnWorklet_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_AddModuleOnWorklet_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  SharedStorageDocumentService_AddModuleOnWorklet_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message));
  return true;
}

void SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::AddModuleOnWorklet", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_AddModuleOnWorklet_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("AddModuleOnWorklet");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::RunOperationOnWorkletCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder> proxy(
        new SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::RunOperationOnWorkletCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message);
};

bool SharedStorageDocumentService_RunOperationOnWorklet_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_RunOperationOnWorklet_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_RunOperationOnWorklet_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  SharedStorageDocumentService_RunOperationOnWorklet_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message));
  return true;
}

void SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::RunOperationOnWorklet", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_RunOperationOnWorklet_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("RunOperationOnWorklet");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::RunURLSelectionOperationOnWorkletCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder> proxy(
        new SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::RunURLSelectionOperationOnWorkletCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message, const ::GURL& in_opaque_url);
};

bool SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  ::GURL p_opaque_url{};
  SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (success && !input_data_view.ReadOpaqueUrl(&p_opaque_url))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message), 
std::move(p_opaque_url));
  return true;
}

void SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message, const ::GURL& in_opaque_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::RunURLSelectionOperationOnWorklet", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opaque_url"), in_opaque_url,
                        "<value of type const ::GURL&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");
  mojo::internal::MessageFragment<
      typename decltype(params->opaque_url)::BaseType> opaque_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_opaque_url, opaque_url_fragment);
  params->opaque_url.Set(
      opaque_url_fragment.is_null() ? nullptr : opaque_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->opaque_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null opaque_url in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("RunURLSelectionOperationOnWorklet");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SharedStorageDocumentService_SharedStorageSet_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::SharedStorageSetCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_SharedStorageSet_ProxyToResponder> proxy(
        new SharedStorageDocumentService_SharedStorageSet_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_SharedStorageSet_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_SharedStorageSet_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_SharedStorageSet_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::SharedStorageSetCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message);
};

bool SharedStorageDocumentService_SharedStorageSet_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_SharedStorageSet_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_SharedStorageSet_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  SharedStorageDocumentService_SharedStorageSet_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message));
  return true;
}

void SharedStorageDocumentService_SharedStorageSet_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::SharedStorageSet", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageSet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageSet_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageSet");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::SharedStorageAppendCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder> proxy(
        new SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::SharedStorageAppendCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message);
};

bool SharedStorageDocumentService_SharedStorageAppend_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_SharedStorageAppend_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_SharedStorageAppend_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  SharedStorageDocumentService_SharedStorageAppend_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message));
  return true;
}

void SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::SharedStorageAppend", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageAppend_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageAppend_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageAppend");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::SharedStorageDeleteCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder> proxy(
        new SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::SharedStorageDeleteCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message);
};

bool SharedStorageDocumentService_SharedStorageDelete_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_SharedStorageDelete_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_SharedStorageDelete_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  SharedStorageDocumentService_SharedStorageDelete_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message));
  return true;
}

void SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::SharedStorageDelete", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageDelete_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageDelete_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageDelete");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class SharedStorageDocumentService_SharedStorageClear_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SharedStorageDocumentService::SharedStorageClearCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SharedStorageDocumentService_SharedStorageClear_ProxyToResponder> proxy(
        new SharedStorageDocumentService_SharedStorageClear_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SharedStorageDocumentService_SharedStorageClear_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SharedStorageDocumentService_SharedStorageClear_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SharedStorageDocumentService_SharedStorageClear_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SharedStorageDocumentService::SharedStorageClearCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const std::string& in_error_message);
};

bool SharedStorageDocumentService_SharedStorageClear_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SharedStorageDocumentService_SharedStorageClear_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SharedStorageDocumentService_SharedStorageClear_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  std::string p_error_message{};
  SharedStorageDocumentService_SharedStorageClear_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadErrorMessage(&p_error_message))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SharedStorageDocumentService::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_error_message));
  return true;
}

void SharedStorageDocumentService_SharedStorageClear_ProxyToResponder::Run(
    bool in_success, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SharedStorageDocumentService::SharedStorageClear", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSharedStorageDocumentService_SharedStorageClear_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SharedStorageDocumentService_SharedStorageClear_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SharedStorageDocumentService::Name_);
  message.set_method_name("SharedStorageClear");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool SharedStorageDocumentServiceStubDispatch::Accept(
    SharedStorageDocumentService* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name: {
      break;
    }
    case internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name: {
      break;
    }
    case internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name: {
      break;
    }
    case internal::kSharedStorageDocumentService_SharedStorageSet_Name: {
      break;
    }
    case internal::kSharedStorageDocumentService_SharedStorageAppend_Name: {
      break;
    }
    case internal::kSharedStorageDocumentService_SharedStorageDelete_Name: {
      break;
    }
    case internal::kSharedStorageDocumentService_SharedStorageClear_Name: {
      break;
    }
  }
  return false;
}

// static
bool SharedStorageDocumentServiceStubDispatch::AcceptWithResponder(
    SharedStorageDocumentService* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSharedStorageDocumentService_AddModuleOnWorklet_Name: {

      internal::SharedStorageDocumentService_AddModuleOnWorklet_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_AddModuleOnWorklet_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_script_source_url{};
      SharedStorageDocumentService_AddModuleOnWorklet_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadScriptSourceUrl(&p_script_source_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 0, false);
        return false;
      }
      SharedStorageDocumentService::AddModuleOnWorkletCallback callback =
          SharedStorageDocumentService_AddModuleOnWorklet_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddModuleOnWorklet(
std::move(p_script_source_url), std::move(callback));
      return true;
    }
    case internal::kSharedStorageDocumentService_RunOperationOnWorklet_Name: {

      internal::SharedStorageDocumentService_RunOperationOnWorklet_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_RunOperationOnWorklet_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_name{};
      std::vector<uint8_t> p_serialized_data{};
      SharedStorageDocumentService_RunOperationOnWorklet_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success && !input_data_view.ReadSerializedData(&p_serialized_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 1, false);
        return false;
      }
      SharedStorageDocumentService::RunOperationOnWorkletCallback callback =
          SharedStorageDocumentService_RunOperationOnWorklet_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunOperationOnWorklet(
std::move(p_name), 
std::move(p_serialized_data), std::move(callback));
      return true;
    }
    case internal::kSharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Name: {

      internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_name{};
      std::vector<SharedStorageUrlWithMetadataPtr> p_urls_with_metadata{};
      std::vector<uint8_t> p_serialized_data{};
      SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadName(&p_name))
        success = false;
      if (success && !input_data_view.ReadUrlsWithMetadata(&p_urls_with_metadata))
        success = false;
      if (success && !input_data_view.ReadSerializedData(&p_serialized_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 2, false);
        return false;
      }
      SharedStorageDocumentService::RunURLSelectionOperationOnWorkletCallback callback =
          SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunURLSelectionOperationOnWorklet(
std::move(p_name), 
std::move(p_urls_with_metadata), 
std::move(p_serialized_data), std::move(callback));
      return true;
    }
    case internal::kSharedStorageDocumentService_SharedStorageSet_Name: {

      internal::SharedStorageDocumentService_SharedStorageSet_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_SharedStorageSet_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_key{};
      ::std::u16string p_value{};
      bool p_ignore_if_present{};
      SharedStorageDocumentService_SharedStorageSet_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (success)
        p_ignore_if_present = input_data_view.ignore_if_present();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 3, false);
        return false;
      }
      SharedStorageDocumentService::SharedStorageSetCallback callback =
          SharedStorageDocumentService_SharedStorageSet_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SharedStorageSet(
std::move(p_key), 
std::move(p_value), 
std::move(p_ignore_if_present), std::move(callback));
      return true;
    }
    case internal::kSharedStorageDocumentService_SharedStorageAppend_Name: {

      internal::SharedStorageDocumentService_SharedStorageAppend_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_SharedStorageAppend_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_key{};
      ::std::u16string p_value{};
      SharedStorageDocumentService_SharedStorageAppend_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 4, false);
        return false;
      }
      SharedStorageDocumentService::SharedStorageAppendCallback callback =
          SharedStorageDocumentService_SharedStorageAppend_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SharedStorageAppend(
std::move(p_key), 
std::move(p_value), std::move(callback));
      return true;
    }
    case internal::kSharedStorageDocumentService_SharedStorageDelete_Name: {

      internal::SharedStorageDocumentService_SharedStorageDelete_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_SharedStorageDelete_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_key{};
      SharedStorageDocumentService_SharedStorageDelete_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 5, false);
        return false;
      }
      SharedStorageDocumentService::SharedStorageDeleteCallback callback =
          SharedStorageDocumentService_SharedStorageDelete_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SharedStorageDelete(
std::move(p_key), std::move(callback));
      return true;
    }
    case internal::kSharedStorageDocumentService_SharedStorageClear_Name: {

      internal::SharedStorageDocumentService_SharedStorageClear_Params_Data* params =
          reinterpret_cast<
              internal::SharedStorageDocumentService_SharedStorageClear_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SharedStorageDocumentService_SharedStorageClear_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SharedStorageDocumentService::Name_, 6, false);
        return false;
      }
      SharedStorageDocumentService::SharedStorageClearCallback callback =
          SharedStorageDocumentService_SharedStorageClear_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SharedStorageClear(std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSharedStorageDocumentServiceValidationInfo[] = {
    {&internal::SharedStorageDocumentService_AddModuleOnWorklet_Params_Data::Validate,
     &internal::SharedStorageDocumentService_AddModuleOnWorklet_ResponseParams_Data::Validate},
    {&internal::SharedStorageDocumentService_RunOperationOnWorklet_Params_Data::Validate,
     &internal::SharedStorageDocumentService_RunOperationOnWorklet_ResponseParams_Data::Validate},
    {&internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_Params_Data::Validate,
     &internal::SharedStorageDocumentService_RunURLSelectionOperationOnWorklet_ResponseParams_Data::Validate},
    {&internal::SharedStorageDocumentService_SharedStorageSet_Params_Data::Validate,
     &internal::SharedStorageDocumentService_SharedStorageSet_ResponseParams_Data::Validate},
    {&internal::SharedStorageDocumentService_SharedStorageAppend_Params_Data::Validate,
     &internal::SharedStorageDocumentService_SharedStorageAppend_ResponseParams_Data::Validate},
    {&internal::SharedStorageDocumentService_SharedStorageDelete_Params_Data::Validate,
     &internal::SharedStorageDocumentService_SharedStorageDelete_ResponseParams_Data::Validate},
    {&internal::SharedStorageDocumentService_SharedStorageClear_Params_Data::Validate,
     &internal::SharedStorageDocumentService_SharedStorageClear_ResponseParams_Data::Validate},
};

bool SharedStorageDocumentServiceRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::SharedStorageDocumentService::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSharedStorageDocumentServiceValidationInfo);
}

bool SharedStorageDocumentServiceResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::SharedStorageDocumentService::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kSharedStorageDocumentServiceValidationInfo);
}


}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::SharedStorageKeyArgument::DataView, ::blink::mojom::SharedStorageKeyArgumentPtr>::Read(
    ::blink::mojom::SharedStorageKeyArgument::DataView input,
    ::blink::mojom::SharedStorageKeyArgumentPtr* output) {
  bool success = true;
  ::blink::mojom::SharedStorageKeyArgumentPtr result(::blink::mojom::SharedStorageKeyArgument::New());
  
      if (success && !input.ReadData(&result->data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::SharedStorageValueArgument::DataView, ::blink::mojom::SharedStorageValueArgumentPtr>::Read(
    ::blink::mojom::SharedStorageValueArgument::DataView input,
    ::blink::mojom::SharedStorageValueArgumentPtr* output) {
  bool success = true;
  ::blink::mojom::SharedStorageValueArgumentPtr result(::blink::mojom::SharedStorageValueArgument::New());
  
      if (success && !input.ReadData(&result->data))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::SharedStorageUrlWithMetadata::DataView, ::blink::mojom::SharedStorageUrlWithMetadataPtr>::Read(
    ::blink::mojom::SharedStorageUrlWithMetadata::DataView input,
    ::blink::mojom::SharedStorageUrlWithMetadataPtr* output) {
  bool success = true;
  ::blink::mojom::SharedStorageUrlWithMetadataPtr result(::blink::mojom::SharedStorageUrlWithMetadata::New());
  
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadReportingMetadata(&result->reporting_metadata))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void SharedStorageDocumentServiceInterceptorForTesting::AddModuleOnWorklet(const ::GURL& script_source_url, AddModuleOnWorkletCallback callback) {
  GetForwardingInterface()->AddModuleOnWorklet(std::move(script_source_url), std::move(callback));
}
void SharedStorageDocumentServiceInterceptorForTesting::RunOperationOnWorklet(const std::string& name, const std::vector<uint8_t>& serialized_data, RunOperationOnWorkletCallback callback) {
  GetForwardingInterface()->RunOperationOnWorklet(std::move(name), std::move(serialized_data), std::move(callback));
}
void SharedStorageDocumentServiceInterceptorForTesting::RunURLSelectionOperationOnWorklet(const std::string& name, std::vector<SharedStorageUrlWithMetadataPtr> urls_with_metadata, const std::vector<uint8_t>& serialized_data, RunURLSelectionOperationOnWorkletCallback callback) {
  GetForwardingInterface()->RunURLSelectionOperationOnWorklet(std::move(name), std::move(urls_with_metadata), std::move(serialized_data), std::move(callback));
}
void SharedStorageDocumentServiceInterceptorForTesting::SharedStorageSet(const ::std::u16string& key, const ::std::u16string& value, bool ignore_if_present, SharedStorageSetCallback callback) {
  GetForwardingInterface()->SharedStorageSet(std::move(key), std::move(value), std::move(ignore_if_present), std::move(callback));
}
void SharedStorageDocumentServiceInterceptorForTesting::SharedStorageAppend(const ::std::u16string& key, const ::std::u16string& value, SharedStorageAppendCallback callback) {
  GetForwardingInterface()->SharedStorageAppend(std::move(key), std::move(value), std::move(callback));
}
void SharedStorageDocumentServiceInterceptorForTesting::SharedStorageDelete(const ::std::u16string& key, SharedStorageDeleteCallback callback) {
  GetForwardingInterface()->SharedStorageDelete(std::move(key), std::move(callback));
}
void SharedStorageDocumentServiceInterceptorForTesting::SharedStorageClear(SharedStorageClearCallback callback) {
  GetForwardingInterface()->SharedStorageClear(std::move(callback));
}
SharedStorageDocumentServiceAsyncWaiter::SharedStorageDocumentServiceAsyncWaiter(
    SharedStorageDocumentService* proxy) : proxy_(proxy) {}

SharedStorageDocumentServiceAsyncWaiter::~SharedStorageDocumentServiceAsyncWaiter() = default;

void SharedStorageDocumentServiceAsyncWaiter::AddModuleOnWorklet(
    const ::GURL& script_source_url, bool* out_success, std::string* out_error_message) {
  base::RunLoop loop;
  proxy_->AddModuleOnWorklet(std::move(script_source_url),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             bool success,
             const std::string& error_message) {*out_success = std::move(success);*out_error_message = std::move(error_message);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message));
  loop.Run();
}
void SharedStorageDocumentServiceAsyncWaiter::RunOperationOnWorklet(
    const std::string& name, const std::vector<uint8_t>& serialized_data, bool* out_success, std::string* out_error_message) {
  base::RunLoop loop;
  proxy_->RunOperationOnWorklet(std::move(name),std::move(serialized_data),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             bool success,
             const std::string& error_message) {*out_success = std::move(success);*out_error_message = std::move(error_message);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message));
  loop.Run();
}
void SharedStorageDocumentServiceAsyncWaiter::RunURLSelectionOperationOnWorklet(
    const std::string& name, std::vector<SharedStorageUrlWithMetadataPtr> urls_with_metadata, const std::vector<uint8_t>& serialized_data, bool* out_success, std::string* out_error_message, ::GURL* out_opaque_url) {
  base::RunLoop loop;
  proxy_->RunURLSelectionOperationOnWorklet(std::move(name),std::move(urls_with_metadata),std::move(serialized_data),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             ::GURL* out_opaque_url
,
             bool success,
             const std::string& error_message,
             const ::GURL& opaque_url) {*out_success = std::move(success);*out_error_message = std::move(error_message);*out_opaque_url = std::move(opaque_url);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message,
          out_opaque_url));
  loop.Run();
}
void SharedStorageDocumentServiceAsyncWaiter::SharedStorageSet(
    const ::std::u16string& key, const ::std::u16string& value, bool ignore_if_present, bool* out_success, std::string* out_error_message) {
  base::RunLoop loop;
  proxy_->SharedStorageSet(std::move(key),std::move(value),std::move(ignore_if_present),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             bool success,
             const std::string& error_message) {*out_success = std::move(success);*out_error_message = std::move(error_message);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message));
  loop.Run();
}
void SharedStorageDocumentServiceAsyncWaiter::SharedStorageAppend(
    const ::std::u16string& key, const ::std::u16string& value, bool* out_success, std::string* out_error_message) {
  base::RunLoop loop;
  proxy_->SharedStorageAppend(std::move(key),std::move(value),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             bool success,
             const std::string& error_message) {*out_success = std::move(success);*out_error_message = std::move(error_message);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message));
  loop.Run();
}
void SharedStorageDocumentServiceAsyncWaiter::SharedStorageDelete(
    const ::std::u16string& key, bool* out_success, std::string* out_error_message) {
  base::RunLoop loop;
  proxy_->SharedStorageDelete(std::move(key),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             bool success,
             const std::string& error_message) {*out_success = std::move(success);*out_error_message = std::move(error_message);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message));
  loop.Run();
}
void SharedStorageDocumentServiceAsyncWaiter::SharedStorageClear(
    bool* out_success, std::string* out_error_message) {
  base::RunLoop loop;
  proxy_->SharedStorageClear(
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             std::string* out_error_message
,
             bool success,
             const std::string& error_message) {*out_success = std::move(success);*out_error_message = std::move(error_message);
            loop->Quit();
          },
          &loop,
          out_success,
          out_error_message));
  loop.Run();
}





}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif