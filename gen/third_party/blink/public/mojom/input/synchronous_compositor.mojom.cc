// third_party/blink/public/mojom/input/synchronous_compositor.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/input/synchronous_compositor.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/input/synchronous_compositor.mojom-params-data.h"
#include "third_party/blink/public/mojom/input/synchronous_compositor.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/input/synchronous_compositor.mojom-import-headers.h"
#include "third_party/blink/public/mojom/input/synchronous_compositor.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_SYNCHRONOUS_COMPOSITOR_MOJOM_JUMBO_H_
#include "services/viz/public/cpp/compositing/begin_frame_args_mojom_traits.h"
#include "services/viz/public/cpp/compositing/compositor_frame_mojom_traits.h"
#endif



namespace blink {
namespace mojom {
SyncCompositorDemandDrawHwParams::SyncCompositorDemandDrawHwParams()
    : viewport_size(),
      viewport_rect_for_tile_priority(),
      transform_for_tile_priority(),
      need_new_local_surface_id() {}

SyncCompositorDemandDrawHwParams::SyncCompositorDemandDrawHwParams(
    const ::gfx::Size& viewport_size_in,
    const ::gfx::Rect& viewport_rect_for_tile_priority_in,
    const ::gfx::Transform& transform_for_tile_priority_in,
    bool need_new_local_surface_id_in)
    : viewport_size(std::move(viewport_size_in)),
      viewport_rect_for_tile_priority(std::move(viewport_rect_for_tile_priority_in)),
      transform_for_tile_priority(std::move(transform_for_tile_priority_in)),
      need_new_local_surface_id(std::move(need_new_local_surface_id_in)) {}

SyncCompositorDemandDrawHwParams::~SyncCompositorDemandDrawHwParams() = default;

void SyncCompositorDemandDrawHwParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "viewport_size"), this->viewport_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "viewport_rect_for_tile_priority"), this->viewport_rect_for_tile_priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "transform_for_tile_priority"), this->transform_for_tile_priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Transform&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "need_new_local_surface_id"), this->need_new_local_surface_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SyncCompositorDemandDrawHwParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SyncCompositorDemandDrawSwParams::SyncCompositorDemandDrawSwParams()
    : size(),
      clip(),
      transform() {}

SyncCompositorDemandDrawSwParams::SyncCompositorDemandDrawSwParams(
    const ::gfx::Size& size_in,
    const ::gfx::Rect& clip_in,
    const ::gfx::Transform& transform_in)
    : size(std::move(size_in)),
      clip(std::move(clip_in)),
      transform(std::move(transform_in)) {}

SyncCompositorDemandDrawSwParams::~SyncCompositorDemandDrawSwParams() = default;

void SyncCompositorDemandDrawSwParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "size"), this->size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Size&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "clip"), this->clip,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Rect&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "transform"), this->transform,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::Transform&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SyncCompositorDemandDrawSwParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SyncCompositorCommonRendererParams::SyncCompositorCommonRendererParams()
    : version(0U),
      total_scroll_offset(),
      max_scroll_offset(),
      scrollable_size(),
      page_scale_factor(0),
      min_page_scale_factor(0),
      max_page_scale_factor(0),
      need_invalidate_count(0U),
      invalidate_needs_draw(true),
      did_activate_pending_tree_count(0U) {}

SyncCompositorCommonRendererParams::SyncCompositorCommonRendererParams(
    uint32_t version_in,
    const ::gfx::PointF& total_scroll_offset_in,
    const ::gfx::PointF& max_scroll_offset_in,
    const ::gfx::SizeF& scrollable_size_in,
    float page_scale_factor_in,
    float min_page_scale_factor_in,
    float max_page_scale_factor_in,
    uint32_t need_invalidate_count_in,
    bool invalidate_needs_draw_in,
    uint32_t did_activate_pending_tree_count_in)
    : version(std::move(version_in)),
      total_scroll_offset(std::move(total_scroll_offset_in)),
      max_scroll_offset(std::move(max_scroll_offset_in)),
      scrollable_size(std::move(scrollable_size_in)),
      page_scale_factor(std::move(page_scale_factor_in)),
      min_page_scale_factor(std::move(min_page_scale_factor_in)),
      max_page_scale_factor(std::move(max_page_scale_factor_in)),
      need_invalidate_count(std::move(need_invalidate_count_in)),
      invalidate_needs_draw(std::move(invalidate_needs_draw_in)),
      did_activate_pending_tree_count(std::move(did_activate_pending_tree_count_in)) {}

SyncCompositorCommonRendererParams::~SyncCompositorCommonRendererParams() = default;

void SyncCompositorCommonRendererParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "version"), this->version,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "total_scroll_offset"), this->total_scroll_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_scroll_offset"), this->max_scroll_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::PointF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "scrollable_size"), this->scrollable_size,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::gfx::SizeF&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "page_scale_factor"), this->page_scale_factor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "min_page_scale_factor"), this->min_page_scale_factor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "max_page_scale_factor"), this->max_page_scale_factor,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type float>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "need_invalidate_count"), this->need_invalidate_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "invalidate_needs_draw"), this->invalidate_needs_draw,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "did_activate_pending_tree_count"), this->did_activate_pending_tree_count,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SyncCompositorCommonRendererParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char SynchronousCompositor::Name_[] = "blink.mojom.SynchronousCompositor";

SynchronousCompositor::IPCStableHashFunction SynchronousCompositor::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSynchronousCompositor_DemandDrawHwAsync_Name: {
      return &SynchronousCompositor::DemandDrawHwAsync_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_DemandDrawHw_Name: {
      return &SynchronousCompositor::DemandDrawHw_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_SetSharedMemory_Name: {
      return &SynchronousCompositor::SetSharedMemory_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_DemandDrawSw_Name: {
      return &SynchronousCompositor::DemandDrawSw_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_WillSkipDraw_Name: {
      return &SynchronousCompositor::WillSkipDraw_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_ZeroSharedMemory_Name: {
      return &SynchronousCompositor::ZeroSharedMemory_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_ZoomBy_Name: {
      return &SynchronousCompositor::ZoomBy_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_SetMemoryPolicy_Name: {
      return &SynchronousCompositor::SetMemoryPolicy_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_ReclaimResources_Name: {
      return &SynchronousCompositor::ReclaimResources_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Name: {
      return &SynchronousCompositor::OnCompositorFrameTransitionDirectiveProcessed_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_SetScroll_Name: {
      return &SynchronousCompositor::SetScroll_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_BeginFrame_Name: {
      return &SynchronousCompositor::BeginFrame_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositor_SetBeginFrameSourcePaused_Name: {
      return &SynchronousCompositor::SetBeginFrameSourcePaused_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SynchronousCompositor::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSynchronousCompositor_DemandDrawHwAsync_Name:
            return "Receive blink::mojom::SynchronousCompositor::DemandDrawHwAsync";
      case internal::kSynchronousCompositor_DemandDrawHw_Name:
            return "Receive blink::mojom::SynchronousCompositor::DemandDrawHw";
      case internal::kSynchronousCompositor_SetSharedMemory_Name:
            return "Receive blink::mojom::SynchronousCompositor::SetSharedMemory";
      case internal::kSynchronousCompositor_DemandDrawSw_Name:
            return "Receive blink::mojom::SynchronousCompositor::DemandDrawSw";
      case internal::kSynchronousCompositor_WillSkipDraw_Name:
            return "Receive blink::mojom::SynchronousCompositor::WillSkipDraw";
      case internal::kSynchronousCompositor_ZeroSharedMemory_Name:
            return "Receive blink::mojom::SynchronousCompositor::ZeroSharedMemory";
      case internal::kSynchronousCompositor_ZoomBy_Name:
            return "Receive blink::mojom::SynchronousCompositor::ZoomBy";
      case internal::kSynchronousCompositor_SetMemoryPolicy_Name:
            return "Receive blink::mojom::SynchronousCompositor::SetMemoryPolicy";
      case internal::kSynchronousCompositor_ReclaimResources_Name:
            return "Receive blink::mojom::SynchronousCompositor::ReclaimResources";
      case internal::kSynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Name:
            return "Receive blink::mojom::SynchronousCompositor::OnCompositorFrameTransitionDirectiveProcessed";
      case internal::kSynchronousCompositor_SetScroll_Name:
            return "Receive blink::mojom::SynchronousCompositor::SetScroll";
      case internal::kSynchronousCompositor_BeginFrame_Name:
            return "Receive blink::mojom::SynchronousCompositor::BeginFrame";
      case internal::kSynchronousCompositor_SetBeginFrameSourcePaused_Name:
            return "Receive blink::mojom::SynchronousCompositor::SetBeginFrameSourcePaused";
    }
  } else {
    switch (message.name()) {
      case internal::kSynchronousCompositor_DemandDrawHwAsync_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::DemandDrawHwAsync";
      case internal::kSynchronousCompositor_DemandDrawHw_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::DemandDrawHw";
      case internal::kSynchronousCompositor_SetSharedMemory_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::SetSharedMemory";
      case internal::kSynchronousCompositor_DemandDrawSw_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::DemandDrawSw";
      case internal::kSynchronousCompositor_WillSkipDraw_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::WillSkipDraw";
      case internal::kSynchronousCompositor_ZeroSharedMemory_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::ZeroSharedMemory";
      case internal::kSynchronousCompositor_ZoomBy_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::ZoomBy";
      case internal::kSynchronousCompositor_SetMemoryPolicy_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::SetMemoryPolicy";
      case internal::kSynchronousCompositor_ReclaimResources_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::ReclaimResources";
      case internal::kSynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::OnCompositorFrameTransitionDirectiveProcessed";
      case internal::kSynchronousCompositor_SetScroll_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::SetScroll";
      case internal::kSynchronousCompositor_BeginFrame_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::BeginFrame";
      case internal::kSynchronousCompositor_SetBeginFrameSourcePaused_Name:
            return "Receive reply blink::mojom::SynchronousCompositor::SetBeginFrameSourcePaused";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SynchronousCompositor::DemandDrawHwAsync_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::DemandDrawHwAsync");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::DemandDrawHw_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::DemandDrawHw");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::SetSharedMemory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::SetSharedMemory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::DemandDrawSw_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::DemandDrawSw");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::WillSkipDraw_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::WillSkipDraw");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::ZeroSharedMemory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::ZeroSharedMemory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::ZoomBy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::ZoomBy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::SetMemoryPolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::SetMemoryPolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::ReclaimResources_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::ReclaimResources");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::OnCompositorFrameTransitionDirectiveProcessed_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::OnCompositorFrameTransitionDirectiveProcessed");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::SetScroll_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::SetScroll");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::BeginFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::BeginFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositor::SetBeginFrameSourcePaused_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositor::SetBeginFrameSourcePaused");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)
bool SynchronousCompositor::DemandDrawHw(SyncCompositorDemandDrawHwParamsPtr draw_params, SyncCompositorCommonRendererParamsPtr* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, absl::optional<::viz::LocalSurfaceId>* out_local_surface_id, absl::optional<::viz::CompositorFrame>* out_frame, absl::optional<::viz::HitTestRegionList>* out_hit_test_region_list) {
  NOTREACHED();
  return false;
}
bool SynchronousCompositor::SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, bool* out_success, SyncCompositorCommonRendererParamsPtr* out_result) {
  NOTREACHED();
  return false;
}
bool SynchronousCompositor::DemandDrawSw(SyncCompositorDemandDrawSwParamsPtr draw_params, SyncCompositorCommonRendererParamsPtr* out_result, uint32_t* out_metadata_version, absl::optional<::viz::CompositorFrameMetadata>* out_meta_data) {
  NOTREACHED();
  return false;
}
bool SynchronousCompositor::ZoomBy(float delta, const ::gfx::Point& anchor, SyncCompositorCommonRendererParamsPtr* out_result) {
  NOTREACHED();
  return false;
}
class SynchronousCompositor_DemandDrawHw_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_DemandDrawHw_HandleSyncResponse(
      bool* result, SyncCompositorCommonRendererParamsPtr* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, absl::optional<::viz::LocalSurfaceId>* out_local_surface_id, absl::optional<::viz::CompositorFrame>* out_frame, absl::optional<::viz::HitTestRegionList>* out_hit_test_region_list)
      : result_(result), out_result_(out_result), out_layer_tree_frame_sink_id_(out_layer_tree_frame_sink_id), out_metadata_version_(out_metadata_version), out_local_surface_id_(out_local_surface_id), out_frame_(out_frame), out_hit_test_region_list_(out_hit_test_region_list) {
    DCHECK(!*result_);
  }

  SynchronousCompositor_DemandDrawHw_HandleSyncResponse(const SynchronousCompositor_DemandDrawHw_HandleSyncResponse&) = delete;
  SynchronousCompositor_DemandDrawHw_HandleSyncResponse& operator=(const SynchronousCompositor_DemandDrawHw_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  SyncCompositorCommonRendererParamsPtr* out_result_;
  uint32_t* out_layer_tree_frame_sink_id_;
  uint32_t* out_metadata_version_;
  absl::optional<::viz::LocalSurfaceId>* out_local_surface_id_;
  absl::optional<::viz::CompositorFrame>* out_frame_;
  absl::optional<::viz::HitTestRegionList>* out_hit_test_region_list_;};

class SynchronousCompositor_DemandDrawHw_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_DemandDrawHw_ForwardToCallback(
      SynchronousCompositor::DemandDrawHwCallback callback
      ) : callback_(std::move(callback)) {
  }

  SynchronousCompositor_DemandDrawHw_ForwardToCallback(const SynchronousCompositor_DemandDrawHw_ForwardToCallback&) = delete;
  SynchronousCompositor_DemandDrawHw_ForwardToCallback& operator=(const SynchronousCompositor_DemandDrawHw_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SynchronousCompositor::DemandDrawHwCallback callback_;
};
class SynchronousCompositor_SetSharedMemory_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_SetSharedMemory_HandleSyncResponse(
      bool* result, bool* out_success, SyncCompositorCommonRendererParamsPtr* out_result)
      : result_(result), out_success_(out_success), out_result_(out_result) {
    DCHECK(!*result_);
  }

  SynchronousCompositor_SetSharedMemory_HandleSyncResponse(const SynchronousCompositor_SetSharedMemory_HandleSyncResponse&) = delete;
  SynchronousCompositor_SetSharedMemory_HandleSyncResponse& operator=(const SynchronousCompositor_SetSharedMemory_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;
  SyncCompositorCommonRendererParamsPtr* out_result_;};

class SynchronousCompositor_SetSharedMemory_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_SetSharedMemory_ForwardToCallback(
      SynchronousCompositor::SetSharedMemoryCallback callback
      ) : callback_(std::move(callback)) {
  }

  SynchronousCompositor_SetSharedMemory_ForwardToCallback(const SynchronousCompositor_SetSharedMemory_ForwardToCallback&) = delete;
  SynchronousCompositor_SetSharedMemory_ForwardToCallback& operator=(const SynchronousCompositor_SetSharedMemory_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SynchronousCompositor::SetSharedMemoryCallback callback_;
};
class SynchronousCompositor_DemandDrawSw_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_DemandDrawSw_HandleSyncResponse(
      bool* result, SyncCompositorCommonRendererParamsPtr* out_result, uint32_t* out_metadata_version, absl::optional<::viz::CompositorFrameMetadata>* out_meta_data)
      : result_(result), out_result_(out_result), out_metadata_version_(out_metadata_version), out_meta_data_(out_meta_data) {
    DCHECK(!*result_);
  }

  SynchronousCompositor_DemandDrawSw_HandleSyncResponse(const SynchronousCompositor_DemandDrawSw_HandleSyncResponse&) = delete;
  SynchronousCompositor_DemandDrawSw_HandleSyncResponse& operator=(const SynchronousCompositor_DemandDrawSw_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  SyncCompositorCommonRendererParamsPtr* out_result_;
  uint32_t* out_metadata_version_;
  absl::optional<::viz::CompositorFrameMetadata>* out_meta_data_;};

class SynchronousCompositor_DemandDrawSw_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_DemandDrawSw_ForwardToCallback(
      SynchronousCompositor::DemandDrawSwCallback callback
      ) : callback_(std::move(callback)) {
  }

  SynchronousCompositor_DemandDrawSw_ForwardToCallback(const SynchronousCompositor_DemandDrawSw_ForwardToCallback&) = delete;
  SynchronousCompositor_DemandDrawSw_ForwardToCallback& operator=(const SynchronousCompositor_DemandDrawSw_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SynchronousCompositor::DemandDrawSwCallback callback_;
};
class SynchronousCompositor_ZoomBy_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_ZoomBy_HandleSyncResponse(
      bool* result, SyncCompositorCommonRendererParamsPtr* out_result)
      : result_(result), out_result_(out_result) {
    DCHECK(!*result_);
  }

  SynchronousCompositor_ZoomBy_HandleSyncResponse(const SynchronousCompositor_ZoomBy_HandleSyncResponse&) = delete;
  SynchronousCompositor_ZoomBy_HandleSyncResponse& operator=(const SynchronousCompositor_ZoomBy_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  SyncCompositorCommonRendererParamsPtr* out_result_;};

class SynchronousCompositor_ZoomBy_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  SynchronousCompositor_ZoomBy_ForwardToCallback(
      SynchronousCompositor::ZoomByCallback callback
      ) : callback_(std::move(callback)) {
  }

  SynchronousCompositor_ZoomBy_ForwardToCallback(const SynchronousCompositor_ZoomBy_ForwardToCallback&) = delete;
  SynchronousCompositor_ZoomBy_ForwardToCallback& operator=(const SynchronousCompositor_ZoomBy_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  SynchronousCompositor::ZoomByCallback callback_;
};

SynchronousCompositorProxy::SynchronousCompositorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SynchronousCompositorProxy::DemandDrawHwAsync(
    SyncCompositorDemandDrawHwParamsPtr in_draw_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::DemandDrawHwAsync", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("draw_params"), in_draw_params,
                        "<value of type SyncCompositorDemandDrawHwParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawHwAsync_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawHwAsync_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->draw_params)::BaseType> draw_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorDemandDrawHwParamsDataView>(
      in_draw_params, draw_params_fragment);
  params->draw_params.Set(
      draw_params_fragment.is_null() ? nullptr : draw_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->draw_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null draw_params in SynchronousCompositor.DemandDrawHwAsync request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawHwAsync");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool SynchronousCompositorProxy::DemandDrawHw(
    SyncCompositorDemandDrawHwParamsPtr param_draw_params, SyncCompositorCommonRendererParamsPtr* out_param_result, uint32_t* out_param_layer_tree_frame_sink_id, uint32_t* out_param_metadata_version, absl::optional<::viz::LocalSurfaceId>* out_param_local_surface_id, absl::optional<::viz::CompositorFrame>* out_param_frame, absl::optional<::viz::HitTestRegionList>* out_param_hit_test_region_list) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::SynchronousCompositor::DemandDrawHw (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("draw_params"), param_draw_params,
                        "<value of type SyncCompositorDemandDrawHwParamsPtr>");
   });
#else
  TRACE_EVENT0("mojom", "SynchronousCompositor::DemandDrawHw");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawHw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawHw_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->draw_params)::BaseType> draw_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorDemandDrawHwParamsDataView>(
      param_draw_params, draw_params_fragment);
  params->draw_params.Set(
      draw_params_fragment.is_null() ? nullptr : draw_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->draw_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null draw_params in SynchronousCompositor.DemandDrawHw request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawHw");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_DemandDrawHw_HandleSyncResponse(
          &result, out_param_result, out_param_layer_tree_frame_sink_id, out_param_metadata_version, out_param_local_surface_id, out_param_frame, out_param_hit_test_region_list));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "SynchronousCompositor::DemandDrawHw", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), out_param_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("layer_tree_frame_sink_id"), out_param_layer_tree_frame_sink_id,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata_version"), out_param_metadata_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_surface_id"), out_param_local_surface_id,
                        "<value of type const absl::optional<::viz::LocalSurfaceId>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame"), out_param_frame,
                        "<value of type absl::optional<::viz::CompositorFrame>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("hit_test_region_list"), out_param_hit_test_region_list,
                        "<value of type absl::optional<::viz::HitTestRegionList>>");
   });
#endif
  return result;
}

void SynchronousCompositorProxy::DemandDrawHw(
    SyncCompositorDemandDrawHwParamsPtr in_draw_params, DemandDrawHwCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::DemandDrawHw", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("draw_params"), in_draw_params,
                        "<value of type SyncCompositorDemandDrawHwParamsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawHw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawHw_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->draw_params)::BaseType> draw_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorDemandDrawHwParamsDataView>(
      in_draw_params, draw_params_fragment);
  params->draw_params.Set(
      draw_params_fragment.is_null() ? nullptr : draw_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->draw_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null draw_params in SynchronousCompositor.DemandDrawHw request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawHw");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_DemandDrawHw_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool SynchronousCompositorProxy::SetSharedMemory(
    ::base::WritableSharedMemoryRegion param_shm_region, bool* out_param_success, SyncCompositorCommonRendererParamsPtr* out_param_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::SynchronousCompositor::SetSharedMemory (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("shm_region"), param_shm_region,
                        "<value of type ::base::WritableSharedMemoryRegion>");
   });
#else
  TRACE_EVENT0("mojom", "SynchronousCompositor::SetSharedMemory");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_SetSharedMemory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_SetSharedMemory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->shm_region)::BaseType> shm_region_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::WritableSharedMemoryRegionDataView>(
      param_shm_region, shm_region_fragment);
  params->shm_region.Set(
      shm_region_fragment.is_null() ? nullptr : shm_region_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->shm_region.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null shm_region in SynchronousCompositor.SetSharedMemory request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("SetSharedMemory");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_SetSharedMemory_HandleSyncResponse(
          &result, out_param_success, out_param_result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "SynchronousCompositor::SetSharedMemory", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), out_param_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), out_param_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
   });
#endif
  return result;
}

void SynchronousCompositorProxy::SetSharedMemory(
    ::base::WritableSharedMemoryRegion in_shm_region, SetSharedMemoryCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::SetSharedMemory", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("shm_region"), in_shm_region,
                        "<value of type ::base::WritableSharedMemoryRegion>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_SetSharedMemory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_SetSharedMemory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->shm_region)::BaseType> shm_region_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::WritableSharedMemoryRegionDataView>(
      in_shm_region, shm_region_fragment);
  params->shm_region.Set(
      shm_region_fragment.is_null() ? nullptr : shm_region_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->shm_region.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null shm_region in SynchronousCompositor.SetSharedMemory request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("SetSharedMemory");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_SetSharedMemory_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool SynchronousCompositorProxy::DemandDrawSw(
    SyncCompositorDemandDrawSwParamsPtr param_draw_params, SyncCompositorCommonRendererParamsPtr* out_param_result, uint32_t* out_param_metadata_version, absl::optional<::viz::CompositorFrameMetadata>* out_param_meta_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::SynchronousCompositor::DemandDrawSw (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("draw_params"), param_draw_params,
                        "<value of type SyncCompositorDemandDrawSwParamsPtr>");
   });
#else
  TRACE_EVENT0("mojom", "SynchronousCompositor::DemandDrawSw");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawSw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawSw_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->draw_params)::BaseType> draw_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorDemandDrawSwParamsDataView>(
      param_draw_params, draw_params_fragment);
  params->draw_params.Set(
      draw_params_fragment.is_null() ? nullptr : draw_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->draw_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null draw_params in SynchronousCompositor.DemandDrawSw request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawSw");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_DemandDrawSw_HandleSyncResponse(
          &result, out_param_result, out_param_metadata_version, out_param_meta_data));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "SynchronousCompositor::DemandDrawSw", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), out_param_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata_version"), out_param_metadata_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("meta_data"), out_param_meta_data,
                        "<value of type absl::optional<::viz::CompositorFrameMetadata>>");
   });
#endif
  return result;
}

void SynchronousCompositorProxy::DemandDrawSw(
    SyncCompositorDemandDrawSwParamsPtr in_draw_params, DemandDrawSwCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::DemandDrawSw", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("draw_params"), in_draw_params,
                        "<value of type SyncCompositorDemandDrawSwParamsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawSw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawSw_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->draw_params)::BaseType> draw_params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorDemandDrawSwParamsDataView>(
      in_draw_params, draw_params_fragment);
  params->draw_params.Set(
      draw_params_fragment.is_null() ? nullptr : draw_params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->draw_params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null draw_params in SynchronousCompositor.DemandDrawSw request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawSw");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_DemandDrawSw_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SynchronousCompositorProxy::WillSkipDraw(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::SynchronousCompositor::WillSkipDraw");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_WillSkipDraw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_WillSkipDraw_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("WillSkipDraw");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorProxy::ZeroSharedMemory(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::SynchronousCompositor::ZeroSharedMemory");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_ZeroSharedMemory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_ZeroSharedMemory_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("ZeroSharedMemory");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool SynchronousCompositorProxy::ZoomBy(
    float param_delta, const ::gfx::Point& param_anchor, SyncCompositorCommonRendererParamsPtr* out_param_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::SynchronousCompositor::ZoomBy (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("delta"), param_delta,
                        "<value of type float>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("anchor"), param_anchor,
                        "<value of type const ::gfx::Point&>");
   });
#else
  TRACE_EVENT0("mojom", "SynchronousCompositor::ZoomBy");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_ZoomBy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_ZoomBy_Params_Data> params(
          message);
  params.Allocate();
  params->delta = param_delta;
  mojo::internal::MessageFragment<
      typename decltype(params->anchor)::BaseType> anchor_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      param_anchor, anchor_fragment);
  params->anchor.Set(
      anchor_fragment.is_null() ? nullptr : anchor_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->anchor.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null anchor in SynchronousCompositor.ZoomBy request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("ZoomBy");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_ZoomBy_HandleSyncResponse(
          &result, out_param_result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "SynchronousCompositor::ZoomBy", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), out_param_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
   });
#endif
  return result;
}

void SynchronousCompositorProxy::ZoomBy(
    float in_delta, const ::gfx::Point& in_anchor, ZoomByCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::ZoomBy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("delta"), in_delta,
                        "<value of type float>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("anchor"), in_anchor,
                        "<value of type const ::gfx::Point&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_ZoomBy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_ZoomBy_Params_Data> params(
          message);
  params.Allocate();
  params->delta = in_delta;
  mojo::internal::MessageFragment<
      typename decltype(params->anchor)::BaseType> anchor_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_anchor, anchor_fragment);
  params->anchor.Set(
      anchor_fragment.is_null() ? nullptr : anchor_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->anchor.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null anchor in SynchronousCompositor.ZoomBy request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("ZoomBy");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new SynchronousCompositor_ZoomBy_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void SynchronousCompositorProxy::SetMemoryPolicy(
    uint32_t in_bytes_limit) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::SetMemoryPolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bytes_limit"), in_bytes_limit,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_SetMemoryPolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_SetMemoryPolicy_Params_Data> params(
          message);
  params.Allocate();
  params->bytes_limit = in_bytes_limit;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("SetMemoryPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorProxy::ReclaimResources(
    uint32_t in_layer_tree_frame_sink_id, std::vector<::viz::ReturnedResource> in_resources) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::ReclaimResources", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("layer_tree_frame_sink_id"), in_layer_tree_frame_sink_id,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("resources"), in_resources,
                        "<value of type std::vector<::viz::ReturnedResource>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_ReclaimResources_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_ReclaimResources_Params_Data> params(
          message);
  params.Allocate();
  params->layer_tree_frame_sink_id = in_layer_tree_frame_sink_id;
  mojo::internal::MessageFragment<
      typename decltype(params->resources)::BaseType>
      resources_fragment(params.message());
  const mojo::internal::ContainerValidateParams resources_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::viz::mojom::ReturnedResourceDataView>>(
      in_resources, resources_fragment, &resources_validate_params);
  params->resources.Set(
      resources_fragment.is_null() ? nullptr : resources_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->resources.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null resources in SynchronousCompositor.ReclaimResources request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("ReclaimResources");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorProxy::OnCompositorFrameTransitionDirectiveProcessed(
    uint32_t in_layer_tree_frame_sink_id, uint32_t in_sequence_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::OnCompositorFrameTransitionDirectiveProcessed", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("layer_tree_frame_sink_id"), in_layer_tree_frame_sink_id,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("sequence_id"), in_sequence_id,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Params_Data> params(
          message);
  params.Allocate();
  params->layer_tree_frame_sink_id = in_layer_tree_frame_sink_id;
  params->sequence_id = in_sequence_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("OnCompositorFrameTransitionDirectiveProcessed");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorProxy::SetScroll(
    const ::gfx::PointF& in_offset) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::SetScroll", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type const ::gfx::PointF&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_SetScroll_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_SetScroll_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->offset)::BaseType> offset_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
      in_offset, offset_fragment);
  params->offset.Set(
      offset_fragment.is_null() ? nullptr : offset_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->offset.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null offset in SynchronousCompositor.SetScroll request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("SetScroll");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorProxy::BeginFrame(
    const ::viz::BeginFrameArgs& in_args, const base::flat_map<uint32_t, ::viz::FrameTimingDetails>& in_timing_details) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::BeginFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("args"), in_args,
                        "<value of type const ::viz::BeginFrameArgs&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timing_details"), in_timing_details,
                        "<value of type const base::flat_map<uint32_t, ::viz::FrameTimingDetails>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_BeginFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_BeginFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->args)::BaseType> args_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::BeginFrameArgsDataView>(
      in_args, args_fragment);
  params->args.Set(
      args_fragment.is_null() ? nullptr : args_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->args.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null args in SynchronousCompositor.BeginFrame request");
  mojo::internal::MessageFragment<
      typename decltype(params->timing_details)::BaseType>
      timing_details_fragment(params.message());
  const mojo::internal::ContainerValidateParams timing_details_validate_params(
      new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
  mojo::internal::Serialize<mojo::MapDataView<uint32_t, ::viz::mojom::FrameTimingDetailsDataView>>(
      in_timing_details, timing_details_fragment, &timing_details_validate_params);
  params->timing_details.Set(
      timing_details_fragment.is_null() ? nullptr : timing_details_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing_details.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing_details in SynchronousCompositor.BeginFrame request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("BeginFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorProxy::SetBeginFrameSourcePaused(
    bool in_paused) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositor::SetBeginFrameSourcePaused", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("paused"), in_paused,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_SetBeginFrameSourcePaused_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_SetBeginFrameSourcePaused_Params_Data> params(
          message);
  params.Allocate();
  params->paused = in_paused;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("SetBeginFrameSourcePaused");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class SynchronousCompositor_DemandDrawHw_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SynchronousCompositor::DemandDrawHwCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SynchronousCompositor_DemandDrawHw_ProxyToResponder> proxy(
        new SynchronousCompositor_DemandDrawHw_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SynchronousCompositor_DemandDrawHw_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SynchronousCompositor_DemandDrawHw_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SynchronousCompositor_DemandDrawHw_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SynchronousCompositor::DemandDrawHwCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      SyncCompositorCommonRendererParamsPtr in_result, uint32_t in_layer_tree_frame_sink_id, uint32_t in_metadata_version, const absl::optional<::viz::LocalSurfaceId>& in_local_surface_id, absl::optional<::viz::CompositorFrame> in_frame, absl::optional<::viz::HitTestRegionList> in_hit_test_region_list);
};

bool SynchronousCompositor_DemandDrawHw_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_DemandDrawHw_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SynchronousCompositor_DemandDrawHw_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SyncCompositorCommonRendererParamsPtr p_result{};
  uint32_t p_layer_tree_frame_sink_id{};
  uint32_t p_metadata_version{};
  absl::optional<::viz::LocalSurfaceId> p_local_surface_id{};
  absl::optional<::viz::CompositorFrame> p_frame{};
  absl::optional<::viz::HitTestRegionList> p_hit_test_region_list{};
  SynchronousCompositor_DemandDrawHw_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_layer_tree_frame_sink_id = input_data_view.layer_tree_frame_sink_id();
  if (success)
    p_metadata_version = input_data_view.metadata_version();
  if (success && !input_data_view.ReadLocalSurfaceId(&p_local_surface_id))
    success = false;
  if (success && !input_data_view.ReadFrame(&p_frame))
    success = false;
  if (success && !input_data_view.ReadHitTestRegionList(&p_hit_test_region_list))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_layer_tree_frame_sink_id), 
std::move(p_metadata_version), 
std::move(p_local_surface_id), 
std::move(p_frame), 
std::move(p_hit_test_region_list));
  return true;
}

void SynchronousCompositor_DemandDrawHw_ProxyToResponder::Run(
    SyncCompositorCommonRendererParamsPtr in_result, uint32_t in_layer_tree_frame_sink_id, uint32_t in_metadata_version, const absl::optional<::viz::LocalSurfaceId>& in_local_surface_id, absl::optional<::viz::CompositorFrame> in_frame, absl::optional<::viz::HitTestRegionList> in_hit_test_region_list) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SynchronousCompositor::DemandDrawHw", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("layer_tree_frame_sink_id"), in_layer_tree_frame_sink_id,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata_version"), in_metadata_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_surface_id"), in_local_surface_id,
                        "<value of type const absl::optional<::viz::LocalSurfaceId>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame"), in_frame,
                        "<value of type absl::optional<::viz::CompositorFrame>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("hit_test_region_list"), in_hit_test_region_list,
                        "<value of type absl::optional<::viz::HitTestRegionList>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawHw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawHw_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorCommonRendererParamsDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  params->layer_tree_frame_sink_id = in_layer_tree_frame_sink_id;
  params->metadata_version = in_metadata_version;
  mojo::internal::MessageFragment<
      typename decltype(params->local_surface_id)::BaseType> local_surface_id_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::LocalSurfaceIdDataView>(
      in_local_surface_id, local_surface_id_fragment);
  params->local_surface_id.Set(
      local_surface_id_fragment.is_null() ? nullptr : local_surface_id_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->frame)::BaseType> frame_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::CompositorFrameDataView>(
      in_frame, frame_fragment);
  params->frame.Set(
      frame_fragment.is_null() ? nullptr : frame_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->hit_test_region_list)::BaseType> hit_test_region_list_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::HitTestRegionListDataView>(
      in_hit_test_region_list, hit_test_region_list_fragment);
  params->hit_test_region_list.Set(
      hit_test_region_list_fragment.is_null() ? nullptr : hit_test_region_list_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawHw");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SynchronousCompositor_DemandDrawHw_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_DemandDrawHw_ResponseParams_Data* params =
      reinterpret_cast<internal::SynchronousCompositor_DemandDrawHw_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  SyncCompositorCommonRendererParamsPtr p_result{};
  uint32_t p_layer_tree_frame_sink_id{};
  uint32_t p_metadata_version{};
  absl::optional<::viz::LocalSurfaceId> p_local_surface_id{};
  absl::optional<::viz::CompositorFrame> p_frame{};
  absl::optional<::viz::HitTestRegionList> p_hit_test_region_list{};
  SynchronousCompositor_DemandDrawHw_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_layer_tree_frame_sink_id = input_data_view.layer_tree_frame_sink_id();
  if (success)
    p_metadata_version = input_data_view.metadata_version();
  if (success && !input_data_view.ReadLocalSurfaceId(&p_local_surface_id))
    success = false;
  if (success && !input_data_view.ReadFrame(&p_frame))
    success = false;
  if (success && !input_data_view.ReadHitTestRegionList(&p_hit_test_region_list))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 1, true);
    return false;
  }
  *out_result_ = std::move(p_result);
  *out_layer_tree_frame_sink_id_ = std::move(p_layer_tree_frame_sink_id);
  *out_metadata_version_ = std::move(p_metadata_version);
  *out_local_surface_id_ = std::move(p_local_surface_id);
  *out_frame_ = std::move(p_frame);
  *out_hit_test_region_list_ = std::move(p_hit_test_region_list);
  *result_ = true;
  return true;
}
class SynchronousCompositor_SetSharedMemory_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SynchronousCompositor::SetSharedMemoryCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SynchronousCompositor_SetSharedMemory_ProxyToResponder> proxy(
        new SynchronousCompositor_SetSharedMemory_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SynchronousCompositor_SetSharedMemory_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SynchronousCompositor_SetSharedMemory_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SynchronousCompositor_SetSharedMemory_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SynchronousCompositor::SetSharedMemoryCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, SyncCompositorCommonRendererParamsPtr in_result);
};

bool SynchronousCompositor_SetSharedMemory_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_SetSharedMemory_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SynchronousCompositor_SetSharedMemory_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  SyncCompositorCommonRendererParamsPtr p_result{};
  SynchronousCompositor_SetSharedMemory_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_result));
  return true;
}

void SynchronousCompositor_SetSharedMemory_ProxyToResponder::Run(
    bool in_success, SyncCompositorCommonRendererParamsPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SynchronousCompositor::SetSharedMemory", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_SetSharedMemory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_SetSharedMemory_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorCommonRendererParamsDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("SetSharedMemory");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SynchronousCompositor_SetSharedMemory_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_SetSharedMemory_ResponseParams_Data* params =
      reinterpret_cast<internal::SynchronousCompositor_SetSharedMemory_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  SyncCompositorCommonRendererParamsPtr p_result{};
  SynchronousCompositor_SetSharedMemory_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 2, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  *out_result_ = std::move(p_result);
  *result_ = true;
  return true;
}
class SynchronousCompositor_DemandDrawSw_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SynchronousCompositor::DemandDrawSwCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SynchronousCompositor_DemandDrawSw_ProxyToResponder> proxy(
        new SynchronousCompositor_DemandDrawSw_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SynchronousCompositor_DemandDrawSw_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SynchronousCompositor_DemandDrawSw_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SynchronousCompositor_DemandDrawSw_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SynchronousCompositor::DemandDrawSwCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      SyncCompositorCommonRendererParamsPtr in_result, uint32_t in_metadata_version, absl::optional<::viz::CompositorFrameMetadata> in_meta_data);
};

bool SynchronousCompositor_DemandDrawSw_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_DemandDrawSw_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SynchronousCompositor_DemandDrawSw_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SyncCompositorCommonRendererParamsPtr p_result{};
  uint32_t p_metadata_version{};
  absl::optional<::viz::CompositorFrameMetadata> p_meta_data{};
  SynchronousCompositor_DemandDrawSw_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_metadata_version = input_data_view.metadata_version();
  if (success && !input_data_view.ReadMetaData(&p_meta_data))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result), 
std::move(p_metadata_version), 
std::move(p_meta_data));
  return true;
}

void SynchronousCompositor_DemandDrawSw_ProxyToResponder::Run(
    SyncCompositorCommonRendererParamsPtr in_result, uint32_t in_metadata_version, absl::optional<::viz::CompositorFrameMetadata> in_meta_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SynchronousCompositor::DemandDrawSw", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata_version"), in_metadata_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("meta_data"), in_meta_data,
                        "<value of type absl::optional<::viz::CompositorFrameMetadata>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_DemandDrawSw_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_DemandDrawSw_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorCommonRendererParamsDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");
  params->metadata_version = in_metadata_version;
  mojo::internal::MessageFragment<
      typename decltype(params->meta_data)::BaseType> meta_data_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::CompositorFrameMetadataDataView>(
      in_meta_data, meta_data_fragment);
  params->meta_data.Set(
      meta_data_fragment.is_null() ? nullptr : meta_data_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("DemandDrawSw");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SynchronousCompositor_DemandDrawSw_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_DemandDrawSw_ResponseParams_Data* params =
      reinterpret_cast<internal::SynchronousCompositor_DemandDrawSw_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  SyncCompositorCommonRendererParamsPtr p_result{};
  uint32_t p_metadata_version{};
  absl::optional<::viz::CompositorFrameMetadata> p_meta_data{};
  SynchronousCompositor_DemandDrawSw_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (success)
    p_metadata_version = input_data_view.metadata_version();
  if (success && !input_data_view.ReadMetaData(&p_meta_data))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 3, true);
    return false;
  }
  *out_result_ = std::move(p_result);
  *out_metadata_version_ = std::move(p_metadata_version);
  *out_meta_data_ = std::move(p_meta_data);
  *result_ = true;
  return true;
}
class SynchronousCompositor_ZoomBy_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static SynchronousCompositor::ZoomByCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<SynchronousCompositor_ZoomBy_ProxyToResponder> proxy(
        new SynchronousCompositor_ZoomBy_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&SynchronousCompositor_ZoomBy_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~SynchronousCompositor_ZoomBy_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  SynchronousCompositor_ZoomBy_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "SynchronousCompositor::ZoomByCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      SyncCompositorCommonRendererParamsPtr in_result);
};

bool SynchronousCompositor_ZoomBy_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_ZoomBy_ResponseParams_Data* params =
      reinterpret_cast<
          internal::SynchronousCompositor_ZoomBy_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  SyncCompositorCommonRendererParamsPtr p_result{};
  SynchronousCompositor_ZoomBy_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void SynchronousCompositor_ZoomBy_ProxyToResponder::Run(
    SyncCompositorCommonRendererParamsPtr in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::SynchronousCompositor::ZoomBy", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositor_ZoomBy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositor_ZoomBy_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorCommonRendererParamsDataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositor::Name_);
  message.set_method_name("ZoomBy");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool SynchronousCompositor_ZoomBy_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::SynchronousCompositor_ZoomBy_ResponseParams_Data* params =
      reinterpret_cast<internal::SynchronousCompositor_ZoomBy_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  SyncCompositorCommonRendererParamsPtr p_result{};
  SynchronousCompositor_ZoomBy_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        SynchronousCompositor::Name_, 6, true);
    return false;
  }
  *out_result_ = std::move(p_result);
  *result_ = true;
  return true;
}

// static
bool SynchronousCompositorStubDispatch::Accept(
    SynchronousCompositor* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSynchronousCompositor_DemandDrawHwAsync_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_DemandDrawHwAsync_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_DemandDrawHwAsync_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SyncCompositorDemandDrawHwParamsPtr p_draw_params{};
      SynchronousCompositor_DemandDrawHwAsync_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDrawParams(&p_draw_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DemandDrawHwAsync(
std::move(p_draw_params));
      return true;
    }
    case internal::kSynchronousCompositor_DemandDrawHw_Name: {
      break;
    }
    case internal::kSynchronousCompositor_SetSharedMemory_Name: {
      break;
    }
    case internal::kSynchronousCompositor_DemandDrawSw_Name: {
      break;
    }
    case internal::kSynchronousCompositor_WillSkipDraw_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_WillSkipDraw_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_WillSkipDraw_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SynchronousCompositor_WillSkipDraw_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WillSkipDraw();
      return true;
    }
    case internal::kSynchronousCompositor_ZeroSharedMemory_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_ZeroSharedMemory_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_ZeroSharedMemory_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SynchronousCompositor_ZeroSharedMemory_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ZeroSharedMemory();
      return true;
    }
    case internal::kSynchronousCompositor_ZoomBy_Name: {
      break;
    }
    case internal::kSynchronousCompositor_SetMemoryPolicy_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_SetMemoryPolicy_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_SetMemoryPolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_bytes_limit{};
      SynchronousCompositor_SetMemoryPolicy_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_bytes_limit = input_data_view.bytes_limit();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetMemoryPolicy(
std::move(p_bytes_limit));
      return true;
    }
    case internal::kSynchronousCompositor_ReclaimResources_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_ReclaimResources_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_ReclaimResources_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_layer_tree_frame_sink_id{};
      std::vector<::viz::ReturnedResource> p_resources{};
      SynchronousCompositor_ReclaimResources_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_layer_tree_frame_sink_id = input_data_view.layer_tree_frame_sink_id();
      if (success && !input_data_view.ReadResources(&p_resources))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReclaimResources(
std::move(p_layer_tree_frame_sink_id), 
std::move(p_resources));
      return true;
    }
    case internal::kSynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_layer_tree_frame_sink_id{};
      uint32_t p_sequence_id{};
      SynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_layer_tree_frame_sink_id = input_data_view.layer_tree_frame_sink_id();
      if (success)
        p_sequence_id = input_data_view.sequence_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnCompositorFrameTransitionDirectiveProcessed(
std::move(p_layer_tree_frame_sink_id), 
std::move(p_sequence_id));
      return true;
    }
    case internal::kSynchronousCompositor_SetScroll_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_SetScroll_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_SetScroll_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::PointF p_offset{};
      SynchronousCompositor_SetScroll_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOffset(&p_offset))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetScroll(
std::move(p_offset));
      return true;
    }
    case internal::kSynchronousCompositor_BeginFrame_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_BeginFrame_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_BeginFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::viz::BeginFrameArgs p_args{};
      base::flat_map<uint32_t, ::viz::FrameTimingDetails> p_timing_details{};
      SynchronousCompositor_BeginFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadArgs(&p_args))
        success = false;
      if (success && !input_data_view.ReadTimingDetails(&p_timing_details))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BeginFrame(
std::move(p_args), 
std::move(p_timing_details));
      return true;
    }
    case internal::kSynchronousCompositor_SetBeginFrameSourcePaused_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositor_SetBeginFrameSourcePaused_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositor_SetBeginFrameSourcePaused_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_paused{};
      SynchronousCompositor_SetBeginFrameSourcePaused_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_paused = input_data_view.paused();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetBeginFrameSourcePaused(
std::move(p_paused));
      return true;
    }
  }
  return false;
}

// static
bool SynchronousCompositorStubDispatch::AcceptWithResponder(
    SynchronousCompositor* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSynchronousCompositor_DemandDrawHwAsync_Name: {
      break;
    }
    case internal::kSynchronousCompositor_DemandDrawHw_Name: {

      internal::SynchronousCompositor_DemandDrawHw_Params_Data* params =
          reinterpret_cast<
              internal::SynchronousCompositor_DemandDrawHw_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SyncCompositorDemandDrawHwParamsPtr p_draw_params{};
      SynchronousCompositor_DemandDrawHw_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDrawParams(&p_draw_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 1, false);
        return false;
      }
      SynchronousCompositor::DemandDrawHwCallback callback =
          SynchronousCompositor_DemandDrawHw_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DemandDrawHw(
std::move(p_draw_params), std::move(callback));
      return true;
    }
    case internal::kSynchronousCompositor_SetSharedMemory_Name: {

      internal::SynchronousCompositor_SetSharedMemory_Params_Data* params =
          reinterpret_cast<
              internal::SynchronousCompositor_SetSharedMemory_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::base::WritableSharedMemoryRegion p_shm_region{};
      SynchronousCompositor_SetSharedMemory_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadShmRegion(&p_shm_region))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 2, false);
        return false;
      }
      SynchronousCompositor::SetSharedMemoryCallback callback =
          SynchronousCompositor_SetSharedMemory_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetSharedMemory(
std::move(p_shm_region), std::move(callback));
      return true;
    }
    case internal::kSynchronousCompositor_DemandDrawSw_Name: {

      internal::SynchronousCompositor_DemandDrawSw_Params_Data* params =
          reinterpret_cast<
              internal::SynchronousCompositor_DemandDrawSw_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      SyncCompositorDemandDrawSwParamsPtr p_draw_params{};
      SynchronousCompositor_DemandDrawSw_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDrawParams(&p_draw_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 3, false);
        return false;
      }
      SynchronousCompositor::DemandDrawSwCallback callback =
          SynchronousCompositor_DemandDrawSw_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DemandDrawSw(
std::move(p_draw_params), std::move(callback));
      return true;
    }
    case internal::kSynchronousCompositor_WillSkipDraw_Name: {
      break;
    }
    case internal::kSynchronousCompositor_ZeroSharedMemory_Name: {
      break;
    }
    case internal::kSynchronousCompositor_ZoomBy_Name: {

      internal::SynchronousCompositor_ZoomBy_Params_Data* params =
          reinterpret_cast<
              internal::SynchronousCompositor_ZoomBy_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      float p_delta{};
      ::gfx::Point p_anchor{};
      SynchronousCompositor_ZoomBy_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_delta = input_data_view.delta();
      if (success && !input_data_view.ReadAnchor(&p_anchor))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositor::Name_, 6, false);
        return false;
      }
      SynchronousCompositor::ZoomByCallback callback =
          SynchronousCompositor_ZoomBy_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ZoomBy(
std::move(p_delta), 
std::move(p_anchor), std::move(callback));
      return true;
    }
    case internal::kSynchronousCompositor_SetMemoryPolicy_Name: {
      break;
    }
    case internal::kSynchronousCompositor_ReclaimResources_Name: {
      break;
    }
    case internal::kSynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Name: {
      break;
    }
    case internal::kSynchronousCompositor_SetScroll_Name: {
      break;
    }
    case internal::kSynchronousCompositor_BeginFrame_Name: {
      break;
    }
    case internal::kSynchronousCompositor_SetBeginFrameSourcePaused_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSynchronousCompositorValidationInfo[] = {
    {&internal::SynchronousCompositor_DemandDrawHwAsync_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_DemandDrawHw_Params_Data::Validate,
     &internal::SynchronousCompositor_DemandDrawHw_ResponseParams_Data::Validate},
    {&internal::SynchronousCompositor_SetSharedMemory_Params_Data::Validate,
     &internal::SynchronousCompositor_SetSharedMemory_ResponseParams_Data::Validate},
    {&internal::SynchronousCompositor_DemandDrawSw_Params_Data::Validate,
     &internal::SynchronousCompositor_DemandDrawSw_ResponseParams_Data::Validate},
    {&internal::SynchronousCompositor_WillSkipDraw_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_ZeroSharedMemory_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_ZoomBy_Params_Data::Validate,
     &internal::SynchronousCompositor_ZoomBy_ResponseParams_Data::Validate},
    {&internal::SynchronousCompositor_SetMemoryPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_ReclaimResources_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_OnCompositorFrameTransitionDirectiveProcessed_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_SetScroll_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_BeginFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositor_SetBeginFrameSourcePaused_Params_Data::Validate,
     nullptr /* no response */},
};

bool SynchronousCompositorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::SynchronousCompositor::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSynchronousCompositorValidationInfo);
}

bool SynchronousCompositorResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::SynchronousCompositor::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kSynchronousCompositorValidationInfo);
}
const char SynchronousCompositorHost::Name_[] = "blink.mojom.SynchronousCompositorHost";

SynchronousCompositorHost::IPCStableHashFunction SynchronousCompositorHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSynchronousCompositorHost_LayerTreeFrameSinkCreated_Name: {
      return &SynchronousCompositorHost::LayerTreeFrameSinkCreated_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositorHost_UpdateState_Name: {
      return &SynchronousCompositorHost::UpdateState_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositorHost_SetNeedsBeginFrames_Name: {
      return &SynchronousCompositorHost::SetNeedsBeginFrames_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SynchronousCompositorHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSynchronousCompositorHost_LayerTreeFrameSinkCreated_Name:
            return "Receive blink::mojom::SynchronousCompositorHost::LayerTreeFrameSinkCreated";
      case internal::kSynchronousCompositorHost_UpdateState_Name:
            return "Receive blink::mojom::SynchronousCompositorHost::UpdateState";
      case internal::kSynchronousCompositorHost_SetNeedsBeginFrames_Name:
            return "Receive blink::mojom::SynchronousCompositorHost::SetNeedsBeginFrames";
    }
  } else {
    switch (message.name()) {
      case internal::kSynchronousCompositorHost_LayerTreeFrameSinkCreated_Name:
            return "Receive reply blink::mojom::SynchronousCompositorHost::LayerTreeFrameSinkCreated";
      case internal::kSynchronousCompositorHost_UpdateState_Name:
            return "Receive reply blink::mojom::SynchronousCompositorHost::UpdateState";
      case internal::kSynchronousCompositorHost_SetNeedsBeginFrames_Name:
            return "Receive reply blink::mojom::SynchronousCompositorHost::SetNeedsBeginFrames";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SynchronousCompositorHost::LayerTreeFrameSinkCreated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositorHost::LayerTreeFrameSinkCreated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositorHost::UpdateState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositorHost::UpdateState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositorHost::SetNeedsBeginFrames_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositorHost::SetNeedsBeginFrames");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

SynchronousCompositorHostProxy::SynchronousCompositorHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SynchronousCompositorHostProxy::LayerTreeFrameSinkCreated(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::SynchronousCompositorHost::LayerTreeFrameSinkCreated");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositorHost_LayerTreeFrameSinkCreated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositorHost_LayerTreeFrameSinkCreated_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositorHost::Name_);
  message.set_method_name("LayerTreeFrameSinkCreated");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorHostProxy::UpdateState(
    SyncCompositorCommonRendererParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositorHost::UpdateState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositorHost_UpdateState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositorHost_UpdateState_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorCommonRendererParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in SynchronousCompositorHost.UpdateState request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositorHost::Name_);
  message.set_method_name("UpdateState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorHostProxy::SetNeedsBeginFrames(
    bool in_needs_begin_frames) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositorHost::SetNeedsBeginFrames", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("needs_begin_frames"), in_needs_begin_frames,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositorHost_SetNeedsBeginFrames_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositorHost_SetNeedsBeginFrames_Params_Data> params(
          message);
  params.Allocate();
  params->needs_begin_frames = in_needs_begin_frames;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositorHost::Name_);
  message.set_method_name("SetNeedsBeginFrames");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool SynchronousCompositorHostStubDispatch::Accept(
    SynchronousCompositorHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSynchronousCompositorHost_LayerTreeFrameSinkCreated_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositorHost_LayerTreeFrameSinkCreated_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositorHost_LayerTreeFrameSinkCreated_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SynchronousCompositorHost_LayerTreeFrameSinkCreated_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositorHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->LayerTreeFrameSinkCreated();
      return true;
    }
    case internal::kSynchronousCompositorHost_UpdateState_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositorHost_UpdateState_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositorHost_UpdateState_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SyncCompositorCommonRendererParamsPtr p_params{};
      SynchronousCompositorHost_UpdateState_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositorHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateState(
std::move(p_params));
      return true;
    }
    case internal::kSynchronousCompositorHost_SetNeedsBeginFrames_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositorHost_SetNeedsBeginFrames_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositorHost_SetNeedsBeginFrames_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_needs_begin_frames{};
      SynchronousCompositorHost_SetNeedsBeginFrames_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_needs_begin_frames = input_data_view.needs_begin_frames();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositorHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNeedsBeginFrames(
std::move(p_needs_begin_frames));
      return true;
    }
  }
  return false;
}

// static
bool SynchronousCompositorHostStubDispatch::AcceptWithResponder(
    SynchronousCompositorHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSynchronousCompositorHost_LayerTreeFrameSinkCreated_Name: {
      break;
    }
    case internal::kSynchronousCompositorHost_UpdateState_Name: {
      break;
    }
    case internal::kSynchronousCompositorHost_SetNeedsBeginFrames_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSynchronousCompositorHostValidationInfo[] = {
    {&internal::SynchronousCompositorHost_LayerTreeFrameSinkCreated_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositorHost_UpdateState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositorHost_SetNeedsBeginFrames_Params_Data::Validate,
     nullptr /* no response */},
};

bool SynchronousCompositorHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::SynchronousCompositorHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSynchronousCompositorHostValidationInfo);
}

const char SynchronousCompositorControlHost::Name_[] = "blink.mojom.SynchronousCompositorControlHost";

SynchronousCompositorControlHost::IPCStableHashFunction SynchronousCompositorControlHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kSynchronousCompositorControlHost_ReturnFrame_Name: {
      return &SynchronousCompositorControlHost::ReturnFrame_Sym::IPCStableHash;
    }
    case internal::kSynchronousCompositorControlHost_BeginFrameResponse_Name: {
      return &SynchronousCompositorControlHost::BeginFrameResponse_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* SynchronousCompositorControlHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kSynchronousCompositorControlHost_ReturnFrame_Name:
            return "Receive blink::mojom::SynchronousCompositorControlHost::ReturnFrame";
      case internal::kSynchronousCompositorControlHost_BeginFrameResponse_Name:
            return "Receive blink::mojom::SynchronousCompositorControlHost::BeginFrameResponse";
    }
  } else {
    switch (message.name()) {
      case internal::kSynchronousCompositorControlHost_ReturnFrame_Name:
            return "Receive reply blink::mojom::SynchronousCompositorControlHost::ReturnFrame";
      case internal::kSynchronousCompositorControlHost_BeginFrameResponse_Name:
            return "Receive reply blink::mojom::SynchronousCompositorControlHost::BeginFrameResponse";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t SynchronousCompositorControlHost::ReturnFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositorControlHost::ReturnFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t SynchronousCompositorControlHost::BeginFrameResponse_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::SynchronousCompositorControlHost::BeginFrameResponse");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

SynchronousCompositorControlHostProxy::SynchronousCompositorControlHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void SynchronousCompositorControlHostProxy::ReturnFrame(
    uint32_t in_layer_tree_frame_sink_id, uint32_t in_metadata_version, const absl::optional<::viz::LocalSurfaceId>& in_local_surface_id, absl::optional<::viz::CompositorFrame> in_frame, absl::optional<::viz::HitTestRegionList> in_hit_test_region_list) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositorControlHost::ReturnFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("layer_tree_frame_sink_id"), in_layer_tree_frame_sink_id,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata_version"), in_metadata_version,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_surface_id"), in_local_surface_id,
                        "<value of type const absl::optional<::viz::LocalSurfaceId>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame"), in_frame,
                        "<value of type absl::optional<::viz::CompositorFrame>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("hit_test_region_list"), in_hit_test_region_list,
                        "<value of type absl::optional<::viz::HitTestRegionList>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositorControlHost_ReturnFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositorControlHost_ReturnFrame_Params_Data> params(
          message);
  params.Allocate();
  params->layer_tree_frame_sink_id = in_layer_tree_frame_sink_id;
  params->metadata_version = in_metadata_version;
  mojo::internal::MessageFragment<
      typename decltype(params->local_surface_id)::BaseType> local_surface_id_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::LocalSurfaceIdDataView>(
      in_local_surface_id, local_surface_id_fragment);
  params->local_surface_id.Set(
      local_surface_id_fragment.is_null() ? nullptr : local_surface_id_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->frame)::BaseType> frame_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::CompositorFrameDataView>(
      in_frame, frame_fragment);
  params->frame.Set(
      frame_fragment.is_null() ? nullptr : frame_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->hit_test_region_list)::BaseType> hit_test_region_list_fragment(
          params.message());
  mojo::internal::Serialize<::viz::mojom::HitTestRegionListDataView>(
      in_hit_test_region_list, hit_test_region_list_fragment);
  params->hit_test_region_list.Set(
      hit_test_region_list_fragment.is_null() ? nullptr : hit_test_region_list_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositorControlHost::Name_);
  message.set_method_name("ReturnFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void SynchronousCompositorControlHostProxy::BeginFrameResponse(
    SyncCompositorCommonRendererParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::SynchronousCompositorControlHost::BeginFrameResponse", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type SyncCompositorCommonRendererParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kSynchronousCompositorControlHost_BeginFrameResponse_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::SynchronousCompositorControlHost_BeginFrameResponse_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::SyncCompositorCommonRendererParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in SynchronousCompositorControlHost.BeginFrameResponse request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(SynchronousCompositorControlHost::Name_);
  message.set_method_name("BeginFrameResponse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool SynchronousCompositorControlHostStubDispatch::Accept(
    SynchronousCompositorControlHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kSynchronousCompositorControlHost_ReturnFrame_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositorControlHost_ReturnFrame_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositorControlHost_ReturnFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      uint32_t p_layer_tree_frame_sink_id{};
      uint32_t p_metadata_version{};
      absl::optional<::viz::LocalSurfaceId> p_local_surface_id{};
      absl::optional<::viz::CompositorFrame> p_frame{};
      absl::optional<::viz::HitTestRegionList> p_hit_test_region_list{};
      SynchronousCompositorControlHost_ReturnFrame_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_layer_tree_frame_sink_id = input_data_view.layer_tree_frame_sink_id();
      if (success)
        p_metadata_version = input_data_view.metadata_version();
      if (success && !input_data_view.ReadLocalSurfaceId(&p_local_surface_id))
        success = false;
      if (success && !input_data_view.ReadFrame(&p_frame))
        success = false;
      if (success && !input_data_view.ReadHitTestRegionList(&p_hit_test_region_list))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositorControlHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReturnFrame(
std::move(p_layer_tree_frame_sink_id), 
std::move(p_metadata_version), 
std::move(p_local_surface_id), 
std::move(p_frame), 
std::move(p_hit_test_region_list));
      return true;
    }
    case internal::kSynchronousCompositorControlHost_BeginFrameResponse_Name: {

      DCHECK(message->is_serialized());
      internal::SynchronousCompositorControlHost_BeginFrameResponse_Params_Data* params =
          reinterpret_cast<internal::SynchronousCompositorControlHost_BeginFrameResponse_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      SyncCompositorCommonRendererParamsPtr p_params{};
      SynchronousCompositorControlHost_BeginFrameResponse_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            SynchronousCompositorControlHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BeginFrameResponse(
std::move(p_params));
      return true;
    }
  }
  return false;
}

// static
bool SynchronousCompositorControlHostStubDispatch::AcceptWithResponder(
    SynchronousCompositorControlHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kSynchronousCompositorControlHost_ReturnFrame_Name: {
      break;
    }
    case internal::kSynchronousCompositorControlHost_BeginFrameResponse_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kSynchronousCompositorControlHostValidationInfo[] = {
    {&internal::SynchronousCompositorControlHost_ReturnFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::SynchronousCompositorControlHost_BeginFrameResponse_Params_Data::Validate,
     nullptr /* no response */},
};

bool SynchronousCompositorControlHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::SynchronousCompositorControlHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kSynchronousCompositorControlHostValidationInfo);
}



}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::SyncCompositorDemandDrawHwParams::DataView, ::blink::mojom::SyncCompositorDemandDrawHwParamsPtr>::Read(
    ::blink::mojom::SyncCompositorDemandDrawHwParams::DataView input,
    ::blink::mojom::SyncCompositorDemandDrawHwParamsPtr* output) {
  bool success = true;
  ::blink::mojom::SyncCompositorDemandDrawHwParamsPtr result(::blink::mojom::SyncCompositorDemandDrawHwParams::New());
  
      if (success && !input.ReadViewportSize(&result->viewport_size))
        success = false;
      if (success && !input.ReadViewportRectForTilePriority(&result->viewport_rect_for_tile_priority))
        success = false;
      if (success && !input.ReadTransformForTilePriority(&result->transform_for_tile_priority))
        success = false;
      if (success)
        result->need_new_local_surface_id = input.need_new_local_surface_id();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::SyncCompositorDemandDrawSwParams::DataView, ::blink::mojom::SyncCompositorDemandDrawSwParamsPtr>::Read(
    ::blink::mojom::SyncCompositorDemandDrawSwParams::DataView input,
    ::blink::mojom::SyncCompositorDemandDrawSwParamsPtr* output) {
  bool success = true;
  ::blink::mojom::SyncCompositorDemandDrawSwParamsPtr result(::blink::mojom::SyncCompositorDemandDrawSwParams::New());
  
      if (success && !input.ReadSize(&result->size))
        success = false;
      if (success && !input.ReadClip(&result->clip))
        success = false;
      if (success && !input.ReadTransform(&result->transform))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::SyncCompositorCommonRendererParams::DataView, ::blink::mojom::SyncCompositorCommonRendererParamsPtr>::Read(
    ::blink::mojom::SyncCompositorCommonRendererParams::DataView input,
    ::blink::mojom::SyncCompositorCommonRendererParamsPtr* output) {
  bool success = true;
  ::blink::mojom::SyncCompositorCommonRendererParamsPtr result(::blink::mojom::SyncCompositorCommonRendererParams::New());
  
      if (success)
        result->version = input.version();
      if (success && !input.ReadTotalScrollOffset(&result->total_scroll_offset))
        success = false;
      if (success && !input.ReadMaxScrollOffset(&result->max_scroll_offset))
        success = false;
      if (success && !input.ReadScrollableSize(&result->scrollable_size))
        success = false;
      if (success)
        result->page_scale_factor = input.page_scale_factor();
      if (success)
        result->min_page_scale_factor = input.min_page_scale_factor();
      if (success)
        result->max_page_scale_factor = input.max_page_scale_factor();
      if (success)
        result->need_invalidate_count = input.need_invalidate_count();
      if (success)
        result->invalidate_needs_draw = input.invalidate_needs_draw();
      if (success)
        result->did_activate_pending_tree_count = input.did_activate_pending_tree_count();
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void SynchronousCompositorInterceptorForTesting::DemandDrawHwAsync(SyncCompositorDemandDrawHwParamsPtr draw_params) {
  GetForwardingInterface()->DemandDrawHwAsync(std::move(draw_params));
}
void SynchronousCompositorInterceptorForTesting::DemandDrawHw(SyncCompositorDemandDrawHwParamsPtr draw_params, DemandDrawHwCallback callback) {
  GetForwardingInterface()->DemandDrawHw(std::move(draw_params), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::SetSharedMemory(::base::WritableSharedMemoryRegion shm_region, SetSharedMemoryCallback callback) {
  GetForwardingInterface()->SetSharedMemory(std::move(shm_region), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::DemandDrawSw(SyncCompositorDemandDrawSwParamsPtr draw_params, DemandDrawSwCallback callback) {
  GetForwardingInterface()->DemandDrawSw(std::move(draw_params), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::WillSkipDraw() {
  GetForwardingInterface()->WillSkipDraw();
}
void SynchronousCompositorInterceptorForTesting::ZeroSharedMemory() {
  GetForwardingInterface()->ZeroSharedMemory();
}
void SynchronousCompositorInterceptorForTesting::ZoomBy(float delta, const ::gfx::Point& anchor, ZoomByCallback callback) {
  GetForwardingInterface()->ZoomBy(std::move(delta), std::move(anchor), std::move(callback));
}
void SynchronousCompositorInterceptorForTesting::SetMemoryPolicy(uint32_t bytes_limit) {
  GetForwardingInterface()->SetMemoryPolicy(std::move(bytes_limit));
}
void SynchronousCompositorInterceptorForTesting::ReclaimResources(uint32_t layer_tree_frame_sink_id, std::vector<::viz::ReturnedResource> resources) {
  GetForwardingInterface()->ReclaimResources(std::move(layer_tree_frame_sink_id), std::move(resources));
}
void SynchronousCompositorInterceptorForTesting::OnCompositorFrameTransitionDirectiveProcessed(uint32_t layer_tree_frame_sink_id, uint32_t sequence_id) {
  GetForwardingInterface()->OnCompositorFrameTransitionDirectiveProcessed(std::move(layer_tree_frame_sink_id), std::move(sequence_id));
}
void SynchronousCompositorInterceptorForTesting::SetScroll(const ::gfx::PointF& offset) {
  GetForwardingInterface()->SetScroll(std::move(offset));
}
void SynchronousCompositorInterceptorForTesting::BeginFrame(const ::viz::BeginFrameArgs& args, const base::flat_map<uint32_t, ::viz::FrameTimingDetails>& timing_details) {
  GetForwardingInterface()->BeginFrame(std::move(args), std::move(timing_details));
}
void SynchronousCompositorInterceptorForTesting::SetBeginFrameSourcePaused(bool paused) {
  GetForwardingInterface()->SetBeginFrameSourcePaused(std::move(paused));
}
SynchronousCompositorAsyncWaiter::SynchronousCompositorAsyncWaiter(
    SynchronousCompositor* proxy) : proxy_(proxy) {}

SynchronousCompositorAsyncWaiter::~SynchronousCompositorAsyncWaiter() = default;

void SynchronousCompositorAsyncWaiter::DemandDrawHw(
    SyncCompositorDemandDrawHwParamsPtr draw_params, SyncCompositorCommonRendererParamsPtr* out_result, uint32_t* out_layer_tree_frame_sink_id, uint32_t* out_metadata_version, absl::optional<::viz::LocalSurfaceId>* out_local_surface_id, absl::optional<::viz::CompositorFrame>* out_frame, absl::optional<::viz::HitTestRegionList>* out_hit_test_region_list) {
  base::RunLoop loop;
  proxy_->DemandDrawHw(std::move(draw_params),
      base::BindOnce(
          [](base::RunLoop* loop,
             SyncCompositorCommonRendererParamsPtr* out_result
,
             uint32_t* out_layer_tree_frame_sink_id
,
             uint32_t* out_metadata_version
,
             absl::optional<::viz::LocalSurfaceId>* out_local_surface_id
,
             absl::optional<::viz::CompositorFrame>* out_frame
,
             absl::optional<::viz::HitTestRegionList>* out_hit_test_region_list
,
             SyncCompositorCommonRendererParamsPtr result,
             uint32_t layer_tree_frame_sink_id,
             uint32_t metadata_version,
             const absl::optional<::viz::LocalSurfaceId>& local_surface_id,
             absl::optional<::viz::CompositorFrame> frame,
             absl::optional<::viz::HitTestRegionList> hit_test_region_list) {*out_result = std::move(result);*out_layer_tree_frame_sink_id = std::move(layer_tree_frame_sink_id);*out_metadata_version = std::move(metadata_version);*out_local_surface_id = std::move(local_surface_id);*out_frame = std::move(frame);*out_hit_test_region_list = std::move(hit_test_region_list);
            loop->Quit();
          },
          &loop,
          out_result,
          out_layer_tree_frame_sink_id,
          out_metadata_version,
          out_local_surface_id,
          out_frame,
          out_hit_test_region_list));
  loop.Run();
}
void SynchronousCompositorAsyncWaiter::SetSharedMemory(
    ::base::WritableSharedMemoryRegion shm_region, bool* out_success, SyncCompositorCommonRendererParamsPtr* out_result) {
  base::RunLoop loop;
  proxy_->SetSharedMemory(std::move(shm_region),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             SyncCompositorCommonRendererParamsPtr* out_result
,
             bool success,
             SyncCompositorCommonRendererParamsPtr result) {*out_success = std::move(success);*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_success,
          out_result));
  loop.Run();
}
void SynchronousCompositorAsyncWaiter::DemandDrawSw(
    SyncCompositorDemandDrawSwParamsPtr draw_params, SyncCompositorCommonRendererParamsPtr* out_result, uint32_t* out_metadata_version, absl::optional<::viz::CompositorFrameMetadata>* out_meta_data) {
  base::RunLoop loop;
  proxy_->DemandDrawSw(std::move(draw_params),
      base::BindOnce(
          [](base::RunLoop* loop,
             SyncCompositorCommonRendererParamsPtr* out_result
,
             uint32_t* out_metadata_version
,
             absl::optional<::viz::CompositorFrameMetadata>* out_meta_data
,
             SyncCompositorCommonRendererParamsPtr result,
             uint32_t metadata_version,
             absl::optional<::viz::CompositorFrameMetadata> meta_data) {*out_result = std::move(result);*out_metadata_version = std::move(metadata_version);*out_meta_data = std::move(meta_data);
            loop->Quit();
          },
          &loop,
          out_result,
          out_metadata_version,
          out_meta_data));
  loop.Run();
}
void SynchronousCompositorAsyncWaiter::ZoomBy(
    float delta, const ::gfx::Point& anchor, SyncCompositorCommonRendererParamsPtr* out_result) {
  base::RunLoop loop;
  proxy_->ZoomBy(std::move(delta),std::move(anchor),
      base::BindOnce(
          [](base::RunLoop* loop,
             SyncCompositorCommonRendererParamsPtr* out_result
,
             SyncCompositorCommonRendererParamsPtr result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void SynchronousCompositorHostInterceptorForTesting::LayerTreeFrameSinkCreated() {
  GetForwardingInterface()->LayerTreeFrameSinkCreated();
}
void SynchronousCompositorHostInterceptorForTesting::UpdateState(SyncCompositorCommonRendererParamsPtr params) {
  GetForwardingInterface()->UpdateState(std::move(params));
}
void SynchronousCompositorHostInterceptorForTesting::SetNeedsBeginFrames(bool needs_begin_frames) {
  GetForwardingInterface()->SetNeedsBeginFrames(std::move(needs_begin_frames));
}
SynchronousCompositorHostAsyncWaiter::SynchronousCompositorHostAsyncWaiter(
    SynchronousCompositorHost* proxy) : proxy_(proxy) {}

SynchronousCompositorHostAsyncWaiter::~SynchronousCompositorHostAsyncWaiter() = default;




void SynchronousCompositorControlHostInterceptorForTesting::ReturnFrame(uint32_t layer_tree_frame_sink_id, uint32_t metadata_version, const absl::optional<::viz::LocalSurfaceId>& local_surface_id, absl::optional<::viz::CompositorFrame> frame, absl::optional<::viz::HitTestRegionList> hit_test_region_list) {
  GetForwardingInterface()->ReturnFrame(std::move(layer_tree_frame_sink_id), std::move(metadata_version), std::move(local_surface_id), std::move(frame), std::move(hit_test_region_list));
}
void SynchronousCompositorControlHostInterceptorForTesting::BeginFrameResponse(SyncCompositorCommonRendererParamsPtr params) {
  GetForwardingInterface()->BeginFrameResponse(std::move(params));
}
SynchronousCompositorControlHostAsyncWaiter::SynchronousCompositorControlHostAsyncWaiter(
    SynchronousCompositorControlHost* proxy) : proxy_(proxy) {}

SynchronousCompositorControlHostAsyncWaiter::~SynchronousCompositorControlHostAsyncWaiter() = default;






}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif