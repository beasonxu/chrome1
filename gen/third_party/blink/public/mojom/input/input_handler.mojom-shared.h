// third_party/blink/public/mojom/input/input_handler.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_INPUT_HANDLER_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_INPUT_HANDLER_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/input/input_handler.mojom-shared-internal.h"
#include "cc/mojom/overscroll_behavior.mojom-shared.h"
#include "cc/mojom/touch_action.mojom-shared.h"
#include "mojo/public/mojom/base/string16.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "third_party/blink/public/mojom/input/gesture_event.mojom-shared.h"
#include "third_party/blink/public/mojom/input/input_event.mojom-shared.h"
#include "third_party/blink/public/mojom/input/input_event_result.mojom-shared.h"
#include "third_party/blink/public/mojom/input/pointer_lock_context.mojom-shared.h"
#include "third_party/blink/public/mojom/input/pointer_lock_result.mojom-shared.h"
#include "third_party/blink/public/mojom/input/touch_event.mojom-shared.h"
#include "third_party/blink/public/mojom/selection_menu/selection_menu_behavior.mojom-shared.h"
#include "ui/base/ime/mojom/ime_types.mojom-shared.h"
#include "third_party/blink/public/mojom/input/stylus_writing_gesture.mojom-shared.h"
#include "ui/events/mojom/event.mojom-shared.h"
#include "ui/events/mojom/event_constants.mojom-shared.h"
#include "ui/events/mojom/scroll_granularity.mojom-shared.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "ui/gfx/range/mojom/range.mojom-shared.h"
#include "ui/latency/mojom/latency_info.mojom-shared.h"
#include "third_party/blink/public/mojom/input/synchronous_compositor.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "base/component_export.h"




namespace blink {
namespace mojom {
class KeyDataDataView;

class PointerDataDataView;

class WheelDataDataView;

class MouseDataDataView;

class ScrollUpdateDataView;

class ScrollDataDataView;

class PinchBeginDataDataView;

class PinchUpdateDataDataView;

class PinchEndDataDataView;

class FlingDataDataView;

class TapDataDataView;

class GestureDataDataView;

class TouchPointDataView;

class TouchDataDataView;

class EventDataView;

class DidOverscrollParamsDataView;

class TouchActionOptionalDataView;

class EditCommandDataView;

class SelectAroundCaretResultDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::KeyDataDataView> {
  using Data = ::blink::mojom::internal::KeyData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PointerDataDataView> {
  using Data = ::blink::mojom::internal::PointerData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::WheelDataDataView> {
  using Data = ::blink::mojom::internal::WheelData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::MouseDataDataView> {
  using Data = ::blink::mojom::internal::MouseData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::ScrollUpdateDataView> {
  using Data = ::blink::mojom::internal::ScrollUpdate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::ScrollDataDataView> {
  using Data = ::blink::mojom::internal::ScrollData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PinchBeginDataDataView> {
  using Data = ::blink::mojom::internal::PinchBeginData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PinchUpdateDataDataView> {
  using Data = ::blink::mojom::internal::PinchUpdateData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PinchEndDataDataView> {
  using Data = ::blink::mojom::internal::PinchEndData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::FlingDataDataView> {
  using Data = ::blink::mojom::internal::FlingData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::TapDataDataView> {
  using Data = ::blink::mojom::internal::TapData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::GestureDataDataView> {
  using Data = ::blink::mojom::internal::GestureData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::TouchPointDataView> {
  using Data = ::blink::mojom::internal::TouchPoint_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::TouchDataDataView> {
  using Data = ::blink::mojom::internal::TouchData_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::EventDataView> {
  using Data = ::blink::mojom::internal::Event_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::DidOverscrollParamsDataView> {
  using Data = ::blink::mojom::internal::DidOverscrollParams_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::TouchActionOptionalDataView> {
  using Data = ::blink::mojom::internal::TouchActionOptional_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::EditCommandDataView> {
  using Data = ::blink::mojom::internal::EditCommand_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::SelectAroundCaretResultDataView> {
  using Data = ::blink::mojom::internal::SelectAroundCaretResult_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class SelectionGranularity : int32_t {
  
  kWord = 0,
  
  kSentence = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, SelectionGranularity value);
inline bool IsKnownEnumValue(SelectionGranularity value) {
  return internal::SelectionGranularity_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class PanAction : int32_t {
  
  kNone = 0,
  
  kScroll = 1,
  
  kMoveCursorOrScroll = 2,
  
  kStylusWritable = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, PanAction value);
inline bool IsKnownEnumValue(PanAction value) {
  return internal::PanAction_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class FocusState : int32_t {
  
  kFocused = 0,
  
  kNotFocusedAndActive = 1,
  
  kNotFocusedAndNotActive = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, FocusState value);
inline bool IsKnownEnumValue(FocusState value) {
  return internal::FocusState_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class WidgetInputHandlerHostInterfaceBase {};

using WidgetInputHandlerHostPtrDataView =
    mojo::InterfacePtrDataView<WidgetInputHandlerHostInterfaceBase>;
using WidgetInputHandlerHostRequestDataView =
    mojo::InterfaceRequestDataView<WidgetInputHandlerHostInterfaceBase>;
using WidgetInputHandlerHostAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<WidgetInputHandlerHostInterfaceBase>;
using WidgetInputHandlerHostAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<WidgetInputHandlerHostInterfaceBase>;
class FrameWidgetInputHandlerInterfaceBase {};

using FrameWidgetInputHandlerPtrDataView =
    mojo::InterfacePtrDataView<FrameWidgetInputHandlerInterfaceBase>;
using FrameWidgetInputHandlerRequestDataView =
    mojo::InterfaceRequestDataView<FrameWidgetInputHandlerInterfaceBase>;
using FrameWidgetInputHandlerAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<FrameWidgetInputHandlerInterfaceBase>;
using FrameWidgetInputHandlerAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<FrameWidgetInputHandlerInterfaceBase>;
class WidgetInputHandlerInterfaceBase {};

using WidgetInputHandlerPtrDataView =
    mojo::InterfacePtrDataView<WidgetInputHandlerInterfaceBase>;
using WidgetInputHandlerRequestDataView =
    mojo::InterfaceRequestDataView<WidgetInputHandlerInterfaceBase>;
using WidgetInputHandlerAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<WidgetInputHandlerInterfaceBase>;
using WidgetInputHandlerAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<WidgetInputHandlerInterfaceBase>;


class KeyDataDataView {
 public:
  KeyDataDataView() = default;

  KeyDataDataView(
      internal::KeyData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t dom_key() const {
    return data_->dom_key;
  }
  int32_t dom_code() const {
    return data_->dom_code;
  }
  int32_t windows_key_code() const {
    return data_->windows_key_code;
  }
  int32_t native_key_code() const {
    return data_->native_key_code;
  }
  bool is_system_key() const {
    return data_->is_system_key;
  }
  bool is_browser_shortcut() const {
    return data_->is_browser_shortcut;
  }
  inline void GetTextDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadText(UserType* output) {
    
    auto* pointer = data_->text.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  inline void GetUnmodifiedTextDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUnmodifiedText(UserType* output) {
    
    auto* pointer = data_->unmodified_text.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
 private:
  internal::KeyData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PointerDataDataView {
 public:
  PointerDataDataView() = default;

  PointerDataDataView(
      internal::PointerData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t pointer_id() const {
    return data_->pointer_id;
  }
  float force() const {
    return data_->force;
  }
  int32_t tilt_x() const {
    return data_->tilt_x;
  }
  int32_t tilt_y() const {
    return data_->tilt_y;
  }
  float tangential_pressure() const {
    return data_->tangential_pressure;
  }
  int32_t twist() const {
    return data_->twist;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadButton(UserType* output) const {
    auto data_value = data_->button;
    return mojo::internal::Deserialize<::blink::mojom::Button>(
        data_value, output);
  }
  ::blink::mojom::Button button() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::Button>(data_->button));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadPointerType(UserType* output) const {
    auto data_value = data_->pointer_type;
    return mojo::internal::Deserialize<::ui::mojom::EventPointerType>(
        data_value, output);
  }
  ::ui::mojom::EventPointerType pointer_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::ui::mojom::EventPointerType>(data_->pointer_type));
  }
  int32_t movement_x() const {
    return data_->movement_x;
  }
  int32_t movement_y() const {
    return data_->movement_y;
  }
  bool is_raw_movement_event() const {
    return data_->is_raw_movement_event;
  }
  inline void GetWidgetPositionDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadWidgetPosition(UserType* output) {
    
    auto* pointer = data_->widget_position.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetScreenPositionDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadScreenPosition(UserType* output) {
    
    auto* pointer = data_->screen_position.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetMouseDataDataView(
      MouseDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMouseData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::MouseDataDataView, UserType>(),
    "Attempting to read the optional `mouse_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMouseData` instead "
    "of `ReadMouseData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->mouse_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::MouseDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::PointerData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class WheelDataDataView {
 public:
  WheelDataDataView() = default;

  WheelDataDataView(
      internal::WheelData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float delta_x() const {
    return data_->delta_x;
  }
  float delta_y() const {
    return data_->delta_y;
  }
  float wheel_ticks_x() const {
    return data_->wheel_ticks_x;
  }
  float wheel_ticks_y() const {
    return data_->wheel_ticks_y;
  }
  float acceleration_ratio_x() const {
    return data_->acceleration_ratio_x;
  }
  float acceleration_ratio_y() const {
    return data_->acceleration_ratio_y;
  }
  uint8_t phase() const {
    return data_->phase;
  }
  uint8_t momentum_phase() const {
    return data_->momentum_phase;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadCancelable(UserType* output) const {
    auto data_value = data_->cancelable;
    return mojo::internal::Deserialize<::blink::mojom::DispatchType>(
        data_value, output);
  }
  ::blink::mojom::DispatchType cancelable() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::DispatchType>(data_->cancelable));
  }
  uint8_t event_action() const {
    return data_->event_action;
  }
  uint8_t delta_units() const {
    return data_->delta_units;
  }
 private:
  internal::WheelData_Data* data_ = nullptr;
};



class MouseDataDataView {
 public:
  MouseDataDataView() = default;

  MouseDataDataView(
      internal::MouseData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t click_count() const {
    return data_->click_count;
  }
  inline void GetWheelDataDataView(
      WheelDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadWheelData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::WheelDataDataView, UserType>(),
    "Attempting to read the optional `wheel_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadWheelData` instead "
    "of `ReadWheelData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->wheel_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::WheelDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::MouseData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ScrollUpdateDataView {
 public:
  ScrollUpdateDataView() = default;

  ScrollUpdateDataView(
      internal::ScrollUpdate_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float velocity_x() const {
    return data_->velocity_x;
  }
  float velocity_y() const {
    return data_->velocity_y;
  }
 private:
  internal::ScrollUpdate_Data* data_ = nullptr;
};



class ScrollDataDataView {
 public:
  ScrollDataDataView() = default;

  ScrollDataDataView(
      internal::ScrollData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  float delta_x() const {
    return data_->delta_x;
  }
  float delta_y() const {
    return data_->delta_y;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadDeltaUnits(UserType* output) const {
    auto data_value = data_->delta_units;
    return mojo::internal::Deserialize<::ui::mojom::ScrollGranularity>(
        data_value, output);
  }
  ::ui::mojom::ScrollGranularity delta_units() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::ui::mojom::ScrollGranularity>(data_->delta_units));
  }
  bool target_viewport() const {
    return data_->target_viewport;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadInertialPhase(UserType* output) const {
    auto data_value = data_->inertial_phase;
    return mojo::internal::Deserialize<::blink::mojom::InertialPhaseState>(
        data_value, output);
  }
  ::blink::mojom::InertialPhaseState inertial_phase() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::InertialPhaseState>(data_->inertial_phase));
  }
  bool synthetic() const {
    return data_->synthetic;
  }
  int32_t pointer_count() const {
    return data_->pointer_count;
  }
  bool cursor_control() const {
    return data_->cursor_control;
  }
  inline void GetUpdateDetailsDataView(
      ScrollUpdateDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUpdateDetails(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::ScrollUpdateDataView, UserType>(),
    "Attempting to read the optional `update_details` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUpdateDetails` instead "
    "of `ReadUpdateDetails if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->update_details.Get();
    return mojo::internal::Deserialize<::blink::mojom::ScrollUpdateDataView>(
        pointer, output, message_);
  }
 private:
  internal::ScrollData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PinchBeginDataDataView {
 public:
  PinchBeginDataDataView() = default;

  PinchBeginDataDataView(
      internal::PinchBeginData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  bool needs_wheel_event() const {
    return data_->needs_wheel_event;
  }
 private:
  internal::PinchBeginData_Data* data_ = nullptr;
};



class PinchUpdateDataDataView {
 public:
  PinchUpdateDataDataView() = default;

  PinchUpdateDataDataView(
      internal::PinchUpdateData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float scale() const {
    return data_->scale;
  }
  bool zoom_disabled() const {
    return data_->zoom_disabled;
  }
  bool needs_wheel_event() const {
    return data_->needs_wheel_event;
  }
 private:
  internal::PinchUpdateData_Data* data_ = nullptr;
};



class PinchEndDataDataView {
 public:
  PinchEndDataDataView() = default;

  PinchEndDataDataView(
      internal::PinchEndData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  bool needs_wheel_event() const {
    return data_->needs_wheel_event;
  }
 private:
  internal::PinchEndData_Data* data_ = nullptr;
};



class FlingDataDataView {
 public:
  FlingDataDataView() = default;

  FlingDataDataView(
      internal::FlingData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  float velocity_x() const {
    return data_->velocity_x;
  }
  float velocity_y() const {
    return data_->velocity_y;
  }
  bool target_viewport() const {
    return data_->target_viewport;
  }
  bool prevent_boosting() const {
    return data_->prevent_boosting;
  }
 private:
  internal::FlingData_Data* data_ = nullptr;
};



class TapDataDataView {
 public:
  TapDataDataView() = default;

  TapDataDataView(
      internal::TapData_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t tap_count() const {
    return data_->tap_count;
  }
  bool needs_wheel_event() const {
    return data_->needs_wheel_event;
  }
 private:
  internal::TapData_Data* data_ = nullptr;
};



class GestureDataDataView {
 public:
  GestureDataDataView() = default;

  GestureDataDataView(
      internal::GestureData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetScreenPositionDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadScreenPosition(UserType* output) {
    
    auto* pointer = data_->screen_position.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetWidgetPositionDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadWidgetPosition(UserType* output) {
    
    auto* pointer = data_->widget_position.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadSourceDevice(UserType* output) const {
    auto data_value = data_->source_device;
    return mojo::internal::Deserialize<::blink::mojom::GestureDevice>(
        data_value, output);
  }
  ::blink::mojom::GestureDevice source_device() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::GestureDevice>(data_->source_device));
  }
  bool is_source_touch_event_set_blocking() const {
    return data_->is_source_touch_event_set_blocking;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryPointerType(UserType* output) const {
    auto data_value = data_->primary_pointer_type;
    return mojo::internal::Deserialize<::ui::mojom::EventPointerType>(
        data_value, output);
  }
  ::ui::mojom::EventPointerType primary_pointer_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::ui::mojom::EventPointerType>(data_->primary_pointer_type));
  }
  int32_t primary_unique_touch_event_id() const {
    return data_->primary_unique_touch_event_id;
  }
  int32_t unique_touch_event_id() const {
    return data_->unique_touch_event_id;
  }
  inline void GetContactSizeDataView(
      ::gfx::mojom::SizeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadContactSize(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::SizeDataView, UserType>(),
    "Attempting to read the optional `contact_size` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadContactSize` instead "
    "of `ReadContactSize if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->contact_size.Get();
    return mojo::internal::Deserialize<::gfx::mojom::SizeDataView>(
        pointer, output, message_);
  }
  inline void GetScrollDataDataView(
      ScrollDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadScrollData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::ScrollDataDataView, UserType>(),
    "Attempting to read the optional `scroll_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadScrollData` instead "
    "of `ReadScrollData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->scroll_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::ScrollDataDataView>(
        pointer, output, message_);
  }
  inline void GetPinchBeginDataDataView(
      PinchBeginDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPinchBeginData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::PinchBeginDataDataView, UserType>(),
    "Attempting to read the optional `pinch_begin_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPinchBeginData` instead "
    "of `ReadPinchBeginData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pinch_begin_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::PinchBeginDataDataView>(
        pointer, output, message_);
  }
  inline void GetPinchUpdateDataDataView(
      PinchUpdateDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPinchUpdateData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::PinchUpdateDataDataView, UserType>(),
    "Attempting to read the optional `pinch_update_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPinchUpdateData` instead "
    "of `ReadPinchUpdateData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pinch_update_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::PinchUpdateDataDataView>(
        pointer, output, message_);
  }
  inline void GetPinchEndDataDataView(
      PinchEndDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPinchEndData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::PinchEndDataDataView, UserType>(),
    "Attempting to read the optional `pinch_end_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPinchEndData` instead "
    "of `ReadPinchEndData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pinch_end_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::PinchEndDataDataView>(
        pointer, output, message_);
  }
  inline void GetTapDataDataView(
      TapDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTapData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::TapDataDataView, UserType>(),
    "Attempting to read the optional `tap_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTapData` instead "
    "of `ReadTapData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->tap_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::TapDataDataView>(
        pointer, output, message_);
  }
  inline void GetFlingDataDataView(
      FlingDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFlingData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::FlingDataDataView, UserType>(),
    "Attempting to read the optional `fling_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFlingData` instead "
    "of `ReadFlingData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->fling_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::FlingDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::GestureData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TouchPointDataView {
 public:
  TouchPointDataView() = default;

  TouchPointDataView(
      internal::TouchPoint_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadState(UserType* output) const {
    auto data_value = data_->state;
    return mojo::internal::Deserialize<::blink::mojom::TouchState>(
        data_value, output);
  }
  ::blink::mojom::TouchState state() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::TouchState>(data_->state));
  }
  float radius_x() const {
    return data_->radius_x;
  }
  float radius_y() const {
    return data_->radius_y;
  }
  float rotation_angle() const {
    return data_->rotation_angle;
  }
  inline void GetPointerDataDataView(
      PointerDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPointerData(UserType* output) {
    
    auto* pointer = data_->pointer_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::PointerDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::TouchPoint_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TouchDataDataView {
 public:
  TouchDataDataView() = default;

  TouchDataDataView(
      internal::TouchData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadCancelable(UserType* output) const {
    auto data_value = data_->cancelable;
    return mojo::internal::Deserialize<::blink::mojom::DispatchType>(
        data_value, output);
  }
  ::blink::mojom::DispatchType cancelable() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::DispatchType>(data_->cancelable));
  }
  bool moved_beyond_slop_region() const {
    return data_->moved_beyond_slop_region;
  }
  bool touch_start_or_first_move() const {
    return data_->touch_start_or_first_move;
  }
  bool hovering() const {
    return data_->hovering;
  }
  uint32_t unique_touch_event_id() const {
    return data_->unique_touch_event_id;
  }
  inline void GetTouchesDataView(
      mojo::ArrayDataView<TouchPointDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTouches(UserType* output) {
    
    auto* pointer = data_->touches.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::TouchPointDataView>>(
        pointer, output, message_);
  }
 private:
  internal::TouchData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class EventDataView {
 public:
  EventDataView() = default;

  EventDataView(
      internal::Event_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::blink::mojom::EventType>(
        data_value, output);
  }
  ::blink::mojom::EventType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::EventType>(data_->type));
  }
  int32_t modifiers() const {
    return data_->modifiers;
  }
  inline void GetTimestampDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimestamp(UserType* output) {
    
    auto* pointer = data_->timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  inline void GetLatencyDataView(
      ::ui::mojom::LatencyInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLatency(UserType* output) {
    
    auto* pointer = data_->latency.Get();
    return mojo::internal::Deserialize<::ui::mojom::LatencyInfoDataView>(
        pointer, output, message_);
  }
  inline void GetKeyDataDataView(
      KeyDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::KeyDataDataView, UserType>(),
    "Attempting to read the optional `key_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadKeyData` instead "
    "of `ReadKeyData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->key_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::KeyDataDataView>(
        pointer, output, message_);
  }
  inline void GetPointerDataDataView(
      PointerDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPointerData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::PointerDataDataView, UserType>(),
    "Attempting to read the optional `pointer_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPointerData` instead "
    "of `ReadPointerData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->pointer_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::PointerDataDataView>(
        pointer, output, message_);
  }
  inline void GetGestureDataDataView(
      GestureDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGestureData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::GestureDataDataView, UserType>(),
    "Attempting to read the optional `gesture_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadGestureData` instead "
    "of `ReadGestureData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->gesture_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::GestureDataDataView>(
        pointer, output, message_);
  }
  inline void GetTouchDataDataView(
      TouchDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTouchData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::TouchDataDataView, UserType>(),
    "Attempting to read the optional `touch_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTouchData` instead "
    "of `ReadTouchData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->touch_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::TouchDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::Event_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class DidOverscrollParamsDataView {
 public:
  DidOverscrollParamsDataView() = default;

  DidOverscrollParamsDataView(
      internal::DidOverscrollParams_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetAccumulatedOverscrollDataView(
      ::gfx::mojom::Vector2dFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAccumulatedOverscroll(UserType* output) {
    
    auto* pointer = data_->accumulated_overscroll.Get();
    return mojo::internal::Deserialize<::gfx::mojom::Vector2dFDataView>(
        pointer, output, message_);
  }
  inline void GetLatestOverscrollDeltaDataView(
      ::gfx::mojom::Vector2dFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLatestOverscrollDelta(UserType* output) {
    
    auto* pointer = data_->latest_overscroll_delta.Get();
    return mojo::internal::Deserialize<::gfx::mojom::Vector2dFDataView>(
        pointer, output, message_);
  }
  inline void GetCurrentFlingVelocityDataView(
      ::gfx::mojom::Vector2dFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCurrentFlingVelocity(UserType* output) {
    
    auto* pointer = data_->current_fling_velocity.Get();
    return mojo::internal::Deserialize<::gfx::mojom::Vector2dFDataView>(
        pointer, output, message_);
  }
  inline void GetCausalEventViewportPointDataView(
      ::gfx::mojom::PointFDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCausalEventViewportPoint(UserType* output) {
    
    auto* pointer = data_->causal_event_viewport_point.Get();
    return mojo::internal::Deserialize<::gfx::mojom::PointFDataView>(
        pointer, output, message_);
  }
  inline void GetOverscrollBehaviorDataView(
      ::cc::mojom::OverscrollBehaviorDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOverscrollBehavior(UserType* output) {
    
    auto* pointer = data_->overscroll_behavior.Get();
    return mojo::internal::Deserialize<::cc::mojom::OverscrollBehaviorDataView>(
        pointer, output, message_);
  }
 private:
  internal::DidOverscrollParams_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TouchActionOptionalDataView {
 public:
  TouchActionOptionalDataView() = default;

  TouchActionOptionalDataView(
      internal::TouchActionOptional_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadTouchAction(UserType* output) const {
    auto data_value = data_->touch_action;
    return mojo::internal::Deserialize<::cc::mojom::TouchAction>(
        data_value, output);
  }
  ::cc::mojom::TouchAction touch_action() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::cc::mojom::TouchAction>(data_->touch_action));
  }
 private:
  internal::TouchActionOptional_Data* data_ = nullptr;
};



class EditCommandDataView {
 public:
  EditCommandDataView() = default;

  EditCommandDataView(
      internal::EditCommand_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetValueDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
    auto* pointer = data_->value.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::EditCommand_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class SelectAroundCaretResultDataView {
 public:
  SelectAroundCaretResultDataView() = default;

  SelectAroundCaretResultDataView(
      internal::SelectAroundCaretResult_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  int32_t extended_start_adjust() const {
    return data_->extended_start_adjust;
  }
  int32_t extended_end_adjust() const {
    return data_->extended_end_adjust;
  }
  int32_t word_start_adjust() const {
    return data_->word_start_adjust;
  }
  int32_t word_end_adjust() const {
    return data_->word_end_adjust;
  }
 private:
  internal::SelectAroundCaretResult_Data* data_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::SelectionGranularity>
    : public mojo::internal::EnumHashImpl<::blink::mojom::SelectionGranularity> {};

template <>
struct hash<::blink::mojom::PanAction>
    : public mojo::internal::EnumHashImpl<::blink::mojom::PanAction> {};

template <>
struct hash<::blink::mojom::FocusState>
    : public mojo::internal::EnumHashImpl<::blink::mojom::FocusState> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::SelectionGranularity, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::SelectionGranularity, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::SelectionGranularity>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PanAction, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::PanAction, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::PanAction>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FocusState, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::FocusState, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::FocusState>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::KeyDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::KeyDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::KeyData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->dom_key = Traits::dom_key(input);
    fragment->dom_code = Traits::dom_code(input);
    fragment->windows_key_code = Traits::windows_key_code(input);
    fragment->native_key_code = Traits::native_key_code(input);
    fragment->is_system_key = Traits::is_system_key(input);
    fragment->is_browser_shortcut = Traits::is_browser_shortcut(input);
    decltype(Traits::text(input)) in_text = Traits::text(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->text)::BaseType> text_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_text, text_fragment);
    fragment->text.Set(
        text_fragment.is_null() ? nullptr : text_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->text.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null text in KeyData struct");
    decltype(Traits::unmodified_text(input)) in_unmodified_text = Traits::unmodified_text(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->unmodified_text)::BaseType> unmodified_text_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_unmodified_text, unmodified_text_fragment);
    fragment->unmodified_text.Set(
        unmodified_text_fragment.is_null() ? nullptr : unmodified_text_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->unmodified_text.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null unmodified_text in KeyData struct");
  }

  static bool Deserialize(::blink::mojom::internal::KeyData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::KeyDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PointerDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PointerDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PointerData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->pointer_id = Traits::pointer_id(input);
    fragment->force = Traits::force(input);
    fragment->tilt_x = Traits::tilt_x(input);
    fragment->tilt_y = Traits::tilt_y(input);
    fragment->tangential_pressure = Traits::tangential_pressure(input);
    fragment->twist = Traits::twist(input);
    mojo::internal::Serialize<::blink::mojom::Button>(
        Traits::button(input), &fragment->button);
    mojo::internal::Serialize<::ui::mojom::EventPointerType>(
        Traits::pointer_type(input), &fragment->pointer_type);
    fragment->movement_x = Traits::movement_x(input);
    fragment->movement_y = Traits::movement_y(input);
    fragment->is_raw_movement_event = Traits::is_raw_movement_event(input);
    decltype(Traits::widget_position(input)) in_widget_position = Traits::widget_position(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->widget_position)::BaseType> widget_position_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_widget_position, widget_position_fragment);
    fragment->widget_position.Set(
        widget_position_fragment.is_null() ? nullptr : widget_position_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->widget_position.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null widget_position in PointerData struct");
    decltype(Traits::screen_position(input)) in_screen_position = Traits::screen_position(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->screen_position)::BaseType> screen_position_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_screen_position, screen_position_fragment);
    fragment->screen_position.Set(
        screen_position_fragment.is_null() ? nullptr : screen_position_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->screen_position.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null screen_position in PointerData struct");
    decltype(Traits::mouse_data(input)) in_mouse_data = Traits::mouse_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mouse_data)::BaseType> mouse_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::MouseDataDataView>(
        in_mouse_data, mouse_data_fragment);
    fragment->mouse_data.Set(
        mouse_data_fragment.is_null() ? nullptr : mouse_data_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::PointerData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PointerDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::WheelDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::WheelDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::WheelData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->delta_x = Traits::delta_x(input);
    fragment->delta_y = Traits::delta_y(input);
    fragment->wheel_ticks_x = Traits::wheel_ticks_x(input);
    fragment->wheel_ticks_y = Traits::wheel_ticks_y(input);
    fragment->acceleration_ratio_x = Traits::acceleration_ratio_x(input);
    fragment->acceleration_ratio_y = Traits::acceleration_ratio_y(input);
    fragment->phase = Traits::phase(input);
    fragment->momentum_phase = Traits::momentum_phase(input);
    mojo::internal::Serialize<::blink::mojom::DispatchType>(
        Traits::cancelable(input), &fragment->cancelable);
    fragment->event_action = Traits::event_action(input);
    fragment->delta_units = Traits::delta_units(input);
  }

  static bool Deserialize(::blink::mojom::internal::WheelData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::WheelDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MouseDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::MouseDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::MouseData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->click_count = Traits::click_count(input);
    decltype(Traits::wheel_data(input)) in_wheel_data = Traits::wheel_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->wheel_data)::BaseType> wheel_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::WheelDataDataView>(
        in_wheel_data, wheel_data_fragment);
    fragment->wheel_data.Set(
        wheel_data_fragment.is_null() ? nullptr : wheel_data_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::MouseData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::MouseDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::ScrollUpdateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::ScrollUpdateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::ScrollUpdate_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->velocity_x = Traits::velocity_x(input);
    fragment->velocity_y = Traits::velocity_y(input);
  }

  static bool Deserialize(::blink::mojom::internal::ScrollUpdate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::ScrollUpdateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::ScrollDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::ScrollDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::ScrollData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->delta_x = Traits::delta_x(input);
    fragment->delta_y = Traits::delta_y(input);
    mojo::internal::Serialize<::ui::mojom::ScrollGranularity>(
        Traits::delta_units(input), &fragment->delta_units);
    fragment->target_viewport = Traits::target_viewport(input);
    mojo::internal::Serialize<::blink::mojom::InertialPhaseState>(
        Traits::inertial_phase(input), &fragment->inertial_phase);
    fragment->synthetic = Traits::synthetic(input);
    fragment->pointer_count = Traits::pointer_count(input);
    fragment->cursor_control = Traits::cursor_control(input);
    decltype(Traits::update_details(input)) in_update_details = Traits::update_details(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->update_details)::BaseType> update_details_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::ScrollUpdateDataView>(
        in_update_details, update_details_fragment);
    fragment->update_details.Set(
        update_details_fragment.is_null() ? nullptr : update_details_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::ScrollData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::ScrollDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PinchBeginDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PinchBeginDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PinchBeginData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->needs_wheel_event = Traits::needs_wheel_event(input);
  }

  static bool Deserialize(::blink::mojom::internal::PinchBeginData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PinchBeginDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PinchUpdateDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PinchUpdateDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PinchUpdateData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->scale = Traits::scale(input);
    fragment->zoom_disabled = Traits::zoom_disabled(input);
    fragment->needs_wheel_event = Traits::needs_wheel_event(input);
  }

  static bool Deserialize(::blink::mojom::internal::PinchUpdateData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PinchUpdateDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PinchEndDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PinchEndDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PinchEndData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->needs_wheel_event = Traits::needs_wheel_event(input);
  }

  static bool Deserialize(::blink::mojom::internal::PinchEndData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PinchEndDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::FlingDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::FlingDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::FlingData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->velocity_x = Traits::velocity_x(input);
    fragment->velocity_y = Traits::velocity_y(input);
    fragment->target_viewport = Traits::target_viewport(input);
    fragment->prevent_boosting = Traits::prevent_boosting(input);
  }

  static bool Deserialize(::blink::mojom::internal::FlingData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::FlingDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TapDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::TapDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::TapData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->tap_count = Traits::tap_count(input);
    fragment->needs_wheel_event = Traits::needs_wheel_event(input);
  }

  static bool Deserialize(::blink::mojom::internal::TapData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::TapDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::GestureDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::GestureDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::GestureData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::screen_position(input)) in_screen_position = Traits::screen_position(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->screen_position)::BaseType> screen_position_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_screen_position, screen_position_fragment);
    fragment->screen_position.Set(
        screen_position_fragment.is_null() ? nullptr : screen_position_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->screen_position.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null screen_position in GestureData struct");
    decltype(Traits::widget_position(input)) in_widget_position = Traits::widget_position(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->widget_position)::BaseType> widget_position_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_widget_position, widget_position_fragment);
    fragment->widget_position.Set(
        widget_position_fragment.is_null() ? nullptr : widget_position_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->widget_position.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null widget_position in GestureData struct");
    mojo::internal::Serialize<::blink::mojom::GestureDevice>(
        Traits::source_device(input), &fragment->source_device);
    fragment->is_source_touch_event_set_blocking = Traits::is_source_touch_event_set_blocking(input);
    mojo::internal::Serialize<::ui::mojom::EventPointerType>(
        Traits::primary_pointer_type(input), &fragment->primary_pointer_type);
    fragment->primary_unique_touch_event_id = Traits::primary_unique_touch_event_id(input);
    fragment->unique_touch_event_id = Traits::unique_touch_event_id(input);
    decltype(Traits::contact_size(input)) in_contact_size = Traits::contact_size(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->contact_size)::BaseType> contact_size_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
        in_contact_size, contact_size_fragment);
    fragment->contact_size.Set(
        contact_size_fragment.is_null() ? nullptr : contact_size_fragment.data());
    decltype(Traits::scroll_data(input)) in_scroll_data = Traits::scroll_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->scroll_data)::BaseType> scroll_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::ScrollDataDataView>(
        in_scroll_data, scroll_data_fragment);
    fragment->scroll_data.Set(
        scroll_data_fragment.is_null() ? nullptr : scroll_data_fragment.data());
    decltype(Traits::pinch_begin_data(input)) in_pinch_begin_data = Traits::pinch_begin_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pinch_begin_data)::BaseType> pinch_begin_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PinchBeginDataDataView>(
        in_pinch_begin_data, pinch_begin_data_fragment);
    fragment->pinch_begin_data.Set(
        pinch_begin_data_fragment.is_null() ? nullptr : pinch_begin_data_fragment.data());
    decltype(Traits::pinch_update_data(input)) in_pinch_update_data = Traits::pinch_update_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pinch_update_data)::BaseType> pinch_update_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PinchUpdateDataDataView>(
        in_pinch_update_data, pinch_update_data_fragment);
    fragment->pinch_update_data.Set(
        pinch_update_data_fragment.is_null() ? nullptr : pinch_update_data_fragment.data());
    decltype(Traits::pinch_end_data(input)) in_pinch_end_data = Traits::pinch_end_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pinch_end_data)::BaseType> pinch_end_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PinchEndDataDataView>(
        in_pinch_end_data, pinch_end_data_fragment);
    fragment->pinch_end_data.Set(
        pinch_end_data_fragment.is_null() ? nullptr : pinch_end_data_fragment.data());
    decltype(Traits::tap_data(input)) in_tap_data = Traits::tap_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->tap_data)::BaseType> tap_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::TapDataDataView>(
        in_tap_data, tap_data_fragment);
    fragment->tap_data.Set(
        tap_data_fragment.is_null() ? nullptr : tap_data_fragment.data());
    decltype(Traits::fling_data(input)) in_fling_data = Traits::fling_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->fling_data)::BaseType> fling_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::FlingDataDataView>(
        in_fling_data, fling_data_fragment);
    fragment->fling_data.Set(
        fling_data_fragment.is_null() ? nullptr : fling_data_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::GestureData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::GestureDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TouchPointDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::TouchPointDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::TouchPoint_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::TouchState>(
        Traits::state(input), &fragment->state);
    fragment->radius_x = Traits::radius_x(input);
    fragment->radius_y = Traits::radius_y(input);
    fragment->rotation_angle = Traits::rotation_angle(input);
    decltype(Traits::pointer_data(input)) in_pointer_data = Traits::pointer_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pointer_data)::BaseType> pointer_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PointerDataDataView>(
        in_pointer_data, pointer_data_fragment);
    fragment->pointer_data.Set(
        pointer_data_fragment.is_null() ? nullptr : pointer_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->pointer_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null pointer_data in TouchPoint struct");
  }

  static bool Deserialize(::blink::mojom::internal::TouchPoint_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::TouchPointDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TouchDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::TouchDataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::TouchData_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::DispatchType>(
        Traits::cancelable(input), &fragment->cancelable);
    fragment->moved_beyond_slop_region = Traits::moved_beyond_slop_region(input);
    fragment->touch_start_or_first_move = Traits::touch_start_or_first_move(input);
    fragment->hovering = Traits::hovering(input);
    fragment->unique_touch_event_id = Traits::unique_touch_event_id(input);
    decltype(Traits::touches(input)) in_touches = Traits::touches(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->touches)::BaseType>
        touches_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams touches_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::TouchPointDataView>>(
        in_touches, touches_fragment, &touches_validate_params);
    fragment->touches.Set(
        touches_fragment.is_null() ? nullptr : touches_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->touches.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null touches in TouchData struct");
  }

  static bool Deserialize(::blink::mojom::internal::TouchData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::TouchDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::EventDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::EventDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::Event_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::EventType>(
        Traits::type(input), &fragment->type);
    fragment->modifiers = Traits::modifiers(input);
    decltype(Traits::timestamp(input)) in_timestamp = Traits::timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timestamp)::BaseType> timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_timestamp, timestamp_fragment);
    fragment->timestamp.Set(
        timestamp_fragment.is_null() ? nullptr : timestamp_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->timestamp.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null timestamp in Event struct");
    decltype(Traits::latency(input)) in_latency = Traits::latency(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->latency)::BaseType> latency_fragment(
            fragment.message());
    mojo::internal::Serialize<::ui::mojom::LatencyInfoDataView>(
        in_latency, latency_fragment);
    fragment->latency.Set(
        latency_fragment.is_null() ? nullptr : latency_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->latency.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null latency in Event struct");
    decltype(Traits::key_data(input)) in_key_data = Traits::key_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_data)::BaseType> key_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::KeyDataDataView>(
        in_key_data, key_data_fragment);
    fragment->key_data.Set(
        key_data_fragment.is_null() ? nullptr : key_data_fragment.data());
    decltype(Traits::pointer_data(input)) in_pointer_data = Traits::pointer_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->pointer_data)::BaseType> pointer_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PointerDataDataView>(
        in_pointer_data, pointer_data_fragment);
    fragment->pointer_data.Set(
        pointer_data_fragment.is_null() ? nullptr : pointer_data_fragment.data());
    decltype(Traits::gesture_data(input)) in_gesture_data = Traits::gesture_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->gesture_data)::BaseType> gesture_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::GestureDataDataView>(
        in_gesture_data, gesture_data_fragment);
    fragment->gesture_data.Set(
        gesture_data_fragment.is_null() ? nullptr : gesture_data_fragment.data());
    decltype(Traits::touch_data(input)) in_touch_data = Traits::touch_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->touch_data)::BaseType> touch_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::TouchDataDataView>(
        in_touch_data, touch_data_fragment);
    fragment->touch_data.Set(
        touch_data_fragment.is_null() ? nullptr : touch_data_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::Event_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::EventDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::DidOverscrollParamsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::DidOverscrollParamsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::DidOverscrollParams_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::accumulated_overscroll(input)) in_accumulated_overscroll = Traits::accumulated_overscroll(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->accumulated_overscroll)::BaseType> accumulated_overscroll_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::Vector2dFDataView>(
        in_accumulated_overscroll, accumulated_overscroll_fragment);
    fragment->accumulated_overscroll.Set(
        accumulated_overscroll_fragment.is_null() ? nullptr : accumulated_overscroll_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->accumulated_overscroll.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null accumulated_overscroll in DidOverscrollParams struct");
    decltype(Traits::latest_overscroll_delta(input)) in_latest_overscroll_delta = Traits::latest_overscroll_delta(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->latest_overscroll_delta)::BaseType> latest_overscroll_delta_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::Vector2dFDataView>(
        in_latest_overscroll_delta, latest_overscroll_delta_fragment);
    fragment->latest_overscroll_delta.Set(
        latest_overscroll_delta_fragment.is_null() ? nullptr : latest_overscroll_delta_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->latest_overscroll_delta.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null latest_overscroll_delta in DidOverscrollParams struct");
    decltype(Traits::current_fling_velocity(input)) in_current_fling_velocity = Traits::current_fling_velocity(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->current_fling_velocity)::BaseType> current_fling_velocity_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::Vector2dFDataView>(
        in_current_fling_velocity, current_fling_velocity_fragment);
    fragment->current_fling_velocity.Set(
        current_fling_velocity_fragment.is_null() ? nullptr : current_fling_velocity_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->current_fling_velocity.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null current_fling_velocity in DidOverscrollParams struct");
    decltype(Traits::causal_event_viewport_point(input)) in_causal_event_viewport_point = Traits::causal_event_viewport_point(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->causal_event_viewport_point)::BaseType> causal_event_viewport_point_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::PointFDataView>(
        in_causal_event_viewport_point, causal_event_viewport_point_fragment);
    fragment->causal_event_viewport_point.Set(
        causal_event_viewport_point_fragment.is_null() ? nullptr : causal_event_viewport_point_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->causal_event_viewport_point.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null causal_event_viewport_point in DidOverscrollParams struct");
    decltype(Traits::overscroll_behavior(input)) in_overscroll_behavior = Traits::overscroll_behavior(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->overscroll_behavior)::BaseType> overscroll_behavior_fragment(
            fragment.message());
    mojo::internal::Serialize<::cc::mojom::OverscrollBehaviorDataView>(
        in_overscroll_behavior, overscroll_behavior_fragment);
    fragment->overscroll_behavior.Set(
        overscroll_behavior_fragment.is_null() ? nullptr : overscroll_behavior_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->overscroll_behavior.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null overscroll_behavior in DidOverscrollParams struct");
  }

  static bool Deserialize(::blink::mojom::internal::DidOverscrollParams_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::DidOverscrollParamsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TouchActionOptionalDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::TouchActionOptionalDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::TouchActionOptional_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::cc::mojom::TouchAction>(
        Traits::touch_action(input), &fragment->touch_action);
  }

  static bool Deserialize(::blink::mojom::internal::TouchActionOptional_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::TouchActionOptionalDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::EditCommandDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::EditCommandDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::EditCommand_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in EditCommand struct");
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->value)::BaseType> value_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_value, value_fragment);
    fragment->value.Set(
        value_fragment.is_null() ? nullptr : value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null value in EditCommand struct");
  }

  static bool Deserialize(::blink::mojom::internal::EditCommand_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::EditCommandDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::SelectAroundCaretResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::SelectAroundCaretResultDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::SelectAroundCaretResult_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->extended_start_adjust = Traits::extended_start_adjust(input);
    fragment->extended_end_adjust = Traits::extended_end_adjust(input);
    fragment->word_start_adjust = Traits::word_start_adjust(input);
    fragment->word_end_adjust = Traits::word_end_adjust(input);
  }

  static bool Deserialize(::blink::mojom::internal::SelectAroundCaretResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::SelectAroundCaretResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void KeyDataDataView::GetTextDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->text.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void KeyDataDataView::GetUnmodifiedTextDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->unmodified_text.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}


inline void PointerDataDataView::GetWidgetPositionDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->widget_position.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void PointerDataDataView::GetScreenPositionDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->screen_position.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void PointerDataDataView::GetMouseDataDataView(
    MouseDataDataView* output) {
  auto pointer = data_->mouse_data.Get();
  *output = MouseDataDataView(pointer, message_);
}




inline void MouseDataDataView::GetWheelDataDataView(
    WheelDataDataView* output) {
  auto pointer = data_->wheel_data.Get();
  *output = WheelDataDataView(pointer, message_);
}




inline void ScrollDataDataView::GetUpdateDetailsDataView(
    ScrollUpdateDataView* output) {
  auto pointer = data_->update_details.Get();
  *output = ScrollUpdateDataView(pointer, message_);
}












inline void GestureDataDataView::GetScreenPositionDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->screen_position.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void GestureDataDataView::GetWidgetPositionDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->widget_position.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void GestureDataDataView::GetContactSizeDataView(
    ::gfx::mojom::SizeDataView* output) {
  auto pointer = data_->contact_size.Get();
  *output = ::gfx::mojom::SizeDataView(pointer, message_);
}
inline void GestureDataDataView::GetScrollDataDataView(
    ScrollDataDataView* output) {
  auto pointer = data_->scroll_data.Get();
  *output = ScrollDataDataView(pointer, message_);
}
inline void GestureDataDataView::GetPinchBeginDataDataView(
    PinchBeginDataDataView* output) {
  auto pointer = data_->pinch_begin_data.Get();
  *output = PinchBeginDataDataView(pointer, message_);
}
inline void GestureDataDataView::GetPinchUpdateDataDataView(
    PinchUpdateDataDataView* output) {
  auto pointer = data_->pinch_update_data.Get();
  *output = PinchUpdateDataDataView(pointer, message_);
}
inline void GestureDataDataView::GetPinchEndDataDataView(
    PinchEndDataDataView* output) {
  auto pointer = data_->pinch_end_data.Get();
  *output = PinchEndDataDataView(pointer, message_);
}
inline void GestureDataDataView::GetTapDataDataView(
    TapDataDataView* output) {
  auto pointer = data_->tap_data.Get();
  *output = TapDataDataView(pointer, message_);
}
inline void GestureDataDataView::GetFlingDataDataView(
    FlingDataDataView* output) {
  auto pointer = data_->fling_data.Get();
  *output = FlingDataDataView(pointer, message_);
}


inline void TouchPointDataView::GetPointerDataDataView(
    PointerDataDataView* output) {
  auto pointer = data_->pointer_data.Get();
  *output = PointerDataDataView(pointer, message_);
}


inline void TouchDataDataView::GetTouchesDataView(
    mojo::ArrayDataView<TouchPointDataView>* output) {
  auto pointer = data_->touches.Get();
  *output = mojo::ArrayDataView<TouchPointDataView>(pointer, message_);
}


inline void EventDataView::GetTimestampDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->timestamp.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}
inline void EventDataView::GetLatencyDataView(
    ::ui::mojom::LatencyInfoDataView* output) {
  auto pointer = data_->latency.Get();
  *output = ::ui::mojom::LatencyInfoDataView(pointer, message_);
}
inline void EventDataView::GetKeyDataDataView(
    KeyDataDataView* output) {
  auto pointer = data_->key_data.Get();
  *output = KeyDataDataView(pointer, message_);
}
inline void EventDataView::GetPointerDataDataView(
    PointerDataDataView* output) {
  auto pointer = data_->pointer_data.Get();
  *output = PointerDataDataView(pointer, message_);
}
inline void EventDataView::GetGestureDataDataView(
    GestureDataDataView* output) {
  auto pointer = data_->gesture_data.Get();
  *output = GestureDataDataView(pointer, message_);
}
inline void EventDataView::GetTouchDataDataView(
    TouchDataDataView* output) {
  auto pointer = data_->touch_data.Get();
  *output = TouchDataDataView(pointer, message_);
}


inline void DidOverscrollParamsDataView::GetAccumulatedOverscrollDataView(
    ::gfx::mojom::Vector2dFDataView* output) {
  auto pointer = data_->accumulated_overscroll.Get();
  *output = ::gfx::mojom::Vector2dFDataView(pointer, message_);
}
inline void DidOverscrollParamsDataView::GetLatestOverscrollDeltaDataView(
    ::gfx::mojom::Vector2dFDataView* output) {
  auto pointer = data_->latest_overscroll_delta.Get();
  *output = ::gfx::mojom::Vector2dFDataView(pointer, message_);
}
inline void DidOverscrollParamsDataView::GetCurrentFlingVelocityDataView(
    ::gfx::mojom::Vector2dFDataView* output) {
  auto pointer = data_->current_fling_velocity.Get();
  *output = ::gfx::mojom::Vector2dFDataView(pointer, message_);
}
inline void DidOverscrollParamsDataView::GetCausalEventViewportPointDataView(
    ::gfx::mojom::PointFDataView* output) {
  auto pointer = data_->causal_event_viewport_point.Get();
  *output = ::gfx::mojom::PointFDataView(pointer, message_);
}
inline void DidOverscrollParamsDataView::GetOverscrollBehaviorDataView(
    ::cc::mojom::OverscrollBehaviorDataView* output) {
  auto pointer = data_->overscroll_behavior.Get();
  *output = ::cc::mojom::OverscrollBehaviorDataView(pointer, message_);
}




inline void EditCommandDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void EditCommandDataView::GetValueDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->value.Get();
  *output = mojo::StringDataView(pointer, message_);
}





}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::SelectionGranularity> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::SelectionGranularity value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::PanAction> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::PanAction value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::FocusState> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::FocusState value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_INPUT_INPUT_HANDLER_MOJOM_SHARED_H_