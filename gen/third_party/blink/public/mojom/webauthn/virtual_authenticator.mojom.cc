// third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom-params-data.h"
#include "third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom-import-headers.h"
#include "third_party/blink/public/mojom/webauthn/virtual_authenticator.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_VIRTUAL_AUTHENTICATOR_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_VIRTUAL_AUTHENTICATOR_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace test {
namespace mojom {
VirtualAuthenticatorOptions::VirtualAuthenticatorOptions()
    : protocol(),
      ctap2_version(),
      transport(),
      attachment(),
      has_resident_key(),
      has_user_verification(),
      is_user_present(true),
      has_large_blob(),
      has_cred_blob(),
      has_min_pin_length() {}

VirtualAuthenticatorOptions::VirtualAuthenticatorOptions(
    ::device::ProtocolVersion protocol_in,
    ::device::Ctap2Version ctap2_version_in,
    ::device::FidoTransportProtocol transport_in,
    ::device::AuthenticatorAttachment attachment_in,
    bool has_resident_key_in,
    bool has_user_verification_in,
    bool is_user_present_in,
    bool has_large_blob_in,
    bool has_cred_blob_in,
    bool has_min_pin_length_in)
    : protocol(std::move(protocol_in)),
      ctap2_version(std::move(ctap2_version_in)),
      transport(std::move(transport_in)),
      attachment(std::move(attachment_in)),
      has_resident_key(std::move(has_resident_key_in)),
      has_user_verification(std::move(has_user_verification_in)),
      is_user_present(std::move(is_user_present_in)),
      has_large_blob(std::move(has_large_blob_in)),
      has_cred_blob(std::move(has_cred_blob_in)),
      has_min_pin_length(std::move(has_min_pin_length_in)) {}

VirtualAuthenticatorOptions::~VirtualAuthenticatorOptions() = default;

void VirtualAuthenticatorOptions::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "protocol"), this->protocol,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::device::ProtocolVersion>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "ctap2_version"), this->ctap2_version,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::device::Ctap2Version>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "transport"), this->transport,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::device::FidoTransportProtocol>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "attachment"), this->attachment,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::device::AuthenticatorAttachment>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_resident_key"), this->has_resident_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_user_verification"), this->has_user_verification,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_user_present"), this->is_user_present,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_large_blob"), this->has_large_blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_cred_blob"), this->has_cred_blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_min_pin_length"), this->has_min_pin_length,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool VirtualAuthenticatorOptions::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RegisteredKey::RegisteredKey()
    : key_handle(),
      rp_id(),
      private_key(),
      counter() {}

RegisteredKey::RegisteredKey(
    std::vector<uint8_t> key_handle_in,
    const std::string& rp_id_in,
    std::vector<uint8_t> private_key_in,
    int32_t counter_in)
    : key_handle(std::move(key_handle_in)),
      rp_id(std::move(rp_id_in)),
      private_key(std::move(private_key_in)),
      counter(std::move(counter_in)) {}

RegisteredKey::~RegisteredKey() = default;

void RegisteredKey::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_handle"), this->key_handle,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "rp_id"), this->rp_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "private_key"), this->private_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<uint8_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "counter"), this->counter,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RegisteredKey::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char VirtualAuthenticator::Name_[] = "blink.test.mojom.VirtualAuthenticator";

VirtualAuthenticator::IPCStableHashFunction VirtualAuthenticator::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kVirtualAuthenticator_GetUniqueId_Name: {
      return &VirtualAuthenticator::GetUniqueId_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_AddRegistration_Name: {
      return &VirtualAuthenticator::AddRegistration_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_GetRegistrations_Name: {
      return &VirtualAuthenticator::GetRegistrations_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_RemoveRegistration_Name: {
      return &VirtualAuthenticator::RemoveRegistration_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_ClearRegistrations_Name: {
      return &VirtualAuthenticator::ClearRegistrations_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_GetLargeBlob_Name: {
      return &VirtualAuthenticator::GetLargeBlob_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_SetLargeBlob_Name: {
      return &VirtualAuthenticator::SetLargeBlob_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticator_SetUserVerified_Name: {
      return &VirtualAuthenticator::SetUserVerified_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* VirtualAuthenticator::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kVirtualAuthenticator_GetUniqueId_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::GetUniqueId";
      case internal::kVirtualAuthenticator_AddRegistration_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::AddRegistration";
      case internal::kVirtualAuthenticator_GetRegistrations_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::GetRegistrations";
      case internal::kVirtualAuthenticator_RemoveRegistration_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::RemoveRegistration";
      case internal::kVirtualAuthenticator_ClearRegistrations_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::ClearRegistrations";
      case internal::kVirtualAuthenticator_GetLargeBlob_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::GetLargeBlob";
      case internal::kVirtualAuthenticator_SetLargeBlob_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::SetLargeBlob";
      case internal::kVirtualAuthenticator_SetUserVerified_Name:
            return "Receive blink::test::mojom::VirtualAuthenticator::SetUserVerified";
    }
  } else {
    switch (message.name()) {
      case internal::kVirtualAuthenticator_GetUniqueId_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::GetUniqueId";
      case internal::kVirtualAuthenticator_AddRegistration_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::AddRegistration";
      case internal::kVirtualAuthenticator_GetRegistrations_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::GetRegistrations";
      case internal::kVirtualAuthenticator_RemoveRegistration_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::RemoveRegistration";
      case internal::kVirtualAuthenticator_ClearRegistrations_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::ClearRegistrations";
      case internal::kVirtualAuthenticator_GetLargeBlob_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::GetLargeBlob";
      case internal::kVirtualAuthenticator_SetLargeBlob_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::SetLargeBlob";
      case internal::kVirtualAuthenticator_SetUserVerified_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticator::SetUserVerified";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t VirtualAuthenticator::GetUniqueId_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::GetUniqueId");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::AddRegistration_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::AddRegistration");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::GetRegistrations_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::GetRegistrations");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::RemoveRegistration_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::RemoveRegistration");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::ClearRegistrations_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::ClearRegistrations");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::GetLargeBlob_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::GetLargeBlob");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::SetLargeBlob_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::SetLargeBlob");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticator::SetUserVerified_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticator::SetUserVerified");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class VirtualAuthenticator_GetUniqueId_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_GetUniqueId_ForwardToCallback(
      VirtualAuthenticator::GetUniqueIdCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_GetUniqueId_ForwardToCallback(const VirtualAuthenticator_GetUniqueId_ForwardToCallback&) = delete;
  VirtualAuthenticator_GetUniqueId_ForwardToCallback& operator=(const VirtualAuthenticator_GetUniqueId_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::GetUniqueIdCallback callback_;
};

class VirtualAuthenticator_AddRegistration_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_AddRegistration_ForwardToCallback(
      VirtualAuthenticator::AddRegistrationCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_AddRegistration_ForwardToCallback(const VirtualAuthenticator_AddRegistration_ForwardToCallback&) = delete;
  VirtualAuthenticator_AddRegistration_ForwardToCallback& operator=(const VirtualAuthenticator_AddRegistration_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::AddRegistrationCallback callback_;
};

class VirtualAuthenticator_GetRegistrations_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_GetRegistrations_ForwardToCallback(
      VirtualAuthenticator::GetRegistrationsCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_GetRegistrations_ForwardToCallback(const VirtualAuthenticator_GetRegistrations_ForwardToCallback&) = delete;
  VirtualAuthenticator_GetRegistrations_ForwardToCallback& operator=(const VirtualAuthenticator_GetRegistrations_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::GetRegistrationsCallback callback_;
};

class VirtualAuthenticator_RemoveRegistration_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_RemoveRegistration_ForwardToCallback(
      VirtualAuthenticator::RemoveRegistrationCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_RemoveRegistration_ForwardToCallback(const VirtualAuthenticator_RemoveRegistration_ForwardToCallback&) = delete;
  VirtualAuthenticator_RemoveRegistration_ForwardToCallback& operator=(const VirtualAuthenticator_RemoveRegistration_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::RemoveRegistrationCallback callback_;
};

class VirtualAuthenticator_ClearRegistrations_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_ClearRegistrations_ForwardToCallback(
      VirtualAuthenticator::ClearRegistrationsCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_ClearRegistrations_ForwardToCallback(const VirtualAuthenticator_ClearRegistrations_ForwardToCallback&) = delete;
  VirtualAuthenticator_ClearRegistrations_ForwardToCallback& operator=(const VirtualAuthenticator_ClearRegistrations_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::ClearRegistrationsCallback callback_;
};

class VirtualAuthenticator_GetLargeBlob_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_GetLargeBlob_ForwardToCallback(
      VirtualAuthenticator::GetLargeBlobCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_GetLargeBlob_ForwardToCallback(const VirtualAuthenticator_GetLargeBlob_ForwardToCallback&) = delete;
  VirtualAuthenticator_GetLargeBlob_ForwardToCallback& operator=(const VirtualAuthenticator_GetLargeBlob_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::GetLargeBlobCallback callback_;
};

class VirtualAuthenticator_SetLargeBlob_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_SetLargeBlob_ForwardToCallback(
      VirtualAuthenticator::SetLargeBlobCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_SetLargeBlob_ForwardToCallback(const VirtualAuthenticator_SetLargeBlob_ForwardToCallback&) = delete;
  VirtualAuthenticator_SetLargeBlob_ForwardToCallback& operator=(const VirtualAuthenticator_SetLargeBlob_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::SetLargeBlobCallback callback_;
};

class VirtualAuthenticator_SetUserVerified_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticator_SetUserVerified_ForwardToCallback(
      VirtualAuthenticator::SetUserVerifiedCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticator_SetUserVerified_ForwardToCallback(const VirtualAuthenticator_SetUserVerified_ForwardToCallback&) = delete;
  VirtualAuthenticator_SetUserVerified_ForwardToCallback& operator=(const VirtualAuthenticator_SetUserVerified_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticator::SetUserVerifiedCallback callback_;
};

VirtualAuthenticatorProxy::VirtualAuthenticatorProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void VirtualAuthenticatorProxy::GetUniqueId(
    GetUniqueIdCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::test::mojom::VirtualAuthenticator::GetUniqueId");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_GetUniqueId_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_GetUniqueId_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("GetUniqueId");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_GetUniqueId_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::AddRegistration(
    RegisteredKeyPtr in_key, AddRegistrationCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticator::AddRegistration", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type RegisteredKeyPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_AddRegistration_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_AddRegistration_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<::blink::test::mojom::RegisteredKeyDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in VirtualAuthenticator.AddRegistration request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("AddRegistration");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_AddRegistration_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::GetRegistrations(
    GetRegistrationsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::test::mojom::VirtualAuthenticator::GetRegistrations");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_GetRegistrations_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_GetRegistrations_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("GetRegistrations");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_GetRegistrations_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::RemoveRegistration(
    const std::vector<uint8_t>& in_key_handle, RemoveRegistrationCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticator::RemoveRegistration", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_handle"), in_key_handle,
                        "<value of type const std::vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_RemoveRegistration_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_RemoveRegistration_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key_handle)::BaseType>
      key_handle_fragment(params.message());
  const mojo::internal::ContainerValidateParams key_handle_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_key_handle, key_handle_fragment, &key_handle_validate_params);
  params->key_handle.Set(
      key_handle_fragment.is_null() ? nullptr : key_handle_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_handle.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_handle in VirtualAuthenticator.RemoveRegistration request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("RemoveRegistration");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_RemoveRegistration_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::ClearRegistrations(
    ClearRegistrationsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::test::mojom::VirtualAuthenticator::ClearRegistrations");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_ClearRegistrations_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_ClearRegistrations_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("ClearRegistrations");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_ClearRegistrations_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::GetLargeBlob(
    const std::vector<uint8_t>& in_key_handle, GetLargeBlobCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticator::GetLargeBlob", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_handle"), in_key_handle,
                        "<value of type const std::vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_GetLargeBlob_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_GetLargeBlob_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key_handle)::BaseType>
      key_handle_fragment(params.message());
  const mojo::internal::ContainerValidateParams key_handle_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_key_handle, key_handle_fragment, &key_handle_validate_params);
  params->key_handle.Set(
      key_handle_fragment.is_null() ? nullptr : key_handle_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_handle.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_handle in VirtualAuthenticator.GetLargeBlob request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("GetLargeBlob");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_GetLargeBlob_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::SetLargeBlob(
    const std::vector<uint8_t>& in_key_handle, const std::vector<uint8_t>& in_blob, SetLargeBlobCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticator::SetLargeBlob", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key_handle"), in_key_handle,
                        "<value of type const std::vector<uint8_t>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("blob"), in_blob,
                        "<value of type const std::vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_SetLargeBlob_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_SetLargeBlob_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key_handle)::BaseType>
      key_handle_fragment(params.message());
  const mojo::internal::ContainerValidateParams key_handle_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_key_handle, key_handle_fragment, &key_handle_validate_params);
  params->key_handle.Set(
      key_handle_fragment.is_null() ? nullptr : key_handle_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key_handle.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key_handle in VirtualAuthenticator.SetLargeBlob request");
  mojo::internal::MessageFragment<
      typename decltype(params->blob)::BaseType>
      blob_fragment(params.message());
  const mojo::internal::ContainerValidateParams blob_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_blob, blob_fragment, &blob_validate_params);
  params->blob.Set(
      blob_fragment.is_null() ? nullptr : blob_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->blob.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null blob in VirtualAuthenticator.SetLargeBlob request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("SetLargeBlob");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_SetLargeBlob_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorProxy::SetUserVerified(
    bool in_verified, SetUserVerifiedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticator::SetUserVerified", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("verified"), in_verified,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_SetUserVerified_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_SetUserVerified_Params_Data> params(
          message);
  params.Allocate();
  params->verified = in_verified;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("SetUserVerified");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticator_SetUserVerified_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class VirtualAuthenticator_GetUniqueId_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::GetUniqueIdCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_GetUniqueId_ProxyToResponder> proxy(
        new VirtualAuthenticator_GetUniqueId_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_GetUniqueId_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_GetUniqueId_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_GetUniqueId_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::GetUniqueIdCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const std::string& in_id);
};

bool VirtualAuthenticator_GetUniqueId_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_GetUniqueId_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_GetUniqueId_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::string p_id{};
  VirtualAuthenticator_GetUniqueId_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadId(&p_id))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_id));
  return true;
}

void VirtualAuthenticator_GetUniqueId_ProxyToResponder::Run(
    const std::string& in_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticator::GetUniqueId", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("id"), in_id,
                        "<value of type const std::string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_GetUniqueId_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_GetUniqueId_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->id)::BaseType> id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, id_fragment);
  params->id.Set(
      id_fragment.is_null() ? nullptr : id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("GetUniqueId");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_AddRegistration_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::AddRegistrationCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_AddRegistration_ProxyToResponder> proxy(
        new VirtualAuthenticator_AddRegistration_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_AddRegistration_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_AddRegistration_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_AddRegistration_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::AddRegistrationCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_added);
};

bool VirtualAuthenticator_AddRegistration_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_AddRegistration_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_AddRegistration_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_added{};
  VirtualAuthenticator_AddRegistration_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_added = input_data_view.added();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_added));
  return true;
}

void VirtualAuthenticator_AddRegistration_ProxyToResponder::Run(
    bool in_added) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticator::AddRegistration", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("added"), in_added,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_AddRegistration_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_AddRegistration_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->added = in_added;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("AddRegistration");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_GetRegistrations_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::GetRegistrationsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_GetRegistrations_ProxyToResponder> proxy(
        new VirtualAuthenticator_GetRegistrations_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_GetRegistrations_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_GetRegistrations_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_GetRegistrations_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::GetRegistrationsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<RegisteredKeyPtr> in_keys);
};

bool VirtualAuthenticator_GetRegistrations_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_GetRegistrations_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_GetRegistrations_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<RegisteredKeyPtr> p_keys{};
  VirtualAuthenticator_GetRegistrations_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadKeys(&p_keys))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_keys));
  return true;
}

void VirtualAuthenticator_GetRegistrations_ProxyToResponder::Run(
    std::vector<RegisteredKeyPtr> in_keys) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticator::GetRegistrations", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("keys"), in_keys,
                        "<value of type std::vector<RegisteredKeyPtr>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_GetRegistrations_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_GetRegistrations_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->keys)::BaseType>
      keys_fragment(params.message());
  const mojo::internal::ContainerValidateParams keys_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::test::mojom::RegisteredKeyDataView>>(
      in_keys, keys_fragment, &keys_validate_params);
  params->keys.Set(
      keys_fragment.is_null() ? nullptr : keys_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->keys.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null keys in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("GetRegistrations");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_RemoveRegistration_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::RemoveRegistrationCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_RemoveRegistration_ProxyToResponder> proxy(
        new VirtualAuthenticator_RemoveRegistration_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_RemoveRegistration_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_RemoveRegistration_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_RemoveRegistration_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::RemoveRegistrationCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_removed);
};

bool VirtualAuthenticator_RemoveRegistration_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_RemoveRegistration_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_RemoveRegistration_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_removed{};
  VirtualAuthenticator_RemoveRegistration_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_removed = input_data_view.removed();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_removed));
  return true;
}

void VirtualAuthenticator_RemoveRegistration_ProxyToResponder::Run(
    bool in_removed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticator::RemoveRegistration", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("removed"), in_removed,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_RemoveRegistration_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_RemoveRegistration_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->removed = in_removed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("RemoveRegistration");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_ClearRegistrations_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::ClearRegistrationsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_ClearRegistrations_ProxyToResponder> proxy(
        new VirtualAuthenticator_ClearRegistrations_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_ClearRegistrations_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_ClearRegistrations_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_ClearRegistrations_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::ClearRegistrationsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool VirtualAuthenticator_ClearRegistrations_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_ClearRegistrations_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_ClearRegistrations_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  VirtualAuthenticator_ClearRegistrations_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 4, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void VirtualAuthenticator_ClearRegistrations_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::test::mojom::VirtualAuthenticator::ClearRegistrations");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_ClearRegistrations_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_ClearRegistrations_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("ClearRegistrations");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_GetLargeBlob_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::GetLargeBlobCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_GetLargeBlob_ProxyToResponder> proxy(
        new VirtualAuthenticator_GetLargeBlob_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_GetLargeBlob_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_GetLargeBlob_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_GetLargeBlob_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::GetLargeBlobCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<std::vector<uint8_t>>& in_blob);
};

bool VirtualAuthenticator_GetLargeBlob_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_GetLargeBlob_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_GetLargeBlob_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<std::vector<uint8_t>> p_blob{};
  VirtualAuthenticator_GetLargeBlob_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadBlob(&p_blob))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_blob));
  return true;
}

void VirtualAuthenticator_GetLargeBlob_ProxyToResponder::Run(
    const absl::optional<std::vector<uint8_t>>& in_blob) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticator::GetLargeBlob", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("blob"), in_blob,
                        "<value of type const absl::optional<std::vector<uint8_t>>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_GetLargeBlob_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_GetLargeBlob_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->blob)::BaseType>
      blob_fragment(params.message());
  const mojo::internal::ContainerValidateParams blob_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_blob, blob_fragment, &blob_validate_params);
  params->blob.Set(
      blob_fragment.is_null() ? nullptr : blob_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("GetLargeBlob");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_SetLargeBlob_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::SetLargeBlobCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_SetLargeBlob_ProxyToResponder> proxy(
        new VirtualAuthenticator_SetLargeBlob_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_SetLargeBlob_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_SetLargeBlob_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_SetLargeBlob_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::SetLargeBlobCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_set);
};

bool VirtualAuthenticator_SetLargeBlob_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_SetLargeBlob_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_SetLargeBlob_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_set{};
  VirtualAuthenticator_SetLargeBlob_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_set = input_data_view.set();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 6, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_set));
  return true;
}

void VirtualAuthenticator_SetLargeBlob_ProxyToResponder::Run(
    bool in_set) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticator::SetLargeBlob", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("set"), in_set,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_SetLargeBlob_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_SetLargeBlob_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->set = in_set;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("SetLargeBlob");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticator_SetUserVerified_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticator::SetUserVerifiedCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticator_SetUserVerified_ProxyToResponder> proxy(
        new VirtualAuthenticator_SetUserVerified_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticator_SetUserVerified_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticator_SetUserVerified_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticator_SetUserVerified_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticator::SetUserVerifiedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool VirtualAuthenticator_SetUserVerified_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticator_SetUserVerified_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticator_SetUserVerified_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  VirtualAuthenticator_SetUserVerified_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticator::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void VirtualAuthenticator_SetUserVerified_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::test::mojom::VirtualAuthenticator::SetUserVerified");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticator_SetUserVerified_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticator_SetUserVerified_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticator::Name_);
  message.set_method_name("SetUserVerified");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool VirtualAuthenticatorStubDispatch::Accept(
    VirtualAuthenticator* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kVirtualAuthenticator_GetUniqueId_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_AddRegistration_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_GetRegistrations_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_RemoveRegistration_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_ClearRegistrations_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_GetLargeBlob_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_SetLargeBlob_Name: {
      break;
    }
    case internal::kVirtualAuthenticator_SetUserVerified_Name: {
      break;
    }
  }
  return false;
}

// static
bool VirtualAuthenticatorStubDispatch::AcceptWithResponder(
    VirtualAuthenticator* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kVirtualAuthenticator_GetUniqueId_Name: {

      internal::VirtualAuthenticator_GetUniqueId_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_GetUniqueId_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      VirtualAuthenticator_GetUniqueId_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 0, false);
        return false;
      }
      VirtualAuthenticator::GetUniqueIdCallback callback =
          VirtualAuthenticator_GetUniqueId_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetUniqueId(std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_AddRegistration_Name: {

      internal::VirtualAuthenticator_AddRegistration_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_AddRegistration_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      RegisteredKeyPtr p_key{};
      VirtualAuthenticator_AddRegistration_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 1, false);
        return false;
      }
      VirtualAuthenticator::AddRegistrationCallback callback =
          VirtualAuthenticator_AddRegistration_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddRegistration(
std::move(p_key), std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_GetRegistrations_Name: {

      internal::VirtualAuthenticator_GetRegistrations_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_GetRegistrations_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      VirtualAuthenticator_GetRegistrations_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 2, false);
        return false;
      }
      VirtualAuthenticator::GetRegistrationsCallback callback =
          VirtualAuthenticator_GetRegistrations_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetRegistrations(std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_RemoveRegistration_Name: {

      internal::VirtualAuthenticator_RemoveRegistration_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_RemoveRegistration_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<uint8_t> p_key_handle{};
      VirtualAuthenticator_RemoveRegistration_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKeyHandle(&p_key_handle))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 3, false);
        return false;
      }
      VirtualAuthenticator::RemoveRegistrationCallback callback =
          VirtualAuthenticator_RemoveRegistration_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RemoveRegistration(
std::move(p_key_handle), std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_ClearRegistrations_Name: {

      internal::VirtualAuthenticator_ClearRegistrations_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_ClearRegistrations_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      VirtualAuthenticator_ClearRegistrations_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 4, false);
        return false;
      }
      VirtualAuthenticator::ClearRegistrationsCallback callback =
          VirtualAuthenticator_ClearRegistrations_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearRegistrations(std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_GetLargeBlob_Name: {

      internal::VirtualAuthenticator_GetLargeBlob_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_GetLargeBlob_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<uint8_t> p_key_handle{};
      VirtualAuthenticator_GetLargeBlob_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKeyHandle(&p_key_handle))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 5, false);
        return false;
      }
      VirtualAuthenticator::GetLargeBlobCallback callback =
          VirtualAuthenticator_GetLargeBlob_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetLargeBlob(
std::move(p_key_handle), std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_SetLargeBlob_Name: {

      internal::VirtualAuthenticator_SetLargeBlob_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_SetLargeBlob_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::vector<uint8_t> p_key_handle{};
      std::vector<uint8_t> p_blob{};
      VirtualAuthenticator_SetLargeBlob_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKeyHandle(&p_key_handle))
        success = false;
      if (success && !input_data_view.ReadBlob(&p_blob))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 6, false);
        return false;
      }
      VirtualAuthenticator::SetLargeBlobCallback callback =
          VirtualAuthenticator_SetLargeBlob_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetLargeBlob(
std::move(p_key_handle), 
std::move(p_blob), std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticator_SetUserVerified_Name: {

      internal::VirtualAuthenticator_SetUserVerified_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticator_SetUserVerified_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_verified{};
      VirtualAuthenticator_SetUserVerified_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_verified = input_data_view.verified();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticator::Name_, 7, false);
        return false;
      }
      VirtualAuthenticator::SetUserVerifiedCallback callback =
          VirtualAuthenticator_SetUserVerified_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetUserVerified(
std::move(p_verified), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kVirtualAuthenticatorValidationInfo[] = {
    {&internal::VirtualAuthenticator_GetUniqueId_Params_Data::Validate,
     &internal::VirtualAuthenticator_GetUniqueId_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_AddRegistration_Params_Data::Validate,
     &internal::VirtualAuthenticator_AddRegistration_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_GetRegistrations_Params_Data::Validate,
     &internal::VirtualAuthenticator_GetRegistrations_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_RemoveRegistration_Params_Data::Validate,
     &internal::VirtualAuthenticator_RemoveRegistration_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_ClearRegistrations_Params_Data::Validate,
     &internal::VirtualAuthenticator_ClearRegistrations_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_GetLargeBlob_Params_Data::Validate,
     &internal::VirtualAuthenticator_GetLargeBlob_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_SetLargeBlob_Params_Data::Validate,
     &internal::VirtualAuthenticator_SetLargeBlob_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticator_SetUserVerified_Params_Data::Validate,
     &internal::VirtualAuthenticator_SetUserVerified_ResponseParams_Data::Validate},
};

bool VirtualAuthenticatorRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::test::mojom::VirtualAuthenticator::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kVirtualAuthenticatorValidationInfo);
}

bool VirtualAuthenticatorResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::test::mojom::VirtualAuthenticator::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kVirtualAuthenticatorValidationInfo);
}
const char VirtualAuthenticatorManager::Name_[] = "blink.test.mojom.VirtualAuthenticatorManager";

VirtualAuthenticatorManager::IPCStableHashFunction VirtualAuthenticatorManager::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name: {
      return &VirtualAuthenticatorManager::CreateAuthenticator_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticatorManager_GetAuthenticators_Name: {
      return &VirtualAuthenticatorManager::GetAuthenticators_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name: {
      return &VirtualAuthenticatorManager::RemoveAuthenticator_Sym::IPCStableHash;
    }
    case internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name: {
      return &VirtualAuthenticatorManager::ClearAuthenticators_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* VirtualAuthenticatorManager::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name:
            return "Receive blink::test::mojom::VirtualAuthenticatorManager::CreateAuthenticator";
      case internal::kVirtualAuthenticatorManager_GetAuthenticators_Name:
            return "Receive blink::test::mojom::VirtualAuthenticatorManager::GetAuthenticators";
      case internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name:
            return "Receive blink::test::mojom::VirtualAuthenticatorManager::RemoveAuthenticator";
      case internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name:
            return "Receive blink::test::mojom::VirtualAuthenticatorManager::ClearAuthenticators";
    }
  } else {
    switch (message.name()) {
      case internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticatorManager::CreateAuthenticator";
      case internal::kVirtualAuthenticatorManager_GetAuthenticators_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticatorManager::GetAuthenticators";
      case internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticatorManager::RemoveAuthenticator";
      case internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name:
            return "Receive reply blink::test::mojom::VirtualAuthenticatorManager::ClearAuthenticators";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t VirtualAuthenticatorManager::CreateAuthenticator_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticatorManager::CreateAuthenticator");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticatorManager::GetAuthenticators_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticatorManager::GetAuthenticators");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticatorManager::RemoveAuthenticator_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticatorManager::RemoveAuthenticator");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t VirtualAuthenticatorManager::ClearAuthenticators_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::test::mojom::VirtualAuthenticatorManager::ClearAuthenticators");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback(
      VirtualAuthenticatorManager::CreateAuthenticatorCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback(const VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback&) = delete;
  VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback& operator=(const VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticatorManager::CreateAuthenticatorCallback callback_;
};

class VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback(
      VirtualAuthenticatorManager::GetAuthenticatorsCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback(const VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback&) = delete;
  VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback& operator=(const VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticatorManager::GetAuthenticatorsCallback callback_;
};

class VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback(
      VirtualAuthenticatorManager::RemoveAuthenticatorCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback(const VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback&) = delete;
  VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback& operator=(const VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticatorManager::RemoveAuthenticatorCallback callback_;
};

class VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback(
      VirtualAuthenticatorManager::ClearAuthenticatorsCallback callback
      ) : callback_(std::move(callback)) {
  }

  VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback(const VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback&) = delete;
  VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback& operator=(const VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  VirtualAuthenticatorManager::ClearAuthenticatorsCallback callback_;
};

VirtualAuthenticatorManagerProxy::VirtualAuthenticatorManagerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void VirtualAuthenticatorManagerProxy::CreateAuthenticator(
    VirtualAuthenticatorOptionsPtr in_options, CreateAuthenticatorCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticatorManager::CreateAuthenticator", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("options"), in_options,
                        "<value of type VirtualAuthenticatorOptionsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_CreateAuthenticator_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->options)::BaseType> options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::test::mojom::VirtualAuthenticatorOptionsDataView>(
      in_options, options_fragment);
  params->options.Set(
      options_fragment.is_null() ? nullptr : options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null options in VirtualAuthenticatorManager.CreateAuthenticator request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("CreateAuthenticator");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorManagerProxy::GetAuthenticators(
    GetAuthenticatorsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::test::mojom::VirtualAuthenticatorManager::GetAuthenticators");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_GetAuthenticators_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_GetAuthenticators_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("GetAuthenticators");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorManagerProxy::RemoveAuthenticator(
    const std::string& in_id, RemoveAuthenticatorCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::test::mojom::VirtualAuthenticatorManager::RemoveAuthenticator", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("id"), in_id,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_RemoveAuthenticator_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->id)::BaseType> id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, id_fragment);
  params->id.Set(
      id_fragment.is_null() ? nullptr : id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in VirtualAuthenticatorManager.RemoveAuthenticator request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("RemoveAuthenticator");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void VirtualAuthenticatorManagerProxy::ClearAuthenticators(
    ClearAuthenticatorsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::test::mojom::VirtualAuthenticatorManager::ClearAuthenticators");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_ClearAuthenticators_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("ClearAuthenticators");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticatorManager::CreateAuthenticatorCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder> proxy(
        new VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticatorManager::CreateAuthenticatorCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::mojo::PendingRemote<VirtualAuthenticator> in_authenticator);
};

bool VirtualAuthenticatorManager_CreateAuthenticator_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticatorManager_CreateAuthenticator_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticatorManager_CreateAuthenticator_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::mojo::PendingRemote<VirtualAuthenticator> p_authenticator{};
  VirtualAuthenticatorManager_CreateAuthenticator_ResponseParamsDataView input_data_view(params, message);
  
  if (success) {
    p_authenticator =
        input_data_view.TakeAuthenticator<decltype(p_authenticator)>();
  }
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticatorManager::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_authenticator));
  return true;
}

void VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder::Run(
    ::mojo::PendingRemote<VirtualAuthenticator> in_authenticator) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticatorManager::CreateAuthenticator", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("authenticator"), in_authenticator,
                        "<value of type ::mojo::PendingRemote<VirtualAuthenticator>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_CreateAuthenticator_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::test::mojom::VirtualAuthenticatorInterfaceBase>>(
      in_authenticator, &params->authenticator, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->authenticator),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid authenticator in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("CreateAuthenticator");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticatorManager::GetAuthenticatorsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder> proxy(
        new VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticatorManager::GetAuthenticatorsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      std::vector<::mojo::PendingRemote<VirtualAuthenticator>> in_authenticators);
};

bool VirtualAuthenticatorManager_GetAuthenticators_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticatorManager_GetAuthenticators_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticatorManager_GetAuthenticators_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  std::vector<::mojo::PendingRemote<VirtualAuthenticator>> p_authenticators{};
  VirtualAuthenticatorManager_GetAuthenticators_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadAuthenticators(&p_authenticators))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticatorManager::Name_, 1, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_authenticators));
  return true;
}

void VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder::Run(
    std::vector<::mojo::PendingRemote<VirtualAuthenticator>> in_authenticators) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticatorManager::GetAuthenticators", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("authenticators"), in_authenticators,
                        "<value of type std::vector<::mojo::PendingRemote<VirtualAuthenticator>>>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_GetAuthenticators_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_GetAuthenticators_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->authenticators)::BaseType>
      authenticators_fragment(params.message());
  const mojo::internal::ContainerValidateParams authenticators_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<mojo::InterfacePtrDataView<::blink::test::mojom::VirtualAuthenticatorInterfaceBase>>>(
      in_authenticators, authenticators_fragment, &authenticators_validate_params);
  params->authenticators.Set(
      authenticators_fragment.is_null() ? nullptr : authenticators_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->authenticators.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null authenticators in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("GetAuthenticators");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticatorManager::RemoveAuthenticatorCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder> proxy(
        new VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticatorManager::RemoveAuthenticatorCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_removed);
};

bool VirtualAuthenticatorManager_RemoveAuthenticator_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticatorManager_RemoveAuthenticator_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticatorManager_RemoveAuthenticator_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_removed{};
  VirtualAuthenticatorManager_RemoveAuthenticator_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_removed = input_data_view.removed();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticatorManager::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_removed));
  return true;
}

void VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder::Run(
    bool in_removed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::test::mojom::VirtualAuthenticatorManager::RemoveAuthenticator", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("removed"), in_removed,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_RemoveAuthenticator_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->removed = in_removed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("RemoveAuthenticator");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static VirtualAuthenticatorManager::ClearAuthenticatorsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder> proxy(
        new VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "VirtualAuthenticatorManager::ClearAuthenticatorsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool VirtualAuthenticatorManager_ClearAuthenticators_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::VirtualAuthenticatorManager_ClearAuthenticators_ResponseParams_Data* params =
      reinterpret_cast<
          internal::VirtualAuthenticatorManager_ClearAuthenticators_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  VirtualAuthenticatorManager_ClearAuthenticators_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        VirtualAuthenticatorManager::Name_, 3, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::test::mojom::VirtualAuthenticatorManager::ClearAuthenticators");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::test::mojom::internal::VirtualAuthenticatorManager_ClearAuthenticators_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(VirtualAuthenticatorManager::Name_);
  message.set_method_name("ClearAuthenticators");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool VirtualAuthenticatorManagerStubDispatch::Accept(
    VirtualAuthenticatorManager* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name: {
      break;
    }
    case internal::kVirtualAuthenticatorManager_GetAuthenticators_Name: {
      break;
    }
    case internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name: {
      break;
    }
    case internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name: {
      break;
    }
  }
  return false;
}

// static
bool VirtualAuthenticatorManagerStubDispatch::AcceptWithResponder(
    VirtualAuthenticatorManager* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kVirtualAuthenticatorManager_CreateAuthenticator_Name: {

      internal::VirtualAuthenticatorManager_CreateAuthenticator_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticatorManager_CreateAuthenticator_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      VirtualAuthenticatorOptionsPtr p_options{};
      VirtualAuthenticatorManager_CreateAuthenticator_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticatorManager::Name_, 0, false);
        return false;
      }
      VirtualAuthenticatorManager::CreateAuthenticatorCallback callback =
          VirtualAuthenticatorManager_CreateAuthenticator_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateAuthenticator(
std::move(p_options), std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticatorManager_GetAuthenticators_Name: {

      internal::VirtualAuthenticatorManager_GetAuthenticators_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticatorManager_GetAuthenticators_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      VirtualAuthenticatorManager_GetAuthenticators_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticatorManager::Name_, 1, false);
        return false;
      }
      VirtualAuthenticatorManager::GetAuthenticatorsCallback callback =
          VirtualAuthenticatorManager_GetAuthenticators_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetAuthenticators(std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticatorManager_RemoveAuthenticator_Name: {

      internal::VirtualAuthenticatorManager_RemoveAuthenticator_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticatorManager_RemoveAuthenticator_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      VirtualAuthenticatorManager_RemoveAuthenticator_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticatorManager::Name_, 2, false);
        return false;
      }
      VirtualAuthenticatorManager::RemoveAuthenticatorCallback callback =
          VirtualAuthenticatorManager_RemoveAuthenticator_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RemoveAuthenticator(
std::move(p_id), std::move(callback));
      return true;
    }
    case internal::kVirtualAuthenticatorManager_ClearAuthenticators_Name: {

      internal::VirtualAuthenticatorManager_ClearAuthenticators_Params_Data* params =
          reinterpret_cast<
              internal::VirtualAuthenticatorManager_ClearAuthenticators_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      VirtualAuthenticatorManager_ClearAuthenticators_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            VirtualAuthenticatorManager::Name_, 3, false);
        return false;
      }
      VirtualAuthenticatorManager::ClearAuthenticatorsCallback callback =
          VirtualAuthenticatorManager_ClearAuthenticators_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearAuthenticators(std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kVirtualAuthenticatorManagerValidationInfo[] = {
    {&internal::VirtualAuthenticatorManager_CreateAuthenticator_Params_Data::Validate,
     &internal::VirtualAuthenticatorManager_CreateAuthenticator_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticatorManager_GetAuthenticators_Params_Data::Validate,
     &internal::VirtualAuthenticatorManager_GetAuthenticators_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticatorManager_RemoveAuthenticator_Params_Data::Validate,
     &internal::VirtualAuthenticatorManager_RemoveAuthenticator_ResponseParams_Data::Validate},
    {&internal::VirtualAuthenticatorManager_ClearAuthenticators_Params_Data::Validate,
     &internal::VirtualAuthenticatorManager_ClearAuthenticators_ResponseParams_Data::Validate},
};

bool VirtualAuthenticatorManagerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::test::mojom::VirtualAuthenticatorManager::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kVirtualAuthenticatorManagerValidationInfo);
}

bool VirtualAuthenticatorManagerResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::test::mojom::VirtualAuthenticatorManager::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kVirtualAuthenticatorManagerValidationInfo);
}


}  // namespace mojom
}  // namespace test
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::test::mojom::VirtualAuthenticatorOptions::DataView, ::blink::test::mojom::VirtualAuthenticatorOptionsPtr>::Read(
    ::blink::test::mojom::VirtualAuthenticatorOptions::DataView input,
    ::blink::test::mojom::VirtualAuthenticatorOptionsPtr* output) {
  bool success = true;
  ::blink::test::mojom::VirtualAuthenticatorOptionsPtr result(::blink::test::mojom::VirtualAuthenticatorOptions::New());
  
      if (success && !input.ReadProtocol(&result->protocol))
        success = false;
      if (success && !input.ReadCtap2Version(&result->ctap2_version))
        success = false;
      if (success && !input.ReadTransport(&result->transport))
        success = false;
      if (success && !input.ReadAttachment(&result->attachment))
        success = false;
      if (success)
        result->has_resident_key = input.has_resident_key();
      if (success)
        result->has_user_verification = input.has_user_verification();
      if (success)
        result->is_user_present = input.is_user_present();
      if (success)
        result->has_large_blob = input.has_large_blob();
      if (success)
        result->has_cred_blob = input.has_cred_blob();
      if (success)
        result->has_min_pin_length = input.has_min_pin_length();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::test::mojom::RegisteredKey::DataView, ::blink::test::mojom::RegisteredKeyPtr>::Read(
    ::blink::test::mojom::RegisteredKey::DataView input,
    ::blink::test::mojom::RegisteredKeyPtr* output) {
  bool success = true;
  ::blink::test::mojom::RegisteredKeyPtr result(::blink::test::mojom::RegisteredKey::New());
  
      if (success && !input.ReadKeyHandle(&result->key_handle))
        success = false;
      if (success && !input.ReadRpId(&result->rp_id))
        success = false;
      if (success && !input.ReadPrivateKey(&result->private_key))
        success = false;
      if (success)
        result->counter = input.counter();
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace test {
namespace mojom {


void VirtualAuthenticatorInterceptorForTesting::GetUniqueId(GetUniqueIdCallback callback) {
  GetForwardingInterface()->GetUniqueId(std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::AddRegistration(RegisteredKeyPtr key, AddRegistrationCallback callback) {
  GetForwardingInterface()->AddRegistration(std::move(key), std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::GetRegistrations(GetRegistrationsCallback callback) {
  GetForwardingInterface()->GetRegistrations(std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::RemoveRegistration(const std::vector<uint8_t>& key_handle, RemoveRegistrationCallback callback) {
  GetForwardingInterface()->RemoveRegistration(std::move(key_handle), std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::ClearRegistrations(ClearRegistrationsCallback callback) {
  GetForwardingInterface()->ClearRegistrations(std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::GetLargeBlob(const std::vector<uint8_t>& key_handle, GetLargeBlobCallback callback) {
  GetForwardingInterface()->GetLargeBlob(std::move(key_handle), std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::SetLargeBlob(const std::vector<uint8_t>& key_handle, const std::vector<uint8_t>& blob, SetLargeBlobCallback callback) {
  GetForwardingInterface()->SetLargeBlob(std::move(key_handle), std::move(blob), std::move(callback));
}
void VirtualAuthenticatorInterceptorForTesting::SetUserVerified(bool verified, SetUserVerifiedCallback callback) {
  GetForwardingInterface()->SetUserVerified(std::move(verified), std::move(callback));
}
VirtualAuthenticatorAsyncWaiter::VirtualAuthenticatorAsyncWaiter(
    VirtualAuthenticator* proxy) : proxy_(proxy) {}

VirtualAuthenticatorAsyncWaiter::~VirtualAuthenticatorAsyncWaiter() = default;

void VirtualAuthenticatorAsyncWaiter::GetUniqueId(
    std::string* out_id) {
  base::RunLoop loop;
  proxy_->GetUniqueId(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::string* out_id
,
             const std::string& id) {*out_id = std::move(id);
            loop->Quit();
          },
          &loop,
          out_id));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::AddRegistration(
    RegisteredKeyPtr key, bool* out_added) {
  base::RunLoop loop;
  proxy_->AddRegistration(std::move(key),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_added
,
             bool added) {*out_added = std::move(added);
            loop->Quit();
          },
          &loop,
          out_added));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::GetRegistrations(
    std::vector<RegisteredKeyPtr>* out_keys) {
  base::RunLoop loop;
  proxy_->GetRegistrations(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<RegisteredKeyPtr>* out_keys
,
             std::vector<RegisteredKeyPtr> keys) {*out_keys = std::move(keys);
            loop->Quit();
          },
          &loop,
          out_keys));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::RemoveRegistration(
    const std::vector<uint8_t>& key_handle, bool* out_removed) {
  base::RunLoop loop;
  proxy_->RemoveRegistration(std::move(key_handle),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_removed
,
             bool removed) {*out_removed = std::move(removed);
            loop->Quit();
          },
          &loop,
          out_removed));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::ClearRegistrations(
    ) {
  base::RunLoop loop;
  proxy_->ClearRegistrations(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::GetLargeBlob(
    const std::vector<uint8_t>& key_handle, absl::optional<std::vector<uint8_t>>* out_blob) {
  base::RunLoop loop;
  proxy_->GetLargeBlob(std::move(key_handle),
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<std::vector<uint8_t>>* out_blob
,
             const absl::optional<std::vector<uint8_t>>& blob) {*out_blob = std::move(blob);
            loop->Quit();
          },
          &loop,
          out_blob));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::SetLargeBlob(
    const std::vector<uint8_t>& key_handle, const std::vector<uint8_t>& blob, bool* out_set) {
  base::RunLoop loop;
  proxy_->SetLargeBlob(std::move(key_handle),std::move(blob),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_set
,
             bool set) {*out_set = std::move(set);
            loop->Quit();
          },
          &loop,
          out_set));
  loop.Run();
}
void VirtualAuthenticatorAsyncWaiter::SetUserVerified(
    bool verified) {
  base::RunLoop loop;
  proxy_->SetUserVerified(std::move(verified),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}



void VirtualAuthenticatorManagerInterceptorForTesting::CreateAuthenticator(VirtualAuthenticatorOptionsPtr options, CreateAuthenticatorCallback callback) {
  GetForwardingInterface()->CreateAuthenticator(std::move(options), std::move(callback));
}
void VirtualAuthenticatorManagerInterceptorForTesting::GetAuthenticators(GetAuthenticatorsCallback callback) {
  GetForwardingInterface()->GetAuthenticators(std::move(callback));
}
void VirtualAuthenticatorManagerInterceptorForTesting::RemoveAuthenticator(const std::string& id, RemoveAuthenticatorCallback callback) {
  GetForwardingInterface()->RemoveAuthenticator(std::move(id), std::move(callback));
}
void VirtualAuthenticatorManagerInterceptorForTesting::ClearAuthenticators(ClearAuthenticatorsCallback callback) {
  GetForwardingInterface()->ClearAuthenticators(std::move(callback));
}
VirtualAuthenticatorManagerAsyncWaiter::VirtualAuthenticatorManagerAsyncWaiter(
    VirtualAuthenticatorManager* proxy) : proxy_(proxy) {}

VirtualAuthenticatorManagerAsyncWaiter::~VirtualAuthenticatorManagerAsyncWaiter() = default;

void VirtualAuthenticatorManagerAsyncWaiter::CreateAuthenticator(
    VirtualAuthenticatorOptionsPtr options, ::mojo::PendingRemote<VirtualAuthenticator>* out_authenticator) {
  base::RunLoop loop;
  proxy_->CreateAuthenticator(std::move(options),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::mojo::PendingRemote<VirtualAuthenticator>* out_authenticator
,
             ::mojo::PendingRemote<VirtualAuthenticator> authenticator) {*out_authenticator = std::move(authenticator);
            loop->Quit();
          },
          &loop,
          out_authenticator));
  loop.Run();
}
void VirtualAuthenticatorManagerAsyncWaiter::GetAuthenticators(
    std::vector<::mojo::PendingRemote<VirtualAuthenticator>>* out_authenticators) {
  base::RunLoop loop;
  proxy_->GetAuthenticators(
      base::BindOnce(
          [](base::RunLoop* loop,
             std::vector<::mojo::PendingRemote<VirtualAuthenticator>>* out_authenticators
,
             std::vector<::mojo::PendingRemote<VirtualAuthenticator>> authenticators) {*out_authenticators = std::move(authenticators);
            loop->Quit();
          },
          &loop,
          out_authenticators));
  loop.Run();
}
void VirtualAuthenticatorManagerAsyncWaiter::RemoveAuthenticator(
    const std::string& id, bool* out_removed) {
  base::RunLoop loop;
  proxy_->RemoveAuthenticator(std::move(id),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_removed
,
             bool removed) {*out_removed = std::move(removed);
            loop->Quit();
          },
          &loop,
          out_removed));
  loop.Run();
}
void VirtualAuthenticatorManagerAsyncWaiter::ClearAuthenticators(
    ) {
  base::RunLoop loop;
  proxy_->ClearAuthenticators(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace test
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif