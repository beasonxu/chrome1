// third_party/blink/public/mojom/webauthn/authenticator.mojom-blink.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_AUTHENTICATOR_MOJOM_BLINK_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_AUTHENTICATOR_MOJOM_BLINK_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/webauthn/authenticator.mojom-shared.h"
#include "third_party/blink/public/mojom/webauthn/authenticator.mojom-blink-forward.h"
#include "components/payments/mojom/payment_request_data.mojom-blink.h"
#include "mojo/public/mojom/base/time.mojom-blink.h"
#include "third_party/blink/public/mojom/payments/payment_credential.mojom-blink-forward.h"
#include "url/mojom/origin.mojom-blink.h"
#include "url/mojom/url.mojom-blink.h"

#include "mojo/public/cpp/bindings/lib/wtf_clone_equals_util.h"
#include "mojo/public/cpp/bindings/lib/wtf_hash_util.h"
#include "third_party/blink/renderer/platform/wtf/hash_functions.h"
#include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/renderer/platform/platform_export.h"




namespace WTF {
struct blink_mojom_internal_AuthenticatorStatus_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::AuthenticatorStatus& value) {
    using utype = std::underlying_type<::blink::mojom::AuthenticatorStatus>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::AuthenticatorStatus& left, const ::blink::mojom::AuthenticatorStatus& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::AuthenticatorStatus>
    : public GenericHashTraits<::blink::mojom::AuthenticatorStatus> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::AuthenticatorStatus EmptyValue() { return static_cast<::blink::mojom::AuthenticatorStatus>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::AuthenticatorStatus& slot, bool) {
    slot = static_cast<::blink::mojom::AuthenticatorStatus>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::AuthenticatorStatus& value) {
    return value == static_cast<::blink::mojom::AuthenticatorStatus>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_AuthenticatorTransport_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::AuthenticatorTransport& value) {
    using utype = std::underlying_type<::blink::mojom::AuthenticatorTransport>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::AuthenticatorTransport& left, const ::blink::mojom::AuthenticatorTransport& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::AuthenticatorTransport>
    : public GenericHashTraits<::blink::mojom::AuthenticatorTransport> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::AuthenticatorTransport EmptyValue() { return static_cast<::blink::mojom::AuthenticatorTransport>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::AuthenticatorTransport& slot, bool) {
    slot = static_cast<::blink::mojom::AuthenticatorTransport>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::AuthenticatorTransport& value) {
    return value == static_cast<::blink::mojom::AuthenticatorTransport>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_UserVerificationRequirement_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::UserVerificationRequirement& value) {
    using utype = std::underlying_type<::blink::mojom::UserVerificationRequirement>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::UserVerificationRequirement& left, const ::blink::mojom::UserVerificationRequirement& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::UserVerificationRequirement>
    : public GenericHashTraits<::blink::mojom::UserVerificationRequirement> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::UserVerificationRequirement EmptyValue() { return static_cast<::blink::mojom::UserVerificationRequirement>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::UserVerificationRequirement& slot, bool) {
    slot = static_cast<::blink::mojom::UserVerificationRequirement>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::UserVerificationRequirement& value) {
    return value == static_cast<::blink::mojom::UserVerificationRequirement>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_AttestationConveyancePreference_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::AttestationConveyancePreference& value) {
    using utype = std::underlying_type<::blink::mojom::AttestationConveyancePreference>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::AttestationConveyancePreference& left, const ::blink::mojom::AttestationConveyancePreference& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::AttestationConveyancePreference>
    : public GenericHashTraits<::blink::mojom::AttestationConveyancePreference> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::AttestationConveyancePreference EmptyValue() { return static_cast<::blink::mojom::AttestationConveyancePreference>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::AttestationConveyancePreference& slot, bool) {
    slot = static_cast<::blink::mojom::AttestationConveyancePreference>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::AttestationConveyancePreference& value) {
    return value == static_cast<::blink::mojom::AttestationConveyancePreference>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ResidentKeyRequirement_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ResidentKeyRequirement& value) {
    using utype = std::underlying_type<::blink::mojom::ResidentKeyRequirement>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ResidentKeyRequirement& left, const ::blink::mojom::ResidentKeyRequirement& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ResidentKeyRequirement>
    : public GenericHashTraits<::blink::mojom::ResidentKeyRequirement> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ResidentKeyRequirement EmptyValue() { return static_cast<::blink::mojom::ResidentKeyRequirement>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ResidentKeyRequirement& slot, bool) {
    slot = static_cast<::blink::mojom::ResidentKeyRequirement>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ResidentKeyRequirement& value) {
    return value == static_cast<::blink::mojom::ResidentKeyRequirement>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_AuthenticatorAttachment_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::AuthenticatorAttachment& value) {
    using utype = std::underlying_type<::blink::mojom::AuthenticatorAttachment>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::AuthenticatorAttachment& left, const ::blink::mojom::AuthenticatorAttachment& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::AuthenticatorAttachment>
    : public GenericHashTraits<::blink::mojom::AuthenticatorAttachment> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::AuthenticatorAttachment EmptyValue() { return static_cast<::blink::mojom::AuthenticatorAttachment>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::AuthenticatorAttachment& slot, bool) {
    slot = static_cast<::blink::mojom::AuthenticatorAttachment>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::AuthenticatorAttachment& value) {
    return value == static_cast<::blink::mojom::AuthenticatorAttachment>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_ProtectionPolicy_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::ProtectionPolicy& value) {
    using utype = std::underlying_type<::blink::mojom::ProtectionPolicy>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::ProtectionPolicy& left, const ::blink::mojom::ProtectionPolicy& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::ProtectionPolicy>
    : public GenericHashTraits<::blink::mojom::ProtectionPolicy> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::ProtectionPolicy EmptyValue() { return static_cast<::blink::mojom::ProtectionPolicy>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::ProtectionPolicy& slot, bool) {
    slot = static_cast<::blink::mojom::ProtectionPolicy>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::ProtectionPolicy& value) {
    return value == static_cast<::blink::mojom::ProtectionPolicy>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_LargeBlobSupport_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::LargeBlobSupport& value) {
    using utype = std::underlying_type<::blink::mojom::LargeBlobSupport>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::LargeBlobSupport& left, const ::blink::mojom::LargeBlobSupport& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::LargeBlobSupport>
    : public GenericHashTraits<::blink::mojom::LargeBlobSupport> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::LargeBlobSupport EmptyValue() { return static_cast<::blink::mojom::LargeBlobSupport>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::LargeBlobSupport& slot, bool) {
    slot = static_cast<::blink::mojom::LargeBlobSupport>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::LargeBlobSupport& value) {
    return value == static_cast<::blink::mojom::LargeBlobSupport>(-1000001);
  }
};
}  // namespace WTF


namespace WTF {
struct blink_mojom_internal_PublicKeyCredentialType_DataHashFn {
  static unsigned GetHash(const ::blink::mojom::PublicKeyCredentialType& value) {
    using utype = std::underlying_type<::blink::mojom::PublicKeyCredentialType>::type;
    return DefaultHash<utype>::Hash().GetHash(static_cast<utype>(value));
  }
  static bool Equal(const ::blink::mojom::PublicKeyCredentialType& left, const ::blink::mojom::PublicKeyCredentialType& right) {
    return left == right;
  }
  static const bool safe_to_compare_to_empty_or_deleted = true;
};

template <>
struct HashTraits<::blink::mojom::PublicKeyCredentialType>
    : public GenericHashTraits<::blink::mojom::PublicKeyCredentialType> {
  static_assert(true,
                "-1000000 is a reserved enum value");
  static_assert(true,
                "-1000001 is a reserved enum value");
  static const bool kEmptyValueIsZero = false;
  static ::blink::mojom::PublicKeyCredentialType EmptyValue() { return static_cast<::blink::mojom::PublicKeyCredentialType>(-1000000); }
  static void ConstructDeletedValue(::blink::mojom::PublicKeyCredentialType& slot, bool) {
    slot = static_cast<::blink::mojom::PublicKeyCredentialType>(-1000001);
  }
  static bool IsDeletedValue(const ::blink::mojom::PublicKeyCredentialType& value) {
    return value == static_cast<::blink::mojom::PublicKeyCredentialType>(-1000001);
  }
};
}  // namespace WTF


namespace blink {
namespace mojom {
namespace blink {

class AuthenticatorProxy;

template <typename ImplRefTraits>
class AuthenticatorStub;

class AuthenticatorRequestValidator;
class AuthenticatorResponseValidator;


class PLATFORM_EXPORT Authenticator
    : public AuthenticatorInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = AuthenticatorInterfaceBase;
  using Proxy_ = AuthenticatorProxy;

  template <typename ImplRefTraits>
  using Stub_ = AuthenticatorStub<ImplRefTraits>;

  using RequestValidator_ = AuthenticatorRequestValidator;
  using ResponseValidator_ = AuthenticatorResponseValidator;
  enum MethodMinVersions : uint32_t {
    kMakeCredentialMinVersion = 0,
    kGetAssertionMinVersion = 0,
    kIsUserVerifyingPlatformAuthenticatorAvailableMinVersion = 0,
    kIsConditionalMediationAvailableMinVersion = 0,
    kCancelMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct MakeCredential_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetAssertion_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct IsUserVerifyingPlatformAuthenticatorAvailable_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct IsConditionalMediationAvailable_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct Cancel_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~Authenticator() = default;


  using MakeCredentialCallback = base::OnceCallback<void(AuthenticatorStatus, MakeCredentialAuthenticatorResponsePtr, WebAuthnDOMExceptionDetailsPtr)>;
  
  virtual void MakeCredential(PublicKeyCredentialCreationOptionsPtr options, MakeCredentialCallback callback) = 0;


  using GetAssertionCallback = base::OnceCallback<void(AuthenticatorStatus, GetAssertionAuthenticatorResponsePtr, WebAuthnDOMExceptionDetailsPtr)>;
  
  virtual void GetAssertion(PublicKeyCredentialRequestOptionsPtr options, GetAssertionCallback callback) = 0;


  using IsUserVerifyingPlatformAuthenticatorAvailableCallback = base::OnceCallback<void(bool)>;
  
  virtual void IsUserVerifyingPlatformAuthenticatorAvailable(IsUserVerifyingPlatformAuthenticatorAvailableCallback callback) = 0;


  using IsConditionalMediationAvailableCallback = base::OnceCallback<void(bool)>;
  
  virtual void IsConditionalMediationAvailable(IsConditionalMediationAvailableCallback callback) = 0;

  
  virtual void Cancel() = 0;
};



class PLATFORM_EXPORT AuthenticatorProxy
    : public Authenticator {
 public:
  using InterfaceType = Authenticator;

  explicit AuthenticatorProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void MakeCredential(PublicKeyCredentialCreationOptionsPtr options, MakeCredentialCallback callback) final;
  
  void GetAssertion(PublicKeyCredentialRequestOptionsPtr options, GetAssertionCallback callback) final;
  
  void IsUserVerifyingPlatformAuthenticatorAvailable(IsUserVerifyingPlatformAuthenticatorAvailableCallback callback) final;
  
  void IsConditionalMediationAvailable(IsConditionalMediationAvailableCallback callback) final;
  
  void Cancel() final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class PLATFORM_EXPORT AuthenticatorStubDispatch {
 public:
  static bool Accept(Authenticator* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      Authenticator* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<Authenticator>>
class AuthenticatorStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  AuthenticatorStub() = default;
  ~AuthenticatorStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AuthenticatorStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AuthenticatorStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class PLATFORM_EXPORT AuthenticatorRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class PLATFORM_EXPORT AuthenticatorResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};






class PLATFORM_EXPORT UvmEntry {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<UvmEntry, T>::value>;
  using DataView = UvmEntryDataView;
  using Data_ = internal::UvmEntry_Data;

  template <typename... Args>
  static UvmEntryPtr New(Args&&... args) {
    return UvmEntryPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static UvmEntryPtr From(const U& u) {
    return mojo::TypeConverter<UvmEntryPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, UvmEntry>::Convert(*this);
  }


  UvmEntry();

  UvmEntry(
      uint32_t user_verification_method,
      uint16_t key_protection_type,
      uint16_t matcher_protection_type);


  ~UvmEntry();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = UvmEntryPtr>
  UvmEntryPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, UvmEntry::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, UvmEntry::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        UvmEntry::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        UvmEntry::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::UvmEntry_UnserializedMessageContext<
            UserType, UvmEntry::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<UvmEntry::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return UvmEntry::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::UvmEntry_UnserializedMessageContext<
            UserType, UvmEntry::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<UvmEntry::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint32_t user_verification_method;
  
  uint16_t key_protection_type;
  
  uint16_t matcher_protection_type;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, UvmEntry::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, UvmEntry::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, UvmEntry::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, UvmEntry::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}









class PLATFORM_EXPORT PublicKeyCredentialParameters {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PublicKeyCredentialParameters, T>::value>;
  using DataView = PublicKeyCredentialParametersDataView;
  using Data_ = internal::PublicKeyCredentialParameters_Data;

  template <typename... Args>
  static PublicKeyCredentialParametersPtr New(Args&&... args) {
    return PublicKeyCredentialParametersPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PublicKeyCredentialParametersPtr From(const U& u) {
    return mojo::TypeConverter<PublicKeyCredentialParametersPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PublicKeyCredentialParameters>::Convert(*this);
  }


  PublicKeyCredentialParameters();

  PublicKeyCredentialParameters(
      PublicKeyCredentialType type,
      int32_t algorithm_identifier);


  ~PublicKeyCredentialParameters();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PublicKeyCredentialParametersPtr>
  PublicKeyCredentialParametersPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PublicKeyCredentialParameters::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PublicKeyCredentialParameters::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PublicKeyCredentialParameters_UnserializedMessageContext<
            UserType, PublicKeyCredentialParameters::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PublicKeyCredentialParameters::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PublicKeyCredentialParameters::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PublicKeyCredentialParameters_UnserializedMessageContext<
            UserType, PublicKeyCredentialParameters::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PublicKeyCredentialParameters::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  PublicKeyCredentialType type;
  
  int32_t algorithm_identifier;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}












class PLATFORM_EXPORT AuthenticatorSelectionCriteria {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AuthenticatorSelectionCriteria, T>::value>;
  using DataView = AuthenticatorSelectionCriteriaDataView;
  using Data_ = internal::AuthenticatorSelectionCriteria_Data;

  template <typename... Args>
  static AuthenticatorSelectionCriteriaPtr New(Args&&... args) {
    return AuthenticatorSelectionCriteriaPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AuthenticatorSelectionCriteriaPtr From(const U& u) {
    return mojo::TypeConverter<AuthenticatorSelectionCriteriaPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AuthenticatorSelectionCriteria>::Convert(*this);
  }


  AuthenticatorSelectionCriteria();

  AuthenticatorSelectionCriteria(
      AuthenticatorAttachment authenticator_attachment,
      ResidentKeyRequirement resident_key,
      UserVerificationRequirement user_verification);


  ~AuthenticatorSelectionCriteria();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AuthenticatorSelectionCriteriaPtr>
  AuthenticatorSelectionCriteriaPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AuthenticatorSelectionCriteria::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AuthenticatorSelectionCriteria::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AuthenticatorSelectionCriteria_UnserializedMessageContext<
            UserType, AuthenticatorSelectionCriteria::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AuthenticatorSelectionCriteria::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return AuthenticatorSelectionCriteria::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AuthenticatorSelectionCriteria_UnserializedMessageContext<
            UserType, AuthenticatorSelectionCriteria::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AuthenticatorSelectionCriteria::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  AuthenticatorAttachment authenticator_attachment;
  
  ResidentKeyRequirement resident_key;
  
  UserVerificationRequirement user_verification;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class PLATFORM_EXPORT WebAuthnDOMExceptionDetails {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<WebAuthnDOMExceptionDetails, T>::value>;
  using DataView = WebAuthnDOMExceptionDetailsDataView;
  using Data_ = internal::WebAuthnDOMExceptionDetails_Data;

  template <typename... Args>
  static WebAuthnDOMExceptionDetailsPtr New(Args&&... args) {
    return WebAuthnDOMExceptionDetailsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static WebAuthnDOMExceptionDetailsPtr From(const U& u) {
    return mojo::TypeConverter<WebAuthnDOMExceptionDetailsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, WebAuthnDOMExceptionDetails>::Convert(*this);
  }


  WebAuthnDOMExceptionDetails();

  WebAuthnDOMExceptionDetails(
      const WTF::String& name,
      const WTF::String& message);


  ~WebAuthnDOMExceptionDetails();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = WebAuthnDOMExceptionDetailsPtr>
  WebAuthnDOMExceptionDetailsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        WebAuthnDOMExceptionDetails::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        WebAuthnDOMExceptionDetails::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::WebAuthnDOMExceptionDetails_UnserializedMessageContext<
            UserType, WebAuthnDOMExceptionDetails::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<WebAuthnDOMExceptionDetails::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return WebAuthnDOMExceptionDetails::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::WebAuthnDOMExceptionDetails_UnserializedMessageContext<
            UserType, WebAuthnDOMExceptionDetails::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<WebAuthnDOMExceptionDetails::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String name;
  
  WTF::String message;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}







class PLATFORM_EXPORT CommonCredentialInfo {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CommonCredentialInfo, T>::value>;
  using DataView = CommonCredentialInfoDataView;
  using Data_ = internal::CommonCredentialInfo_Data;

  template <typename... Args>
  static CommonCredentialInfoPtr New(Args&&... args) {
    return CommonCredentialInfoPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CommonCredentialInfoPtr From(const U& u) {
    return mojo::TypeConverter<CommonCredentialInfoPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CommonCredentialInfo>::Convert(*this);
  }


  CommonCredentialInfo();

  CommonCredentialInfo(
      const WTF::String& id,
      WTF::Vector<uint8_t> raw_id,
      WTF::Vector<uint8_t> client_data_json,
      WTF::Vector<uint8_t> authenticator_data);


  ~CommonCredentialInfo();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CommonCredentialInfoPtr>
  CommonCredentialInfoPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CommonCredentialInfo::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CommonCredentialInfo::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CommonCredentialInfo::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CommonCredentialInfo::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CommonCredentialInfo_UnserializedMessageContext<
            UserType, CommonCredentialInfo::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CommonCredentialInfo::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CommonCredentialInfo::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CommonCredentialInfo_UnserializedMessageContext<
            UserType, CommonCredentialInfo::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CommonCredentialInfo::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String id;
  
  WTF::Vector<uint8_t> raw_id;
  
  WTF::Vector<uint8_t> client_data_json;
  
  WTF::Vector<uint8_t> authenticator_data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CommonCredentialInfo::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CommonCredentialInfo::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CommonCredentialInfo::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CommonCredentialInfo::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class PLATFORM_EXPORT MakeCredentialAuthenticatorResponse {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MakeCredentialAuthenticatorResponse, T>::value>;
  using DataView = MakeCredentialAuthenticatorResponseDataView;
  using Data_ = internal::MakeCredentialAuthenticatorResponse_Data;

  template <typename... Args>
  static MakeCredentialAuthenticatorResponsePtr New(Args&&... args) {
    return MakeCredentialAuthenticatorResponsePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MakeCredentialAuthenticatorResponsePtr From(const U& u) {
    return mojo::TypeConverter<MakeCredentialAuthenticatorResponsePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MakeCredentialAuthenticatorResponse>::Convert(*this);
  }


  MakeCredentialAuthenticatorResponse();

  MakeCredentialAuthenticatorResponse(
      CommonCredentialInfoPtr info,
      AuthenticatorAttachment authenticator_attachment,
      WTF::Vector<uint8_t> attestation_object,
      WTF::Vector<AuthenticatorTransport> transports,
      bool echo_hmac_create_secret,
      bool hmac_create_secret,
      bool echo_prf,
      bool prf,
      bool echo_cred_blob,
      bool cred_blob,
      absl::optional<WTF::Vector<uint8_t>> public_key_der,
      int32_t public_key_algo,
      bool echo_cred_props,
      bool has_cred_props_rk,
      bool cred_props_rk,
      bool echo_large_blob,
      bool supports_large_blob);

MakeCredentialAuthenticatorResponse(const MakeCredentialAuthenticatorResponse&) = delete;
MakeCredentialAuthenticatorResponse& operator=(const MakeCredentialAuthenticatorResponse&) = delete;

  ~MakeCredentialAuthenticatorResponse();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MakeCredentialAuthenticatorResponsePtr>
  MakeCredentialAuthenticatorResponsePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MakeCredentialAuthenticatorResponse::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MakeCredentialAuthenticatorResponse::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MakeCredentialAuthenticatorResponse_UnserializedMessageContext<
            UserType, MakeCredentialAuthenticatorResponse::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MakeCredentialAuthenticatorResponse::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return MakeCredentialAuthenticatorResponse::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MakeCredentialAuthenticatorResponse_UnserializedMessageContext<
            UserType, MakeCredentialAuthenticatorResponse::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MakeCredentialAuthenticatorResponse::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  CommonCredentialInfoPtr info;
  
  AuthenticatorAttachment authenticator_attachment;
  
  WTF::Vector<uint8_t> attestation_object;
  
  WTF::Vector<AuthenticatorTransport> transports;
  
  bool echo_hmac_create_secret;
  
  bool hmac_create_secret;
  
  bool echo_prf;
  
  bool prf;
  
  bool echo_cred_blob;
  
  bool cred_blob;
  
  absl::optional<WTF::Vector<uint8_t>> public_key_der;
  
  int32_t public_key_algo;
  
  bool echo_cred_props;
  
  bool has_cred_props_rk;
  
  bool cred_props_rk;
  
  bool echo_large_blob;
  
  bool supports_large_blob;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT GetAssertionAuthenticatorResponse {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<GetAssertionAuthenticatorResponse, T>::value>;
  using DataView = GetAssertionAuthenticatorResponseDataView;
  using Data_ = internal::GetAssertionAuthenticatorResponse_Data;

  template <typename... Args>
  static GetAssertionAuthenticatorResponsePtr New(Args&&... args) {
    return GetAssertionAuthenticatorResponsePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static GetAssertionAuthenticatorResponsePtr From(const U& u) {
    return mojo::TypeConverter<GetAssertionAuthenticatorResponsePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, GetAssertionAuthenticatorResponse>::Convert(*this);
  }


  GetAssertionAuthenticatorResponse();

  GetAssertionAuthenticatorResponse(
      CommonCredentialInfoPtr info,
      AuthenticatorAttachment authenticator_attachment,
      WTF::Vector<uint8_t> signature,
      absl::optional<WTF::Vector<uint8_t>> user_handle,
      bool echo_appid_extension,
      bool appid_extension,
      bool echo_user_verification_methods,
      absl::optional<WTF::Vector<UvmEntryPtr>> user_verification_methods,
      bool echo_prf,
      PRFValuesPtr prf_results,
      bool prf_not_evaluated,
      bool echo_large_blob,
      absl::optional<WTF::Vector<uint8_t>> large_blob,
      bool echo_large_blob_written,
      bool large_blob_written,
      absl::optional<WTF::Vector<uint8_t>> get_cred_blob);

GetAssertionAuthenticatorResponse(const GetAssertionAuthenticatorResponse&) = delete;
GetAssertionAuthenticatorResponse& operator=(const GetAssertionAuthenticatorResponse&) = delete;

  ~GetAssertionAuthenticatorResponse();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = GetAssertionAuthenticatorResponsePtr>
  GetAssertionAuthenticatorResponsePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        GetAssertionAuthenticatorResponse::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        GetAssertionAuthenticatorResponse::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::GetAssertionAuthenticatorResponse_UnserializedMessageContext<
            UserType, GetAssertionAuthenticatorResponse::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<GetAssertionAuthenticatorResponse::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return GetAssertionAuthenticatorResponse::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::GetAssertionAuthenticatorResponse_UnserializedMessageContext<
            UserType, GetAssertionAuthenticatorResponse::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<GetAssertionAuthenticatorResponse::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  CommonCredentialInfoPtr info;
  
  AuthenticatorAttachment authenticator_attachment;
  
  WTF::Vector<uint8_t> signature;
  
  absl::optional<WTF::Vector<uint8_t>> user_handle;
  
  bool echo_appid_extension;
  
  bool appid_extension;
  
  bool echo_user_verification_methods;
  
  absl::optional<WTF::Vector<UvmEntryPtr>> user_verification_methods;
  
  bool echo_prf;
  
  PRFValuesPtr prf_results;
  
  bool prf_not_evaluated;
  
  bool echo_large_blob;
  
  absl::optional<WTF::Vector<uint8_t>> large_blob;
  
  bool echo_large_blob_written;
  
  bool large_blob_written;
  
  absl::optional<WTF::Vector<uint8_t>> get_cred_blob;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PublicKeyCredentialRpEntity {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PublicKeyCredentialRpEntity, T>::value>;
  using DataView = PublicKeyCredentialRpEntityDataView;
  using Data_ = internal::PublicKeyCredentialRpEntity_Data;

  template <typename... Args>
  static PublicKeyCredentialRpEntityPtr New(Args&&... args) {
    return PublicKeyCredentialRpEntityPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PublicKeyCredentialRpEntityPtr From(const U& u) {
    return mojo::TypeConverter<PublicKeyCredentialRpEntityPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PublicKeyCredentialRpEntity>::Convert(*this);
  }


  PublicKeyCredentialRpEntity();

  PublicKeyCredentialRpEntity(
      const WTF::String& id,
      const WTF::String& name,
      const absl::optional<::blink::KURL>& icon);


  ~PublicKeyCredentialRpEntity();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PublicKeyCredentialRpEntityPtr>
  PublicKeyCredentialRpEntityPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PublicKeyCredentialRpEntity::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PublicKeyCredentialRpEntity::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PublicKeyCredentialRpEntity_UnserializedMessageContext<
            UserType, PublicKeyCredentialRpEntity::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PublicKeyCredentialRpEntity::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PublicKeyCredentialRpEntity::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PublicKeyCredentialRpEntity_UnserializedMessageContext<
            UserType, PublicKeyCredentialRpEntity::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PublicKeyCredentialRpEntity::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String id;
  
  WTF::String name;
  
  absl::optional<::blink::KURL> icon;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PublicKeyCredentialUserEntity {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PublicKeyCredentialUserEntity, T>::value>;
  using DataView = PublicKeyCredentialUserEntityDataView;
  using Data_ = internal::PublicKeyCredentialUserEntity_Data;

  template <typename... Args>
  static PublicKeyCredentialUserEntityPtr New(Args&&... args) {
    return PublicKeyCredentialUserEntityPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PublicKeyCredentialUserEntityPtr From(const U& u) {
    return mojo::TypeConverter<PublicKeyCredentialUserEntityPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PublicKeyCredentialUserEntity>::Convert(*this);
  }


  PublicKeyCredentialUserEntity();

  PublicKeyCredentialUserEntity(
      WTF::Vector<uint8_t> id,
      const WTF::String& name,
      const absl::optional<::blink::KURL>& icon,
      const WTF::String& display_name);


  ~PublicKeyCredentialUserEntity();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PublicKeyCredentialUserEntityPtr>
  PublicKeyCredentialUserEntityPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PublicKeyCredentialUserEntity::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PublicKeyCredentialUserEntity::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PublicKeyCredentialUserEntity_UnserializedMessageContext<
            UserType, PublicKeyCredentialUserEntity::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PublicKeyCredentialUserEntity::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PublicKeyCredentialUserEntity::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PublicKeyCredentialUserEntity_UnserializedMessageContext<
            UserType, PublicKeyCredentialUserEntity::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PublicKeyCredentialUserEntity::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::Vector<uint8_t> id;
  
  WTF::String name;
  
  absl::optional<::blink::KURL> icon;
  
  WTF::String display_name;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class PLATFORM_EXPORT CableAuthentication {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CableAuthentication, T>::value>;
  using DataView = CableAuthenticationDataView;
  using Data_ = internal::CableAuthentication_Data;

  template <typename... Args>
  static CableAuthenticationPtr New(Args&&... args) {
    return CableAuthenticationPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CableAuthenticationPtr From(const U& u) {
    return mojo::TypeConverter<CableAuthenticationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CableAuthentication>::Convert(*this);
  }


  CableAuthentication();

  CableAuthentication(
      uint8_t version,
      absl::optional<WTF::Vector<uint8_t>> client_eid,
      absl::optional<WTF::Vector<uint8_t>> authenticator_eid,
      absl::optional<WTF::Vector<uint8_t>> session_pre_key,
      absl::optional<WTF::Vector<uint8_t>> server_link_data,
      absl::optional<WTF::Vector<uint8_t>> experiments);


  ~CableAuthentication();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CableAuthenticationPtr>
  CableAuthenticationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CableAuthentication::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CableAuthentication::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CableAuthentication::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CableAuthentication::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CableAuthentication_UnserializedMessageContext<
            UserType, CableAuthentication::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CableAuthentication::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CableAuthentication::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CableAuthentication_UnserializedMessageContext<
            UserType, CableAuthentication::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CableAuthentication::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint8_t version;
  
  absl::optional<WTF::Vector<uint8_t>> client_eid;
  
  absl::optional<WTF::Vector<uint8_t>> authenticator_eid;
  
  absl::optional<WTF::Vector<uint8_t>> session_pre_key;
  
  absl::optional<WTF::Vector<uint8_t>> server_link_data;
  
  absl::optional<WTF::Vector<uint8_t>> experiments;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CableAuthentication::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CableAuthentication::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CableAuthentication::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CableAuthentication::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT CableRegistration {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CableRegistration, T>::value>;
  using DataView = CableRegistrationDataView;
  using Data_ = internal::CableRegistration_Data;

  template <typename... Args>
  static CableRegistrationPtr New(Args&&... args) {
    return CableRegistrationPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CableRegistrationPtr From(const U& u) {
    return mojo::TypeConverter<CableRegistrationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CableRegistration>::Convert(*this);
  }


  CableRegistration();

  CableRegistration(
      WTF::Vector<uint8_t> versions,
      WTF::Vector<uint8_t> relying_party_public_key);


  ~CableRegistration();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CableRegistrationPtr>
  CableRegistrationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CableRegistration::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CableRegistration::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CableRegistration::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CableRegistration::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CableRegistration_UnserializedMessageContext<
            UserType, CableRegistration::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CableRegistration::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return CableRegistration::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CableRegistration_UnserializedMessageContext<
            UserType, CableRegistration::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CableRegistration::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::Vector<uint8_t> versions;
  
  WTF::Vector<uint8_t> relying_party_public_key;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CableRegistration::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CableRegistration::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CableRegistration::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CableRegistration::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PRFValues {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PRFValues, T>::value>;
  using DataView = PRFValuesDataView;
  using Data_ = internal::PRFValues_Data;

  template <typename... Args>
  static PRFValuesPtr New(Args&&... args) {
    return PRFValuesPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PRFValuesPtr From(const U& u) {
    return mojo::TypeConverter<PRFValuesPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PRFValues>::Convert(*this);
  }


  PRFValues();

  PRFValues(
      absl::optional<WTF::Vector<uint8_t>> id,
      WTF::Vector<uint8_t> first,
      absl::optional<WTF::Vector<uint8_t>> second);


  ~PRFValues();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PRFValuesPtr>
  PRFValuesPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PRFValues::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PRFValues::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PRFValues::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PRFValues::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PRFValues_UnserializedMessageContext<
            UserType, PRFValues::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PRFValues::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PRFValues::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PRFValues_UnserializedMessageContext<
            UserType, PRFValues::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PRFValues::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  absl::optional<WTF::Vector<uint8_t>> id;
  
  WTF::Vector<uint8_t> first;
  
  absl::optional<WTF::Vector<uint8_t>> second;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PRFValues::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PRFValues::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PRFValues::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PRFValues::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PaymentOptions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PaymentOptions, T>::value>;
  using DataView = PaymentOptionsDataView;
  using Data_ = internal::PaymentOptions_Data;

  template <typename... Args>
  static PaymentOptionsPtr New(Args&&... args) {
    return PaymentOptionsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PaymentOptionsPtr From(const U& u) {
    return mojo::TypeConverter<PaymentOptionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PaymentOptions>::Convert(*this);
  }


  PaymentOptions();

  PaymentOptions(
      ::payments::mojom::blink::PaymentCurrencyAmountPtr total,
      PaymentCredentialInstrumentPtr instrument,
      const WTF::String& payee_name,
      const ::scoped_refptr<const ::blink::SecurityOrigin>& payee_origin);

PaymentOptions(const PaymentOptions&) = delete;
PaymentOptions& operator=(const PaymentOptions&) = delete;

  ~PaymentOptions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PaymentOptionsPtr>
  PaymentOptionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PaymentOptions::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PaymentOptions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PaymentOptions_UnserializedMessageContext<
            UserType, PaymentOptions::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PaymentOptions::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PaymentOptions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PaymentOptions_UnserializedMessageContext<
            UserType, PaymentOptions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PaymentOptions::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::payments::mojom::blink::PaymentCurrencyAmountPtr total;
  
  PaymentCredentialInstrumentPtr instrument;
  
  WTF::String payee_name;
  
  ::scoped_refptr<const ::blink::SecurityOrigin> payee_origin;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PaymentOptions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PaymentCredentialInstrument {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PaymentCredentialInstrument, T>::value>;
  using DataView = PaymentCredentialInstrumentDataView;
  using Data_ = internal::PaymentCredentialInstrument_Data;

  template <typename... Args>
  static PaymentCredentialInstrumentPtr New(Args&&... args) {
    return PaymentCredentialInstrumentPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PaymentCredentialInstrumentPtr From(const U& u) {
    return mojo::TypeConverter<PaymentCredentialInstrumentPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PaymentCredentialInstrument>::Convert(*this);
  }


  PaymentCredentialInstrument();

  PaymentCredentialInstrument(
      const WTF::String& display_name,
      const ::blink::KURL& icon,
      bool iconMustBeShown);


  ~PaymentCredentialInstrument();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PaymentCredentialInstrumentPtr>
  PaymentCredentialInstrumentPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PaymentCredentialInstrument::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PaymentCredentialInstrument::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PaymentCredentialInstrument::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PaymentCredentialInstrument::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PaymentCredentialInstrument_UnserializedMessageContext<
            UserType, PaymentCredentialInstrument::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PaymentCredentialInstrument::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PaymentCredentialInstrument::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PaymentCredentialInstrument_UnserializedMessageContext<
            UserType, PaymentCredentialInstrument::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PaymentCredentialInstrument::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  WTF::String display_name;
  
  ::blink::KURL icon;
  
  bool iconMustBeShown;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PaymentCredentialInstrument::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PaymentCredentialInstrument::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PaymentCredentialInstrument::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PaymentCredentialInstrument::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT RemoteDesktopClientOverride {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<RemoteDesktopClientOverride, T>::value>;
  using DataView = RemoteDesktopClientOverrideDataView;
  using Data_ = internal::RemoteDesktopClientOverride_Data;

  template <typename... Args>
  static RemoteDesktopClientOverridePtr New(Args&&... args) {
    return RemoteDesktopClientOverridePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RemoteDesktopClientOverridePtr From(const U& u) {
    return mojo::TypeConverter<RemoteDesktopClientOverridePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RemoteDesktopClientOverride>::Convert(*this);
  }


  RemoteDesktopClientOverride();

  RemoteDesktopClientOverride(
      const ::scoped_refptr<const ::blink::SecurityOrigin>& origin,
      bool same_origin_with_ancestors);


  ~RemoteDesktopClientOverride();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RemoteDesktopClientOverridePtr>
  RemoteDesktopClientOverridePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        RemoteDesktopClientOverride::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        RemoteDesktopClientOverride::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::RemoteDesktopClientOverride_UnserializedMessageContext<
            UserType, RemoteDesktopClientOverride::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<RemoteDesktopClientOverride::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return RemoteDesktopClientOverride::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::RemoteDesktopClientOverride_UnserializedMessageContext<
            UserType, RemoteDesktopClientOverride::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<RemoteDesktopClientOverride::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::scoped_refptr<const ::blink::SecurityOrigin> origin;
  
  bool same_origin_with_ancestors;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PublicKeyCredentialRequestOptions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PublicKeyCredentialRequestOptions, T>::value>;
  using DataView = PublicKeyCredentialRequestOptionsDataView;
  using Data_ = internal::PublicKeyCredentialRequestOptions_Data;

  template <typename... Args>
  static PublicKeyCredentialRequestOptionsPtr New(Args&&... args) {
    return PublicKeyCredentialRequestOptionsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PublicKeyCredentialRequestOptionsPtr From(const U& u) {
    return mojo::TypeConverter<PublicKeyCredentialRequestOptionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PublicKeyCredentialRequestOptions>::Convert(*this);
  }


  PublicKeyCredentialRequestOptions();

  PublicKeyCredentialRequestOptions(
      bool is_conditional,
      WTF::Vector<uint8_t> challenge,
      absl::optional<::base::TimeDelta> timeout,
      const WTF::String& relying_party_id,
      WTF::Vector<PublicKeyCredentialDescriptorPtr> allow_credentials,
      UserVerificationRequirement user_verification,
      const WTF::String& appid,
      WTF::Vector<CableAuthenticationPtr> cable_authentication_data,
      bool user_verification_methods,
      bool prf,
      WTF::Vector<PRFValuesPtr> prf_inputs,
      bool large_blob_read,
      absl::optional<WTF::Vector<uint8_t>> large_blob_write,
      bool get_cred_blob,
      RemoteDesktopClientOverridePtr remote_desktop_client_override);

PublicKeyCredentialRequestOptions(const PublicKeyCredentialRequestOptions&) = delete;
PublicKeyCredentialRequestOptions& operator=(const PublicKeyCredentialRequestOptions&) = delete;

  ~PublicKeyCredentialRequestOptions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PublicKeyCredentialRequestOptionsPtr>
  PublicKeyCredentialRequestOptionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PublicKeyCredentialRequestOptions::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PublicKeyCredentialRequestOptions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PublicKeyCredentialRequestOptions_UnserializedMessageContext<
            UserType, PublicKeyCredentialRequestOptions::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PublicKeyCredentialRequestOptions::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PublicKeyCredentialRequestOptions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PublicKeyCredentialRequestOptions_UnserializedMessageContext<
            UserType, PublicKeyCredentialRequestOptions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PublicKeyCredentialRequestOptions::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  bool is_conditional;
  
  WTF::Vector<uint8_t> challenge;
  
  absl::optional<::base::TimeDelta> timeout;
  
  WTF::String relying_party_id;
  
  WTF::Vector<PublicKeyCredentialDescriptorPtr> allow_credentials;
  
  UserVerificationRequirement user_verification;
  
  WTF::String appid;
  
  WTF::Vector<CableAuthenticationPtr> cable_authentication_data;
  
  bool user_verification_methods;
  
  bool prf;
  
  WTF::Vector<PRFValuesPtr> prf_inputs;
  
  bool large_blob_read;
  
  absl::optional<WTF::Vector<uint8_t>> large_blob_write;
  
  bool get_cred_blob;
  
  RemoteDesktopClientOverridePtr remote_desktop_client_override;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class PLATFORM_EXPORT PublicKeyCredentialCreationOptions {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PublicKeyCredentialCreationOptions, T>::value>;
  using DataView = PublicKeyCredentialCreationOptionsDataView;
  using Data_ = internal::PublicKeyCredentialCreationOptions_Data;

  template <typename... Args>
  static PublicKeyCredentialCreationOptionsPtr New(Args&&... args) {
    return PublicKeyCredentialCreationOptionsPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PublicKeyCredentialCreationOptionsPtr From(const U& u) {
    return mojo::TypeConverter<PublicKeyCredentialCreationOptionsPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PublicKeyCredentialCreationOptions>::Convert(*this);
  }


  PublicKeyCredentialCreationOptions();

  PublicKeyCredentialCreationOptions(
      PublicKeyCredentialRpEntityPtr relying_party,
      PublicKeyCredentialUserEntityPtr user,
      WTF::Vector<uint8_t> challenge,
      WTF::Vector<PublicKeyCredentialParametersPtr> public_key_parameters,
      absl::optional<::base::TimeDelta> timeout,
      WTF::Vector<PublicKeyCredentialDescriptorPtr> exclude_credentials,
      AuthenticatorSelectionCriteriaPtr authenticator_selection,
      AttestationConveyancePreference attestation,
      CableRegistrationPtr cable_registration_data,
      bool hmac_create_secret,
      bool prf_enable,
      ProtectionPolicy protection_policy,
      bool enforce_protection_policy,
      const WTF::String& appid_exclude,
      bool cred_props,
      LargeBlobSupport large_blob_enable,
      bool is_payment_credential_creation,
      absl::optional<WTF::Vector<uint8_t>> cred_blob,
      bool google_legacy_app_id_support,
      bool min_pin_length_requested,
      RemoteDesktopClientOverridePtr remote_desktop_client_override);

PublicKeyCredentialCreationOptions(const PublicKeyCredentialCreationOptions&) = delete;
PublicKeyCredentialCreationOptions& operator=(const PublicKeyCredentialCreationOptions&) = delete;

  ~PublicKeyCredentialCreationOptions();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PublicKeyCredentialCreationOptionsPtr>
  PublicKeyCredentialCreationOptionsPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PublicKeyCredentialCreationOptions::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PublicKeyCredentialCreationOptions::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PublicKeyCredentialCreationOptions_UnserializedMessageContext<
            UserType, PublicKeyCredentialCreationOptions::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PublicKeyCredentialCreationOptions::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PublicKeyCredentialCreationOptions::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PublicKeyCredentialCreationOptions_UnserializedMessageContext<
            UserType, PublicKeyCredentialCreationOptions::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PublicKeyCredentialCreationOptions::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  PublicKeyCredentialRpEntityPtr relying_party;
  
  PublicKeyCredentialUserEntityPtr user;
  
  WTF::Vector<uint8_t> challenge;
  
  WTF::Vector<PublicKeyCredentialParametersPtr> public_key_parameters;
  
  absl::optional<::base::TimeDelta> timeout;
  
  WTF::Vector<PublicKeyCredentialDescriptorPtr> exclude_credentials;
  
  AuthenticatorSelectionCriteriaPtr authenticator_selection;
  
  AttestationConveyancePreference attestation;
  
  CableRegistrationPtr cable_registration_data;
  
  bool hmac_create_secret;
  
  bool prf_enable;
  
  ProtectionPolicy protection_policy;
  
  bool enforce_protection_policy;
  
  WTF::String appid_exclude;
  
  bool cred_props;
  
  LargeBlobSupport large_blob_enable;
  
  bool is_payment_credential_creation;
  
  absl::optional<WTF::Vector<uint8_t>> cred_blob;
  
  bool google_legacy_app_id_support;
  
  bool min_pin_length_requested;
  
  RemoteDesktopClientOverridePtr remote_desktop_client_override;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class PLATFORM_EXPORT PublicKeyCredentialDescriptor {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<PublicKeyCredentialDescriptor, T>::value>;
  using DataView = PublicKeyCredentialDescriptorDataView;
  using Data_ = internal::PublicKeyCredentialDescriptor_Data;

  template <typename... Args>
  static PublicKeyCredentialDescriptorPtr New(Args&&... args) {
    return PublicKeyCredentialDescriptorPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static PublicKeyCredentialDescriptorPtr From(const U& u) {
    return mojo::TypeConverter<PublicKeyCredentialDescriptorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, PublicKeyCredentialDescriptor>::Convert(*this);
  }


  PublicKeyCredentialDescriptor();

  PublicKeyCredentialDescriptor(
      PublicKeyCredentialType type,
      WTF::Vector<uint8_t> id,
      WTF::Vector<AuthenticatorTransport> transports);


  ~PublicKeyCredentialDescriptor();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = PublicKeyCredentialDescriptorPtr>
  PublicKeyCredentialDescriptorPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static WTF::Vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        PublicKeyCredentialDescriptor::DataView, WTF::Vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        PublicKeyCredentialDescriptor::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::PublicKeyCredentialDescriptor_UnserializedMessageContext<
            UserType, PublicKeyCredentialDescriptor::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<PublicKeyCredentialDescriptor::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const WTF::Vector<uint8_t>& input,
                          UserType* output) {
    return PublicKeyCredentialDescriptor::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::PublicKeyCredentialDescriptor_UnserializedMessageContext<
            UserType, PublicKeyCredentialDescriptor::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<PublicKeyCredentialDescriptor::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  PublicKeyCredentialType type;
  
  WTF::Vector<uint8_t> id;
  
  WTF::Vector<AuthenticatorTransport> transports;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}


template <typename StructPtrType>
CommonCredentialInfoPtr CommonCredentialInfo::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(raw_id),
      mojo::Clone(client_data_json),
      mojo::Clone(authenticator_data)
  );
}

template <typename T, CommonCredentialInfo::EnableIfSame<T>*>
bool CommonCredentialInfo::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->raw_id, other_struct.raw_id))
    return false;
  if (!mojo::Equals(this->client_data_json, other_struct.client_data_json))
    return false;
  if (!mojo::Equals(this->authenticator_data, other_struct.authenticator_data))
    return false;
  return true;
}

template <typename T, CommonCredentialInfo::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.raw_id < rhs.raw_id)
    return true;
  if (rhs.raw_id < lhs.raw_id)
    return false;
  if (lhs.client_data_json < rhs.client_data_json)
    return true;
  if (rhs.client_data_json < lhs.client_data_json)
    return false;
  if (lhs.authenticator_data < rhs.authenticator_data)
    return true;
  if (rhs.authenticator_data < lhs.authenticator_data)
    return false;
  return false;
}
template <typename StructPtrType>
UvmEntryPtr UvmEntry::Clone() const {
  return New(
      mojo::Clone(user_verification_method),
      mojo::Clone(key_protection_type),
      mojo::Clone(matcher_protection_type)
  );
}

template <typename T, UvmEntry::EnableIfSame<T>*>
bool UvmEntry::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->user_verification_method, other_struct.user_verification_method))
    return false;
  if (!mojo::Equals(this->key_protection_type, other_struct.key_protection_type))
    return false;
  if (!mojo::Equals(this->matcher_protection_type, other_struct.matcher_protection_type))
    return false;
  return true;
}

template <typename T, UvmEntry::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.user_verification_method < rhs.user_verification_method)
    return true;
  if (rhs.user_verification_method < lhs.user_verification_method)
    return false;
  if (lhs.key_protection_type < rhs.key_protection_type)
    return true;
  if (rhs.key_protection_type < lhs.key_protection_type)
    return false;
  if (lhs.matcher_protection_type < rhs.matcher_protection_type)
    return true;
  if (rhs.matcher_protection_type < lhs.matcher_protection_type)
    return false;
  return false;
}
template <typename StructPtrType>
MakeCredentialAuthenticatorResponsePtr MakeCredentialAuthenticatorResponse::Clone() const {
  return New(
      mojo::Clone(info),
      mojo::Clone(authenticator_attachment),
      mojo::Clone(attestation_object),
      mojo::Clone(transports),
      mojo::Clone(echo_hmac_create_secret),
      mojo::Clone(hmac_create_secret),
      mojo::Clone(echo_prf),
      mojo::Clone(prf),
      mojo::Clone(echo_cred_blob),
      mojo::Clone(cred_blob),
      mojo::Clone(public_key_der),
      mojo::Clone(public_key_algo),
      mojo::Clone(echo_cred_props),
      mojo::Clone(has_cred_props_rk),
      mojo::Clone(cred_props_rk),
      mojo::Clone(echo_large_blob),
      mojo::Clone(supports_large_blob)
  );
}

template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>*>
bool MakeCredentialAuthenticatorResponse::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->info, other_struct.info))
    return false;
  if (!mojo::Equals(this->authenticator_attachment, other_struct.authenticator_attachment))
    return false;
  if (!mojo::Equals(this->attestation_object, other_struct.attestation_object))
    return false;
  if (!mojo::Equals(this->transports, other_struct.transports))
    return false;
  if (!mojo::Equals(this->echo_hmac_create_secret, other_struct.echo_hmac_create_secret))
    return false;
  if (!mojo::Equals(this->hmac_create_secret, other_struct.hmac_create_secret))
    return false;
  if (!mojo::Equals(this->echo_prf, other_struct.echo_prf))
    return false;
  if (!mojo::Equals(this->prf, other_struct.prf))
    return false;
  if (!mojo::Equals(this->echo_cred_blob, other_struct.echo_cred_blob))
    return false;
  if (!mojo::Equals(this->cred_blob, other_struct.cred_blob))
    return false;
  if (!mojo::Equals(this->public_key_der, other_struct.public_key_der))
    return false;
  if (!mojo::Equals(this->public_key_algo, other_struct.public_key_algo))
    return false;
  if (!mojo::Equals(this->echo_cred_props, other_struct.echo_cred_props))
    return false;
  if (!mojo::Equals(this->has_cred_props_rk, other_struct.has_cred_props_rk))
    return false;
  if (!mojo::Equals(this->cred_props_rk, other_struct.cred_props_rk))
    return false;
  if (!mojo::Equals(this->echo_large_blob, other_struct.echo_large_blob))
    return false;
  if (!mojo::Equals(this->supports_large_blob, other_struct.supports_large_blob))
    return false;
  return true;
}

template <typename T, MakeCredentialAuthenticatorResponse::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.info < rhs.info)
    return true;
  if (rhs.info < lhs.info)
    return false;
  if (lhs.authenticator_attachment < rhs.authenticator_attachment)
    return true;
  if (rhs.authenticator_attachment < lhs.authenticator_attachment)
    return false;
  if (lhs.attestation_object < rhs.attestation_object)
    return true;
  if (rhs.attestation_object < lhs.attestation_object)
    return false;
  if (lhs.transports < rhs.transports)
    return true;
  if (rhs.transports < lhs.transports)
    return false;
  if (lhs.echo_hmac_create_secret < rhs.echo_hmac_create_secret)
    return true;
  if (rhs.echo_hmac_create_secret < lhs.echo_hmac_create_secret)
    return false;
  if (lhs.hmac_create_secret < rhs.hmac_create_secret)
    return true;
  if (rhs.hmac_create_secret < lhs.hmac_create_secret)
    return false;
  if (lhs.echo_prf < rhs.echo_prf)
    return true;
  if (rhs.echo_prf < lhs.echo_prf)
    return false;
  if (lhs.prf < rhs.prf)
    return true;
  if (rhs.prf < lhs.prf)
    return false;
  if (lhs.echo_cred_blob < rhs.echo_cred_blob)
    return true;
  if (rhs.echo_cred_blob < lhs.echo_cred_blob)
    return false;
  if (lhs.cred_blob < rhs.cred_blob)
    return true;
  if (rhs.cred_blob < lhs.cred_blob)
    return false;
  if (lhs.public_key_der < rhs.public_key_der)
    return true;
  if (rhs.public_key_der < lhs.public_key_der)
    return false;
  if (lhs.public_key_algo < rhs.public_key_algo)
    return true;
  if (rhs.public_key_algo < lhs.public_key_algo)
    return false;
  if (lhs.echo_cred_props < rhs.echo_cred_props)
    return true;
  if (rhs.echo_cred_props < lhs.echo_cred_props)
    return false;
  if (lhs.has_cred_props_rk < rhs.has_cred_props_rk)
    return true;
  if (rhs.has_cred_props_rk < lhs.has_cred_props_rk)
    return false;
  if (lhs.cred_props_rk < rhs.cred_props_rk)
    return true;
  if (rhs.cred_props_rk < lhs.cred_props_rk)
    return false;
  if (lhs.echo_large_blob < rhs.echo_large_blob)
    return true;
  if (rhs.echo_large_blob < lhs.echo_large_blob)
    return false;
  if (lhs.supports_large_blob < rhs.supports_large_blob)
    return true;
  if (rhs.supports_large_blob < lhs.supports_large_blob)
    return false;
  return false;
}
template <typename StructPtrType>
GetAssertionAuthenticatorResponsePtr GetAssertionAuthenticatorResponse::Clone() const {
  return New(
      mojo::Clone(info),
      mojo::Clone(authenticator_attachment),
      mojo::Clone(signature),
      mojo::Clone(user_handle),
      mojo::Clone(echo_appid_extension),
      mojo::Clone(appid_extension),
      mojo::Clone(echo_user_verification_methods),
      mojo::Clone(user_verification_methods),
      mojo::Clone(echo_prf),
      mojo::Clone(prf_results),
      mojo::Clone(prf_not_evaluated),
      mojo::Clone(echo_large_blob),
      mojo::Clone(large_blob),
      mojo::Clone(echo_large_blob_written),
      mojo::Clone(large_blob_written),
      mojo::Clone(get_cred_blob)
  );
}

template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>*>
bool GetAssertionAuthenticatorResponse::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->info, other_struct.info))
    return false;
  if (!mojo::Equals(this->authenticator_attachment, other_struct.authenticator_attachment))
    return false;
  if (!mojo::Equals(this->signature, other_struct.signature))
    return false;
  if (!mojo::Equals(this->user_handle, other_struct.user_handle))
    return false;
  if (!mojo::Equals(this->echo_appid_extension, other_struct.echo_appid_extension))
    return false;
  if (!mojo::Equals(this->appid_extension, other_struct.appid_extension))
    return false;
  if (!mojo::Equals(this->echo_user_verification_methods, other_struct.echo_user_verification_methods))
    return false;
  if (!mojo::Equals(this->user_verification_methods, other_struct.user_verification_methods))
    return false;
  if (!mojo::Equals(this->echo_prf, other_struct.echo_prf))
    return false;
  if (!mojo::Equals(this->prf_results, other_struct.prf_results))
    return false;
  if (!mojo::Equals(this->prf_not_evaluated, other_struct.prf_not_evaluated))
    return false;
  if (!mojo::Equals(this->echo_large_blob, other_struct.echo_large_blob))
    return false;
  if (!mojo::Equals(this->large_blob, other_struct.large_blob))
    return false;
  if (!mojo::Equals(this->echo_large_blob_written, other_struct.echo_large_blob_written))
    return false;
  if (!mojo::Equals(this->large_blob_written, other_struct.large_blob_written))
    return false;
  if (!mojo::Equals(this->get_cred_blob, other_struct.get_cred_blob))
    return false;
  return true;
}

template <typename T, GetAssertionAuthenticatorResponse::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.info < rhs.info)
    return true;
  if (rhs.info < lhs.info)
    return false;
  if (lhs.authenticator_attachment < rhs.authenticator_attachment)
    return true;
  if (rhs.authenticator_attachment < lhs.authenticator_attachment)
    return false;
  if (lhs.signature < rhs.signature)
    return true;
  if (rhs.signature < lhs.signature)
    return false;
  if (lhs.user_handle < rhs.user_handle)
    return true;
  if (rhs.user_handle < lhs.user_handle)
    return false;
  if (lhs.echo_appid_extension < rhs.echo_appid_extension)
    return true;
  if (rhs.echo_appid_extension < lhs.echo_appid_extension)
    return false;
  if (lhs.appid_extension < rhs.appid_extension)
    return true;
  if (rhs.appid_extension < lhs.appid_extension)
    return false;
  if (lhs.echo_user_verification_methods < rhs.echo_user_verification_methods)
    return true;
  if (rhs.echo_user_verification_methods < lhs.echo_user_verification_methods)
    return false;
  if (lhs.user_verification_methods < rhs.user_verification_methods)
    return true;
  if (rhs.user_verification_methods < lhs.user_verification_methods)
    return false;
  if (lhs.echo_prf < rhs.echo_prf)
    return true;
  if (rhs.echo_prf < lhs.echo_prf)
    return false;
  if (lhs.prf_results < rhs.prf_results)
    return true;
  if (rhs.prf_results < lhs.prf_results)
    return false;
  if (lhs.prf_not_evaluated < rhs.prf_not_evaluated)
    return true;
  if (rhs.prf_not_evaluated < lhs.prf_not_evaluated)
    return false;
  if (lhs.echo_large_blob < rhs.echo_large_blob)
    return true;
  if (rhs.echo_large_blob < lhs.echo_large_blob)
    return false;
  if (lhs.large_blob < rhs.large_blob)
    return true;
  if (rhs.large_blob < lhs.large_blob)
    return false;
  if (lhs.echo_large_blob_written < rhs.echo_large_blob_written)
    return true;
  if (rhs.echo_large_blob_written < lhs.echo_large_blob_written)
    return false;
  if (lhs.large_blob_written < rhs.large_blob_written)
    return true;
  if (rhs.large_blob_written < lhs.large_blob_written)
    return false;
  if (lhs.get_cred_blob < rhs.get_cred_blob)
    return true;
  if (rhs.get_cred_blob < lhs.get_cred_blob)
    return false;
  return false;
}
template <typename StructPtrType>
PublicKeyCredentialRpEntityPtr PublicKeyCredentialRpEntity::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(name),
      mojo::Clone(icon)
  );
}

template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>*>
bool PublicKeyCredentialRpEntity::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->icon, other_struct.icon))
    return false;
  return true;
}

template <typename T, PublicKeyCredentialRpEntity::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.icon < rhs.icon)
    return true;
  if (rhs.icon < lhs.icon)
    return false;
  return false;
}
template <typename StructPtrType>
PublicKeyCredentialUserEntityPtr PublicKeyCredentialUserEntity::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(name),
      mojo::Clone(icon),
      mojo::Clone(display_name)
  );
}

template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>*>
bool PublicKeyCredentialUserEntity::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->icon, other_struct.icon))
    return false;
  if (!mojo::Equals(this->display_name, other_struct.display_name))
    return false;
  return true;
}

template <typename T, PublicKeyCredentialUserEntity::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.icon < rhs.icon)
    return true;
  if (rhs.icon < lhs.icon)
    return false;
  if (lhs.display_name < rhs.display_name)
    return true;
  if (rhs.display_name < lhs.display_name)
    return false;
  return false;
}
template <typename StructPtrType>
PublicKeyCredentialParametersPtr PublicKeyCredentialParameters::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(algorithm_identifier)
  );
}

template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>*>
bool PublicKeyCredentialParameters::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->algorithm_identifier, other_struct.algorithm_identifier))
    return false;
  return true;
}

template <typename T, PublicKeyCredentialParameters::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.algorithm_identifier < rhs.algorithm_identifier)
    return true;
  if (rhs.algorithm_identifier < lhs.algorithm_identifier)
    return false;
  return false;
}
template <typename StructPtrType>
CableAuthenticationPtr CableAuthentication::Clone() const {
  return New(
      mojo::Clone(version),
      mojo::Clone(client_eid),
      mojo::Clone(authenticator_eid),
      mojo::Clone(session_pre_key),
      mojo::Clone(server_link_data),
      mojo::Clone(experiments)
  );
}

template <typename T, CableAuthentication::EnableIfSame<T>*>
bool CableAuthentication::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->version, other_struct.version))
    return false;
  if (!mojo::Equals(this->client_eid, other_struct.client_eid))
    return false;
  if (!mojo::Equals(this->authenticator_eid, other_struct.authenticator_eid))
    return false;
  if (!mojo::Equals(this->session_pre_key, other_struct.session_pre_key))
    return false;
  if (!mojo::Equals(this->server_link_data, other_struct.server_link_data))
    return false;
  if (!mojo::Equals(this->experiments, other_struct.experiments))
    return false;
  return true;
}

template <typename T, CableAuthentication::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.version < rhs.version)
    return true;
  if (rhs.version < lhs.version)
    return false;
  if (lhs.client_eid < rhs.client_eid)
    return true;
  if (rhs.client_eid < lhs.client_eid)
    return false;
  if (lhs.authenticator_eid < rhs.authenticator_eid)
    return true;
  if (rhs.authenticator_eid < lhs.authenticator_eid)
    return false;
  if (lhs.session_pre_key < rhs.session_pre_key)
    return true;
  if (rhs.session_pre_key < lhs.session_pre_key)
    return false;
  if (lhs.server_link_data < rhs.server_link_data)
    return true;
  if (rhs.server_link_data < lhs.server_link_data)
    return false;
  if (lhs.experiments < rhs.experiments)
    return true;
  if (rhs.experiments < lhs.experiments)
    return false;
  return false;
}
template <typename StructPtrType>
CableRegistrationPtr CableRegistration::Clone() const {
  return New(
      mojo::Clone(versions),
      mojo::Clone(relying_party_public_key)
  );
}

template <typename T, CableRegistration::EnableIfSame<T>*>
bool CableRegistration::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->versions, other_struct.versions))
    return false;
  if (!mojo::Equals(this->relying_party_public_key, other_struct.relying_party_public_key))
    return false;
  return true;
}

template <typename T, CableRegistration::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.versions < rhs.versions)
    return true;
  if (rhs.versions < lhs.versions)
    return false;
  if (lhs.relying_party_public_key < rhs.relying_party_public_key)
    return true;
  if (rhs.relying_party_public_key < lhs.relying_party_public_key)
    return false;
  return false;
}
template <typename StructPtrType>
PRFValuesPtr PRFValues::Clone() const {
  return New(
      mojo::Clone(id),
      mojo::Clone(first),
      mojo::Clone(second)
  );
}

template <typename T, PRFValues::EnableIfSame<T>*>
bool PRFValues::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->first, other_struct.first))
    return false;
  if (!mojo::Equals(this->second, other_struct.second))
    return false;
  return true;
}

template <typename T, PRFValues::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.first < rhs.first)
    return true;
  if (rhs.first < lhs.first)
    return false;
  if (lhs.second < rhs.second)
    return true;
  if (rhs.second < lhs.second)
    return false;
  return false;
}
template <typename StructPtrType>
PaymentOptionsPtr PaymentOptions::Clone() const {
  return New(
      mojo::Clone(total),
      mojo::Clone(instrument),
      mojo::Clone(payee_name),
      mojo::Clone(payee_origin)
  );
}

template <typename T, PaymentOptions::EnableIfSame<T>*>
bool PaymentOptions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->total, other_struct.total))
    return false;
  if (!mojo::Equals(this->instrument, other_struct.instrument))
    return false;
  if (!mojo::Equals(this->payee_name, other_struct.payee_name))
    return false;
  if (!mojo::Equals(this->payee_origin, other_struct.payee_origin))
    return false;
  return true;
}

template <typename T, PaymentOptions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.total < rhs.total)
    return true;
  if (rhs.total < lhs.total)
    return false;
  if (lhs.instrument < rhs.instrument)
    return true;
  if (rhs.instrument < lhs.instrument)
    return false;
  if (lhs.payee_name < rhs.payee_name)
    return true;
  if (rhs.payee_name < lhs.payee_name)
    return false;
  if (lhs.payee_origin < rhs.payee_origin)
    return true;
  if (rhs.payee_origin < lhs.payee_origin)
    return false;
  return false;
}
template <typename StructPtrType>
PaymentCredentialInstrumentPtr PaymentCredentialInstrument::Clone() const {
  return New(
      mojo::Clone(display_name),
      mojo::Clone(icon),
      mojo::Clone(iconMustBeShown)
  );
}

template <typename T, PaymentCredentialInstrument::EnableIfSame<T>*>
bool PaymentCredentialInstrument::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->display_name, other_struct.display_name))
    return false;
  if (!mojo::Equals(this->icon, other_struct.icon))
    return false;
  if (!mojo::Equals(this->iconMustBeShown, other_struct.iconMustBeShown))
    return false;
  return true;
}

template <typename T, PaymentCredentialInstrument::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.display_name < rhs.display_name)
    return true;
  if (rhs.display_name < lhs.display_name)
    return false;
  if (lhs.icon < rhs.icon)
    return true;
  if (rhs.icon < lhs.icon)
    return false;
  if (lhs.iconMustBeShown < rhs.iconMustBeShown)
    return true;
  if (rhs.iconMustBeShown < lhs.iconMustBeShown)
    return false;
  return false;
}
template <typename StructPtrType>
RemoteDesktopClientOverridePtr RemoteDesktopClientOverride::Clone() const {
  return New(
      mojo::Clone(origin),
      mojo::Clone(same_origin_with_ancestors)
  );
}

template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>*>
bool RemoteDesktopClientOverride::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->origin, other_struct.origin))
    return false;
  if (!mojo::Equals(this->same_origin_with_ancestors, other_struct.same_origin_with_ancestors))
    return false;
  return true;
}

template <typename T, RemoteDesktopClientOverride::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.origin < rhs.origin)
    return true;
  if (rhs.origin < lhs.origin)
    return false;
  if (lhs.same_origin_with_ancestors < rhs.same_origin_with_ancestors)
    return true;
  if (rhs.same_origin_with_ancestors < lhs.same_origin_with_ancestors)
    return false;
  return false;
}
template <typename StructPtrType>
PublicKeyCredentialRequestOptionsPtr PublicKeyCredentialRequestOptions::Clone() const {
  return New(
      mojo::Clone(is_conditional),
      mojo::Clone(challenge),
      mojo::Clone(timeout),
      mojo::Clone(relying_party_id),
      mojo::Clone(allow_credentials),
      mojo::Clone(user_verification),
      mojo::Clone(appid),
      mojo::Clone(cable_authentication_data),
      mojo::Clone(user_verification_methods),
      mojo::Clone(prf),
      mojo::Clone(prf_inputs),
      mojo::Clone(large_blob_read),
      mojo::Clone(large_blob_write),
      mojo::Clone(get_cred_blob),
      mojo::Clone(remote_desktop_client_override)
  );
}

template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>*>
bool PublicKeyCredentialRequestOptions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->is_conditional, other_struct.is_conditional))
    return false;
  if (!mojo::Equals(this->challenge, other_struct.challenge))
    return false;
  if (!mojo::Equals(this->timeout, other_struct.timeout))
    return false;
  if (!mojo::Equals(this->relying_party_id, other_struct.relying_party_id))
    return false;
  if (!mojo::Equals(this->allow_credentials, other_struct.allow_credentials))
    return false;
  if (!mojo::Equals(this->user_verification, other_struct.user_verification))
    return false;
  if (!mojo::Equals(this->appid, other_struct.appid))
    return false;
  if (!mojo::Equals(this->cable_authentication_data, other_struct.cable_authentication_data))
    return false;
  if (!mojo::Equals(this->user_verification_methods, other_struct.user_verification_methods))
    return false;
  if (!mojo::Equals(this->prf, other_struct.prf))
    return false;
  if (!mojo::Equals(this->prf_inputs, other_struct.prf_inputs))
    return false;
  if (!mojo::Equals(this->large_blob_read, other_struct.large_blob_read))
    return false;
  if (!mojo::Equals(this->large_blob_write, other_struct.large_blob_write))
    return false;
  if (!mojo::Equals(this->get_cred_blob, other_struct.get_cred_blob))
    return false;
  if (!mojo::Equals(this->remote_desktop_client_override, other_struct.remote_desktop_client_override))
    return false;
  return true;
}

template <typename T, PublicKeyCredentialRequestOptions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.is_conditional < rhs.is_conditional)
    return true;
  if (rhs.is_conditional < lhs.is_conditional)
    return false;
  if (lhs.challenge < rhs.challenge)
    return true;
  if (rhs.challenge < lhs.challenge)
    return false;
  if (lhs.timeout < rhs.timeout)
    return true;
  if (rhs.timeout < lhs.timeout)
    return false;
  if (lhs.relying_party_id < rhs.relying_party_id)
    return true;
  if (rhs.relying_party_id < lhs.relying_party_id)
    return false;
  if (lhs.allow_credentials < rhs.allow_credentials)
    return true;
  if (rhs.allow_credentials < lhs.allow_credentials)
    return false;
  if (lhs.user_verification < rhs.user_verification)
    return true;
  if (rhs.user_verification < lhs.user_verification)
    return false;
  if (lhs.appid < rhs.appid)
    return true;
  if (rhs.appid < lhs.appid)
    return false;
  if (lhs.cable_authentication_data < rhs.cable_authentication_data)
    return true;
  if (rhs.cable_authentication_data < lhs.cable_authentication_data)
    return false;
  if (lhs.user_verification_methods < rhs.user_verification_methods)
    return true;
  if (rhs.user_verification_methods < lhs.user_verification_methods)
    return false;
  if (lhs.prf < rhs.prf)
    return true;
  if (rhs.prf < lhs.prf)
    return false;
  if (lhs.prf_inputs < rhs.prf_inputs)
    return true;
  if (rhs.prf_inputs < lhs.prf_inputs)
    return false;
  if (lhs.large_blob_read < rhs.large_blob_read)
    return true;
  if (rhs.large_blob_read < lhs.large_blob_read)
    return false;
  if (lhs.large_blob_write < rhs.large_blob_write)
    return true;
  if (rhs.large_blob_write < lhs.large_blob_write)
    return false;
  if (lhs.get_cred_blob < rhs.get_cred_blob)
    return true;
  if (rhs.get_cred_blob < lhs.get_cred_blob)
    return false;
  if (lhs.remote_desktop_client_override < rhs.remote_desktop_client_override)
    return true;
  if (rhs.remote_desktop_client_override < lhs.remote_desktop_client_override)
    return false;
  return false;
}
template <typename StructPtrType>
AuthenticatorSelectionCriteriaPtr AuthenticatorSelectionCriteria::Clone() const {
  return New(
      mojo::Clone(authenticator_attachment),
      mojo::Clone(resident_key),
      mojo::Clone(user_verification)
  );
}

template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>*>
bool AuthenticatorSelectionCriteria::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->authenticator_attachment, other_struct.authenticator_attachment))
    return false;
  if (!mojo::Equals(this->resident_key, other_struct.resident_key))
    return false;
  if (!mojo::Equals(this->user_verification, other_struct.user_verification))
    return false;
  return true;
}

template <typename T, AuthenticatorSelectionCriteria::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.authenticator_attachment < rhs.authenticator_attachment)
    return true;
  if (rhs.authenticator_attachment < lhs.authenticator_attachment)
    return false;
  if (lhs.resident_key < rhs.resident_key)
    return true;
  if (rhs.resident_key < lhs.resident_key)
    return false;
  if (lhs.user_verification < rhs.user_verification)
    return true;
  if (rhs.user_verification < lhs.user_verification)
    return false;
  return false;
}
template <typename StructPtrType>
PublicKeyCredentialCreationOptionsPtr PublicKeyCredentialCreationOptions::Clone() const {
  return New(
      mojo::Clone(relying_party),
      mojo::Clone(user),
      mojo::Clone(challenge),
      mojo::Clone(public_key_parameters),
      mojo::Clone(timeout),
      mojo::Clone(exclude_credentials),
      mojo::Clone(authenticator_selection),
      mojo::Clone(attestation),
      mojo::Clone(cable_registration_data),
      mojo::Clone(hmac_create_secret),
      mojo::Clone(prf_enable),
      mojo::Clone(protection_policy),
      mojo::Clone(enforce_protection_policy),
      mojo::Clone(appid_exclude),
      mojo::Clone(cred_props),
      mojo::Clone(large_blob_enable),
      mojo::Clone(is_payment_credential_creation),
      mojo::Clone(cred_blob),
      mojo::Clone(google_legacy_app_id_support),
      mojo::Clone(min_pin_length_requested),
      mojo::Clone(remote_desktop_client_override)
  );
}

template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>*>
bool PublicKeyCredentialCreationOptions::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->relying_party, other_struct.relying_party))
    return false;
  if (!mojo::Equals(this->user, other_struct.user))
    return false;
  if (!mojo::Equals(this->challenge, other_struct.challenge))
    return false;
  if (!mojo::Equals(this->public_key_parameters, other_struct.public_key_parameters))
    return false;
  if (!mojo::Equals(this->timeout, other_struct.timeout))
    return false;
  if (!mojo::Equals(this->exclude_credentials, other_struct.exclude_credentials))
    return false;
  if (!mojo::Equals(this->authenticator_selection, other_struct.authenticator_selection))
    return false;
  if (!mojo::Equals(this->attestation, other_struct.attestation))
    return false;
  if (!mojo::Equals(this->cable_registration_data, other_struct.cable_registration_data))
    return false;
  if (!mojo::Equals(this->hmac_create_secret, other_struct.hmac_create_secret))
    return false;
  if (!mojo::Equals(this->prf_enable, other_struct.prf_enable))
    return false;
  if (!mojo::Equals(this->protection_policy, other_struct.protection_policy))
    return false;
  if (!mojo::Equals(this->enforce_protection_policy, other_struct.enforce_protection_policy))
    return false;
  if (!mojo::Equals(this->appid_exclude, other_struct.appid_exclude))
    return false;
  if (!mojo::Equals(this->cred_props, other_struct.cred_props))
    return false;
  if (!mojo::Equals(this->large_blob_enable, other_struct.large_blob_enable))
    return false;
  if (!mojo::Equals(this->is_payment_credential_creation, other_struct.is_payment_credential_creation))
    return false;
  if (!mojo::Equals(this->cred_blob, other_struct.cred_blob))
    return false;
  if (!mojo::Equals(this->google_legacy_app_id_support, other_struct.google_legacy_app_id_support))
    return false;
  if (!mojo::Equals(this->min_pin_length_requested, other_struct.min_pin_length_requested))
    return false;
  if (!mojo::Equals(this->remote_desktop_client_override, other_struct.remote_desktop_client_override))
    return false;
  return true;
}

template <typename T, PublicKeyCredentialCreationOptions::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.relying_party < rhs.relying_party)
    return true;
  if (rhs.relying_party < lhs.relying_party)
    return false;
  if (lhs.user < rhs.user)
    return true;
  if (rhs.user < lhs.user)
    return false;
  if (lhs.challenge < rhs.challenge)
    return true;
  if (rhs.challenge < lhs.challenge)
    return false;
  if (lhs.public_key_parameters < rhs.public_key_parameters)
    return true;
  if (rhs.public_key_parameters < lhs.public_key_parameters)
    return false;
  if (lhs.timeout < rhs.timeout)
    return true;
  if (rhs.timeout < lhs.timeout)
    return false;
  if (lhs.exclude_credentials < rhs.exclude_credentials)
    return true;
  if (rhs.exclude_credentials < lhs.exclude_credentials)
    return false;
  if (lhs.authenticator_selection < rhs.authenticator_selection)
    return true;
  if (rhs.authenticator_selection < lhs.authenticator_selection)
    return false;
  if (lhs.attestation < rhs.attestation)
    return true;
  if (rhs.attestation < lhs.attestation)
    return false;
  if (lhs.cable_registration_data < rhs.cable_registration_data)
    return true;
  if (rhs.cable_registration_data < lhs.cable_registration_data)
    return false;
  if (lhs.hmac_create_secret < rhs.hmac_create_secret)
    return true;
  if (rhs.hmac_create_secret < lhs.hmac_create_secret)
    return false;
  if (lhs.prf_enable < rhs.prf_enable)
    return true;
  if (rhs.prf_enable < lhs.prf_enable)
    return false;
  if (lhs.protection_policy < rhs.protection_policy)
    return true;
  if (rhs.protection_policy < lhs.protection_policy)
    return false;
  if (lhs.enforce_protection_policy < rhs.enforce_protection_policy)
    return true;
  if (rhs.enforce_protection_policy < lhs.enforce_protection_policy)
    return false;
  if (lhs.appid_exclude < rhs.appid_exclude)
    return true;
  if (rhs.appid_exclude < lhs.appid_exclude)
    return false;
  if (lhs.cred_props < rhs.cred_props)
    return true;
  if (rhs.cred_props < lhs.cred_props)
    return false;
  if (lhs.large_blob_enable < rhs.large_blob_enable)
    return true;
  if (rhs.large_blob_enable < lhs.large_blob_enable)
    return false;
  if (lhs.is_payment_credential_creation < rhs.is_payment_credential_creation)
    return true;
  if (rhs.is_payment_credential_creation < lhs.is_payment_credential_creation)
    return false;
  if (lhs.cred_blob < rhs.cred_blob)
    return true;
  if (rhs.cred_blob < lhs.cred_blob)
    return false;
  if (lhs.google_legacy_app_id_support < rhs.google_legacy_app_id_support)
    return true;
  if (rhs.google_legacy_app_id_support < lhs.google_legacy_app_id_support)
    return false;
  if (lhs.min_pin_length_requested < rhs.min_pin_length_requested)
    return true;
  if (rhs.min_pin_length_requested < lhs.min_pin_length_requested)
    return false;
  if (lhs.remote_desktop_client_override < rhs.remote_desktop_client_override)
    return true;
  if (rhs.remote_desktop_client_override < lhs.remote_desktop_client_override)
    return false;
  return false;
}
template <typename StructPtrType>
PublicKeyCredentialDescriptorPtr PublicKeyCredentialDescriptor::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(id),
      mojo::Clone(transports)
  );
}

template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>*>
bool PublicKeyCredentialDescriptor::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->id, other_struct.id))
    return false;
  if (!mojo::Equals(this->transports, other_struct.transports))
    return false;
  return true;
}

template <typename T, PublicKeyCredentialDescriptor::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.id < rhs.id)
    return true;
  if (rhs.id < lhs.id)
    return false;
  if (lhs.transports < rhs.transports)
    return true;
  if (rhs.transports < lhs.transports)
    return false;
  return false;
}
template <typename StructPtrType>
WebAuthnDOMExceptionDetailsPtr WebAuthnDOMExceptionDetails::Clone() const {
  return New(
      mojo::Clone(name),
      mojo::Clone(message)
  );
}

template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>*>
bool WebAuthnDOMExceptionDetails::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  return true;
}

template <typename T, WebAuthnDOMExceptionDetails::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  return false;
}


}  // namespace blink
}  // namespace mojom
}  // namespace blink

namespace mojo {


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::CommonCredentialInfo::DataView,
                                         ::blink::mojom::blink::CommonCredentialInfoPtr> {
  static bool IsNull(const ::blink::mojom::blink::CommonCredentialInfoPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::CommonCredentialInfoPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::CommonCredentialInfo::id)& id(
      const ::blink::mojom::blink::CommonCredentialInfoPtr& input) {
    return input->id;
  }

  static const decltype(::blink::mojom::blink::CommonCredentialInfo::raw_id)& raw_id(
      const ::blink::mojom::blink::CommonCredentialInfoPtr& input) {
    return input->raw_id;
  }

  static const decltype(::blink::mojom::blink::CommonCredentialInfo::client_data_json)& client_data_json(
      const ::blink::mojom::blink::CommonCredentialInfoPtr& input) {
    return input->client_data_json;
  }

  static const decltype(::blink::mojom::blink::CommonCredentialInfo::authenticator_data)& authenticator_data(
      const ::blink::mojom::blink::CommonCredentialInfoPtr& input) {
    return input->authenticator_data;
  }

  static bool Read(::blink::mojom::blink::CommonCredentialInfo::DataView input, ::blink::mojom::blink::CommonCredentialInfoPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::UvmEntry::DataView,
                                         ::blink::mojom::blink::UvmEntryPtr> {
  static bool IsNull(const ::blink::mojom::blink::UvmEntryPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::UvmEntryPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::UvmEntry::user_verification_method) user_verification_method(
      const ::blink::mojom::blink::UvmEntryPtr& input) {
    return input->user_verification_method;
  }

  static decltype(::blink::mojom::blink::UvmEntry::key_protection_type) key_protection_type(
      const ::blink::mojom::blink::UvmEntryPtr& input) {
    return input->key_protection_type;
  }

  static decltype(::blink::mojom::blink::UvmEntry::matcher_protection_type) matcher_protection_type(
      const ::blink::mojom::blink::UvmEntryPtr& input) {
    return input->matcher_protection_type;
  }

  static bool Read(::blink::mojom::blink::UvmEntry::DataView input, ::blink::mojom::blink::UvmEntryPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::MakeCredentialAuthenticatorResponse::DataView,
                                         ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr> {
  static bool IsNull(const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::info)& info(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->info;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::authenticator_attachment) authenticator_attachment(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->authenticator_attachment;
  }

  static const decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::attestation_object)& attestation_object(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->attestation_object;
  }

  static const decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::transports)& transports(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->transports;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::echo_hmac_create_secret) echo_hmac_create_secret(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->echo_hmac_create_secret;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::hmac_create_secret) hmac_create_secret(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->hmac_create_secret;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::echo_prf) echo_prf(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->echo_prf;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::prf) prf(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->prf;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::echo_cred_blob) echo_cred_blob(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->echo_cred_blob;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::cred_blob) cred_blob(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->cred_blob;
  }

  static const decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::public_key_der)& public_key_der(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->public_key_der;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::public_key_algo) public_key_algo(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->public_key_algo;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::echo_cred_props) echo_cred_props(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->echo_cred_props;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::has_cred_props_rk) has_cred_props_rk(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->has_cred_props_rk;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::cred_props_rk) cred_props_rk(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->cred_props_rk;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::echo_large_blob) echo_large_blob(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->echo_large_blob;
  }

  static decltype(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::supports_large_blob) supports_large_blob(
      const ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr& input) {
    return input->supports_large_blob;
  }

  static bool Read(::blink::mojom::blink::MakeCredentialAuthenticatorResponse::DataView input, ::blink::mojom::blink::MakeCredentialAuthenticatorResponsePtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::GetAssertionAuthenticatorResponse::DataView,
                                         ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr> {
  static bool IsNull(const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::info)& info(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->info;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::authenticator_attachment) authenticator_attachment(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->authenticator_attachment;
  }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::signature)& signature(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->signature;
  }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::user_handle)& user_handle(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->user_handle;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::echo_appid_extension) echo_appid_extension(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->echo_appid_extension;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::appid_extension) appid_extension(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->appid_extension;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::echo_user_verification_methods) echo_user_verification_methods(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->echo_user_verification_methods;
  }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::user_verification_methods)& user_verification_methods(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->user_verification_methods;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::echo_prf) echo_prf(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->echo_prf;
  }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::prf_results)& prf_results(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->prf_results;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::prf_not_evaluated) prf_not_evaluated(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->prf_not_evaluated;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::echo_large_blob) echo_large_blob(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->echo_large_blob;
  }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::large_blob)& large_blob(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->large_blob;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::echo_large_blob_written) echo_large_blob_written(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->echo_large_blob_written;
  }

  static decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::large_blob_written) large_blob_written(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->large_blob_written;
  }

  static const decltype(::blink::mojom::blink::GetAssertionAuthenticatorResponse::get_cred_blob)& get_cred_blob(
      const ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr& input) {
    return input->get_cred_blob;
  }

  static bool Read(::blink::mojom::blink::GetAssertionAuthenticatorResponse::DataView input, ::blink::mojom::blink::GetAssertionAuthenticatorResponsePtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PublicKeyCredentialRpEntity::DataView,
                                         ::blink::mojom::blink::PublicKeyCredentialRpEntityPtr> {
  static bool IsNull(const ::blink::mojom::blink::PublicKeyCredentialRpEntityPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PublicKeyCredentialRpEntityPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRpEntity::id)& id(
      const ::blink::mojom::blink::PublicKeyCredentialRpEntityPtr& input) {
    return input->id;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRpEntity::name)& name(
      const ::blink::mojom::blink::PublicKeyCredentialRpEntityPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRpEntity::icon)& icon(
      const ::blink::mojom::blink::PublicKeyCredentialRpEntityPtr& input) {
    return input->icon;
  }

  static bool Read(::blink::mojom::blink::PublicKeyCredentialRpEntity::DataView input, ::blink::mojom::blink::PublicKeyCredentialRpEntityPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PublicKeyCredentialUserEntity::DataView,
                                         ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr> {
  static bool IsNull(const ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PublicKeyCredentialUserEntityPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialUserEntity::id)& id(
      const ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr& input) {
    return input->id;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialUserEntity::name)& name(
      const ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialUserEntity::icon)& icon(
      const ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr& input) {
    return input->icon;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialUserEntity::display_name)& display_name(
      const ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr& input) {
    return input->display_name;
  }

  static bool Read(::blink::mojom::blink::PublicKeyCredentialUserEntity::DataView input, ::blink::mojom::blink::PublicKeyCredentialUserEntityPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PublicKeyCredentialParameters::DataView,
                                         ::blink::mojom::blink::PublicKeyCredentialParametersPtr> {
  static bool IsNull(const ::blink::mojom::blink::PublicKeyCredentialParametersPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PublicKeyCredentialParametersPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::PublicKeyCredentialParameters::type) type(
      const ::blink::mojom::blink::PublicKeyCredentialParametersPtr& input) {
    return input->type;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialParameters::algorithm_identifier) algorithm_identifier(
      const ::blink::mojom::blink::PublicKeyCredentialParametersPtr& input) {
    return input->algorithm_identifier;
  }

  static bool Read(::blink::mojom::blink::PublicKeyCredentialParameters::DataView input, ::blink::mojom::blink::PublicKeyCredentialParametersPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::CableAuthentication::DataView,
                                         ::blink::mojom::blink::CableAuthenticationPtr> {
  static bool IsNull(const ::blink::mojom::blink::CableAuthenticationPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::CableAuthenticationPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::CableAuthentication::version) version(
      const ::blink::mojom::blink::CableAuthenticationPtr& input) {
    return input->version;
  }

  static const decltype(::blink::mojom::blink::CableAuthentication::client_eid)& client_eid(
      const ::blink::mojom::blink::CableAuthenticationPtr& input) {
    return input->client_eid;
  }

  static const decltype(::blink::mojom::blink::CableAuthentication::authenticator_eid)& authenticator_eid(
      const ::blink::mojom::blink::CableAuthenticationPtr& input) {
    return input->authenticator_eid;
  }

  static const decltype(::blink::mojom::blink::CableAuthentication::session_pre_key)& session_pre_key(
      const ::blink::mojom::blink::CableAuthenticationPtr& input) {
    return input->session_pre_key;
  }

  static const decltype(::blink::mojom::blink::CableAuthentication::server_link_data)& server_link_data(
      const ::blink::mojom::blink::CableAuthenticationPtr& input) {
    return input->server_link_data;
  }

  static const decltype(::blink::mojom::blink::CableAuthentication::experiments)& experiments(
      const ::blink::mojom::blink::CableAuthenticationPtr& input) {
    return input->experiments;
  }

  static bool Read(::blink::mojom::blink::CableAuthentication::DataView input, ::blink::mojom::blink::CableAuthenticationPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::CableRegistration::DataView,
                                         ::blink::mojom::blink::CableRegistrationPtr> {
  static bool IsNull(const ::blink::mojom::blink::CableRegistrationPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::CableRegistrationPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::CableRegistration::versions)& versions(
      const ::blink::mojom::blink::CableRegistrationPtr& input) {
    return input->versions;
  }

  static const decltype(::blink::mojom::blink::CableRegistration::relying_party_public_key)& relying_party_public_key(
      const ::blink::mojom::blink::CableRegistrationPtr& input) {
    return input->relying_party_public_key;
  }

  static bool Read(::blink::mojom::blink::CableRegistration::DataView input, ::blink::mojom::blink::CableRegistrationPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PRFValues::DataView,
                                         ::blink::mojom::blink::PRFValuesPtr> {
  static bool IsNull(const ::blink::mojom::blink::PRFValuesPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PRFValuesPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::PRFValues::id)& id(
      const ::blink::mojom::blink::PRFValuesPtr& input) {
    return input->id;
  }

  static const decltype(::blink::mojom::blink::PRFValues::first)& first(
      const ::blink::mojom::blink::PRFValuesPtr& input) {
    return input->first;
  }

  static const decltype(::blink::mojom::blink::PRFValues::second)& second(
      const ::blink::mojom::blink::PRFValuesPtr& input) {
    return input->second;
  }

  static bool Read(::blink::mojom::blink::PRFValues::DataView input, ::blink::mojom::blink::PRFValuesPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PaymentOptions::DataView,
                                         ::blink::mojom::blink::PaymentOptionsPtr> {
  static bool IsNull(const ::blink::mojom::blink::PaymentOptionsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PaymentOptionsPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::PaymentOptions::total)& total(
      const ::blink::mojom::blink::PaymentOptionsPtr& input) {
    return input->total;
  }

  static const decltype(::blink::mojom::blink::PaymentOptions::instrument)& instrument(
      const ::blink::mojom::blink::PaymentOptionsPtr& input) {
    return input->instrument;
  }

  static const decltype(::blink::mojom::blink::PaymentOptions::payee_name)& payee_name(
      const ::blink::mojom::blink::PaymentOptionsPtr& input) {
    return input->payee_name;
  }

  static const decltype(::blink::mojom::blink::PaymentOptions::payee_origin)& payee_origin(
      const ::blink::mojom::blink::PaymentOptionsPtr& input) {
    return input->payee_origin;
  }

  static bool Read(::blink::mojom::blink::PaymentOptions::DataView input, ::blink::mojom::blink::PaymentOptionsPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PaymentCredentialInstrument::DataView,
                                         ::blink::mojom::blink::PaymentCredentialInstrumentPtr> {
  static bool IsNull(const ::blink::mojom::blink::PaymentCredentialInstrumentPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PaymentCredentialInstrumentPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::PaymentCredentialInstrument::display_name)& display_name(
      const ::blink::mojom::blink::PaymentCredentialInstrumentPtr& input) {
    return input->display_name;
  }

  static const decltype(::blink::mojom::blink::PaymentCredentialInstrument::icon)& icon(
      const ::blink::mojom::blink::PaymentCredentialInstrumentPtr& input) {
    return input->icon;
  }

  static decltype(::blink::mojom::blink::PaymentCredentialInstrument::iconMustBeShown) iconMustBeShown(
      const ::blink::mojom::blink::PaymentCredentialInstrumentPtr& input) {
    return input->iconMustBeShown;
  }

  static bool Read(::blink::mojom::blink::PaymentCredentialInstrument::DataView input, ::blink::mojom::blink::PaymentCredentialInstrumentPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::RemoteDesktopClientOverride::DataView,
                                         ::blink::mojom::blink::RemoteDesktopClientOverridePtr> {
  static bool IsNull(const ::blink::mojom::blink::RemoteDesktopClientOverridePtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::RemoteDesktopClientOverridePtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::RemoteDesktopClientOverride::origin)& origin(
      const ::blink::mojom::blink::RemoteDesktopClientOverridePtr& input) {
    return input->origin;
  }

  static decltype(::blink::mojom::blink::RemoteDesktopClientOverride::same_origin_with_ancestors) same_origin_with_ancestors(
      const ::blink::mojom::blink::RemoteDesktopClientOverridePtr& input) {
    return input->same_origin_with_ancestors;
  }

  static bool Read(::blink::mojom::blink::RemoteDesktopClientOverride::DataView input, ::blink::mojom::blink::RemoteDesktopClientOverridePtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PublicKeyCredentialRequestOptions::DataView,
                                         ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr> {
  static bool IsNull(const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::is_conditional) is_conditional(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->is_conditional;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::challenge)& challenge(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->challenge;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::timeout)& timeout(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->timeout;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::relying_party_id)& relying_party_id(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->relying_party_id;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::allow_credentials)& allow_credentials(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->allow_credentials;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::user_verification) user_verification(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->user_verification;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::appid)& appid(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->appid;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::cable_authentication_data)& cable_authentication_data(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->cable_authentication_data;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::user_verification_methods) user_verification_methods(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->user_verification_methods;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::prf) prf(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->prf;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::prf_inputs)& prf_inputs(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->prf_inputs;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::large_blob_read) large_blob_read(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->large_blob_read;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::large_blob_write)& large_blob_write(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->large_blob_write;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::get_cred_blob) get_cred_blob(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->get_cred_blob;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialRequestOptions::remote_desktop_client_override)& remote_desktop_client_override(
      const ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr& input) {
    return input->remote_desktop_client_override;
  }

  static bool Read(::blink::mojom::blink::PublicKeyCredentialRequestOptions::DataView input, ::blink::mojom::blink::PublicKeyCredentialRequestOptionsPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::AuthenticatorSelectionCriteria::DataView,
                                         ::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr> {
  static bool IsNull(const ::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::AuthenticatorSelectionCriteria::authenticator_attachment) authenticator_attachment(
      const ::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr& input) {
    return input->authenticator_attachment;
  }

  static decltype(::blink::mojom::blink::AuthenticatorSelectionCriteria::resident_key) resident_key(
      const ::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr& input) {
    return input->resident_key;
  }

  static decltype(::blink::mojom::blink::AuthenticatorSelectionCriteria::user_verification) user_verification(
      const ::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr& input) {
    return input->user_verification;
  }

  static bool Read(::blink::mojom::blink::AuthenticatorSelectionCriteria::DataView input, ::blink::mojom::blink::AuthenticatorSelectionCriteriaPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PublicKeyCredentialCreationOptions::DataView,
                                         ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr> {
  static bool IsNull(const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::relying_party)& relying_party(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->relying_party;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::user)& user(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->user;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::challenge)& challenge(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->challenge;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::public_key_parameters)& public_key_parameters(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->public_key_parameters;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::timeout)& timeout(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->timeout;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::exclude_credentials)& exclude_credentials(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->exclude_credentials;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::authenticator_selection)& authenticator_selection(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->authenticator_selection;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::attestation) attestation(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->attestation;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::cable_registration_data)& cable_registration_data(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->cable_registration_data;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::hmac_create_secret) hmac_create_secret(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->hmac_create_secret;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::prf_enable) prf_enable(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->prf_enable;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::protection_policy) protection_policy(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->protection_policy;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::enforce_protection_policy) enforce_protection_policy(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->enforce_protection_policy;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::appid_exclude)& appid_exclude(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->appid_exclude;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::cred_props) cred_props(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->cred_props;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::large_blob_enable) large_blob_enable(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->large_blob_enable;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::is_payment_credential_creation) is_payment_credential_creation(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->is_payment_credential_creation;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::cred_blob)& cred_blob(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->cred_blob;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::google_legacy_app_id_support) google_legacy_app_id_support(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->google_legacy_app_id_support;
  }

  static decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::min_pin_length_requested) min_pin_length_requested(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->min_pin_length_requested;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialCreationOptions::remote_desktop_client_override)& remote_desktop_client_override(
      const ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr& input) {
    return input->remote_desktop_client_override;
  }

  static bool Read(::blink::mojom::blink::PublicKeyCredentialCreationOptions::DataView input, ::blink::mojom::blink::PublicKeyCredentialCreationOptionsPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::PublicKeyCredentialDescriptor::DataView,
                                         ::blink::mojom::blink::PublicKeyCredentialDescriptorPtr> {
  static bool IsNull(const ::blink::mojom::blink::PublicKeyCredentialDescriptorPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::PublicKeyCredentialDescriptorPtr* output) { output->reset(); }

  static decltype(::blink::mojom::blink::PublicKeyCredentialDescriptor::type) type(
      const ::blink::mojom::blink::PublicKeyCredentialDescriptorPtr& input) {
    return input->type;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialDescriptor::id)& id(
      const ::blink::mojom::blink::PublicKeyCredentialDescriptorPtr& input) {
    return input->id;
  }

  static const decltype(::blink::mojom::blink::PublicKeyCredentialDescriptor::transports)& transports(
      const ::blink::mojom::blink::PublicKeyCredentialDescriptorPtr& input) {
    return input->transports;
  }

  static bool Read(::blink::mojom::blink::PublicKeyCredentialDescriptor::DataView input, ::blink::mojom::blink::PublicKeyCredentialDescriptorPtr* output);
};


template <>
struct PLATFORM_EXPORT StructTraits<::blink::mojom::blink::WebAuthnDOMExceptionDetails::DataView,
                                         ::blink::mojom::blink::WebAuthnDOMExceptionDetailsPtr> {
  static bool IsNull(const ::blink::mojom::blink::WebAuthnDOMExceptionDetailsPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::blink::WebAuthnDOMExceptionDetailsPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::blink::WebAuthnDOMExceptionDetails::name)& name(
      const ::blink::mojom::blink::WebAuthnDOMExceptionDetailsPtr& input) {
    return input->name;
  }

  static const decltype(::blink::mojom::blink::WebAuthnDOMExceptionDetails::message)& message(
      const ::blink::mojom::blink::WebAuthnDOMExceptionDetailsPtr& input) {
    return input->message;
  }

  static bool Read(::blink::mojom::blink::WebAuthnDOMExceptionDetails::DataView input, ::blink::mojom::blink::WebAuthnDOMExceptionDetailsPtr* output);
};

}  // namespace mojo

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_AUTHENTICATOR_MOJOM_BLINK_H_