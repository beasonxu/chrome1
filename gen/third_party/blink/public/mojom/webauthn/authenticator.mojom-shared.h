// third_party/blink/public/mojom/webauthn/authenticator.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_AUTHENTICATOR_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_AUTHENTICATOR_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/webauthn/authenticator.mojom-shared-internal.h"
#include "components/payments/mojom/payment_request_data.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "third_party/blink/public/mojom/payments/payment_credential.mojom-shared.h"
#include "url/mojom/origin.mojom-shared.h"
#include "url/mojom/url.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace blink {
namespace mojom {
class CommonCredentialInfoDataView;

class UvmEntryDataView;

class MakeCredentialAuthenticatorResponseDataView;

class GetAssertionAuthenticatorResponseDataView;

class PublicKeyCredentialRpEntityDataView;

class PublicKeyCredentialUserEntityDataView;

class PublicKeyCredentialParametersDataView;

class CableAuthenticationDataView;

class CableRegistrationDataView;

class PRFValuesDataView;

class PaymentOptionsDataView;

class PaymentCredentialInstrumentDataView;

class RemoteDesktopClientOverrideDataView;

class PublicKeyCredentialRequestOptionsDataView;

class AuthenticatorSelectionCriteriaDataView;

class PublicKeyCredentialCreationOptionsDataView;

class PublicKeyCredentialDescriptorDataView;

class WebAuthnDOMExceptionDetailsDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::CommonCredentialInfoDataView> {
  using Data = ::blink::mojom::internal::CommonCredentialInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::UvmEntryDataView> {
  using Data = ::blink::mojom::internal::UvmEntry_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::MakeCredentialAuthenticatorResponseDataView> {
  using Data = ::blink::mojom::internal::MakeCredentialAuthenticatorResponse_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::GetAssertionAuthenticatorResponseDataView> {
  using Data = ::blink::mojom::internal::GetAssertionAuthenticatorResponse_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PublicKeyCredentialRpEntityDataView> {
  using Data = ::blink::mojom::internal::PublicKeyCredentialRpEntity_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PublicKeyCredentialUserEntityDataView> {
  using Data = ::blink::mojom::internal::PublicKeyCredentialUserEntity_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PublicKeyCredentialParametersDataView> {
  using Data = ::blink::mojom::internal::PublicKeyCredentialParameters_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::CableAuthenticationDataView> {
  using Data = ::blink::mojom::internal::CableAuthentication_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::CableRegistrationDataView> {
  using Data = ::blink::mojom::internal::CableRegistration_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PRFValuesDataView> {
  using Data = ::blink::mojom::internal::PRFValues_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PaymentOptionsDataView> {
  using Data = ::blink::mojom::internal::PaymentOptions_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PaymentCredentialInstrumentDataView> {
  using Data = ::blink::mojom::internal::PaymentCredentialInstrument_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::RemoteDesktopClientOverrideDataView> {
  using Data = ::blink::mojom::internal::RemoteDesktopClientOverride_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PublicKeyCredentialRequestOptionsDataView> {
  using Data = ::blink::mojom::internal::PublicKeyCredentialRequestOptions_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::AuthenticatorSelectionCriteriaDataView> {
  using Data = ::blink::mojom::internal::AuthenticatorSelectionCriteria_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PublicKeyCredentialCreationOptionsDataView> {
  using Data = ::blink::mojom::internal::PublicKeyCredentialCreationOptions_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::PublicKeyCredentialDescriptorDataView> {
  using Data = ::blink::mojom::internal::PublicKeyCredentialDescriptor_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::WebAuthnDOMExceptionDetailsDataView> {
  using Data = ::blink::mojom::internal::WebAuthnDOMExceptionDetails_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class AuthenticatorStatus : int32_t {
  
  SUCCESS = 0,
  
  PENDING_REQUEST = 1,
  
  NOT_ALLOWED_ERROR = 2,
  
  INVALID_DOMAIN = 3,
  
  INVALID_ICON_URL = 4,
  
  CREDENTIAL_EXCLUDED = 5,
  
  NOT_IMPLEMENTED = 6,
  
  NOT_FOCUSED = 7,
  
  RESIDENT_CREDENTIALS_UNSUPPORTED = 8,
  
  USER_VERIFICATION_UNSUPPORTED = 9,
  
  ALGORITHM_UNSUPPORTED = 10,
  
  EMPTY_ALLOW_CREDENTIALS = 11,
  
  ANDROID_NOT_SUPPORTED_ERROR = 12,
  
  PROTECTION_POLICY_INCONSISTENT = 13,
  
  ABORT_ERROR = 14,
  
  OPAQUE_DOMAIN = 15,
  
  INVALID_PROTOCOL = 16,
  
  BAD_RELYING_PARTY_ID = 17,
  
  CANNOT_READ_AND_WRITE_LARGE_BLOB = 18,
  
  INVALID_ALLOW_CREDENTIALS_FOR_LARGE_BLOB = 19,
  
  FAILED_TO_SAVE_CREDENTIAL_ID_FOR_PAYMENT_EXTENSION = 20,
  
  REMOTE_DESKTOP_CLIENT_OVERRIDE_NOT_AUTHORIZED = 21,
  
  ERROR_WITH_DOM_EXCEPTION_DETAILS = 22,
  
  UNKNOWN_ERROR = 23,
  kMinValue = 0,
  kMaxValue = 23,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AuthenticatorStatus value);
inline bool IsKnownEnumValue(AuthenticatorStatus value) {
  return internal::AuthenticatorStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class AuthenticatorTransport : int32_t {
  
  USB = 0,
  
  NFC = 1,
  
  BLE = 2,
  
  CABLE = 3,
  
  INTERNAL = 4,
  kMinValue = 0,
  kMaxValue = 4,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AuthenticatorTransport value);
inline bool IsKnownEnumValue(AuthenticatorTransport value) {
  return internal::AuthenticatorTransport_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class UserVerificationRequirement : int32_t {
  
  REQUIRED = 0,
  
  PREFERRED = 1,
  
  DISCOURAGED = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, UserVerificationRequirement value);
inline bool IsKnownEnumValue(UserVerificationRequirement value) {
  return internal::UserVerificationRequirement_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class AttestationConveyancePreference : int32_t {
  
  NONE = 0,
  
  INDIRECT = 1,
  
  DIRECT = 2,
  
  ENTERPRISE = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AttestationConveyancePreference value);
inline bool IsKnownEnumValue(AttestationConveyancePreference value) {
  return internal::AttestationConveyancePreference_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ResidentKeyRequirement : int32_t {
  
  DISCOURAGED = 0,
  
  PREFERRED = 1,
  
  REQUIRED = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, ResidentKeyRequirement value);
inline bool IsKnownEnumValue(ResidentKeyRequirement value) {
  return internal::ResidentKeyRequirement_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class AuthenticatorAttachment : int32_t {
  
  NO_PREFERENCE = 0,
  
  PLATFORM = 1,
  
  CROSS_PLATFORM = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, AuthenticatorAttachment value);
inline bool IsKnownEnumValue(AuthenticatorAttachment value) {
  return internal::AuthenticatorAttachment_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class ProtectionPolicy : int32_t {
  
  UNSPECIFIED = 0,
  
  NONE = 1,
  
  UV_OR_CRED_ID_REQUIRED = 2,
  
  UV_REQUIRED = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, ProtectionPolicy value);
inline bool IsKnownEnumValue(ProtectionPolicy value) {
  return internal::ProtectionPolicy_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class LargeBlobSupport : int32_t {
  
  NOT_REQUESTED = 0,
  
  REQUIRED = 1,
  
  PREFERRED = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, LargeBlobSupport value);
inline bool IsKnownEnumValue(LargeBlobSupport value) {
  return internal::LargeBlobSupport_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class PublicKeyCredentialType : int32_t {
  
  PUBLIC_KEY = 0,
  kMinValue = 0,
  kMaxValue = 0,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, PublicKeyCredentialType value);
inline bool IsKnownEnumValue(PublicKeyCredentialType value) {
  return internal::PublicKeyCredentialType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class AuthenticatorInterfaceBase {};

using AuthenticatorPtrDataView =
    mojo::InterfacePtrDataView<AuthenticatorInterfaceBase>;
using AuthenticatorRequestDataView =
    mojo::InterfaceRequestDataView<AuthenticatorInterfaceBase>;
using AuthenticatorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<AuthenticatorInterfaceBase>;
using AuthenticatorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<AuthenticatorInterfaceBase>;


class CommonCredentialInfoDataView {
 public:
  CommonCredentialInfoDataView() = default;

  CommonCredentialInfoDataView(
      internal::CommonCredentialInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetRawIdDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRawId(UserType* output) {
    
    auto* pointer = data_->raw_id.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetClientDataJsonDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadClientDataJson(UserType* output) {
    
    auto* pointer = data_->client_data_json.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetAuthenticatorDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuthenticatorData(UserType* output) {
    
    auto* pointer = data_->authenticator_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::CommonCredentialInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class UvmEntryDataView {
 public:
  UvmEntryDataView() = default;

  UvmEntryDataView(
      internal::UvmEntry_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  uint32_t user_verification_method() const {
    return data_->user_verification_method;
  }
  uint16_t key_protection_type() const {
    return data_->key_protection_type;
  }
  uint16_t matcher_protection_type() const {
    return data_->matcher_protection_type;
  }
 private:
  internal::UvmEntry_Data* data_ = nullptr;
};



class MakeCredentialAuthenticatorResponseDataView {
 public:
  MakeCredentialAuthenticatorResponseDataView() = default;

  MakeCredentialAuthenticatorResponseDataView(
      internal::MakeCredentialAuthenticatorResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInfoDataView(
      CommonCredentialInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInfo(UserType* output) {
    
    auto* pointer = data_->info.Get();
    return mojo::internal::Deserialize<::blink::mojom::CommonCredentialInfoDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAuthenticatorAttachment(UserType* output) const {
    auto data_value = data_->authenticator_attachment;
    return mojo::internal::Deserialize<::blink::mojom::AuthenticatorAttachment>(
        data_value, output);
  }
  AuthenticatorAttachment authenticator_attachment() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::AuthenticatorAttachment>(data_->authenticator_attachment));
  }
  inline void GetAttestationObjectDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAttestationObject(UserType* output) {
    
    auto* pointer = data_->attestation_object.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetTransportsDataView(
      mojo::ArrayDataView<AuthenticatorTransport>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransports(UserType* output) {
    
    auto* pointer = data_->transports.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::AuthenticatorTransport>>(
        pointer, output, message_);
  }
  bool echo_hmac_create_secret() const {
    return data_->echo_hmac_create_secret;
  }
  bool hmac_create_secret() const {
    return data_->hmac_create_secret;
  }
  bool echo_prf() const {
    return data_->echo_prf;
  }
  bool prf() const {
    return data_->prf;
  }
  bool echo_cred_blob() const {
    return data_->echo_cred_blob;
  }
  bool cred_blob() const {
    return data_->cred_blob;
  }
  inline void GetPublicKeyDerDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPublicKeyDer(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `public_key_der` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPublicKeyDer` instead "
    "of `ReadPublicKeyDer if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->public_key_der.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  int32_t public_key_algo() const {
    return data_->public_key_algo;
  }
  bool echo_cred_props() const {
    return data_->echo_cred_props;
  }
  bool has_cred_props_rk() const {
    return data_->has_cred_props_rk;
  }
  bool cred_props_rk() const {
    return data_->cred_props_rk;
  }
  bool echo_large_blob() const {
    return data_->echo_large_blob;
  }
  bool supports_large_blob() const {
    return data_->supports_large_blob;
  }
 private:
  internal::MakeCredentialAuthenticatorResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GetAssertionAuthenticatorResponseDataView {
 public:
  GetAssertionAuthenticatorResponseDataView() = default;

  GetAssertionAuthenticatorResponseDataView(
      internal::GetAssertionAuthenticatorResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInfoDataView(
      CommonCredentialInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInfo(UserType* output) {
    
    auto* pointer = data_->info.Get();
    return mojo::internal::Deserialize<::blink::mojom::CommonCredentialInfoDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAuthenticatorAttachment(UserType* output) const {
    auto data_value = data_->authenticator_attachment;
    return mojo::internal::Deserialize<::blink::mojom::AuthenticatorAttachment>(
        data_value, output);
  }
  AuthenticatorAttachment authenticator_attachment() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::AuthenticatorAttachment>(data_->authenticator_attachment));
  }
  inline void GetSignatureDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSignature(UserType* output) {
    
    auto* pointer = data_->signature.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetUserHandleDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUserHandle(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `user_handle` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUserHandle` instead "
    "of `ReadUserHandle if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->user_handle.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  bool echo_appid_extension() const {
    return data_->echo_appid_extension;
  }
  bool appid_extension() const {
    return data_->appid_extension;
  }
  bool echo_user_verification_methods() const {
    return data_->echo_user_verification_methods;
  }
  inline void GetUserVerificationMethodsDataView(
      mojo::ArrayDataView<UvmEntryDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUserVerificationMethods(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<::blink::mojom::UvmEntryDataView>, UserType>(),
    "Attempting to read the optional `user_verification_methods` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUserVerificationMethods` instead "
    "of `ReadUserVerificationMethods if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->user_verification_methods.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::UvmEntryDataView>>(
        pointer, output, message_);
  }
  bool echo_prf() const {
    return data_->echo_prf;
  }
  inline void GetPrfResultsDataView(
      PRFValuesDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrfResults(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::PRFValuesDataView, UserType>(),
    "Attempting to read the optional `prf_results` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPrfResults` instead "
    "of `ReadPrfResults if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->prf_results.Get();
    return mojo::internal::Deserialize<::blink::mojom::PRFValuesDataView>(
        pointer, output, message_);
  }
  bool prf_not_evaluated() const {
    return data_->prf_not_evaluated;
  }
  bool echo_large_blob() const {
    return data_->echo_large_blob;
  }
  inline void GetLargeBlobDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLargeBlob(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `large_blob` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLargeBlob` instead "
    "of `ReadLargeBlob if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->large_blob.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  bool echo_large_blob_written() const {
    return data_->echo_large_blob_written;
  }
  bool large_blob_written() const {
    return data_->large_blob_written;
  }
  inline void GetGetCredBlobDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGetCredBlob(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `get_cred_blob` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadGetCredBlob` instead "
    "of `ReadGetCredBlob if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->get_cred_blob.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::GetAssertionAuthenticatorResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PublicKeyCredentialRpEntityDataView {
 public:
  PublicKeyCredentialRpEntityDataView() = default;

  PublicKeyCredentialRpEntityDataView(
      internal::PublicKeyCredentialRpEntity_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetIconDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIcon(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `icon` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadIcon` instead "
    "of `ReadIcon if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->icon.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
 private:
  internal::PublicKeyCredentialRpEntity_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PublicKeyCredentialUserEntityDataView {
 public:
  PublicKeyCredentialUserEntityDataView() = default;

  PublicKeyCredentialUserEntityDataView(
      internal::PublicKeyCredentialUserEntity_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIdDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetIconDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIcon(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::UrlDataView, UserType>(),
    "Attempting to read the optional `icon` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadIcon` instead "
    "of `ReadIcon if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->icon.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  inline void GetDisplayNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDisplayName(UserType* output) {
    
    auto* pointer = data_->display_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::PublicKeyCredentialUserEntity_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PublicKeyCredentialParametersDataView {
 public:
  PublicKeyCredentialParametersDataView() = default;

  PublicKeyCredentialParametersDataView(
      internal::PublicKeyCredentialParameters_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::blink::mojom::PublicKeyCredentialType>(
        data_value, output);
  }
  PublicKeyCredentialType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::PublicKeyCredentialType>(data_->type));
  }
  int32_t algorithm_identifier() const {
    return data_->algorithm_identifier;
  }
 private:
  internal::PublicKeyCredentialParameters_Data* data_ = nullptr;
};



class CableAuthenticationDataView {
 public:
  CableAuthenticationDataView() = default;

  CableAuthenticationDataView(
      internal::CableAuthentication_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  uint8_t version() const {
    return data_->version;
  }
  inline void GetClientEidDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadClientEid(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `client_eid` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadClientEid` instead "
    "of `ReadClientEid if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->client_eid.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetAuthenticatorEidDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuthenticatorEid(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `authenticator_eid` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAuthenticatorEid` instead "
    "of `ReadAuthenticatorEid if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->authenticator_eid.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetSessionPreKeyDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSessionPreKey(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `session_pre_key` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSessionPreKey` instead "
    "of `ReadSessionPreKey if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->session_pre_key.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetServerLinkDataDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadServerLinkData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `server_link_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadServerLinkData` instead "
    "of `ReadServerLinkData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->server_link_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetExperimentsDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExperiments(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `experiments` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadExperiments` instead "
    "of `ReadExperiments if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->experiments.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::CableAuthentication_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CableRegistrationDataView {
 public:
  CableRegistrationDataView() = default;

  CableRegistrationDataView(
      internal::CableRegistration_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetVersionsDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVersions(UserType* output) {
    
    auto* pointer = data_->versions.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetRelyingPartyPublicKeyDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRelyingPartyPublicKey(UserType* output) {
    
    auto* pointer = data_->relying_party_public_key.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::CableRegistration_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PRFValuesDataView {
 public:
  PRFValuesDataView() = default;

  PRFValuesDataView(
      internal::PRFValues_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetIdDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadId` instead "
    "of `ReadId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetFirstDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirst(UserType* output) {
    
    auto* pointer = data_->first.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetSecondDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSecond(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `second` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSecond` instead "
    "of `ReadSecond if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->second.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
 private:
  internal::PRFValues_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PaymentOptionsDataView {
 public:
  PaymentOptionsDataView() = default;

  PaymentOptionsDataView(
      internal::PaymentOptions_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetTotalDataView(
      ::payments::mojom::PaymentCurrencyAmountDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTotal(UserType* output) {
    
    auto* pointer = data_->total.Get();
    return mojo::internal::Deserialize<::payments::mojom::PaymentCurrencyAmountDataView>(
        pointer, output, message_);
  }
  inline void GetInstrumentDataView(
      PaymentCredentialInstrumentDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInstrument(UserType* output) {
    
    auto* pointer = data_->instrument.Get();
    return mojo::internal::Deserialize<::blink::mojom::PaymentCredentialInstrumentDataView>(
        pointer, output, message_);
  }
  inline void GetPayeeNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPayeeName(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `payee_name` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPayeeName` instead "
    "of `ReadPayeeName if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->payee_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetPayeeOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPayeeOrigin(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::url::mojom::OriginDataView, UserType>(),
    "Attempting to read the optional `payee_origin` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPayeeOrigin` instead "
    "of `ReadPayeeOrigin if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->payee_origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
 private:
  internal::PaymentOptions_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PaymentCredentialInstrumentDataView {
 public:
  PaymentCredentialInstrumentDataView() = default;

  PaymentCredentialInstrumentDataView(
      internal::PaymentCredentialInstrument_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDisplayNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDisplayName(UserType* output) {
    
    auto* pointer = data_->display_name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetIconDataView(
      ::url::mojom::UrlDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIcon(UserType* output) {
    
    auto* pointer = data_->icon.Get();
    return mojo::internal::Deserialize<::url::mojom::UrlDataView>(
        pointer, output, message_);
  }
  bool iconMustBeShown() const {
    return data_->iconMustBeShown;
  }
 private:
  internal::PaymentCredentialInstrument_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class RemoteDesktopClientOverrideDataView {
 public:
  RemoteDesktopClientOverrideDataView() = default;

  RemoteDesktopClientOverrideDataView(
      internal::RemoteDesktopClientOverride_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetOriginDataView(
      ::url::mojom::OriginDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadOrigin(UserType* output) {
    
    auto* pointer = data_->origin.Get();
    return mojo::internal::Deserialize<::url::mojom::OriginDataView>(
        pointer, output, message_);
  }
  bool same_origin_with_ancestors() const {
    return data_->same_origin_with_ancestors;
  }
 private:
  internal::RemoteDesktopClientOverride_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PublicKeyCredentialRequestOptionsDataView {
 public:
  PublicKeyCredentialRequestOptionsDataView() = default;

  PublicKeyCredentialRequestOptionsDataView(
      internal::PublicKeyCredentialRequestOptions_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  bool is_conditional() const {
    return data_->is_conditional;
  }
  inline void GetChallengeDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadChallenge(UserType* output) {
    
    auto* pointer = data_->challenge.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetTimeoutDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimeout(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `timeout` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTimeout` instead "
    "of `ReadTimeout if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->timeout.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetRelyingPartyIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRelyingPartyId(UserType* output) {
    
    auto* pointer = data_->relying_party_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetAllowCredentialsDataView(
      mojo::ArrayDataView<PublicKeyCredentialDescriptorDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAllowCredentials(UserType* output) {
    
    auto* pointer = data_->allow_credentials.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::PublicKeyCredentialDescriptorDataView>>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadUserVerification(UserType* output) const {
    auto data_value = data_->user_verification;
    return mojo::internal::Deserialize<::blink::mojom::UserVerificationRequirement>(
        data_value, output);
  }
  UserVerificationRequirement user_verification() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::UserVerificationRequirement>(data_->user_verification));
  }
  inline void GetAppidDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAppid(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `appid` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAppid` instead "
    "of `ReadAppid if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->appid.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetCableAuthenticationDataDataView(
      mojo::ArrayDataView<CableAuthenticationDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCableAuthenticationData(UserType* output) {
    
    auto* pointer = data_->cable_authentication_data.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::CableAuthenticationDataView>>(
        pointer, output, message_);
  }
  bool user_verification_methods() const {
    return data_->user_verification_methods;
  }
  bool prf() const {
    return data_->prf;
  }
  inline void GetPrfInputsDataView(
      mojo::ArrayDataView<PRFValuesDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrfInputs(UserType* output) {
    
    auto* pointer = data_->prf_inputs.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::PRFValuesDataView>>(
        pointer, output, message_);
  }
  bool large_blob_read() const {
    return data_->large_blob_read;
  }
  inline void GetLargeBlobWriteDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLargeBlobWrite(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `large_blob_write` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLargeBlobWrite` instead "
    "of `ReadLargeBlobWrite if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->large_blob_write.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  bool get_cred_blob() const {
    return data_->get_cred_blob;
  }
  inline void GetRemoteDesktopClientOverrideDataView(
      RemoteDesktopClientOverrideDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRemoteDesktopClientOverride(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::RemoteDesktopClientOverrideDataView, UserType>(),
    "Attempting to read the optional `remote_desktop_client_override` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRemoteDesktopClientOverride` instead "
    "of `ReadRemoteDesktopClientOverride if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->remote_desktop_client_override.Get();
    return mojo::internal::Deserialize<::blink::mojom::RemoteDesktopClientOverrideDataView>(
        pointer, output, message_);
  }
 private:
  internal::PublicKeyCredentialRequestOptions_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AuthenticatorSelectionCriteriaDataView {
 public:
  AuthenticatorSelectionCriteriaDataView() = default;

  AuthenticatorSelectionCriteriaDataView(
      internal::AuthenticatorSelectionCriteria_Data* data,
      mojo::Message* message)
      : data_(data) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadAuthenticatorAttachment(UserType* output) const {
    auto data_value = data_->authenticator_attachment;
    return mojo::internal::Deserialize<::blink::mojom::AuthenticatorAttachment>(
        data_value, output);
  }
  AuthenticatorAttachment authenticator_attachment() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::AuthenticatorAttachment>(data_->authenticator_attachment));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadResidentKey(UserType* output) const {
    auto data_value = data_->resident_key;
    return mojo::internal::Deserialize<::blink::mojom::ResidentKeyRequirement>(
        data_value, output);
  }
  ResidentKeyRequirement resident_key() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::ResidentKeyRequirement>(data_->resident_key));
  }
  template <typename UserType>
  [[nodiscard]] bool ReadUserVerification(UserType* output) const {
    auto data_value = data_->user_verification;
    return mojo::internal::Deserialize<::blink::mojom::UserVerificationRequirement>(
        data_value, output);
  }
  UserVerificationRequirement user_verification() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::UserVerificationRequirement>(data_->user_verification));
  }
 private:
  internal::AuthenticatorSelectionCriteria_Data* data_ = nullptr;
};



class PublicKeyCredentialCreationOptionsDataView {
 public:
  PublicKeyCredentialCreationOptionsDataView() = default;

  PublicKeyCredentialCreationOptionsDataView(
      internal::PublicKeyCredentialCreationOptions_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetRelyingPartyDataView(
      PublicKeyCredentialRpEntityDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRelyingParty(UserType* output) {
    
    auto* pointer = data_->relying_party.Get();
    return mojo::internal::Deserialize<::blink::mojom::PublicKeyCredentialRpEntityDataView>(
        pointer, output, message_);
  }
  inline void GetUserDataView(
      PublicKeyCredentialUserEntityDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUser(UserType* output) {
    
    auto* pointer = data_->user.Get();
    return mojo::internal::Deserialize<::blink::mojom::PublicKeyCredentialUserEntityDataView>(
        pointer, output, message_);
  }
  inline void GetChallengeDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadChallenge(UserType* output) {
    
    auto* pointer = data_->challenge.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetPublicKeyParametersDataView(
      mojo::ArrayDataView<PublicKeyCredentialParametersDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPublicKeyParameters(UserType* output) {
    
    auto* pointer = data_->public_key_parameters.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::PublicKeyCredentialParametersDataView>>(
        pointer, output, message_);
  }
  inline void GetTimeoutDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTimeout(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `timeout` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadTimeout` instead "
    "of `ReadTimeout if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->timeout.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetExcludeCredentialsDataView(
      mojo::ArrayDataView<PublicKeyCredentialDescriptorDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExcludeCredentials(UserType* output) {
    
    auto* pointer = data_->exclude_credentials.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::PublicKeyCredentialDescriptorDataView>>(
        pointer, output, message_);
  }
  inline void GetAuthenticatorSelectionDataView(
      AuthenticatorSelectionCriteriaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAuthenticatorSelection(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::AuthenticatorSelectionCriteriaDataView, UserType>(),
    "Attempting to read the optional `authenticator_selection` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAuthenticatorSelection` instead "
    "of `ReadAuthenticatorSelection if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->authenticator_selection.Get();
    return mojo::internal::Deserialize<::blink::mojom::AuthenticatorSelectionCriteriaDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadAttestation(UserType* output) const {
    auto data_value = data_->attestation;
    return mojo::internal::Deserialize<::blink::mojom::AttestationConveyancePreference>(
        data_value, output);
  }
  AttestationConveyancePreference attestation() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::AttestationConveyancePreference>(data_->attestation));
  }
  inline void GetCableRegistrationDataDataView(
      CableRegistrationDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCableRegistrationData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::CableRegistrationDataView, UserType>(),
    "Attempting to read the optional `cable_registration_data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCableRegistrationData` instead "
    "of `ReadCableRegistrationData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->cable_registration_data.Get();
    return mojo::internal::Deserialize<::blink::mojom::CableRegistrationDataView>(
        pointer, output, message_);
  }
  bool hmac_create_secret() const {
    return data_->hmac_create_secret;
  }
  bool prf_enable() const {
    return data_->prf_enable;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadProtectionPolicy(UserType* output) const {
    auto data_value = data_->protection_policy;
    return mojo::internal::Deserialize<::blink::mojom::ProtectionPolicy>(
        data_value, output);
  }
  ProtectionPolicy protection_policy() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::ProtectionPolicy>(data_->protection_policy));
  }
  bool enforce_protection_policy() const {
    return data_->enforce_protection_policy;
  }
  inline void GetAppidExcludeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAppidExclude(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `appid_exclude` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAppidExclude` instead "
    "of `ReadAppidExclude if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->appid_exclude.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool cred_props() const {
    return data_->cred_props;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadLargeBlobEnable(UserType* output) const {
    auto data_value = data_->large_blob_enable;
    return mojo::internal::Deserialize<::blink::mojom::LargeBlobSupport>(
        data_value, output);
  }
  LargeBlobSupport large_blob_enable() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::LargeBlobSupport>(data_->large_blob_enable));
  }
  bool is_payment_credential_creation() const {
    return data_->is_payment_credential_creation;
  }
  inline void GetCredBlobDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadCredBlob(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::ArrayDataView<uint8_t>, UserType>(),
    "Attempting to read the optional `cred_blob` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadCredBlob` instead "
    "of `ReadCredBlob if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->cred_blob.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  bool google_legacy_app_id_support() const {
    return data_->google_legacy_app_id_support;
  }
  bool min_pin_length_requested() const {
    return data_->min_pin_length_requested;
  }
  inline void GetRemoteDesktopClientOverrideDataView(
      RemoteDesktopClientOverrideDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRemoteDesktopClientOverride(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::RemoteDesktopClientOverrideDataView, UserType>(),
    "Attempting to read the optional `remote_desktop_client_override` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadRemoteDesktopClientOverride` instead "
    "of `ReadRemoteDesktopClientOverride if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->remote_desktop_client_override.Get();
    return mojo::internal::Deserialize<::blink::mojom::RemoteDesktopClientOverrideDataView>(
        pointer, output, message_);
  }
 private:
  internal::PublicKeyCredentialCreationOptions_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PublicKeyCredentialDescriptorDataView {
 public:
  PublicKeyCredentialDescriptorDataView() = default;

  PublicKeyCredentialDescriptorDataView(
      internal::PublicKeyCredentialDescriptor_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::blink::mojom::PublicKeyCredentialType>(
        data_value, output);
  }
  PublicKeyCredentialType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::PublicKeyCredentialType>(data_->type));
  }
  inline void GetIdDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetTransportsDataView(
      mojo::ArrayDataView<AuthenticatorTransport>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTransports(UserType* output) {
    
    auto* pointer = data_->transports.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::AuthenticatorTransport>>(
        pointer, output, message_);
  }
 private:
  internal::PublicKeyCredentialDescriptor_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class WebAuthnDOMExceptionDetailsDataView {
 public:
  WebAuthnDOMExceptionDetailsDataView() = default;

  WebAuthnDOMExceptionDetailsDataView(
      internal::WebAuthnDOMExceptionDetails_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetMessageDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMessage(UserType* output) {
    
    auto* pointer = data_->message.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::WebAuthnDOMExceptionDetails_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::AuthenticatorStatus>
    : public mojo::internal::EnumHashImpl<::blink::mojom::AuthenticatorStatus> {};

template <>
struct hash<::blink::mojom::AuthenticatorTransport>
    : public mojo::internal::EnumHashImpl<::blink::mojom::AuthenticatorTransport> {};

template <>
struct hash<::blink::mojom::UserVerificationRequirement>
    : public mojo::internal::EnumHashImpl<::blink::mojom::UserVerificationRequirement> {};

template <>
struct hash<::blink::mojom::AttestationConveyancePreference>
    : public mojo::internal::EnumHashImpl<::blink::mojom::AttestationConveyancePreference> {};

template <>
struct hash<::blink::mojom::ResidentKeyRequirement>
    : public mojo::internal::EnumHashImpl<::blink::mojom::ResidentKeyRequirement> {};

template <>
struct hash<::blink::mojom::AuthenticatorAttachment>
    : public mojo::internal::EnumHashImpl<::blink::mojom::AuthenticatorAttachment> {};

template <>
struct hash<::blink::mojom::ProtectionPolicy>
    : public mojo::internal::EnumHashImpl<::blink::mojom::ProtectionPolicy> {};

template <>
struct hash<::blink::mojom::LargeBlobSupport>
    : public mojo::internal::EnumHashImpl<::blink::mojom::LargeBlobSupport> {};

template <>
struct hash<::blink::mojom::PublicKeyCredentialType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::PublicKeyCredentialType> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AuthenticatorStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::AuthenticatorStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::AuthenticatorStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AuthenticatorTransport, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::AuthenticatorTransport, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::AuthenticatorTransport>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::UserVerificationRequirement, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::UserVerificationRequirement, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::UserVerificationRequirement>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AttestationConveyancePreference, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::AttestationConveyancePreference, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::AttestationConveyancePreference>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::ResidentKeyRequirement, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::ResidentKeyRequirement, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::ResidentKeyRequirement>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AuthenticatorAttachment, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::AuthenticatorAttachment, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::AuthenticatorAttachment>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::ProtectionPolicy, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::ProtectionPolicy, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::ProtectionPolicy>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::LargeBlobSupport, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::LargeBlobSupport, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::LargeBlobSupport>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::PublicKeyCredentialType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::PublicKeyCredentialType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CommonCredentialInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::CommonCredentialInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::CommonCredentialInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType> id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_id, id_fragment);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in CommonCredentialInfo struct");
    decltype(Traits::raw_id(input)) in_raw_id = Traits::raw_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->raw_id)::BaseType>
        raw_id_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams raw_id_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_raw_id, raw_id_fragment, &raw_id_validate_params);
    fragment->raw_id.Set(
        raw_id_fragment.is_null() ? nullptr : raw_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->raw_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null raw_id in CommonCredentialInfo struct");
    decltype(Traits::client_data_json(input)) in_client_data_json = Traits::client_data_json(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->client_data_json)::BaseType>
        client_data_json_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams client_data_json_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_client_data_json, client_data_json_fragment, &client_data_json_validate_params);
    fragment->client_data_json.Set(
        client_data_json_fragment.is_null() ? nullptr : client_data_json_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->client_data_json.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null client_data_json in CommonCredentialInfo struct");
    decltype(Traits::authenticator_data(input)) in_authenticator_data = Traits::authenticator_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->authenticator_data)::BaseType>
        authenticator_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams authenticator_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_authenticator_data, authenticator_data_fragment, &authenticator_data_validate_params);
    fragment->authenticator_data.Set(
        authenticator_data_fragment.is_null() ? nullptr : authenticator_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->authenticator_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null authenticator_data in CommonCredentialInfo struct");
  }

  static bool Deserialize(::blink::mojom::internal::CommonCredentialInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::CommonCredentialInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::UvmEntryDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::UvmEntryDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::UvmEntry_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->user_verification_method = Traits::user_verification_method(input);
    fragment->key_protection_type = Traits::key_protection_type(input);
    fragment->matcher_protection_type = Traits::matcher_protection_type(input);
  }

  static bool Deserialize(::blink::mojom::internal::UvmEntry_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::UvmEntryDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MakeCredentialAuthenticatorResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::MakeCredentialAuthenticatorResponseDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::MakeCredentialAuthenticatorResponse_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::info(input)) in_info = Traits::info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->info)::BaseType> info_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::CommonCredentialInfoDataView>(
        in_info, info_fragment);
    fragment->info.Set(
        info_fragment.is_null() ? nullptr : info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null info in MakeCredentialAuthenticatorResponse struct");
    mojo::internal::Serialize<::blink::mojom::AuthenticatorAttachment>(
        Traits::authenticator_attachment(input), &fragment->authenticator_attachment);
    decltype(Traits::attestation_object(input)) in_attestation_object = Traits::attestation_object(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->attestation_object)::BaseType>
        attestation_object_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams attestation_object_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_attestation_object, attestation_object_fragment, &attestation_object_validate_params);
    fragment->attestation_object.Set(
        attestation_object_fragment.is_null() ? nullptr : attestation_object_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->attestation_object.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null attestation_object in MakeCredentialAuthenticatorResponse struct");
    decltype(Traits::transports(input)) in_transports = Traits::transports(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transports)::BaseType>
        transports_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams transports_validate_params(
        0, ::blink::mojom::internal::AuthenticatorTransport_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::AuthenticatorTransport>>(
        in_transports, transports_fragment, &transports_validate_params);
    fragment->transports.Set(
        transports_fragment.is_null() ? nullptr : transports_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->transports.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transports in MakeCredentialAuthenticatorResponse struct");
    fragment->echo_hmac_create_secret = Traits::echo_hmac_create_secret(input);
    fragment->hmac_create_secret = Traits::hmac_create_secret(input);
    fragment->echo_prf = Traits::echo_prf(input);
    fragment->prf = Traits::prf(input);
    fragment->echo_cred_blob = Traits::echo_cred_blob(input);
    fragment->cred_blob = Traits::cred_blob(input);
    decltype(Traits::public_key_der(input)) in_public_key_der = Traits::public_key_der(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->public_key_der)::BaseType>
        public_key_der_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams public_key_der_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_public_key_der, public_key_der_fragment, &public_key_der_validate_params);
    fragment->public_key_der.Set(
        public_key_der_fragment.is_null() ? nullptr : public_key_der_fragment.data());
    fragment->public_key_algo = Traits::public_key_algo(input);
    fragment->echo_cred_props = Traits::echo_cred_props(input);
    fragment->has_cred_props_rk = Traits::has_cred_props_rk(input);
    fragment->cred_props_rk = Traits::cred_props_rk(input);
    fragment->echo_large_blob = Traits::echo_large_blob(input);
    fragment->supports_large_blob = Traits::supports_large_blob(input);
  }

  static bool Deserialize(::blink::mojom::internal::MakeCredentialAuthenticatorResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::MakeCredentialAuthenticatorResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::GetAssertionAuthenticatorResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::GetAssertionAuthenticatorResponseDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::GetAssertionAuthenticatorResponse_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::info(input)) in_info = Traits::info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->info)::BaseType> info_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::CommonCredentialInfoDataView>(
        in_info, info_fragment);
    fragment->info.Set(
        info_fragment.is_null() ? nullptr : info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null info in GetAssertionAuthenticatorResponse struct");
    mojo::internal::Serialize<::blink::mojom::AuthenticatorAttachment>(
        Traits::authenticator_attachment(input), &fragment->authenticator_attachment);
    decltype(Traits::signature(input)) in_signature = Traits::signature(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->signature)::BaseType>
        signature_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams signature_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_signature, signature_fragment, &signature_validate_params);
    fragment->signature.Set(
        signature_fragment.is_null() ? nullptr : signature_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->signature.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null signature in GetAssertionAuthenticatorResponse struct");
    decltype(Traits::user_handle(input)) in_user_handle = Traits::user_handle(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user_handle)::BaseType>
        user_handle_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams user_handle_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_user_handle, user_handle_fragment, &user_handle_validate_params);
    fragment->user_handle.Set(
        user_handle_fragment.is_null() ? nullptr : user_handle_fragment.data());
    fragment->echo_appid_extension = Traits::echo_appid_extension(input);
    fragment->appid_extension = Traits::appid_extension(input);
    fragment->echo_user_verification_methods = Traits::echo_user_verification_methods(input);
    decltype(Traits::user_verification_methods(input)) in_user_verification_methods = Traits::user_verification_methods(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user_verification_methods)::BaseType>
        user_verification_methods_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams user_verification_methods_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::UvmEntryDataView>>(
        in_user_verification_methods, user_verification_methods_fragment, &user_verification_methods_validate_params);
    fragment->user_verification_methods.Set(
        user_verification_methods_fragment.is_null() ? nullptr : user_verification_methods_fragment.data());
    fragment->echo_prf = Traits::echo_prf(input);
    decltype(Traits::prf_results(input)) in_prf_results = Traits::prf_results(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->prf_results)::BaseType> prf_results_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PRFValuesDataView>(
        in_prf_results, prf_results_fragment);
    fragment->prf_results.Set(
        prf_results_fragment.is_null() ? nullptr : prf_results_fragment.data());
    fragment->prf_not_evaluated = Traits::prf_not_evaluated(input);
    fragment->echo_large_blob = Traits::echo_large_blob(input);
    decltype(Traits::large_blob(input)) in_large_blob = Traits::large_blob(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->large_blob)::BaseType>
        large_blob_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams large_blob_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_large_blob, large_blob_fragment, &large_blob_validate_params);
    fragment->large_blob.Set(
        large_blob_fragment.is_null() ? nullptr : large_blob_fragment.data());
    fragment->echo_large_blob_written = Traits::echo_large_blob_written(input);
    fragment->large_blob_written = Traits::large_blob_written(input);
    decltype(Traits::get_cred_blob(input)) in_get_cred_blob = Traits::get_cred_blob(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->get_cred_blob)::BaseType>
        get_cred_blob_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams get_cred_blob_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_get_cred_blob, get_cred_blob_fragment, &get_cred_blob_validate_params);
    fragment->get_cred_blob.Set(
        get_cred_blob_fragment.is_null() ? nullptr : get_cred_blob_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::GetAssertionAuthenticatorResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::GetAssertionAuthenticatorResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialRpEntityDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PublicKeyCredentialRpEntityDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PublicKeyCredentialRpEntity_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType> id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_id, id_fragment);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in PublicKeyCredentialRpEntity struct");
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in PublicKeyCredentialRpEntity struct");
    decltype(Traits::icon(input)) in_icon = Traits::icon(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->icon)::BaseType> icon_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_icon, icon_fragment);
    fragment->icon.Set(
        icon_fragment.is_null() ? nullptr : icon_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::PublicKeyCredentialRpEntity_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PublicKeyCredentialRpEntityDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialUserEntityDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PublicKeyCredentialUserEntityDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PublicKeyCredentialUserEntity_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType>
        id_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams id_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_id, id_fragment, &id_validate_params);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in PublicKeyCredentialUserEntity struct");
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in PublicKeyCredentialUserEntity struct");
    decltype(Traits::icon(input)) in_icon = Traits::icon(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->icon)::BaseType> icon_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_icon, icon_fragment);
    fragment->icon.Set(
        icon_fragment.is_null() ? nullptr : icon_fragment.data());
    decltype(Traits::display_name(input)) in_display_name = Traits::display_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->display_name)::BaseType> display_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_display_name, display_name_fragment);
    fragment->display_name.Set(
        display_name_fragment.is_null() ? nullptr : display_name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->display_name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null display_name in PublicKeyCredentialUserEntity struct");
  }

  static bool Deserialize(::blink::mojom::internal::PublicKeyCredentialUserEntity_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PublicKeyCredentialUserEntityDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialParametersDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PublicKeyCredentialParametersDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PublicKeyCredentialParameters_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::PublicKeyCredentialType>(
        Traits::type(input), &fragment->type);
    fragment->algorithm_identifier = Traits::algorithm_identifier(input);
  }

  static bool Deserialize(::blink::mojom::internal::PublicKeyCredentialParameters_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PublicKeyCredentialParametersDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CableAuthenticationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::CableAuthenticationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::CableAuthentication_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->version = Traits::version(input);
    decltype(Traits::client_eid(input)) in_client_eid = Traits::client_eid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->client_eid)::BaseType>
        client_eid_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams client_eid_validate_params(
        16, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_client_eid, client_eid_fragment, &client_eid_validate_params);
    fragment->client_eid.Set(
        client_eid_fragment.is_null() ? nullptr : client_eid_fragment.data());
    decltype(Traits::authenticator_eid(input)) in_authenticator_eid = Traits::authenticator_eid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->authenticator_eid)::BaseType>
        authenticator_eid_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams authenticator_eid_validate_params(
        16, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_authenticator_eid, authenticator_eid_fragment, &authenticator_eid_validate_params);
    fragment->authenticator_eid.Set(
        authenticator_eid_fragment.is_null() ? nullptr : authenticator_eid_fragment.data());
    decltype(Traits::session_pre_key(input)) in_session_pre_key = Traits::session_pre_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->session_pre_key)::BaseType>
        session_pre_key_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams session_pre_key_validate_params(
        32, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_session_pre_key, session_pre_key_fragment, &session_pre_key_validate_params);
    fragment->session_pre_key.Set(
        session_pre_key_fragment.is_null() ? nullptr : session_pre_key_fragment.data());
    decltype(Traits::server_link_data(input)) in_server_link_data = Traits::server_link_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->server_link_data)::BaseType>
        server_link_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams server_link_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_server_link_data, server_link_data_fragment, &server_link_data_validate_params);
    fragment->server_link_data.Set(
        server_link_data_fragment.is_null() ? nullptr : server_link_data_fragment.data());
    decltype(Traits::experiments(input)) in_experiments = Traits::experiments(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->experiments)::BaseType>
        experiments_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams experiments_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_experiments, experiments_fragment, &experiments_validate_params);
    fragment->experiments.Set(
        experiments_fragment.is_null() ? nullptr : experiments_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::CableAuthentication_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::CableAuthenticationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::CableRegistrationDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::CableRegistrationDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::CableRegistration_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::versions(input)) in_versions = Traits::versions(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->versions)::BaseType>
        versions_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams versions_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_versions, versions_fragment, &versions_validate_params);
    fragment->versions.Set(
        versions_fragment.is_null() ? nullptr : versions_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->versions.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null versions in CableRegistration struct");
    decltype(Traits::relying_party_public_key(input)) in_relying_party_public_key = Traits::relying_party_public_key(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->relying_party_public_key)::BaseType>
        relying_party_public_key_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams relying_party_public_key_validate_params(
        65, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_relying_party_public_key, relying_party_public_key_fragment, &relying_party_public_key_validate_params);
    fragment->relying_party_public_key.Set(
        relying_party_public_key_fragment.is_null() ? nullptr : relying_party_public_key_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->relying_party_public_key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null relying_party_public_key in CableRegistration struct");
  }

  static bool Deserialize(::blink::mojom::internal::CableRegistration_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::CableRegistrationDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PRFValuesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PRFValuesDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PRFValues_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType>
        id_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams id_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_id, id_fragment, &id_validate_params);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    decltype(Traits::first(input)) in_first = Traits::first(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first)::BaseType>
        first_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams first_validate_params(
        32, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_first, first_fragment, &first_validate_params);
    fragment->first.Set(
        first_fragment.is_null() ? nullptr : first_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->first.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null first in PRFValues struct");
    decltype(Traits::second(input)) in_second = Traits::second(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->second)::BaseType>
        second_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams second_validate_params(
        32, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_second, second_fragment, &second_validate_params);
    fragment->second.Set(
        second_fragment.is_null() ? nullptr : second_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::PRFValues_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PRFValuesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PaymentOptionsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PaymentOptionsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PaymentOptions_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::total(input)) in_total = Traits::total(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->total)::BaseType> total_fragment(
            fragment.message());
    mojo::internal::Serialize<::payments::mojom::PaymentCurrencyAmountDataView>(
        in_total, total_fragment);
    fragment->total.Set(
        total_fragment.is_null() ? nullptr : total_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->total.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null total in PaymentOptions struct");
    decltype(Traits::instrument(input)) in_instrument = Traits::instrument(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->instrument)::BaseType> instrument_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PaymentCredentialInstrumentDataView>(
        in_instrument, instrument_fragment);
    fragment->instrument.Set(
        instrument_fragment.is_null() ? nullptr : instrument_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->instrument.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null instrument in PaymentOptions struct");
    decltype(Traits::payee_name(input)) in_payee_name = Traits::payee_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->payee_name)::BaseType> payee_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_payee_name, payee_name_fragment);
    fragment->payee_name.Set(
        payee_name_fragment.is_null() ? nullptr : payee_name_fragment.data());
    decltype(Traits::payee_origin(input)) in_payee_origin = Traits::payee_origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->payee_origin)::BaseType> payee_origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_payee_origin, payee_origin_fragment);
    fragment->payee_origin.Set(
        payee_origin_fragment.is_null() ? nullptr : payee_origin_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::PaymentOptions_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PaymentOptionsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PaymentCredentialInstrumentDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PaymentCredentialInstrumentDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PaymentCredentialInstrument_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::display_name(input)) in_display_name = Traits::display_name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->display_name)::BaseType> display_name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_display_name, display_name_fragment);
    fragment->display_name.Set(
        display_name_fragment.is_null() ? nullptr : display_name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->display_name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null display_name in PaymentCredentialInstrument struct");
    decltype(Traits::icon(input)) in_icon = Traits::icon(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->icon)::BaseType> icon_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::UrlDataView>(
        in_icon, icon_fragment);
    fragment->icon.Set(
        icon_fragment.is_null() ? nullptr : icon_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->icon.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null icon in PaymentCredentialInstrument struct");
    fragment->iconMustBeShown = Traits::iconMustBeShown(input);
  }

  static bool Deserialize(::blink::mojom::internal::PaymentCredentialInstrument_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PaymentCredentialInstrumentDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::RemoteDesktopClientOverrideDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::RemoteDesktopClientOverrideDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::RemoteDesktopClientOverride_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::origin(input)) in_origin = Traits::origin(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->origin)::BaseType> origin_fragment(
            fragment.message());
    mojo::internal::Serialize<::url::mojom::OriginDataView>(
        in_origin, origin_fragment);
    fragment->origin.Set(
        origin_fragment.is_null() ? nullptr : origin_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->origin.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null origin in RemoteDesktopClientOverride struct");
    fragment->same_origin_with_ancestors = Traits::same_origin_with_ancestors(input);
  }

  static bool Deserialize(::blink::mojom::internal::RemoteDesktopClientOverride_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::RemoteDesktopClientOverrideDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialRequestOptionsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PublicKeyCredentialRequestOptionsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PublicKeyCredentialRequestOptions_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->is_conditional = Traits::is_conditional(input);
    decltype(Traits::challenge(input)) in_challenge = Traits::challenge(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->challenge)::BaseType>
        challenge_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams challenge_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_challenge, challenge_fragment, &challenge_validate_params);
    fragment->challenge.Set(
        challenge_fragment.is_null() ? nullptr : challenge_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->challenge.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null challenge in PublicKeyCredentialRequestOptions struct");
    decltype(Traits::timeout(input)) in_timeout = Traits::timeout(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timeout)::BaseType> timeout_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timeout, timeout_fragment);
    fragment->timeout.Set(
        timeout_fragment.is_null() ? nullptr : timeout_fragment.data());
    decltype(Traits::relying_party_id(input)) in_relying_party_id = Traits::relying_party_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->relying_party_id)::BaseType> relying_party_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_relying_party_id, relying_party_id_fragment);
    fragment->relying_party_id.Set(
        relying_party_id_fragment.is_null() ? nullptr : relying_party_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->relying_party_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null relying_party_id in PublicKeyCredentialRequestOptions struct");
    decltype(Traits::allow_credentials(input)) in_allow_credentials = Traits::allow_credentials(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->allow_credentials)::BaseType>
        allow_credentials_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams allow_credentials_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::PublicKeyCredentialDescriptorDataView>>(
        in_allow_credentials, allow_credentials_fragment, &allow_credentials_validate_params);
    fragment->allow_credentials.Set(
        allow_credentials_fragment.is_null() ? nullptr : allow_credentials_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->allow_credentials.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null allow_credentials in PublicKeyCredentialRequestOptions struct");
    mojo::internal::Serialize<::blink::mojom::UserVerificationRequirement>(
        Traits::user_verification(input), &fragment->user_verification);
    decltype(Traits::appid(input)) in_appid = Traits::appid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->appid)::BaseType> appid_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_appid, appid_fragment);
    fragment->appid.Set(
        appid_fragment.is_null() ? nullptr : appid_fragment.data());
    decltype(Traits::cable_authentication_data(input)) in_cable_authentication_data = Traits::cable_authentication_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cable_authentication_data)::BaseType>
        cable_authentication_data_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams cable_authentication_data_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::CableAuthenticationDataView>>(
        in_cable_authentication_data, cable_authentication_data_fragment, &cable_authentication_data_validate_params);
    fragment->cable_authentication_data.Set(
        cable_authentication_data_fragment.is_null() ? nullptr : cable_authentication_data_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->cable_authentication_data.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null cable_authentication_data in PublicKeyCredentialRequestOptions struct");
    fragment->user_verification_methods = Traits::user_verification_methods(input);
    fragment->prf = Traits::prf(input);
    decltype(Traits::prf_inputs(input)) in_prf_inputs = Traits::prf_inputs(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->prf_inputs)::BaseType>
        prf_inputs_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams prf_inputs_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::PRFValuesDataView>>(
        in_prf_inputs, prf_inputs_fragment, &prf_inputs_validate_params);
    fragment->prf_inputs.Set(
        prf_inputs_fragment.is_null() ? nullptr : prf_inputs_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->prf_inputs.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null prf_inputs in PublicKeyCredentialRequestOptions struct");
    fragment->large_blob_read = Traits::large_blob_read(input);
    decltype(Traits::large_blob_write(input)) in_large_blob_write = Traits::large_blob_write(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->large_blob_write)::BaseType>
        large_blob_write_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams large_blob_write_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_large_blob_write, large_blob_write_fragment, &large_blob_write_validate_params);
    fragment->large_blob_write.Set(
        large_blob_write_fragment.is_null() ? nullptr : large_blob_write_fragment.data());
    fragment->get_cred_blob = Traits::get_cred_blob(input);
    decltype(Traits::remote_desktop_client_override(input)) in_remote_desktop_client_override = Traits::remote_desktop_client_override(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->remote_desktop_client_override)::BaseType> remote_desktop_client_override_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::RemoteDesktopClientOverrideDataView>(
        in_remote_desktop_client_override, remote_desktop_client_override_fragment);
    fragment->remote_desktop_client_override.Set(
        remote_desktop_client_override_fragment.is_null() ? nullptr : remote_desktop_client_override_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::PublicKeyCredentialRequestOptions_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PublicKeyCredentialRequestOptionsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::AuthenticatorSelectionCriteriaDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::AuthenticatorSelectionCriteriaDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::AuthenticatorSelectionCriteria_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::AuthenticatorAttachment>(
        Traits::authenticator_attachment(input), &fragment->authenticator_attachment);
    mojo::internal::Serialize<::blink::mojom::ResidentKeyRequirement>(
        Traits::resident_key(input), &fragment->resident_key);
    mojo::internal::Serialize<::blink::mojom::UserVerificationRequirement>(
        Traits::user_verification(input), &fragment->user_verification);
  }

  static bool Deserialize(::blink::mojom::internal::AuthenticatorSelectionCriteria_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::AuthenticatorSelectionCriteriaDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialCreationOptionsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PublicKeyCredentialCreationOptionsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PublicKeyCredentialCreationOptions_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::relying_party(input)) in_relying_party = Traits::relying_party(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->relying_party)::BaseType> relying_party_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PublicKeyCredentialRpEntityDataView>(
        in_relying_party, relying_party_fragment);
    fragment->relying_party.Set(
        relying_party_fragment.is_null() ? nullptr : relying_party_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->relying_party.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null relying_party in PublicKeyCredentialCreationOptions struct");
    decltype(Traits::user(input)) in_user = Traits::user(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user)::BaseType> user_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::PublicKeyCredentialUserEntityDataView>(
        in_user, user_fragment);
    fragment->user.Set(
        user_fragment.is_null() ? nullptr : user_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->user.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null user in PublicKeyCredentialCreationOptions struct");
    decltype(Traits::challenge(input)) in_challenge = Traits::challenge(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->challenge)::BaseType>
        challenge_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams challenge_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_challenge, challenge_fragment, &challenge_validate_params);
    fragment->challenge.Set(
        challenge_fragment.is_null() ? nullptr : challenge_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->challenge.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null challenge in PublicKeyCredentialCreationOptions struct");
    decltype(Traits::public_key_parameters(input)) in_public_key_parameters = Traits::public_key_parameters(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->public_key_parameters)::BaseType>
        public_key_parameters_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams public_key_parameters_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::PublicKeyCredentialParametersDataView>>(
        in_public_key_parameters, public_key_parameters_fragment, &public_key_parameters_validate_params);
    fragment->public_key_parameters.Set(
        public_key_parameters_fragment.is_null() ? nullptr : public_key_parameters_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->public_key_parameters.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null public_key_parameters in PublicKeyCredentialCreationOptions struct");
    decltype(Traits::timeout(input)) in_timeout = Traits::timeout(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->timeout)::BaseType> timeout_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_timeout, timeout_fragment);
    fragment->timeout.Set(
        timeout_fragment.is_null() ? nullptr : timeout_fragment.data());
    decltype(Traits::exclude_credentials(input)) in_exclude_credentials = Traits::exclude_credentials(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->exclude_credentials)::BaseType>
        exclude_credentials_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams exclude_credentials_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::PublicKeyCredentialDescriptorDataView>>(
        in_exclude_credentials, exclude_credentials_fragment, &exclude_credentials_validate_params);
    fragment->exclude_credentials.Set(
        exclude_credentials_fragment.is_null() ? nullptr : exclude_credentials_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->exclude_credentials.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null exclude_credentials in PublicKeyCredentialCreationOptions struct");
    decltype(Traits::authenticator_selection(input)) in_authenticator_selection = Traits::authenticator_selection(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->authenticator_selection)::BaseType> authenticator_selection_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::AuthenticatorSelectionCriteriaDataView>(
        in_authenticator_selection, authenticator_selection_fragment);
    fragment->authenticator_selection.Set(
        authenticator_selection_fragment.is_null() ? nullptr : authenticator_selection_fragment.data());
    mojo::internal::Serialize<::blink::mojom::AttestationConveyancePreference>(
        Traits::attestation(input), &fragment->attestation);
    decltype(Traits::cable_registration_data(input)) in_cable_registration_data = Traits::cable_registration_data(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cable_registration_data)::BaseType> cable_registration_data_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::CableRegistrationDataView>(
        in_cable_registration_data, cable_registration_data_fragment);
    fragment->cable_registration_data.Set(
        cable_registration_data_fragment.is_null() ? nullptr : cable_registration_data_fragment.data());
    fragment->hmac_create_secret = Traits::hmac_create_secret(input);
    fragment->prf_enable = Traits::prf_enable(input);
    mojo::internal::Serialize<::blink::mojom::ProtectionPolicy>(
        Traits::protection_policy(input), &fragment->protection_policy);
    fragment->enforce_protection_policy = Traits::enforce_protection_policy(input);
    decltype(Traits::appid_exclude(input)) in_appid_exclude = Traits::appid_exclude(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->appid_exclude)::BaseType> appid_exclude_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_appid_exclude, appid_exclude_fragment);
    fragment->appid_exclude.Set(
        appid_exclude_fragment.is_null() ? nullptr : appid_exclude_fragment.data());
    fragment->cred_props = Traits::cred_props(input);
    mojo::internal::Serialize<::blink::mojom::LargeBlobSupport>(
        Traits::large_blob_enable(input), &fragment->large_blob_enable);
    fragment->is_payment_credential_creation = Traits::is_payment_credential_creation(input);
    decltype(Traits::cred_blob(input)) in_cred_blob = Traits::cred_blob(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->cred_blob)::BaseType>
        cred_blob_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams cred_blob_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_cred_blob, cred_blob_fragment, &cred_blob_validate_params);
    fragment->cred_blob.Set(
        cred_blob_fragment.is_null() ? nullptr : cred_blob_fragment.data());
    fragment->google_legacy_app_id_support = Traits::google_legacy_app_id_support(input);
    fragment->min_pin_length_requested = Traits::min_pin_length_requested(input);
    decltype(Traits::remote_desktop_client_override(input)) in_remote_desktop_client_override = Traits::remote_desktop_client_override(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->remote_desktop_client_override)::BaseType> remote_desktop_client_override_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::RemoteDesktopClientOverrideDataView>(
        in_remote_desktop_client_override, remote_desktop_client_override_fragment);
    fragment->remote_desktop_client_override.Set(
        remote_desktop_client_override_fragment.is_null() ? nullptr : remote_desktop_client_override_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::PublicKeyCredentialCreationOptions_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PublicKeyCredentialCreationOptionsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::PublicKeyCredentialDescriptorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::PublicKeyCredentialDescriptorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::PublicKeyCredentialDescriptor_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::PublicKeyCredentialType>(
        Traits::type(input), &fragment->type);
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType>
        id_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams id_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_id, id_fragment, &id_validate_params);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in PublicKeyCredentialDescriptor struct");
    decltype(Traits::transports(input)) in_transports = Traits::transports(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->transports)::BaseType>
        transports_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams transports_validate_params(
        0, ::blink::mojom::internal::AuthenticatorTransport_Data::Validate);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::AuthenticatorTransport>>(
        in_transports, transports_fragment, &transports_validate_params);
    fragment->transports.Set(
        transports_fragment.is_null() ? nullptr : transports_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->transports.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null transports in PublicKeyCredentialDescriptor struct");
  }

  static bool Deserialize(::blink::mojom::internal::PublicKeyCredentialDescriptor_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::PublicKeyCredentialDescriptorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::WebAuthnDOMExceptionDetailsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::WebAuthnDOMExceptionDetailsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::WebAuthnDOMExceptionDetails_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in WebAuthnDOMExceptionDetails struct");
    decltype(Traits::message(input)) in_message = Traits::message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->message)::BaseType> message_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_message, message_fragment);
    fragment->message.Set(
        message_fragment.is_null() ? nullptr : message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null message in WebAuthnDOMExceptionDetails struct");
  }

  static bool Deserialize(::blink::mojom::internal::WebAuthnDOMExceptionDetails_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::WebAuthnDOMExceptionDetailsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void CommonCredentialInfoDataView::GetIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void CommonCredentialInfoDataView::GetRawIdDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->raw_id.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CommonCredentialInfoDataView::GetClientDataJsonDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->client_data_json.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CommonCredentialInfoDataView::GetAuthenticatorDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->authenticator_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}




inline void MakeCredentialAuthenticatorResponseDataView::GetInfoDataView(
    CommonCredentialInfoDataView* output) {
  auto pointer = data_->info.Get();
  *output = CommonCredentialInfoDataView(pointer, message_);
}
inline void MakeCredentialAuthenticatorResponseDataView::GetAttestationObjectDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->attestation_object.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void MakeCredentialAuthenticatorResponseDataView::GetTransportsDataView(
    mojo::ArrayDataView<AuthenticatorTransport>* output) {
  auto pointer = data_->transports.Get();
  *output = mojo::ArrayDataView<AuthenticatorTransport>(pointer, message_);
}
inline void MakeCredentialAuthenticatorResponseDataView::GetPublicKeyDerDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->public_key_der.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void GetAssertionAuthenticatorResponseDataView::GetInfoDataView(
    CommonCredentialInfoDataView* output) {
  auto pointer = data_->info.Get();
  *output = CommonCredentialInfoDataView(pointer, message_);
}
inline void GetAssertionAuthenticatorResponseDataView::GetSignatureDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->signature.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void GetAssertionAuthenticatorResponseDataView::GetUserHandleDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->user_handle.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void GetAssertionAuthenticatorResponseDataView::GetUserVerificationMethodsDataView(
    mojo::ArrayDataView<UvmEntryDataView>* output) {
  auto pointer = data_->user_verification_methods.Get();
  *output = mojo::ArrayDataView<UvmEntryDataView>(pointer, message_);
}
inline void GetAssertionAuthenticatorResponseDataView::GetPrfResultsDataView(
    PRFValuesDataView* output) {
  auto pointer = data_->prf_results.Get();
  *output = PRFValuesDataView(pointer, message_);
}
inline void GetAssertionAuthenticatorResponseDataView::GetLargeBlobDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->large_blob.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void GetAssertionAuthenticatorResponseDataView::GetGetCredBlobDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->get_cred_blob.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void PublicKeyCredentialRpEntityDataView::GetIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PublicKeyCredentialRpEntityDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PublicKeyCredentialRpEntityDataView::GetIconDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->icon.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}


inline void PublicKeyCredentialUserEntityDataView::GetIdDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->id.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PublicKeyCredentialUserEntityDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PublicKeyCredentialUserEntityDataView::GetIconDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->icon.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}
inline void PublicKeyCredentialUserEntityDataView::GetDisplayNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->display_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}




inline void CableAuthenticationDataView::GetClientEidDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->client_eid.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CableAuthenticationDataView::GetAuthenticatorEidDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->authenticator_eid.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CableAuthenticationDataView::GetSessionPreKeyDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->session_pre_key.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CableAuthenticationDataView::GetServerLinkDataDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->server_link_data.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CableAuthenticationDataView::GetExperimentsDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->experiments.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void CableRegistrationDataView::GetVersionsDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->versions.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void CableRegistrationDataView::GetRelyingPartyPublicKeyDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->relying_party_public_key.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void PRFValuesDataView::GetIdDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->id.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PRFValuesDataView::GetFirstDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->first.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PRFValuesDataView::GetSecondDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->second.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}


inline void PaymentOptionsDataView::GetTotalDataView(
    ::payments::mojom::PaymentCurrencyAmountDataView* output) {
  auto pointer = data_->total.Get();
  *output = ::payments::mojom::PaymentCurrencyAmountDataView(pointer, message_);
}
inline void PaymentOptionsDataView::GetInstrumentDataView(
    PaymentCredentialInstrumentDataView* output) {
  auto pointer = data_->instrument.Get();
  *output = PaymentCredentialInstrumentDataView(pointer, message_);
}
inline void PaymentOptionsDataView::GetPayeeNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->payee_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PaymentOptionsDataView::GetPayeeOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->payee_origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}


inline void PaymentCredentialInstrumentDataView::GetDisplayNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->display_name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PaymentCredentialInstrumentDataView::GetIconDataView(
    ::url::mojom::UrlDataView* output) {
  auto pointer = data_->icon.Get();
  *output = ::url::mojom::UrlDataView(pointer, message_);
}


inline void RemoteDesktopClientOverrideDataView::GetOriginDataView(
    ::url::mojom::OriginDataView* output) {
  auto pointer = data_->origin.Get();
  *output = ::url::mojom::OriginDataView(pointer, message_);
}


inline void PublicKeyCredentialRequestOptionsDataView::GetChallengeDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->challenge.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetTimeoutDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timeout.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetRelyingPartyIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->relying_party_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetAllowCredentialsDataView(
    mojo::ArrayDataView<PublicKeyCredentialDescriptorDataView>* output) {
  auto pointer = data_->allow_credentials.Get();
  *output = mojo::ArrayDataView<PublicKeyCredentialDescriptorDataView>(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetAppidDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->appid.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetCableAuthenticationDataDataView(
    mojo::ArrayDataView<CableAuthenticationDataView>* output) {
  auto pointer = data_->cable_authentication_data.Get();
  *output = mojo::ArrayDataView<CableAuthenticationDataView>(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetPrfInputsDataView(
    mojo::ArrayDataView<PRFValuesDataView>* output) {
  auto pointer = data_->prf_inputs.Get();
  *output = mojo::ArrayDataView<PRFValuesDataView>(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetLargeBlobWriteDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->large_blob_write.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PublicKeyCredentialRequestOptionsDataView::GetRemoteDesktopClientOverrideDataView(
    RemoteDesktopClientOverrideDataView* output) {
  auto pointer = data_->remote_desktop_client_override.Get();
  *output = RemoteDesktopClientOverrideDataView(pointer, message_);
}




inline void PublicKeyCredentialCreationOptionsDataView::GetRelyingPartyDataView(
    PublicKeyCredentialRpEntityDataView* output) {
  auto pointer = data_->relying_party.Get();
  *output = PublicKeyCredentialRpEntityDataView(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetUserDataView(
    PublicKeyCredentialUserEntityDataView* output) {
  auto pointer = data_->user.Get();
  *output = PublicKeyCredentialUserEntityDataView(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetChallengeDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->challenge.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetPublicKeyParametersDataView(
    mojo::ArrayDataView<PublicKeyCredentialParametersDataView>* output) {
  auto pointer = data_->public_key_parameters.Get();
  *output = mojo::ArrayDataView<PublicKeyCredentialParametersDataView>(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetTimeoutDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->timeout.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetExcludeCredentialsDataView(
    mojo::ArrayDataView<PublicKeyCredentialDescriptorDataView>* output) {
  auto pointer = data_->exclude_credentials.Get();
  *output = mojo::ArrayDataView<PublicKeyCredentialDescriptorDataView>(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetAuthenticatorSelectionDataView(
    AuthenticatorSelectionCriteriaDataView* output) {
  auto pointer = data_->authenticator_selection.Get();
  *output = AuthenticatorSelectionCriteriaDataView(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetCableRegistrationDataDataView(
    CableRegistrationDataView* output) {
  auto pointer = data_->cable_registration_data.Get();
  *output = CableRegistrationDataView(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetAppidExcludeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->appid_exclude.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetCredBlobDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->cred_blob.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PublicKeyCredentialCreationOptionsDataView::GetRemoteDesktopClientOverrideDataView(
    RemoteDesktopClientOverrideDataView* output) {
  auto pointer = data_->remote_desktop_client_override.Get();
  *output = RemoteDesktopClientOverrideDataView(pointer, message_);
}


inline void PublicKeyCredentialDescriptorDataView::GetIdDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->id.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void PublicKeyCredentialDescriptorDataView::GetTransportsDataView(
    mojo::ArrayDataView<AuthenticatorTransport>* output) {
  auto pointer = data_->transports.Get();
  *output = mojo::ArrayDataView<AuthenticatorTransport>(pointer, message_);
}


inline void WebAuthnDOMExceptionDetailsDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void WebAuthnDOMExceptionDetailsDataView::GetMessageDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->message.Get();
  *output = mojo::StringDataView(pointer, message_);
}



}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AuthenticatorStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AuthenticatorStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AuthenticatorTransport> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AuthenticatorTransport value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::UserVerificationRequirement> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::UserVerificationRequirement value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AttestationConveyancePreference> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AttestationConveyancePreference value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::ResidentKeyRequirement> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::ResidentKeyRequirement value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::AuthenticatorAttachment> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::AuthenticatorAttachment value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::ProtectionPolicy> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::ProtectionPolicy value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::LargeBlobSupport> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::LargeBlobSupport value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::PublicKeyCredentialType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::PublicKeyCredentialType value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_WEBAUTHN_AUTHENTICATOR_MOJOM_SHARED_H_