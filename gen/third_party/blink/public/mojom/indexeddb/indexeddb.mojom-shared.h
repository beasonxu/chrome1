// third_party/blink/public/mojom/indexeddb/indexeddb.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_INDEXEDDB_INDEXEDDB_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_INDEXEDDB_INDEXEDDB_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/indexeddb/indexeddb.mojom-shared-internal.h"
#include "mojo/public/mojom/base/string16.mojom-shared.h"
#include "mojo/public/mojom/base/string16.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "third_party/blink/public/mojom/blob/blob.mojom-shared.h"
#include "third_party/blink/public/mojom/file_system_access/file_system_access_transfer_token.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "base/component_export.h"




namespace blink {
namespace mojom {
class IDBKeyPathDataView;

class IDBKeyRangeDataView;

class IDBIndexMetadataDataView;

class IDBObjectStoreMetadataDataView;

class IDBDatabaseMetadataDataView;

class IDBNameAndVersionDataView;

class IDBIndexKeysDataView;

class IDBFileInfoDataView;

class IDBBlobInfoDataView;

class IDBValueDataView;

class IDBReturnValueDataView;

class IDBErrorDataView;

class IDBCursorValueDataView;

class IDBDatabaseOpenCursorValueDataView;

class IDBKeyDataView;
class IDBKeyPathDataDataView;
class IDBExternalObjectDataView;
class IDBCursorResultDataView;
class IDBTransactionPutResultDataView;
class IDBDatabaseGetResultDataView;
class IDBDatabaseBatchGetAllResultDataView;
class IDBDatabaseOpenCursorResultDataView;


}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::IDBKeyPathDataView> {
  using Data = ::blink::mojom::internal::IDBKeyPath_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBKeyRangeDataView> {
  using Data = ::blink::mojom::internal::IDBKeyRange_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBIndexMetadataDataView> {
  using Data = ::blink::mojom::internal::IDBIndexMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBObjectStoreMetadataDataView> {
  using Data = ::blink::mojom::internal::IDBObjectStoreMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBDatabaseMetadataDataView> {
  using Data = ::blink::mojom::internal::IDBDatabaseMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBNameAndVersionDataView> {
  using Data = ::blink::mojom::internal::IDBNameAndVersion_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBIndexKeysDataView> {
  using Data = ::blink::mojom::internal::IDBIndexKeys_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBFileInfoDataView> {
  using Data = ::blink::mojom::internal::IDBFileInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBBlobInfoDataView> {
  using Data = ::blink::mojom::internal::IDBBlobInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBValueDataView> {
  using Data = ::blink::mojom::internal::IDBValue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBReturnValueDataView> {
  using Data = ::blink::mojom::internal::IDBReturnValue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBErrorDataView> {
  using Data = ::blink::mojom::internal::IDBError_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBCursorValueDataView> {
  using Data = ::blink::mojom::internal::IDBCursorValue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBDatabaseOpenCursorValueDataView> {
  using Data = ::blink::mojom::internal::IDBDatabaseOpenCursorValue_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBKeyDataView> {
  using Data = ::blink::mojom::internal::IDBKey_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBKeyPathDataDataView> {
  using Data = ::blink::mojom::internal::IDBKeyPathData_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBExternalObjectDataView> {
  using Data = ::blink::mojom::internal::IDBExternalObject_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBCursorResultDataView> {
  using Data = ::blink::mojom::internal::IDBCursorResult_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBTransactionPutResultDataView> {
  using Data = ::blink::mojom::internal::IDBTransactionPutResult_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBDatabaseGetResultDataView> {
  using Data = ::blink::mojom::internal::IDBDatabaseGetResult_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBDatabaseBatchGetAllResultDataView> {
  using Data = ::blink::mojom::internal::IDBDatabaseBatchGetAllResult_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::blink::mojom::IDBDatabaseOpenCursorResultDataView> {
  using Data = ::blink::mojom::internal::IDBDatabaseOpenCursorResult_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class IDBCursorDirection : int32_t {
  
  Next = 0,
  
  NextNoDuplicate = 1,
  
  Prev = 2,
  
  PrevNoDuplicate = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBCursorDirection value);
inline bool IsKnownEnumValue(IDBCursorDirection value) {
  return internal::IDBCursorDirection_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBDataLoss : int32_t {
  
  None = 0,
  
  Total = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBDataLoss value);
inline bool IsKnownEnumValue(IDBDataLoss value) {
  return internal::IDBDataLoss_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBKeyType : int32_t {
  
  Invalid = 0,
  
  Array = 1,
  
  Binary = 2,
  
  String = 3,
  
  Date = 4,
  
  Number = 5,
  
  None = 6,
  
  Min = 7,
  kMinValue = 0,
  kMaxValue = 7,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBKeyType value);
inline bool IsKnownEnumValue(IDBKeyType value) {
  return internal::IDBKeyType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBTransactionDurability : int32_t {
  
  Default = 0,
  
  Strict = 1,
  
  Relaxed = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBTransactionDurability value);
inline bool IsKnownEnumValue(IDBTransactionDurability value) {
  return internal::IDBTransactionDurability_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBKeyPathType : int32_t {
  
  Null = 0,
  
  String = 1,
  
  Array = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBKeyPathType value);
inline bool IsKnownEnumValue(IDBKeyPathType value) {
  return internal::IDBKeyPathType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBOperationType : int32_t {
  
  Add = 0,
  
  Put = 1,
  
  Delete = 2,
  
  Clear = 3,
  kMinValue = 0,
  kMaxValue = 3,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBOperationType value);
inline bool IsKnownEnumValue(IDBOperationType value) {
  return internal::IDBOperationType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBPutMode : int32_t {
  
  AddOrUpdate = 0,
  
  AddOnly = 1,
  
  CursorUpdate = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBPutMode value);
inline bool IsKnownEnumValue(IDBPutMode value) {
  return internal::IDBPutMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBTaskType : int32_t {
  
  Normal = 0,
  
  Preemptive = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBTaskType value);
inline bool IsKnownEnumValue(IDBTaskType value) {
  return internal::IDBTaskType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBTransactionMode : int32_t {
  
  ReadOnly = 0,
  
  ReadWrite = 1,
  
  VersionChange = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBTransactionMode value);
inline bool IsKnownEnumValue(IDBTransactionMode value) {
  return internal::IDBTransactionMode_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBStatus : int32_t {
  
  OK = 0,
  
  NotFound = 1,
  
  Corruption = 2,
  
  NotSupported = 3,
  
  InvalidArgument = 4,
  
  IOError = 5,
  kMinValue = 0,
  kMaxValue = 5,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBStatus value);
inline bool IsKnownEnumValue(IDBStatus value) {
  return internal::IDBStatus_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class IDBException : int32_t {
  
  kNoError = 0,
  
  kUnknownError = 28,
  
  kConstraintError = 29,
  
  kDataError = 30,
  
  kVersionError = 33,
  
  kAbortError = 20,
  
  kIgnorableAbortError = 11,
  
  kQuotaError = 22,
  
  kTimeoutError = 23,
  kMinValue = 0,
  kMaxValue = 33,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, IDBException value);
inline bool IsKnownEnumValue(IDBException value) {
  return internal::IDBException_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class IDBCallbacksInterfaceBase {};

using IDBCallbacksPtrDataView =
    mojo::InterfacePtrDataView<IDBCallbacksInterfaceBase>;
using IDBCallbacksRequestDataView =
    mojo::InterfaceRequestDataView<IDBCallbacksInterfaceBase>;
using IDBCallbacksAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBCallbacksInterfaceBase>;
using IDBCallbacksAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBCallbacksInterfaceBase>;
class IDBDatabaseCallbacksInterfaceBase {};

using IDBDatabaseCallbacksPtrDataView =
    mojo::InterfacePtrDataView<IDBDatabaseCallbacksInterfaceBase>;
using IDBDatabaseCallbacksRequestDataView =
    mojo::InterfaceRequestDataView<IDBDatabaseCallbacksInterfaceBase>;
using IDBDatabaseCallbacksAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBDatabaseCallbacksInterfaceBase>;
using IDBDatabaseCallbacksAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBDatabaseCallbacksInterfaceBase>;
class IDBCursorInterfaceBase {};

using IDBCursorPtrDataView =
    mojo::InterfacePtrDataView<IDBCursorInterfaceBase>;
using IDBCursorRequestDataView =
    mojo::InterfaceRequestDataView<IDBCursorInterfaceBase>;
using IDBCursorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBCursorInterfaceBase>;
using IDBCursorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBCursorInterfaceBase>;
class IDBTransactionInterfaceBase {};

using IDBTransactionPtrDataView =
    mojo::InterfacePtrDataView<IDBTransactionInterfaceBase>;
using IDBTransactionRequestDataView =
    mojo::InterfaceRequestDataView<IDBTransactionInterfaceBase>;
using IDBTransactionAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBTransactionInterfaceBase>;
using IDBTransactionAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBTransactionInterfaceBase>;
class IDBDatabaseGetAllResultSinkInterfaceBase {};

using IDBDatabaseGetAllResultSinkPtrDataView =
    mojo::InterfacePtrDataView<IDBDatabaseGetAllResultSinkInterfaceBase>;
using IDBDatabaseGetAllResultSinkRequestDataView =
    mojo::InterfaceRequestDataView<IDBDatabaseGetAllResultSinkInterfaceBase>;
using IDBDatabaseGetAllResultSinkAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBDatabaseGetAllResultSinkInterfaceBase>;
using IDBDatabaseGetAllResultSinkAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBDatabaseGetAllResultSinkInterfaceBase>;
class IDBDatabaseInterfaceBase {};

using IDBDatabasePtrDataView =
    mojo::InterfacePtrDataView<IDBDatabaseInterfaceBase>;
using IDBDatabaseRequestDataView =
    mojo::InterfaceRequestDataView<IDBDatabaseInterfaceBase>;
using IDBDatabaseAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBDatabaseInterfaceBase>;
using IDBDatabaseAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBDatabaseInterfaceBase>;
class IDBFactoryInterfaceBase {};

using IDBFactoryPtrDataView =
    mojo::InterfacePtrDataView<IDBFactoryInterfaceBase>;
using IDBFactoryRequestDataView =
    mojo::InterfaceRequestDataView<IDBFactoryInterfaceBase>;
using IDBFactoryAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<IDBFactoryInterfaceBase>;
using IDBFactoryAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<IDBFactoryInterfaceBase>;


class IDBKeyPathDataView {
 public:
  IDBKeyPathDataView() = default;

  IDBKeyPathDataView(
      internal::IDBKeyPath_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDataDataView(
      IDBKeyPathDataDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadData(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::IDBKeyPathDataDataView, UserType>(),
    "Attempting to read the optional `data` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadData` instead "
    "of `ReadData if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = !data_->data.is_null() ? &data_->data : nullptr;
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyPathDataDataView>(
        pointer, output, message_);
  }
 private:
  internal::IDBKeyPath_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBKeyRangeDataView {
 public:
  IDBKeyRangeDataView() = default;

  IDBKeyRangeDataView(
      internal::IDBKeyRange_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetLowerDataView(
      IDBKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLower(UserType* output) {
    
    auto* pointer = !data_->lower.is_null() ? &data_->lower : nullptr;
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        pointer, output, message_);
  }
  inline void GetUpperDataView(
      IDBKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUpper(UserType* output) {
    
    auto* pointer = !data_->upper.is_null() ? &data_->upper : nullptr;
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        pointer, output, message_);
  }
  bool lower_open() const {
    return data_->lower_open;
  }
  bool upper_open() const {
    return data_->upper_open;
  }
 private:
  internal::IDBKeyRange_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBIndexMetadataDataView {
 public:
  IDBIndexMetadataDataView() = default;

  IDBIndexMetadataDataView(
      internal::IDBIndexMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int64_t id() const {
    return data_->id;
  }
  inline void GetNameDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  inline void GetKeyPathDataView(
      IDBKeyPathDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyPath(UserType* output) {
    
    auto* pointer = data_->key_path.Get();
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyPathDataView>(
        pointer, output, message_);
  }
  bool unique() const {
    return data_->unique;
  }
  bool multi_entry() const {
    return data_->multi_entry;
  }
 private:
  internal::IDBIndexMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBObjectStoreMetadataDataView {
 public:
  IDBObjectStoreMetadataDataView() = default;

  IDBObjectStoreMetadataDataView(
      internal::IDBObjectStoreMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int64_t id() const {
    return data_->id;
  }
  inline void GetNameDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  inline void GetKeyPathDataView(
      IDBKeyPathDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyPath(UserType* output) {
    
    auto* pointer = data_->key_path.Get();
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyPathDataView>(
        pointer, output, message_);
  }
  bool auto_increment() const {
    return data_->auto_increment;
  }
  int64_t max_index_id() const {
    return data_->max_index_id;
  }
  inline void GetIndexesDataView(
      mojo::MapDataView<int64_t, IDBIndexMetadataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIndexes(UserType* output) {
    
    auto* pointer = data_->indexes.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<int64_t, ::blink::mojom::IDBIndexMetadataDataView>>(
        pointer, output, message_);
  }
 private:
  internal::IDBObjectStoreMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBDatabaseMetadataDataView {
 public:
  IDBDatabaseMetadataDataView() = default;

  IDBDatabaseMetadataDataView(
      internal::IDBDatabaseMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int64_t id() const {
    return data_->id;
  }
  inline void GetNameDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  int64_t version() const {
    return data_->version;
  }
  int64_t max_object_store_id() const {
    return data_->max_object_store_id;
  }
  inline void GetObjectStoresDataView(
      mojo::MapDataView<int64_t, IDBObjectStoreMetadataDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadObjectStores(UserType* output) {
    
    auto* pointer = data_->object_stores.Get();
    return mojo::internal::Deserialize<mojo::MapDataView<int64_t, ::blink::mojom::IDBObjectStoreMetadataDataView>>(
        pointer, output, message_);
  }
  bool was_cold_open() const {
    return data_->was_cold_open;
  }
 private:
  internal::IDBDatabaseMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBNameAndVersionDataView {
 public:
  IDBNameAndVersionDataView() = default;

  IDBNameAndVersionDataView(
      internal::IDBNameAndVersion_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNameDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  int64_t version() const {
    return data_->version;
  }
 private:
  internal::IDBNameAndVersion_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBIndexKeysDataView {
 public:
  IDBIndexKeysDataView() = default;

  IDBIndexKeysDataView(
      internal::IDBIndexKeys_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int64_t index_id() const {
    return data_->index_id;
  }
  inline void GetIndexKeysDataView(
      mojo::ArrayDataView<IDBKeyDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadIndexKeys(UserType* output) {
    
    auto* pointer = data_->index_keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        pointer, output, message_);
  }
 private:
  internal::IDBIndexKeys_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBFileInfoDataView {
 public:
  IDBFileInfoDataView() = default;

  IDBFileInfoDataView(
      internal::IDBFileInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNameDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  inline void GetLastModifiedDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLastModified(UserType* output) {
    
    auto* pointer = data_->last_modified.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, message_);
  }
 private:
  internal::IDBFileInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBBlobInfoDataView {
 public:
  IDBBlobInfoDataView() = default;

  IDBBlobInfoDataView(
      internal::IDBBlobInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  UserType TakeBlob() {
    UserType result;
    bool ret =
        mojo::internal::Deserialize<mojo::InterfacePtrDataView<::blink::mojom::BlobInterfaceBase>>(
            &data_->blob, &result, message_);
    DCHECK(ret);
    return result;
  }
  inline void GetUuidDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUuid(UserType* output) {
    
    auto* pointer = data_->uuid.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetMimeTypeDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMimeType(UserType* output) {
    
    auto* pointer = data_->mime_type.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
  int64_t size() const {
    return data_->size;
  }
  inline void GetFileDataView(
      IDBFileInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFile(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::IDBFileInfoDataView, UserType>(),
    "Attempting to read the optional `file` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFile` instead "
    "of `ReadFile if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->file.Get();
    return mojo::internal::Deserialize<::blink::mojom::IDBFileInfoDataView>(
        pointer, output, message_);
  }
 private:
  internal::IDBBlobInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBValueDataView {
 public:
  IDBValueDataView() = default;

  IDBValueDataView(
      internal::IDBValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetBitsDataView(
      mojo::ArrayDataView<uint8_t>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBits(UserType* output) {
    
    auto* pointer = data_->bits.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        pointer, output, message_);
  }
  inline void GetExternalObjectsDataView(
      mojo::ArrayDataView<IDBExternalObjectDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExternalObjects(UserType* output) {
    
    auto* pointer = data_->external_objects.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::IDBExternalObjectDataView>>(
        pointer, output, message_);
  }
 private:
  internal::IDBValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBReturnValueDataView {
 public:
  IDBReturnValueDataView() = default;

  IDBReturnValueDataView(
      internal::IDBReturnValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetValueDataView(
      IDBValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
    auto* pointer = data_->value.Get();
    return mojo::internal::Deserialize<::blink::mojom::IDBValueDataView>(
        pointer, output, message_);
  }
  inline void GetPrimaryKeyDataView(
      IDBKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryKey(UserType* output) {
    
    auto* pointer = !data_->primary_key.is_null() ? &data_->primary_key : nullptr;
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        pointer, output, message_);
  }
  inline void GetKeyPathDataView(
      IDBKeyPathDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeyPath(UserType* output) {
    
    auto* pointer = data_->key_path.Get();
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyPathDataView>(
        pointer, output, message_);
  }
 private:
  internal::IDBReturnValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBErrorDataView {
 public:
  IDBErrorDataView() = default;

  IDBErrorDataView(
      internal::IDBError_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadErrorCode(UserType* output) const {
    auto data_value = data_->error_code;
    return mojo::internal::Deserialize<::blink::mojom::IDBException>(
        data_value, output);
  }
  IDBException error_code() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::IDBException>(data_->error_code));
  }
  inline void GetErrorMessageDataView(
      ::mojo_base::mojom::String16DataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadErrorMessage(UserType* output) {
    
    auto* pointer = data_->error_message.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        pointer, output, message_);
  }
 private:
  internal::IDBError_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBCursorValueDataView {
 public:
  IDBCursorValueDataView() = default;

  IDBCursorValueDataView(
      internal::IDBCursorValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetKeysDataView(
      mojo::ArrayDataView<IDBKeyDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKeys(UserType* output) {
    
    auto* pointer = data_->keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        pointer, output, message_);
  }
  inline void GetPrimaryKeysDataView(
      mojo::ArrayDataView<IDBKeyDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryKeys(UserType* output) {
    
    auto* pointer = data_->primary_keys.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        pointer, output, message_);
  }
  inline void GetValuesDataView(
      mojo::ArrayDataView<IDBValueDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValues(UserType* output) {
    
    auto* pointer = data_->values.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::IDBValueDataView>>(
        pointer, output, message_);
  }
 private:
  internal::IDBCursorValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBDatabaseOpenCursorValueDataView {
 public:
  IDBDatabaseOpenCursorValueDataView() = default;

  IDBDatabaseOpenCursorValueDataView(
      internal::IDBDatabaseOpenCursorValue_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  UserType TakeCursor() {
    UserType result;
    bool ret =
        mojo::internal::Deserialize<::blink::mojom::IDBCursorAssociatedPtrInfoDataView>(
            &data_->cursor, &result, message_);
    DCHECK(ret);
    return result;
  }
  inline void GetKeyDataView(
      IDBKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadKey(UserType* output) {
    
    auto* pointer = !data_->key.is_null() ? &data_->key : nullptr;
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        pointer, output, message_);
  }
  inline void GetPrimaryKeyDataView(
      IDBKeyDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPrimaryKey(UserType* output) {
    
    auto* pointer = !data_->primary_key.is_null() ? &data_->primary_key : nullptr;
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        pointer, output, message_);
  }
  inline void GetValueDataView(
      IDBValueDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::IDBValueDataView, UserType>(),
    "Attempting to read the optional `value` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadValue` instead "
    "of `ReadValue if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->value.Get();
    return mojo::internal::Deserialize<::blink::mojom::IDBValueDataView>(
        pointer, output, message_);
  }
 private:
  internal::IDBDatabaseOpenCursorValue_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBKeyDataView {
 public:
  using Tag = internal::IDBKey_Data::IDBKey_Tag;

  IDBKeyDataView() = default;

  IDBKeyDataView(
      internal::IDBKey_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_key_array() const { return data_->tag == Tag::kKeyArray; }
  inline void GetKeyArrayDataView(
      mojo::ArrayDataView<IDBKeyDataView>* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadKeyArray(UserType* output) const {
    
    CHECK(is_key_array());
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        data_->data.f_key_array.Get(), output, message_);
  }
  bool is_binary() const { return data_->tag == Tag::kBinary; }
  inline void GetBinaryDataView(
      mojo::ArrayDataView<uint8_t>* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadBinary(UserType* output) const {
    
    CHECK(is_binary());
    return mojo::internal::Deserialize<mojo::ArrayDataView<uint8_t>>(
        data_->data.f_binary.Get(), output, message_);
  }
  bool is_string() const { return data_->tag == Tag::kString; }
  inline void GetStringDataView(
      ::mojo_base::mojom::String16DataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadString(UserType* output) const {
    
    CHECK(is_string());
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        data_->data.f_string.Get(), output, message_);
  }
  bool is_date() const { return data_->tag == Tag::kDate; }
  double date() const {
    CHECK(is_date());
    return data_->data.f_date;
  }
  bool is_number() const { return data_->tag == Tag::kNumber; }
  double number() const {
    CHECK(is_number());
    return data_->data.f_number;
  }
  bool is_other_none() const { return data_->tag == Tag::kOtherNone; }
  bool other_none() const {
    CHECK(is_other_none());
    return data_->data.f_other_none;
  }

 private:
  internal::IDBKey_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBKeyPathDataDataView {
 public:
  using Tag = internal::IDBKeyPathData_Data::IDBKeyPathData_Tag;

  IDBKeyPathDataDataView() = default;

  IDBKeyPathDataDataView(
      internal::IDBKeyPathData_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_string() const { return data_->tag == Tag::kString; }
  inline void GetStringDataView(
      ::mojo_base::mojom::String16DataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadString(UserType* output) const {
    
    CHECK(is_string());
    return mojo::internal::Deserialize<::mojo_base::mojom::String16DataView>(
        data_->data.f_string.Get(), output, message_);
  }
  bool is_string_array() const { return data_->tag == Tag::kStringArray; }
  inline void GetStringArrayDataView(
      mojo::ArrayDataView<::mojo_base::mojom::String16DataView>* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadStringArray(UserType* output) const {
    
    CHECK(is_string_array());
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::String16DataView>>(
        data_->data.f_string_array.Get(), output, message_);
  }

 private:
  internal::IDBKeyPathData_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBExternalObjectDataView {
 public:
  using Tag = internal::IDBExternalObject_Data::IDBExternalObject_Tag;

  IDBExternalObjectDataView() = default;

  IDBExternalObjectDataView(
      internal::IDBExternalObject_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_blob_or_file() const { return data_->tag == Tag::kBlobOrFile; }
  inline void GetBlobOrFileDataView(
      IDBBlobInfoDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadBlobOrFile(UserType* output) const {
    
    CHECK(is_blob_or_file());
    return mojo::internal::Deserialize<::blink::mojom::IDBBlobInfoDataView>(
        data_->data.f_blob_or_file.Get(), output, message_);
  }
  bool is_file_system_access_token() const { return data_->tag == Tag::kFileSystemAccessToken; }
  template <typename UserType>
  UserType TakeFileSystemAccessToken() {
    CHECK(is_file_system_access_token());
    UserType result;
    bool ret =
        mojo::internal::Deserialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
            &data_->data.f_file_system_access_token, &result, message_);
    CHECK(ret);
    return result;
  }

 private:
  internal::IDBExternalObject_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBCursorResultDataView {
 public:
  using Tag = internal::IDBCursorResult_Data::IDBCursorResult_Tag;

  IDBCursorResultDataView() = default;

  IDBCursorResultDataView(
      internal::IDBCursorResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_error_result() const { return data_->tag == Tag::kErrorResult; }
  inline void GetErrorResultDataView(
      IDBErrorDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadErrorResult(UserType* output) const {
    
    CHECK(is_error_result());
    return mojo::internal::Deserialize<::blink::mojom::IDBErrorDataView>(
        data_->data.f_error_result.Get(), output, message_);
  }
  bool is_empty() const { return data_->tag == Tag::kEmpty; }
  bool empty() const {
    CHECK(is_empty());
    return data_->data.f_empty;
  }
  bool is_values() const { return data_->tag == Tag::kValues; }
  inline void GetValuesDataView(
      IDBCursorValueDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadValues(UserType* output) const {
    
    CHECK(is_values());
    return mojo::internal::Deserialize<::blink::mojom::IDBCursorValueDataView>(
        data_->data.f_values.Get(), output, message_);
  }

 private:
  internal::IDBCursorResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBTransactionPutResultDataView {
 public:
  using Tag = internal::IDBTransactionPutResult_Data::IDBTransactionPutResult_Tag;

  IDBTransactionPutResultDataView() = default;

  IDBTransactionPutResultDataView(
      internal::IDBTransactionPutResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_error_result() const { return data_->tag == Tag::kErrorResult; }
  inline void GetErrorResultDataView(
      IDBErrorDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadErrorResult(UserType* output) const {
    
    CHECK(is_error_result());
    return mojo::internal::Deserialize<::blink::mojom::IDBErrorDataView>(
        data_->data.f_error_result.Get(), output, message_);
  }
  bool is_key() const { return data_->tag == Tag::kKey; }
  inline void GetKeyDataView(
      IDBKeyDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadKey(UserType* output) const {
    
    CHECK(is_key());
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        data_->data.f_key.Get(), output, message_);
  }

 private:
  internal::IDBTransactionPutResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBDatabaseGetResultDataView {
 public:
  using Tag = internal::IDBDatabaseGetResult_Data::IDBDatabaseGetResult_Tag;

  IDBDatabaseGetResultDataView() = default;

  IDBDatabaseGetResultDataView(
      internal::IDBDatabaseGetResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_error_result() const { return data_->tag == Tag::kErrorResult; }
  inline void GetErrorResultDataView(
      IDBErrorDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadErrorResult(UserType* output) const {
    
    CHECK(is_error_result());
    return mojo::internal::Deserialize<::blink::mojom::IDBErrorDataView>(
        data_->data.f_error_result.Get(), output, message_);
  }
  bool is_empty() const { return data_->tag == Tag::kEmpty; }
  bool empty() const {
    CHECK(is_empty());
    return data_->data.f_empty;
  }
  bool is_key() const { return data_->tag == Tag::kKey; }
  inline void GetKeyDataView(
      IDBKeyDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadKey(UserType* output) const {
    
    CHECK(is_key());
    return mojo::internal::Deserialize<::blink::mojom::IDBKeyDataView>(
        data_->data.f_key.Get(), output, message_);
  }
  bool is_value() const { return data_->tag == Tag::kValue; }
  inline void GetValueDataView(
      IDBReturnValueDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) const {
    
    CHECK(is_value());
    return mojo::internal::Deserialize<::blink::mojom::IDBReturnValueDataView>(
        data_->data.f_value.Get(), output, message_);
  }

 private:
  internal::IDBDatabaseGetResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBDatabaseBatchGetAllResultDataView {
 public:
  using Tag = internal::IDBDatabaseBatchGetAllResult_Data::IDBDatabaseBatchGetAllResult_Tag;

  IDBDatabaseBatchGetAllResultDataView() = default;

  IDBDatabaseBatchGetAllResultDataView(
      internal::IDBDatabaseBatchGetAllResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_error_result() const { return data_->tag == Tag::kErrorResult; }
  inline void GetErrorResultDataView(
      IDBErrorDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadErrorResult(UserType* output) const {
    
    CHECK(is_error_result());
    return mojo::internal::Deserialize<::blink::mojom::IDBErrorDataView>(
        data_->data.f_error_result.Get(), output, message_);
  }
  bool is_values() const { return data_->tag == Tag::kValues; }
  inline void GetValuesDataView(
      mojo::ArrayDataView<mojo::ArrayDataView<IDBReturnValueDataView>>* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadValues(UserType* output) const {
    
    CHECK(is_values());
    return mojo::internal::Deserialize<mojo::ArrayDataView<mojo::ArrayDataView<::blink::mojom::IDBReturnValueDataView>>>(
        data_->data.f_values.Get(), output, message_);
  }

 private:
  internal::IDBDatabaseBatchGetAllResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class IDBDatabaseOpenCursorResultDataView {
 public:
  using Tag = internal::IDBDatabaseOpenCursorResult_Data::IDBDatabaseOpenCursorResult_Tag;

  IDBDatabaseOpenCursorResultDataView() = default;

  IDBDatabaseOpenCursorResultDataView(
      internal::IDBDatabaseOpenCursorResult_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_error_result() const { return data_->tag == Tag::kErrorResult; }
  inline void GetErrorResultDataView(
      IDBErrorDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadErrorResult(UserType* output) const {
    
    CHECK(is_error_result());
    return mojo::internal::Deserialize<::blink::mojom::IDBErrorDataView>(
        data_->data.f_error_result.Get(), output, message_);
  }
  bool is_empty() const { return data_->tag == Tag::kEmpty; }
  bool empty() const {
    CHECK(is_empty());
    return data_->data.f_empty;
  }
  bool is_value() const { return data_->tag == Tag::kValue; }
  inline void GetValueDataView(
      IDBDatabaseOpenCursorValueDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadValue(UserType* output) const {
    
    CHECK(is_value());
    return mojo::internal::Deserialize<::blink::mojom::IDBDatabaseOpenCursorValueDataView>(
        data_->data.f_value.Get(), output, message_);
  }

 private:
  internal::IDBDatabaseOpenCursorResult_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::IDBCursorDirection>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBCursorDirection> {};

template <>
struct hash<::blink::mojom::IDBDataLoss>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBDataLoss> {};

template <>
struct hash<::blink::mojom::IDBKeyType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBKeyType> {};

template <>
struct hash<::blink::mojom::IDBTransactionDurability>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBTransactionDurability> {};

template <>
struct hash<::blink::mojom::IDBKeyPathType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBKeyPathType> {};

template <>
struct hash<::blink::mojom::IDBOperationType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBOperationType> {};

template <>
struct hash<::blink::mojom::IDBPutMode>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBPutMode> {};

template <>
struct hash<::blink::mojom::IDBTaskType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBTaskType> {};

template <>
struct hash<::blink::mojom::IDBTransactionMode>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBTransactionMode> {};

template <>
struct hash<::blink::mojom::IDBStatus>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBStatus> {};

template <>
struct hash<::blink::mojom::IDBException>
    : public mojo::internal::EnumHashImpl<::blink::mojom::IDBException> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBCursorDirection, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBCursorDirection, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBCursorDirection>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBDataLoss, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBDataLoss, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBDataLoss>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBKeyType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBKeyType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBKeyType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBTransactionDurability, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBTransactionDurability, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBTransactionDurability>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBKeyPathType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBKeyPathType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBKeyPathType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBOperationType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBOperationType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBOperationType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBPutMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBPutMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBPutMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBTaskType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBTaskType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBTaskType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBTransactionMode, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBTransactionMode, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBTransactionMode>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBStatus, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBStatus, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBStatus>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBException, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::IDBException, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::IDBException>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBKeyPathDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBKeyPathDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBKeyPath_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::data(input)) in_data = Traits::data(input);
    mojo::internal::MessageFragment<decltype(fragment->data)>
        data_fragment(fragment.message());
    data_fragment.Claim(&fragment->data);
    mojo::internal::Serialize<::blink::mojom::IDBKeyPathDataDataView>(
        in_data, data_fragment, true);
  }

  static bool Deserialize(::blink::mojom::internal::IDBKeyPath_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBKeyPathDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBKeyRangeDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBKeyRangeDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBKeyRange_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::lower(input)) in_lower = Traits::lower(input);
    mojo::internal::MessageFragment<decltype(fragment->lower)>
        lower_fragment(fragment.message());
    lower_fragment.Claim(&fragment->lower);
    mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
        in_lower, lower_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->lower.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null lower in IDBKeyRange struct");
    decltype(Traits::upper(input)) in_upper = Traits::upper(input);
    mojo::internal::MessageFragment<decltype(fragment->upper)>
        upper_fragment(fragment.message());
    upper_fragment.Claim(&fragment->upper);
    mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
        in_upper, upper_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->upper.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null upper in IDBKeyRange struct");
    fragment->lower_open = Traits::lower_open(input);
    fragment->upper_open = Traits::upper_open(input);
  }

  static bool Deserialize(::blink::mojom::internal::IDBKeyRange_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBKeyRangeDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBIndexMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBIndexMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBIndexMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->id = Traits::id(input);
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in IDBIndexMetadata struct");
    decltype(Traits::key_path(input)) in_key_path = Traits::key_path(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_path)::BaseType> key_path_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::IDBKeyPathDataView>(
        in_key_path, key_path_fragment);
    fragment->key_path.Set(
        key_path_fragment.is_null() ? nullptr : key_path_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_path.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_path in IDBIndexMetadata struct");
    fragment->unique = Traits::unique(input);
    fragment->multi_entry = Traits::multi_entry(input);
  }

  static bool Deserialize(::blink::mojom::internal::IDBIndexMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBIndexMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBObjectStoreMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBObjectStoreMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBObjectStoreMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->id = Traits::id(input);
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in IDBObjectStoreMetadata struct");
    decltype(Traits::key_path(input)) in_key_path = Traits::key_path(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_path)::BaseType> key_path_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::IDBKeyPathDataView>(
        in_key_path, key_path_fragment);
    fragment->key_path.Set(
        key_path_fragment.is_null() ? nullptr : key_path_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_path.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_path in IDBObjectStoreMetadata struct");
    fragment->auto_increment = Traits::auto_increment(input);
    fragment->max_index_id = Traits::max_index_id(input);
    decltype(Traits::indexes(input)) in_indexes = Traits::indexes(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->indexes)::BaseType>
        indexes_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams indexes_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<int64_t, ::blink::mojom::IDBIndexMetadataDataView>>(
        in_indexes, indexes_fragment, &indexes_validate_params);
    fragment->indexes.Set(
        indexes_fragment.is_null() ? nullptr : indexes_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->indexes.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null indexes in IDBObjectStoreMetadata struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBObjectStoreMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBObjectStoreMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBDatabaseMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBDatabaseMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBDatabaseMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->id = Traits::id(input);
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in IDBDatabaseMetadata struct");
    fragment->version = Traits::version(input);
    fragment->max_object_store_id = Traits::max_object_store_id(input);
    decltype(Traits::object_stores(input)) in_object_stores = Traits::object_stores(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->object_stores)::BaseType>
        object_stores_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams object_stores_validate_params(
        new mojo::internal::ContainerValidateParams(0, false, nullptr), new mojo::internal::ContainerValidateParams(0, false, nullptr));
    mojo::internal::Serialize<mojo::MapDataView<int64_t, ::blink::mojom::IDBObjectStoreMetadataDataView>>(
        in_object_stores, object_stores_fragment, &object_stores_validate_params);
    fragment->object_stores.Set(
        object_stores_fragment.is_null() ? nullptr : object_stores_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->object_stores.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null object_stores in IDBDatabaseMetadata struct");
    fragment->was_cold_open = Traits::was_cold_open(input);
  }

  static bool Deserialize(::blink::mojom::internal::IDBDatabaseMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBDatabaseMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBNameAndVersionDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBNameAndVersionDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBNameAndVersion_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in IDBNameAndVersion struct");
    fragment->version = Traits::version(input);
  }

  static bool Deserialize(::blink::mojom::internal::IDBNameAndVersion_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBNameAndVersionDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBIndexKeysDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBIndexKeysDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBIndexKeys_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->index_id = Traits::index_id(input);
    decltype(Traits::index_keys(input)) in_index_keys = Traits::index_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->index_keys)::BaseType>
        index_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams index_keys_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        in_index_keys, index_keys_fragment, &index_keys_validate_params);
    fragment->index_keys.Set(
        index_keys_fragment.is_null() ? nullptr : index_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->index_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null index_keys in IDBIndexKeys struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBIndexKeys_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBIndexKeysDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBFileInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBFileInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBFileInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in IDBFileInfo struct");
    decltype(Traits::last_modified(input)) in_last_modified = Traits::last_modified(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->last_modified)::BaseType> last_modified_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_last_modified, last_modified_fragment);
    fragment->last_modified.Set(
        last_modified_fragment.is_null() ? nullptr : last_modified_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->last_modified.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null last_modified in IDBFileInfo struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBFileInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBFileInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBBlobInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBBlobInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBBlobInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::blob(input)) in_blob = Traits::blob(input);
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::BlobInterfaceBase>>(
        in_blob, &fragment->blob, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->blob),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid blob in IDBBlobInfo struct");
    decltype(Traits::uuid(input)) in_uuid = Traits::uuid(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->uuid)::BaseType> uuid_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_uuid, uuid_fragment);
    fragment->uuid.Set(
        uuid_fragment.is_null() ? nullptr : uuid_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->uuid.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null uuid in IDBBlobInfo struct");
    decltype(Traits::mime_type(input)) in_mime_type = Traits::mime_type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mime_type)::BaseType> mime_type_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_mime_type, mime_type_fragment);
    fragment->mime_type.Set(
        mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mime_type.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mime_type in IDBBlobInfo struct");
    fragment->size = Traits::size(input);
    decltype(Traits::file(input)) in_file = Traits::file(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->file)::BaseType> file_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::IDBFileInfoDataView>(
        in_file, file_fragment);
    fragment->file.Set(
        file_fragment.is_null() ? nullptr : file_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::IDBBlobInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBBlobInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBValueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBValue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::bits(input)) in_bits = Traits::bits(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->bits)::BaseType>
        bits_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams bits_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
        in_bits, bits_fragment, &bits_validate_params);
    fragment->bits.Set(
        bits_fragment.is_null() ? nullptr : bits_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->bits.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null bits in IDBValue struct");
    decltype(Traits::external_objects(input)) in_external_objects = Traits::external_objects(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->external_objects)::BaseType>
        external_objects_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams external_objects_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBExternalObjectDataView>>(
        in_external_objects, external_objects_fragment, &external_objects_validate_params);
    fragment->external_objects.Set(
        external_objects_fragment.is_null() ? nullptr : external_objects_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->external_objects.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null external_objects in IDBValue struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBReturnValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBReturnValueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBReturnValue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->value)::BaseType> value_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::IDBValueDataView>(
        in_value, value_fragment);
    fragment->value.Set(
        value_fragment.is_null() ? nullptr : value_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->value.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null value in IDBReturnValue struct");
    decltype(Traits::primary_key(input)) in_primary_key = Traits::primary_key(input);
    mojo::internal::MessageFragment<decltype(fragment->primary_key)>
        primary_key_fragment(fragment.message());
    primary_key_fragment.Claim(&fragment->primary_key);
    mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
        in_primary_key, primary_key_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_key in IDBReturnValue struct");
    decltype(Traits::key_path(input)) in_key_path = Traits::key_path(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->key_path)::BaseType> key_path_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::IDBKeyPathDataView>(
        in_key_path, key_path_fragment);
    fragment->key_path.Set(
        key_path_fragment.is_null() ? nullptr : key_path_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key_path.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key_path in IDBReturnValue struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBReturnValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBReturnValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBErrorDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBErrorDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBError_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::IDBException>(
        Traits::error_code(input), &fragment->error_code);
    decltype(Traits::error_message(input)) in_error_message = Traits::error_message(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->error_message)::BaseType> error_message_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
        in_error_message, error_message_fragment);
    fragment->error_message.Set(
        error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->error_message.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null error_message in IDBError struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBError_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBErrorDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBCursorValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBCursorValueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBCursorValue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::keys(input)) in_keys = Traits::keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->keys)::BaseType>
        keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams keys_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        in_keys, keys_fragment, &keys_validate_params);
    fragment->keys.Set(
        keys_fragment.is_null() ? nullptr : keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null keys in IDBCursorValue struct");
    decltype(Traits::primary_keys(input)) in_primary_keys = Traits::primary_keys(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->primary_keys)::BaseType>
        primary_keys_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams primary_keys_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
        in_primary_keys, primary_keys_fragment, &primary_keys_validate_params);
    fragment->primary_keys.Set(
        primary_keys_fragment.is_null() ? nullptr : primary_keys_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_keys.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_keys in IDBCursorValue struct");
    decltype(Traits::values(input)) in_values = Traits::values(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->values)::BaseType>
        values_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams values_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBValueDataView>>(
        in_values, values_fragment, &values_validate_params);
    fragment->values.Set(
        values_fragment.is_null() ? nullptr : values_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->values.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null values in IDBCursorValue struct");
  }

  static bool Deserialize(::blink::mojom::internal::IDBCursorValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBCursorValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBDatabaseOpenCursorValueDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::IDBDatabaseOpenCursorValueDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::IDBDatabaseOpenCursorValue_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::cursor(input)) in_cursor = Traits::cursor(input);
    mojo::internal::Serialize<::blink::mojom::IDBCursorAssociatedPtrInfoDataView>(
        in_cursor, &fragment->cursor, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->cursor),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
        "invalid cursor in IDBDatabaseOpenCursorValue struct");
    decltype(Traits::key(input)) in_key = Traits::key(input);
    mojo::internal::MessageFragment<decltype(fragment->key)>
        key_fragment(fragment.message());
    key_fragment.Claim(&fragment->key);
    mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
        in_key, key_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null key in IDBDatabaseOpenCursorValue struct");
    decltype(Traits::primary_key(input)) in_primary_key = Traits::primary_key(input);
    mojo::internal::MessageFragment<decltype(fragment->primary_key)>
        primary_key_fragment(fragment.message());
    primary_key_fragment.Claim(&fragment->primary_key);
    mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
        in_primary_key, primary_key_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->primary_key.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null primary_key in IDBDatabaseOpenCursorValue struct");
    decltype(Traits::value(input)) in_value = Traits::value(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->value)::BaseType> value_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::IDBValueDataView>(
        in_value, value_fragment);
    fragment->value.Set(
        value_fragment.is_null() ? nullptr : value_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::IDBDatabaseOpenCursorValue_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBDatabaseOpenCursorValueDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBKeyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBKeyDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBKey_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBKeyDataView::Tag::kKeyArray: {
        decltype(Traits::key_array(input))
            in_key_array = Traits::key_array(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_key_array)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams key_array_validate_params(
            0, false, nullptr);
        mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::IDBKeyDataView>>(
            in_key_array, value_fragment, &key_array_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null key_array in IDBKey union");
        fragment->data.f_key_array.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBKeyDataView::Tag::kBinary: {
        decltype(Traits::binary(input))
            in_binary = Traits::binary(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_binary)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams binary_validate_params(
            0, false, nullptr);
        mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
            in_binary, value_fragment, &binary_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null binary in IDBKey union");
        fragment->data.f_binary.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBKeyDataView::Tag::kString: {
        decltype(Traits::string(input))
            in_string = Traits::string(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_string)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
            in_string, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null string in IDBKey union");
        fragment->data.f_string.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBKeyDataView::Tag::kDate: {
        decltype(Traits::date(input))
            in_date = Traits::date(input);
        fragment->data.f_date = in_date;
        break;
      }
      case ::blink::mojom::IDBKeyDataView::Tag::kNumber: {
        decltype(Traits::number(input))
            in_number = Traits::number(input);
        fragment->data.f_number = in_number;
        break;
      }
      case ::blink::mojom::IDBKeyDataView::Tag::kOtherNone: {
        decltype(Traits::other_none(input))
            in_other_none = Traits::other_none(input);
        fragment->data.f_other_none = in_other_none;
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBKey_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBKeyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBKeyPathDataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBKeyPathDataDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBKeyPathData_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBKeyPathDataDataView::Tag::kString: {
        decltype(Traits::string(input))
            in_string = Traits::string(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_string)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
            in_string, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null string in IDBKeyPathData union");
        fragment->data.f_string.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBKeyPathDataDataView::Tag::kStringArray: {
        decltype(Traits::string_array(input))
            in_string_array = Traits::string_array(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_string_array)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams string_array_validate_params(
            0, false, nullptr);
        mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::String16DataView>>(
            in_string_array, value_fragment, &string_array_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null string_array in IDBKeyPathData union");
        fragment->data.f_string_array.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBKeyPathData_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBKeyPathDataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBExternalObjectDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBExternalObjectDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBExternalObject_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBExternalObjectDataView::Tag::kBlobOrFile: {
        decltype(Traits::blob_or_file(input))
            in_blob_or_file = Traits::blob_or_file(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_blob_or_file)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBBlobInfoDataView>(
            in_blob_or_file, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null blob_or_file in IDBExternalObject union");
        fragment->data.f_blob_or_file.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBExternalObjectDataView::Tag::kFileSystemAccessToken: {
        decltype(Traits::file_system_access_token(input))
            in_file_system_access_token = Traits::file_system_access_token(input);
        mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::FileSystemAccessTransferTokenInterfaceBase>>(
            in_file_system_access_token, &fragment->data.f_file_system_access_token, &fragment.message());
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            !mojo::internal::IsHandleOrInterfaceValid(fragment->data.f_file_system_access_token),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
            "invalid file_system_access_token in IDBExternalObject union");
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBExternalObject_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBExternalObjectDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBCursorResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBCursorResultDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBCursorResult_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBCursorResultDataView::Tag::kErrorResult: {
        decltype(Traits::error_result(input))
            in_error_result = Traits::error_result(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_error_result)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBErrorDataView>(
            in_error_result, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null error_result in IDBCursorResult union");
        fragment->data.f_error_result.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBCursorResultDataView::Tag::kEmpty: {
        decltype(Traits::empty(input))
            in_empty = Traits::empty(input);
        fragment->data.f_empty = in_empty;
        break;
      }
      case ::blink::mojom::IDBCursorResultDataView::Tag::kValues: {
        decltype(Traits::values(input))
            in_values = Traits::values(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_values)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBCursorValueDataView>(
            in_values, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null values in IDBCursorResult union");
        fragment->data.f_values.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBCursorResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBCursorResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBTransactionPutResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBTransactionPutResultDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBTransactionPutResult_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBTransactionPutResultDataView::Tag::kErrorResult: {
        decltype(Traits::error_result(input))
            in_error_result = Traits::error_result(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_error_result)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBErrorDataView>(
            in_error_result, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null error_result in IDBTransactionPutResult union");
        fragment->data.f_error_result.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBTransactionPutResultDataView::Tag::kKey: {
        decltype(Traits::key(input))
            in_key = Traits::key(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_key)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
            in_key, value_fragment, false);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null key in IDBTransactionPutResult union");
        fragment->data.f_key.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBTransactionPutResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBTransactionPutResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBDatabaseGetResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBDatabaseGetResultDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBDatabaseGetResult_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBDatabaseGetResultDataView::Tag::kErrorResult: {
        decltype(Traits::error_result(input))
            in_error_result = Traits::error_result(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_error_result)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBErrorDataView>(
            in_error_result, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null error_result in IDBDatabaseGetResult union");
        fragment->data.f_error_result.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBDatabaseGetResultDataView::Tag::kEmpty: {
        decltype(Traits::empty(input))
            in_empty = Traits::empty(input);
        fragment->data.f_empty = in_empty;
        break;
      }
      case ::blink::mojom::IDBDatabaseGetResultDataView::Tag::kKey: {
        decltype(Traits::key(input))
            in_key = Traits::key(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_key)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBKeyDataView>(
            in_key, value_fragment, false);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null key in IDBDatabaseGetResult union");
        fragment->data.f_key.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBDatabaseGetResultDataView::Tag::kValue: {
        decltype(Traits::value(input))
            in_value = Traits::value(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_value)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBReturnValueDataView>(
            in_value, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null value in IDBDatabaseGetResult union");
        fragment->data.f_value.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBDatabaseGetResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBDatabaseGetResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBDatabaseBatchGetAllResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBDatabaseBatchGetAllResultDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBDatabaseBatchGetAllResult_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBDatabaseBatchGetAllResultDataView::Tag::kErrorResult: {
        decltype(Traits::error_result(input))
            in_error_result = Traits::error_result(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_error_result)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBErrorDataView>(
            in_error_result, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null error_result in IDBDatabaseBatchGetAllResult union");
        fragment->data.f_error_result.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBDatabaseBatchGetAllResultDataView::Tag::kValues: {
        decltype(Traits::values(input))
            in_values = Traits::values(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_values)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams values_validate_params(
            0, false, new mojo::internal::ContainerValidateParams(0, false, nullptr));
        mojo::internal::Serialize<mojo::ArrayDataView<mojo::ArrayDataView<::blink::mojom::IDBReturnValueDataView>>>(
            in_values, value_fragment, &values_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null values in IDBDatabaseBatchGetAllResult union");
        fragment->data.f_values.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBDatabaseBatchGetAllResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBDatabaseBatchGetAllResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::IDBDatabaseOpenCursorResultDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::blink::mojom::IDBDatabaseOpenCursorResultDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::blink::mojom::internal::IDBDatabaseOpenCursorResult_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::blink::mojom::IDBDatabaseOpenCursorResultDataView::Tag::kErrorResult: {
        decltype(Traits::error_result(input))
            in_error_result = Traits::error_result(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_error_result)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBErrorDataView>(
            in_error_result, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null error_result in IDBDatabaseOpenCursorResult union");
        fragment->data.f_error_result.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::blink::mojom::IDBDatabaseOpenCursorResultDataView::Tag::kEmpty: {
        decltype(Traits::empty(input))
            in_empty = Traits::empty(input);
        fragment->data.f_empty = in_empty;
        break;
      }
      case ::blink::mojom::IDBDatabaseOpenCursorResultDataView::Tag::kValue: {
        decltype(Traits::value(input))
            in_value = Traits::value(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_value)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::blink::mojom::IDBDatabaseOpenCursorValueDataView>(
            in_value, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null value in IDBDatabaseOpenCursorResult union");
        fragment->data.f_value.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::blink::mojom::internal::IDBDatabaseOpenCursorResult_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::IDBDatabaseOpenCursorResultDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void IDBKeyPathDataView::GetDataDataView(
    IDBKeyPathDataDataView* output) {
  auto pointer = &data_->data;
  *output = IDBKeyPathDataDataView(pointer, message_);
}


inline void IDBKeyRangeDataView::GetLowerDataView(
    IDBKeyDataView* output) {
  auto pointer = &data_->lower;
  *output = IDBKeyDataView(pointer, message_);
}
inline void IDBKeyRangeDataView::GetUpperDataView(
    IDBKeyDataView* output) {
  auto pointer = &data_->upper;
  *output = IDBKeyDataView(pointer, message_);
}


inline void IDBIndexMetadataDataView::GetNameDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->name.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void IDBIndexMetadataDataView::GetKeyPathDataView(
    IDBKeyPathDataView* output) {
  auto pointer = data_->key_path.Get();
  *output = IDBKeyPathDataView(pointer, message_);
}


inline void IDBObjectStoreMetadataDataView::GetNameDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->name.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void IDBObjectStoreMetadataDataView::GetKeyPathDataView(
    IDBKeyPathDataView* output) {
  auto pointer = data_->key_path.Get();
  *output = IDBKeyPathDataView(pointer, message_);
}
inline void IDBObjectStoreMetadataDataView::GetIndexesDataView(
    mojo::MapDataView<int64_t, IDBIndexMetadataDataView>* output) {
  auto pointer = data_->indexes.Get();
  *output = mojo::MapDataView<int64_t, IDBIndexMetadataDataView>(pointer, message_);
}


inline void IDBDatabaseMetadataDataView::GetNameDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->name.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void IDBDatabaseMetadataDataView::GetObjectStoresDataView(
    mojo::MapDataView<int64_t, IDBObjectStoreMetadataDataView>* output) {
  auto pointer = data_->object_stores.Get();
  *output = mojo::MapDataView<int64_t, IDBObjectStoreMetadataDataView>(pointer, message_);
}


inline void IDBNameAndVersionDataView::GetNameDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->name.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}


inline void IDBIndexKeysDataView::GetIndexKeysDataView(
    mojo::ArrayDataView<IDBKeyDataView>* output) {
  auto pointer = data_->index_keys.Get();
  *output = mojo::ArrayDataView<IDBKeyDataView>(pointer, message_);
}


inline void IDBFileInfoDataView::GetNameDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->name.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void IDBFileInfoDataView::GetLastModifiedDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->last_modified.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}


inline void IDBBlobInfoDataView::GetUuidDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->uuid.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void IDBBlobInfoDataView::GetMimeTypeDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->mime_type.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}
inline void IDBBlobInfoDataView::GetFileDataView(
    IDBFileInfoDataView* output) {
  auto pointer = data_->file.Get();
  *output = IDBFileInfoDataView(pointer, message_);
}


inline void IDBValueDataView::GetBitsDataView(
    mojo::ArrayDataView<uint8_t>* output) {
  auto pointer = data_->bits.Get();
  *output = mojo::ArrayDataView<uint8_t>(pointer, message_);
}
inline void IDBValueDataView::GetExternalObjectsDataView(
    mojo::ArrayDataView<IDBExternalObjectDataView>* output) {
  auto pointer = data_->external_objects.Get();
  *output = mojo::ArrayDataView<IDBExternalObjectDataView>(pointer, message_);
}


inline void IDBReturnValueDataView::GetValueDataView(
    IDBValueDataView* output) {
  auto pointer = data_->value.Get();
  *output = IDBValueDataView(pointer, message_);
}
inline void IDBReturnValueDataView::GetPrimaryKeyDataView(
    IDBKeyDataView* output) {
  auto pointer = &data_->primary_key;
  *output = IDBKeyDataView(pointer, message_);
}
inline void IDBReturnValueDataView::GetKeyPathDataView(
    IDBKeyPathDataView* output) {
  auto pointer = data_->key_path.Get();
  *output = IDBKeyPathDataView(pointer, message_);
}


inline void IDBErrorDataView::GetErrorMessageDataView(
    ::mojo_base::mojom::String16DataView* output) {
  auto pointer = data_->error_message.Get();
  *output = ::mojo_base::mojom::String16DataView(pointer, message_);
}


inline void IDBCursorValueDataView::GetKeysDataView(
    mojo::ArrayDataView<IDBKeyDataView>* output) {
  auto pointer = data_->keys.Get();
  *output = mojo::ArrayDataView<IDBKeyDataView>(pointer, message_);
}
inline void IDBCursorValueDataView::GetPrimaryKeysDataView(
    mojo::ArrayDataView<IDBKeyDataView>* output) {
  auto pointer = data_->primary_keys.Get();
  *output = mojo::ArrayDataView<IDBKeyDataView>(pointer, message_);
}
inline void IDBCursorValueDataView::GetValuesDataView(
    mojo::ArrayDataView<IDBValueDataView>* output) {
  auto pointer = data_->values.Get();
  *output = mojo::ArrayDataView<IDBValueDataView>(pointer, message_);
}


inline void IDBDatabaseOpenCursorValueDataView::GetKeyDataView(
    IDBKeyDataView* output) {
  auto pointer = &data_->key;
  *output = IDBKeyDataView(pointer, message_);
}
inline void IDBDatabaseOpenCursorValueDataView::GetPrimaryKeyDataView(
    IDBKeyDataView* output) {
  auto pointer = &data_->primary_key;
  *output = IDBKeyDataView(pointer, message_);
}
inline void IDBDatabaseOpenCursorValueDataView::GetValueDataView(
    IDBValueDataView* output) {
  auto pointer = data_->value.Get();
  *output = IDBValueDataView(pointer, message_);
}


inline void IDBKeyDataView::GetKeyArrayDataView(
    mojo::ArrayDataView<IDBKeyDataView>* output) const {
  CHECK(is_key_array());
  *output = mojo::ArrayDataView<IDBKeyDataView>(data_->data.f_key_array.Get(), message_);
}
inline void IDBKeyDataView::GetBinaryDataView(
    mojo::ArrayDataView<uint8_t>* output) const {
  CHECK(is_binary());
  *output = mojo::ArrayDataView<uint8_t>(data_->data.f_binary.Get(), message_);
}
inline void IDBKeyDataView::GetStringDataView(
    ::mojo_base::mojom::String16DataView* output) const {
  CHECK(is_string());
  *output = ::mojo_base::mojom::String16DataView(data_->data.f_string.Get(), message_);
}

inline void IDBKeyPathDataDataView::GetStringDataView(
    ::mojo_base::mojom::String16DataView* output) const {
  CHECK(is_string());
  *output = ::mojo_base::mojom::String16DataView(data_->data.f_string.Get(), message_);
}
inline void IDBKeyPathDataDataView::GetStringArrayDataView(
    mojo::ArrayDataView<::mojo_base::mojom::String16DataView>* output) const {
  CHECK(is_string_array());
  *output = mojo::ArrayDataView<::mojo_base::mojom::String16DataView>(data_->data.f_string_array.Get(), message_);
}

inline void IDBExternalObjectDataView::GetBlobOrFileDataView(
    IDBBlobInfoDataView* output) const {
  CHECK(is_blob_or_file());
  *output = IDBBlobInfoDataView(data_->data.f_blob_or_file.Get(), message_);
}

inline void IDBCursorResultDataView::GetErrorResultDataView(
    IDBErrorDataView* output) const {
  CHECK(is_error_result());
  *output = IDBErrorDataView(data_->data.f_error_result.Get(), message_);
}
inline void IDBCursorResultDataView::GetValuesDataView(
    IDBCursorValueDataView* output) const {
  CHECK(is_values());
  *output = IDBCursorValueDataView(data_->data.f_values.Get(), message_);
}

inline void IDBTransactionPutResultDataView::GetErrorResultDataView(
    IDBErrorDataView* output) const {
  CHECK(is_error_result());
  *output = IDBErrorDataView(data_->data.f_error_result.Get(), message_);
}
inline void IDBTransactionPutResultDataView::GetKeyDataView(
    IDBKeyDataView* output) const {
  CHECK(is_key());
  *output = IDBKeyDataView(data_->data.f_key.Get(), message_);
}

inline void IDBDatabaseGetResultDataView::GetErrorResultDataView(
    IDBErrorDataView* output) const {
  CHECK(is_error_result());
  *output = IDBErrorDataView(data_->data.f_error_result.Get(), message_);
}
inline void IDBDatabaseGetResultDataView::GetKeyDataView(
    IDBKeyDataView* output) const {
  CHECK(is_key());
  *output = IDBKeyDataView(data_->data.f_key.Get(), message_);
}
inline void IDBDatabaseGetResultDataView::GetValueDataView(
    IDBReturnValueDataView* output) const {
  CHECK(is_value());
  *output = IDBReturnValueDataView(data_->data.f_value.Get(), message_);
}

inline void IDBDatabaseBatchGetAllResultDataView::GetErrorResultDataView(
    IDBErrorDataView* output) const {
  CHECK(is_error_result());
  *output = IDBErrorDataView(data_->data.f_error_result.Get(), message_);
}
inline void IDBDatabaseBatchGetAllResultDataView::GetValuesDataView(
    mojo::ArrayDataView<mojo::ArrayDataView<IDBReturnValueDataView>>* output) const {
  CHECK(is_values());
  *output = mojo::ArrayDataView<mojo::ArrayDataView<IDBReturnValueDataView>>(data_->data.f_values.Get(), message_);
}

inline void IDBDatabaseOpenCursorResultDataView::GetErrorResultDataView(
    IDBErrorDataView* output) const {
  CHECK(is_error_result());
  *output = IDBErrorDataView(data_->data.f_error_result.Get(), message_);
}
inline void IDBDatabaseOpenCursorResultDataView::GetValueDataView(
    IDBDatabaseOpenCursorValueDataView* output) const {
  CHECK(is_value());
  *output = IDBDatabaseOpenCursorValueDataView(data_->data.f_value.Get(), message_);
}


}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBCursorDirection> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBCursorDirection value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBDataLoss> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBDataLoss value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBKeyType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBKeyType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBTransactionDurability> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBTransactionDurability value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBKeyPathType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBKeyPathType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBOperationType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBOperationType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBPutMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBPutMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBTaskType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBTaskType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBTransactionMode> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBTransactionMode value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBStatus> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBStatus value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::IDBException> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::IDBException value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_INDEXEDDB_INDEXEDDB_MOJOM_SHARED_H_