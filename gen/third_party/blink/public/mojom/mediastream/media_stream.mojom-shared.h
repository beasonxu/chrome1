// third_party/blink/public/mojom/mediastream/media_stream.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_SHARED_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/mediastream/media_stream.mojom-shared-internal.h"
#include "media/capture/mojom/video_capture_types.mojom-shared.h"
#include "media/mojo/mojom/audio_parameters.mojom-shared.h"
#include "media/mojo/mojom/display_media_information.mojom-shared.h"
#include "mojo/public/mojom/base/token.mojom-shared.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"
#include "base/component_export.h"




namespace blink {
namespace mojom {
class StreamSelectionInfoDataView;

class MediaStreamDeviceDataView;

class TrackControlsDataView;

class StreamControlsDataView;

class GetOpenDeviceResponseDataView;

class StreamDevicesDataView;

class StreamDevicesSetDataView;



}  // namespace mojom
}  // namespace blink

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::blink::mojom::StreamSelectionInfoDataView> {
  using Data = ::blink::mojom::internal::StreamSelectionInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::MediaStreamDeviceDataView> {
  using Data = ::blink::mojom::internal::MediaStreamDevice_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::TrackControlsDataView> {
  using Data = ::blink::mojom::internal::TrackControls_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::StreamControlsDataView> {
  using Data = ::blink::mojom::internal::StreamControls_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::GetOpenDeviceResponseDataView> {
  using Data = ::blink::mojom::internal::GetOpenDeviceResponse_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::StreamDevicesDataView> {
  using Data = ::blink::mojom::internal::StreamDevices_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::blink::mojom::StreamDevicesSetDataView> {
  using Data = ::blink::mojom::internal::StreamDevicesSet_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

}  // namespace internal
}  // namespace mojo


namespace blink {
namespace mojom {


enum class MediaStreamType : int32_t {
  
  NO_SERVICE = 0,
  
  DEVICE_AUDIO_CAPTURE = 1,
  
  DEVICE_VIDEO_CAPTURE = 2,
  
  GUM_TAB_AUDIO_CAPTURE = 3,
  
  GUM_TAB_VIDEO_CAPTURE = 4,
  
  GUM_DESKTOP_VIDEO_CAPTURE = 5,
  
  GUM_DESKTOP_AUDIO_CAPTURE = 6,
  
  DISPLAY_VIDEO_CAPTURE = 7,
  
  DISPLAY_AUDIO_CAPTURE = 8,
  
  DISPLAY_VIDEO_CAPTURE_THIS_TAB = 9,
  
  DISPLAY_VIDEO_CAPTURE_SET = 10,
  
  NUM_MEDIA_TYPES = 11,
  kMinValue = 0,
  kMaxValue = 11,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, MediaStreamType value);
inline bool IsKnownEnumValue(MediaStreamType value) {
  return internal::MediaStreamType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MediaStreamRequestResult : int32_t {
  
  OK = 0,
  
  PERMISSION_DENIED = 1,
  
  PERMISSION_DISMISSED = 2,
  
  INVALID_STATE = 3,
  
  NO_HARDWARE = 4,
  
  INVALID_SECURITY_ORIGIN = 5,
  
  TAB_CAPTURE_FAILURE = 6,
  
  SCREEN_CAPTURE_FAILURE = 7,
  
  CAPTURE_FAILURE = 8,
  
  CONSTRAINT_NOT_SATISFIED = 9,
  
  TRACK_START_FAILURE_AUDIO = 10,
  
  TRACK_START_FAILURE_VIDEO = 11,
  
  NOT_SUPPORTED = 12,
  
  FAILED_DUE_TO_SHUTDOWN = 13,
  
  KILL_SWITCH_ON = 14,
  
  SYSTEM_PERMISSION_DENIED = 15,
  
  DEVICE_IN_USE = 16,
  
  NUM_MEDIA_REQUEST_RESULTS = 17,
  kMinValue = 0,
  kMaxValue = 17,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, MediaStreamRequestResult value);
inline bool IsKnownEnumValue(MediaStreamRequestResult value) {
  return internal::MediaStreamRequestResult_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class StreamSelectionStrategy : int32_t {
  
  SEARCH_BY_SESSION_ID = 0,
  
  SEARCH_BY_DEVICE_ID = 1,
  
  FORCE_NEW_STREAM = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, StreamSelectionStrategy value);
inline bool IsKnownEnumValue(StreamSelectionStrategy value) {
  return internal::StreamSelectionStrategy_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class MediaStreamStateChange : int32_t {
  
  PLAY = 0,
  
  PAUSE = 1,
  kMinValue = 0,
  kMaxValue = 1,
};

COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) std::ostream& operator<<(std::ostream& os, MediaStreamStateChange value);
inline bool IsKnownEnumValue(MediaStreamStateChange value) {
  return internal::MediaStreamStateChange_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class MediaStreamDeviceObserverInterfaceBase {};

using MediaStreamDeviceObserverPtrDataView =
    mojo::InterfacePtrDataView<MediaStreamDeviceObserverInterfaceBase>;
using MediaStreamDeviceObserverRequestDataView =
    mojo::InterfaceRequestDataView<MediaStreamDeviceObserverInterfaceBase>;
using MediaStreamDeviceObserverAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<MediaStreamDeviceObserverInterfaceBase>;
using MediaStreamDeviceObserverAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<MediaStreamDeviceObserverInterfaceBase>;
class MediaStreamDispatcherHostInterfaceBase {};

using MediaStreamDispatcherHostPtrDataView =
    mojo::InterfacePtrDataView<MediaStreamDispatcherHostInterfaceBase>;
using MediaStreamDispatcherHostRequestDataView =
    mojo::InterfaceRequestDataView<MediaStreamDispatcherHostInterfaceBase>;
using MediaStreamDispatcherHostAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<MediaStreamDispatcherHostInterfaceBase>;
using MediaStreamDispatcherHostAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<MediaStreamDispatcherHostInterfaceBase>;
class MediaStreamTrackMetricsHostInterfaceBase {};

using MediaStreamTrackMetricsHostPtrDataView =
    mojo::InterfacePtrDataView<MediaStreamTrackMetricsHostInterfaceBase>;
using MediaStreamTrackMetricsHostRequestDataView =
    mojo::InterfaceRequestDataView<MediaStreamTrackMetricsHostInterfaceBase>;
using MediaStreamTrackMetricsHostAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<MediaStreamTrackMetricsHostInterfaceBase>;
using MediaStreamTrackMetricsHostAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<MediaStreamTrackMetricsHostInterfaceBase>;


class StreamSelectionInfoDataView {
 public:
  StreamSelectionInfoDataView() = default;

  StreamSelectionInfoDataView(
      internal::StreamSelectionInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadStrategy(UserType* output) const {
    auto data_value = data_->strategy;
    return mojo::internal::Deserialize<::blink::mojom::StreamSelectionStrategy>(
        data_value, output);
  }
  StreamSelectionStrategy strategy() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::StreamSelectionStrategy>(data_->strategy));
  }
  inline void GetSessionIdDataView(
      ::mojo_base::mojom::UnguessableTokenDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSessionId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::UnguessableTokenDataView, UserType>(),
    "Attempting to read the optional `session_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSessionId` instead "
    "of `ReadSessionId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->session_id.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(
        pointer, output, message_);
  }
 private:
  internal::StreamSelectionInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class MediaStreamDeviceDataView {
 public:
  MediaStreamDeviceDataView() = default;

  MediaStreamDeviceDataView(
      internal::MediaStreamDevice_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  [[nodiscard]] bool ReadType(UserType* output) const {
    auto data_value = data_->type;
    return mojo::internal::Deserialize<::blink::mojom::MediaStreamType>(
        data_value, output);
  }
  MediaStreamType type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::MediaStreamType>(data_->type));
  }
  inline void GetIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadId(UserType* output) {
    
    auto* pointer = data_->id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadVideoFacing(UserType* output) const {
    auto data_value = data_->video_facing;
    return mojo::internal::Deserialize<::media::mojom::VideoFacingMode>(
        data_value, output);
  }
  ::media::mojom::VideoFacingMode video_facing() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::media::mojom::VideoFacingMode>(data_->video_facing));
  }
  inline void GetGroupIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadGroupId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `group_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadGroupId` instead "
    "of `ReadGroupId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->group_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetMatchedOutputDeviceIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMatchedOutputDeviceId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        mojo::StringDataView, UserType>(),
    "Attempting to read the optional `matched_output_device_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMatchedOutputDeviceId` instead "
    "of `ReadMatchedOutputDeviceId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->matched_output_device_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetNameDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadName(UserType* output) {
    
    auto* pointer = data_->name.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetInputDataView(
      ::media::mojom::AudioParametersDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInput(UserType* output) {
    
    auto* pointer = data_->input.Get();
    return mojo::internal::Deserialize<::media::mojom::AudioParametersDataView>(
        pointer, output, message_);
  }
  inline void GetSessionIdDataView(
      ::mojo_base::mojom::UnguessableTokenDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadSessionId(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::UnguessableTokenDataView, UserType>(),
    "Attempting to read the optional `session_id` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadSessionId` instead "
    "of `ReadSessionId if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->session_id.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::UnguessableTokenDataView>(
        pointer, output, message_);
  }
  inline void GetDisplayMediaInfoDataView(
      ::media::mojom::DisplayMediaInformationDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDisplayMediaInfo(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::media::mojom::DisplayMediaInformationDataView, UserType>(),
    "Attempting to read the optional `display_media_info` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDisplayMediaInfo` instead "
    "of `ReadDisplayMediaInfo if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->display_media_info.Get();
    return mojo::internal::Deserialize<::media::mojom::DisplayMediaInformationDataView>(
        pointer, output, message_);
  }
 private:
  internal::MediaStreamDevice_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class TrackControlsDataView {
 public:
  TrackControlsDataView() = default;

  TrackControlsDataView(
      internal::TrackControls_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  bool requested() const {
    return data_->requested;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadStreamType(UserType* output) const {
    auto data_value = data_->stream_type;
    return mojo::internal::Deserialize<::blink::mojom::MediaStreamType>(
        data_value, output);
  }
  MediaStreamType stream_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::blink::mojom::MediaStreamType>(data_->stream_type));
  }
  inline void GetDeviceIdDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDeviceId(UserType* output) {
    
    auto* pointer = data_->device_id.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
 private:
  internal::TrackControls_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StreamControlsDataView {
 public:
  StreamControlsDataView() = default;

  StreamControlsDataView(
      internal::StreamControls_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetAudioDataView(
      TrackControlsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAudio(UserType* output) {
    
    auto* pointer = data_->audio.Get();
    return mojo::internal::Deserialize<::blink::mojom::TrackControlsDataView>(
        pointer, output, message_);
  }
  inline void GetVideoDataView(
      TrackControlsDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVideo(UserType* output) {
    
    auto* pointer = data_->video.Get();
    return mojo::internal::Deserialize<::blink::mojom::TrackControlsDataView>(
        pointer, output, message_);
  }
  bool hotword_enabled() const {
    return data_->hotword_enabled;
  }
  bool disable_local_echo() const {
    return data_->disable_local_echo;
  }
  bool exclude_system_audio() const {
    return data_->exclude_system_audio;
  }
  bool request_pan_tilt_zoom_permission() const {
    return data_->request_pan_tilt_zoom_permission;
  }
  bool request_all_screens() const {
    return data_->request_all_screens;
  }
 private:
  internal::StreamControls_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GetOpenDeviceResponseDataView {
 public:
  GetOpenDeviceResponseDataView() = default;

  GetOpenDeviceResponseDataView(
      internal::GetOpenDeviceResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetLabelDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLabel(UserType* output) {
    
    auto* pointer = data_->label.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  inline void GetDeviceDataView(
      MediaStreamDeviceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDevice(UserType* output) {
    
    auto* pointer = data_->device.Get();
    return mojo::internal::Deserialize<::blink::mojom::MediaStreamDeviceDataView>(
        pointer, output, message_);
  }
  bool pan_tilt_zoom_allowed() const {
    return data_->pan_tilt_zoom_allowed;
  }
 private:
  internal::GetOpenDeviceResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StreamDevicesDataView {
 public:
  StreamDevicesDataView() = default;

  StreamDevicesDataView(
      internal::StreamDevices_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetAudioDeviceDataView(
      MediaStreamDeviceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadAudioDevice(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::MediaStreamDeviceDataView, UserType>(),
    "Attempting to read the optional `audio_device` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadAudioDevice` instead "
    "of `ReadAudioDevice if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->audio_device.Get();
    return mojo::internal::Deserialize<::blink::mojom::MediaStreamDeviceDataView>(
        pointer, output, message_);
  }
  inline void GetVideoDeviceDataView(
      MediaStreamDeviceDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadVideoDevice(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::blink::mojom::MediaStreamDeviceDataView, UserType>(),
    "Attempting to read the optional `video_device` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadVideoDevice` instead "
    "of `ReadVideoDevice if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->video_device.Get();
    return mojo::internal::Deserialize<::blink::mojom::MediaStreamDeviceDataView>(
        pointer, output, message_);
  }
 private:
  internal::StreamDevices_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class StreamDevicesSetDataView {
 public:
  StreamDevicesSetDataView() = default;

  StreamDevicesSetDataView(
      internal::StreamDevicesSet_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetStreamDevicesDataView(
      mojo::ArrayDataView<StreamDevicesDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStreamDevices(UserType* output) {
    
    auto* pointer = data_->stream_devices.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::blink::mojom::StreamDevicesDataView>>(
        pointer, output, message_);
  }
 private:
  internal::StreamDevicesSet_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace blink

namespace std {

template <>
struct hash<::blink::mojom::MediaStreamType>
    : public mojo::internal::EnumHashImpl<::blink::mojom::MediaStreamType> {};

template <>
struct hash<::blink::mojom::MediaStreamRequestResult>
    : public mojo::internal::EnumHashImpl<::blink::mojom::MediaStreamRequestResult> {};

template <>
struct hash<::blink::mojom::StreamSelectionStrategy>
    : public mojo::internal::EnumHashImpl<::blink::mojom::StreamSelectionStrategy> {};

template <>
struct hash<::blink::mojom::MediaStreamStateChange>
    : public mojo::internal::EnumHashImpl<::blink::mojom::MediaStreamStateChange> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MediaStreamType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::MediaStreamType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::MediaStreamType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MediaStreamRequestResult, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::MediaStreamRequestResult, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::MediaStreamRequestResult>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::StreamSelectionStrategy, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::StreamSelectionStrategy, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::StreamSelectionStrategy>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MediaStreamStateChange, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::blink::mojom::MediaStreamStateChange, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::blink::mojom::MediaStreamStateChange>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::StreamSelectionInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::StreamSelectionInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::StreamSelectionInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::StreamSelectionStrategy>(
        Traits::strategy(input), &fragment->strategy);
    decltype(Traits::session_id(input)) in_session_id = Traits::session_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->session_id)::BaseType> session_id_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
        in_session_id, session_id_fragment);
    fragment->session_id.Set(
        session_id_fragment.is_null() ? nullptr : session_id_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::StreamSelectionInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::StreamSelectionInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::MediaStreamDeviceDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::MediaStreamDeviceDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::MediaStreamDevice_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    mojo::internal::Serialize<::blink::mojom::MediaStreamType>(
        Traits::type(input), &fragment->type);
    decltype(Traits::id(input)) in_id = Traits::id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->id)::BaseType> id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_id, id_fragment);
    fragment->id.Set(
        id_fragment.is_null() ? nullptr : id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null id in MediaStreamDevice struct");
    mojo::internal::Serialize<::media::mojom::VideoFacingMode>(
        Traits::video_facing(input), &fragment->video_facing);
    decltype(Traits::group_id(input)) in_group_id = Traits::group_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->group_id)::BaseType> group_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_group_id, group_id_fragment);
    fragment->group_id.Set(
        group_id_fragment.is_null() ? nullptr : group_id_fragment.data());
    decltype(Traits::matched_output_device_id(input)) in_matched_output_device_id = Traits::matched_output_device_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->matched_output_device_id)::BaseType> matched_output_device_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_matched_output_device_id, matched_output_device_id_fragment);
    fragment->matched_output_device_id.Set(
        matched_output_device_id_fragment.is_null() ? nullptr : matched_output_device_id_fragment.data());
    decltype(Traits::name(input)) in_name = Traits::name(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->name)::BaseType> name_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_name, name_fragment);
    fragment->name.Set(
        name_fragment.is_null() ? nullptr : name_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->name.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null name in MediaStreamDevice struct");
    decltype(Traits::input(input)) in_input = Traits::input(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->input)::BaseType> input_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::AudioParametersDataView>(
        in_input, input_fragment);
    fragment->input.Set(
        input_fragment.is_null() ? nullptr : input_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->input.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null input in MediaStreamDevice struct");
    decltype(Traits::session_id(input)) in_session_id = Traits::session_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->session_id)::BaseType> session_id_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
        in_session_id, session_id_fragment);
    fragment->session_id.Set(
        session_id_fragment.is_null() ? nullptr : session_id_fragment.data());
    decltype(Traits::display_media_info(input)) in_display_media_info = Traits::display_media_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->display_media_info)::BaseType> display_media_info_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::DisplayMediaInformationDataView>(
        in_display_media_info, display_media_info_fragment);
    fragment->display_media_info.Set(
        display_media_info_fragment.is_null() ? nullptr : display_media_info_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::MediaStreamDevice_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::MediaStreamDeviceDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::TrackControlsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::TrackControlsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::TrackControls_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->requested = Traits::requested(input);
    mojo::internal::Serialize<::blink::mojom::MediaStreamType>(
        Traits::stream_type(input), &fragment->stream_type);
    decltype(Traits::device_id(input)) in_device_id = Traits::device_id(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->device_id)::BaseType> device_id_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_device_id, device_id_fragment);
    fragment->device_id.Set(
        device_id_fragment.is_null() ? nullptr : device_id_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->device_id.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null device_id in TrackControls struct");
  }

  static bool Deserialize(::blink::mojom::internal::TrackControls_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::TrackControlsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::StreamControlsDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::StreamControlsDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::StreamControls_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::audio(input)) in_audio = Traits::audio(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->audio)::BaseType> audio_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::TrackControlsDataView>(
        in_audio, audio_fragment);
    fragment->audio.Set(
        audio_fragment.is_null() ? nullptr : audio_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->audio.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null audio in StreamControls struct");
    decltype(Traits::video(input)) in_video = Traits::video(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->video)::BaseType> video_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::TrackControlsDataView>(
        in_video, video_fragment);
    fragment->video.Set(
        video_fragment.is_null() ? nullptr : video_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->video.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null video in StreamControls struct");
    fragment->hotword_enabled = Traits::hotword_enabled(input);
    fragment->disable_local_echo = Traits::disable_local_echo(input);
    fragment->exclude_system_audio = Traits::exclude_system_audio(input);
    fragment->request_pan_tilt_zoom_permission = Traits::request_pan_tilt_zoom_permission(input);
    fragment->request_all_screens = Traits::request_all_screens(input);
  }

  static bool Deserialize(::blink::mojom::internal::StreamControls_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::StreamControlsDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::GetOpenDeviceResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::GetOpenDeviceResponseDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::GetOpenDeviceResponse_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::label(input)) in_label = Traits::label(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->label)::BaseType> label_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_label, label_fragment);
    fragment->label.Set(
        label_fragment.is_null() ? nullptr : label_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->label.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null label in GetOpenDeviceResponse struct");
    decltype(Traits::device(input)) in_device = Traits::device(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->device)::BaseType> device_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::MediaStreamDeviceDataView>(
        in_device, device_fragment);
    fragment->device.Set(
        device_fragment.is_null() ? nullptr : device_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->device.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null device in GetOpenDeviceResponse struct");
    fragment->pan_tilt_zoom_allowed = Traits::pan_tilt_zoom_allowed(input);
  }

  static bool Deserialize(::blink::mojom::internal::GetOpenDeviceResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::GetOpenDeviceResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::StreamDevicesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::StreamDevicesDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::StreamDevices_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::audio_device(input)) in_audio_device = Traits::audio_device(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->audio_device)::BaseType> audio_device_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::MediaStreamDeviceDataView>(
        in_audio_device, audio_device_fragment);
    fragment->audio_device.Set(
        audio_device_fragment.is_null() ? nullptr : audio_device_fragment.data());
    decltype(Traits::video_device(input)) in_video_device = Traits::video_device(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->video_device)::BaseType> video_device_fragment(
            fragment.message());
    mojo::internal::Serialize<::blink::mojom::MediaStreamDeviceDataView>(
        in_video_device, video_device_fragment);
    fragment->video_device.Set(
        video_device_fragment.is_null() ? nullptr : video_device_fragment.data());
  }

  static bool Deserialize(::blink::mojom::internal::StreamDevices_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::StreamDevicesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::blink::mojom::StreamDevicesSetDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::blink::mojom::StreamDevicesSetDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::blink::mojom::internal::StreamDevicesSet_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::stream_devices(input)) in_stream_devices = Traits::stream_devices(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->stream_devices)::BaseType>
        stream_devices_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams stream_devices_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::StreamDevicesDataView>>(
        in_stream_devices, stream_devices_fragment, &stream_devices_validate_params);
    fragment->stream_devices.Set(
        stream_devices_fragment.is_null() ? nullptr : stream_devices_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->stream_devices.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null stream_devices in StreamDevicesSet struct");
  }

  static bool Deserialize(::blink::mojom::internal::StreamDevicesSet_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::blink::mojom::StreamDevicesSetDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace blink {
namespace mojom {

inline void StreamSelectionInfoDataView::GetSessionIdDataView(
    ::mojo_base::mojom::UnguessableTokenDataView* output) {
  auto pointer = data_->session_id.Get();
  *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}


inline void MediaStreamDeviceDataView::GetIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MediaStreamDeviceDataView::GetGroupIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->group_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MediaStreamDeviceDataView::GetMatchedOutputDeviceIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->matched_output_device_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MediaStreamDeviceDataView::GetNameDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->name.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void MediaStreamDeviceDataView::GetInputDataView(
    ::media::mojom::AudioParametersDataView* output) {
  auto pointer = data_->input.Get();
  *output = ::media::mojom::AudioParametersDataView(pointer, message_);
}
inline void MediaStreamDeviceDataView::GetSessionIdDataView(
    ::mojo_base::mojom::UnguessableTokenDataView* output) {
  auto pointer = data_->session_id.Get();
  *output = ::mojo_base::mojom::UnguessableTokenDataView(pointer, message_);
}
inline void MediaStreamDeviceDataView::GetDisplayMediaInfoDataView(
    ::media::mojom::DisplayMediaInformationDataView* output) {
  auto pointer = data_->display_media_info.Get();
  *output = ::media::mojom::DisplayMediaInformationDataView(pointer, message_);
}


inline void TrackControlsDataView::GetDeviceIdDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->device_id.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void StreamControlsDataView::GetAudioDataView(
    TrackControlsDataView* output) {
  auto pointer = data_->audio.Get();
  *output = TrackControlsDataView(pointer, message_);
}
inline void StreamControlsDataView::GetVideoDataView(
    TrackControlsDataView* output) {
  auto pointer = data_->video.Get();
  *output = TrackControlsDataView(pointer, message_);
}


inline void GetOpenDeviceResponseDataView::GetLabelDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->label.Get();
  *output = mojo::StringDataView(pointer, message_);
}
inline void GetOpenDeviceResponseDataView::GetDeviceDataView(
    MediaStreamDeviceDataView* output) {
  auto pointer = data_->device.Get();
  *output = MediaStreamDeviceDataView(pointer, message_);
}


inline void StreamDevicesDataView::GetAudioDeviceDataView(
    MediaStreamDeviceDataView* output) {
  auto pointer = data_->audio_device.Get();
  *output = MediaStreamDeviceDataView(pointer, message_);
}
inline void StreamDevicesDataView::GetVideoDeviceDataView(
    MediaStreamDeviceDataView* output) {
  auto pointer = data_->video_device.Get();
  *output = MediaStreamDeviceDataView(pointer, message_);
}


inline void StreamDevicesSetDataView::GetStreamDevicesDataView(
    mojo::ArrayDataView<StreamDevicesDataView>* output) {
  auto pointer = data_->stream_devices.Get();
  *output = mojo::ArrayDataView<StreamDevicesDataView>(pointer, message_);
}



}  // namespace mojom
}  // namespace blink

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::MediaStreamType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::MediaStreamType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::MediaStreamRequestResult> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::MediaStreamRequestResult value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::StreamSelectionStrategy> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::StreamSelectionStrategy value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TraceFormatTraits<::blink::mojom::MediaStreamStateChange> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::blink::mojom::MediaStreamStateChange value);
};

} // namespace perfetto

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_MEDIASTREAM_MEDIA_STREAM_MOJOM_SHARED_H_