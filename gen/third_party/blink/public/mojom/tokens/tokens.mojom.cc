// third_party/blink/public/mojom/tokens/tokens.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/tokens/tokens.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/tokens/tokens.mojom-params-data.h"
#include "third_party/blink/public/mojom/tokens/tokens.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/tokens/tokens.mojom-import-headers.h"
#include "third_party/blink/public/mojom/tokens/tokens.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_TOKENS_TOKENS_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace mojom {
LocalFrameToken::LocalFrameToken()
    : value() {}

LocalFrameToken::LocalFrameToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

LocalFrameToken::~LocalFrameToken() = default;

void LocalFrameToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LocalFrameToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
RemoteFrameToken::RemoteFrameToken()
    : value() {}

RemoteFrameToken::RemoteFrameToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

RemoteFrameToken::~RemoteFrameToken() = default;

void RemoteFrameToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool RemoteFrameToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DedicatedWorkerToken::DedicatedWorkerToken()
    : value() {}

DedicatedWorkerToken::DedicatedWorkerToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

DedicatedWorkerToken::~DedicatedWorkerToken() = default;

void DedicatedWorkerToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DedicatedWorkerToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ServiceWorkerToken::ServiceWorkerToken()
    : value() {}

ServiceWorkerToken::ServiceWorkerToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

ServiceWorkerToken::~ServiceWorkerToken() = default;

void ServiceWorkerToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ServiceWorkerToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
SharedWorkerToken::SharedWorkerToken()
    : value() {}

SharedWorkerToken::SharedWorkerToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

SharedWorkerToken::~SharedWorkerToken() = default;

void SharedWorkerToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SharedWorkerToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AnimationWorkletToken::AnimationWorkletToken()
    : value() {}

AnimationWorkletToken::AnimationWorkletToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

AnimationWorkletToken::~AnimationWorkletToken() = default;

void AnimationWorkletToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AnimationWorkletToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AudioWorkletToken::AudioWorkletToken()
    : value() {}

AudioWorkletToken::AudioWorkletToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

AudioWorkletToken::~AudioWorkletToken() = default;

void AudioWorkletToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AudioWorkletToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
LayoutWorkletToken::LayoutWorkletToken()
    : value() {}

LayoutWorkletToken::LayoutWorkletToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

LayoutWorkletToken::~LayoutWorkletToken() = default;

void LayoutWorkletToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool LayoutWorkletToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PaintWorkletToken::PaintWorkletToken()
    : value() {}

PaintWorkletToken::PaintWorkletToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

PaintWorkletToken::~PaintWorkletToken() = default;

void PaintWorkletToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PaintWorkletToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AttributionSrcToken::AttributionSrcToken()
    : value() {}

AttributionSrcToken::AttributionSrcToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

AttributionSrcToken::~AttributionSrcToken() = default;

void AttributionSrcToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionSrcToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
ClipboardSequenceNumberToken::ClipboardSequenceNumberToken()
    : value() {}

ClipboardSequenceNumberToken::ClipboardSequenceNumberToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

ClipboardSequenceNumberToken::~ClipboardSequenceNumberToken() = default;

void ClipboardSequenceNumberToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool ClipboardSequenceNumberToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
PortalToken::PortalToken()
    : value() {}

PortalToken::PortalToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

PortalToken::~PortalToken() = default;

void PortalToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PortalToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
V8ContextToken::V8ContextToken()
    : value() {}

V8ContextToken::V8ContextToken(
    const ::base::UnguessableToken& value_in)
    : value(std::move(value_in)) {}

V8ContextToken::~V8ContextToken() = default;

void V8ContextToken::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::base::UnguessableToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool V8ContextToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FrameToken::FrameToken() : tag_(Tag::kLocalFrameToken) {
  data_.local_frame_token = new ::blink::LocalFrameToken;
}

FrameToken::~FrameToken() {
  DestroyActive();
}


void FrameToken::set_local_frame_token(
    const ::blink::LocalFrameToken& local_frame_token) {
  if (tag_ == Tag::kLocalFrameToken) {
    *(data_.local_frame_token) = std::move(local_frame_token);
  } else {
    DestroyActive();
    tag_ = Tag::kLocalFrameToken;
    data_.local_frame_token = new ::blink::LocalFrameToken(
        std::move(local_frame_token));
  }
}
void FrameToken::set_remote_frame_token(
    const ::blink::RemoteFrameToken& remote_frame_token) {
  if (tag_ == Tag::kRemoteFrameToken) {
    *(data_.remote_frame_token) = std::move(remote_frame_token);
  } else {
    DestroyActive();
    tag_ = Tag::kRemoteFrameToken;
    data_.remote_frame_token = new ::blink::RemoteFrameToken(
        std::move(remote_frame_token));
  }
}

void FrameToken::DestroyActive() {
  switch (tag_) {

    case Tag::kLocalFrameToken:

      delete data_.local_frame_token;
      break;
    case Tag::kRemoteFrameToken:

      delete data_.remote_frame_token;
      break;
  }
}

bool FrameToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
WorkerToken::WorkerToken() : tag_(Tag::kDedicatedWorkerToken) {
  data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken;
}

WorkerToken::~WorkerToken() {
  DestroyActive();
}


void WorkerToken::set_dedicated_worker_token(
    const ::blink::DedicatedWorkerToken& dedicated_worker_token) {
  if (tag_ == Tag::kDedicatedWorkerToken) {
    *(data_.dedicated_worker_token) = std::move(dedicated_worker_token);
  } else {
    DestroyActive();
    tag_ = Tag::kDedicatedWorkerToken;
    data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken(
        std::move(dedicated_worker_token));
  }
}
void WorkerToken::set_service_worker_token(
    const ::blink::ServiceWorkerToken& service_worker_token) {
  if (tag_ == Tag::kServiceWorkerToken) {
    *(data_.service_worker_token) = std::move(service_worker_token);
  } else {
    DestroyActive();
    tag_ = Tag::kServiceWorkerToken;
    data_.service_worker_token = new ::blink::ServiceWorkerToken(
        std::move(service_worker_token));
  }
}
void WorkerToken::set_shared_worker_token(
    const ::blink::SharedWorkerToken& shared_worker_token) {
  if (tag_ == Tag::kSharedWorkerToken) {
    *(data_.shared_worker_token) = std::move(shared_worker_token);
  } else {
    DestroyActive();
    tag_ = Tag::kSharedWorkerToken;
    data_.shared_worker_token = new ::blink::SharedWorkerToken(
        std::move(shared_worker_token));
  }
}

void WorkerToken::DestroyActive() {
  switch (tag_) {

    case Tag::kDedicatedWorkerToken:

      delete data_.dedicated_worker_token;
      break;
    case Tag::kServiceWorkerToken:

      delete data_.service_worker_token;
      break;
    case Tag::kSharedWorkerToken:

      delete data_.shared_worker_token;
      break;
  }
}

bool WorkerToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
WorkletToken::WorkletToken() : tag_(Tag::kAnimationWorkletToken) {
  data_.animation_worklet_token = new ::blink::AnimationWorkletToken;
}

WorkletToken::~WorkletToken() {
  DestroyActive();
}


void WorkletToken::set_animation_worklet_token(
    const ::blink::AnimationWorkletToken& animation_worklet_token) {
  if (tag_ == Tag::kAnimationWorkletToken) {
    *(data_.animation_worklet_token) = std::move(animation_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kAnimationWorkletToken;
    data_.animation_worklet_token = new ::blink::AnimationWorkletToken(
        std::move(animation_worklet_token));
  }
}
void WorkletToken::set_audio_worklet_token(
    const ::blink::AudioWorkletToken& audio_worklet_token) {
  if (tag_ == Tag::kAudioWorkletToken) {
    *(data_.audio_worklet_token) = std::move(audio_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kAudioWorkletToken;
    data_.audio_worklet_token = new ::blink::AudioWorkletToken(
        std::move(audio_worklet_token));
  }
}
void WorkletToken::set_layout_worklet_token(
    LayoutWorkletTokenPtr layout_worklet_token) {
  if (tag_ == Tag::kLayoutWorkletToken) {
    *(data_.layout_worklet_token) = std::move(layout_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kLayoutWorkletToken;
    data_.layout_worklet_token = new LayoutWorkletTokenPtr(
        std::move(layout_worklet_token));
  }
}
void WorkletToken::set_paint_worklet_token(
    const ::blink::PaintWorkletToken& paint_worklet_token) {
  if (tag_ == Tag::kPaintWorkletToken) {
    *(data_.paint_worklet_token) = std::move(paint_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kPaintWorkletToken;
    data_.paint_worklet_token = new ::blink::PaintWorkletToken(
        std::move(paint_worklet_token));
  }
}

void WorkletToken::DestroyActive() {
  switch (tag_) {

    case Tag::kAnimationWorkletToken:

      delete data_.animation_worklet_token;
      break;
    case Tag::kAudioWorkletToken:

      delete data_.audio_worklet_token;
      break;
    case Tag::kLayoutWorkletToken:

      delete data_.layout_worklet_token;
      break;
    case Tag::kPaintWorkletToken:

      delete data_.paint_worklet_token;
      break;
  }
}

bool WorkletToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}
ExecutionContextToken::ExecutionContextToken() : tag_(Tag::kLocalFrameToken) {
  data_.local_frame_token = new ::blink::LocalFrameToken;
}

ExecutionContextToken::~ExecutionContextToken() {
  DestroyActive();
}


void ExecutionContextToken::set_local_frame_token(
    const ::blink::LocalFrameToken& local_frame_token) {
  if (tag_ == Tag::kLocalFrameToken) {
    *(data_.local_frame_token) = std::move(local_frame_token);
  } else {
    DestroyActive();
    tag_ = Tag::kLocalFrameToken;
    data_.local_frame_token = new ::blink::LocalFrameToken(
        std::move(local_frame_token));
  }
}
void ExecutionContextToken::set_dedicated_worker_token(
    const ::blink::DedicatedWorkerToken& dedicated_worker_token) {
  if (tag_ == Tag::kDedicatedWorkerToken) {
    *(data_.dedicated_worker_token) = std::move(dedicated_worker_token);
  } else {
    DestroyActive();
    tag_ = Tag::kDedicatedWorkerToken;
    data_.dedicated_worker_token = new ::blink::DedicatedWorkerToken(
        std::move(dedicated_worker_token));
  }
}
void ExecutionContextToken::set_service_worker_token(
    const ::blink::ServiceWorkerToken& service_worker_token) {
  if (tag_ == Tag::kServiceWorkerToken) {
    *(data_.service_worker_token) = std::move(service_worker_token);
  } else {
    DestroyActive();
    tag_ = Tag::kServiceWorkerToken;
    data_.service_worker_token = new ::blink::ServiceWorkerToken(
        std::move(service_worker_token));
  }
}
void ExecutionContextToken::set_shared_worker_token(
    const ::blink::SharedWorkerToken& shared_worker_token) {
  if (tag_ == Tag::kSharedWorkerToken) {
    *(data_.shared_worker_token) = std::move(shared_worker_token);
  } else {
    DestroyActive();
    tag_ = Tag::kSharedWorkerToken;
    data_.shared_worker_token = new ::blink::SharedWorkerToken(
        std::move(shared_worker_token));
  }
}
void ExecutionContextToken::set_animation_worklet_token(
    const ::blink::AnimationWorkletToken& animation_worklet_token) {
  if (tag_ == Tag::kAnimationWorkletToken) {
    *(data_.animation_worklet_token) = std::move(animation_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kAnimationWorkletToken;
    data_.animation_worklet_token = new ::blink::AnimationWorkletToken(
        std::move(animation_worklet_token));
  }
}
void ExecutionContextToken::set_audio_worklet_token(
    const ::blink::AudioWorkletToken& audio_worklet_token) {
  if (tag_ == Tag::kAudioWorkletToken) {
    *(data_.audio_worklet_token) = std::move(audio_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kAudioWorkletToken;
    data_.audio_worklet_token = new ::blink::AudioWorkletToken(
        std::move(audio_worklet_token));
  }
}
void ExecutionContextToken::set_layout_worklet_token(
    LayoutWorkletTokenPtr layout_worklet_token) {
  if (tag_ == Tag::kLayoutWorkletToken) {
    *(data_.layout_worklet_token) = std::move(layout_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kLayoutWorkletToken;
    data_.layout_worklet_token = new LayoutWorkletTokenPtr(
        std::move(layout_worklet_token));
  }
}
void ExecutionContextToken::set_paint_worklet_token(
    const ::blink::PaintWorkletToken& paint_worklet_token) {
  if (tag_ == Tag::kPaintWorkletToken) {
    *(data_.paint_worklet_token) = std::move(paint_worklet_token);
  } else {
    DestroyActive();
    tag_ = Tag::kPaintWorkletToken;
    data_.paint_worklet_token = new ::blink::PaintWorkletToken(
        std::move(paint_worklet_token));
  }
}

void ExecutionContextToken::DestroyActive() {
  switch (tag_) {

    case Tag::kLocalFrameToken:

      delete data_.local_frame_token;
      break;
    case Tag::kDedicatedWorkerToken:

      delete data_.dedicated_worker_token;
      break;
    case Tag::kServiceWorkerToken:

      delete data_.service_worker_token;
      break;
    case Tag::kSharedWorkerToken:

      delete data_.shared_worker_token;
      break;
    case Tag::kAnimationWorkletToken:

      delete data_.animation_worklet_token;
      break;
    case Tag::kAudioWorkletToken:

      delete data_.audio_worklet_token;
      break;
    case Tag::kLayoutWorkletToken:

      delete data_.layout_worklet_token;
      break;
    case Tag::kPaintWorkletToken:

      delete data_.paint_worklet_token;
      break;
  }
}

bool ExecutionContextToken::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context, false);
}


}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::LocalFrameToken::DataView, ::blink::mojom::LocalFrameTokenPtr>::Read(
    ::blink::mojom::LocalFrameToken::DataView input,
    ::blink::mojom::LocalFrameTokenPtr* output) {
  bool success = true;
  ::blink::mojom::LocalFrameTokenPtr result(::blink::mojom::LocalFrameToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::RemoteFrameToken::DataView, ::blink::mojom::RemoteFrameTokenPtr>::Read(
    ::blink::mojom::RemoteFrameToken::DataView input,
    ::blink::mojom::RemoteFrameTokenPtr* output) {
  bool success = true;
  ::blink::mojom::RemoteFrameTokenPtr result(::blink::mojom::RemoteFrameToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::DedicatedWorkerToken::DataView, ::blink::mojom::DedicatedWorkerTokenPtr>::Read(
    ::blink::mojom::DedicatedWorkerToken::DataView input,
    ::blink::mojom::DedicatedWorkerTokenPtr* output) {
  bool success = true;
  ::blink::mojom::DedicatedWorkerTokenPtr result(::blink::mojom::DedicatedWorkerToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::ServiceWorkerToken::DataView, ::blink::mojom::ServiceWorkerTokenPtr>::Read(
    ::blink::mojom::ServiceWorkerToken::DataView input,
    ::blink::mojom::ServiceWorkerTokenPtr* output) {
  bool success = true;
  ::blink::mojom::ServiceWorkerTokenPtr result(::blink::mojom::ServiceWorkerToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::SharedWorkerToken::DataView, ::blink::mojom::SharedWorkerTokenPtr>::Read(
    ::blink::mojom::SharedWorkerToken::DataView input,
    ::blink::mojom::SharedWorkerTokenPtr* output) {
  bool success = true;
  ::blink::mojom::SharedWorkerTokenPtr result(::blink::mojom::SharedWorkerToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AnimationWorkletToken::DataView, ::blink::mojom::AnimationWorkletTokenPtr>::Read(
    ::blink::mojom::AnimationWorkletToken::DataView input,
    ::blink::mojom::AnimationWorkletTokenPtr* output) {
  bool success = true;
  ::blink::mojom::AnimationWorkletTokenPtr result(::blink::mojom::AnimationWorkletToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AudioWorkletToken::DataView, ::blink::mojom::AudioWorkletTokenPtr>::Read(
    ::blink::mojom::AudioWorkletToken::DataView input,
    ::blink::mojom::AudioWorkletTokenPtr* output) {
  bool success = true;
  ::blink::mojom::AudioWorkletTokenPtr result(::blink::mojom::AudioWorkletToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::LayoutWorkletToken::DataView, ::blink::mojom::LayoutWorkletTokenPtr>::Read(
    ::blink::mojom::LayoutWorkletToken::DataView input,
    ::blink::mojom::LayoutWorkletTokenPtr* output) {
  bool success = true;
  ::blink::mojom::LayoutWorkletTokenPtr result(::blink::mojom::LayoutWorkletToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::PaintWorkletToken::DataView, ::blink::mojom::PaintWorkletTokenPtr>::Read(
    ::blink::mojom::PaintWorkletToken::DataView input,
    ::blink::mojom::PaintWorkletTokenPtr* output) {
  bool success = true;
  ::blink::mojom::PaintWorkletTokenPtr result(::blink::mojom::PaintWorkletToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AttributionSrcToken::DataView, ::blink::mojom::AttributionSrcTokenPtr>::Read(
    ::blink::mojom::AttributionSrcToken::DataView input,
    ::blink::mojom::AttributionSrcTokenPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionSrcTokenPtr result(::blink::mojom::AttributionSrcToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::ClipboardSequenceNumberToken::DataView, ::blink::mojom::ClipboardSequenceNumberTokenPtr>::Read(
    ::blink::mojom::ClipboardSequenceNumberToken::DataView input,
    ::blink::mojom::ClipboardSequenceNumberTokenPtr* output) {
  bool success = true;
  ::blink::mojom::ClipboardSequenceNumberTokenPtr result(::blink::mojom::ClipboardSequenceNumberToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::PortalToken::DataView, ::blink::mojom::PortalTokenPtr>::Read(
    ::blink::mojom::PortalToken::DataView input,
    ::blink::mojom::PortalTokenPtr* output) {
  bool success = true;
  ::blink::mojom::PortalTokenPtr result(::blink::mojom::PortalToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::V8ContextToken::DataView, ::blink::mojom::V8ContextTokenPtr>::Read(
    ::blink::mojom::V8ContextToken::DataView input,
    ::blink::mojom::V8ContextTokenPtr* output) {
  bool success = true;
  ::blink::mojom::V8ContextTokenPtr result(::blink::mojom::V8ContextToken::New());
  
      if (success && !input.ReadValue(&result->value))
        success = false;
  *output = std::move(result);
  return success;
}

// static
bool UnionTraits<::blink::mojom::FrameToken::DataView, ::blink::mojom::FrameTokenPtr>::Read(
    ::blink::mojom::FrameToken::DataView input,
    ::blink::mojom::FrameTokenPtr* output) {
  using UnionType = ::blink::mojom::FrameToken;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kLocalFrameToken: {
      ::blink::LocalFrameToken result_local_frame_token;
      if (!input.ReadLocalFrameToken(&result_local_frame_token))
        return false;

      *output = UnionType::NewLocalFrameToken(
          std::move(result_local_frame_token));
      break;
    }
    case Tag::kRemoteFrameToken: {
      ::blink::RemoteFrameToken result_remote_frame_token;
      if (!input.ReadRemoteFrameToken(&result_remote_frame_token))
        return false;

      *output = UnionType::NewRemoteFrameToken(
          std::move(result_remote_frame_token));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::WorkerToken::DataView, ::blink::mojom::WorkerTokenPtr>::Read(
    ::blink::mojom::WorkerToken::DataView input,
    ::blink::mojom::WorkerTokenPtr* output) {
  using UnionType = ::blink::mojom::WorkerToken;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kDedicatedWorkerToken: {
      ::blink::DedicatedWorkerToken result_dedicated_worker_token;
      if (!input.ReadDedicatedWorkerToken(&result_dedicated_worker_token))
        return false;

      *output = UnionType::NewDedicatedWorkerToken(
          std::move(result_dedicated_worker_token));
      break;
    }
    case Tag::kServiceWorkerToken: {
      ::blink::ServiceWorkerToken result_service_worker_token;
      if (!input.ReadServiceWorkerToken(&result_service_worker_token))
        return false;

      *output = UnionType::NewServiceWorkerToken(
          std::move(result_service_worker_token));
      break;
    }
    case Tag::kSharedWorkerToken: {
      ::blink::SharedWorkerToken result_shared_worker_token;
      if (!input.ReadSharedWorkerToken(&result_shared_worker_token))
        return false;

      *output = UnionType::NewSharedWorkerToken(
          std::move(result_shared_worker_token));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::WorkletToken::DataView, ::blink::mojom::WorkletTokenPtr>::Read(
    ::blink::mojom::WorkletToken::DataView input,
    ::blink::mojom::WorkletTokenPtr* output) {
  using UnionType = ::blink::mojom::WorkletToken;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kAnimationWorkletToken: {
      ::blink::AnimationWorkletToken result_animation_worklet_token;
      if (!input.ReadAnimationWorkletToken(&result_animation_worklet_token))
        return false;

      *output = UnionType::NewAnimationWorkletToken(
          std::move(result_animation_worklet_token));
      break;
    }
    case Tag::kAudioWorkletToken: {
      ::blink::AudioWorkletToken result_audio_worklet_token;
      if (!input.ReadAudioWorkletToken(&result_audio_worklet_token))
        return false;

      *output = UnionType::NewAudioWorkletToken(
          std::move(result_audio_worklet_token));
      break;
    }
    case Tag::kLayoutWorkletToken: {
      ::blink::mojom::LayoutWorkletTokenPtr result_layout_worklet_token;
      if (!input.ReadLayoutWorkletToken(&result_layout_worklet_token))
        return false;

      *output = UnionType::NewLayoutWorkletToken(
          std::move(result_layout_worklet_token));
      break;
    }
    case Tag::kPaintWorkletToken: {
      ::blink::PaintWorkletToken result_paint_worklet_token;
      if (!input.ReadPaintWorkletToken(&result_paint_worklet_token))
        return false;

      *output = UnionType::NewPaintWorkletToken(
          std::move(result_paint_worklet_token));
      break;
    }
    default:

      return false;
  }
  return true;
}

// static
bool UnionTraits<::blink::mojom::ExecutionContextToken::DataView, ::blink::mojom::ExecutionContextTokenPtr>::Read(
    ::blink::mojom::ExecutionContextToken::DataView input,
    ::blink::mojom::ExecutionContextTokenPtr* output) {
  using UnionType = ::blink::mojom::ExecutionContextToken;
  using Tag = UnionType::Tag;

  switch (input.tag()) {
    case Tag::kLocalFrameToken: {
      ::blink::LocalFrameToken result_local_frame_token;
      if (!input.ReadLocalFrameToken(&result_local_frame_token))
        return false;

      *output = UnionType::NewLocalFrameToken(
          std::move(result_local_frame_token));
      break;
    }
    case Tag::kDedicatedWorkerToken: {
      ::blink::DedicatedWorkerToken result_dedicated_worker_token;
      if (!input.ReadDedicatedWorkerToken(&result_dedicated_worker_token))
        return false;

      *output = UnionType::NewDedicatedWorkerToken(
          std::move(result_dedicated_worker_token));
      break;
    }
    case Tag::kServiceWorkerToken: {
      ::blink::ServiceWorkerToken result_service_worker_token;
      if (!input.ReadServiceWorkerToken(&result_service_worker_token))
        return false;

      *output = UnionType::NewServiceWorkerToken(
          std::move(result_service_worker_token));
      break;
    }
    case Tag::kSharedWorkerToken: {
      ::blink::SharedWorkerToken result_shared_worker_token;
      if (!input.ReadSharedWorkerToken(&result_shared_worker_token))
        return false;

      *output = UnionType::NewSharedWorkerToken(
          std::move(result_shared_worker_token));
      break;
    }
    case Tag::kAnimationWorkletToken: {
      ::blink::AnimationWorkletToken result_animation_worklet_token;
      if (!input.ReadAnimationWorkletToken(&result_animation_worklet_token))
        return false;

      *output = UnionType::NewAnimationWorkletToken(
          std::move(result_animation_worklet_token));
      break;
    }
    case Tag::kAudioWorkletToken: {
      ::blink::AudioWorkletToken result_audio_worklet_token;
      if (!input.ReadAudioWorkletToken(&result_audio_worklet_token))
        return false;

      *output = UnionType::NewAudioWorkletToken(
          std::move(result_audio_worklet_token));
      break;
    }
    case Tag::kLayoutWorkletToken: {
      ::blink::mojom::LayoutWorkletTokenPtr result_layout_worklet_token;
      if (!input.ReadLayoutWorkletToken(&result_layout_worklet_token))
        return false;

      *output = UnionType::NewLayoutWorkletToken(
          std::move(result_layout_worklet_token));
      break;
    }
    case Tag::kPaintWorkletToken: {
      ::blink::PaintWorkletToken result_paint_worklet_token;
      if (!input.ReadPaintWorkletToken(&result_paint_worklet_token))
        return false;

      *output = UnionType::NewPaintWorkletToken(
          std::move(result_paint_worklet_token));
      break;
    }
    default:

      return false;
  }
  return true;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {




}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif