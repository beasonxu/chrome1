// third_party/blink/public/mojom/frame/frame.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/frame/frame.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-params-data.h"
#include "third_party/blink/public/mojom/frame/frame.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/frame/frame.mojom-import-headers.h"
#include "third_party/blink/public/mojom/frame/frame.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_FRAME_FRAME_MOJOM_JUMBO_H_
#include "third_party/blink/common/permissions_policy/permissions_policy_mojom_traits.h"
#include "third_party/blink/public/common/messaging/cloneable_message_mojom_traits.h"
#include "third_party/blink/public/common/messaging/transferable_message_mojom_traits.h"
#endif



namespace blink {
namespace mojom {
SavableSubframe::SavableSubframe()
    : original_url(),
      subframe_token() {}

SavableSubframe::SavableSubframe(
    const ::GURL& original_url_in,
    const ::blink::FrameToken& subframe_token_in)
    : original_url(std::move(original_url_in)),
      subframe_token(std::move(subframe_token_in)) {}

SavableSubframe::~SavableSubframe() = default;

void SavableSubframe::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "original_url"), this->original_url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "subframe_token"), this->subframe_token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::blink::FrameToken&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool SavableSubframe::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
GetSavableResourceLinksReply::GetSavableResourceLinksReply()
    : resources_list(),
      referrer(),
      subframes() {}

GetSavableResourceLinksReply::GetSavableResourceLinksReply(
    std::vector<::GURL> resources_list_in,
    ::blink::mojom::ReferrerPtr referrer_in,
    std::vector<SavableSubframePtr> subframes_in)
    : resources_list(std::move(resources_list_in)),
      referrer(std::move(referrer_in)),
      subframes(std::move(subframes_in)) {}

GetSavableResourceLinksReply::~GetSavableResourceLinksReply() = default;

void GetSavableResourceLinksReply::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "resources_list"), this->resources_list,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<::GURL>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "referrer"), this->referrer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::ReferrerPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "subframes"), this->subframes,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<SavableSubframePtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool GetSavableResourceLinksReply::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
FindInPageResultAXParams::FindInPageResultAXParams()
    : request_id(),
      match_index(),
      start_id(),
      start_offset(),
      end_id(),
      end_offset() {}

FindInPageResultAXParams::FindInPageResultAXParams(
    int32_t request_id_in,
    int32_t match_index_in,
    int32_t start_id_in,
    int32_t start_offset_in,
    int32_t end_id_in,
    int32_t end_offset_in)
    : request_id(std::move(request_id_in)),
      match_index(std::move(match_index_in)),
      start_id(std::move(start_id_in)),
      start_offset(std::move(start_offset_in)),
      end_id(std::move(end_id_in)),
      end_offset(std::move(end_offset_in)) {}

FindInPageResultAXParams::~FindInPageResultAXParams() = default;
size_t FindInPageResultAXParams::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->request_id);
  seed = mojo::internal::Hash(seed, this->match_index);
  seed = mojo::internal::Hash(seed, this->start_id);
  seed = mojo::internal::Hash(seed, this->start_offset);
  seed = mojo::internal::Hash(seed, this->end_id);
  seed = mojo::internal::Hash(seed, this->end_offset);
  return seed;
}

void FindInPageResultAXParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "request_id"), this->request_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "match_index"), this->match_index,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "start_id"), this->start_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "start_offset"), this->start_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "end_id"), this->end_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "end_offset"), this->end_offset,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool FindInPageResultAXParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
DownloadURLParams::DownloadURLParams()
    : url(),
      referrer(),
      initiator_origin(),
      suggested_name(),
      cross_origin_redirects(),
      blob_url_token(),
      data_url_blob(),
      is_context_menu_save(false),
      has_user_gesture(false) {}

DownloadURLParams::DownloadURLParams(
    const ::GURL& url_in,
    ::blink::mojom::ReferrerPtr referrer_in,
    const absl::optional<::url::Origin>& initiator_origin_in,
    const absl::optional<::std::u16string>& suggested_name_in,
    ::network::mojom::RedirectMode cross_origin_redirects_in,
    ::mojo::PendingRemote<::blink::mojom::BlobURLToken> blob_url_token_in,
    ::mojo::PendingRemote<::blink::mojom::Blob> data_url_blob_in,
    bool is_context_menu_save_in,
    bool has_user_gesture_in)
    : url(std::move(url_in)),
      referrer(std::move(referrer_in)),
      initiator_origin(std::move(initiator_origin_in)),
      suggested_name(std::move(suggested_name_in)),
      cross_origin_redirects(std::move(cross_origin_redirects_in)),
      blob_url_token(std::move(blob_url_token_in)),
      data_url_blob(std::move(data_url_blob_in)),
      is_context_menu_save(std::move(is_context_menu_save_in)),
      has_user_gesture(std::move(has_user_gesture_in)) {}

DownloadURLParams::~DownloadURLParams() = default;

void DownloadURLParams::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::GURL&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "referrer"), this->referrer,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::blink::mojom::ReferrerPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "initiator_origin"), this->initiator_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::url::Origin>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "suggested_name"), this->suggested_name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<::std::u16string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "cross_origin_redirects"), this->cross_origin_redirects,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::RedirectMode>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "blob_url_token"), this->blob_url_token,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::blink::mojom::BlobURLToken>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data_url_blob"), this->data_url_blob,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::mojo::PendingRemote<::blink::mojom::Blob>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "is_context_menu_save"), this->is_context_menu_save,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "has_user_gesture"), this->has_user_gesture,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool DownloadURLParams::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
IframeAttributes::IframeAttributes()
    : parsed_csp_attribute(),
      anonymous(),
      id(),
      name(),
      src() {}

IframeAttributes::IframeAttributes(
    ::network::mojom::ContentSecurityPolicyPtr parsed_csp_attribute_in,
    bool anonymous_in,
    const std::string& id_in,
    const std::string& name_in,
    const std::string& src_in)
    : parsed_csp_attribute(std::move(parsed_csp_attribute_in)),
      anonymous(std::move(anonymous_in)),
      id(std::move(id_in)),
      name(std::move(name_in)),
      src(std::move(src_in)) {}

IframeAttributes::~IframeAttributes() = default;

void IframeAttributes::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "parsed_csp_attribute"), this->parsed_csp_attribute,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type ::network::mojom::ContentSecurityPolicyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "anonymous"), this->anonymous,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type bool>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "id"), this->id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "name"), this->name,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "src"), this->src,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool IframeAttributes::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char KeepAliveHandle::Name_[] = "blink.mojom.KeepAliveHandle";

KeepAliveHandle::IPCStableHashFunction KeepAliveHandle::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* KeepAliveHandle::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
# endif // !BUILDFLAG(IS_FUCHSIA)

KeepAliveHandleProxy::KeepAliveHandleProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

// static
bool KeepAliveHandleStubDispatch::Accept(
    KeepAliveHandle* impl,
    mojo::Message* message) {
  return false;
}

// static
bool KeepAliveHandleStubDispatch::AcceptWithResponder(
    KeepAliveHandle* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  return false;
}



bool KeepAliveHandleRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::KeepAliveHandle::Name_;
  return mojo::internal::ValidateRequestGeneric(message, name, {});
}

const char KeepAliveHandleFactory::Name_[] = "blink.mojom.KeepAliveHandleFactory";

KeepAliveHandleFactory::IPCStableHashFunction KeepAliveHandleFactory::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kKeepAliveHandleFactory_IssueKeepAliveHandle_Name: {
      return &KeepAliveHandleFactory::IssueKeepAliveHandle_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* KeepAliveHandleFactory::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kKeepAliveHandleFactory_IssueKeepAliveHandle_Name:
            return "Receive blink::mojom::KeepAliveHandleFactory::IssueKeepAliveHandle";
    }
  } else {
    switch (message.name()) {
      case internal::kKeepAliveHandleFactory_IssueKeepAliveHandle_Name:
            return "Receive reply blink::mojom::KeepAliveHandleFactory::IssueKeepAliveHandle";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t KeepAliveHandleFactory::IssueKeepAliveHandle_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::KeepAliveHandleFactory::IssueKeepAliveHandle");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

KeepAliveHandleFactoryProxy::KeepAliveHandleFactoryProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void KeepAliveHandleFactoryProxy::IssueKeepAliveHandle(
    ::mojo::PendingReceiver<KeepAliveHandle> in_keep_alive_handle) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::KeepAliveHandleFactory::IssueKeepAliveHandle", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("keep_alive_handle"), in_keep_alive_handle,
                        "<value of type ::mojo::PendingReceiver<KeepAliveHandle>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kKeepAliveHandleFactory_IssueKeepAliveHandle_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::KeepAliveHandleFactory_IssueKeepAliveHandle_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::KeepAliveHandleInterfaceBase>>(
      in_keep_alive_handle, &params->keep_alive_handle, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->keep_alive_handle),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid keep_alive_handle in KeepAliveHandleFactory.IssueKeepAliveHandle request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(KeepAliveHandleFactory::Name_);
  message.set_method_name("IssueKeepAliveHandle");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool KeepAliveHandleFactoryStubDispatch::Accept(
    KeepAliveHandleFactory* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kKeepAliveHandleFactory_IssueKeepAliveHandle_Name: {

      DCHECK(message->is_serialized());
      internal::KeepAliveHandleFactory_IssueKeepAliveHandle_Params_Data* params =
          reinterpret_cast<internal::KeepAliveHandleFactory_IssueKeepAliveHandle_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<KeepAliveHandle> p_keep_alive_handle{};
      KeepAliveHandleFactory_IssueKeepAliveHandle_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_keep_alive_handle =
            input_data_view.TakeKeepAliveHandle<decltype(p_keep_alive_handle)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            KeepAliveHandleFactory::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->IssueKeepAliveHandle(
std::move(p_keep_alive_handle));
      return true;
    }
  }
  return false;
}

// static
bool KeepAliveHandleFactoryStubDispatch::AcceptWithResponder(
    KeepAliveHandleFactory* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kKeepAliveHandleFactory_IssueKeepAliveHandle_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kKeepAliveHandleFactoryValidationInfo[] = {
    {&internal::KeepAliveHandleFactory_IssueKeepAliveHandle_Params_Data::Validate,
     nullptr /* no response */},
};

bool KeepAliveHandleFactoryRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::KeepAliveHandleFactory::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kKeepAliveHandleFactoryValidationInfo);
}

const char LocalFrameHost::Name_[] = "blink.mojom.LocalFrameHost";

LocalFrameHost::IPCStableHashFunction LocalFrameHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kLocalFrameHost_EnterFullscreen_Name: {
      return &LocalFrameHost::EnterFullscreen_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_ExitFullscreen_Name: {
      return &LocalFrameHost::ExitFullscreen_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_FullscreenStateChanged_Name: {
      return &LocalFrameHost::FullscreenStateChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_RegisterProtocolHandler_Name: {
      return &LocalFrameHost::RegisterProtocolHandler_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_UnregisterProtocolHandler_Name: {
      return &LocalFrameHost::UnregisterProtocolHandler_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidDisplayInsecureContent_Name: {
      return &LocalFrameHost::DidDisplayInsecureContent_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidContainInsecureFormAction_Name: {
      return &LocalFrameHost::DidContainInsecureFormAction_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_MainDocumentElementAvailable_Name: {
      return &LocalFrameHost::MainDocumentElementAvailable_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name: {
      return &LocalFrameHost::SetNeedsOcclusionTracking_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_SetVirtualKeyboardOverlayPolicy_Name: {
      return &LocalFrameHost::SetVirtualKeyboardOverlayPolicy_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_VisibilityChanged_Name: {
      return &LocalFrameHost::VisibilityChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeThemeColor_Name: {
      return &LocalFrameHost::DidChangeThemeColor_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeBackgroundColor_Name: {
      return &LocalFrameHost::DidChangeBackgroundColor_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidFailLoadWithError_Name: {
      return &LocalFrameHost::DidFailLoadWithError_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidFocusFrame_Name: {
      return &LocalFrameHost::DidFocusFrame_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidCallFocus_Name: {
      return &LocalFrameHost::DidCallFocus_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name: {
      return &LocalFrameHost::EnforceInsecureRequestPolicy_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name: {
      return &LocalFrameHost::EnforceInsecureNavigationsSet_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name: {
      return &LocalFrameHost::SuddenTerminationDisablerChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name: {
      return &LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name: {
      return &LocalFrameHost::ScrollRectToVisibleInParentFrame_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name: {
      return &LocalFrameHost::BubbleLogicalScrollInParentFrame_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidBlockNavigation_Name: {
      return &LocalFrameHost::DidBlockNavigation_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeLoadProgress_Name: {
      return &LocalFrameHost::DidChangeLoadProgress_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidFinishLoad_Name: {
      return &LocalFrameHost::DidFinishLoad_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DispatchLoad_Name: {
      return &LocalFrameHost::DispatchLoad_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_GoToEntryAtOffset_Name: {
      return &LocalFrameHost::GoToEntryAtOffset_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_NavigateToNavigationApiKey_Name: {
      return &LocalFrameHost::NavigateToNavigationApiKey_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_UpdateTitle_Name: {
      return &LocalFrameHost::UpdateTitle_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_UpdateUserActivationState_Name: {
      return &LocalFrameHost::UpdateUserActivationState_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name: {
      return &LocalFrameHost::HandleAccessibilityFindInPageResult_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name: {
      return &LocalFrameHost::HandleAccessibilityFindInPageTermination_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name: {
      return &LocalFrameHost::DocumentOnLoadCompleted_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name: {
      return &LocalFrameHost::ForwardResourceTimingToParent_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidDispatchDOMContentLoadedEvent_Name: {
      return &LocalFrameHost::DidDispatchDOMContentLoadedEvent_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_RunModalAlertDialog_Name: {
      return &LocalFrameHost::RunModalAlertDialog_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_RunModalConfirmDialog_Name: {
      return &LocalFrameHost::RunModalConfirmDialog_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_RunModalPromptDialog_Name: {
      return &LocalFrameHost::RunModalPromptDialog_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name: {
      return &LocalFrameHost::RunBeforeUnloadConfirm_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_UpdateFaviconURL_Name: {
      return &LocalFrameHost::UpdateFaviconURL_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DownloadURL_Name: {
      return &LocalFrameHost::DownloadURL_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_FocusedElementChanged_Name: {
      return &LocalFrameHost::FocusedElementChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_TextSelectionChanged_Name: {
      return &LocalFrameHost::TextSelectionChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_ShowPopupMenu_Name: {
      return &LocalFrameHost::ShowPopupMenu_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_CreateNewPopupWidget_Name: {
      return &LocalFrameHost::CreateNewPopupWidget_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_ShowContextMenu_Name: {
      return &LocalFrameHost::ShowContextMenu_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidLoadResourceFromMemoryCache_Name: {
      return &LocalFrameHost::DidLoadResourceFromMemoryCache_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeFrameOwnerProperties_Name: {
      return &LocalFrameHost::DidChangeFrameOwnerProperties_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeOpener_Name: {
      return &LocalFrameHost::DidChangeOpener_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeFramePolicy_Name: {
      return &LocalFrameHost::DidChangeFramePolicy_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeIframeAttributes_Name: {
      return &LocalFrameHost::DidChangeIframeAttributes_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_CapturePaintPreviewOfSubframe_Name: {
      return &LocalFrameHost::CapturePaintPreviewOfSubframe_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_SetCloseListener_Name: {
      return &LocalFrameHost::SetCloseListener_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_Detach_Name: {
      return &LocalFrameHost::Detach_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_GetKeepAliveHandleFactory_Name: {
      return &LocalFrameHost::GetKeepAliveHandleFactory_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidAddMessageToConsole_Name: {
      return &LocalFrameHost::DidAddMessageToConsole_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_FrameSizeChanged_Name: {
      return &LocalFrameHost::FrameSizeChanged_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidInferColorScheme_Name: {
      return &LocalFrameHost::DidInferColorScheme_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_DidChangeSrcDoc_Name: {
      return &LocalFrameHost::DidChangeSrcDoc_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_ReceivedDelegatedCapability_Name: {
      return &LocalFrameHost::ReceivedDelegatedCapability_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_CreatePortal_Name: {
      return &LocalFrameHost::CreatePortal_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_AdoptPortal_Name: {
      return &LocalFrameHost::AdoptPortal_Sym::IPCStableHash;
    }
    case internal::kLocalFrameHost_CreateFencedFrame_Name: {
      return &LocalFrameHost::CreateFencedFrame_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* LocalFrameHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kLocalFrameHost_EnterFullscreen_Name:
            return "Receive blink::mojom::LocalFrameHost::EnterFullscreen";
      case internal::kLocalFrameHost_ExitFullscreen_Name:
            return "Receive blink::mojom::LocalFrameHost::ExitFullscreen";
      case internal::kLocalFrameHost_FullscreenStateChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::FullscreenStateChanged";
      case internal::kLocalFrameHost_RegisterProtocolHandler_Name:
            return "Receive blink::mojom::LocalFrameHost::RegisterProtocolHandler";
      case internal::kLocalFrameHost_UnregisterProtocolHandler_Name:
            return "Receive blink::mojom::LocalFrameHost::UnregisterProtocolHandler";
      case internal::kLocalFrameHost_DidDisplayInsecureContent_Name:
            return "Receive blink::mojom::LocalFrameHost::DidDisplayInsecureContent";
      case internal::kLocalFrameHost_DidContainInsecureFormAction_Name:
            return "Receive blink::mojom::LocalFrameHost::DidContainInsecureFormAction";
      case internal::kLocalFrameHost_MainDocumentElementAvailable_Name:
            return "Receive blink::mojom::LocalFrameHost::MainDocumentElementAvailable";
      case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name:
            return "Receive blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking";
      case internal::kLocalFrameHost_SetVirtualKeyboardOverlayPolicy_Name:
            return "Receive blink::mojom::LocalFrameHost::SetVirtualKeyboardOverlayPolicy";
      case internal::kLocalFrameHost_VisibilityChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::VisibilityChanged";
      case internal::kLocalFrameHost_DidChangeThemeColor_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeThemeColor";
      case internal::kLocalFrameHost_DidChangeBackgroundColor_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeBackgroundColor";
      case internal::kLocalFrameHost_DidFailLoadWithError_Name:
            return "Receive blink::mojom::LocalFrameHost::DidFailLoadWithError";
      case internal::kLocalFrameHost_DidFocusFrame_Name:
            return "Receive blink::mojom::LocalFrameHost::DidFocusFrame";
      case internal::kLocalFrameHost_DidCallFocus_Name:
            return "Receive blink::mojom::LocalFrameHost::DidCallFocus";
      case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name:
            return "Receive blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy";
      case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name:
            return "Receive blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet";
      case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged";
      case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged";
      case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name:
            return "Receive blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame";
      case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name:
            return "Receive blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame";
      case internal::kLocalFrameHost_DidBlockNavigation_Name:
            return "Receive blink::mojom::LocalFrameHost::DidBlockNavigation";
      case internal::kLocalFrameHost_DidChangeLoadProgress_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeLoadProgress";
      case internal::kLocalFrameHost_DidFinishLoad_Name:
            return "Receive blink::mojom::LocalFrameHost::DidFinishLoad";
      case internal::kLocalFrameHost_DispatchLoad_Name:
            return "Receive blink::mojom::LocalFrameHost::DispatchLoad";
      case internal::kLocalFrameHost_GoToEntryAtOffset_Name:
            return "Receive blink::mojom::LocalFrameHost::GoToEntryAtOffset";
      case internal::kLocalFrameHost_NavigateToNavigationApiKey_Name:
            return "Receive blink::mojom::LocalFrameHost::NavigateToNavigationApiKey";
      case internal::kLocalFrameHost_UpdateTitle_Name:
            return "Receive blink::mojom::LocalFrameHost::UpdateTitle";
      case internal::kLocalFrameHost_UpdateUserActivationState_Name:
            return "Receive blink::mojom::LocalFrameHost::UpdateUserActivationState";
      case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name:
            return "Receive blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult";
      case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name:
            return "Receive blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination";
      case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name:
            return "Receive blink::mojom::LocalFrameHost::DocumentOnLoadCompleted";
      case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name:
            return "Receive blink::mojom::LocalFrameHost::ForwardResourceTimingToParent";
      case internal::kLocalFrameHost_DidDispatchDOMContentLoadedEvent_Name:
            return "Receive blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent";
      case internal::kLocalFrameHost_RunModalAlertDialog_Name:
            return "Receive blink::mojom::LocalFrameHost::RunModalAlertDialog";
      case internal::kLocalFrameHost_RunModalConfirmDialog_Name:
            return "Receive blink::mojom::LocalFrameHost::RunModalConfirmDialog";
      case internal::kLocalFrameHost_RunModalPromptDialog_Name:
            return "Receive blink::mojom::LocalFrameHost::RunModalPromptDialog";
      case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name:
            return "Receive blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm";
      case internal::kLocalFrameHost_UpdateFaviconURL_Name:
            return "Receive blink::mojom::LocalFrameHost::UpdateFaviconURL";
      case internal::kLocalFrameHost_DownloadURL_Name:
            return "Receive blink::mojom::LocalFrameHost::DownloadURL";
      case internal::kLocalFrameHost_FocusedElementChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::FocusedElementChanged";
      case internal::kLocalFrameHost_TextSelectionChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::TextSelectionChanged";
      case internal::kLocalFrameHost_ShowPopupMenu_Name:
            return "Receive blink::mojom::LocalFrameHost::ShowPopupMenu";
      case internal::kLocalFrameHost_CreateNewPopupWidget_Name:
            return "Receive blink::mojom::LocalFrameHost::CreateNewPopupWidget";
      case internal::kLocalFrameHost_ShowContextMenu_Name:
            return "Receive blink::mojom::LocalFrameHost::ShowContextMenu";
      case internal::kLocalFrameHost_DidLoadResourceFromMemoryCache_Name:
            return "Receive blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache";
      case internal::kLocalFrameHost_DidChangeFrameOwnerProperties_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties";
      case internal::kLocalFrameHost_DidChangeOpener_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeOpener";
      case internal::kLocalFrameHost_DidChangeFramePolicy_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeFramePolicy";
      case internal::kLocalFrameHost_DidChangeIframeAttributes_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeIframeAttributes";
      case internal::kLocalFrameHost_CapturePaintPreviewOfSubframe_Name:
            return "Receive blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe";
      case internal::kLocalFrameHost_SetCloseListener_Name:
            return "Receive blink::mojom::LocalFrameHost::SetCloseListener";
      case internal::kLocalFrameHost_Detach_Name:
            return "Receive blink::mojom::LocalFrameHost::Detach";
      case internal::kLocalFrameHost_GetKeepAliveHandleFactory_Name:
            return "Receive blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory";
      case internal::kLocalFrameHost_DidAddMessageToConsole_Name:
            return "Receive blink::mojom::LocalFrameHost::DidAddMessageToConsole";
      case internal::kLocalFrameHost_FrameSizeChanged_Name:
            return "Receive blink::mojom::LocalFrameHost::FrameSizeChanged";
      case internal::kLocalFrameHost_DidInferColorScheme_Name:
            return "Receive blink::mojom::LocalFrameHost::DidInferColorScheme";
      case internal::kLocalFrameHost_DidChangeSrcDoc_Name:
            return "Receive blink::mojom::LocalFrameHost::DidChangeSrcDoc";
      case internal::kLocalFrameHost_ReceivedDelegatedCapability_Name:
            return "Receive blink::mojom::LocalFrameHost::ReceivedDelegatedCapability";
      case internal::kLocalFrameHost_CreatePortal_Name:
            return "Receive blink::mojom::LocalFrameHost::CreatePortal";
      case internal::kLocalFrameHost_AdoptPortal_Name:
            return "Receive blink::mojom::LocalFrameHost::AdoptPortal";
      case internal::kLocalFrameHost_CreateFencedFrame_Name:
            return "Receive blink::mojom::LocalFrameHost::CreateFencedFrame";
    }
  } else {
    switch (message.name()) {
      case internal::kLocalFrameHost_EnterFullscreen_Name:
            return "Receive reply blink::mojom::LocalFrameHost::EnterFullscreen";
      case internal::kLocalFrameHost_ExitFullscreen_Name:
            return "Receive reply blink::mojom::LocalFrameHost::ExitFullscreen";
      case internal::kLocalFrameHost_FullscreenStateChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::FullscreenStateChanged";
      case internal::kLocalFrameHost_RegisterProtocolHandler_Name:
            return "Receive reply blink::mojom::LocalFrameHost::RegisterProtocolHandler";
      case internal::kLocalFrameHost_UnregisterProtocolHandler_Name:
            return "Receive reply blink::mojom::LocalFrameHost::UnregisterProtocolHandler";
      case internal::kLocalFrameHost_DidDisplayInsecureContent_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidDisplayInsecureContent";
      case internal::kLocalFrameHost_DidContainInsecureFormAction_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidContainInsecureFormAction";
      case internal::kLocalFrameHost_MainDocumentElementAvailable_Name:
            return "Receive reply blink::mojom::LocalFrameHost::MainDocumentElementAvailable";
      case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name:
            return "Receive reply blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking";
      case internal::kLocalFrameHost_SetVirtualKeyboardOverlayPolicy_Name:
            return "Receive reply blink::mojom::LocalFrameHost::SetVirtualKeyboardOverlayPolicy";
      case internal::kLocalFrameHost_VisibilityChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::VisibilityChanged";
      case internal::kLocalFrameHost_DidChangeThemeColor_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeThemeColor";
      case internal::kLocalFrameHost_DidChangeBackgroundColor_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeBackgroundColor";
      case internal::kLocalFrameHost_DidFailLoadWithError_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidFailLoadWithError";
      case internal::kLocalFrameHost_DidFocusFrame_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidFocusFrame";
      case internal::kLocalFrameHost_DidCallFocus_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidCallFocus";
      case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name:
            return "Receive reply blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy";
      case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name:
            return "Receive reply blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet";
      case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged";
      case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged";
      case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name:
            return "Receive reply blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame";
      case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name:
            return "Receive reply blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame";
      case internal::kLocalFrameHost_DidBlockNavigation_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidBlockNavigation";
      case internal::kLocalFrameHost_DidChangeLoadProgress_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeLoadProgress";
      case internal::kLocalFrameHost_DidFinishLoad_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidFinishLoad";
      case internal::kLocalFrameHost_DispatchLoad_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DispatchLoad";
      case internal::kLocalFrameHost_GoToEntryAtOffset_Name:
            return "Receive reply blink::mojom::LocalFrameHost::GoToEntryAtOffset";
      case internal::kLocalFrameHost_NavigateToNavigationApiKey_Name:
            return "Receive reply blink::mojom::LocalFrameHost::NavigateToNavigationApiKey";
      case internal::kLocalFrameHost_UpdateTitle_Name:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateTitle";
      case internal::kLocalFrameHost_UpdateUserActivationState_Name:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateUserActivationState";
      case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name:
            return "Receive reply blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult";
      case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name:
            return "Receive reply blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination";
      case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DocumentOnLoadCompleted";
      case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name:
            return "Receive reply blink::mojom::LocalFrameHost::ForwardResourceTimingToParent";
      case internal::kLocalFrameHost_DidDispatchDOMContentLoadedEvent_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent";
      case internal::kLocalFrameHost_RunModalAlertDialog_Name:
            return "Receive reply blink::mojom::LocalFrameHost::RunModalAlertDialog";
      case internal::kLocalFrameHost_RunModalConfirmDialog_Name:
            return "Receive reply blink::mojom::LocalFrameHost::RunModalConfirmDialog";
      case internal::kLocalFrameHost_RunModalPromptDialog_Name:
            return "Receive reply blink::mojom::LocalFrameHost::RunModalPromptDialog";
      case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name:
            return "Receive reply blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm";
      case internal::kLocalFrameHost_UpdateFaviconURL_Name:
            return "Receive reply blink::mojom::LocalFrameHost::UpdateFaviconURL";
      case internal::kLocalFrameHost_DownloadURL_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DownloadURL";
      case internal::kLocalFrameHost_FocusedElementChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::FocusedElementChanged";
      case internal::kLocalFrameHost_TextSelectionChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::TextSelectionChanged";
      case internal::kLocalFrameHost_ShowPopupMenu_Name:
            return "Receive reply blink::mojom::LocalFrameHost::ShowPopupMenu";
      case internal::kLocalFrameHost_CreateNewPopupWidget_Name:
            return "Receive reply blink::mojom::LocalFrameHost::CreateNewPopupWidget";
      case internal::kLocalFrameHost_ShowContextMenu_Name:
            return "Receive reply blink::mojom::LocalFrameHost::ShowContextMenu";
      case internal::kLocalFrameHost_DidLoadResourceFromMemoryCache_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache";
      case internal::kLocalFrameHost_DidChangeFrameOwnerProperties_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties";
      case internal::kLocalFrameHost_DidChangeOpener_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeOpener";
      case internal::kLocalFrameHost_DidChangeFramePolicy_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeFramePolicy";
      case internal::kLocalFrameHost_DidChangeIframeAttributes_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeIframeAttributes";
      case internal::kLocalFrameHost_CapturePaintPreviewOfSubframe_Name:
            return "Receive reply blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe";
      case internal::kLocalFrameHost_SetCloseListener_Name:
            return "Receive reply blink::mojom::LocalFrameHost::SetCloseListener";
      case internal::kLocalFrameHost_Detach_Name:
            return "Receive reply blink::mojom::LocalFrameHost::Detach";
      case internal::kLocalFrameHost_GetKeepAliveHandleFactory_Name:
            return "Receive reply blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory";
      case internal::kLocalFrameHost_DidAddMessageToConsole_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidAddMessageToConsole";
      case internal::kLocalFrameHost_FrameSizeChanged_Name:
            return "Receive reply blink::mojom::LocalFrameHost::FrameSizeChanged";
      case internal::kLocalFrameHost_DidInferColorScheme_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidInferColorScheme";
      case internal::kLocalFrameHost_DidChangeSrcDoc_Name:
            return "Receive reply blink::mojom::LocalFrameHost::DidChangeSrcDoc";
      case internal::kLocalFrameHost_ReceivedDelegatedCapability_Name:
            return "Receive reply blink::mojom::LocalFrameHost::ReceivedDelegatedCapability";
      case internal::kLocalFrameHost_CreatePortal_Name:
            return "Receive reply blink::mojom::LocalFrameHost::CreatePortal";
      case internal::kLocalFrameHost_AdoptPortal_Name:
            return "Receive reply blink::mojom::LocalFrameHost::AdoptPortal";
      case internal::kLocalFrameHost_CreateFencedFrame_Name:
            return "Receive reply blink::mojom::LocalFrameHost::CreateFencedFrame";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalFrameHost::EnterFullscreen_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::EnterFullscreen");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::ExitFullscreen_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::ExitFullscreen");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::FullscreenStateChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::FullscreenStateChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::RegisterProtocolHandler_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::RegisterProtocolHandler");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::UnregisterProtocolHandler_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::UnregisterProtocolHandler");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidDisplayInsecureContent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidDisplayInsecureContent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidContainInsecureFormAction_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidContainInsecureFormAction");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::MainDocumentElementAvailable_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::MainDocumentElementAvailable");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::SetNeedsOcclusionTracking_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::SetVirtualKeyboardOverlayPolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::SetVirtualKeyboardOverlayPolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::VisibilityChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::VisibilityChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeThemeColor_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeThemeColor");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeBackgroundColor_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeBackgroundColor");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidFailLoadWithError_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidFailLoadWithError");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidFocusFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidFocusFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidCallFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidCallFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::EnforceInsecureRequestPolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::EnforceInsecureNavigationsSet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::SuddenTerminationDisablerChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::ScrollRectToVisibleInParentFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::BubbleLogicalScrollInParentFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidBlockNavigation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidBlockNavigation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeLoadProgress_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeLoadProgress");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidFinishLoad_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidFinishLoad");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DispatchLoad_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DispatchLoad");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::GoToEntryAtOffset_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::GoToEntryAtOffset");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::NavigateToNavigationApiKey_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::NavigateToNavigationApiKey");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::UpdateTitle_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::UpdateTitle");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::UpdateUserActivationState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::UpdateUserActivationState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::HandleAccessibilityFindInPageResult_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::HandleAccessibilityFindInPageTermination_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DocumentOnLoadCompleted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DocumentOnLoadCompleted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::ForwardResourceTimingToParent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::ForwardResourceTimingToParent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidDispatchDOMContentLoadedEvent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::RunModalAlertDialog_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::RunModalAlertDialog");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::RunModalConfirmDialog_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::RunModalConfirmDialog");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::RunModalPromptDialog_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::RunModalPromptDialog");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::RunBeforeUnloadConfirm_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::UpdateFaviconURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::UpdateFaviconURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DownloadURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DownloadURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::FocusedElementChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::FocusedElementChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::TextSelectionChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::TextSelectionChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::ShowPopupMenu_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::ShowPopupMenu");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::CreateNewPopupWidget_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::CreateNewPopupWidget");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::ShowContextMenu_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::ShowContextMenu");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidLoadResourceFromMemoryCache_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeFrameOwnerProperties_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeOpener_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeOpener");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeFramePolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeFramePolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeIframeAttributes_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeIframeAttributes");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::CapturePaintPreviewOfSubframe_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::SetCloseListener_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::SetCloseListener");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::Detach_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::Detach");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::GetKeepAliveHandleFactory_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidAddMessageToConsole_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidAddMessageToConsole");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::FrameSizeChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::FrameSizeChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidInferColorScheme_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidInferColorScheme");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::DidChangeSrcDoc_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::DidChangeSrcDoc");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::ReceivedDelegatedCapability_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::ReceivedDelegatedCapability");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::CreatePortal_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::CreatePortal");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::AdoptPortal_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::AdoptPortal");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrameHost::CreateFencedFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrameHost::CreateFencedFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)
bool LocalFrameHost::RunModalAlertDialog(const ::std::u16string& alert_message, bool disable_third_party_subframe_suppresion) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::RunModalConfirmDialog(const ::std::u16string& alert_message, bool disable_third_party_subframe_suppresion, bool* out_success) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::RunModalPromptDialog(const ::std::u16string& alert_message, const ::std::u16string& default_value, bool disable_third_party_subframe_suppresion, bool* out_success, ::std::u16string* out_result) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::RunBeforeUnloadConfirm(bool is_reload, bool* out_success) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::CreatePortal(::mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, ::blink::mojom::FrameReplicationStatePtr* out_initial_replicated_state, ::blink::PortalToken* out_portal_token, ::blink::RemoteFrameToken* out_frame_token, ::base::UnguessableToken* out_devtools_frame_token) {
  NOTREACHED();
  return false;
}
bool LocalFrameHost::AdoptPortal(const ::blink::PortalToken& portal_token, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, ::blink::mojom::FrameReplicationStatePtr* out_replicated_state, ::blink::RemoteFrameToken* out_frame_token, ::base::UnguessableToken* out_devtools_frame_token) {
  NOTREACHED();
  return false;
}

class LocalFrameHost_EnterFullscreen_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_EnterFullscreen_ForwardToCallback(
      LocalFrameHost::EnterFullscreenCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_EnterFullscreen_ForwardToCallback(const LocalFrameHost_EnterFullscreen_ForwardToCallback&) = delete;
  LocalFrameHost_EnterFullscreen_ForwardToCallback& operator=(const LocalFrameHost_EnterFullscreen_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::EnterFullscreenCallback callback_;
};
class LocalFrameHost_RunModalAlertDialog_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(
      bool* result)
      : result_(result) {
    DCHECK(!*result_);
  }

  LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(const LocalFrameHost_RunModalAlertDialog_HandleSyncResponse&) = delete;
  LocalFrameHost_RunModalAlertDialog_HandleSyncResponse& operator=(const LocalFrameHost_RunModalAlertDialog_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;};

class LocalFrameHost_RunModalAlertDialog_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalAlertDialog_ForwardToCallback(
      LocalFrameHost::RunModalAlertDialogCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_RunModalAlertDialog_ForwardToCallback(const LocalFrameHost_RunModalAlertDialog_ForwardToCallback&) = delete;
  LocalFrameHost_RunModalAlertDialog_ForwardToCallback& operator=(const LocalFrameHost_RunModalAlertDialog_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunModalAlertDialogCallback callback_;
};
class LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(
      bool* result, bool* out_success)
      : result_(result), out_success_(out_success) {
    DCHECK(!*result_);
  }

  LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(const LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse&) = delete;
  LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse& operator=(const LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;};

class LocalFrameHost_RunModalConfirmDialog_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(
      LocalFrameHost::RunModalConfirmDialogCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(const LocalFrameHost_RunModalConfirmDialog_ForwardToCallback&) = delete;
  LocalFrameHost_RunModalConfirmDialog_ForwardToCallback& operator=(const LocalFrameHost_RunModalConfirmDialog_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunModalConfirmDialogCallback callback_;
};
class LocalFrameHost_RunModalPromptDialog_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(
      bool* result, bool* out_success, ::std::u16string* out_result)
      : result_(result), out_success_(out_success), out_result_(out_result) {
    DCHECK(!*result_);
  }

  LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(const LocalFrameHost_RunModalPromptDialog_HandleSyncResponse&) = delete;
  LocalFrameHost_RunModalPromptDialog_HandleSyncResponse& operator=(const LocalFrameHost_RunModalPromptDialog_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;
  ::std::u16string* out_result_;};

class LocalFrameHost_RunModalPromptDialog_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunModalPromptDialog_ForwardToCallback(
      LocalFrameHost::RunModalPromptDialogCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_RunModalPromptDialog_ForwardToCallback(const LocalFrameHost_RunModalPromptDialog_ForwardToCallback&) = delete;
  LocalFrameHost_RunModalPromptDialog_ForwardToCallback& operator=(const LocalFrameHost_RunModalPromptDialog_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunModalPromptDialogCallback callback_;
};
class LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(
      bool* result, bool* out_success)
      : result_(result), out_success_(out_success) {
    DCHECK(!*result_);
  }

  LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(const LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse&) = delete;
  LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse& operator=(const LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  bool* out_success_;};

class LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(
      LocalFrameHost::RunBeforeUnloadConfirmCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(const LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback&) = delete;
  LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback& operator=(const LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::RunBeforeUnloadConfirmCallback callback_;
};
class LocalFrameHost_CreatePortal_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_CreatePortal_HandleSyncResponse(
      bool* result, ::blink::mojom::FrameReplicationStatePtr* out_initial_replicated_state, ::blink::PortalToken* out_portal_token, ::blink::RemoteFrameToken* out_frame_token, ::base::UnguessableToken* out_devtools_frame_token)
      : result_(result), out_initial_replicated_state_(out_initial_replicated_state), out_portal_token_(out_portal_token), out_frame_token_(out_frame_token), out_devtools_frame_token_(out_devtools_frame_token) {
    DCHECK(!*result_);
  }

  LocalFrameHost_CreatePortal_HandleSyncResponse(const LocalFrameHost_CreatePortal_HandleSyncResponse&) = delete;
  LocalFrameHost_CreatePortal_HandleSyncResponse& operator=(const LocalFrameHost_CreatePortal_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  ::blink::mojom::FrameReplicationStatePtr* out_initial_replicated_state_;
  ::blink::PortalToken* out_portal_token_;
  ::blink::RemoteFrameToken* out_frame_token_;
  ::base::UnguessableToken* out_devtools_frame_token_;};

class LocalFrameHost_CreatePortal_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_CreatePortal_ForwardToCallback(
      LocalFrameHost::CreatePortalCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_CreatePortal_ForwardToCallback(const LocalFrameHost_CreatePortal_ForwardToCallback&) = delete;
  LocalFrameHost_CreatePortal_ForwardToCallback& operator=(const LocalFrameHost_CreatePortal_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::CreatePortalCallback callback_;
};
class LocalFrameHost_AdoptPortal_HandleSyncResponse
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_AdoptPortal_HandleSyncResponse(
      bool* result, ::blink::mojom::FrameReplicationStatePtr* out_replicated_state, ::blink::RemoteFrameToken* out_frame_token, ::base::UnguessableToken* out_devtools_frame_token)
      : result_(result), out_replicated_state_(out_replicated_state), out_frame_token_(out_frame_token), out_devtools_frame_token_(out_devtools_frame_token) {
    DCHECK(!*result_);
  }

  LocalFrameHost_AdoptPortal_HandleSyncResponse(const LocalFrameHost_AdoptPortal_HandleSyncResponse&) = delete;
  LocalFrameHost_AdoptPortal_HandleSyncResponse& operator=(const LocalFrameHost_AdoptPortal_HandleSyncResponse&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  bool* result_;
  ::blink::mojom::FrameReplicationStatePtr* out_replicated_state_;
  ::blink::RemoteFrameToken* out_frame_token_;
  ::base::UnguessableToken* out_devtools_frame_token_;};

class LocalFrameHost_AdoptPortal_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrameHost_AdoptPortal_ForwardToCallback(
      LocalFrameHost::AdoptPortalCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrameHost_AdoptPortal_ForwardToCallback(const LocalFrameHost_AdoptPortal_ForwardToCallback&) = delete;
  LocalFrameHost_AdoptPortal_ForwardToCallback& operator=(const LocalFrameHost_AdoptPortal_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrameHost::AdoptPortalCallback callback_;
};

LocalFrameHostProxy::LocalFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void LocalFrameHostProxy::EnterFullscreen(
    ::blink::mojom::FullscreenOptionsPtr in_options, EnterFullscreenCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::EnterFullscreen", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("options"), in_options,
                        "<value of type ::blink::mojom::FullscreenOptionsPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnterFullscreen_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_EnterFullscreen_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->options)::BaseType> options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FullscreenOptionsDataView>(
      in_options, options_fragment);
  params->options.Set(
      options_fragment.is_null() ? nullptr : options_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->options.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null options in LocalFrameHost.EnterFullscreen request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnterFullscreen");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_EnterFullscreen_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::ExitFullscreen(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::ExitFullscreen");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_ExitFullscreen_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_ExitFullscreen_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ExitFullscreen");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::FullscreenStateChanged(
    bool in_is_fullscreen, ::blink::mojom::FullscreenOptionsPtr in_options) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::FullscreenStateChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_fullscreen"), in_is_fullscreen,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("options"), in_options,
                        "<value of type ::blink::mojom::FullscreenOptionsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_FullscreenStateChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_FullscreenStateChanged_Params_Data> params(
          message);
  params.Allocate();
  params->is_fullscreen = in_is_fullscreen;
  mojo::internal::MessageFragment<
      typename decltype(params->options)::BaseType> options_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FullscreenOptionsDataView>(
      in_options, options_fragment);
  params->options.Set(
      options_fragment.is_null() ? nullptr : options_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("FullscreenStateChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::RegisterProtocolHandler(
    const std::string& in_scheme, const ::GURL& in_url, bool in_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::RegisterProtocolHandler", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("scheme"), in_scheme,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("user_gesture"), in_user_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RegisterProtocolHandler_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RegisterProtocolHandler_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->scheme)::BaseType> scheme_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_scheme, scheme_fragment);
  params->scheme.Set(
      scheme_fragment.is_null() ? nullptr : scheme_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->scheme.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null scheme in LocalFrameHost.RegisterProtocolHandler request");
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrameHost.RegisterProtocolHandler request");
  params->user_gesture = in_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RegisterProtocolHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UnregisterProtocolHandler(
    const std::string& in_scheme, const ::GURL& in_url, bool in_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::UnregisterProtocolHandler", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("scheme"), in_scheme,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("user_gesture"), in_user_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_UnregisterProtocolHandler_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->scheme)::BaseType> scheme_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_scheme, scheme_fragment);
  params->scheme.Set(
      scheme_fragment.is_null() ? nullptr : scheme_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->scheme.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null scheme in LocalFrameHost.UnregisterProtocolHandler request");
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrameHost.UnregisterProtocolHandler request");
  params->user_gesture = in_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("UnregisterProtocolHandler");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidDisplayInsecureContent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidDisplayInsecureContent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidDisplayInsecureContent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidDisplayInsecureContent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidContainInsecureFormAction(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidContainInsecureFormAction");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidContainInsecureFormAction_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidContainInsecureFormAction");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::MainDocumentElementAvailable(
    bool in_uses_temporary_zoom_level) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::MainDocumentElementAvailable", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("uses_temporary_zoom_level"), in_uses_temporary_zoom_level,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_MainDocumentElementAvailable_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data> params(
          message);
  params.Allocate();
  params->uses_temporary_zoom_level = in_uses_temporary_zoom_level;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("MainDocumentElementAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetNeedsOcclusionTracking(
    bool in_needs_tracking) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::SetNeedsOcclusionTracking", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("needs_tracking"), in_needs_tracking,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data> params(
          message);
  params.Allocate();
  params->needs_tracking = in_needs_tracking;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("SetNeedsOcclusionTracking");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetVirtualKeyboardOverlayPolicy(
    bool in_vk_overlays_content) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::SetVirtualKeyboardOverlayPolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("vk_overlays_content"), in_vk_overlays_content,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_SetVirtualKeyboardOverlayPolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_SetVirtualKeyboardOverlayPolicy_Params_Data> params(
          message);
  params.Allocate();
  params->vk_overlays_content = in_vk_overlays_content;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("SetVirtualKeyboardOverlayPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::VisibilityChanged(
    ::blink::mojom::FrameVisibility in_visibility) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::VisibilityChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("visibility"), in_visibility,
                        "<value of type ::blink::mojom::FrameVisibility>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_VisibilityChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_VisibilityChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::FrameVisibility>(
      in_visibility, &params->visibility);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("VisibilityChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeThemeColor(
    absl::optional<::SkColor> in_theme_color) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeThemeColor", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("theme_color"), in_theme_color,
                        "<value of type absl::optional<::SkColor>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeThemeColor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeThemeColor_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->theme_color)::BaseType> theme_color_fragment(
          params.message());
  mojo::internal::Serialize<::skia::mojom::SkColorDataView>(
      in_theme_color, theme_color_fragment);
  params->theme_color.Set(
      theme_color_fragment.is_null() ? nullptr : theme_color_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeThemeColor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeBackgroundColor(
    ::SkColor in_background_color, bool in_color_adjust) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeBackgroundColor", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("background_color"), in_background_color,
                        "<value of type ::SkColor>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("color_adjust"), in_color_adjust,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeBackgroundColor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->background_color)::BaseType> background_color_fragment(
          params.message());
  mojo::internal::Serialize<::skia::mojom::SkColorDataView>(
      in_background_color, background_color_fragment);
  params->background_color.Set(
      background_color_fragment.is_null() ? nullptr : background_color_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->background_color.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null background_color in LocalFrameHost.DidChangeBackgroundColor request");
  params->color_adjust = in_color_adjust;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeBackgroundColor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidFailLoadWithError(
    const ::GURL& in_url, int32_t in_error_code) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidFailLoadWithError", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_code"), in_error_code,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidFailLoadWithError_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidFailLoadWithError_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrameHost.DidFailLoadWithError request");
  params->error_code = in_error_code;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidFailLoadWithError");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidFocusFrame(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidFocusFrame");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidFocusFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidFocusFrame_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidFocusFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidCallFocus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidCallFocus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidCallFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidCallFocus_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidCallFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::EnforceInsecureRequestPolicy(
    ::blink::mojom::InsecureRequestPolicy in_policy_bitmap) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::EnforceInsecureRequestPolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("policy_bitmap"), in_policy_bitmap,
                        "<value of type ::blink::mojom::InsecureRequestPolicy>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::InsecureRequestPolicy>(
      in_policy_bitmap, &params->policy_bitmap);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnforceInsecureRequestPolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::EnforceInsecureNavigationsSet(
    const std::vector<uint32_t>& in_set) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::EnforceInsecureNavigationsSet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("set"), in_set,
                        "<value of type const std::vector<uint32_t>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->set)::BaseType>
      set_fragment(params.message());
  const mojo::internal::ContainerValidateParams set_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint32_t>>(
      in_set, set_fragment, &set_validate_params);
  params->set.Set(
      set_fragment.is_null() ? nullptr : set_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->set.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null set in LocalFrameHost.EnforceInsecureNavigationsSet request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnforceInsecureNavigationsSet");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SuddenTerminationDisablerChanged(
    bool in_present, ::blink::mojom::SuddenTerminationDisablerType in_disabler_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::SuddenTerminationDisablerChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("present"), in_present,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disabler_type"), in_disabler_type,
                        "<value of type ::blink::mojom::SuddenTerminationDisablerType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data> params(
          message);
  params.Allocate();
  params->present = in_present;
  mojo::internal::Serialize<::blink::mojom::SuddenTerminationDisablerType>(
      in_disabler_type, &params->disabler_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("SuddenTerminationDisablerChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::HadStickyUserActivationBeforeNavigationChanged(
    bool in_has_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::HadStickyUserActivationBeforeNavigationChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_gesture"), in_has_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data> params(
          message);
  params.Allocate();
  params->has_gesture = in_has_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("HadStickyUserActivationBeforeNavigationChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ScrollRectToVisibleInParentFrame(
    const ::gfx::RectF& in_rect_to_scroll, ::blink::mojom::ScrollIntoViewParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::ScrollRectToVisibleInParentFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect_to_scroll"), in_rect_to_scroll,
                        "<value of type const ::gfx::RectF&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type ::blink::mojom::ScrollIntoViewParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rect_to_scroll)::BaseType> rect_to_scroll_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectFDataView>(
      in_rect_to_scroll, rect_to_scroll_fragment);
  params->rect_to_scroll.Set(
      rect_to_scroll_fragment.is_null() ? nullptr : rect_to_scroll_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect_to_scroll.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect_to_scroll in LocalFrameHost.ScrollRectToVisibleInParentFrame request");
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ScrollIntoViewParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in LocalFrameHost.ScrollRectToVisibleInParentFrame request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ScrollRectToVisibleInParentFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::BubbleLogicalScrollInParentFrame(
    ::blink::mojom::ScrollDirection in_direction, ::ui::ScrollGranularity in_granularity) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::BubbleLogicalScrollInParentFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("direction"), in_direction,
                        "<value of type ::blink::mojom::ScrollDirection>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("granularity"), in_granularity,
                        "<value of type ::ui::ScrollGranularity>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::ScrollDirection>(
      in_direction, &params->direction);
  mojo::internal::Serialize<::ui::mojom::ScrollGranularity>(
      in_granularity, &params->granularity);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("BubbleLogicalScrollInParentFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidBlockNavigation(
    const ::GURL& in_blocked_url, const ::GURL& in_initiator_url, ::blink::mojom::NavigationBlockedReason in_reason) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidBlockNavigation", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("blocked_url"), in_blocked_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("initiator_url"), in_initiator_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reason"), in_reason,
                        "<value of type ::blink::mojom::NavigationBlockedReason>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidBlockNavigation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidBlockNavigation_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->blocked_url)::BaseType> blocked_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_blocked_url, blocked_url_fragment);
  params->blocked_url.Set(
      blocked_url_fragment.is_null() ? nullptr : blocked_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->blocked_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null blocked_url in LocalFrameHost.DidBlockNavigation request");
  mojo::internal::MessageFragment<
      typename decltype(params->initiator_url)::BaseType> initiator_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_initiator_url, initiator_url_fragment);
  params->initiator_url.Set(
      initiator_url_fragment.is_null() ? nullptr : initiator_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->initiator_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null initiator_url in LocalFrameHost.DidBlockNavigation request");
  mojo::internal::Serialize<::blink::mojom::NavigationBlockedReason>(
      in_reason, &params->reason);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidBlockNavigation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeLoadProgress(
    double in_load_progress) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeLoadProgress", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("load_progress"), in_load_progress,
                        "<value of type double>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeLoadProgress_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeLoadProgress_Params_Data> params(
          message);
  params.Allocate();
  params->load_progress = in_load_progress;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeLoadProgress");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidFinishLoad(
    const ::GURL& in_validated_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidFinishLoad", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("validated_url"), in_validated_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidFinishLoad_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidFinishLoad_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->validated_url)::BaseType> validated_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_validated_url, validated_url_fragment);
  params->validated_url.Set(
      validated_url_fragment.is_null() ? nullptr : validated_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->validated_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null validated_url in LocalFrameHost.DidFinishLoad request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidFinishLoad");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DispatchLoad(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DispatchLoad");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DispatchLoad_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DispatchLoad_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DispatchLoad");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::GoToEntryAtOffset(
    int32_t in_offset, bool in_has_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::GoToEntryAtOffset", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_user_gesture"), in_has_user_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_GoToEntryAtOffset_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_GoToEntryAtOffset_Params_Data> params(
          message);
  params.Allocate();
  params->offset = in_offset;
  params->has_user_gesture = in_has_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("GoToEntryAtOffset");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::NavigateToNavigationApiKey(
    const std::string& in_key, bool in_has_user_gesture) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::NavigateToNavigationApiKey", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("key"), in_key,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_user_gesture"), in_has_user_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_NavigateToNavigationApiKey_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->key)::BaseType> key_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_key, key_fragment);
  params->key.Set(
      key_fragment.is_null() ? nullptr : key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null key in LocalFrameHost.NavigateToNavigationApiKey request");
  params->has_user_gesture = in_has_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("NavigateToNavigationApiKey");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UpdateTitle(
    const absl::optional<::std::u16string>& in_title, ::base::i18n::TextDirection in_title_direction) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::UpdateTitle", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("title"), in_title,
                        "<value of type const absl::optional<::std::u16string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("title_direction"), in_title_direction,
                        "<value of type ::base::i18n::TextDirection>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_UpdateTitle_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_UpdateTitle_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->title)::BaseType> title_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_title, title_fragment);
  params->title.Set(
      title_fragment.is_null() ? nullptr : title_fragment.data());
  mojo::internal::Serialize<::mojo_base::mojom::TextDirection>(
      in_title_direction, &params->title_direction);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("UpdateTitle");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::UpdateUserActivationState(
    ::blink::mojom::UserActivationUpdateType in_update_type, ::blink::mojom::UserActivationNotificationType in_notification_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::UpdateUserActivationState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("update_type"), in_update_type,
                        "<value of type ::blink::mojom::UserActivationUpdateType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("notification_type"), in_notification_type,
                        "<value of type ::blink::mojom::UserActivationNotificationType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_UpdateUserActivationState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_UpdateUserActivationState_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::UserActivationUpdateType>(
      in_update_type, &params->update_type);
  mojo::internal::Serialize<::blink::mojom::UserActivationNotificationType>(
      in_notification_type, &params->notification_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("UpdateUserActivationState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::HandleAccessibilityFindInPageResult(
    FindInPageResultAXParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageResult", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type FindInPageResultAXParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FindInPageResultAXParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in LocalFrameHost.HandleAccessibilityFindInPageResult request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("HandleAccessibilityFindInPageResult");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::HandleAccessibilityFindInPageTermination(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::HandleAccessibilityFindInPageTermination");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("HandleAccessibilityFindInPageTermination");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DocumentOnLoadCompleted(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DocumentOnLoadCompleted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DocumentOnLoadCompleted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DocumentOnLoadCompleted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ForwardResourceTimingToParent(
    ::blink::mojom::ResourceTimingInfoPtr in_timing) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::ForwardResourceTimingToParent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timing"), in_timing,
                        "<value of type ::blink::mojom::ResourceTimingInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_ForwardResourceTimingToParent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->timing)::BaseType> timing_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(
      in_timing, timing_fragment);
  params->timing.Set(
      timing_fragment.is_null() ? nullptr : timing_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing in LocalFrameHost.ForwardResourceTimingToParent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ForwardResourceTimingToParent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidDispatchDOMContentLoadedEvent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::DidDispatchDOMContentLoadedEvent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidDispatchDOMContentLoadedEvent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidDispatchDOMContentLoadedEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool LocalFrameHostProxy::RunModalAlertDialog(
    const ::std::u16string& param_alert_message, bool param_disable_third_party_subframe_suppresion) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::LocalFrameHost::RunModalAlertDialog (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("alert_message"), param_alert_message,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disable_third_party_subframe_suppresion"), param_disable_third_party_subframe_suppresion,
                        "<value of type bool>");
   });
#else
  TRACE_EVENT0("mojom", "LocalFrameHost::RunModalAlertDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalAlertDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->alert_message)::BaseType> alert_message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_alert_message, alert_message_fragment);
  params->alert_message.Set(
      alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalAlertDialog request");
  params->disable_third_party_subframe_suppresion = param_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalAlertDialog");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalAlertDialog_HandleSyncResponse(
          &result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END0("mojom", "LocalFrameHost::RunModalAlertDialog");
#endif
  return result;
}

void LocalFrameHostProxy::RunModalAlertDialog(
    const ::std::u16string& in_alert_message, bool in_disable_third_party_subframe_suppresion, RunModalAlertDialogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::RunModalAlertDialog", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("alert_message"), in_alert_message,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disable_third_party_subframe_suppresion"), in_disable_third_party_subframe_suppresion,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalAlertDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->alert_message)::BaseType> alert_message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_alert_message, alert_message_fragment);
  params->alert_message.Set(
      alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalAlertDialog request");
  params->disable_third_party_subframe_suppresion = in_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalAlertDialog");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalAlertDialog_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::RunModalConfirmDialog(
    const ::std::u16string& param_alert_message, bool param_disable_third_party_subframe_suppresion, bool* out_param_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::LocalFrameHost::RunModalConfirmDialog (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("alert_message"), param_alert_message,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disable_third_party_subframe_suppresion"), param_disable_third_party_subframe_suppresion,
                        "<value of type bool>");
   });
#else
  TRACE_EVENT0("mojom", "LocalFrameHost::RunModalConfirmDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalConfirmDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->alert_message)::BaseType> alert_message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_alert_message, alert_message_fragment);
  params->alert_message.Set(
      alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalConfirmDialog request");
  params->disable_third_party_subframe_suppresion = param_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalConfirmDialog");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse(
          &result, out_param_success));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "LocalFrameHost::RunModalConfirmDialog", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), out_param_success,
                        "<value of type bool>");
   });
#endif
  return result;
}

void LocalFrameHostProxy::RunModalConfirmDialog(
    const ::std::u16string& in_alert_message, bool in_disable_third_party_subframe_suppresion, RunModalConfirmDialogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::RunModalConfirmDialog", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("alert_message"), in_alert_message,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disable_third_party_subframe_suppresion"), in_disable_third_party_subframe_suppresion,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalConfirmDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->alert_message)::BaseType> alert_message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_alert_message, alert_message_fragment);
  params->alert_message.Set(
      alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalConfirmDialog request");
  params->disable_third_party_subframe_suppresion = in_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalConfirmDialog");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalConfirmDialog_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::RunModalPromptDialog(
    const ::std::u16string& param_alert_message, const ::std::u16string& param_default_value, bool param_disable_third_party_subframe_suppresion, bool* out_param_success, ::std::u16string* out_param_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::LocalFrameHost::RunModalPromptDialog (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("alert_message"), param_alert_message,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("default_value"), param_default_value,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disable_third_party_subframe_suppresion"), param_disable_third_party_subframe_suppresion,
                        "<value of type bool>");
   });
#else
  TRACE_EVENT0("mojom", "LocalFrameHost::RunModalPromptDialog");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalPromptDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->alert_message)::BaseType> alert_message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_alert_message, alert_message_fragment);
  params->alert_message.Set(
      alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalPromptDialog request");
  mojo::internal::MessageFragment<
      typename decltype(params->default_value)::BaseType> default_value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      param_default_value, default_value_fragment);
  params->default_value.Set(
      default_value_fragment.is_null() ? nullptr : default_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->default_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null default_value in LocalFrameHost.RunModalPromptDialog request");
  params->disable_third_party_subframe_suppresion = param_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalPromptDialog");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalPromptDialog_HandleSyncResponse(
          &result, out_param_success, out_param_result));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "LocalFrameHost::RunModalPromptDialog", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), out_param_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), out_param_result,
                        "<value of type const ::std::u16string&>");
   });
#endif
  return result;
}

void LocalFrameHostProxy::RunModalPromptDialog(
    const ::std::u16string& in_alert_message, const ::std::u16string& in_default_value, bool in_disable_third_party_subframe_suppresion, RunModalPromptDialogCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::RunModalPromptDialog", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("alert_message"), in_alert_message,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("default_value"), in_default_value,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disable_third_party_subframe_suppresion"), in_disable_third_party_subframe_suppresion,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalPromptDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->alert_message)::BaseType> alert_message_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_alert_message, alert_message_fragment);
  params->alert_message.Set(
      alert_message_fragment.is_null() ? nullptr : alert_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->alert_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null alert_message in LocalFrameHost.RunModalPromptDialog request");
  mojo::internal::MessageFragment<
      typename decltype(params->default_value)::BaseType> default_value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_default_value, default_value_fragment);
  params->default_value.Set(
      default_value_fragment.is_null() ? nullptr : default_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->default_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null default_value in LocalFrameHost.RunModalPromptDialog request");
  params->disable_third_party_subframe_suppresion = in_disable_third_party_subframe_suppresion;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalPromptDialog");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunModalPromptDialog_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::RunBeforeUnloadConfirm(
    bool param_is_reload, bool* out_param_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_reload"), param_is_reload,
                        "<value of type bool>");
   });
#else
  TRACE_EVENT0("mojom", "LocalFrameHost::RunBeforeUnloadConfirm");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data> params(
          message);
  params.Allocate();
  params->is_reload = param_is_reload;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunBeforeUnloadConfirm");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse(
          &result, out_param_success));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "LocalFrameHost::RunBeforeUnloadConfirm", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), out_param_success,
                        "<value of type bool>");
   });
#endif
  return result;
}

void LocalFrameHostProxy::RunBeforeUnloadConfirm(
    bool in_is_reload, RunBeforeUnloadConfirmCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_reload"), in_is_reload,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data> params(
          message);
  params.Allocate();
  params->is_reload = in_is_reload;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunBeforeUnloadConfirm");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::UpdateFaviconURL(
    std::vector<::blink::mojom::FaviconURLPtr> in_favicon_urls) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::UpdateFaviconURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("favicon_urls"), in_favicon_urls,
                        "<value of type std::vector<::blink::mojom::FaviconURLPtr>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_UpdateFaviconURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_UpdateFaviconURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->favicon_urls)::BaseType>
      favicon_urls_fragment(params.message());
  const mojo::internal::ContainerValidateParams favicon_urls_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::FaviconURLDataView>>(
      in_favicon_urls, favicon_urls_fragment, &favicon_urls_validate_params);
  params->favicon_urls.Set(
      favicon_urls_fragment.is_null() ? nullptr : favicon_urls_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->favicon_urls.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null favicon_urls in LocalFrameHost.UpdateFaviconURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("UpdateFaviconURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DownloadURL(
    DownloadURLParamsPtr in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DownloadURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type DownloadURLParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DownloadURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DownloadURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::DownloadURLParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in LocalFrameHost.DownloadURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DownloadURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::FocusedElementChanged(
    bool in_is_editable_element, const ::gfx::Rect& in_bounds_in_frame_widget, ::blink::mojom::FocusType in_focus_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::FocusedElementChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_editable_element"), in_is_editable_element,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounds_in_frame_widget"), in_bounds_in_frame_widget,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focus_type"), in_focus_type,
                        "<value of type ::blink::mojom::FocusType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_FocusedElementChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_FocusedElementChanged_Params_Data> params(
          message);
  params.Allocate();
  params->is_editable_element = in_is_editable_element;
  mojo::internal::MessageFragment<
      typename decltype(params->bounds_in_frame_widget)::BaseType> bounds_in_frame_widget_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_bounds_in_frame_widget, bounds_in_frame_widget_fragment);
  params->bounds_in_frame_widget.Set(
      bounds_in_frame_widget_fragment.is_null() ? nullptr : bounds_in_frame_widget_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds_in_frame_widget.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds_in_frame_widget in LocalFrameHost.FocusedElementChanged request");
  mojo::internal::Serialize<::blink::mojom::FocusType>(
      in_focus_type, &params->focus_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("FocusedElementChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::TextSelectionChanged(
    const ::std::u16string& in_text, uint32_t in_offset, const ::gfx::Range& in_range) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::TextSelectionChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("text"), in_text,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("offset"), in_offset,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("range"), in_range,
                        "<value of type const ::gfx::Range&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_TextSelectionChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_TextSelectionChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->text)::BaseType> text_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_text, text_fragment);
  params->text.Set(
      text_fragment.is_null() ? nullptr : text_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text in LocalFrameHost.TextSelectionChanged request");
  params->offset = in_offset;
  mojo::internal::MessageFragment<
      typename decltype(params->range)::BaseType> range_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RangeDataView>(
      in_range, range_fragment);
  params->range.Set(
      range_fragment.is_null() ? nullptr : range_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->range.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null range in LocalFrameHost.TextSelectionChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("TextSelectionChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ShowPopupMenu(
    ::mojo::PendingRemote<::blink::mojom::PopupMenuClient> in_popup_client, const ::gfx::Rect& in_bounds, int32_t in_item_height, double in_font_size, int32_t in_selected_item, std::vector<::blink::mojom::MenuItemPtr> in_menu_items, bool in_right_aligned, bool in_allow_multiple_selection) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::ShowPopupMenu", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("popup_client"), in_popup_client,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::PopupMenuClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounds"), in_bounds,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("item_height"), in_item_height,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("font_size"), in_font_size,
                        "<value of type double>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("selected_item"), in_selected_item,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("menu_items"), in_menu_items,
                        "<value of type std::vector<::blink::mojom::MenuItemPtr>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("right_aligned"), in_right_aligned,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("allow_multiple_selection"), in_allow_multiple_selection,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_ShowPopupMenu_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_ShowPopupMenu_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::PopupMenuClientInterfaceBase>>(
      in_popup_client, &params->popup_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->popup_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid popup_client in LocalFrameHost.ShowPopupMenu request");
  mojo::internal::MessageFragment<
      typename decltype(params->bounds)::BaseType> bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_bounds, bounds_fragment);
  params->bounds.Set(
      bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in LocalFrameHost.ShowPopupMenu request");
  params->item_height = in_item_height;
  params->font_size = in_font_size;
  params->selected_item = in_selected_item;
  mojo::internal::MessageFragment<
      typename decltype(params->menu_items)::BaseType>
      menu_items_fragment(params.message());
  const mojo::internal::ContainerValidateParams menu_items_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::MenuItemDataView>>(
      in_menu_items, menu_items_fragment, &menu_items_validate_params);
  params->menu_items.Set(
      menu_items_fragment.is_null() ? nullptr : menu_items_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->menu_items.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null menu_items in LocalFrameHost.ShowPopupMenu request");
  params->right_aligned = in_right_aligned;
  params->allow_multiple_selection = in_allow_multiple_selection;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ShowPopupMenu");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::CreateNewPopupWidget(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::PopupWidgetHost> in_popup_host, ::mojo::PendingAssociatedReceiver<::blink::mojom::WidgetHost> in_blink_widget_host, ::mojo::PendingAssociatedRemote<::blink::mojom::Widget> in_blink_widget) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::CreateNewPopupWidget", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("popup_host"), in_popup_host,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::PopupWidgetHost>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("blink_widget_host"), in_blink_widget_host,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::WidgetHost>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("blink_widget"), in_blink_widget,
                        "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::Widget>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_CreateNewPopupWidget_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_CreateNewPopupWidget_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PopupWidgetHostAssociatedRequestDataView>(
      in_popup_host, &params->popup_host, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->popup_host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid popup_host in LocalFrameHost.CreateNewPopupWidget request");
  mojo::internal::Serialize<::blink::mojom::WidgetHostAssociatedRequestDataView>(
      in_blink_widget_host, &params->blink_widget_host, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->blink_widget_host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid blink_widget_host in LocalFrameHost.CreateNewPopupWidget request");
  mojo::internal::Serialize<::blink::mojom::WidgetAssociatedPtrInfoDataView>(
      in_blink_widget, &params->blink_widget, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->blink_widget),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid blink_widget in LocalFrameHost.CreateNewPopupWidget request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("CreateNewPopupWidget");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ShowContextMenu(
    ::mojo::PendingAssociatedRemote<::blink::mojom::ContextMenuClient> in_client, const ::blink::UntrustworthyContextMenuParams& in_params) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::ShowContextMenu", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("client"), in_client,
                        "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::ContextMenuClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("params"), in_params,
                        "<value of type const ::blink::UntrustworthyContextMenuParams&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_ShowContextMenu_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_ShowContextMenu_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::ContextMenuClientAssociatedPtrInfoDataView>(
      in_client, &params->client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid client in LocalFrameHost.ShowContextMenu request");
  mojo::internal::MessageFragment<
      typename decltype(params->params)::BaseType> params_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::UntrustworthyContextMenuParamsDataView>(
      in_params, params_fragment);
  params->params.Set(
      params_fragment.is_null() ? nullptr : params_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->params.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null params in LocalFrameHost.ShowContextMenu request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ShowContextMenu");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidLoadResourceFromMemoryCache(
    const ::GURL& in_url, const std::string& in_http_method, const std::string& in_mime_type, ::network::mojom::RequestDestination in_request_destination, bool in_include_credentials) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidLoadResourceFromMemoryCache", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("http_method"), in_http_method,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mime_type"), in_mime_type,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request_destination"), in_request_destination,
                        "<value of type ::network::mojom::RequestDestination>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("include_credentials"), in_include_credentials,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidLoadResourceFromMemoryCache_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrameHost.DidLoadResourceFromMemoryCache request");
  mojo::internal::MessageFragment<
      typename decltype(params->http_method)::BaseType> http_method_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_http_method, http_method_fragment);
  params->http_method.Set(
      http_method_fragment.is_null() ? nullptr : http_method_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->http_method.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null http_method in LocalFrameHost.DidLoadResourceFromMemoryCache request");
  mojo::internal::MessageFragment<
      typename decltype(params->mime_type)::BaseType> mime_type_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_mime_type, mime_type_fragment);
  params->mime_type.Set(
      mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->mime_type.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null mime_type in LocalFrameHost.DidLoadResourceFromMemoryCache request");
  mojo::internal::Serialize<::network::mojom::RequestDestination>(
      in_request_destination, &params->request_destination);
  params->include_credentials = in_include_credentials;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidLoadResourceFromMemoryCache");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeFrameOwnerProperties(
    const ::blink::FrameToken& in_child_frame_token, ::blink::mojom::FrameOwnerPropertiesPtr in_frame_owner_properties) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeFrameOwnerProperties", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("child_frame_token"), in_child_frame_token,
                        "<value of type const ::blink::FrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_owner_properties"), in_frame_owner_properties,
                        "<value of type ::blink::mojom::FrameOwnerPropertiesPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeFrameOwnerProperties_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->child_frame_token)>
      child_frame_token_fragment(params.message());
  child_frame_token_fragment.Claim(&params->child_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_child_frame_token, child_frame_token_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->child_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null child_frame_token in LocalFrameHost.DidChangeFrameOwnerProperties request");
  mojo::internal::MessageFragment<
      typename decltype(params->frame_owner_properties)::BaseType> frame_owner_properties_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameOwnerPropertiesDataView>(
      in_frame_owner_properties, frame_owner_properties_fragment);
  params->frame_owner_properties.Set(
      frame_owner_properties_fragment.is_null() ? nullptr : frame_owner_properties_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_owner_properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_owner_properties in LocalFrameHost.DidChangeFrameOwnerProperties request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeFrameOwnerProperties");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeOpener(
    const absl::optional<::blink::LocalFrameToken>& in_opener_frame) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeOpener", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opener_frame"), in_opener_frame,
                        "<value of type const absl::optional<::blink::LocalFrameToken>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeOpener_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeOpener_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->opener_frame)::BaseType> opener_frame_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_opener_frame, opener_frame_fragment);
  params->opener_frame.Set(
      opener_frame_fragment.is_null() ? nullptr : opener_frame_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeOpener");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeFramePolicy(
    const ::blink::FrameToken& in_child_frame_token, const ::blink::FramePolicy& in_frame_policy) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeFramePolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("child_frame_token"), in_child_frame_token,
                        "<value of type const ::blink::FrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_policy"), in_frame_policy,
                        "<value of type const ::blink::FramePolicy&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeFramePolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeFramePolicy_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->child_frame_token)>
      child_frame_token_fragment(params.message());
  child_frame_token_fragment.Claim(&params->child_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_child_frame_token, child_frame_token_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->child_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null child_frame_token in LocalFrameHost.DidChangeFramePolicy request");
  mojo::internal::MessageFragment<
      typename decltype(params->frame_policy)::BaseType> frame_policy_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FramePolicyDataView>(
      in_frame_policy, frame_policy_fragment);
  params->frame_policy.Set(
      frame_policy_fragment.is_null() ? nullptr : frame_policy_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_policy.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_policy in LocalFrameHost.DidChangeFramePolicy request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeFramePolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeIframeAttributes(
    const ::blink::FrameToken& in_child_frame_token, IframeAttributesPtr in_attributes) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeIframeAttributes", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("child_frame_token"), in_child_frame_token,
                        "<value of type const ::blink::FrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("attributes"), in_attributes,
                        "<value of type IframeAttributesPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeIframeAttributes_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->child_frame_token)>
      child_frame_token_fragment(params.message());
  child_frame_token_fragment.Claim(&params->child_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_child_frame_token, child_frame_token_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->child_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null child_frame_token in LocalFrameHost.DidChangeIframeAttributes request");
  mojo::internal::MessageFragment<
      typename decltype(params->attributes)::BaseType> attributes_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::IframeAttributesDataView>(
      in_attributes, attributes_fragment);
  params->attributes.Set(
      attributes_fragment.is_null() ? nullptr : attributes_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->attributes.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null attributes in LocalFrameHost.DidChangeIframeAttributes request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeIframeAttributes");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::CapturePaintPreviewOfSubframe(
    const ::gfx::Rect& in_clip_rect, const ::base::UnguessableToken& in_guid) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::CapturePaintPreviewOfSubframe", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("clip_rect"), in_clip_rect,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("guid"), in_guid,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_CapturePaintPreviewOfSubframe_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->clip_rect)::BaseType> clip_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_clip_rect, clip_rect_fragment);
  params->clip_rect.Set(
      clip_rect_fragment.is_null() ? nullptr : clip_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->clip_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null clip_rect in LocalFrameHost.CapturePaintPreviewOfSubframe request");
  mojo::internal::MessageFragment<
      typename decltype(params->guid)::BaseType> guid_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_guid, guid_fragment);
  params->guid.Set(
      guid_fragment.is_null() ? nullptr : guid_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->guid.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null guid in LocalFrameHost.CapturePaintPreviewOfSubframe request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("CapturePaintPreviewOfSubframe");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::SetCloseListener(
    ::mojo::PendingRemote<::blink::mojom::CloseListener> in_listener) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::SetCloseListener", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("listener"), in_listener,
                        "<value of type ::mojo::PendingRemote<::blink::mojom::CloseListener>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_SetCloseListener_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_SetCloseListener_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::CloseListenerInterfaceBase>>(
      in_listener, &params->listener, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->listener),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid listener in LocalFrameHost.SetCloseListener request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("SetCloseListener");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::Detach(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrameHost::Detach");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_Detach_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_Detach_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("Detach");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::GetKeepAliveHandleFactory(
    ::mojo::PendingReceiver<KeepAliveHandleFactory> in_factory) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::GetKeepAliveHandleFactory", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("factory"), in_factory,
                        "<value of type ::mojo::PendingReceiver<KeepAliveHandleFactory>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_GetKeepAliveHandleFactory_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::KeepAliveHandleFactoryInterfaceBase>>(
      in_factory, &params->factory, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->factory),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid factory in LocalFrameHost.GetKeepAliveHandleFactory request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("GetKeepAliveHandleFactory");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidAddMessageToConsole(
    ::blink::mojom::ConsoleMessageLevel in_log_level, const ::std::u16string& in_msg, uint32_t in_line_number, const absl::optional<::std::u16string>& in_source_id, const absl::optional<::std::u16string>& in_untrusted_stack_trace) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidAddMessageToConsole", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("log_level"), in_log_level,
                        "<value of type ::blink::mojom::ConsoleMessageLevel>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("msg"), in_msg,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("line_number"), in_line_number,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_id"), in_source_id,
                        "<value of type const absl::optional<::std::u16string>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("untrusted_stack_trace"), in_untrusted_stack_trace,
                        "<value of type const absl::optional<::std::u16string>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidAddMessageToConsole_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidAddMessageToConsole_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::ConsoleMessageLevel>(
      in_log_level, &params->log_level);
  mojo::internal::MessageFragment<
      typename decltype(params->msg)::BaseType> msg_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_msg, msg_fragment);
  params->msg.Set(
      msg_fragment.is_null() ? nullptr : msg_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->msg.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null msg in LocalFrameHost.DidAddMessageToConsole request");
  params->line_number = in_line_number;
  mojo::internal::MessageFragment<
      typename decltype(params->source_id)::BaseType> source_id_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_source_id, source_id_fragment);
  params->source_id.Set(
      source_id_fragment.is_null() ? nullptr : source_id_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->untrusted_stack_trace)::BaseType> untrusted_stack_trace_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_untrusted_stack_trace, untrusted_stack_trace_fragment);
  params->untrusted_stack_trace.Set(
      untrusted_stack_trace_fragment.is_null() ? nullptr : untrusted_stack_trace_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidAddMessageToConsole");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::FrameSizeChanged(
    const ::gfx::Size& in_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::FrameSizeChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("size"), in_size,
                        "<value of type const ::gfx::Size&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_FrameSizeChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_FrameSizeChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->size)::BaseType> size_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_size, size_fragment);
  params->size.Set(
      size_fragment.is_null() ? nullptr : size_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null size in LocalFrameHost.FrameSizeChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("FrameSizeChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidInferColorScheme(
    ::blink::mojom::PreferredColorScheme in_color_scheme) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidInferColorScheme", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("color_scheme"), in_color_scheme,
                        "<value of type ::blink::mojom::PreferredColorScheme>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidInferColorScheme_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidInferColorScheme_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PreferredColorScheme>(
      in_color_scheme, &params->color_scheme);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidInferColorScheme");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::DidChangeSrcDoc(
    const ::blink::FrameToken& in_child_frame_token, const std::string& in_srcdoc_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::DidChangeSrcDoc", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("child_frame_token"), in_child_frame_token,
                        "<value of type const ::blink::FrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("srcdoc_value"), in_srcdoc_value,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_DidChangeSrcDoc_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_DidChangeSrcDoc_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->child_frame_token)>
      child_frame_token_fragment(params.message());
  child_frame_token_fragment.Claim(&params->child_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_child_frame_token, child_frame_token_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->child_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null child_frame_token in LocalFrameHost.DidChangeSrcDoc request");
  mojo::internal::MessageFragment<
      typename decltype(params->srcdoc_value)::BaseType> srcdoc_value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_srcdoc_value, srcdoc_value_fragment);
  params->srcdoc_value.Set(
      srcdoc_value_fragment.is_null() ? nullptr : srcdoc_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->srcdoc_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null srcdoc_value in LocalFrameHost.DidChangeSrcDoc request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("DidChangeSrcDoc");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameHostProxy::ReceivedDelegatedCapability(
    ::blink::mojom::DelegatedCapability in_delegated_capability) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::ReceivedDelegatedCapability", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("delegated_capability"), in_delegated_capability,
                        "<value of type ::blink::mojom::DelegatedCapability>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_ReceivedDelegatedCapability_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::DelegatedCapability>(
      in_delegated_capability, &params->delegated_capability);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("ReceivedDelegatedCapability");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
bool LocalFrameHostProxy::CreatePortal(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::Portal> param_portal, ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> param_client, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr param_remote_frame_interfaces, ::blink::mojom::FrameReplicationStatePtr* out_param_initial_replicated_state, ::blink::PortalToken* out_param_portal_token, ::blink::RemoteFrameToken* out_param_frame_token, ::base::UnguessableToken* out_param_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::LocalFrameHost::CreatePortal (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal"), param_portal,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::Portal>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("client"), param_client,
                        "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_frame_interfaces"), param_remote_frame_interfaces,
                        "<value of type ::blink::mojom::RemoteFrameInterfacesFromRendererPtr>");
   });
#else
  TRACE_EVENT0("mojom", "LocalFrameHost::CreatePortal");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_CreatePortal_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_CreatePortal_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PortalAssociatedRequestDataView>(
      param_portal, &params->portal, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal in LocalFrameHost.CreatePortal request");
  mojo::internal::Serialize<::blink::mojom::PortalClientAssociatedPtrInfoDataView>(
      param_client, &params->client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid client in LocalFrameHost.CreatePortal request");
  mojo::internal::MessageFragment<
      typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromRendererDataView>(
      param_remote_frame_interfaces, remote_frame_interfaces_fragment);
  params->remote_frame_interfaces.Set(
      remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_frame_interfaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_frame_interfaces in LocalFrameHost.CreatePortal request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("CreatePortal");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_CreatePortal_HandleSyncResponse(
          &result, out_param_initial_replicated_state, out_param_portal_token, out_param_frame_token, out_param_devtools_frame_token));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "LocalFrameHost::CreatePortal", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("initial_replicated_state"), out_param_initial_replicated_state,
                        "<value of type ::blink::mojom::FrameReplicationStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal_token"), out_param_portal_token,
                        "<value of type const ::blink::PortalToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_token"), out_param_frame_token,
                        "<value of type const ::blink::RemoteFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("devtools_frame_token"), out_param_devtools_frame_token,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  return result;
}

void LocalFrameHostProxy::CreatePortal(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::Portal> in_portal, ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> in_client, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr in_remote_frame_interfaces, CreatePortalCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::CreatePortal", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal"), in_portal,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::Portal>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("client"), in_client,
                        "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_frame_interfaces"), in_remote_frame_interfaces,
                        "<value of type ::blink::mojom::RemoteFrameInterfacesFromRendererPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_CreatePortal_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_CreatePortal_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PortalAssociatedRequestDataView>(
      in_portal, &params->portal, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal in LocalFrameHost.CreatePortal request");
  mojo::internal::Serialize<::blink::mojom::PortalClientAssociatedPtrInfoDataView>(
      in_client, &params->client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid client in LocalFrameHost.CreatePortal request");
  mojo::internal::MessageFragment<
      typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromRendererDataView>(
      in_remote_frame_interfaces, remote_frame_interfaces_fragment);
  params->remote_frame_interfaces.Set(
      remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_frame_interfaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_frame_interfaces in LocalFrameHost.CreatePortal request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("CreatePortal");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_CreatePortal_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
bool LocalFrameHostProxy::AdoptPortal(
    const ::blink::PortalToken& param_portal_token, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr param_remote_frame_interfaces, ::blink::mojom::FrameReplicationStatePtr* out_param_replicated_state, ::blink::RemoteFrameToken* out_param_frame_token, ::base::UnguessableToken* out_param_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_BEGIN1(
    "mojom", "Call blink::mojom::LocalFrameHost::AdoptPortal (sync)", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal_token"), param_portal_token,
                        "<value of type const ::blink::PortalToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_frame_interfaces"), param_remote_frame_interfaces,
                        "<value of type ::blink::mojom::RemoteFrameInterfacesFromRendererPtr>");
   });
#else
  TRACE_EVENT0("mojom", "LocalFrameHost::AdoptPortal");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = true;
  const bool kAllowInterrupt =
      true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_AdoptPortal_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_AdoptPortal_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->portal_token)::BaseType> portal_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::PortalTokenDataView>(
      param_portal_token, portal_token_fragment);
  params->portal_token.Set(
      portal_token_fragment.is_null() ? nullptr : portal_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in LocalFrameHost.AdoptPortal request");
  mojo::internal::MessageFragment<
      typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromRendererDataView>(
      param_remote_frame_interfaces, remote_frame_interfaces_fragment);
  params->remote_frame_interfaces.Set(
      remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_frame_interfaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_frame_interfaces in LocalFrameHost.AdoptPortal request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("AdoptPortal");
#endif

  bool result = false;
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_AdoptPortal_HandleSyncResponse(
          &result, out_param_replicated_state, out_param_frame_token, out_param_devtools_frame_token));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT_END1(
    "mojom", "LocalFrameHost::AdoptPortal", "sync_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("replicated_state"), out_param_replicated_state,
                        "<value of type ::blink::mojom::FrameReplicationStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_token"), out_param_frame_token,
                        "<value of type const ::blink::RemoteFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("devtools_frame_token"), out_param_devtools_frame_token,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  return result;
}

void LocalFrameHostProxy::AdoptPortal(
    const ::blink::PortalToken& in_portal_token, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr in_remote_frame_interfaces, AdoptPortalCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::AdoptPortal", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal_token"), in_portal_token,
                        "<value of type const ::blink::PortalToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_frame_interfaces"), in_remote_frame_interfaces,
                        "<value of type ::blink::mojom::RemoteFrameInterfacesFromRendererPtr>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_AdoptPortal_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_AdoptPortal_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->portal_token)::BaseType> portal_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::PortalTokenDataView>(
      in_portal_token, portal_token_fragment);
  params->portal_token.Set(
      portal_token_fragment.is_null() ? nullptr : portal_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in LocalFrameHost.AdoptPortal request");
  mojo::internal::MessageFragment<
      typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromRendererDataView>(
      in_remote_frame_interfaces, remote_frame_interfaces_fragment);
  params->remote_frame_interfaces.Set(
      remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_frame_interfaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_frame_interfaces in LocalFrameHost.AdoptPortal request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("AdoptPortal");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrameHost_AdoptPortal_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameHostProxy::CreateFencedFrame(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::FencedFrameOwnerHost> in_fenced_frame, ::blink::mojom::FencedFrameMode in_mode, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr in_remote_frame_interfaces, const ::blink::RemoteFrameToken& in_frame_token, const ::base::UnguessableToken& in_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrameHost::CreateFencedFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("fenced_frame"), in_fenced_frame,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::FencedFrameOwnerHost>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mode"), in_mode,
                        "<value of type ::blink::mojom::FencedFrameMode>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("remote_frame_interfaces"), in_remote_frame_interfaces,
                        "<value of type ::blink::mojom::RemoteFrameInterfacesFromRendererPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_token"), in_frame_token,
                        "<value of type const ::blink::RemoteFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("devtools_frame_token"), in_devtools_frame_token,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_CreateFencedFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_CreateFencedFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::FencedFrameOwnerHostAssociatedRequestDataView>(
      in_fenced_frame, &params->fenced_frame, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->fenced_frame),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid fenced_frame in LocalFrameHost.CreateFencedFrame request");
  mojo::internal::Serialize<::blink::mojom::FencedFrameMode>(
      in_mode, &params->mode);
  mojo::internal::MessageFragment<
      typename decltype(params->remote_frame_interfaces)::BaseType> remote_frame_interfaces_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameInterfacesFromRendererDataView>(
      in_remote_frame_interfaces, remote_frame_interfaces_fragment);
  params->remote_frame_interfaces.Set(
      remote_frame_interfaces_fragment.is_null() ? nullptr : remote_frame_interfaces_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->remote_frame_interfaces.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null remote_frame_interfaces in LocalFrameHost.CreateFencedFrame request");
  mojo::internal::MessageFragment<
      typename decltype(params->frame_token)::BaseType> frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(
      in_frame_token, frame_token_fragment);
  params->frame_token.Set(
      frame_token_fragment.is_null() ? nullptr : frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_token in LocalFrameHost.CreateFencedFrame request");
  mojo::internal::MessageFragment<
      typename decltype(params->devtools_frame_token)::BaseType> devtools_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_frame_token, devtools_frame_token_fragment);
  params->devtools_frame_token.Set(
      devtools_frame_token_fragment.is_null() ? nullptr : devtools_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_frame_token in LocalFrameHost.CreateFencedFrame request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("CreateFencedFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalFrameHost_EnterFullscreen_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::EnterFullscreenCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_EnterFullscreen_ProxyToResponder> proxy(
        new LocalFrameHost_EnterFullscreen_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_EnterFullscreen_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_EnterFullscreen_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_EnterFullscreen_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::EnterFullscreenCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_granted);
};

bool LocalFrameHost_EnterFullscreen_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_granted{};
  LocalFrameHost_EnterFullscreen_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_granted = input_data_view.granted();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_granted));
  return true;
}

void LocalFrameHost_EnterFullscreen_ProxyToResponder::Run(
    bool in_granted) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrameHost::EnterFullscreen", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("granted"), in_granted,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_EnterFullscreen_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->granted = in_granted;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("EnterFullscreen");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrameHost_RunModalAlertDialog_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::RunModalAlertDialogCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunModalAlertDialog_ProxyToResponder> proxy(
        new LocalFrameHost_RunModalAlertDialog_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunModalAlertDialog_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunModalAlertDialog_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_RunModalAlertDialog_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunModalAlertDialogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool LocalFrameHost_RunModalAlertDialog_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  LocalFrameHost_RunModalAlertDialog_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 35, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void LocalFrameHost_RunModalAlertDialog_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalFrameHost::RunModalAlertDialog");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalAlertDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalAlertDialog");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunModalAlertDialog_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  LocalFrameHost_RunModalAlertDialog_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 35, true);
    return false;
  }
  *result_ = true;
  return true;
}
class LocalFrameHost_RunModalConfirmDialog_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::RunModalConfirmDialogCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunModalConfirmDialog_ProxyToResponder> proxy(
        new LocalFrameHost_RunModalConfirmDialog_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunModalConfirmDialog_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_RunModalConfirmDialog_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunModalConfirmDialogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);
};

bool LocalFrameHost_RunModalConfirmDialog_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunModalConfirmDialog_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 36, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::Run(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrameHost::RunModalConfirmDialog", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalConfirmDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalConfirmDialog");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunModalConfirmDialog_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunModalConfirmDialog_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 36, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  *result_ = true;
  return true;
}
class LocalFrameHost_RunModalPromptDialog_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::RunModalPromptDialogCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunModalPromptDialog_ProxyToResponder> proxy(
        new LocalFrameHost_RunModalPromptDialog_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunModalPromptDialog_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunModalPromptDialog_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_RunModalPromptDialog_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunModalPromptDialogCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success, const ::std::u16string& in_result);
};

bool LocalFrameHost_RunModalPromptDialog_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  ::std::u16string p_result{};
  LocalFrameHost_RunModalPromptDialog_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 37, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success), 
std::move(p_result));
  return true;
}

void LocalFrameHost_RunModalPromptDialog_ProxyToResponder::Run(
    bool in_success, const ::std::u16string& in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrameHost::RunModalPromptDialog", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type const ::std::u16string&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunModalPromptDialog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;
  mojo::internal::MessageFragment<
      typename decltype(params->result)::BaseType> result_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_result, result_fragment);
  params->result.Set(
      result_fragment.is_null() ? nullptr : result_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunModalPromptDialog");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunModalPromptDialog_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  ::std::u16string p_result{};
  LocalFrameHost_RunModalPromptDialog_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 37, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  *out_result_ = std::move(p_result);
  *result_ = true;
  return true;
}
class LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::RunBeforeUnloadConfirmCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder> proxy(
        new LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::RunBeforeUnloadConfirmCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_success);
};

bool LocalFrameHost_RunBeforeUnloadConfirm_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunBeforeUnloadConfirm_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 38, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_success));
  return true;
}

void LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::Run(
    bool in_success) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrameHost::RunBeforeUnloadConfirm", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("success"), in_success,
                        "<value of type bool>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->success = in_success;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("RunBeforeUnloadConfirm");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_RunBeforeUnloadConfirm_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  bool p_success{};
  LocalFrameHost_RunBeforeUnloadConfirm_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_success = input_data_view.success();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 38, true);
    return false;
  }
  *out_success_ = std::move(p_success);
  *result_ = true;
  return true;
}
class LocalFrameHost_CreatePortal_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::CreatePortalCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_CreatePortal_ProxyToResponder> proxy(
        new LocalFrameHost_CreatePortal_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_CreatePortal_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_CreatePortal_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_CreatePortal_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::CreatePortalCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::FrameReplicationStatePtr in_initial_replicated_state, const ::blink::PortalToken& in_portal_token, const ::blink::RemoteFrameToken& in_frame_token, const ::base::UnguessableToken& in_devtools_frame_token);
};

bool LocalFrameHost_CreatePortal_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_CreatePortal_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_CreatePortal_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::FrameReplicationStatePtr p_initial_replicated_state{};
  ::blink::PortalToken p_portal_token{};
  ::blink::RemoteFrameToken p_frame_token{};
  ::base::UnguessableToken p_devtools_frame_token{};
  LocalFrameHost_CreatePortal_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadInitialReplicatedState(&p_initial_replicated_state))
    success = false;
  if (success && !input_data_view.ReadPortalToken(&p_portal_token))
    success = false;
  if (success && !input_data_view.ReadFrameToken(&p_frame_token))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 60, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_initial_replicated_state), 
std::move(p_portal_token), 
std::move(p_frame_token), 
std::move(p_devtools_frame_token));
  return true;
}

void LocalFrameHost_CreatePortal_ProxyToResponder::Run(
    ::blink::mojom::FrameReplicationStatePtr in_initial_replicated_state, const ::blink::PortalToken& in_portal_token, const ::blink::RemoteFrameToken& in_frame_token, const ::base::UnguessableToken& in_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrameHost::CreatePortal", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("initial_replicated_state"), in_initial_replicated_state,
                        "<value of type ::blink::mojom::FrameReplicationStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal_token"), in_portal_token,
                        "<value of type const ::blink::PortalToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_token"), in_frame_token,
                        "<value of type const ::blink::RemoteFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("devtools_frame_token"), in_devtools_frame_token,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_CreatePortal_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_CreatePortal_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->initial_replicated_state)::BaseType> initial_replicated_state_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameReplicationStateDataView>(
      in_initial_replicated_state, initial_replicated_state_fragment);
  params->initial_replicated_state.Set(
      initial_replicated_state_fragment.is_null() ? nullptr : initial_replicated_state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->initial_replicated_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null initial_replicated_state in ");
  mojo::internal::MessageFragment<
      typename decltype(params->portal_token)::BaseType> portal_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::PortalTokenDataView>(
      in_portal_token, portal_token_fragment);
  params->portal_token.Set(
      portal_token_fragment.is_null() ? nullptr : portal_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in ");
  mojo::internal::MessageFragment<
      typename decltype(params->frame_token)::BaseType> frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(
      in_frame_token, frame_token_fragment);
  params->frame_token.Set(
      frame_token_fragment.is_null() ? nullptr : frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_token in ");
  mojo::internal::MessageFragment<
      typename decltype(params->devtools_frame_token)::BaseType> devtools_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_frame_token, devtools_frame_token_fragment);
  params->devtools_frame_token.Set(
      devtools_frame_token_fragment.is_null() ? nullptr : devtools_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_frame_token in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("CreatePortal");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_CreatePortal_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_CreatePortal_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_CreatePortal_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::FrameReplicationStatePtr p_initial_replicated_state{};
  ::blink::PortalToken p_portal_token{};
  ::blink::RemoteFrameToken p_frame_token{};
  ::base::UnguessableToken p_devtools_frame_token{};
  LocalFrameHost_CreatePortal_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadInitialReplicatedState(&p_initial_replicated_state))
    success = false;
  if (success && !input_data_view.ReadPortalToken(&p_portal_token))
    success = false;
  if (success && !input_data_view.ReadFrameToken(&p_frame_token))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 60, true);
    return false;
  }
  *out_initial_replicated_state_ = std::move(p_initial_replicated_state);
  *out_portal_token_ = std::move(p_portal_token);
  *out_frame_token_ = std::move(p_frame_token);
  *out_devtools_frame_token_ = std::move(p_devtools_frame_token);
  *result_ = true;
  return true;
}
class LocalFrameHost_AdoptPortal_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrameHost::AdoptPortalCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrameHost_AdoptPortal_ProxyToResponder> proxy(
        new LocalFrameHost_AdoptPortal_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrameHost_AdoptPortal_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrameHost_AdoptPortal_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrameHost_AdoptPortal_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrameHost::AdoptPortalCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::FrameReplicationStatePtr in_replicated_state, const ::blink::RemoteFrameToken& in_frame_token, const ::base::UnguessableToken& in_devtools_frame_token);
};

bool LocalFrameHost_AdoptPortal_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_AdoptPortal_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrameHost_AdoptPortal_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::FrameReplicationStatePtr p_replicated_state{};
  ::blink::RemoteFrameToken p_frame_token{};
  ::base::UnguessableToken p_devtools_frame_token{};
  LocalFrameHost_AdoptPortal_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadReplicatedState(&p_replicated_state))
    success = false;
  if (success && !input_data_view.ReadFrameToken(&p_frame_token))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 61, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_replicated_state), 
std::move(p_frame_token), 
std::move(p_devtools_frame_token));
  return true;
}

void LocalFrameHost_AdoptPortal_ProxyToResponder::Run(
    ::blink::mojom::FrameReplicationStatePtr in_replicated_state, const ::blink::RemoteFrameToken& in_frame_token, const ::base::UnguessableToken& in_devtools_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrameHost::AdoptPortal", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("replicated_state"), in_replicated_state,
                        "<value of type ::blink::mojom::FrameReplicationStatePtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_token"), in_frame_token,
                        "<value of type const ::blink::RemoteFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("devtools_frame_token"), in_devtools_frame_token,
                        "<value of type const ::base::UnguessableToken&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrameHost_AdoptPortal_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrameHost_AdoptPortal_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->replicated_state)::BaseType> replicated_state_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameReplicationStateDataView>(
      in_replicated_state, replicated_state_fragment);
  params->replicated_state.Set(
      replicated_state_fragment.is_null() ? nullptr : replicated_state_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->replicated_state.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null replicated_state in ");
  mojo::internal::MessageFragment<
      typename decltype(params->frame_token)::BaseType> frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(
      in_frame_token, frame_token_fragment);
  params->frame_token.Set(
      frame_token_fragment.is_null() ? nullptr : frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_token in ");
  mojo::internal::MessageFragment<
      typename decltype(params->devtools_frame_token)::BaseType> devtools_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::UnguessableTokenDataView>(
      in_devtools_frame_token, devtools_frame_token_fragment);
  params->devtools_frame_token.Set(
      devtools_frame_token_fragment.is_null() ? nullptr : devtools_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->devtools_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null devtools_frame_token in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrameHost::Name_);
  message.set_method_name("AdoptPortal");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
bool LocalFrameHost_AdoptPortal_HandleSyncResponse::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrameHost_AdoptPortal_ResponseParams_Data* params =
      reinterpret_cast<internal::LocalFrameHost_AdoptPortal_ResponseParams_Data*>(
          message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::FrameReplicationStatePtr p_replicated_state{};
  ::blink::RemoteFrameToken p_frame_token{};
  ::base::UnguessableToken p_devtools_frame_token{};
  LocalFrameHost_AdoptPortal_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadReplicatedState(&p_replicated_state))
    success = false;
  if (success && !input_data_view.ReadFrameToken(&p_frame_token))
    success = false;
  if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrameHost::Name_, 61, true);
    return false;
  }
  *out_replicated_state_ = std::move(p_replicated_state);
  *out_frame_token_ = std::move(p_frame_token);
  *out_devtools_frame_token_ = std::move(p_devtools_frame_token);
  *result_ = true;
  return true;
}

// static
bool LocalFrameHostStubDispatch::Accept(
    LocalFrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kLocalFrameHost_EnterFullscreen_Name: {
      break;
    }
    case internal::kLocalFrameHost_ExitFullscreen_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ExitFullscreen_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ExitFullscreen_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_ExitFullscreen_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExitFullscreen();
      return true;
    }
    case internal::kLocalFrameHost_FullscreenStateChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_FullscreenStateChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_FullscreenStateChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_fullscreen{};
      ::blink::mojom::FullscreenOptionsPtr p_options{};
      LocalFrameHost_FullscreenStateChanged_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_fullscreen = input_data_view.is_fullscreen();
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FullscreenStateChanged(
std::move(p_is_fullscreen), 
std::move(p_options));
      return true;
    }
    case internal::kLocalFrameHost_RegisterProtocolHandler_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_RegisterProtocolHandler_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_RegisterProtocolHandler_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_scheme{};
      ::GURL p_url{};
      bool p_user_gesture{};
      LocalFrameHost_RegisterProtocolHandler_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadScheme(&p_scheme))
        success = false;
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_user_gesture = input_data_view.user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RegisterProtocolHandler(
std::move(p_scheme), 
std::move(p_url), 
std::move(p_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_UnregisterProtocolHandler_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_scheme{};
      ::GURL p_url{};
      bool p_user_gesture{};
      LocalFrameHost_UnregisterProtocolHandler_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadScheme(&p_scheme))
        success = false;
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_user_gesture = input_data_view.user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UnregisterProtocolHandler(
std::move(p_scheme), 
std::move(p_url), 
std::move(p_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_DidDisplayInsecureContent_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DidDisplayInsecureContent_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidDisplayInsecureContent();
      return true;
    }
    case internal::kLocalFrameHost_DidContainInsecureFormAction_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DidContainInsecureFormAction_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidContainInsecureFormAction();
      return true;
    }
    case internal::kLocalFrameHost_MainDocumentElementAvailable_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_uses_temporary_zoom_level{};
      LocalFrameHost_MainDocumentElementAvailable_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_uses_temporary_zoom_level = input_data_view.uses_temporary_zoom_level();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MainDocumentElementAvailable(
std::move(p_uses_temporary_zoom_level));
      return true;
    }
    case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_needs_tracking{};
      LocalFrameHost_SetNeedsOcclusionTracking_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_needs_tracking = input_data_view.needs_tracking();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNeedsOcclusionTracking(
std::move(p_needs_tracking));
      return true;
    }
    case internal::kLocalFrameHost_SetVirtualKeyboardOverlayPolicy_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_SetVirtualKeyboardOverlayPolicy_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_SetVirtualKeyboardOverlayPolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_vk_overlays_content{};
      LocalFrameHost_SetVirtualKeyboardOverlayPolicy_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_vk_overlays_content = input_data_view.vk_overlays_content();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetVirtualKeyboardOverlayPolicy(
std::move(p_vk_overlays_content));
      return true;
    }
    case internal::kLocalFrameHost_VisibilityChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_VisibilityChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_VisibilityChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FrameVisibility p_visibility{};
      LocalFrameHost_VisibilityChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadVisibility(&p_visibility))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->VisibilityChanged(
std::move(p_visibility));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeThemeColor_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeThemeColor_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeThemeColor_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::SkColor> p_theme_color{};
      LocalFrameHost_DidChangeThemeColor_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadThemeColor(&p_theme_color))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeThemeColor(
std::move(p_theme_color));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeBackgroundColor_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::SkColor p_background_color{};
      bool p_color_adjust{};
      LocalFrameHost_DidChangeBackgroundColor_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBackgroundColor(&p_background_color))
        success = false;
      if (success)
        p_color_adjust = input_data_view.color_adjust();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeBackgroundColor(
std::move(p_background_color), 
std::move(p_color_adjust));
      return true;
    }
    case internal::kLocalFrameHost_DidFailLoadWithError_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidFailLoadWithError_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidFailLoadWithError_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      int32_t p_error_code{};
      LocalFrameHost_DidFailLoadWithError_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success)
        p_error_code = input_data_view.error_code();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFailLoadWithError(
std::move(p_url), 
std::move(p_error_code));
      return true;
    }
    case internal::kLocalFrameHost_DidFocusFrame_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidFocusFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidFocusFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DidFocusFrame_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFocusFrame();
      return true;
    }
    case internal::kLocalFrameHost_DidCallFocus_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidCallFocus_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidCallFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DidCallFocus_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidCallFocus();
      return true;
    }
    case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::InsecureRequestPolicy p_policy_bitmap{};
      LocalFrameHost_EnforceInsecureRequestPolicy_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPolicyBitmap(&p_policy_bitmap))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureRequestPolicy(
std::move(p_policy_bitmap));
      return true;
    }
    case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<uint32_t> p_set{};
      LocalFrameHost_EnforceInsecureNavigationsSet_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSet(&p_set))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnforceInsecureNavigationsSet(
std::move(p_set));
      return true;
    }
    case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_present{};
      ::blink::mojom::SuddenTerminationDisablerType p_disabler_type{};
      LocalFrameHost_SuddenTerminationDisablerChanged_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_present = input_data_view.present();
      if (success && !input_data_view.ReadDisablerType(&p_disabler_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SuddenTerminationDisablerChanged(
std::move(p_present), 
std::move(p_disabler_type));
      return true;
    }
    case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_has_gesture{};
      LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_has_gesture = input_data_view.has_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HadStickyUserActivationBeforeNavigationChanged(
std::move(p_has_gesture));
      return true;
    }
    case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::RectF p_rect_to_scroll{};
      ::blink::mojom::ScrollIntoViewParamsPtr p_params{};
      LocalFrameHost_ScrollRectToVisibleInParentFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRectToScroll(&p_rect_to_scroll))
        success = false;
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 20, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScrollRectToVisibleInParentFrame(
std::move(p_rect_to_scroll), 
std::move(p_params));
      return true;
    }
    case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ScrollDirection p_direction{};
      ::ui::ScrollGranularity p_granularity{};
      LocalFrameHost_BubbleLogicalScrollInParentFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDirection(&p_direction))
        success = false;
      if (success && !input_data_view.ReadGranularity(&p_granularity))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BubbleLogicalScrollInParentFrame(
std::move(p_direction), 
std::move(p_granularity));
      return true;
    }
    case internal::kLocalFrameHost_DidBlockNavigation_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidBlockNavigation_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidBlockNavigation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_blocked_url{};
      ::GURL p_initiator_url{};
      ::blink::mojom::NavigationBlockedReason p_reason{};
      LocalFrameHost_DidBlockNavigation_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBlockedUrl(&p_blocked_url))
        success = false;
      if (success && !input_data_view.ReadInitiatorUrl(&p_initiator_url))
        success = false;
      if (success && !input_data_view.ReadReason(&p_reason))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidBlockNavigation(
std::move(p_blocked_url), 
std::move(p_initiator_url), 
std::move(p_reason));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeLoadProgress_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeLoadProgress_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeLoadProgress_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      double p_load_progress{};
      LocalFrameHost_DidChangeLoadProgress_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_load_progress = input_data_view.load_progress();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeLoadProgress(
std::move(p_load_progress));
      return true;
    }
    case internal::kLocalFrameHost_DidFinishLoad_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidFinishLoad_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidFinishLoad_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_validated_url{};
      LocalFrameHost_DidFinishLoad_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadValidatedUrl(&p_validated_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFinishLoad(
std::move(p_validated_url));
      return true;
    }
    case internal::kLocalFrameHost_DispatchLoad_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DispatchLoad_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DispatchLoad_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DispatchLoad_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchLoad();
      return true;
    }
    case internal::kLocalFrameHost_GoToEntryAtOffset_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_GoToEntryAtOffset_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_GoToEntryAtOffset_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_offset{};
      bool p_has_user_gesture{};
      LocalFrameHost_GoToEntryAtOffset_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_offset = input_data_view.offset();
      if (success)
        p_has_user_gesture = input_data_view.has_user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GoToEntryAtOffset(
std::move(p_offset), 
std::move(p_has_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_NavigateToNavigationApiKey_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_key{};
      bool p_has_user_gesture{};
      LocalFrameHost_NavigateToNavigationApiKey_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKey(&p_key))
        success = false;
      if (success)
        p_has_user_gesture = input_data_view.has_user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->NavigateToNavigationApiKey(
std::move(p_key), 
std::move(p_has_user_gesture));
      return true;
    }
    case internal::kLocalFrameHost_UpdateTitle_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_UpdateTitle_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_UpdateTitle_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::std::u16string> p_title{};
      ::base::i18n::TextDirection p_title_direction{};
      LocalFrameHost_UpdateTitle_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTitle(&p_title))
        success = false;
      if (success && !input_data_view.ReadTitleDirection(&p_title_direction))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 28, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateTitle(
std::move(p_title), 
std::move(p_title_direction));
      return true;
    }
    case internal::kLocalFrameHost_UpdateUserActivationState_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_UpdateUserActivationState_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_UpdateUserActivationState_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::UserActivationUpdateType p_update_type{};
      ::blink::mojom::UserActivationNotificationType p_notification_type{};
      LocalFrameHost_UpdateUserActivationState_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUpdateType(&p_update_type))
        success = false;
      if (success && !input_data_view.ReadNotificationType(&p_notification_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 29, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateUserActivationState(
std::move(p_update_type), 
std::move(p_notification_type));
      return true;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      FindInPageResultAXParamsPtr p_params{};
      LocalFrameHost_HandleAccessibilityFindInPageResult_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 30, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HandleAccessibilityFindInPageResult(
std::move(p_params));
      return true;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_HandleAccessibilityFindInPageTermination_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 31, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HandleAccessibilityFindInPageTermination();
      return true;
    }
    case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DocumentOnLoadCompleted_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 32, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DocumentOnLoadCompleted();
      return true;
    }
    case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ResourceTimingInfoPtr p_timing{};
      LocalFrameHost_ForwardResourceTimingToParent_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTiming(&p_timing))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 33, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForwardResourceTimingToParent(
std::move(p_timing));
      return true;
    }
    case internal::kLocalFrameHost_DidDispatchDOMContentLoadedEvent_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_DidDispatchDOMContentLoadedEvent_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 34, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidDispatchDOMContentLoadedEvent();
      return true;
    }
    case internal::kLocalFrameHost_RunModalAlertDialog_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunModalConfirmDialog_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunModalPromptDialog_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name: {
      break;
    }
    case internal::kLocalFrameHost_UpdateFaviconURL_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_UpdateFaviconURL_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_UpdateFaviconURL_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::blink::mojom::FaviconURLPtr> p_favicon_urls{};
      LocalFrameHost_UpdateFaviconURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFaviconUrls(&p_favicon_urls))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 39, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateFaviconURL(
std::move(p_favicon_urls));
      return true;
    }
    case internal::kLocalFrameHost_DownloadURL_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DownloadURL_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DownloadURL_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DownloadURLParamsPtr p_params{};
      LocalFrameHost_DownloadURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 40, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DownloadURL(
std::move(p_params));
      return true;
    }
    case internal::kLocalFrameHost_FocusedElementChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_FocusedElementChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_FocusedElementChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_is_editable_element{};
      ::gfx::Rect p_bounds_in_frame_widget{};
      ::blink::mojom::FocusType p_focus_type{};
      LocalFrameHost_FocusedElementChanged_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_editable_element = input_data_view.is_editable_element();
      if (success && !input_data_view.ReadBoundsInFrameWidget(&p_bounds_in_frame_widget))
        success = false;
      if (success && !input_data_view.ReadFocusType(&p_focus_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 41, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusedElementChanged(
std::move(p_is_editable_element), 
std::move(p_bounds_in_frame_widget), 
std::move(p_focus_type));
      return true;
    }
    case internal::kLocalFrameHost_TextSelectionChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_TextSelectionChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_TextSelectionChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_text{};
      uint32_t p_offset{};
      ::gfx::Range p_range{};
      LocalFrameHost_TextSelectionChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadText(&p_text))
        success = false;
      if (success)
        p_offset = input_data_view.offset();
      if (success && !input_data_view.ReadRange(&p_range))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 42, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TextSelectionChanged(
std::move(p_text), 
std::move(p_offset), 
std::move(p_range));
      return true;
    }
    case internal::kLocalFrameHost_ShowPopupMenu_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ShowPopupMenu_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ShowPopupMenu_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::blink::mojom::PopupMenuClient> p_popup_client{};
      ::gfx::Rect p_bounds{};
      int32_t p_item_height{};
      double p_font_size{};
      int32_t p_selected_item{};
      std::vector<::blink::mojom::MenuItemPtr> p_menu_items{};
      bool p_right_aligned{};
      bool p_allow_multiple_selection{};
      LocalFrameHost_ShowPopupMenu_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_popup_client =
            input_data_view.TakePopupClient<decltype(p_popup_client)>();
      }
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (success)
        p_item_height = input_data_view.item_height();
      if (success)
        p_font_size = input_data_view.font_size();
      if (success)
        p_selected_item = input_data_view.selected_item();
      if (success && !input_data_view.ReadMenuItems(&p_menu_items))
        success = false;
      if (success)
        p_right_aligned = input_data_view.right_aligned();
      if (success)
        p_allow_multiple_selection = input_data_view.allow_multiple_selection();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 43, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowPopupMenu(
std::move(p_popup_client), 
std::move(p_bounds), 
std::move(p_item_height), 
std::move(p_font_size), 
std::move(p_selected_item), 
std::move(p_menu_items), 
std::move(p_right_aligned), 
std::move(p_allow_multiple_selection));
      return true;
    }
    case internal::kLocalFrameHost_CreateNewPopupWidget_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_CreateNewPopupWidget_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_CreateNewPopupWidget_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<::blink::mojom::PopupWidgetHost> p_popup_host{};
      ::mojo::PendingAssociatedReceiver<::blink::mojom::WidgetHost> p_blink_widget_host{};
      ::mojo::PendingAssociatedRemote<::blink::mojom::Widget> p_blink_widget{};
      LocalFrameHost_CreateNewPopupWidget_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_popup_host =
            input_data_view.TakePopupHost<decltype(p_popup_host)>();
      }
      if (success) {
        p_blink_widget_host =
            input_data_view.TakeBlinkWidgetHost<decltype(p_blink_widget_host)>();
      }
      if (success) {
        p_blink_widget =
            input_data_view.TakeBlinkWidget<decltype(p_blink_widget)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 44, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateNewPopupWidget(
std::move(p_popup_host), 
std::move(p_blink_widget_host), 
std::move(p_blink_widget));
      return true;
    }
    case internal::kLocalFrameHost_ShowContextMenu_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ShowContextMenu_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ShowContextMenu_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<::blink::mojom::ContextMenuClient> p_client{};
      ::blink::UntrustworthyContextMenuParams p_params{};
      LocalFrameHost_ShowContextMenu_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (success && !input_data_view.ReadParams(&p_params))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 45, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowContextMenu(
std::move(p_client), 
std::move(p_params));
      return true;
    }
    case internal::kLocalFrameHost_DidLoadResourceFromMemoryCache_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      std::string p_http_method{};
      std::string p_mime_type{};
      ::network::mojom::RequestDestination p_request_destination{};
      bool p_include_credentials{};
      LocalFrameHost_DidLoadResourceFromMemoryCache_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (success && !input_data_view.ReadHttpMethod(&p_http_method))
        success = false;
      if (success && !input_data_view.ReadMimeType(&p_mime_type))
        success = false;
      if (success && !input_data_view.ReadRequestDestination(&p_request_destination))
        success = false;
      if (success)
        p_include_credentials = input_data_view.include_credentials();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 46, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidLoadResourceFromMemoryCache(
std::move(p_url), 
std::move(p_http_method), 
std::move(p_mime_type), 
std::move(p_request_destination), 
std::move(p_include_credentials));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeFrameOwnerProperties_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FrameToken p_child_frame_token{};
      ::blink::mojom::FrameOwnerPropertiesPtr p_frame_owner_properties{};
      LocalFrameHost_DidChangeFrameOwnerProperties_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
        success = false;
      if (success && !input_data_view.ReadFrameOwnerProperties(&p_frame_owner_properties))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 47, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeFrameOwnerProperties(
std::move(p_child_frame_token), 
std::move(p_frame_owner_properties));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeOpener_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeOpener_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeOpener_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::blink::LocalFrameToken> p_opener_frame{};
      LocalFrameHost_DidChangeOpener_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOpenerFrame(&p_opener_frame))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 48, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeOpener(
std::move(p_opener_frame));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeFramePolicy_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeFramePolicy_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeFramePolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FrameToken p_child_frame_token{};
      ::blink::FramePolicy p_frame_policy{};
      LocalFrameHost_DidChangeFramePolicy_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
        success = false;
      if (success && !input_data_view.ReadFramePolicy(&p_frame_policy))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 49, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeFramePolicy(
std::move(p_child_frame_token), 
std::move(p_frame_policy));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeIframeAttributes_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FrameToken p_child_frame_token{};
      IframeAttributesPtr p_attributes{};
      LocalFrameHost_DidChangeIframeAttributes_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
        success = false;
      if (success && !input_data_view.ReadAttributes(&p_attributes))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 50, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeIframeAttributes(
std::move(p_child_frame_token), 
std::move(p_attributes));
      return true;
    }
    case internal::kLocalFrameHost_CapturePaintPreviewOfSubframe_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_clip_rect{};
      ::base::UnguessableToken p_guid{};
      LocalFrameHost_CapturePaintPreviewOfSubframe_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadClipRect(&p_clip_rect))
        success = false;
      if (success && !input_data_view.ReadGuid(&p_guid))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 51, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CapturePaintPreviewOfSubframe(
std::move(p_clip_rect), 
std::move(p_guid));
      return true;
    }
    case internal::kLocalFrameHost_SetCloseListener_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_SetCloseListener_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_SetCloseListener_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingRemote<::blink::mojom::CloseListener> p_listener{};
      LocalFrameHost_SetCloseListener_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_listener =
            input_data_view.TakeListener<decltype(p_listener)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 52, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetCloseListener(
std::move(p_listener));
      return true;
    }
    case internal::kLocalFrameHost_Detach_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_Detach_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_Detach_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrameHost_Detach_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 53, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Detach();
      return true;
    }
    case internal::kLocalFrameHost_GetKeepAliveHandleFactory_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<KeepAliveHandleFactory> p_factory{};
      LocalFrameHost_GetKeepAliveHandleFactory_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_factory =
            input_data_view.TakeFactory<decltype(p_factory)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 54, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetKeepAliveHandleFactory(
std::move(p_factory));
      return true;
    }
    case internal::kLocalFrameHost_DidAddMessageToConsole_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidAddMessageToConsole_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidAddMessageToConsole_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ConsoleMessageLevel p_log_level{};
      ::std::u16string p_msg{};
      uint32_t p_line_number{};
      absl::optional<::std::u16string> p_source_id{};
      absl::optional<::std::u16string> p_untrusted_stack_trace{};
      LocalFrameHost_DidAddMessageToConsole_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLogLevel(&p_log_level))
        success = false;
      if (success && !input_data_view.ReadMsg(&p_msg))
        success = false;
      if (success)
        p_line_number = input_data_view.line_number();
      if (success && !input_data_view.ReadSourceId(&p_source_id))
        success = false;
      if (success && !input_data_view.ReadUntrustedStackTrace(&p_untrusted_stack_trace))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 55, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidAddMessageToConsole(
std::move(p_log_level), 
std::move(p_msg), 
std::move(p_line_number), 
std::move(p_source_id), 
std::move(p_untrusted_stack_trace));
      return true;
    }
    case internal::kLocalFrameHost_FrameSizeChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_FrameSizeChanged_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_FrameSizeChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Size p_size{};
      LocalFrameHost_FrameSizeChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSize(&p_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 56, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FrameSizeChanged(
std::move(p_size));
      return true;
    }
    case internal::kLocalFrameHost_DidInferColorScheme_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidInferColorScheme_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidInferColorScheme_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::PreferredColorScheme p_color_scheme{};
      LocalFrameHost_DidInferColorScheme_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadColorScheme(&p_color_scheme))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 57, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidInferColorScheme(
std::move(p_color_scheme));
      return true;
    }
    case internal::kLocalFrameHost_DidChangeSrcDoc_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_DidChangeSrcDoc_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_DidChangeSrcDoc_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FrameToken p_child_frame_token{};
      std::string p_srcdoc_value{};
      LocalFrameHost_DidChangeSrcDoc_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadChildFrameToken(&p_child_frame_token))
        success = false;
      if (success && !input_data_view.ReadSrcdocValue(&p_srcdoc_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 58, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidChangeSrcDoc(
std::move(p_child_frame_token), 
std::move(p_srcdoc_value));
      return true;
    }
    case internal::kLocalFrameHost_ReceivedDelegatedCapability_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::DelegatedCapability p_delegated_capability{};
      LocalFrameHost_ReceivedDelegatedCapability_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadDelegatedCapability(&p_delegated_capability))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 59, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReceivedDelegatedCapability(
std::move(p_delegated_capability));
      return true;
    }
    case internal::kLocalFrameHost_CreatePortal_Name: {
      break;
    }
    case internal::kLocalFrameHost_AdoptPortal_Name: {
      break;
    }
    case internal::kLocalFrameHost_CreateFencedFrame_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrameHost_CreateFencedFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrameHost_CreateFencedFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<::blink::mojom::FencedFrameOwnerHost> p_fenced_frame{};
      ::blink::mojom::FencedFrameMode p_mode{};
      ::blink::mojom::RemoteFrameInterfacesFromRendererPtr p_remote_frame_interfaces{};
      ::blink::RemoteFrameToken p_frame_token{};
      ::base::UnguessableToken p_devtools_frame_token{};
      LocalFrameHost_CreateFencedFrame_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_fenced_frame =
            input_data_view.TakeFencedFrame<decltype(p_fenced_frame)>();
      }
      if (success && !input_data_view.ReadMode(&p_mode))
        success = false;
      if (success && !input_data_view.ReadRemoteFrameInterfaces(&p_remote_frame_interfaces))
        success = false;
      if (success && !input_data_view.ReadFrameToken(&p_frame_token))
        success = false;
      if (success && !input_data_view.ReadDevtoolsFrameToken(&p_devtools_frame_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 62, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreateFencedFrame(
std::move(p_fenced_frame), 
std::move(p_mode), 
std::move(p_remote_frame_interfaces), 
std::move(p_frame_token), 
std::move(p_devtools_frame_token));
      return true;
    }
  }
  return false;
}

// static
bool LocalFrameHostStubDispatch::AcceptWithResponder(
    LocalFrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kLocalFrameHost_EnterFullscreen_Name: {

      internal::LocalFrameHost_EnterFullscreen_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_EnterFullscreen_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FullscreenOptionsPtr p_options{};
      LocalFrameHost_EnterFullscreen_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOptions(&p_options))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 0, false);
        return false;
      }
      LocalFrameHost::EnterFullscreenCallback callback =
          LocalFrameHost_EnterFullscreen_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnterFullscreen(
std::move(p_options), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_ExitFullscreen_Name: {
      break;
    }
    case internal::kLocalFrameHost_FullscreenStateChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_RegisterProtocolHandler_Name: {
      break;
    }
    case internal::kLocalFrameHost_UnregisterProtocolHandler_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidDisplayInsecureContent_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidContainInsecureFormAction_Name: {
      break;
    }
    case internal::kLocalFrameHost_MainDocumentElementAvailable_Name: {
      break;
    }
    case internal::kLocalFrameHost_SetNeedsOcclusionTracking_Name: {
      break;
    }
    case internal::kLocalFrameHost_SetVirtualKeyboardOverlayPolicy_Name: {
      break;
    }
    case internal::kLocalFrameHost_VisibilityChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeThemeColor_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeBackgroundColor_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidFailLoadWithError_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidFocusFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidCallFocus_Name: {
      break;
    }
    case internal::kLocalFrameHost_EnforceInsecureRequestPolicy_Name: {
      break;
    }
    case internal::kLocalFrameHost_EnforceInsecureNavigationsSet_Name: {
      break;
    }
    case internal::kLocalFrameHost_SuddenTerminationDisablerChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_ScrollRectToVisibleInParentFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_BubbleLogicalScrollInParentFrame_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidBlockNavigation_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeLoadProgress_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidFinishLoad_Name: {
      break;
    }
    case internal::kLocalFrameHost_DispatchLoad_Name: {
      break;
    }
    case internal::kLocalFrameHost_GoToEntryAtOffset_Name: {
      break;
    }
    case internal::kLocalFrameHost_NavigateToNavigationApiKey_Name: {
      break;
    }
    case internal::kLocalFrameHost_UpdateTitle_Name: {
      break;
    }
    case internal::kLocalFrameHost_UpdateUserActivationState_Name: {
      break;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageResult_Name: {
      break;
    }
    case internal::kLocalFrameHost_HandleAccessibilityFindInPageTermination_Name: {
      break;
    }
    case internal::kLocalFrameHost_DocumentOnLoadCompleted_Name: {
      break;
    }
    case internal::kLocalFrameHost_ForwardResourceTimingToParent_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidDispatchDOMContentLoadedEvent_Name: {
      break;
    }
    case internal::kLocalFrameHost_RunModalAlertDialog_Name: {

      internal::LocalFrameHost_RunModalAlertDialog_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunModalAlertDialog_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_alert_message{};
      bool p_disable_third_party_subframe_suppresion{};
      LocalFrameHost_RunModalAlertDialog_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
        success = false;
      if (success)
        p_disable_third_party_subframe_suppresion = input_data_view.disable_third_party_subframe_suppresion();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 35, false);
        return false;
      }
      LocalFrameHost::RunModalAlertDialogCallback callback =
          LocalFrameHost_RunModalAlertDialog_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunModalAlertDialog(
std::move(p_alert_message), 
std::move(p_disable_third_party_subframe_suppresion), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_RunModalConfirmDialog_Name: {

      internal::LocalFrameHost_RunModalConfirmDialog_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunModalConfirmDialog_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_alert_message{};
      bool p_disable_third_party_subframe_suppresion{};
      LocalFrameHost_RunModalConfirmDialog_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
        success = false;
      if (success)
        p_disable_third_party_subframe_suppresion = input_data_view.disable_third_party_subframe_suppresion();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 36, false);
        return false;
      }
      LocalFrameHost::RunModalConfirmDialogCallback callback =
          LocalFrameHost_RunModalConfirmDialog_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunModalConfirmDialog(
std::move(p_alert_message), 
std::move(p_disable_third_party_subframe_suppresion), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_RunModalPromptDialog_Name: {

      internal::LocalFrameHost_RunModalPromptDialog_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunModalPromptDialog_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_alert_message{};
      ::std::u16string p_default_value{};
      bool p_disable_third_party_subframe_suppresion{};
      LocalFrameHost_RunModalPromptDialog_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAlertMessage(&p_alert_message))
        success = false;
      if (success && !input_data_view.ReadDefaultValue(&p_default_value))
        success = false;
      if (success)
        p_disable_third_party_subframe_suppresion = input_data_view.disable_third_party_subframe_suppresion();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 37, false);
        return false;
      }
      LocalFrameHost::RunModalPromptDialogCallback callback =
          LocalFrameHost_RunModalPromptDialog_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunModalPromptDialog(
std::move(p_alert_message), 
std::move(p_default_value), 
std::move(p_disable_third_party_subframe_suppresion), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_RunBeforeUnloadConfirm_Name: {

      internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_is_reload{};
      LocalFrameHost_RunBeforeUnloadConfirm_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_reload = input_data_view.is_reload();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 38, false);
        return false;
      }
      LocalFrameHost::RunBeforeUnloadConfirmCallback callback =
          LocalFrameHost_RunBeforeUnloadConfirm_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RunBeforeUnloadConfirm(
std::move(p_is_reload), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_UpdateFaviconURL_Name: {
      break;
    }
    case internal::kLocalFrameHost_DownloadURL_Name: {
      break;
    }
    case internal::kLocalFrameHost_FocusedElementChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_TextSelectionChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_ShowPopupMenu_Name: {
      break;
    }
    case internal::kLocalFrameHost_CreateNewPopupWidget_Name: {
      break;
    }
    case internal::kLocalFrameHost_ShowContextMenu_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidLoadResourceFromMemoryCache_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeFrameOwnerProperties_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeOpener_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeFramePolicy_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeIframeAttributes_Name: {
      break;
    }
    case internal::kLocalFrameHost_CapturePaintPreviewOfSubframe_Name: {
      break;
    }
    case internal::kLocalFrameHost_SetCloseListener_Name: {
      break;
    }
    case internal::kLocalFrameHost_Detach_Name: {
      break;
    }
    case internal::kLocalFrameHost_GetKeepAliveHandleFactory_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidAddMessageToConsole_Name: {
      break;
    }
    case internal::kLocalFrameHost_FrameSizeChanged_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidInferColorScheme_Name: {
      break;
    }
    case internal::kLocalFrameHost_DidChangeSrcDoc_Name: {
      break;
    }
    case internal::kLocalFrameHost_ReceivedDelegatedCapability_Name: {
      break;
    }
    case internal::kLocalFrameHost_CreatePortal_Name: {

      internal::LocalFrameHost_CreatePortal_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_CreatePortal_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedReceiver<::blink::mojom::Portal> p_portal{};
      ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> p_client{};
      ::blink::mojom::RemoteFrameInterfacesFromRendererPtr p_remote_frame_interfaces{};
      LocalFrameHost_CreatePortal_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_portal =
            input_data_view.TakePortal<decltype(p_portal)>();
      }
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (success && !input_data_view.ReadRemoteFrameInterfaces(&p_remote_frame_interfaces))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 60, false);
        return false;
      }
      LocalFrameHost::CreatePortalCallback callback =
          LocalFrameHost_CreatePortal_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CreatePortal(
std::move(p_portal), 
std::move(p_client), 
std::move(p_remote_frame_interfaces), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_AdoptPortal_Name: {

      internal::LocalFrameHost_AdoptPortal_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrameHost_AdoptPortal_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::PortalToken p_portal_token{};
      ::blink::mojom::RemoteFrameInterfacesFromRendererPtr p_remote_frame_interfaces{};
      LocalFrameHost_AdoptPortal_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPortalToken(&p_portal_token))
        success = false;
      if (success && !input_data_view.ReadRemoteFrameInterfaces(&p_remote_frame_interfaces))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrameHost::Name_, 61, false);
        return false;
      }
      LocalFrameHost::AdoptPortalCallback callback =
          LocalFrameHost_AdoptPortal_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdoptPortal(
std::move(p_portal_token), 
std::move(p_remote_frame_interfaces), std::move(callback));
      return true;
    }
    case internal::kLocalFrameHost_CreateFencedFrame_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kLocalFrameHostValidationInfo[] = {
    {&internal::LocalFrameHost_EnterFullscreen_Params_Data::Validate,
     &internal::LocalFrameHost_EnterFullscreen_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_ExitFullscreen_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_FullscreenStateChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_RegisterProtocolHandler_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_UnregisterProtocolHandler_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidDisplayInsecureContent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidContainInsecureFormAction_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_MainDocumentElementAvailable_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_SetNeedsOcclusionTracking_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_SetVirtualKeyboardOverlayPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_VisibilityChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeThemeColor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeBackgroundColor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidFailLoadWithError_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidFocusFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidCallFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_EnforceInsecureRequestPolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_EnforceInsecureNavigationsSet_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_SuddenTerminationDisablerChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_HadStickyUserActivationBeforeNavigationChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ScrollRectToVisibleInParentFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_BubbleLogicalScrollInParentFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidBlockNavigation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeLoadProgress_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidFinishLoad_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DispatchLoad_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_GoToEntryAtOffset_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_NavigateToNavigationApiKey_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_UpdateTitle_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_UpdateUserActivationState_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_HandleAccessibilityFindInPageResult_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_HandleAccessibilityFindInPageTermination_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DocumentOnLoadCompleted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ForwardResourceTimingToParent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidDispatchDOMContentLoadedEvent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_RunModalAlertDialog_Params_Data::Validate,
     &internal::LocalFrameHost_RunModalAlertDialog_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_RunModalConfirmDialog_Params_Data::Validate,
     &internal::LocalFrameHost_RunModalConfirmDialog_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_RunModalPromptDialog_Params_Data::Validate,
     &internal::LocalFrameHost_RunModalPromptDialog_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_RunBeforeUnloadConfirm_Params_Data::Validate,
     &internal::LocalFrameHost_RunBeforeUnloadConfirm_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_UpdateFaviconURL_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DownloadURL_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_FocusedElementChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_TextSelectionChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ShowPopupMenu_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_CreateNewPopupWidget_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ShowContextMenu_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidLoadResourceFromMemoryCache_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeFrameOwnerProperties_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeOpener_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeFramePolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeIframeAttributes_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_CapturePaintPreviewOfSubframe_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_SetCloseListener_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_Detach_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_GetKeepAliveHandleFactory_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidAddMessageToConsole_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_FrameSizeChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidInferColorScheme_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_DidChangeSrcDoc_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_ReceivedDelegatedCapability_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrameHost_CreatePortal_Params_Data::Validate,
     &internal::LocalFrameHost_CreatePortal_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_AdoptPortal_Params_Data::Validate,
     &internal::LocalFrameHost_AdoptPortal_ResponseParams_Data::Validate},
    {&internal::LocalFrameHost_CreateFencedFrame_Params_Data::Validate,
     nullptr /* no response */},
};

bool LocalFrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalFrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalFrameHostValidationInfo);
}

bool LocalFrameHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalFrameHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalFrameHostValidationInfo);
}
const char LocalFrame::Name_[] = "blink.mojom.LocalFrame";

LocalFrame::IPCStableHashFunction LocalFrame::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kLocalFrame_GetTextSurroundingSelection_Name: {
      return &LocalFrame::GetTextSurroundingSelection_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_SendInterventionReport_Name: {
      return &LocalFrame::SendInterventionReport_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_SetFrameOwnerProperties_Name: {
      return &LocalFrame::SetFrameOwnerProperties_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_NotifyUserActivation_Name: {
      return &LocalFrame::NotifyUserActivation_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_NotifyVirtualKeyboardOverlayRect_Name: {
      return &LocalFrame::NotifyVirtualKeyboardOverlayRect_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_AddMessageToConsole_Name: {
      return &LocalFrame::AddMessageToConsole_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_AddInspectorIssue_Name: {
      return &LocalFrame::AddInspectorIssue_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_SwapInImmediately_Name: {
      return &LocalFrame::SwapInImmediately_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_CheckCompleted_Name: {
      return &LocalFrame::CheckCompleted_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_StopLoading_Name: {
      return &LocalFrame::StopLoading_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_Collapse_Name: {
      return &LocalFrame::Collapse_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_EnableViewSourceMode_Name: {
      return &LocalFrame::EnableViewSourceMode_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_Focus_Name: {
      return &LocalFrame::Focus_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_ClearFocusedElement_Name: {
      return &LocalFrame::ClearFocusedElement_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_GetResourceSnapshotForWebBundle_Name: {
      return &LocalFrame::GetResourceSnapshotForWebBundle_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_CopyImageAt_Name: {
      return &LocalFrame::CopyImageAt_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_SaveImageAt_Name: {
      return &LocalFrame::SaveImageAt_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_ReportBlinkFeatureUsage_Name: {
      return &LocalFrame::ReportBlinkFeatureUsage_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_RenderFallbackContent_Name: {
      return &LocalFrame::RenderFallbackContent_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_RenderFallbackContentWithResourceTiming_Name: {
      return &LocalFrame::RenderFallbackContentWithResourceTiming_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_BeforeUnload_Name: {
      return &LocalFrame::BeforeUnload_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_MediaPlayerActionAt_Name: {
      return &LocalFrame::MediaPlayerActionAt_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_PluginActionAt_Name: {
      return &LocalFrame::PluginActionAt_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_AdvanceFocusInFrame_Name: {
      return &LocalFrame::AdvanceFocusInFrame_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_AdvanceFocusForIME_Name: {
      return &LocalFrame::AdvanceFocusForIME_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_ReportContentSecurityPolicyViolation_Name: {
      return &LocalFrame::ReportContentSecurityPolicyViolation_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_DidUpdateFramePolicy_Name: {
      return &LocalFrame::DidUpdateFramePolicy_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_PostMessageEvent_Name: {
      return &LocalFrame::PostMessageEvent_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name: {
      return &LocalFrame::JavaScriptMethodExecuteRequest_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequest_Name: {
      return &LocalFrame::JavaScriptExecuteRequest_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name: {
      return &LocalFrame::JavaScriptExecuteRequestForTests_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name: {
      return &LocalFrame::JavaScriptExecuteRequestInIsolatedWorld_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_BindReportingObserver_Name: {
      return &LocalFrame::BindReportingObserver_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_UpdateOpener_Name: {
      return &LocalFrame::UpdateOpener_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_GetSavableResourceLinks_Name: {
      return &LocalFrame::GetSavableResourceLinks_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_MixedContentFound_Name: {
      return &LocalFrame::MixedContentFound_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_BindDevToolsAgent_Name: {
      return &LocalFrame::BindDevToolsAgent_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_ExtractSmartClipData_Name: {
      return &LocalFrame::ExtractSmartClipData_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_HandleRendererDebugURL_Name: {
      return &LocalFrame::HandleRendererDebugURL_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_GetCanonicalUrlForSharing_Name: {
      return &LocalFrame::GetCanonicalUrlForSharing_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_GetOpenGraphMetadata_Name: {
      return &LocalFrame::GetOpenGraphMetadata_Sym::IPCStableHash;
    }
    case internal::kLocalFrame_SetNavigationApiHistoryEntriesForRestore_Name: {
      return &LocalFrame::SetNavigationApiHistoryEntriesForRestore_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* LocalFrame::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kLocalFrame_GetTextSurroundingSelection_Name:
            return "Receive blink::mojom::LocalFrame::GetTextSurroundingSelection";
      case internal::kLocalFrame_SendInterventionReport_Name:
            return "Receive blink::mojom::LocalFrame::SendInterventionReport";
      case internal::kLocalFrame_SetFrameOwnerProperties_Name:
            return "Receive blink::mojom::LocalFrame::SetFrameOwnerProperties";
      case internal::kLocalFrame_NotifyUserActivation_Name:
            return "Receive blink::mojom::LocalFrame::NotifyUserActivation";
      case internal::kLocalFrame_NotifyVirtualKeyboardOverlayRect_Name:
            return "Receive blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect";
      case internal::kLocalFrame_AddMessageToConsole_Name:
            return "Receive blink::mojom::LocalFrame::AddMessageToConsole";
      case internal::kLocalFrame_AddInspectorIssue_Name:
            return "Receive blink::mojom::LocalFrame::AddInspectorIssue";
      case internal::kLocalFrame_SwapInImmediately_Name:
            return "Receive blink::mojom::LocalFrame::SwapInImmediately";
      case internal::kLocalFrame_CheckCompleted_Name:
            return "Receive blink::mojom::LocalFrame::CheckCompleted";
      case internal::kLocalFrame_StopLoading_Name:
            return "Receive blink::mojom::LocalFrame::StopLoading";
      case internal::kLocalFrame_Collapse_Name:
            return "Receive blink::mojom::LocalFrame::Collapse";
      case internal::kLocalFrame_EnableViewSourceMode_Name:
            return "Receive blink::mojom::LocalFrame::EnableViewSourceMode";
      case internal::kLocalFrame_Focus_Name:
            return "Receive blink::mojom::LocalFrame::Focus";
      case internal::kLocalFrame_ClearFocusedElement_Name:
            return "Receive blink::mojom::LocalFrame::ClearFocusedElement";
      case internal::kLocalFrame_GetResourceSnapshotForWebBundle_Name:
            return "Receive blink::mojom::LocalFrame::GetResourceSnapshotForWebBundle";
      case internal::kLocalFrame_CopyImageAt_Name:
            return "Receive blink::mojom::LocalFrame::CopyImageAt";
      case internal::kLocalFrame_SaveImageAt_Name:
            return "Receive blink::mojom::LocalFrame::SaveImageAt";
      case internal::kLocalFrame_ReportBlinkFeatureUsage_Name:
            return "Receive blink::mojom::LocalFrame::ReportBlinkFeatureUsage";
      case internal::kLocalFrame_RenderFallbackContent_Name:
            return "Receive blink::mojom::LocalFrame::RenderFallbackContent";
      case internal::kLocalFrame_RenderFallbackContentWithResourceTiming_Name:
            return "Receive blink::mojom::LocalFrame::RenderFallbackContentWithResourceTiming";
      case internal::kLocalFrame_BeforeUnload_Name:
            return "Receive blink::mojom::LocalFrame::BeforeUnload";
      case internal::kLocalFrame_MediaPlayerActionAt_Name:
            return "Receive blink::mojom::LocalFrame::MediaPlayerActionAt";
      case internal::kLocalFrame_PluginActionAt_Name:
            return "Receive blink::mojom::LocalFrame::PluginActionAt";
      case internal::kLocalFrame_AdvanceFocusInFrame_Name:
            return "Receive blink::mojom::LocalFrame::AdvanceFocusInFrame";
      case internal::kLocalFrame_AdvanceFocusForIME_Name:
            return "Receive blink::mojom::LocalFrame::AdvanceFocusForIME";
      case internal::kLocalFrame_ReportContentSecurityPolicyViolation_Name:
            return "Receive blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation";
      case internal::kLocalFrame_DidUpdateFramePolicy_Name:
            return "Receive blink::mojom::LocalFrame::DidUpdateFramePolicy";
      case internal::kLocalFrame_PostMessageEvent_Name:
            return "Receive blink::mojom::LocalFrame::PostMessageEvent";
      case internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name:
            return "Receive blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest";
      case internal::kLocalFrame_JavaScriptExecuteRequest_Name:
            return "Receive blink::mojom::LocalFrame::JavaScriptExecuteRequest";
      case internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name:
            return "Receive blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests";
      case internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name:
            return "Receive blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld";
      case internal::kLocalFrame_BindReportingObserver_Name:
            return "Receive blink::mojom::LocalFrame::BindReportingObserver";
      case internal::kLocalFrame_UpdateOpener_Name:
            return "Receive blink::mojom::LocalFrame::UpdateOpener";
      case internal::kLocalFrame_GetSavableResourceLinks_Name:
            return "Receive blink::mojom::LocalFrame::GetSavableResourceLinks";
      case internal::kLocalFrame_MixedContentFound_Name:
            return "Receive blink::mojom::LocalFrame::MixedContentFound";
      case internal::kLocalFrame_BindDevToolsAgent_Name:
            return "Receive blink::mojom::LocalFrame::BindDevToolsAgent";
      case internal::kLocalFrame_ExtractSmartClipData_Name:
            return "Receive blink::mojom::LocalFrame::ExtractSmartClipData";
      case internal::kLocalFrame_HandleRendererDebugURL_Name:
            return "Receive blink::mojom::LocalFrame::HandleRendererDebugURL";
      case internal::kLocalFrame_GetCanonicalUrlForSharing_Name:
            return "Receive blink::mojom::LocalFrame::GetCanonicalUrlForSharing";
      case internal::kLocalFrame_GetOpenGraphMetadata_Name:
            return "Receive blink::mojom::LocalFrame::GetOpenGraphMetadata";
      case internal::kLocalFrame_SetNavigationApiHistoryEntriesForRestore_Name:
            return "Receive blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore";
    }
  } else {
    switch (message.name()) {
      case internal::kLocalFrame_GetTextSurroundingSelection_Name:
            return "Receive reply blink::mojom::LocalFrame::GetTextSurroundingSelection";
      case internal::kLocalFrame_SendInterventionReport_Name:
            return "Receive reply blink::mojom::LocalFrame::SendInterventionReport";
      case internal::kLocalFrame_SetFrameOwnerProperties_Name:
            return "Receive reply blink::mojom::LocalFrame::SetFrameOwnerProperties";
      case internal::kLocalFrame_NotifyUserActivation_Name:
            return "Receive reply blink::mojom::LocalFrame::NotifyUserActivation";
      case internal::kLocalFrame_NotifyVirtualKeyboardOverlayRect_Name:
            return "Receive reply blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect";
      case internal::kLocalFrame_AddMessageToConsole_Name:
            return "Receive reply blink::mojom::LocalFrame::AddMessageToConsole";
      case internal::kLocalFrame_AddInspectorIssue_Name:
            return "Receive reply blink::mojom::LocalFrame::AddInspectorIssue";
      case internal::kLocalFrame_SwapInImmediately_Name:
            return "Receive reply blink::mojom::LocalFrame::SwapInImmediately";
      case internal::kLocalFrame_CheckCompleted_Name:
            return "Receive reply blink::mojom::LocalFrame::CheckCompleted";
      case internal::kLocalFrame_StopLoading_Name:
            return "Receive reply blink::mojom::LocalFrame::StopLoading";
      case internal::kLocalFrame_Collapse_Name:
            return "Receive reply blink::mojom::LocalFrame::Collapse";
      case internal::kLocalFrame_EnableViewSourceMode_Name:
            return "Receive reply blink::mojom::LocalFrame::EnableViewSourceMode";
      case internal::kLocalFrame_Focus_Name:
            return "Receive reply blink::mojom::LocalFrame::Focus";
      case internal::kLocalFrame_ClearFocusedElement_Name:
            return "Receive reply blink::mojom::LocalFrame::ClearFocusedElement";
      case internal::kLocalFrame_GetResourceSnapshotForWebBundle_Name:
            return "Receive reply blink::mojom::LocalFrame::GetResourceSnapshotForWebBundle";
      case internal::kLocalFrame_CopyImageAt_Name:
            return "Receive reply blink::mojom::LocalFrame::CopyImageAt";
      case internal::kLocalFrame_SaveImageAt_Name:
            return "Receive reply blink::mojom::LocalFrame::SaveImageAt";
      case internal::kLocalFrame_ReportBlinkFeatureUsage_Name:
            return "Receive reply blink::mojom::LocalFrame::ReportBlinkFeatureUsage";
      case internal::kLocalFrame_RenderFallbackContent_Name:
            return "Receive reply blink::mojom::LocalFrame::RenderFallbackContent";
      case internal::kLocalFrame_RenderFallbackContentWithResourceTiming_Name:
            return "Receive reply blink::mojom::LocalFrame::RenderFallbackContentWithResourceTiming";
      case internal::kLocalFrame_BeforeUnload_Name:
            return "Receive reply blink::mojom::LocalFrame::BeforeUnload";
      case internal::kLocalFrame_MediaPlayerActionAt_Name:
            return "Receive reply blink::mojom::LocalFrame::MediaPlayerActionAt";
      case internal::kLocalFrame_PluginActionAt_Name:
            return "Receive reply blink::mojom::LocalFrame::PluginActionAt";
      case internal::kLocalFrame_AdvanceFocusInFrame_Name:
            return "Receive reply blink::mojom::LocalFrame::AdvanceFocusInFrame";
      case internal::kLocalFrame_AdvanceFocusForIME_Name:
            return "Receive reply blink::mojom::LocalFrame::AdvanceFocusForIME";
      case internal::kLocalFrame_ReportContentSecurityPolicyViolation_Name:
            return "Receive reply blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation";
      case internal::kLocalFrame_DidUpdateFramePolicy_Name:
            return "Receive reply blink::mojom::LocalFrame::DidUpdateFramePolicy";
      case internal::kLocalFrame_PostMessageEvent_Name:
            return "Receive reply blink::mojom::LocalFrame::PostMessageEvent";
      case internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest";
      case internal::kLocalFrame_JavaScriptExecuteRequest_Name:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptExecuteRequest";
      case internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests";
      case internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name:
            return "Receive reply blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld";
      case internal::kLocalFrame_BindReportingObserver_Name:
            return "Receive reply blink::mojom::LocalFrame::BindReportingObserver";
      case internal::kLocalFrame_UpdateOpener_Name:
            return "Receive reply blink::mojom::LocalFrame::UpdateOpener";
      case internal::kLocalFrame_GetSavableResourceLinks_Name:
            return "Receive reply blink::mojom::LocalFrame::GetSavableResourceLinks";
      case internal::kLocalFrame_MixedContentFound_Name:
            return "Receive reply blink::mojom::LocalFrame::MixedContentFound";
      case internal::kLocalFrame_BindDevToolsAgent_Name:
            return "Receive reply blink::mojom::LocalFrame::BindDevToolsAgent";
      case internal::kLocalFrame_ExtractSmartClipData_Name:
            return "Receive reply blink::mojom::LocalFrame::ExtractSmartClipData";
      case internal::kLocalFrame_HandleRendererDebugURL_Name:
            return "Receive reply blink::mojom::LocalFrame::HandleRendererDebugURL";
      case internal::kLocalFrame_GetCanonicalUrlForSharing_Name:
            return "Receive reply blink::mojom::LocalFrame::GetCanonicalUrlForSharing";
      case internal::kLocalFrame_GetOpenGraphMetadata_Name:
            return "Receive reply blink::mojom::LocalFrame::GetOpenGraphMetadata";
      case internal::kLocalFrame_SetNavigationApiHistoryEntriesForRestore_Name:
            return "Receive reply blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalFrame::GetTextSurroundingSelection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::GetTextSurroundingSelection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::SendInterventionReport_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::SendInterventionReport");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::SetFrameOwnerProperties_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::SetFrameOwnerProperties");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::NotifyUserActivation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::NotifyUserActivation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::NotifyVirtualKeyboardOverlayRect_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::AddMessageToConsole_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::AddMessageToConsole");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::AddInspectorIssue_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::AddInspectorIssue");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::SwapInImmediately_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::SwapInImmediately");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::CheckCompleted_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::CheckCompleted");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::StopLoading_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::StopLoading");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::Collapse_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::Collapse");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::EnableViewSourceMode_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::EnableViewSourceMode");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::Focus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::Focus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::ClearFocusedElement_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::ClearFocusedElement");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::GetResourceSnapshotForWebBundle_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::GetResourceSnapshotForWebBundle");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::CopyImageAt_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::CopyImageAt");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::SaveImageAt_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::SaveImageAt");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::ReportBlinkFeatureUsage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::ReportBlinkFeatureUsage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::RenderFallbackContent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::RenderFallbackContent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::RenderFallbackContentWithResourceTiming_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::RenderFallbackContentWithResourceTiming");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::BeforeUnload_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::BeforeUnload");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::MediaPlayerActionAt_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::MediaPlayerActionAt");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::PluginActionAt_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::PluginActionAt");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::AdvanceFocusInFrame_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::AdvanceFocusInFrame");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::AdvanceFocusForIME_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::AdvanceFocusForIME");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::ReportContentSecurityPolicyViolation_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::DidUpdateFramePolicy_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::DidUpdateFramePolicy");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::PostMessageEvent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::PostMessageEvent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::JavaScriptMethodExecuteRequest_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::JavaScriptExecuteRequest_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::JavaScriptExecuteRequest");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::JavaScriptExecuteRequestForTests_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::JavaScriptExecuteRequestInIsolatedWorld_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::BindReportingObserver_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::BindReportingObserver");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::UpdateOpener_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::UpdateOpener");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::GetSavableResourceLinks_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::GetSavableResourceLinks");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::MixedContentFound_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::MixedContentFound");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::BindDevToolsAgent_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::BindDevToolsAgent");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::ExtractSmartClipData_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::ExtractSmartClipData");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::HandleRendererDebugURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::HandleRendererDebugURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::GetCanonicalUrlForSharing_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::GetCanonicalUrlForSharing");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::GetOpenGraphMetadata_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::GetOpenGraphMetadata");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalFrame::SetNavigationApiHistoryEntriesForRestore_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class LocalFrame_GetTextSurroundingSelection_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_GetTextSurroundingSelection_ForwardToCallback(
      LocalFrame::GetTextSurroundingSelectionCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_GetTextSurroundingSelection_ForwardToCallback(const LocalFrame_GetTextSurroundingSelection_ForwardToCallback&) = delete;
  LocalFrame_GetTextSurroundingSelection_ForwardToCallback& operator=(const LocalFrame_GetTextSurroundingSelection_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::GetTextSurroundingSelectionCallback callback_;
};

class LocalFrame_BeforeUnload_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_BeforeUnload_ForwardToCallback(
      LocalFrame::BeforeUnloadCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_BeforeUnload_ForwardToCallback(const LocalFrame_BeforeUnload_ForwardToCallback&) = delete;
  LocalFrame_BeforeUnload_ForwardToCallback& operator=(const LocalFrame_BeforeUnload_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::BeforeUnloadCallback callback_;
};

class LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback(
      LocalFrame::JavaScriptMethodExecuteRequestCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback(const LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback&) = delete;
  LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback& operator=(const LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::JavaScriptMethodExecuteRequestCallback callback_;
};

class LocalFrame_JavaScriptExecuteRequest_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_JavaScriptExecuteRequest_ForwardToCallback(
      LocalFrame::JavaScriptExecuteRequestCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_JavaScriptExecuteRequest_ForwardToCallback(const LocalFrame_JavaScriptExecuteRequest_ForwardToCallback&) = delete;
  LocalFrame_JavaScriptExecuteRequest_ForwardToCallback& operator=(const LocalFrame_JavaScriptExecuteRequest_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::JavaScriptExecuteRequestCallback callback_;
};

class LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback(
      LocalFrame::JavaScriptExecuteRequestForTestsCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback(const LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback&) = delete;
  LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback& operator=(const LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::JavaScriptExecuteRequestForTestsCallback callback_;
};

class LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(
      LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(const LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback&) = delete;
  LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback& operator=(const LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback callback_;
};

class LocalFrame_GetSavableResourceLinks_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_GetSavableResourceLinks_ForwardToCallback(
      LocalFrame::GetSavableResourceLinksCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_GetSavableResourceLinks_ForwardToCallback(const LocalFrame_GetSavableResourceLinks_ForwardToCallback&) = delete;
  LocalFrame_GetSavableResourceLinks_ForwardToCallback& operator=(const LocalFrame_GetSavableResourceLinks_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::GetSavableResourceLinksCallback callback_;
};

class LocalFrame_ExtractSmartClipData_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_ExtractSmartClipData_ForwardToCallback(
      LocalFrame::ExtractSmartClipDataCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_ExtractSmartClipData_ForwardToCallback(const LocalFrame_ExtractSmartClipData_ForwardToCallback&) = delete;
  LocalFrame_ExtractSmartClipData_ForwardToCallback& operator=(const LocalFrame_ExtractSmartClipData_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::ExtractSmartClipDataCallback callback_;
};

class LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback(
      LocalFrame::GetCanonicalUrlForSharingCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback(const LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback&) = delete;
  LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback& operator=(const LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::GetCanonicalUrlForSharingCallback callback_;
};

class LocalFrame_GetOpenGraphMetadata_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalFrame_GetOpenGraphMetadata_ForwardToCallback(
      LocalFrame::GetOpenGraphMetadataCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalFrame_GetOpenGraphMetadata_ForwardToCallback(const LocalFrame_GetOpenGraphMetadata_ForwardToCallback&) = delete;
  LocalFrame_GetOpenGraphMetadata_ForwardToCallback& operator=(const LocalFrame_GetOpenGraphMetadata_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalFrame::GetOpenGraphMetadataCallback callback_;
};

LocalFrameProxy::LocalFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void LocalFrameProxy::GetTextSurroundingSelection(
    uint32_t in_max_length, GetTextSurroundingSelectionCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::GetTextSurroundingSelection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("max_length"), in_max_length,
                        "<value of type uint32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetTextSurroundingSelection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetTextSurroundingSelection_Params_Data> params(
          message);
  params.Allocate();
  params->max_length = in_max_length;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetTextSurroundingSelection");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_GetTextSurroundingSelection_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::SendInterventionReport(
    const std::string& in_id, const std::string& in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::SendInterventionReport", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("id"), in_id,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_SendInterventionReport_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_SendInterventionReport_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->id)::BaseType> id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_id, id_fragment);
  params->id.Set(
      id_fragment.is_null() ? nullptr : id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null id in LocalFrame.SendInterventionReport request");
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in LocalFrame.SendInterventionReport request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SendInterventionReport");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SetFrameOwnerProperties(
    ::blink::mojom::FrameOwnerPropertiesPtr in_properties) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::SetFrameOwnerProperties", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("properties"), in_properties,
                        "<value of type ::blink::mojom::FrameOwnerPropertiesPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_SetFrameOwnerProperties_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_SetFrameOwnerProperties_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->properties)::BaseType> properties_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FrameOwnerPropertiesDataView>(
      in_properties, properties_fragment);
  params->properties.Set(
      properties_fragment.is_null() ? nullptr : properties_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->properties.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null properties in LocalFrame.SetFrameOwnerProperties request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SetFrameOwnerProperties");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::NotifyUserActivation(
    ::blink::mojom::UserActivationNotificationType in_notification_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::NotifyUserActivation", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("notification_type"), in_notification_type,
                        "<value of type ::blink::mojom::UserActivationNotificationType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_NotifyUserActivation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_NotifyUserActivation_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::UserActivationNotificationType>(
      in_notification_type, &params->notification_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("NotifyUserActivation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::NotifyVirtualKeyboardOverlayRect(
    const ::gfx::Rect& in_keyboard_rect) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::NotifyVirtualKeyboardOverlayRect", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("keyboard_rect"), in_keyboard_rect,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_NotifyVirtualKeyboardOverlayRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->keyboard_rect)::BaseType> keyboard_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_keyboard_rect, keyboard_rect_fragment);
  params->keyboard_rect.Set(
      keyboard_rect_fragment.is_null() ? nullptr : keyboard_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->keyboard_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null keyboard_rect in LocalFrame.NotifyVirtualKeyboardOverlayRect request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("NotifyVirtualKeyboardOverlayRect");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AddMessageToConsole(
    ::blink::mojom::ConsoleMessageLevel in_level, const std::string& in_message, bool in_discard_duplicates) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::AddMessageToConsole", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("level"), in_level,
                        "<value of type ::blink::mojom::ConsoleMessageLevel>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("discard_duplicates"), in_discard_duplicates,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_AddMessageToConsole_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_AddMessageToConsole_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::ConsoleMessageLevel>(
      in_level, &params->level);
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in LocalFrame.AddMessageToConsole request");
  params->discard_duplicates = in_discard_duplicates;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("AddMessageToConsole");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AddInspectorIssue(
    ::blink::mojom::InspectorIssueInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::AddInspectorIssue", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type ::blink::mojom::InspectorIssueInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_AddInspectorIssue_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_AddInspectorIssue_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::InspectorIssueInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in LocalFrame.AddInspectorIssue request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("AddInspectorIssue");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SwapInImmediately(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::SwapInImmediately");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_SwapInImmediately_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_SwapInImmediately_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SwapInImmediately");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::CheckCompleted(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::CheckCompleted");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_CheckCompleted_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_CheckCompleted_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("CheckCompleted");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::StopLoading(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::StopLoading");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_StopLoading_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_StopLoading_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("StopLoading");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::Collapse(
    bool in_collapsed) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::Collapse", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("collapsed"), in_collapsed,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_Collapse_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_Collapse_Params_Data> params(
          message);
  params.Allocate();
  params->collapsed = in_collapsed;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("Collapse");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::EnableViewSourceMode(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::EnableViewSourceMode");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_EnableViewSourceMode_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_EnableViewSourceMode_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("EnableViewSourceMode");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::Focus(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::Focus");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_Focus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_Focus_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("Focus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ClearFocusedElement(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::ClearFocusedElement");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_ClearFocusedElement_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_ClearFocusedElement_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ClearFocusedElement");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::GetResourceSnapshotForWebBundle(
    ::mojo::PendingReceiver<::data_decoder::mojom::ResourceSnapshotForWebBundle> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::GetResourceSnapshotForWebBundle", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::data_decoder::mojom::ResourceSnapshotForWebBundle>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetResourceSnapshotForWebBundle_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetResourceSnapshotForWebBundle_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::data_decoder::mojom::ResourceSnapshotForWebBundleInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in LocalFrame.GetResourceSnapshotForWebBundle request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetResourceSnapshotForWebBundle");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::CopyImageAt(
    const ::gfx::Point& in_window_point) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::CopyImageAt", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("window_point"), in_window_point,
                        "<value of type const ::gfx::Point&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_CopyImageAt_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_CopyImageAt_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->window_point)::BaseType> window_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_window_point, window_point_fragment);
  params->window_point.Set(
      window_point_fragment.is_null() ? nullptr : window_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->window_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null window_point in LocalFrame.CopyImageAt request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("CopyImageAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::SaveImageAt(
    const ::gfx::Point& in_window_point) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::SaveImageAt", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("window_point"), in_window_point,
                        "<value of type const ::gfx::Point&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_SaveImageAt_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_SaveImageAt_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->window_point)::BaseType> window_point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_window_point, window_point_fragment);
  params->window_point.Set(
      window_point_fragment.is_null() ? nullptr : window_point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->window_point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null window_point in LocalFrame.SaveImageAt request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SaveImageAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ReportBlinkFeatureUsage(
    const std::vector<::blink::mojom::WebFeature>& in_features) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::ReportBlinkFeatureUsage", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("features"), in_features,
                        "<value of type const std::vector<::blink::mojom::WebFeature>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_ReportBlinkFeatureUsage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->features)::BaseType>
      features_fragment(params.message());
  const mojo::internal::ContainerValidateParams features_validate_params(
      0, ::blink::mojom::internal::WebFeature_Data::Validate);
  mojo::internal::Serialize<mojo::ArrayDataView<::blink::mojom::WebFeature>>(
      in_features, features_fragment, &features_validate_params);
  params->features.Set(
      features_fragment.is_null() ? nullptr : features_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->features.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null features in LocalFrame.ReportBlinkFeatureUsage request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ReportBlinkFeatureUsage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::RenderFallbackContent(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::RenderFallbackContent");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_RenderFallbackContent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_RenderFallbackContent_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("RenderFallbackContent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::RenderFallbackContentWithResourceTiming(
    ::blink::mojom::ResourceTimingInfoPtr in_timing, const std::string& in_server_timing_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::RenderFallbackContentWithResourceTiming", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("timing"), in_timing,
                        "<value of type ::blink::mojom::ResourceTimingInfoPtr>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("server_timing_value"), in_server_timing_value,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_RenderFallbackContentWithResourceTiming_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_RenderFallbackContentWithResourceTiming_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->timing)::BaseType> timing_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::ResourceTimingInfoDataView>(
      in_timing, timing_fragment);
  params->timing.Set(
      timing_fragment.is_null() ? nullptr : timing_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->timing.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null timing in LocalFrame.RenderFallbackContentWithResourceTiming request");
  mojo::internal::MessageFragment<
      typename decltype(params->server_timing_value)::BaseType> server_timing_value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_server_timing_value, server_timing_value_fragment);
  params->server_timing_value.Set(
      server_timing_value_fragment.is_null() ? nullptr : server_timing_value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->server_timing_value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null server_timing_value in LocalFrame.RenderFallbackContentWithResourceTiming request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("RenderFallbackContentWithResourceTiming");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::BeforeUnload(
    bool in_is_reload, BeforeUnloadCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::BeforeUnload", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_reload"), in_is_reload,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_BeforeUnload_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_BeforeUnload_Params_Data> params(
          message);
  params.Allocate();
  params->is_reload = in_is_reload;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("BeforeUnload");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_BeforeUnload_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::MediaPlayerActionAt(
    const ::gfx::Point& in_location, ::blink::mojom::MediaPlayerActionPtr in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::MediaPlayerActionAt", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("location"), in_location,
                        "<value of type const ::gfx::Point&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("action"), in_action,
                        "<value of type ::blink::mojom::MediaPlayerActionPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_MediaPlayerActionAt_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_MediaPlayerActionAt_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->location)::BaseType> location_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_location, location_fragment);
  params->location.Set(
      location_fragment.is_null() ? nullptr : location_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->location.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null location in LocalFrame.MediaPlayerActionAt request");
  mojo::internal::MessageFragment<
      typename decltype(params->action)::BaseType> action_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::MediaPlayerActionDataView>(
      in_action, action_fragment);
  params->action.Set(
      action_fragment.is_null() ? nullptr : action_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->action.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null action in LocalFrame.MediaPlayerActionAt request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("MediaPlayerActionAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::PluginActionAt(
    const ::gfx::Point& in_location, PluginActionType in_action) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::PluginActionAt", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("location"), in_location,
                        "<value of type const ::gfx::Point&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("action"), in_action,
                        "<value of type PluginActionType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_PluginActionAt_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_PluginActionAt_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->location)::BaseType> location_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_location, location_fragment);
  params->location.Set(
      location_fragment.is_null() ? nullptr : location_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->location.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null location in LocalFrame.PluginActionAt request");
  mojo::internal::Serialize<::blink::mojom::PluginActionType>(
      in_action, &params->action);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("PluginActionAt");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AdvanceFocusInFrame(
    ::blink::mojom::FocusType in_focus_type, const absl::optional<::blink::RemoteFrameToken>& in_source_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::AdvanceFocusInFrame", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focus_type"), in_focus_type,
                        "<value of type ::blink::mojom::FocusType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_frame_token"), in_source_frame_token,
                        "<value of type const absl::optional<::blink::RemoteFrameToken>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_AdvanceFocusInFrame_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_AdvanceFocusInFrame_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::FocusType>(
      in_focus_type, &params->focus_type);
  mojo::internal::MessageFragment<
      typename decltype(params->source_frame_token)::BaseType> source_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(
      in_source_frame_token, source_frame_token_fragment);
  params->source_frame_token.Set(
      source_frame_token_fragment.is_null() ? nullptr : source_frame_token_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("AdvanceFocusInFrame");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::AdvanceFocusForIME(
    ::blink::mojom::FocusType in_focus_type) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::AdvanceFocusForIME", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("focus_type"), in_focus_type,
                        "<value of type ::blink::mojom::FocusType>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_AdvanceFocusForIME_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_AdvanceFocusForIME_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::FocusType>(
      in_focus_type, &params->focus_type);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("AdvanceFocusForIME");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ReportContentSecurityPolicyViolation(
    ::network::mojom::CSPViolationPtr in_violation) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::ReportContentSecurityPolicyViolation", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("violation"), in_violation,
                        "<value of type ::network::mojom::CSPViolationPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_ReportContentSecurityPolicyViolation_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->violation)::BaseType> violation_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CSPViolationDataView>(
      in_violation, violation_fragment);
  params->violation.Set(
      violation_fragment.is_null() ? nullptr : violation_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->violation.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null violation in LocalFrame.ReportContentSecurityPolicyViolation request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ReportContentSecurityPolicyViolation");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::DidUpdateFramePolicy(
    const ::blink::FramePolicy& in_frame_policy) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::DidUpdateFramePolicy", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("frame_policy"), in_frame_policy,
                        "<value of type const ::blink::FramePolicy&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_DidUpdateFramePolicy_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_DidUpdateFramePolicy_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->frame_policy)::BaseType> frame_policy_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::FramePolicyDataView>(
      in_frame_policy, frame_policy_fragment);
  params->frame_policy.Set(
      frame_policy_fragment.is_null() ? nullptr : frame_policy_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->frame_policy.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null frame_policy in LocalFrame.DidUpdateFramePolicy request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("DidUpdateFramePolicy");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::PostMessageEvent(
    const absl::optional<::blink::RemoteFrameToken>& in_source_frame_token, const ::std::u16string& in_source_origin, const ::std::u16string& in_target_origin, ::blink::TransferableMessage in_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::PostMessageEvent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_frame_token"), in_source_frame_token,
                        "<value of type const absl::optional<::blink::RemoteFrameToken>&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_origin"), in_source_origin,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("target_origin"), in_target_origin,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type ::blink::TransferableMessage>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_PostMessageEvent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_PostMessageEvent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->source_frame_token)::BaseType> source_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::RemoteFrameTokenDataView>(
      in_source_frame_token, source_frame_token_fragment);
  params->source_frame_token.Set(
      source_frame_token_fragment.is_null() ? nullptr : source_frame_token_fragment.data());
  mojo::internal::MessageFragment<
      typename decltype(params->source_origin)::BaseType> source_origin_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_source_origin, source_origin_fragment);
  params->source_origin.Set(
      source_origin_fragment.is_null() ? nullptr : source_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_origin in LocalFrame.PostMessageEvent request");
  mojo::internal::MessageFragment<
      typename decltype(params->target_origin)::BaseType> target_origin_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_target_origin, target_origin_fragment);
  params->target_origin.Set(
      target_origin_fragment.is_null() ? nullptr : target_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->target_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null target_origin in LocalFrame.PostMessageEvent request");
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in LocalFrame.PostMessageEvent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("PostMessageEvent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::JavaScriptMethodExecuteRequest(
    const ::std::u16string& in_object_name, const ::std::u16string& in_method_name, ::base::Value::List in_arguments, bool in_wants_result, JavaScriptMethodExecuteRequestCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("object_name"), in_object_name,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("method_name"), in_method_name,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("arguments"), in_arguments,
                        "<value of type ::base::Value::List>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("wants_result"), in_wants_result,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->object_name)::BaseType> object_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_object_name, object_name_fragment);
  params->object_name.Set(
      object_name_fragment.is_null() ? nullptr : object_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->object_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null object_name in LocalFrame.JavaScriptMethodExecuteRequest request");
  mojo::internal::MessageFragment<
      typename decltype(params->method_name)::BaseType> method_name_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_method_name, method_name_fragment);
  params->method_name.Set(
      method_name_fragment.is_null() ? nullptr : method_name_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->method_name.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null method_name in LocalFrame.JavaScriptMethodExecuteRequest request");
  mojo::internal::MessageFragment<
      typename decltype(params->arguments)::BaseType> arguments_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::ListValueDataView>(
      in_arguments, arguments_fragment);
  params->arguments.Set(
      arguments_fragment.is_null() ? nullptr : arguments_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->arguments.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null arguments in LocalFrame.JavaScriptMethodExecuteRequest request");
  params->wants_result = in_wants_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptMethodExecuteRequest");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::JavaScriptExecuteRequest(
    const ::std::u16string& in_javascript, bool in_wants_result, JavaScriptExecuteRequestCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::JavaScriptExecuteRequest", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("javascript"), in_javascript,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("wants_result"), in_wants_result,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptExecuteRequest_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequest_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->javascript)::BaseType> javascript_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_javascript, javascript_fragment);
  params->javascript.Set(
      javascript_fragment.is_null() ? nullptr : javascript_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->javascript.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null javascript in LocalFrame.JavaScriptExecuteRequest request");
  params->wants_result = in_wants_result;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptExecuteRequest");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_JavaScriptExecuteRequest_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::JavaScriptExecuteRequestForTests(
    const ::std::u16string& in_javascript, bool in_has_user_gesture, bool in_resolve_promises, int32_t in_world_id, JavaScriptExecuteRequestForTestsCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("javascript"), in_javascript,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("has_user_gesture"), in_has_user_gesture,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("resolve_promises"), in_resolve_promises,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("world_id"), in_world_id,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->javascript)::BaseType> javascript_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_javascript, javascript_fragment);
  params->javascript.Set(
      javascript_fragment.is_null() ? nullptr : javascript_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->javascript.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null javascript in LocalFrame.JavaScriptExecuteRequestForTests request");
  params->has_user_gesture = in_has_user_gesture;
  params->resolve_promises = in_resolve_promises;
  params->world_id = in_world_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptExecuteRequestForTests");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::JavaScriptExecuteRequestInIsolatedWorld(
    const ::std::u16string& in_javascript, bool in_wants_result, int32_t in_world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("javascript"), in_javascript,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("wants_result"), in_wants_result,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("world_id"), in_world_id,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->javascript)::BaseType> javascript_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::BigString16DataView>(
      in_javascript, javascript_fragment);
  params->javascript.Set(
      javascript_fragment.is_null() ? nullptr : javascript_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->javascript.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null javascript in LocalFrame.JavaScriptExecuteRequestInIsolatedWorld request");
  params->wants_result = in_wants_result;
  params->world_id = in_world_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptExecuteRequestInIsolatedWorld");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::BindReportingObserver(
    ::mojo::PendingReceiver<::blink::mojom::ReportingObserver> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::BindReportingObserver", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::ReportingObserver>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_BindReportingObserver_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_BindReportingObserver_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::ReportingObserverInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in LocalFrame.BindReportingObserver request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("BindReportingObserver");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::UpdateOpener(
    const absl::optional<::blink::FrameToken>& in_opener_frame_token) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::UpdateOpener", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opener_frame_token"), in_opener_frame_token,
                        "<value of type const absl::optional<::blink::FrameToken>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_UpdateOpener_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_UpdateOpener_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->opener_frame_token)>
      opener_frame_token_fragment(params.message());
  opener_frame_token_fragment.Claim(&params->opener_frame_token);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_opener_frame_token, opener_frame_token_fragment, true);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("UpdateOpener");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::GetSavableResourceLinks(
    GetSavableResourceLinksCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::GetSavableResourceLinks");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetSavableResourceLinks_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetSavableResourceLinks_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetSavableResourceLinks");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_GetSavableResourceLinks_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::MixedContentFound(
    const ::GURL& in_main_resource_url, const ::GURL& in_mixed_content_url, ::blink::mojom::RequestContextType in_request_context, bool in_was_allowed, const ::GURL& in_url_before_redirects, bool in_had_redirect, ::network::mojom::SourceLocationPtr in_source_location) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::MixedContentFound", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("main_resource_url"), in_main_resource_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("mixed_content_url"), in_mixed_content_url,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request_context"), in_request_context,
                        "<value of type ::blink::mojom::RequestContextType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("was_allowed"), in_was_allowed,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url_before_redirects"), in_url_before_redirects,
                        "<value of type const ::GURL&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("had_redirect"), in_had_redirect,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_location"), in_source_location,
                        "<value of type ::network::mojom::SourceLocationPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_MixedContentFound_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_MixedContentFound_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->main_resource_url)::BaseType> main_resource_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_main_resource_url, main_resource_url_fragment);
  params->main_resource_url.Set(
      main_resource_url_fragment.is_null() ? nullptr : main_resource_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->main_resource_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null main_resource_url in LocalFrame.MixedContentFound request");
  mojo::internal::MessageFragment<
      typename decltype(params->mixed_content_url)::BaseType> mixed_content_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_mixed_content_url, mixed_content_url_fragment);
  params->mixed_content_url.Set(
      mixed_content_url_fragment.is_null() ? nullptr : mixed_content_url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->mixed_content_url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null mixed_content_url in LocalFrame.MixedContentFound request");
  mojo::internal::Serialize<::blink::mojom::RequestContextType>(
      in_request_context, &params->request_context);
  params->was_allowed = in_was_allowed;
  mojo::internal::MessageFragment<
      typename decltype(params->url_before_redirects)::BaseType> url_before_redirects_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url_before_redirects, url_before_redirects_fragment);
  params->url_before_redirects.Set(
      url_before_redirects_fragment.is_null() ? nullptr : url_before_redirects_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url_before_redirects.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url_before_redirects in LocalFrame.MixedContentFound request");
  params->had_redirect = in_had_redirect;
  mojo::internal::MessageFragment<
      typename decltype(params->source_location)::BaseType> source_location_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::SourceLocationDataView>(
      in_source_location, source_location_fragment);
  params->source_location.Set(
      source_location_fragment.is_null() ? nullptr : source_location_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("MixedContentFound");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::BindDevToolsAgent(
    ::mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> in_agent_host, ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> in_agent) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::BindDevToolsAgent", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("agent_host"), in_agent_host,
                        "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("agent"), in_agent,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_BindDevToolsAgent_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_BindDevToolsAgent_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::DevToolsAgentHostAssociatedPtrInfoDataView>(
      in_agent_host, &params->agent_host, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->agent_host),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid agent_host in LocalFrame.BindDevToolsAgent request");
  mojo::internal::Serialize<::blink::mojom::DevToolsAgentAssociatedRequestDataView>(
      in_agent, &params->agent, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->agent),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid agent in LocalFrame.BindDevToolsAgent request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("BindDevToolsAgent");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::ExtractSmartClipData(
    const ::gfx::Rect& in_rect, ExtractSmartClipDataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::ExtractSmartClipData", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect"), in_rect,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_ExtractSmartClipData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_ExtractSmartClipData_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rect)::BaseType> rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, rect_fragment);
  params->rect.Set(
      rect_fragment.is_null() ? nullptr : rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in LocalFrame.ExtractSmartClipData request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ExtractSmartClipData");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_ExtractSmartClipData_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::HandleRendererDebugURL(
    const ::GURL& in_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::HandleRendererDebugURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_HandleRendererDebugURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_HandleRendererDebugURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalFrame.HandleRendererDebugURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("HandleRendererDebugURL");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalFrameProxy::GetCanonicalUrlForSharing(
    GetCanonicalUrlForSharingCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::GetCanonicalUrlForSharing");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetCanonicalUrlForSharing_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetCanonicalUrlForSharing");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::GetOpenGraphMetadata(
    GetOpenGraphMetadataCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalFrame::GetOpenGraphMetadata");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetOpenGraphMetadata_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetOpenGraphMetadata_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetOpenGraphMetadata");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalFrame_GetOpenGraphMetadata_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalFrameProxy::SetNavigationApiHistoryEntriesForRestore(
    ::blink::mojom::NavigationApiHistoryEntryArraysPtr in_entry_arrays) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalFrame::SetNavigationApiHistoryEntriesForRestore", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("entry_arrays"), in_entry_arrays,
                        "<value of type ::blink::mojom::NavigationApiHistoryEntryArraysPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_SetNavigationApiHistoryEntriesForRestore_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->entry_arrays)::BaseType> entry_arrays_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::NavigationApiHistoryEntryArraysDataView>(
      in_entry_arrays, entry_arrays_fragment);
  params->entry_arrays.Set(
      entry_arrays_fragment.is_null() ? nullptr : entry_arrays_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->entry_arrays.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null entry_arrays in LocalFrame.SetNavigationApiHistoryEntriesForRestore request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("SetNavigationApiHistoryEntriesForRestore");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalFrame_GetTextSurroundingSelection_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::GetTextSurroundingSelectionCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_GetTextSurroundingSelection_ProxyToResponder> proxy(
        new LocalFrame_GetTextSurroundingSelection_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_GetTextSurroundingSelection_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_GetTextSurroundingSelection_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_GetTextSurroundingSelection_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::GetTextSurroundingSelectionCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::std::u16string& in_content, uint32_t in_start_offset, uint32_t in_end_offset);
};

bool LocalFrame_GetTextSurroundingSelection_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::std::u16string p_content{};
  uint32_t p_start_offset{};
  uint32_t p_end_offset{};
  LocalFrame_GetTextSurroundingSelection_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadContent(&p_content))
    success = false;
  if (success)
    p_start_offset = input_data_view.start_offset();
  if (success)
    p_end_offset = input_data_view.end_offset();
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_content), 
std::move(p_start_offset), 
std::move(p_end_offset));
  return true;
}

void LocalFrame_GetTextSurroundingSelection_ProxyToResponder::Run(
    const ::std::u16string& in_content, uint32_t in_start_offset, uint32_t in_end_offset) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::GetTextSurroundingSelection", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("content"), in_content,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("start_offset"), in_start_offset,
                        "<value of type uint32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("end_offset"), in_end_offset,
                        "<value of type uint32_t>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetTextSurroundingSelection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->content)::BaseType> content_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_content, content_fragment);
  params->content.Set(
      content_fragment.is_null() ? nullptr : content_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->content.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null content in ");
  params->start_offset = in_start_offset;
  params->end_offset = in_end_offset;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetTextSurroundingSelection");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_BeforeUnload_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::BeforeUnloadCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_BeforeUnload_ProxyToResponder> proxy(
        new LocalFrame_BeforeUnload_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_BeforeUnload_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_BeforeUnload_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_BeforeUnload_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::BeforeUnloadCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time);
};

bool LocalFrame_BeforeUnload_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_BeforeUnload_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_BeforeUnload_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_proceed{};
  ::base::TimeTicks p_before_unload_start_time{};
  ::base::TimeTicks p_before_unload_end_time{};
  LocalFrame_BeforeUnload_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_proceed = input_data_view.proceed();
  if (success && !input_data_view.ReadBeforeUnloadStartTime(&p_before_unload_start_time))
    success = false;
  if (success && !input_data_view.ReadBeforeUnloadEndTime(&p_before_unload_end_time))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 20, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_proceed), 
std::move(p_before_unload_start_time), 
std::move(p_before_unload_end_time));
  return true;
}

void LocalFrame_BeforeUnload_ProxyToResponder::Run(
    bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::BeforeUnload", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("proceed"), in_proceed,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("before_unload_start_time"), in_before_unload_start_time,
                        "<value of type ::base::TimeTicks>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("before_unload_end_time"), in_before_unload_end_time,
                        "<value of type ::base::TimeTicks>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_BeforeUnload_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_BeforeUnload_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->proceed = in_proceed;
  mojo::internal::MessageFragment<
      typename decltype(params->before_unload_start_time)::BaseType> before_unload_start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_before_unload_start_time, before_unload_start_time_fragment);
  params->before_unload_start_time.Set(
      before_unload_start_time_fragment.is_null() ? nullptr : before_unload_start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->before_unload_start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null before_unload_start_time in ");
  mojo::internal::MessageFragment<
      typename decltype(params->before_unload_end_time)::BaseType> before_unload_end_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_before_unload_end_time, before_unload_end_time_fragment);
  params->before_unload_end_time.Set(
      before_unload_end_time_fragment.is_null() ? nullptr : before_unload_end_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->before_unload_end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null before_unload_end_time in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("BeforeUnload");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::JavaScriptMethodExecuteRequestCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder> proxy(
        new LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::JavaScriptMethodExecuteRequestCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value in_result);
};

bool LocalFrame_JavaScriptMethodExecuteRequest_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::Value p_result{};
  LocalFrame_JavaScriptMethodExecuteRequest_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 28, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder::Run(
    ::base::Value in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::JavaScriptMethodExecuteRequest", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::base::Value>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptMethodExecuteRequest");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_JavaScriptExecuteRequest_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::JavaScriptExecuteRequestCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_JavaScriptExecuteRequest_ProxyToResponder> proxy(
        new LocalFrame_JavaScriptExecuteRequest_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_JavaScriptExecuteRequest_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_JavaScriptExecuteRequest_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_JavaScriptExecuteRequest_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::JavaScriptExecuteRequestCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value in_result);
};

bool LocalFrame_JavaScriptExecuteRequest_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::Value p_result{};
  LocalFrame_JavaScriptExecuteRequest_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 29, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void LocalFrame_JavaScriptExecuteRequest_ProxyToResponder::Run(
    ::base::Value in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::JavaScriptExecuteRequest", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::base::Value>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptExecuteRequest_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptExecuteRequest");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::JavaScriptExecuteRequestForTestsCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder> proxy(
        new LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::JavaScriptExecuteRequestForTestsCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      JavaScriptExecutionResultType in_result_type, ::base::Value in_result);
};

bool LocalFrame_JavaScriptExecuteRequestForTests_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  JavaScriptExecutionResultType p_result_type{};
  ::base::Value p_result{};
  LocalFrame_JavaScriptExecuteRequestForTests_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResultType(&p_result_type))
    success = false;
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 30, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result_type), 
std::move(p_result));
  return true;
}

void LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder::Run(
    JavaScriptExecutionResultType in_result_type, ::base::Value in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::JavaScriptExecuteRequestForTests", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result_type"), in_result_type,
                        "<value of type JavaScriptExecutionResultType>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::base::Value>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::JavaScriptExecutionResultType>(
      in_result_type, &params->result_type);
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptExecuteRequestForTests");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder> proxy(
        new LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::base::Value in_result);
};

bool LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::base::Value p_result{};
  LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 31, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::Run(
    ::base::Value in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::JavaScriptExecuteRequestInIsolatedWorld", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::base::Value>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->result)>
      result_fragment(params.message());
  result_fragment.Claim(&params->result);
  mojo::internal::Serialize<::mojo_base::mojom::ValueDataView>(
      in_result, result_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->result.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null result in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("JavaScriptExecuteRequestInIsolatedWorld");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_GetSavableResourceLinks_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::GetSavableResourceLinksCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_GetSavableResourceLinks_ProxyToResponder> proxy(
        new LocalFrame_GetSavableResourceLinks_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_GetSavableResourceLinks_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_GetSavableResourceLinks_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_GetSavableResourceLinks_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::GetSavableResourceLinksCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      GetSavableResourceLinksReplyPtr in_reply);
};

bool LocalFrame_GetSavableResourceLinks_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  GetSavableResourceLinksReplyPtr p_reply{};
  LocalFrame_GetSavableResourceLinks_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadReply(&p_reply))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 34, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_reply));
  return true;
}

void LocalFrame_GetSavableResourceLinks_ProxyToResponder::Run(
    GetSavableResourceLinksReplyPtr in_reply) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::GetSavableResourceLinks", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reply"), in_reply,
                        "<value of type GetSavableResourceLinksReplyPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetSavableResourceLinks_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->reply)::BaseType> reply_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::GetSavableResourceLinksReplyDataView>(
      in_reply, reply_fragment);
  params->reply.Set(
      reply_fragment.is_null() ? nullptr : reply_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetSavableResourceLinks");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_ExtractSmartClipData_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::ExtractSmartClipDataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_ExtractSmartClipData_ProxyToResponder> proxy(
        new LocalFrame_ExtractSmartClipData_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_ExtractSmartClipData_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_ExtractSmartClipData_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_ExtractSmartClipData_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::ExtractSmartClipDataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const ::std::u16string& in_text, const ::std::u16string& in_html, const ::gfx::Rect& in_clip_rect);
};

bool LocalFrame_ExtractSmartClipData_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_ExtractSmartClipData_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_ExtractSmartClipData_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::std::u16string p_text{};
  ::std::u16string p_html{};
  ::gfx::Rect p_clip_rect{};
  LocalFrame_ExtractSmartClipData_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadText(&p_text))
    success = false;
  if (success && !input_data_view.ReadHtml(&p_html))
    success = false;
  if (success && !input_data_view.ReadClipRect(&p_clip_rect))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 37, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_text), 
std::move(p_html), 
std::move(p_clip_rect));
  return true;
}

void LocalFrame_ExtractSmartClipData_ProxyToResponder::Run(
    const ::std::u16string& in_text, const ::std::u16string& in_html, const ::gfx::Rect& in_clip_rect) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::ExtractSmartClipData", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("text"), in_text,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("html"), in_html,
                        "<value of type const ::std::u16string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("clip_rect"), in_clip_rect,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_ExtractSmartClipData_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_ExtractSmartClipData_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->text)::BaseType> text_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_text, text_fragment);
  params->text.Set(
      text_fragment.is_null() ? nullptr : text_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->text.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null text in ");
  mojo::internal::MessageFragment<
      typename decltype(params->html)::BaseType> html_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::String16DataView>(
      in_html, html_fragment);
  params->html.Set(
      html_fragment.is_null() ? nullptr : html_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->html.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null html in ");
  mojo::internal::MessageFragment<
      typename decltype(params->clip_rect)::BaseType> clip_rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_clip_rect, clip_rect_fragment);
  params->clip_rect.Set(
      clip_rect_fragment.is_null() ? nullptr : clip_rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->clip_rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null clip_rect in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("ExtractSmartClipData");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::GetCanonicalUrlForSharingCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder> proxy(
        new LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::GetCanonicalUrlForSharingCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      const absl::optional<::GURL>& in_canonical_url);
};

bool LocalFrame_GetCanonicalUrlForSharing_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  absl::optional<::GURL> p_canonical_url{};
  LocalFrame_GetCanonicalUrlForSharing_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadCanonicalUrl(&p_canonical_url))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 39, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_canonical_url));
  return true;
}

void LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder::Run(
    const absl::optional<::GURL>& in_canonical_url) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::GetCanonicalUrlForSharing", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("canonical_url"), in_canonical_url,
                        "<value of type const absl::optional<::GURL>&>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetCanonicalUrlForSharing_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->canonical_url)::BaseType> canonical_url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_canonical_url, canonical_url_fragment);
  params->canonical_url.Set(
      canonical_url_fragment.is_null() ? nullptr : canonical_url_fragment.data());

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetCanonicalUrlForSharing");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalFrame_GetOpenGraphMetadata_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalFrame::GetOpenGraphMetadataCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalFrame_GetOpenGraphMetadata_ProxyToResponder> proxy(
        new LocalFrame_GetOpenGraphMetadata_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalFrame_GetOpenGraphMetadata_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalFrame_GetOpenGraphMetadata_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalFrame_GetOpenGraphMetadata_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalFrame::GetOpenGraphMetadataCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::OpenGraphMetadataPtr in_metadata);
};

bool LocalFrame_GetOpenGraphMetadata_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::OpenGraphMetadataPtr p_metadata{};
  LocalFrame_GetOpenGraphMetadata_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadMetadata(&p_metadata))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalFrame::Name_, 40, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_metadata));
  return true;
}

void LocalFrame_GetOpenGraphMetadata_ProxyToResponder::Run(
    ::blink::mojom::OpenGraphMetadataPtr in_metadata) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalFrame::GetOpenGraphMetadata", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("metadata"), in_metadata,
                        "<value of type ::blink::mojom::OpenGraphMetadataPtr>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalFrame_GetOpenGraphMetadata_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->metadata)::BaseType> metadata_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::OpenGraphMetadataDataView>(
      in_metadata, metadata_fragment);
  params->metadata.Set(
      metadata_fragment.is_null() ? nullptr : metadata_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->metadata.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null metadata in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalFrame::Name_);
  message.set_method_name("GetOpenGraphMetadata");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool LocalFrameStubDispatch::Accept(
    LocalFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kLocalFrame_GetTextSurroundingSelection_Name: {
      break;
    }
    case internal::kLocalFrame_SendInterventionReport_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_SendInterventionReport_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SendInterventionReport_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_id{};
      std::string p_message{};
      LocalFrame_SendInterventionReport_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadId(&p_id))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SendInterventionReport(
std::move(p_id), 
std::move(p_message));
      return true;
    }
    case internal::kLocalFrame_SetFrameOwnerProperties_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_SetFrameOwnerProperties_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SetFrameOwnerProperties_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FrameOwnerPropertiesPtr p_properties{};
      LocalFrame_SetFrameOwnerProperties_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadProperties(&p_properties))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetFrameOwnerProperties(
std::move(p_properties));
      return true;
    }
    case internal::kLocalFrame_NotifyUserActivation_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_NotifyUserActivation_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_NotifyUserActivation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::UserActivationNotificationType p_notification_type{};
      LocalFrame_NotifyUserActivation_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadNotificationType(&p_notification_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->NotifyUserActivation(
std::move(p_notification_type));
      return true;
    }
    case internal::kLocalFrame_NotifyVirtualKeyboardOverlayRect_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_keyboard_rect{};
      LocalFrame_NotifyVirtualKeyboardOverlayRect_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadKeyboardRect(&p_keyboard_rect))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->NotifyVirtualKeyboardOverlayRect(
std::move(p_keyboard_rect));
      return true;
    }
    case internal::kLocalFrame_AddMessageToConsole_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_AddMessageToConsole_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_AddMessageToConsole_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ConsoleMessageLevel p_level{};
      std::string p_message{};
      bool p_discard_duplicates{};
      LocalFrame_AddMessageToConsole_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLevel(&p_level))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (success)
        p_discard_duplicates = input_data_view.discard_duplicates();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddMessageToConsole(
std::move(p_level), 
std::move(p_message), 
std::move(p_discard_duplicates));
      return true;
    }
    case internal::kLocalFrame_AddInspectorIssue_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_AddInspectorIssue_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_AddInspectorIssue_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::InspectorIssueInfoPtr p_info{};
      LocalFrame_AddInspectorIssue_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddInspectorIssue(
std::move(p_info));
      return true;
    }
    case internal::kLocalFrame_SwapInImmediately_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_SwapInImmediately_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SwapInImmediately_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_SwapInImmediately_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SwapInImmediately();
      return true;
    }
    case internal::kLocalFrame_CheckCompleted_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_CheckCompleted_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_CheckCompleted_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_CheckCompleted_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CheckCompleted();
      return true;
    }
    case internal::kLocalFrame_StopLoading_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_StopLoading_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_StopLoading_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_StopLoading_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StopLoading();
      return true;
    }
    case internal::kLocalFrame_Collapse_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_Collapse_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_Collapse_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_collapsed{};
      LocalFrame_Collapse_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_collapsed = input_data_view.collapsed();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Collapse(
std::move(p_collapsed));
      return true;
    }
    case internal::kLocalFrame_EnableViewSourceMode_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_EnableViewSourceMode_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_EnableViewSourceMode_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_EnableViewSourceMode_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 11, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnableViewSourceMode();
      return true;
    }
    case internal::kLocalFrame_Focus_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_Focus_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_Focus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_Focus_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 12, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->Focus();
      return true;
    }
    case internal::kLocalFrame_ClearFocusedElement_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_ClearFocusedElement_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_ClearFocusedElement_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_ClearFocusedElement_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 13, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClearFocusedElement();
      return true;
    }
    case internal::kLocalFrame_GetResourceSnapshotForWebBundle_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_GetResourceSnapshotForWebBundle_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_GetResourceSnapshotForWebBundle_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::data_decoder::mojom::ResourceSnapshotForWebBundle> p_receiver{};
      LocalFrame_GetResourceSnapshotForWebBundle_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 14, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetResourceSnapshotForWebBundle(
std::move(p_receiver));
      return true;
    }
    case internal::kLocalFrame_CopyImageAt_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_CopyImageAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_CopyImageAt_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Point p_window_point{};
      LocalFrame_CopyImageAt_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadWindowPoint(&p_window_point))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 15, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->CopyImageAt(
std::move(p_window_point));
      return true;
    }
    case internal::kLocalFrame_SaveImageAt_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_SaveImageAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SaveImageAt_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Point p_window_point{};
      LocalFrame_SaveImageAt_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadWindowPoint(&p_window_point))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 16, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SaveImageAt(
std::move(p_window_point));
      return true;
    }
    case internal::kLocalFrame_ReportBlinkFeatureUsage_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::vector<::blink::mojom::WebFeature> p_features{};
      LocalFrame_ReportBlinkFeatureUsage_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFeatures(&p_features))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 17, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportBlinkFeatureUsage(
std::move(p_features));
      return true;
    }
    case internal::kLocalFrame_RenderFallbackContent_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_RenderFallbackContent_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_RenderFallbackContent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalFrame_RenderFallbackContent_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 18, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContent();
      return true;
    }
    case internal::kLocalFrame_RenderFallbackContentWithResourceTiming_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_RenderFallbackContentWithResourceTiming_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_RenderFallbackContentWithResourceTiming_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::ResourceTimingInfoPtr p_timing{};
      std::string p_server_timing_value{};
      LocalFrame_RenderFallbackContentWithResourceTiming_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadTiming(&p_timing))
        success = false;
      if (success && !input_data_view.ReadServerTimingValue(&p_server_timing_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 19, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RenderFallbackContentWithResourceTiming(
std::move(p_timing), 
std::move(p_server_timing_value));
      return true;
    }
    case internal::kLocalFrame_BeforeUnload_Name: {
      break;
    }
    case internal::kLocalFrame_MediaPlayerActionAt_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_MediaPlayerActionAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_MediaPlayerActionAt_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Point p_location{};
      ::blink::mojom::MediaPlayerActionPtr p_action{};
      LocalFrame_MediaPlayerActionAt_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLocation(&p_location))
        success = false;
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 21, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MediaPlayerActionAt(
std::move(p_location), 
std::move(p_action));
      return true;
    }
    case internal::kLocalFrame_PluginActionAt_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_PluginActionAt_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_PluginActionAt_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Point p_location{};
      PluginActionType p_action{};
      LocalFrame_PluginActionAt_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadLocation(&p_location))
        success = false;
      if (success && !input_data_view.ReadAction(&p_action))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 22, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PluginActionAt(
std::move(p_location), 
std::move(p_action));
      return true;
    }
    case internal::kLocalFrame_AdvanceFocusInFrame_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_AdvanceFocusInFrame_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_AdvanceFocusInFrame_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FocusType p_focus_type{};
      absl::optional<::blink::RemoteFrameToken> p_source_frame_token{};
      LocalFrame_AdvanceFocusInFrame_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFocusType(&p_focus_type))
        success = false;
      if (success && !input_data_view.ReadSourceFrameToken(&p_source_frame_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 23, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdvanceFocusInFrame(
std::move(p_focus_type), 
std::move(p_source_frame_token));
      return true;
    }
    case internal::kLocalFrame_AdvanceFocusForIME_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_AdvanceFocusForIME_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_AdvanceFocusForIME_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::FocusType p_focus_type{};
      LocalFrame_AdvanceFocusForIME_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFocusType(&p_focus_type))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 24, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AdvanceFocusForIME(
std::move(p_focus_type));
      return true;
    }
    case internal::kLocalFrame_ReportContentSecurityPolicyViolation_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::network::mojom::CSPViolationPtr p_violation{};
      LocalFrame_ReportContentSecurityPolicyViolation_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadViolation(&p_violation))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 25, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ReportContentSecurityPolicyViolation(
std::move(p_violation));
      return true;
    }
    case internal::kLocalFrame_DidUpdateFramePolicy_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_DidUpdateFramePolicy_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_DidUpdateFramePolicy_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FramePolicy p_frame_policy{};
      LocalFrame_DidUpdateFramePolicy_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadFramePolicy(&p_frame_policy))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 26, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidUpdateFramePolicy(
std::move(p_frame_policy));
      return true;
    }
    case internal::kLocalFrame_PostMessageEvent_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_PostMessageEvent_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_PostMessageEvent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::blink::RemoteFrameToken> p_source_frame_token{};
      ::std::u16string p_source_origin{};
      ::std::u16string p_target_origin{};
      ::blink::TransferableMessage p_message{};
      LocalFrame_PostMessageEvent_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadSourceFrameToken(&p_source_frame_token))
        success = false;
      if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
        success = false;
      if (success && !input_data_view.ReadTargetOrigin(&p_target_origin))
        success = false;
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 27, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->PostMessageEvent(
std::move(p_source_frame_token), 
std::move(p_source_origin), 
std::move(p_target_origin), 
std::move(p_message));
      return true;
    }
    case internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name: {
      break;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequest_Name: {
      break;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name: {
      break;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name: {
      break;
    }
    case internal::kLocalFrame_BindReportingObserver_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_BindReportingObserver_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_BindReportingObserver_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<::blink::mojom::ReportingObserver> p_receiver{};
      LocalFrame_BindReportingObserver_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 32, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindReportingObserver(
std::move(p_receiver));
      return true;
    }
    case internal::kLocalFrame_UpdateOpener_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_UpdateOpener_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_UpdateOpener_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      absl::optional<::blink::FrameToken> p_opener_frame_token{};
      LocalFrame_UpdateOpener_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOpenerFrameToken(&p_opener_frame_token))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 33, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateOpener(
std::move(p_opener_frame_token));
      return true;
    }
    case internal::kLocalFrame_GetSavableResourceLinks_Name: {
      break;
    }
    case internal::kLocalFrame_MixedContentFound_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_MixedContentFound_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_MixedContentFound_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_main_resource_url{};
      ::GURL p_mixed_content_url{};
      ::blink::mojom::RequestContextType p_request_context{};
      bool p_was_allowed{};
      ::GURL p_url_before_redirects{};
      bool p_had_redirect{};
      ::network::mojom::SourceLocationPtr p_source_location{};
      LocalFrame_MixedContentFound_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMainResourceUrl(&p_main_resource_url))
        success = false;
      if (success && !input_data_view.ReadMixedContentUrl(&p_mixed_content_url))
        success = false;
      if (success && !input_data_view.ReadRequestContext(&p_request_context))
        success = false;
      if (success)
        p_was_allowed = input_data_view.was_allowed();
      if (success && !input_data_view.ReadUrlBeforeRedirects(&p_url_before_redirects))
        success = false;
      if (success)
        p_had_redirect = input_data_view.had_redirect();
      if (success && !input_data_view.ReadSourceLocation(&p_source_location))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 35, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->MixedContentFound(
std::move(p_main_resource_url), 
std::move(p_mixed_content_url), 
std::move(p_request_context), 
std::move(p_was_allowed), 
std::move(p_url_before_redirects), 
std::move(p_had_redirect), 
std::move(p_source_location));
      return true;
    }
    case internal::kLocalFrame_BindDevToolsAgent_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_BindDevToolsAgent_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_BindDevToolsAgent_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> p_agent_host{};
      ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> p_agent{};
      LocalFrame_BindDevToolsAgent_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_agent_host =
            input_data_view.TakeAgentHost<decltype(p_agent_host)>();
      }
      if (success) {
        p_agent =
            input_data_view.TakeAgent<decltype(p_agent)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 36, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindDevToolsAgent(
std::move(p_agent_host), 
std::move(p_agent));
      return true;
    }
    case internal::kLocalFrame_ExtractSmartClipData_Name: {
      break;
    }
    case internal::kLocalFrame_HandleRendererDebugURL_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_HandleRendererDebugURL_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_HandleRendererDebugURL_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      LocalFrame_HandleRendererDebugURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 38, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->HandleRendererDebugURL(
std::move(p_url));
      return true;
    }
    case internal::kLocalFrame_GetCanonicalUrlForSharing_Name: {
      break;
    }
    case internal::kLocalFrame_GetOpenGraphMetadata_Name: {
      break;
    }
    case internal::kLocalFrame_SetNavigationApiHistoryEntriesForRestore_Name: {

      DCHECK(message->is_serialized());
      internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data* params =
          reinterpret_cast<internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::NavigationApiHistoryEntryArraysPtr p_entry_arrays{};
      LocalFrame_SetNavigationApiHistoryEntriesForRestore_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadEntryArrays(&p_entry_arrays))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 41, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetNavigationApiHistoryEntriesForRestore(
std::move(p_entry_arrays));
      return true;
    }
  }
  return false;
}

// static
bool LocalFrameStubDispatch::AcceptWithResponder(
    LocalFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kLocalFrame_GetTextSurroundingSelection_Name: {

      internal::LocalFrame_GetTextSurroundingSelection_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_GetTextSurroundingSelection_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      uint32_t p_max_length{};
      LocalFrame_GetTextSurroundingSelection_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_max_length = input_data_view.max_length();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 0, false);
        return false;
      }
      LocalFrame::GetTextSurroundingSelectionCallback callback =
          LocalFrame_GetTextSurroundingSelection_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetTextSurroundingSelection(
std::move(p_max_length), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_SendInterventionReport_Name: {
      break;
    }
    case internal::kLocalFrame_SetFrameOwnerProperties_Name: {
      break;
    }
    case internal::kLocalFrame_NotifyUserActivation_Name: {
      break;
    }
    case internal::kLocalFrame_NotifyVirtualKeyboardOverlayRect_Name: {
      break;
    }
    case internal::kLocalFrame_AddMessageToConsole_Name: {
      break;
    }
    case internal::kLocalFrame_AddInspectorIssue_Name: {
      break;
    }
    case internal::kLocalFrame_SwapInImmediately_Name: {
      break;
    }
    case internal::kLocalFrame_CheckCompleted_Name: {
      break;
    }
    case internal::kLocalFrame_StopLoading_Name: {
      break;
    }
    case internal::kLocalFrame_Collapse_Name: {
      break;
    }
    case internal::kLocalFrame_EnableViewSourceMode_Name: {
      break;
    }
    case internal::kLocalFrame_Focus_Name: {
      break;
    }
    case internal::kLocalFrame_ClearFocusedElement_Name: {
      break;
    }
    case internal::kLocalFrame_GetResourceSnapshotForWebBundle_Name: {
      break;
    }
    case internal::kLocalFrame_CopyImageAt_Name: {
      break;
    }
    case internal::kLocalFrame_SaveImageAt_Name: {
      break;
    }
    case internal::kLocalFrame_ReportBlinkFeatureUsage_Name: {
      break;
    }
    case internal::kLocalFrame_RenderFallbackContent_Name: {
      break;
    }
    case internal::kLocalFrame_RenderFallbackContentWithResourceTiming_Name: {
      break;
    }
    case internal::kLocalFrame_BeforeUnload_Name: {

      internal::LocalFrame_BeforeUnload_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_BeforeUnload_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_is_reload{};
      LocalFrame_BeforeUnload_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_reload = input_data_view.is_reload();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 20, false);
        return false;
      }
      LocalFrame::BeforeUnloadCallback callback =
          LocalFrame_BeforeUnload_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BeforeUnload(
std::move(p_is_reload), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_MediaPlayerActionAt_Name: {
      break;
    }
    case internal::kLocalFrame_PluginActionAt_Name: {
      break;
    }
    case internal::kLocalFrame_AdvanceFocusInFrame_Name: {
      break;
    }
    case internal::kLocalFrame_AdvanceFocusForIME_Name: {
      break;
    }
    case internal::kLocalFrame_ReportContentSecurityPolicyViolation_Name: {
      break;
    }
    case internal::kLocalFrame_DidUpdateFramePolicy_Name: {
      break;
    }
    case internal::kLocalFrame_PostMessageEvent_Name: {
      break;
    }
    case internal::kLocalFrame_JavaScriptMethodExecuteRequest_Name: {

      internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_object_name{};
      ::std::u16string p_method_name{};
      ::base::Value::List p_arguments{};
      bool p_wants_result{};
      LocalFrame_JavaScriptMethodExecuteRequest_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadObjectName(&p_object_name))
        success = false;
      if (success && !input_data_view.ReadMethodName(&p_method_name))
        success = false;
      if (success && !input_data_view.ReadArguments(&p_arguments))
        success = false;
      if (success)
        p_wants_result = input_data_view.wants_result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 28, false);
        return false;
      }
      LocalFrame::JavaScriptMethodExecuteRequestCallback callback =
          LocalFrame_JavaScriptMethodExecuteRequest_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptMethodExecuteRequest(
std::move(p_object_name), 
std::move(p_method_name), 
std::move(p_arguments), 
std::move(p_wants_result), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequest_Name: {

      internal::LocalFrame_JavaScriptExecuteRequest_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_JavaScriptExecuteRequest_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_javascript{};
      bool p_wants_result{};
      LocalFrame_JavaScriptExecuteRequest_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadJavascript(&p_javascript))
        success = false;
      if (success)
        p_wants_result = input_data_view.wants_result();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 29, false);
        return false;
      }
      LocalFrame::JavaScriptExecuteRequestCallback callback =
          LocalFrame_JavaScriptExecuteRequest_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptExecuteRequest(
std::move(p_javascript), 
std::move(p_wants_result), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequestForTests_Name: {

      internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_javascript{};
      bool p_has_user_gesture{};
      bool p_resolve_promises{};
      int32_t p_world_id{};
      LocalFrame_JavaScriptExecuteRequestForTests_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadJavascript(&p_javascript))
        success = false;
      if (success)
        p_has_user_gesture = input_data_view.has_user_gesture();
      if (success)
        p_resolve_promises = input_data_view.resolve_promises();
      if (success)
        p_world_id = input_data_view.world_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 30, false);
        return false;
      }
      LocalFrame::JavaScriptExecuteRequestForTestsCallback callback =
          LocalFrame_JavaScriptExecuteRequestForTests_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptExecuteRequestForTests(
std::move(p_javascript), 
std::move(p_has_user_gesture), 
std::move(p_resolve_promises), 
std::move(p_world_id), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Name: {

      internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::std::u16string p_javascript{};
      bool p_wants_result{};
      int32_t p_world_id{};
      LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadJavascript(&p_javascript))
        success = false;
      if (success)
        p_wants_result = input_data_view.wants_result();
      if (success)
        p_world_id = input_data_view.world_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 31, false);
        return false;
      }
      LocalFrame::JavaScriptExecuteRequestInIsolatedWorldCallback callback =
          LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->JavaScriptExecuteRequestInIsolatedWorld(
std::move(p_javascript), 
std::move(p_wants_result), 
std::move(p_world_id), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_BindReportingObserver_Name: {
      break;
    }
    case internal::kLocalFrame_UpdateOpener_Name: {
      break;
    }
    case internal::kLocalFrame_GetSavableResourceLinks_Name: {

      internal::LocalFrame_GetSavableResourceLinks_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_GetSavableResourceLinks_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      LocalFrame_GetSavableResourceLinks_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 34, false);
        return false;
      }
      LocalFrame::GetSavableResourceLinksCallback callback =
          LocalFrame_GetSavableResourceLinks_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetSavableResourceLinks(std::move(callback));
      return true;
    }
    case internal::kLocalFrame_MixedContentFound_Name: {
      break;
    }
    case internal::kLocalFrame_BindDevToolsAgent_Name: {
      break;
    }
    case internal::kLocalFrame_ExtractSmartClipData_Name: {

      internal::LocalFrame_ExtractSmartClipData_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_ExtractSmartClipData_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_rect{};
      LocalFrame_ExtractSmartClipData_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 37, false);
        return false;
      }
      LocalFrame::ExtractSmartClipDataCallback callback =
          LocalFrame_ExtractSmartClipData_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ExtractSmartClipData(
std::move(p_rect), std::move(callback));
      return true;
    }
    case internal::kLocalFrame_HandleRendererDebugURL_Name: {
      break;
    }
    case internal::kLocalFrame_GetCanonicalUrlForSharing_Name: {

      internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      LocalFrame_GetCanonicalUrlForSharing_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 39, false);
        return false;
      }
      LocalFrame::GetCanonicalUrlForSharingCallback callback =
          LocalFrame_GetCanonicalUrlForSharing_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetCanonicalUrlForSharing(std::move(callback));
      return true;
    }
    case internal::kLocalFrame_GetOpenGraphMetadata_Name: {

      internal::LocalFrame_GetOpenGraphMetadata_Params_Data* params =
          reinterpret_cast<
              internal::LocalFrame_GetOpenGraphMetadata_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      LocalFrame_GetOpenGraphMetadata_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalFrame::Name_, 40, false);
        return false;
      }
      LocalFrame::GetOpenGraphMetadataCallback callback =
          LocalFrame_GetOpenGraphMetadata_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetOpenGraphMetadata(std::move(callback));
      return true;
    }
    case internal::kLocalFrame_SetNavigationApiHistoryEntriesForRestore_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kLocalFrameValidationInfo[] = {
    {&internal::LocalFrame_GetTextSurroundingSelection_Params_Data::Validate,
     &internal::LocalFrame_GetTextSurroundingSelection_ResponseParams_Data::Validate},
    {&internal::LocalFrame_SendInterventionReport_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_SetFrameOwnerProperties_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_NotifyUserActivation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_NotifyVirtualKeyboardOverlayRect_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_AddMessageToConsole_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_AddInspectorIssue_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_SwapInImmediately_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_CheckCompleted_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_StopLoading_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_Collapse_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_EnableViewSourceMode_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_Focus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_ClearFocusedElement_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_GetResourceSnapshotForWebBundle_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_CopyImageAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_SaveImageAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_ReportBlinkFeatureUsage_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_RenderFallbackContent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_RenderFallbackContentWithResourceTiming_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_BeforeUnload_Params_Data::Validate,
     &internal::LocalFrame_BeforeUnload_ResponseParams_Data::Validate},
    {&internal::LocalFrame_MediaPlayerActionAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_PluginActionAt_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_AdvanceFocusInFrame_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_AdvanceFocusForIME_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_ReportContentSecurityPolicyViolation_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_DidUpdateFramePolicy_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_PostMessageEvent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_JavaScriptMethodExecuteRequest_Params_Data::Validate,
     &internal::LocalFrame_JavaScriptMethodExecuteRequest_ResponseParams_Data::Validate},
    {&internal::LocalFrame_JavaScriptExecuteRequest_Params_Data::Validate,
     &internal::LocalFrame_JavaScriptExecuteRequest_ResponseParams_Data::Validate},
    {&internal::LocalFrame_JavaScriptExecuteRequestForTests_Params_Data::Validate,
     &internal::LocalFrame_JavaScriptExecuteRequestForTests_ResponseParams_Data::Validate},
    {&internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_Params_Data::Validate,
     &internal::LocalFrame_JavaScriptExecuteRequestInIsolatedWorld_ResponseParams_Data::Validate},
    {&internal::LocalFrame_BindReportingObserver_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_UpdateOpener_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_GetSavableResourceLinks_Params_Data::Validate,
     &internal::LocalFrame_GetSavableResourceLinks_ResponseParams_Data::Validate},
    {&internal::LocalFrame_MixedContentFound_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_BindDevToolsAgent_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_ExtractSmartClipData_Params_Data::Validate,
     &internal::LocalFrame_ExtractSmartClipData_ResponseParams_Data::Validate},
    {&internal::LocalFrame_HandleRendererDebugURL_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalFrame_GetCanonicalUrlForSharing_Params_Data::Validate,
     &internal::LocalFrame_GetCanonicalUrlForSharing_ResponseParams_Data::Validate},
    {&internal::LocalFrame_GetOpenGraphMetadata_Params_Data::Validate,
     &internal::LocalFrame_GetOpenGraphMetadata_ResponseParams_Data::Validate},
    {&internal::LocalFrame_SetNavigationApiHistoryEntriesForRestore_Params_Data::Validate,
     nullptr /* no response */},
};

bool LocalFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalFrameValidationInfo);
}

bool LocalFrameResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalFrame::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalFrameValidationInfo);
}
const char HighPriorityLocalFrame::Name_[] = "blink.mojom.HighPriorityLocalFrame";

HighPriorityLocalFrame::IPCStableHashFunction HighPriorityLocalFrame::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name: {
      return &HighPriorityLocalFrame::DispatchBeforeUnload_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* HighPriorityLocalFrame::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name:
            return "Receive blink::mojom::HighPriorityLocalFrame::DispatchBeforeUnload";
    }
  } else {
    switch (message.name()) {
      case internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name:
            return "Receive reply blink::mojom::HighPriorityLocalFrame::DispatchBeforeUnload";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t HighPriorityLocalFrame::DispatchBeforeUnload_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::HighPriorityLocalFrame::DispatchBeforeUnload");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback(
      HighPriorityLocalFrame::DispatchBeforeUnloadCallback callback
      ) : callback_(std::move(callback)) {
  }

  HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback(const HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback&) = delete;
  HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback& operator=(const HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  HighPriorityLocalFrame::DispatchBeforeUnloadCallback callback_;
};

HighPriorityLocalFrameProxy::HighPriorityLocalFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void HighPriorityLocalFrameProxy::DispatchBeforeUnload(
    bool in_is_reload, DispatchBeforeUnloadCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::HighPriorityLocalFrame::DispatchBeforeUnload", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("is_reload"), in_is_reload,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::HighPriorityLocalFrame_DispatchBeforeUnload_Params_Data> params(
          message);
  params.Allocate();
  params->is_reload = in_is_reload;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(HighPriorityLocalFrame::Name_);
  message.set_method_name("DispatchBeforeUnload");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}
class HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static HighPriorityLocalFrame::DispatchBeforeUnloadCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder> proxy(
        new HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "HighPriorityLocalFrame::DispatchBeforeUnloadCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time);
};

bool HighPriorityLocalFrame_DispatchBeforeUnload_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::HighPriorityLocalFrame_DispatchBeforeUnload_ResponseParams_Data* params =
      reinterpret_cast<
          internal::HighPriorityLocalFrame_DispatchBeforeUnload_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  bool p_proceed{};
  ::base::TimeTicks p_before_unload_start_time{};
  ::base::TimeTicks p_before_unload_end_time{};
  HighPriorityLocalFrame_DispatchBeforeUnload_ResponseParamsDataView input_data_view(params, message);
  
  if (success)
    p_proceed = input_data_view.proceed();
  if (success && !input_data_view.ReadBeforeUnloadStartTime(&p_before_unload_start_time))
    success = false;
  if (success && !input_data_view.ReadBeforeUnloadEndTime(&p_before_unload_end_time))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        HighPriorityLocalFrame::Name_, 0, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_proceed), 
std::move(p_before_unload_start_time), 
std::move(p_before_unload_end_time));
  return true;
}

void HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder::Run(
    bool in_proceed, ::base::TimeTicks in_before_unload_start_time, ::base::TimeTicks in_before_unload_end_time) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::HighPriorityLocalFrame::DispatchBeforeUnload", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("proceed"), in_proceed,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("before_unload_start_time"), in_before_unload_start_time,
                        "<value of type ::base::TimeTicks>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("before_unload_end_time"), in_before_unload_end_time,
                        "<value of type ::base::TimeTicks>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::HighPriorityLocalFrame_DispatchBeforeUnload_ResponseParams_Data> params(
          message);
  params.Allocate();
  params->proceed = in_proceed;
  mojo::internal::MessageFragment<
      typename decltype(params->before_unload_start_time)::BaseType> before_unload_start_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_before_unload_start_time, before_unload_start_time_fragment);
  params->before_unload_start_time.Set(
      before_unload_start_time_fragment.is_null() ? nullptr : before_unload_start_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->before_unload_start_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null before_unload_start_time in ");
  mojo::internal::MessageFragment<
      typename decltype(params->before_unload_end_time)::BaseType> before_unload_end_time_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
      in_before_unload_end_time, before_unload_end_time_fragment);
  params->before_unload_end_time.Set(
      before_unload_end_time_fragment.is_null() ? nullptr : before_unload_end_time_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->before_unload_end_time.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null before_unload_end_time in ");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(HighPriorityLocalFrame::Name_);
  message.set_method_name("DispatchBeforeUnload");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool HighPriorityLocalFrameStubDispatch::Accept(
    HighPriorityLocalFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name: {
      break;
    }
  }
  return false;
}

// static
bool HighPriorityLocalFrameStubDispatch::AcceptWithResponder(
    HighPriorityLocalFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kHighPriorityLocalFrame_DispatchBeforeUnload_Name: {

      internal::HighPriorityLocalFrame_DispatchBeforeUnload_Params_Data* params =
          reinterpret_cast<
              internal::HighPriorityLocalFrame_DispatchBeforeUnload_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      bool p_is_reload{};
      HighPriorityLocalFrame_DispatchBeforeUnload_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_is_reload = input_data_view.is_reload();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            HighPriorityLocalFrame::Name_, 0, false);
        return false;
      }
      HighPriorityLocalFrame::DispatchBeforeUnloadCallback callback =
          HighPriorityLocalFrame_DispatchBeforeUnload_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DispatchBeforeUnload(
std::move(p_is_reload), std::move(callback));
      return true;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kHighPriorityLocalFrameValidationInfo[] = {
    {&internal::HighPriorityLocalFrame_DispatchBeforeUnload_Params_Data::Validate,
     &internal::HighPriorityLocalFrame_DispatchBeforeUnload_ResponseParams_Data::Validate},
};

bool HighPriorityLocalFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::HighPriorityLocalFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kHighPriorityLocalFrameValidationInfo);
}

bool HighPriorityLocalFrameResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::HighPriorityLocalFrame::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kHighPriorityLocalFrameValidationInfo);
}
const char LocalMainFrame::Name_[] = "blink.mojom.LocalMainFrame";

LocalMainFrame::IPCStableHashFunction LocalMainFrame::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kLocalMainFrame_AnimateDoubleTapZoom_Name: {
      return &LocalMainFrame::AnimateDoubleTapZoom_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_SetScaleFactor_Name: {
      return &LocalMainFrame::SetScaleFactor_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_ClosePage_Name: {
      return &LocalMainFrame::ClosePage_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_SetInitialFocus_Name: {
      return &LocalMainFrame::SetInitialFocus_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_EnablePreferredSizeChangedMode_Name: {
      return &LocalMainFrame::EnablePreferredSizeChangedMode_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_ZoomToFindInPageRect_Name: {
      return &LocalMainFrame::ZoomToFindInPageRect_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_InstallCoopAccessMonitor_Name: {
      return &LocalMainFrame::InstallCoopAccessMonitor_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_OnPortalActivated_Name: {
      return &LocalMainFrame::OnPortalActivated_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_ForwardMessageFromHost_Name: {
      return &LocalMainFrame::ForwardMessageFromHost_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrame_UpdateBrowserControlsState_Name: {
      return &LocalMainFrame::UpdateBrowserControlsState_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* LocalMainFrame::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kLocalMainFrame_AnimateDoubleTapZoom_Name:
            return "Receive blink::mojom::LocalMainFrame::AnimateDoubleTapZoom";
      case internal::kLocalMainFrame_SetScaleFactor_Name:
            return "Receive blink::mojom::LocalMainFrame::SetScaleFactor";
      case internal::kLocalMainFrame_ClosePage_Name:
            return "Receive blink::mojom::LocalMainFrame::ClosePage";
      case internal::kLocalMainFrame_SetInitialFocus_Name:
            return "Receive blink::mojom::LocalMainFrame::SetInitialFocus";
      case internal::kLocalMainFrame_EnablePreferredSizeChangedMode_Name:
            return "Receive blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode";
      case internal::kLocalMainFrame_ZoomToFindInPageRect_Name:
            return "Receive blink::mojom::LocalMainFrame::ZoomToFindInPageRect";
      case internal::kLocalMainFrame_InstallCoopAccessMonitor_Name:
            return "Receive blink::mojom::LocalMainFrame::InstallCoopAccessMonitor";
      case internal::kLocalMainFrame_OnPortalActivated_Name:
            return "Receive blink::mojom::LocalMainFrame::OnPortalActivated";
      case internal::kLocalMainFrame_ForwardMessageFromHost_Name:
            return "Receive blink::mojom::LocalMainFrame::ForwardMessageFromHost";
      case internal::kLocalMainFrame_UpdateBrowserControlsState_Name:
            return "Receive blink::mojom::LocalMainFrame::UpdateBrowserControlsState";
    }
  } else {
    switch (message.name()) {
      case internal::kLocalMainFrame_AnimateDoubleTapZoom_Name:
            return "Receive reply blink::mojom::LocalMainFrame::AnimateDoubleTapZoom";
      case internal::kLocalMainFrame_SetScaleFactor_Name:
            return "Receive reply blink::mojom::LocalMainFrame::SetScaleFactor";
      case internal::kLocalMainFrame_ClosePage_Name:
            return "Receive reply blink::mojom::LocalMainFrame::ClosePage";
      case internal::kLocalMainFrame_SetInitialFocus_Name:
            return "Receive reply blink::mojom::LocalMainFrame::SetInitialFocus";
      case internal::kLocalMainFrame_EnablePreferredSizeChangedMode_Name:
            return "Receive reply blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode";
      case internal::kLocalMainFrame_ZoomToFindInPageRect_Name:
            return "Receive reply blink::mojom::LocalMainFrame::ZoomToFindInPageRect";
      case internal::kLocalMainFrame_InstallCoopAccessMonitor_Name:
            return "Receive reply blink::mojom::LocalMainFrame::InstallCoopAccessMonitor";
      case internal::kLocalMainFrame_OnPortalActivated_Name:
            return "Receive reply blink::mojom::LocalMainFrame::OnPortalActivated";
      case internal::kLocalMainFrame_ForwardMessageFromHost_Name:
            return "Receive reply blink::mojom::LocalMainFrame::ForwardMessageFromHost";
      case internal::kLocalMainFrame_UpdateBrowserControlsState_Name:
            return "Receive reply blink::mojom::LocalMainFrame::UpdateBrowserControlsState";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalMainFrame::AnimateDoubleTapZoom_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::AnimateDoubleTapZoom");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::SetScaleFactor_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::SetScaleFactor");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::ClosePage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::ClosePage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::SetInitialFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::SetInitialFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::EnablePreferredSizeChangedMode_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::ZoomToFindInPageRect_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::ZoomToFindInPageRect");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::InstallCoopAccessMonitor_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::InstallCoopAccessMonitor");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::OnPortalActivated_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::OnPortalActivated");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::ForwardMessageFromHost_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::ForwardMessageFromHost");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrame::UpdateBrowserControlsState_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrame::UpdateBrowserControlsState");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class LocalMainFrame_ClosePage_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalMainFrame_ClosePage_ForwardToCallback(
      LocalMainFrame::ClosePageCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalMainFrame_ClosePage_ForwardToCallback(const LocalMainFrame_ClosePage_ForwardToCallback&) = delete;
  LocalMainFrame_ClosePage_ForwardToCallback& operator=(const LocalMainFrame_ClosePage_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalMainFrame::ClosePageCallback callback_;
};

class LocalMainFrame_OnPortalActivated_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalMainFrame_OnPortalActivated_ForwardToCallback(
      LocalMainFrame::OnPortalActivatedCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalMainFrame_OnPortalActivated_ForwardToCallback(const LocalMainFrame_OnPortalActivated_ForwardToCallback&) = delete;
  LocalMainFrame_OnPortalActivated_ForwardToCallback& operator=(const LocalMainFrame_OnPortalActivated_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalMainFrame::OnPortalActivatedCallback callback_;
};

LocalMainFrameProxy::LocalMainFrameProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void LocalMainFrameProxy::AnimateDoubleTapZoom(
    const ::gfx::Point& in_point, const ::gfx::Rect& in_rect) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::AnimateDoubleTapZoom", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("point"), in_point,
                        "<value of type const ::gfx::Point&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect"), in_rect,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_AnimateDoubleTapZoom_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->point)::BaseType> point_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::PointDataView>(
      in_point, point_fragment);
  params->point.Set(
      point_fragment.is_null() ? nullptr : point_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->point.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null point in LocalMainFrame.AnimateDoubleTapZoom request");
  mojo::internal::MessageFragment<
      typename decltype(params->rect)::BaseType> rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, rect_fragment);
  params->rect.Set(
      rect_fragment.is_null() ? nullptr : rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in LocalMainFrame.AnimateDoubleTapZoom request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("AnimateDoubleTapZoom");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::SetScaleFactor(
    float in_scale) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::SetScaleFactor", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("scale"), in_scale,
                        "<value of type float>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_SetScaleFactor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_SetScaleFactor_Params_Data> params(
          message);
  params.Allocate();
  params->scale = in_scale;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("SetScaleFactor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::ClosePage(
    ClosePageCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrame::ClosePage");
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_ClosePage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_ClosePage_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("ClosePage");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalMainFrame_ClosePage_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameProxy::SetInitialFocus(
    bool in_reverse) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::SetInitialFocus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reverse"), in_reverse,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_SetInitialFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_SetInitialFocus_Params_Data> params(
          message);
  params.Allocate();
  params->reverse = in_reverse;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("SetInitialFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::EnablePreferredSizeChangedMode(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrame::EnablePreferredSizeChangedMode");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_EnablePreferredSizeChangedMode_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("EnablePreferredSizeChangedMode");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::ZoomToFindInPageRect(
    const ::gfx::Rect& in_rect_in_root_frame) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::ZoomToFindInPageRect", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect_in_root_frame"), in_rect_in_root_frame,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_ZoomToFindInPageRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->rect_in_root_frame)::BaseType> rect_in_root_frame_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect_in_root_frame, rect_in_root_frame_fragment);
  params->rect_in_root_frame.Set(
      rect_in_root_frame_fragment.is_null() ? nullptr : rect_in_root_frame_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect_in_root_frame.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect_in_root_frame in LocalMainFrame.ZoomToFindInPageRect request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("ZoomToFindInPageRect");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::InstallCoopAccessMonitor(
    const ::blink::FrameToken& in_accessed_window, ::network::mojom::CrossOriginOpenerPolicyReporterParamsPtr in_coop_reporter_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::InstallCoopAccessMonitor", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("accessed_window"), in_accessed_window,
                        "<value of type const ::blink::FrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("coop_reporter_info"), in_coop_reporter_info,
                        "<value of type ::network::mojom::CrossOriginOpenerPolicyReporterParamsPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_InstallCoopAccessMonitor_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<decltype(params->accessed_window)>
      accessed_window_fragment(params.message());
  accessed_window_fragment.Claim(&params->accessed_window);
  mojo::internal::Serialize<::blink::mojom::FrameTokenDataView>(
      in_accessed_window, accessed_window_fragment, true);
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->accessed_window.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null accessed_window in LocalMainFrame.InstallCoopAccessMonitor request");
  mojo::internal::MessageFragment<
      typename decltype(params->coop_reporter_info)::BaseType> coop_reporter_info_fragment(
          params.message());
  mojo::internal::Serialize<::network::mojom::CrossOriginOpenerPolicyReporterParamsDataView>(
      in_coop_reporter_info, coop_reporter_info_fragment);
  params->coop_reporter_info.Set(
      coop_reporter_info_fragment.is_null() ? nullptr : coop_reporter_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->coop_reporter_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null coop_reporter_info in LocalMainFrame.InstallCoopAccessMonitor request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("InstallCoopAccessMonitor");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::OnPortalActivated(
    const ::blink::PortalToken& in_portal_token, ::mojo::PendingAssociatedRemote<::blink::mojom::Portal> in_portal, ::mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> in_portal_client, ::blink::TransferableMessage in_data, uint64_t in_trace_id, OnPortalActivatedCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::OnPortalActivated", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal_token"), in_portal_token,
                        "<value of type const ::blink::PortalToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal"), in_portal,
                        "<value of type ::mojo::PendingAssociatedRemote<::blink::mojom::Portal>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("portal_client"), in_portal_client,
                        "<value of type ::mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type ::blink::TransferableMessage>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("trace_id"), in_trace_id,
                        "<value of type uint64_t>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_OnPortalActivated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_OnPortalActivated_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->portal_token)::BaseType> portal_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::PortalTokenDataView>(
      in_portal_token, portal_token_fragment);
  params->portal_token.Set(
      portal_token_fragment.is_null() ? nullptr : portal_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->portal_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null portal_token in LocalMainFrame.OnPortalActivated request");
  mojo::internal::Serialize<::blink::mojom::PortalAssociatedPtrInfoDataView>(
      in_portal, &params->portal, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal in LocalMainFrame.OnPortalActivated request");
  mojo::internal::Serialize<::blink::mojom::PortalClientAssociatedRequestDataView>(
      in_portal_client, &params->portal_client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->portal_client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_INTERFACE_ID,
      "invalid portal_client in LocalMainFrame.OnPortalActivated request");
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType> data_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_data, data_fragment);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in LocalMainFrame.OnPortalActivated request");
  params->trace_id = in_trace_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("OnPortalActivated");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalMainFrame_OnPortalActivated_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameProxy::ForwardMessageFromHost(
    ::blink::TransferableMessage in_message, const ::url::Origin& in_source_origin) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::ForwardMessageFromHost", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("message"), in_message,
                        "<value of type ::blink::TransferableMessage>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("source_origin"), in_source_origin,
                        "<value of type const ::url::Origin&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_ForwardMessageFromHost_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_ForwardMessageFromHost_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->message)::BaseType> message_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TransferableMessageDataView>(
      in_message, message_fragment);
  params->message.Set(
      message_fragment.is_null() ? nullptr : message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null message in LocalMainFrame.ForwardMessageFromHost request");
  mojo::internal::MessageFragment<
      typename decltype(params->source_origin)::BaseType> source_origin_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::OriginDataView>(
      in_source_origin, source_origin_fragment);
  params->source_origin.Set(
      source_origin_fragment.is_null() ? nullptr : source_origin_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->source_origin.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null source_origin in LocalMainFrame.ForwardMessageFromHost request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("ForwardMessageFromHost");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameProxy::UpdateBrowserControlsState(
    ::cc::BrowserControlsState in_constraints, ::cc::BrowserControlsState in_current, bool in_animate) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrame::UpdateBrowserControlsState", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("constraints"), in_constraints,
                        "<value of type ::cc::BrowserControlsState>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("current"), in_current,
                        "<value of type ::cc::BrowserControlsState>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("animate"), in_animate,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_UpdateBrowserControlsState_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::cc::mojom::BrowserControlsState>(
      in_constraints, &params->constraints);
  mojo::internal::Serialize<::cc::mojom::BrowserControlsState>(
      in_current, &params->current);
  params->animate = in_animate;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("UpdateBrowserControlsState");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalMainFrame_ClosePage_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalMainFrame::ClosePageCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalMainFrame_ClosePage_ProxyToResponder> proxy(
        new LocalMainFrame_ClosePage_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalMainFrame_ClosePage_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalMainFrame_ClosePage_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalMainFrame_ClosePage_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalMainFrame::ClosePageCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool LocalMainFrame_ClosePage_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalMainFrame_ClosePage_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalMainFrame_ClosePage_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  LocalMainFrame_ClosePage_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalMainFrame::Name_, 2, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void LocalMainFrame_ClosePage_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrame::ClosePage");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_ClosePage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_ClosePage_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("ClosePage");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalMainFrame_OnPortalActivated_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalMainFrame::OnPortalActivatedCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalMainFrame_OnPortalActivated_ProxyToResponder> proxy(
        new LocalMainFrame_OnPortalActivated_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalMainFrame_OnPortalActivated_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalMainFrame_OnPortalActivated_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalMainFrame_OnPortalActivated_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalMainFrame::OnPortalActivatedCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      ::blink::mojom::PortalActivateResult in_result);
};

bool LocalMainFrame_OnPortalActivated_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalMainFrame_OnPortalActivated_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalMainFrame_OnPortalActivated_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  ::blink::mojom::PortalActivateResult p_result{};
  LocalMainFrame_OnPortalActivated_ResponseParamsDataView input_data_view(params, message);
  
  if (success && !input_data_view.ReadResult(&p_result))
    success = false;
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalMainFrame::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run(
std::move(p_result));
  return true;
}

void LocalMainFrame_OnPortalActivated_ProxyToResponder::Run(
    ::blink::mojom::PortalActivateResult in_result) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send reply blink::mojom::LocalMainFrame::OnPortalActivated", "async_response_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("result"), in_result,
                        "<value of type ::blink::mojom::PortalActivateResult>");
   });
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrame_OnPortalActivated_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrame_OnPortalActivated_ResponseParams_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::PortalActivateResult>(
      in_result, &params->result);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrame::Name_);
  message.set_method_name("OnPortalActivated");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool LocalMainFrameStubDispatch::Accept(
    LocalMainFrame* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kLocalMainFrame_AnimateDoubleTapZoom_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Point p_point{};
      ::gfx::Rect p_rect{};
      LocalMainFrame_AnimateDoubleTapZoom_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPoint(&p_point))
        success = false;
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AnimateDoubleTapZoom(
std::move(p_point), 
std::move(p_rect));
      return true;
    }
    case internal::kLocalMainFrame_SetScaleFactor_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_SetScaleFactor_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_SetScaleFactor_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      float p_scale{};
      LocalMainFrame_SetScaleFactor_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_scale = input_data_view.scale();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetScaleFactor(
std::move(p_scale));
      return true;
    }
    case internal::kLocalMainFrame_ClosePage_Name: {
      break;
    }
    case internal::kLocalMainFrame_SetInitialFocus_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_SetInitialFocus_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_SetInitialFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_reverse{};
      LocalMainFrame_SetInitialFocus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_reverse = input_data_view.reverse();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetInitialFocus(
std::move(p_reverse));
      return true;
    }
    case internal::kLocalMainFrame_EnablePreferredSizeChangedMode_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalMainFrame_EnablePreferredSizeChangedMode_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->EnablePreferredSizeChangedMode();
      return true;
    }
    case internal::kLocalMainFrame_ZoomToFindInPageRect_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_rect_in_root_frame{};
      LocalMainFrame_ZoomToFindInPageRect_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadRectInRootFrame(&p_rect_in_root_frame))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ZoomToFindInPageRect(
std::move(p_rect_in_root_frame));
      return true;
    }
    case internal::kLocalMainFrame_InstallCoopAccessMonitor_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::FrameToken p_accessed_window{};
      ::network::mojom::CrossOriginOpenerPolicyReporterParamsPtr p_coop_reporter_info{};
      LocalMainFrame_InstallCoopAccessMonitor_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadAccessedWindow(&p_accessed_window))
        success = false;
      if (success && !input_data_view.ReadCoopReporterInfo(&p_coop_reporter_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->InstallCoopAccessMonitor(
std::move(p_accessed_window), 
std::move(p_coop_reporter_info));
      return true;
    }
    case internal::kLocalMainFrame_OnPortalActivated_Name: {
      break;
    }
    case internal::kLocalMainFrame_ForwardMessageFromHost_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_ForwardMessageFromHost_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_ForwardMessageFromHost_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::TransferableMessage p_message{};
      ::url::Origin p_source_origin{};
      LocalMainFrame_ForwardMessageFromHost_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadMessage(&p_message))
        success = false;
      if (success && !input_data_view.ReadSourceOrigin(&p_source_origin))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ForwardMessageFromHost(
std::move(p_message), 
std::move(p_source_origin));
      return true;
    }
    case internal::kLocalMainFrame_UpdateBrowserControlsState_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::cc::BrowserControlsState p_constraints{};
      ::cc::BrowserControlsState p_current{};
      bool p_animate{};
      LocalMainFrame_UpdateBrowserControlsState_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadConstraints(&p_constraints))
        success = false;
      if (success && !input_data_view.ReadCurrent(&p_current))
        success = false;
      if (success)
        p_animate = input_data_view.animate();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateBrowserControlsState(
std::move(p_constraints), 
std::move(p_current), 
std::move(p_animate));
      return true;
    }
  }
  return false;
}

// static
bool LocalMainFrameStubDispatch::AcceptWithResponder(
    LocalMainFrame* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kLocalMainFrame_AnimateDoubleTapZoom_Name: {
      break;
    }
    case internal::kLocalMainFrame_SetScaleFactor_Name: {
      break;
    }
    case internal::kLocalMainFrame_ClosePage_Name: {

      internal::LocalMainFrame_ClosePage_Params_Data* params =
          reinterpret_cast<
              internal::LocalMainFrame_ClosePage_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      LocalMainFrame_ClosePage_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 2, false);
        return false;
      }
      LocalMainFrame::ClosePageCallback callback =
          LocalMainFrame_ClosePage_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ClosePage(std::move(callback));
      return true;
    }
    case internal::kLocalMainFrame_SetInitialFocus_Name: {
      break;
    }
    case internal::kLocalMainFrame_EnablePreferredSizeChangedMode_Name: {
      break;
    }
    case internal::kLocalMainFrame_ZoomToFindInPageRect_Name: {
      break;
    }
    case internal::kLocalMainFrame_InstallCoopAccessMonitor_Name: {
      break;
    }
    case internal::kLocalMainFrame_OnPortalActivated_Name: {

      internal::LocalMainFrame_OnPortalActivated_Params_Data* params =
          reinterpret_cast<
              internal::LocalMainFrame_OnPortalActivated_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::PortalToken p_portal_token{};
      ::mojo::PendingAssociatedRemote<::blink::mojom::Portal> p_portal{};
      ::mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> p_portal_client{};
      ::blink::TransferableMessage p_data{};
      uint64_t p_trace_id{};
      LocalMainFrame_OnPortalActivated_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPortalToken(&p_portal_token))
        success = false;
      if (success) {
        p_portal =
            input_data_view.TakePortal<decltype(p_portal)>();
      }
      if (success) {
        p_portal_client =
            input_data_view.TakePortalClient<decltype(p_portal_client)>();
      }
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (success)
        p_trace_id = input_data_view.trace_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrame::Name_, 7, false);
        return false;
      }
      LocalMainFrame::OnPortalActivatedCallback callback =
          LocalMainFrame_OnPortalActivated_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnPortalActivated(
std::move(p_portal_token), 
std::move(p_portal), 
std::move(p_portal_client), 
std::move(p_data), 
std::move(p_trace_id), std::move(callback));
      return true;
    }
    case internal::kLocalMainFrame_ForwardMessageFromHost_Name: {
      break;
    }
    case internal::kLocalMainFrame_UpdateBrowserControlsState_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kLocalMainFrameValidationInfo[] = {
    {&internal::LocalMainFrame_AnimateDoubleTapZoom_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_SetScaleFactor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_ClosePage_Params_Data::Validate,
     &internal::LocalMainFrame_ClosePage_ResponseParams_Data::Validate},
    {&internal::LocalMainFrame_SetInitialFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_EnablePreferredSizeChangedMode_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_ZoomToFindInPageRect_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_InstallCoopAccessMonitor_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_OnPortalActivated_Params_Data::Validate,
     &internal::LocalMainFrame_OnPortalActivated_ResponseParams_Data::Validate},
    {&internal::LocalMainFrame_ForwardMessageFromHost_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrame_UpdateBrowserControlsState_Params_Data::Validate,
     nullptr /* no response */},
};

bool LocalMainFrameRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalMainFrame::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalMainFrameValidationInfo);
}

bool LocalMainFrameResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalMainFrame::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalMainFrameValidationInfo);
}
const char LocalMainFrameHost::Name_[] = "blink.mojom.LocalMainFrameHost";

LocalMainFrameHost::IPCStableHashFunction LocalMainFrameHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kLocalMainFrameHost_ScaleFactorChanged_Name: {
      return &LocalMainFrameHost::ScaleFactorChanged_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_ContentsPreferredSizeChanged_Name: {
      return &LocalMainFrameHost::ContentsPreferredSizeChanged_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_TextAutosizerPageInfoChanged_Name: {
      return &LocalMainFrameHost::TextAutosizerPageInfoChanged_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_FocusPage_Name: {
      return &LocalMainFrameHost::FocusPage_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_TakeFocus_Name: {
      return &LocalMainFrameHost::TakeFocus_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_UpdateTargetURL_Name: {
      return &LocalMainFrameHost::UpdateTargetURL_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_RequestClose_Name: {
      return &LocalMainFrameHost::RequestClose_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_ShowCreatedWindow_Name: {
      return &LocalMainFrameHost::ShowCreatedWindow_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_SetWindowRect_Name: {
      return &LocalMainFrameHost::SetWindowRect_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Name: {
      return &LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint_Sym::IPCStableHash;
    }
    case internal::kLocalMainFrameHost_DidAccessInitialMainDocument_Name: {
      return &LocalMainFrameHost::DidAccessInitialMainDocument_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* LocalMainFrameHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kLocalMainFrameHost_ScaleFactorChanged_Name:
            return "Receive blink::mojom::LocalMainFrameHost::ScaleFactorChanged";
      case internal::kLocalMainFrameHost_ContentsPreferredSizeChanged_Name:
            return "Receive blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged";
      case internal::kLocalMainFrameHost_TextAutosizerPageInfoChanged_Name:
            return "Receive blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged";
      case internal::kLocalMainFrameHost_FocusPage_Name:
            return "Receive blink::mojom::LocalMainFrameHost::FocusPage";
      case internal::kLocalMainFrameHost_TakeFocus_Name:
            return "Receive blink::mojom::LocalMainFrameHost::TakeFocus";
      case internal::kLocalMainFrameHost_UpdateTargetURL_Name:
            return "Receive blink::mojom::LocalMainFrameHost::UpdateTargetURL";
      case internal::kLocalMainFrameHost_RequestClose_Name:
            return "Receive blink::mojom::LocalMainFrameHost::RequestClose";
      case internal::kLocalMainFrameHost_ShowCreatedWindow_Name:
            return "Receive blink::mojom::LocalMainFrameHost::ShowCreatedWindow";
      case internal::kLocalMainFrameHost_SetWindowRect_Name:
            return "Receive blink::mojom::LocalMainFrameHost::SetWindowRect";
      case internal::kLocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Name:
            return "Receive blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint";
      case internal::kLocalMainFrameHost_DidAccessInitialMainDocument_Name:
            return "Receive blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument";
    }
  } else {
    switch (message.name()) {
      case internal::kLocalMainFrameHost_ScaleFactorChanged_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::ScaleFactorChanged";
      case internal::kLocalMainFrameHost_ContentsPreferredSizeChanged_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged";
      case internal::kLocalMainFrameHost_TextAutosizerPageInfoChanged_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged";
      case internal::kLocalMainFrameHost_FocusPage_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::FocusPage";
      case internal::kLocalMainFrameHost_TakeFocus_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::TakeFocus";
      case internal::kLocalMainFrameHost_UpdateTargetURL_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::UpdateTargetURL";
      case internal::kLocalMainFrameHost_RequestClose_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::RequestClose";
      case internal::kLocalMainFrameHost_ShowCreatedWindow_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::ShowCreatedWindow";
      case internal::kLocalMainFrameHost_SetWindowRect_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::SetWindowRect";
      case internal::kLocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint";
      case internal::kLocalMainFrameHost_DidAccessInitialMainDocument_Name:
            return "Receive reply blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t LocalMainFrameHost::ScaleFactorChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::ScaleFactorChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::ContentsPreferredSizeChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::TextAutosizerPageInfoChanged_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::FocusPage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::FocusPage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::TakeFocus_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::TakeFocus");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::UpdateTargetURL_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::UpdateTargetURL");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::RequestClose_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::RequestClose");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::ShowCreatedWindow_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::ShowCreatedWindow");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::SetWindowRect_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::SetWindowRect");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t LocalMainFrameHost::DidAccessInitialMainDocument_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

class LocalMainFrameHost_UpdateTargetURL_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalMainFrameHost_UpdateTargetURL_ForwardToCallback(
      LocalMainFrameHost::UpdateTargetURLCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalMainFrameHost_UpdateTargetURL_ForwardToCallback(const LocalMainFrameHost_UpdateTargetURL_ForwardToCallback&) = delete;
  LocalMainFrameHost_UpdateTargetURL_ForwardToCallback& operator=(const LocalMainFrameHost_UpdateTargetURL_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalMainFrameHost::UpdateTargetURLCallback callback_;
};

class LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback(
      LocalMainFrameHost::ShowCreatedWindowCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback(const LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback&) = delete;
  LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback& operator=(const LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalMainFrameHost::ShowCreatedWindowCallback callback_;
};

class LocalMainFrameHost_SetWindowRect_ForwardToCallback
    : public mojo::MessageReceiver {
 public:
  LocalMainFrameHost_SetWindowRect_ForwardToCallback(
      LocalMainFrameHost::SetWindowRectCallback callback
      ) : callback_(std::move(callback)) {
  }

  LocalMainFrameHost_SetWindowRect_ForwardToCallback(const LocalMainFrameHost_SetWindowRect_ForwardToCallback&) = delete;
  LocalMainFrameHost_SetWindowRect_ForwardToCallback& operator=(const LocalMainFrameHost_SetWindowRect_ForwardToCallback&) = delete;

  bool Accept(mojo::Message* message) override;
 private:
  LocalMainFrameHost::SetWindowRectCallback callback_;
};

LocalMainFrameHostProxy::LocalMainFrameHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void LocalMainFrameHostProxy::ScaleFactorChanged(
    float in_scale) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::ScaleFactorChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("scale"), in_scale,
                        "<value of type float>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_ScaleFactorChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data> params(
          message);
  params.Allocate();
  params->scale = in_scale;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("ScaleFactorChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::ContentsPreferredSizeChanged(
    const ::gfx::Size& in_pref_size) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::ContentsPreferredSizeChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("pref_size"), in_pref_size,
                        "<value of type const ::gfx::Size&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_ContentsPreferredSizeChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->pref_size)::BaseType> pref_size_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::SizeDataView>(
      in_pref_size, pref_size_fragment);
  params->pref_size.Set(
      pref_size_fragment.is_null() ? nullptr : pref_size_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->pref_size.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null pref_size in LocalMainFrameHost.ContentsPreferredSizeChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("ContentsPreferredSizeChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::TextAutosizerPageInfoChanged(
    ::blink::mojom::TextAutosizerPageInfoPtr in_page_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::TextAutosizerPageInfoChanged", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("page_info"), in_page_info,
                        "<value of type ::blink::mojom::TextAutosizerPageInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_TextAutosizerPageInfoChanged_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->page_info)::BaseType> page_info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::TextAutosizerPageInfoDataView>(
      in_page_info, page_info_fragment);
  params->page_info.Set(
      page_info_fragment.is_null() ? nullptr : page_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->page_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null page_info in LocalMainFrameHost.TextAutosizerPageInfoChanged request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("TextAutosizerPageInfoChanged");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::FocusPage(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::FocusPage");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_FocusPage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_FocusPage_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("FocusPage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::TakeFocus(
    bool in_reverse) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::TakeFocus", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("reverse"), in_reverse,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_TakeFocus_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_TakeFocus_Params_Data> params(
          message);
  params.Allocate();
  params->reverse = in_reverse;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("TakeFocus");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::UpdateTargetURL(
    const ::GURL& in_url, UpdateTargetURLCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::UpdateTargetURL", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("url"), in_url,
                        "<value of type const ::GURL&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_UpdateTargetURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_UpdateTargetURL_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->url)::BaseType> url_fragment(
          params.message());
  mojo::internal::Serialize<::url::mojom::UrlDataView>(
      in_url, url_fragment);
  params->url.Set(
      url_fragment.is_null() ? nullptr : url_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->url.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null url in LocalMainFrameHost.UpdateTargetURL request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("UpdateTargetURL");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalMainFrameHost_UpdateTargetURL_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameHostProxy::RequestClose(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::RequestClose");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_RequestClose_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_RequestClose_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("RequestClose");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::ShowCreatedWindow(
    const ::blink::LocalFrameToken& in_opener_frame_token, ::WindowOpenDisposition in_disposition, const ::gfx::Rect& in_rect, bool in_opened_by_user_gesture, ShowCreatedWindowCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::ShowCreatedWindow", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opener_frame_token"), in_opener_frame_token,
                        "<value of type const ::blink::LocalFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("disposition"), in_disposition,
                        "<value of type ::WindowOpenDisposition>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("rect"), in_rect,
                        "<value of type const ::gfx::Rect&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("opened_by_user_gesture"), in_opened_by_user_gesture,
                        "<value of type bool>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_ShowCreatedWindow_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->opener_frame_token)::BaseType> opener_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_opener_frame_token, opener_frame_token_fragment);
  params->opener_frame_token.Set(
      opener_frame_token_fragment.is_null() ? nullptr : opener_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->opener_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null opener_frame_token in LocalMainFrameHost.ShowCreatedWindow request");
  mojo::internal::Serialize<::ui::mojom::WindowOpenDisposition>(
      in_disposition, &params->disposition);
  mojo::internal::MessageFragment<
      typename decltype(params->rect)::BaseType> rect_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_rect, rect_fragment);
  params->rect.Set(
      rect_fragment.is_null() ? nullptr : rect_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->rect.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null rect in LocalMainFrameHost.ShowCreatedWindow request");
  params->opened_by_user_gesture = in_opened_by_user_gesture;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("ShowCreatedWindow");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameHostProxy::SetWindowRect(
    const ::gfx::Rect& in_bounds, SetWindowRectCallback callback) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::LocalMainFrameHost::SetWindowRect", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("bounds"), in_bounds,
                        "<value of type const ::gfx::Rect&>");
   });
#endif
  const bool kExpectsResponse = true;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_SetWindowRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_SetWindowRect_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->bounds)::BaseType> bounds_fragment(
          params.message());
  mojo::internal::Serialize<::gfx::mojom::RectDataView>(
      in_bounds, bounds_fragment);
  params->bounds.Set(
      bounds_fragment.is_null() ? nullptr : bounds_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->bounds.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null bounds in LocalMainFrameHost.SetWindowRect request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("SetWindowRect");
#endif
  std::unique_ptr<mojo::MessageReceiver> responder(
      new LocalMainFrameHost_SetWindowRect_ForwardToCallback(
          std::move(callback)));
  ::mojo::internal::SendMojoMessage(*receiver_, message, std::move(responder));
}

void LocalMainFrameHostProxy::DidFirstVisuallyNonEmptyPaint(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::DidFirstVisuallyNonEmptyPaint");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("DidFirstVisuallyNonEmptyPaint");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void LocalMainFrameHostProxy::DidAccessInitialMainDocument(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::LocalMainFrameHost::DidAccessInitialMainDocument");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_DidAccessInitialMainDocument_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("DidAccessInitialMainDocument");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}
class LocalMainFrameHost_UpdateTargetURL_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalMainFrameHost::UpdateTargetURLCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalMainFrameHost_UpdateTargetURL_ProxyToResponder> proxy(
        new LocalMainFrameHost_UpdateTargetURL_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalMainFrameHost_UpdateTargetURL_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalMainFrameHost_UpdateTargetURL_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalMainFrameHost_UpdateTargetURL_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalMainFrameHost::UpdateTargetURLCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool LocalMainFrameHost_UpdateTargetURL_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  LocalMainFrameHost_UpdateTargetURL_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalMainFrameHost::Name_, 5, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void LocalMainFrameHost_UpdateTargetURL_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrameHost::UpdateTargetURL");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_UpdateTargetURL_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("UpdateTargetURL");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalMainFrameHost::ShowCreatedWindowCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder> proxy(
        new LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalMainFrameHost::ShowCreatedWindowCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool LocalMainFrameHost_ShowCreatedWindow_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  LocalMainFrameHost_ShowCreatedWindow_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalMainFrameHost::Name_, 7, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrameHost::ShowCreatedWindow");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_ShowCreatedWindow_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("ShowCreatedWindow");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}
class LocalMainFrameHost_SetWindowRect_ProxyToResponder : public ::mojo::internal::ProxyToResponder {
 public:
  static LocalMainFrameHost::SetWindowRectCallback CreateCallback(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
    std::unique_ptr<LocalMainFrameHost_SetWindowRect_ProxyToResponder> proxy(
        new LocalMainFrameHost_SetWindowRect_ProxyToResponder(
            message, std::move(responder)));
    return base::BindOnce(&LocalMainFrameHost_SetWindowRect_ProxyToResponder::Run,
                          std::move(proxy));
  }

  ~LocalMainFrameHost_SetWindowRect_ProxyToResponder() {
#if DCHECK_IS_ON()
    if (responder_) {
      // If we're being destroyed without being run, we want to ensure the
      // binding endpoint has been closed. This checks for that asynchronously.
      // We pass a bound generated callback to handle the response so that any
      // resulting DCHECK stack will have useful interface type information.
      responder_->IsConnectedAsync(base::BindOnce(&OnIsConnectedComplete));
    }
#endif
  }

 private:
  LocalMainFrameHost_SetWindowRect_ProxyToResponder(
      ::mojo::Message& message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder)
      : ::mojo::internal::ProxyToResponder(message, std::move(responder)) {
  }

#if DCHECK_IS_ON()
  static void OnIsConnectedComplete(bool connected) {
    DCHECK(!connected)
        << "LocalMainFrameHost::SetWindowRectCallback was destroyed without "
        << "first either being run or its corresponding binding being closed. "
        << "It is an error to drop response callbacks which still correspond "
        << "to an open interface pipe.";
  }
#endif

  void Run(
      );
};

bool LocalMainFrameHost_SetWindowRect_ForwardToCallback::Accept(
    mojo::Message* message) {

  DCHECK(message->is_serialized());
  internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data* params =
      reinterpret_cast<
          internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data*>(
              message->mutable_payload());
  
  bool success = true;
  LocalMainFrameHost_SetWindowRect_ResponseParamsDataView input_data_view(params, message);
  
  if (!success) {
    ReportValidationErrorForMessage(
        message,
        mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
        LocalMainFrameHost::Name_, 8, true);
    return false;
  }
  if (!callback_.is_null())
    std::move(callback_).Run();
  return true;
}

void LocalMainFrameHost_SetWindowRect_ProxyToResponder::Run(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send reply blink::mojom::LocalMainFrameHost::SetWindowRect");
#endif
  
  const uint32_t kFlags = mojo::Message::kFlagIsResponse |
      ((is_sync_) ? mojo::Message::kFlagIsSync : 0) |
      ((true) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kLocalMainFrameHost_SetWindowRect_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(LocalMainFrameHost::Name_);
  message.set_method_name("SetWindowRect");
#endif

  message.set_request_id(request_id_);
  message.set_trace_nonce(trace_nonce_);
  ::mojo::internal::SendMojoMessage(*responder_, message);
  // SendMojoMessage() fails silently if the responder connection is closed,
  // or if the message is malformed.
  //
  // TODO(darin): If Accept() returns false due to a malformed message, that
  // may be good reason to close the connection. However, we don't have a
  // way to do that from here. We should add a way.
  responder_ = nullptr;
}

// static
bool LocalMainFrameHostStubDispatch::Accept(
    LocalMainFrameHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kLocalMainFrameHost_ScaleFactorChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      float p_scale{};
      LocalMainFrameHost_ScaleFactorChanged_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_scale = input_data_view.scale();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ScaleFactorChanged(
std::move(p_scale));
      return true;
    }
    case internal::kLocalMainFrameHost_ContentsPreferredSizeChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::gfx::Size p_pref_size{};
      LocalMainFrameHost_ContentsPreferredSizeChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPrefSize(&p_pref_size))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ContentsPreferredSizeChanged(
std::move(p_pref_size));
      return true;
    }
    case internal::kLocalMainFrameHost_TextAutosizerPageInfoChanged_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::mojom::TextAutosizerPageInfoPtr p_page_info{};
      LocalMainFrameHost_TextAutosizerPageInfoChanged_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadPageInfo(&p_page_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TextAutosizerPageInfoChanged(
std::move(p_page_info));
      return true;
    }
    case internal::kLocalMainFrameHost_FocusPage_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_FocusPage_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_FocusPage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalMainFrameHost_FocusPage_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->FocusPage();
      return true;
    }
    case internal::kLocalMainFrameHost_TakeFocus_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_TakeFocus_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_TakeFocus_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      bool p_reverse{};
      LocalMainFrameHost_TakeFocus_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_reverse = input_data_view.reverse();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TakeFocus(
std::move(p_reverse));
      return true;
    }
    case internal::kLocalMainFrameHost_UpdateTargetURL_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_RequestClose_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_RequestClose_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_RequestClose_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalMainFrameHost_RequestClose_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RequestClose();
      return true;
    }
    case internal::kLocalMainFrameHost_ShowCreatedWindow_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_SetWindowRect_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidFirstVisuallyNonEmptyPaint();
      return true;
    }
    case internal::kLocalMainFrameHost_DidAccessInitialMainDocument_Name: {

      DCHECK(message->is_serialized());
      internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data* params =
          reinterpret_cast<internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      LocalMainFrameHost_DidAccessInitialMainDocument_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 10, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->DidAccessInitialMainDocument();
      return true;
    }
  }
  return false;
}

// static
bool LocalMainFrameHostStubDispatch::AcceptWithResponder(
    LocalMainFrameHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kLocalMainFrameHost_ScaleFactorChanged_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_ContentsPreferredSizeChanged_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_TextAutosizerPageInfoChanged_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_FocusPage_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_TakeFocus_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_UpdateTargetURL_Name: {

      internal::LocalMainFrameHost_UpdateTargetURL_Params_Data* params =
          reinterpret_cast<
              internal::LocalMainFrameHost_UpdateTargetURL_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::GURL p_url{};
      LocalMainFrameHost_UpdateTargetURL_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadUrl(&p_url))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 5, false);
        return false;
      }
      LocalMainFrameHost::UpdateTargetURLCallback callback =
          LocalMainFrameHost_UpdateTargetURL_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdateTargetURL(
std::move(p_url), std::move(callback));
      return true;
    }
    case internal::kLocalMainFrameHost_RequestClose_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_ShowCreatedWindow_Name: {

      internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data* params =
          reinterpret_cast<
              internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::blink::LocalFrameToken p_opener_frame_token{};
      ::WindowOpenDisposition p_disposition{};
      ::gfx::Rect p_rect{};
      bool p_opened_by_user_gesture{};
      LocalMainFrameHost_ShowCreatedWindow_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadOpenerFrameToken(&p_opener_frame_token))
        success = false;
      if (success && !input_data_view.ReadDisposition(&p_disposition))
        success = false;
      if (success && !input_data_view.ReadRect(&p_rect))
        success = false;
      if (success)
        p_opened_by_user_gesture = input_data_view.opened_by_user_gesture();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 7, false);
        return false;
      }
      LocalMainFrameHost::ShowCreatedWindowCallback callback =
          LocalMainFrameHost_ShowCreatedWindow_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ShowCreatedWindow(
std::move(p_opener_frame_token), 
std::move(p_disposition), 
std::move(p_rect), 
std::move(p_opened_by_user_gesture), std::move(callback));
      return true;
    }
    case internal::kLocalMainFrameHost_SetWindowRect_Name: {

      internal::LocalMainFrameHost_SetWindowRect_Params_Data* params =
          reinterpret_cast<
              internal::LocalMainFrameHost_SetWindowRect_Params_Data*>(
                  message->mutable_payload());
      
      bool success = true;
      ::gfx::Rect p_bounds{};
      LocalMainFrameHost_SetWindowRect_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadBounds(&p_bounds))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            LocalMainFrameHost::Name_, 8, false);
        return false;
      }
      LocalMainFrameHost::SetWindowRectCallback callback =
          LocalMainFrameHost_SetWindowRect_ProxyToResponder::CreateCallback(
              *message, std::move(responder));
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SetWindowRect(
std::move(p_bounds), std::move(callback));
      return true;
    }
    case internal::kLocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Name: {
      break;
    }
    case internal::kLocalMainFrameHost_DidAccessInitialMainDocument_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kLocalMainFrameHostValidationInfo[] = {
    {&internal::LocalMainFrameHost_ScaleFactorChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_ContentsPreferredSizeChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_TextAutosizerPageInfoChanged_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_FocusPage_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_TakeFocus_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_UpdateTargetURL_Params_Data::Validate,
     &internal::LocalMainFrameHost_UpdateTargetURL_ResponseParams_Data::Validate},
    {&internal::LocalMainFrameHost_RequestClose_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_ShowCreatedWindow_Params_Data::Validate,
     &internal::LocalMainFrameHost_ShowCreatedWindow_ResponseParams_Data::Validate},
    {&internal::LocalMainFrameHost_SetWindowRect_Params_Data::Validate,
     &internal::LocalMainFrameHost_SetWindowRect_ResponseParams_Data::Validate},
    {&internal::LocalMainFrameHost_DidFirstVisuallyNonEmptyPaint_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::LocalMainFrameHost_DidAccessInitialMainDocument_Params_Data::Validate,
     nullptr /* no response */},
};

bool LocalMainFrameHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalMainFrameHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kLocalMainFrameHostValidationInfo);
}

bool LocalMainFrameHostResponseValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::LocalMainFrameHost::Name_;
  return mojo::internal::ValidateResponseGenericPacked(message, name, kLocalMainFrameHostValidationInfo);
}


}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::SavableSubframe::DataView, ::blink::mojom::SavableSubframePtr>::Read(
    ::blink::mojom::SavableSubframe::DataView input,
    ::blink::mojom::SavableSubframePtr* output) {
  bool success = true;
  ::blink::mojom::SavableSubframePtr result(::blink::mojom::SavableSubframe::New());
  
      if (success && !input.ReadOriginalUrl(&result->original_url))
        success = false;
      if (success && !input.ReadSubframeToken(&result->subframe_token))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::GetSavableResourceLinksReply::DataView, ::blink::mojom::GetSavableResourceLinksReplyPtr>::Read(
    ::blink::mojom::GetSavableResourceLinksReply::DataView input,
    ::blink::mojom::GetSavableResourceLinksReplyPtr* output) {
  bool success = true;
  ::blink::mojom::GetSavableResourceLinksReplyPtr result(::blink::mojom::GetSavableResourceLinksReply::New());
  
      if (success && !input.ReadResourcesList(&result->resources_list))
        success = false;
      if (success && !input.ReadReferrer(&result->referrer))
        success = false;
      if (success && !input.ReadSubframes(&result->subframes))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::FindInPageResultAXParams::DataView, ::blink::mojom::FindInPageResultAXParamsPtr>::Read(
    ::blink::mojom::FindInPageResultAXParams::DataView input,
    ::blink::mojom::FindInPageResultAXParamsPtr* output) {
  bool success = true;
  ::blink::mojom::FindInPageResultAXParamsPtr result(::blink::mojom::FindInPageResultAXParams::New());
  
      if (success)
        result->request_id = input.request_id();
      if (success)
        result->match_index = input.match_index();
      if (success)
        result->start_id = input.start_id();
      if (success)
        result->start_offset = input.start_offset();
      if (success)
        result->end_id = input.end_id();
      if (success)
        result->end_offset = input.end_offset();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::DownloadURLParams::DataView, ::blink::mojom::DownloadURLParamsPtr>::Read(
    ::blink::mojom::DownloadURLParams::DataView input,
    ::blink::mojom::DownloadURLParamsPtr* output) {
  bool success = true;
  ::blink::mojom::DownloadURLParamsPtr result(::blink::mojom::DownloadURLParams::New());
  
      if (success && !input.ReadUrl(&result->url))
        success = false;
      if (success && !input.ReadReferrer(&result->referrer))
        success = false;
      if (success && !input.ReadInitiatorOrigin(&result->initiator_origin))
        success = false;
      if (success && !input.ReadSuggestedName(&result->suggested_name))
        success = false;
      if (success && !input.ReadCrossOriginRedirects(&result->cross_origin_redirects))
        success = false;
      if (success) {
        result->blob_url_token =
            input.TakeBlobUrlToken<decltype(result->blob_url_token)>();
      }
      if (success) {
        result->data_url_blob =
            input.TakeDataUrlBlob<decltype(result->data_url_blob)>();
      }
      if (success)
        result->is_context_menu_save = input.is_context_menu_save();
      if (success)
        result->has_user_gesture = input.has_user_gesture();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::IframeAttributes::DataView, ::blink::mojom::IframeAttributesPtr>::Read(
    ::blink::mojom::IframeAttributes::DataView input,
    ::blink::mojom::IframeAttributesPtr* output) {
  bool success = true;
  ::blink::mojom::IframeAttributesPtr result(::blink::mojom::IframeAttributes::New());
  
      if (success && !input.ReadParsedCspAttribute(&result->parsed_csp_attribute))
        success = false;
      if (success)
        result->anonymous = input.anonymous();
      if (success && !input.ReadId(&result->id))
        success = false;
      if (success && !input.ReadName(&result->name))
        success = false;
      if (success && !input.ReadSrc(&result->src))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


KeepAliveHandleAsyncWaiter::KeepAliveHandleAsyncWaiter(
    KeepAliveHandle* proxy) : proxy_(proxy) {}

KeepAliveHandleAsyncWaiter::~KeepAliveHandleAsyncWaiter() = default;




void KeepAliveHandleFactoryInterceptorForTesting::IssueKeepAliveHandle(::mojo::PendingReceiver<KeepAliveHandle> keep_alive_handle) {
  GetForwardingInterface()->IssueKeepAliveHandle(std::move(keep_alive_handle));
}
KeepAliveHandleFactoryAsyncWaiter::KeepAliveHandleFactoryAsyncWaiter(
    KeepAliveHandleFactory* proxy) : proxy_(proxy) {}

KeepAliveHandleFactoryAsyncWaiter::~KeepAliveHandleFactoryAsyncWaiter() = default;




void LocalFrameHostInterceptorForTesting::EnterFullscreen(::blink::mojom::FullscreenOptionsPtr options, EnterFullscreenCallback callback) {
  GetForwardingInterface()->EnterFullscreen(std::move(options), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::ExitFullscreen() {
  GetForwardingInterface()->ExitFullscreen();
}
void LocalFrameHostInterceptorForTesting::FullscreenStateChanged(bool is_fullscreen, ::blink::mojom::FullscreenOptionsPtr options) {
  GetForwardingInterface()->FullscreenStateChanged(std::move(is_fullscreen), std::move(options));
}
void LocalFrameHostInterceptorForTesting::RegisterProtocolHandler(const std::string& scheme, const ::GURL& url, bool user_gesture) {
  GetForwardingInterface()->RegisterProtocolHandler(std::move(scheme), std::move(url), std::move(user_gesture));
}
void LocalFrameHostInterceptorForTesting::UnregisterProtocolHandler(const std::string& scheme, const ::GURL& url, bool user_gesture) {
  GetForwardingInterface()->UnregisterProtocolHandler(std::move(scheme), std::move(url), std::move(user_gesture));
}
void LocalFrameHostInterceptorForTesting::DidDisplayInsecureContent() {
  GetForwardingInterface()->DidDisplayInsecureContent();
}
void LocalFrameHostInterceptorForTesting::DidContainInsecureFormAction() {
  GetForwardingInterface()->DidContainInsecureFormAction();
}
void LocalFrameHostInterceptorForTesting::MainDocumentElementAvailable(bool uses_temporary_zoom_level) {
  GetForwardingInterface()->MainDocumentElementAvailable(std::move(uses_temporary_zoom_level));
}
void LocalFrameHostInterceptorForTesting::SetNeedsOcclusionTracking(bool needs_tracking) {
  GetForwardingInterface()->SetNeedsOcclusionTracking(std::move(needs_tracking));
}
void LocalFrameHostInterceptorForTesting::SetVirtualKeyboardOverlayPolicy(bool vk_overlays_content) {
  GetForwardingInterface()->SetVirtualKeyboardOverlayPolicy(std::move(vk_overlays_content));
}
void LocalFrameHostInterceptorForTesting::VisibilityChanged(::blink::mojom::FrameVisibility visibility) {
  GetForwardingInterface()->VisibilityChanged(std::move(visibility));
}
void LocalFrameHostInterceptorForTesting::DidChangeThemeColor(absl::optional<::SkColor> theme_color) {
  GetForwardingInterface()->DidChangeThemeColor(std::move(theme_color));
}
void LocalFrameHostInterceptorForTesting::DidChangeBackgroundColor(::SkColor background_color, bool color_adjust) {
  GetForwardingInterface()->DidChangeBackgroundColor(std::move(background_color), std::move(color_adjust));
}
void LocalFrameHostInterceptorForTesting::DidFailLoadWithError(const ::GURL& url, int32_t error_code) {
  GetForwardingInterface()->DidFailLoadWithError(std::move(url), std::move(error_code));
}
void LocalFrameHostInterceptorForTesting::DidFocusFrame() {
  GetForwardingInterface()->DidFocusFrame();
}
void LocalFrameHostInterceptorForTesting::DidCallFocus() {
  GetForwardingInterface()->DidCallFocus();
}
void LocalFrameHostInterceptorForTesting::EnforceInsecureRequestPolicy(::blink::mojom::InsecureRequestPolicy policy_bitmap) {
  GetForwardingInterface()->EnforceInsecureRequestPolicy(std::move(policy_bitmap));
}
void LocalFrameHostInterceptorForTesting::EnforceInsecureNavigationsSet(const std::vector<uint32_t>& set) {
  GetForwardingInterface()->EnforceInsecureNavigationsSet(std::move(set));
}
void LocalFrameHostInterceptorForTesting::SuddenTerminationDisablerChanged(bool present, ::blink::mojom::SuddenTerminationDisablerType disabler_type) {
  GetForwardingInterface()->SuddenTerminationDisablerChanged(std::move(present), std::move(disabler_type));
}
void LocalFrameHostInterceptorForTesting::HadStickyUserActivationBeforeNavigationChanged(bool has_gesture) {
  GetForwardingInterface()->HadStickyUserActivationBeforeNavigationChanged(std::move(has_gesture));
}
void LocalFrameHostInterceptorForTesting::ScrollRectToVisibleInParentFrame(const ::gfx::RectF& rect_to_scroll, ::blink::mojom::ScrollIntoViewParamsPtr params) {
  GetForwardingInterface()->ScrollRectToVisibleInParentFrame(std::move(rect_to_scroll), std::move(params));
}
void LocalFrameHostInterceptorForTesting::BubbleLogicalScrollInParentFrame(::blink::mojom::ScrollDirection direction, ::ui::ScrollGranularity granularity) {
  GetForwardingInterface()->BubbleLogicalScrollInParentFrame(std::move(direction), std::move(granularity));
}
void LocalFrameHostInterceptorForTesting::DidBlockNavigation(const ::GURL& blocked_url, const ::GURL& initiator_url, ::blink::mojom::NavigationBlockedReason reason) {
  GetForwardingInterface()->DidBlockNavigation(std::move(blocked_url), std::move(initiator_url), std::move(reason));
}
void LocalFrameHostInterceptorForTesting::DidChangeLoadProgress(double load_progress) {
  GetForwardingInterface()->DidChangeLoadProgress(std::move(load_progress));
}
void LocalFrameHostInterceptorForTesting::DidFinishLoad(const ::GURL& validated_url) {
  GetForwardingInterface()->DidFinishLoad(std::move(validated_url));
}
void LocalFrameHostInterceptorForTesting::DispatchLoad() {
  GetForwardingInterface()->DispatchLoad();
}
void LocalFrameHostInterceptorForTesting::GoToEntryAtOffset(int32_t offset, bool has_user_gesture) {
  GetForwardingInterface()->GoToEntryAtOffset(std::move(offset), std::move(has_user_gesture));
}
void LocalFrameHostInterceptorForTesting::NavigateToNavigationApiKey(const std::string& key, bool has_user_gesture) {
  GetForwardingInterface()->NavigateToNavigationApiKey(std::move(key), std::move(has_user_gesture));
}
void LocalFrameHostInterceptorForTesting::UpdateTitle(const absl::optional<::std::u16string>& title, ::base::i18n::TextDirection title_direction) {
  GetForwardingInterface()->UpdateTitle(std::move(title), std::move(title_direction));
}
void LocalFrameHostInterceptorForTesting::UpdateUserActivationState(::blink::mojom::UserActivationUpdateType update_type, ::blink::mojom::UserActivationNotificationType notification_type) {
  GetForwardingInterface()->UpdateUserActivationState(std::move(update_type), std::move(notification_type));
}
void LocalFrameHostInterceptorForTesting::HandleAccessibilityFindInPageResult(FindInPageResultAXParamsPtr params) {
  GetForwardingInterface()->HandleAccessibilityFindInPageResult(std::move(params));
}
void LocalFrameHostInterceptorForTesting::HandleAccessibilityFindInPageTermination() {
  GetForwardingInterface()->HandleAccessibilityFindInPageTermination();
}
void LocalFrameHostInterceptorForTesting::DocumentOnLoadCompleted() {
  GetForwardingInterface()->DocumentOnLoadCompleted();
}
void LocalFrameHostInterceptorForTesting::ForwardResourceTimingToParent(::blink::mojom::ResourceTimingInfoPtr timing) {
  GetForwardingInterface()->ForwardResourceTimingToParent(std::move(timing));
}
void LocalFrameHostInterceptorForTesting::DidDispatchDOMContentLoadedEvent() {
  GetForwardingInterface()->DidDispatchDOMContentLoadedEvent();
}
void LocalFrameHostInterceptorForTesting::RunModalAlertDialog(const ::std::u16string& alert_message, bool disable_third_party_subframe_suppresion, RunModalAlertDialogCallback callback) {
  GetForwardingInterface()->RunModalAlertDialog(std::move(alert_message), std::move(disable_third_party_subframe_suppresion), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::RunModalConfirmDialog(const ::std::u16string& alert_message, bool disable_third_party_subframe_suppresion, RunModalConfirmDialogCallback callback) {
  GetForwardingInterface()->RunModalConfirmDialog(std::move(alert_message), std::move(disable_third_party_subframe_suppresion), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::RunModalPromptDialog(const ::std::u16string& alert_message, const ::std::u16string& default_value, bool disable_third_party_subframe_suppresion, RunModalPromptDialogCallback callback) {
  GetForwardingInterface()->RunModalPromptDialog(std::move(alert_message), std::move(default_value), std::move(disable_third_party_subframe_suppresion), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::RunBeforeUnloadConfirm(bool is_reload, RunBeforeUnloadConfirmCallback callback) {
  GetForwardingInterface()->RunBeforeUnloadConfirm(std::move(is_reload), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::UpdateFaviconURL(std::vector<::blink::mojom::FaviconURLPtr> favicon_urls) {
  GetForwardingInterface()->UpdateFaviconURL(std::move(favicon_urls));
}
void LocalFrameHostInterceptorForTesting::DownloadURL(DownloadURLParamsPtr params) {
  GetForwardingInterface()->DownloadURL(std::move(params));
}
void LocalFrameHostInterceptorForTesting::FocusedElementChanged(bool is_editable_element, const ::gfx::Rect& bounds_in_frame_widget, ::blink::mojom::FocusType focus_type) {
  GetForwardingInterface()->FocusedElementChanged(std::move(is_editable_element), std::move(bounds_in_frame_widget), std::move(focus_type));
}
void LocalFrameHostInterceptorForTesting::TextSelectionChanged(const ::std::u16string& text, uint32_t offset, const ::gfx::Range& range) {
  GetForwardingInterface()->TextSelectionChanged(std::move(text), std::move(offset), std::move(range));
}
void LocalFrameHostInterceptorForTesting::ShowPopupMenu(::mojo::PendingRemote<::blink::mojom::PopupMenuClient> popup_client, const ::gfx::Rect& bounds, int32_t item_height, double font_size, int32_t selected_item, std::vector<::blink::mojom::MenuItemPtr> menu_items, bool right_aligned, bool allow_multiple_selection) {
  GetForwardingInterface()->ShowPopupMenu(std::move(popup_client), std::move(bounds), std::move(item_height), std::move(font_size), std::move(selected_item), std::move(menu_items), std::move(right_aligned), std::move(allow_multiple_selection));
}
void LocalFrameHostInterceptorForTesting::CreateNewPopupWidget(::mojo::PendingAssociatedReceiver<::blink::mojom::PopupWidgetHost> popup_host, ::mojo::PendingAssociatedReceiver<::blink::mojom::WidgetHost> blink_widget_host, ::mojo::PendingAssociatedRemote<::blink::mojom::Widget> blink_widget) {
  GetForwardingInterface()->CreateNewPopupWidget(std::move(popup_host), std::move(blink_widget_host), std::move(blink_widget));
}
void LocalFrameHostInterceptorForTesting::ShowContextMenu(::mojo::PendingAssociatedRemote<::blink::mojom::ContextMenuClient> client, const ::blink::UntrustworthyContextMenuParams& params) {
  GetForwardingInterface()->ShowContextMenu(std::move(client), std::move(params));
}
void LocalFrameHostInterceptorForTesting::DidLoadResourceFromMemoryCache(const ::GURL& url, const std::string& http_method, const std::string& mime_type, ::network::mojom::RequestDestination request_destination, bool include_credentials) {
  GetForwardingInterface()->DidLoadResourceFromMemoryCache(std::move(url), std::move(http_method), std::move(mime_type), std::move(request_destination), std::move(include_credentials));
}
void LocalFrameHostInterceptorForTesting::DidChangeFrameOwnerProperties(const ::blink::FrameToken& child_frame_token, ::blink::mojom::FrameOwnerPropertiesPtr frame_owner_properties) {
  GetForwardingInterface()->DidChangeFrameOwnerProperties(std::move(child_frame_token), std::move(frame_owner_properties));
}
void LocalFrameHostInterceptorForTesting::DidChangeOpener(const absl::optional<::blink::LocalFrameToken>& opener_frame) {
  GetForwardingInterface()->DidChangeOpener(std::move(opener_frame));
}
void LocalFrameHostInterceptorForTesting::DidChangeFramePolicy(const ::blink::FrameToken& child_frame_token, const ::blink::FramePolicy& frame_policy) {
  GetForwardingInterface()->DidChangeFramePolicy(std::move(child_frame_token), std::move(frame_policy));
}
void LocalFrameHostInterceptorForTesting::DidChangeIframeAttributes(const ::blink::FrameToken& child_frame_token, IframeAttributesPtr attributes) {
  GetForwardingInterface()->DidChangeIframeAttributes(std::move(child_frame_token), std::move(attributes));
}
void LocalFrameHostInterceptorForTesting::CapturePaintPreviewOfSubframe(const ::gfx::Rect& clip_rect, const ::base::UnguessableToken& guid) {
  GetForwardingInterface()->CapturePaintPreviewOfSubframe(std::move(clip_rect), std::move(guid));
}
void LocalFrameHostInterceptorForTesting::SetCloseListener(::mojo::PendingRemote<::blink::mojom::CloseListener> listener) {
  GetForwardingInterface()->SetCloseListener(std::move(listener));
}
void LocalFrameHostInterceptorForTesting::Detach() {
  GetForwardingInterface()->Detach();
}
void LocalFrameHostInterceptorForTesting::GetKeepAliveHandleFactory(::mojo::PendingReceiver<KeepAliveHandleFactory> factory) {
  GetForwardingInterface()->GetKeepAliveHandleFactory(std::move(factory));
}
void LocalFrameHostInterceptorForTesting::DidAddMessageToConsole(::blink::mojom::ConsoleMessageLevel log_level, const ::std::u16string& msg, uint32_t line_number, const absl::optional<::std::u16string>& source_id, const absl::optional<::std::u16string>& untrusted_stack_trace) {
  GetForwardingInterface()->DidAddMessageToConsole(std::move(log_level), std::move(msg), std::move(line_number), std::move(source_id), std::move(untrusted_stack_trace));
}
void LocalFrameHostInterceptorForTesting::FrameSizeChanged(const ::gfx::Size& size) {
  GetForwardingInterface()->FrameSizeChanged(std::move(size));
}
void LocalFrameHostInterceptorForTesting::DidInferColorScheme(::blink::mojom::PreferredColorScheme color_scheme) {
  GetForwardingInterface()->DidInferColorScheme(std::move(color_scheme));
}
void LocalFrameHostInterceptorForTesting::DidChangeSrcDoc(const ::blink::FrameToken& child_frame_token, const std::string& srcdoc_value) {
  GetForwardingInterface()->DidChangeSrcDoc(std::move(child_frame_token), std::move(srcdoc_value));
}
void LocalFrameHostInterceptorForTesting::ReceivedDelegatedCapability(::blink::mojom::DelegatedCapability delegated_capability) {
  GetForwardingInterface()->ReceivedDelegatedCapability(std::move(delegated_capability));
}
void LocalFrameHostInterceptorForTesting::CreatePortal(::mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, CreatePortalCallback callback) {
  GetForwardingInterface()->CreatePortal(std::move(portal), std::move(client), std::move(remote_frame_interfaces), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::AdoptPortal(const ::blink::PortalToken& portal_token, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, AdoptPortalCallback callback) {
  GetForwardingInterface()->AdoptPortal(std::move(portal_token), std::move(remote_frame_interfaces), std::move(callback));
}
void LocalFrameHostInterceptorForTesting::CreateFencedFrame(::mojo::PendingAssociatedReceiver<::blink::mojom::FencedFrameOwnerHost> fenced_frame, ::blink::mojom::FencedFrameMode mode, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, const ::blink::RemoteFrameToken& frame_token, const ::base::UnguessableToken& devtools_frame_token) {
  GetForwardingInterface()->CreateFencedFrame(std::move(fenced_frame), std::move(mode), std::move(remote_frame_interfaces), std::move(frame_token), std::move(devtools_frame_token));
}
LocalFrameHostAsyncWaiter::LocalFrameHostAsyncWaiter(
    LocalFrameHost* proxy) : proxy_(proxy) {}

LocalFrameHostAsyncWaiter::~LocalFrameHostAsyncWaiter() = default;

void LocalFrameHostAsyncWaiter::EnterFullscreen(
    ::blink::mojom::FullscreenOptionsPtr options, bool* out_granted) {
  base::RunLoop loop;
  proxy_->EnterFullscreen(std::move(options),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_granted
,
             bool granted) {*out_granted = std::move(granted);
            loop->Quit();
          },
          &loop,
          out_granted));
  loop.Run();
}
void LocalFrameHostAsyncWaiter::RunModalAlertDialog(
    const ::std::u16string& alert_message, bool disable_third_party_subframe_suppresion) {
  base::RunLoop loop;
  proxy_->RunModalAlertDialog(std::move(alert_message),std::move(disable_third_party_subframe_suppresion),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void LocalFrameHostAsyncWaiter::RunModalConfirmDialog(
    const ::std::u16string& alert_message, bool disable_third_party_subframe_suppresion, bool* out_success) {
  base::RunLoop loop;
  proxy_->RunModalConfirmDialog(std::move(alert_message),std::move(disable_third_party_subframe_suppresion),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void LocalFrameHostAsyncWaiter::RunModalPromptDialog(
    const ::std::u16string& alert_message, const ::std::u16string& default_value, bool disable_third_party_subframe_suppresion, bool* out_success, ::std::u16string* out_result) {
  base::RunLoop loop;
  proxy_->RunModalPromptDialog(std::move(alert_message),std::move(default_value),std::move(disable_third_party_subframe_suppresion),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             ::std::u16string* out_result
,
             bool success,
             const ::std::u16string& result) {*out_success = std::move(success);*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_success,
          out_result));
  loop.Run();
}
void LocalFrameHostAsyncWaiter::RunBeforeUnloadConfirm(
    bool is_reload, bool* out_success) {
  base::RunLoop loop;
  proxy_->RunBeforeUnloadConfirm(std::move(is_reload),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_success
,
             bool success) {*out_success = std::move(success);
            loop->Quit();
          },
          &loop,
          out_success));
  loop.Run();
}
void LocalFrameHostAsyncWaiter::CreatePortal(
    ::mojo::PendingAssociatedReceiver<::blink::mojom::Portal> portal, ::mojo::PendingAssociatedRemote<::blink::mojom::PortalClient> client, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, ::blink::mojom::FrameReplicationStatePtr* out_initial_replicated_state, ::blink::PortalToken* out_portal_token, ::blink::RemoteFrameToken* out_frame_token, ::base::UnguessableToken* out_devtools_frame_token) {
  base::RunLoop loop;
  proxy_->CreatePortal(std::move(portal),std::move(client),std::move(remote_frame_interfaces),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::FrameReplicationStatePtr* out_initial_replicated_state
,
             ::blink::PortalToken* out_portal_token
,
             ::blink::RemoteFrameToken* out_frame_token
,
             ::base::UnguessableToken* out_devtools_frame_token
,
             ::blink::mojom::FrameReplicationStatePtr initial_replicated_state,
             const ::blink::PortalToken& portal_token,
             const ::blink::RemoteFrameToken& frame_token,
             const ::base::UnguessableToken& devtools_frame_token) {*out_initial_replicated_state = std::move(initial_replicated_state);*out_portal_token = std::move(portal_token);*out_frame_token = std::move(frame_token);*out_devtools_frame_token = std::move(devtools_frame_token);
            loop->Quit();
          },
          &loop,
          out_initial_replicated_state,
          out_portal_token,
          out_frame_token,
          out_devtools_frame_token));
  loop.Run();
}
void LocalFrameHostAsyncWaiter::AdoptPortal(
    const ::blink::PortalToken& portal_token, ::blink::mojom::RemoteFrameInterfacesFromRendererPtr remote_frame_interfaces, ::blink::mojom::FrameReplicationStatePtr* out_replicated_state, ::blink::RemoteFrameToken* out_frame_token, ::base::UnguessableToken* out_devtools_frame_token) {
  base::RunLoop loop;
  proxy_->AdoptPortal(std::move(portal_token),std::move(remote_frame_interfaces),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::FrameReplicationStatePtr* out_replicated_state
,
             ::blink::RemoteFrameToken* out_frame_token
,
             ::base::UnguessableToken* out_devtools_frame_token
,
             ::blink::mojom::FrameReplicationStatePtr replicated_state,
             const ::blink::RemoteFrameToken& frame_token,
             const ::base::UnguessableToken& devtools_frame_token) {*out_replicated_state = std::move(replicated_state);*out_frame_token = std::move(frame_token);*out_devtools_frame_token = std::move(devtools_frame_token);
            loop->Quit();
          },
          &loop,
          out_replicated_state,
          out_frame_token,
          out_devtools_frame_token));
  loop.Run();
}



void LocalFrameInterceptorForTesting::GetTextSurroundingSelection(uint32_t max_length, GetTextSurroundingSelectionCallback callback) {
  GetForwardingInterface()->GetTextSurroundingSelection(std::move(max_length), std::move(callback));
}
void LocalFrameInterceptorForTesting::SendInterventionReport(const std::string& id, const std::string& message) {
  GetForwardingInterface()->SendInterventionReport(std::move(id), std::move(message));
}
void LocalFrameInterceptorForTesting::SetFrameOwnerProperties(::blink::mojom::FrameOwnerPropertiesPtr properties) {
  GetForwardingInterface()->SetFrameOwnerProperties(std::move(properties));
}
void LocalFrameInterceptorForTesting::NotifyUserActivation(::blink::mojom::UserActivationNotificationType notification_type) {
  GetForwardingInterface()->NotifyUserActivation(std::move(notification_type));
}
void LocalFrameInterceptorForTesting::NotifyVirtualKeyboardOverlayRect(const ::gfx::Rect& keyboard_rect) {
  GetForwardingInterface()->NotifyVirtualKeyboardOverlayRect(std::move(keyboard_rect));
}
void LocalFrameInterceptorForTesting::AddMessageToConsole(::blink::mojom::ConsoleMessageLevel level, const std::string& message, bool discard_duplicates) {
  GetForwardingInterface()->AddMessageToConsole(std::move(level), std::move(message), std::move(discard_duplicates));
}
void LocalFrameInterceptorForTesting::AddInspectorIssue(::blink::mojom::InspectorIssueInfoPtr info) {
  GetForwardingInterface()->AddInspectorIssue(std::move(info));
}
void LocalFrameInterceptorForTesting::SwapInImmediately() {
  GetForwardingInterface()->SwapInImmediately();
}
void LocalFrameInterceptorForTesting::CheckCompleted() {
  GetForwardingInterface()->CheckCompleted();
}
void LocalFrameInterceptorForTesting::StopLoading() {
  GetForwardingInterface()->StopLoading();
}
void LocalFrameInterceptorForTesting::Collapse(bool collapsed) {
  GetForwardingInterface()->Collapse(std::move(collapsed));
}
void LocalFrameInterceptorForTesting::EnableViewSourceMode() {
  GetForwardingInterface()->EnableViewSourceMode();
}
void LocalFrameInterceptorForTesting::Focus() {
  GetForwardingInterface()->Focus();
}
void LocalFrameInterceptorForTesting::ClearFocusedElement() {
  GetForwardingInterface()->ClearFocusedElement();
}
void LocalFrameInterceptorForTesting::GetResourceSnapshotForWebBundle(::mojo::PendingReceiver<::data_decoder::mojom::ResourceSnapshotForWebBundle> receiver) {
  GetForwardingInterface()->GetResourceSnapshotForWebBundle(std::move(receiver));
}
void LocalFrameInterceptorForTesting::CopyImageAt(const ::gfx::Point& window_point) {
  GetForwardingInterface()->CopyImageAt(std::move(window_point));
}
void LocalFrameInterceptorForTesting::SaveImageAt(const ::gfx::Point& window_point) {
  GetForwardingInterface()->SaveImageAt(std::move(window_point));
}
void LocalFrameInterceptorForTesting::ReportBlinkFeatureUsage(const std::vector<::blink::mojom::WebFeature>& features) {
  GetForwardingInterface()->ReportBlinkFeatureUsage(std::move(features));
}
void LocalFrameInterceptorForTesting::RenderFallbackContent() {
  GetForwardingInterface()->RenderFallbackContent();
}
void LocalFrameInterceptorForTesting::RenderFallbackContentWithResourceTiming(::blink::mojom::ResourceTimingInfoPtr timing, const std::string& server_timing_value) {
  GetForwardingInterface()->RenderFallbackContentWithResourceTiming(std::move(timing), std::move(server_timing_value));
}
void LocalFrameInterceptorForTesting::BeforeUnload(bool is_reload, BeforeUnloadCallback callback) {
  GetForwardingInterface()->BeforeUnload(std::move(is_reload), std::move(callback));
}
void LocalFrameInterceptorForTesting::MediaPlayerActionAt(const ::gfx::Point& location, ::blink::mojom::MediaPlayerActionPtr action) {
  GetForwardingInterface()->MediaPlayerActionAt(std::move(location), std::move(action));
}
void LocalFrameInterceptorForTesting::PluginActionAt(const ::gfx::Point& location, PluginActionType action) {
  GetForwardingInterface()->PluginActionAt(std::move(location), std::move(action));
}
void LocalFrameInterceptorForTesting::AdvanceFocusInFrame(::blink::mojom::FocusType focus_type, const absl::optional<::blink::RemoteFrameToken>& source_frame_token) {
  GetForwardingInterface()->AdvanceFocusInFrame(std::move(focus_type), std::move(source_frame_token));
}
void LocalFrameInterceptorForTesting::AdvanceFocusForIME(::blink::mojom::FocusType focus_type) {
  GetForwardingInterface()->AdvanceFocusForIME(std::move(focus_type));
}
void LocalFrameInterceptorForTesting::ReportContentSecurityPolicyViolation(::network::mojom::CSPViolationPtr violation) {
  GetForwardingInterface()->ReportContentSecurityPolicyViolation(std::move(violation));
}
void LocalFrameInterceptorForTesting::DidUpdateFramePolicy(const ::blink::FramePolicy& frame_policy) {
  GetForwardingInterface()->DidUpdateFramePolicy(std::move(frame_policy));
}
void LocalFrameInterceptorForTesting::PostMessageEvent(const absl::optional<::blink::RemoteFrameToken>& source_frame_token, const ::std::u16string& source_origin, const ::std::u16string& target_origin, ::blink::TransferableMessage message) {
  GetForwardingInterface()->PostMessageEvent(std::move(source_frame_token), std::move(source_origin), std::move(target_origin), std::move(message));
}
void LocalFrameInterceptorForTesting::JavaScriptMethodExecuteRequest(const ::std::u16string& object_name, const ::std::u16string& method_name, ::base::Value::List arguments, bool wants_result, JavaScriptMethodExecuteRequestCallback callback) {
  GetForwardingInterface()->JavaScriptMethodExecuteRequest(std::move(object_name), std::move(method_name), std::move(arguments), std::move(wants_result), std::move(callback));
}
void LocalFrameInterceptorForTesting::JavaScriptExecuteRequest(const ::std::u16string& javascript, bool wants_result, JavaScriptExecuteRequestCallback callback) {
  GetForwardingInterface()->JavaScriptExecuteRequest(std::move(javascript), std::move(wants_result), std::move(callback));
}
void LocalFrameInterceptorForTesting::JavaScriptExecuteRequestForTests(const ::std::u16string& javascript, bool has_user_gesture, bool resolve_promises, int32_t world_id, JavaScriptExecuteRequestForTestsCallback callback) {
  GetForwardingInterface()->JavaScriptExecuteRequestForTests(std::move(javascript), std::move(has_user_gesture), std::move(resolve_promises), std::move(world_id), std::move(callback));
}
void LocalFrameInterceptorForTesting::JavaScriptExecuteRequestInIsolatedWorld(const ::std::u16string& javascript, bool wants_result, int32_t world_id, JavaScriptExecuteRequestInIsolatedWorldCallback callback) {
  GetForwardingInterface()->JavaScriptExecuteRequestInIsolatedWorld(std::move(javascript), std::move(wants_result), std::move(world_id), std::move(callback));
}
void LocalFrameInterceptorForTesting::BindReportingObserver(::mojo::PendingReceiver<::blink::mojom::ReportingObserver> receiver) {
  GetForwardingInterface()->BindReportingObserver(std::move(receiver));
}
void LocalFrameInterceptorForTesting::UpdateOpener(const absl::optional<::blink::FrameToken>& opener_frame_token) {
  GetForwardingInterface()->UpdateOpener(std::move(opener_frame_token));
}
void LocalFrameInterceptorForTesting::GetSavableResourceLinks(GetSavableResourceLinksCallback callback) {
  GetForwardingInterface()->GetSavableResourceLinks(std::move(callback));
}
void LocalFrameInterceptorForTesting::MixedContentFound(const ::GURL& main_resource_url, const ::GURL& mixed_content_url, ::blink::mojom::RequestContextType request_context, bool was_allowed, const ::GURL& url_before_redirects, bool had_redirect, ::network::mojom::SourceLocationPtr source_location) {
  GetForwardingInterface()->MixedContentFound(std::move(main_resource_url), std::move(mixed_content_url), std::move(request_context), std::move(was_allowed), std::move(url_before_redirects), std::move(had_redirect), std::move(source_location));
}
void LocalFrameInterceptorForTesting::BindDevToolsAgent(::mojo::PendingAssociatedRemote<::blink::mojom::DevToolsAgentHost> agent_host, ::mojo::PendingAssociatedReceiver<::blink::mojom::DevToolsAgent> agent) {
  GetForwardingInterface()->BindDevToolsAgent(std::move(agent_host), std::move(agent));
}
void LocalFrameInterceptorForTesting::ExtractSmartClipData(const ::gfx::Rect& rect, ExtractSmartClipDataCallback callback) {
  GetForwardingInterface()->ExtractSmartClipData(std::move(rect), std::move(callback));
}
void LocalFrameInterceptorForTesting::HandleRendererDebugURL(const ::GURL& url) {
  GetForwardingInterface()->HandleRendererDebugURL(std::move(url));
}
void LocalFrameInterceptorForTesting::GetCanonicalUrlForSharing(GetCanonicalUrlForSharingCallback callback) {
  GetForwardingInterface()->GetCanonicalUrlForSharing(std::move(callback));
}
void LocalFrameInterceptorForTesting::GetOpenGraphMetadata(GetOpenGraphMetadataCallback callback) {
  GetForwardingInterface()->GetOpenGraphMetadata(std::move(callback));
}
void LocalFrameInterceptorForTesting::SetNavigationApiHistoryEntriesForRestore(::blink::mojom::NavigationApiHistoryEntryArraysPtr entry_arrays) {
  GetForwardingInterface()->SetNavigationApiHistoryEntriesForRestore(std::move(entry_arrays));
}
LocalFrameAsyncWaiter::LocalFrameAsyncWaiter(
    LocalFrame* proxy) : proxy_(proxy) {}

LocalFrameAsyncWaiter::~LocalFrameAsyncWaiter() = default;

void LocalFrameAsyncWaiter::GetTextSurroundingSelection(
    uint32_t max_length, ::std::u16string* out_content, uint32_t* out_start_offset, uint32_t* out_end_offset) {
  base::RunLoop loop;
  proxy_->GetTextSurroundingSelection(std::move(max_length),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::std::u16string* out_content
,
             uint32_t* out_start_offset
,
             uint32_t* out_end_offset
,
             const ::std::u16string& content,
             uint32_t start_offset,
             uint32_t end_offset) {*out_content = std::move(content);*out_start_offset = std::move(start_offset);*out_end_offset = std::move(end_offset);
            loop->Quit();
          },
          &loop,
          out_content,
          out_start_offset,
          out_end_offset));
  loop.Run();
}
void LocalFrameAsyncWaiter::BeforeUnload(
    bool is_reload, bool* out_proceed, ::base::TimeTicks* out_before_unload_start_time, ::base::TimeTicks* out_before_unload_end_time) {
  base::RunLoop loop;
  proxy_->BeforeUnload(std::move(is_reload),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_proceed
,
             ::base::TimeTicks* out_before_unload_start_time
,
             ::base::TimeTicks* out_before_unload_end_time
,
             bool proceed,
             ::base::TimeTicks before_unload_start_time,
             ::base::TimeTicks before_unload_end_time) {*out_proceed = std::move(proceed);*out_before_unload_start_time = std::move(before_unload_start_time);*out_before_unload_end_time = std::move(before_unload_end_time);
            loop->Quit();
          },
          &loop,
          out_proceed,
          out_before_unload_start_time,
          out_before_unload_end_time));
  loop.Run();
}
void LocalFrameAsyncWaiter::JavaScriptMethodExecuteRequest(
    const ::std::u16string& object_name, const ::std::u16string& method_name, ::base::Value::List arguments, bool wants_result, ::base::Value* out_result) {
  base::RunLoop loop;
  proxy_->JavaScriptMethodExecuteRequest(std::move(object_name),std::move(method_name),std::move(arguments),std::move(wants_result),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::Value* out_result
,
             ::base::Value result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void LocalFrameAsyncWaiter::JavaScriptExecuteRequest(
    const ::std::u16string& javascript, bool wants_result, ::base::Value* out_result) {
  base::RunLoop loop;
  proxy_->JavaScriptExecuteRequest(std::move(javascript),std::move(wants_result),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::Value* out_result
,
             ::base::Value result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void LocalFrameAsyncWaiter::JavaScriptExecuteRequestForTests(
    const ::std::u16string& javascript, bool has_user_gesture, bool resolve_promises, int32_t world_id, JavaScriptExecutionResultType* out_result_type, ::base::Value* out_result) {
  base::RunLoop loop;
  proxy_->JavaScriptExecuteRequestForTests(std::move(javascript),std::move(has_user_gesture),std::move(resolve_promises),std::move(world_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             JavaScriptExecutionResultType* out_result_type
,
             ::base::Value* out_result
,
             JavaScriptExecutionResultType result_type,
             ::base::Value result) {*out_result_type = std::move(result_type);*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result_type,
          out_result));
  loop.Run();
}
void LocalFrameAsyncWaiter::JavaScriptExecuteRequestInIsolatedWorld(
    const ::std::u16string& javascript, bool wants_result, int32_t world_id, ::base::Value* out_result) {
  base::RunLoop loop;
  proxy_->JavaScriptExecuteRequestInIsolatedWorld(std::move(javascript),std::move(wants_result),std::move(world_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::base::Value* out_result
,
             ::base::Value result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}
void LocalFrameAsyncWaiter::GetSavableResourceLinks(
    GetSavableResourceLinksReplyPtr* out_reply) {
  base::RunLoop loop;
  proxy_->GetSavableResourceLinks(
      base::BindOnce(
          [](base::RunLoop* loop,
             GetSavableResourceLinksReplyPtr* out_reply
,
             GetSavableResourceLinksReplyPtr reply) {*out_reply = std::move(reply);
            loop->Quit();
          },
          &loop,
          out_reply));
  loop.Run();
}
void LocalFrameAsyncWaiter::ExtractSmartClipData(
    const ::gfx::Rect& rect, ::std::u16string* out_text, ::std::u16string* out_html, ::gfx::Rect* out_clip_rect) {
  base::RunLoop loop;
  proxy_->ExtractSmartClipData(std::move(rect),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::std::u16string* out_text
,
             ::std::u16string* out_html
,
             ::gfx::Rect* out_clip_rect
,
             const ::std::u16string& text,
             const ::std::u16string& html,
             const ::gfx::Rect& clip_rect) {*out_text = std::move(text);*out_html = std::move(html);*out_clip_rect = std::move(clip_rect);
            loop->Quit();
          },
          &loop,
          out_text,
          out_html,
          out_clip_rect));
  loop.Run();
}
void LocalFrameAsyncWaiter::GetCanonicalUrlForSharing(
    absl::optional<::GURL>* out_canonical_url) {
  base::RunLoop loop;
  proxy_->GetCanonicalUrlForSharing(
      base::BindOnce(
          [](base::RunLoop* loop,
             absl::optional<::GURL>* out_canonical_url
,
             const absl::optional<::GURL>& canonical_url) {*out_canonical_url = std::move(canonical_url);
            loop->Quit();
          },
          &loop,
          out_canonical_url));
  loop.Run();
}
void LocalFrameAsyncWaiter::GetOpenGraphMetadata(
    ::blink::mojom::OpenGraphMetadataPtr* out_metadata) {
  base::RunLoop loop;
  proxy_->GetOpenGraphMetadata(
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::OpenGraphMetadataPtr* out_metadata
,
             ::blink::mojom::OpenGraphMetadataPtr metadata) {*out_metadata = std::move(metadata);
            loop->Quit();
          },
          &loop,
          out_metadata));
  loop.Run();
}



void HighPriorityLocalFrameInterceptorForTesting::DispatchBeforeUnload(bool is_reload, DispatchBeforeUnloadCallback callback) {
  GetForwardingInterface()->DispatchBeforeUnload(std::move(is_reload), std::move(callback));
}
HighPriorityLocalFrameAsyncWaiter::HighPriorityLocalFrameAsyncWaiter(
    HighPriorityLocalFrame* proxy) : proxy_(proxy) {}

HighPriorityLocalFrameAsyncWaiter::~HighPriorityLocalFrameAsyncWaiter() = default;

void HighPriorityLocalFrameAsyncWaiter::DispatchBeforeUnload(
    bool is_reload, bool* out_proceed, ::base::TimeTicks* out_before_unload_start_time, ::base::TimeTicks* out_before_unload_end_time) {
  base::RunLoop loop;
  proxy_->DispatchBeforeUnload(std::move(is_reload),
      base::BindOnce(
          [](base::RunLoop* loop,
             bool* out_proceed
,
             ::base::TimeTicks* out_before_unload_start_time
,
             ::base::TimeTicks* out_before_unload_end_time
,
             bool proceed,
             ::base::TimeTicks before_unload_start_time,
             ::base::TimeTicks before_unload_end_time) {*out_proceed = std::move(proceed);*out_before_unload_start_time = std::move(before_unload_start_time);*out_before_unload_end_time = std::move(before_unload_end_time);
            loop->Quit();
          },
          &loop,
          out_proceed,
          out_before_unload_start_time,
          out_before_unload_end_time));
  loop.Run();
}



void LocalMainFrameInterceptorForTesting::AnimateDoubleTapZoom(const ::gfx::Point& point, const ::gfx::Rect& rect) {
  GetForwardingInterface()->AnimateDoubleTapZoom(std::move(point), std::move(rect));
}
void LocalMainFrameInterceptorForTesting::SetScaleFactor(float scale) {
  GetForwardingInterface()->SetScaleFactor(std::move(scale));
}
void LocalMainFrameInterceptorForTesting::ClosePage(ClosePageCallback callback) {
  GetForwardingInterface()->ClosePage(std::move(callback));
}
void LocalMainFrameInterceptorForTesting::SetInitialFocus(bool reverse) {
  GetForwardingInterface()->SetInitialFocus(std::move(reverse));
}
void LocalMainFrameInterceptorForTesting::EnablePreferredSizeChangedMode() {
  GetForwardingInterface()->EnablePreferredSizeChangedMode();
}
void LocalMainFrameInterceptorForTesting::ZoomToFindInPageRect(const ::gfx::Rect& rect_in_root_frame) {
  GetForwardingInterface()->ZoomToFindInPageRect(std::move(rect_in_root_frame));
}
void LocalMainFrameInterceptorForTesting::InstallCoopAccessMonitor(const ::blink::FrameToken& accessed_window, ::network::mojom::CrossOriginOpenerPolicyReporterParamsPtr coop_reporter_info) {
  GetForwardingInterface()->InstallCoopAccessMonitor(std::move(accessed_window), std::move(coop_reporter_info));
}
void LocalMainFrameInterceptorForTesting::OnPortalActivated(const ::blink::PortalToken& portal_token, ::mojo::PendingAssociatedRemote<::blink::mojom::Portal> portal, ::mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> portal_client, ::blink::TransferableMessage data, uint64_t trace_id, OnPortalActivatedCallback callback) {
  GetForwardingInterface()->OnPortalActivated(std::move(portal_token), std::move(portal), std::move(portal_client), std::move(data), std::move(trace_id), std::move(callback));
}
void LocalMainFrameInterceptorForTesting::ForwardMessageFromHost(::blink::TransferableMessage message, const ::url::Origin& source_origin) {
  GetForwardingInterface()->ForwardMessageFromHost(std::move(message), std::move(source_origin));
}
void LocalMainFrameInterceptorForTesting::UpdateBrowserControlsState(::cc::BrowserControlsState constraints, ::cc::BrowserControlsState current, bool animate) {
  GetForwardingInterface()->UpdateBrowserControlsState(std::move(constraints), std::move(current), std::move(animate));
}
LocalMainFrameAsyncWaiter::LocalMainFrameAsyncWaiter(
    LocalMainFrame* proxy) : proxy_(proxy) {}

LocalMainFrameAsyncWaiter::~LocalMainFrameAsyncWaiter() = default;

void LocalMainFrameAsyncWaiter::ClosePage(
    ) {
  base::RunLoop loop;
  proxy_->ClosePage(
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void LocalMainFrameAsyncWaiter::OnPortalActivated(
    const ::blink::PortalToken& portal_token, ::mojo::PendingAssociatedRemote<::blink::mojom::Portal> portal, ::mojo::PendingAssociatedReceiver<::blink::mojom::PortalClient> portal_client, ::blink::TransferableMessage data, uint64_t trace_id, ::blink::mojom::PortalActivateResult* out_result) {
  base::RunLoop loop;
  proxy_->OnPortalActivated(std::move(portal_token),std::move(portal),std::move(portal_client),std::move(data),std::move(trace_id),
      base::BindOnce(
          [](base::RunLoop* loop,
             ::blink::mojom::PortalActivateResult* out_result
,
             ::blink::mojom::PortalActivateResult result) {*out_result = std::move(result);
            loop->Quit();
          },
          &loop,
          out_result));
  loop.Run();
}



void LocalMainFrameHostInterceptorForTesting::ScaleFactorChanged(float scale) {
  GetForwardingInterface()->ScaleFactorChanged(std::move(scale));
}
void LocalMainFrameHostInterceptorForTesting::ContentsPreferredSizeChanged(const ::gfx::Size& pref_size) {
  GetForwardingInterface()->ContentsPreferredSizeChanged(std::move(pref_size));
}
void LocalMainFrameHostInterceptorForTesting::TextAutosizerPageInfoChanged(::blink::mojom::TextAutosizerPageInfoPtr page_info) {
  GetForwardingInterface()->TextAutosizerPageInfoChanged(std::move(page_info));
}
void LocalMainFrameHostInterceptorForTesting::FocusPage() {
  GetForwardingInterface()->FocusPage();
}
void LocalMainFrameHostInterceptorForTesting::TakeFocus(bool reverse) {
  GetForwardingInterface()->TakeFocus(std::move(reverse));
}
void LocalMainFrameHostInterceptorForTesting::UpdateTargetURL(const ::GURL& url, UpdateTargetURLCallback callback) {
  GetForwardingInterface()->UpdateTargetURL(std::move(url), std::move(callback));
}
void LocalMainFrameHostInterceptorForTesting::RequestClose() {
  GetForwardingInterface()->RequestClose();
}
void LocalMainFrameHostInterceptorForTesting::ShowCreatedWindow(const ::blink::LocalFrameToken& opener_frame_token, ::WindowOpenDisposition disposition, const ::gfx::Rect& rect, bool opened_by_user_gesture, ShowCreatedWindowCallback callback) {
  GetForwardingInterface()->ShowCreatedWindow(std::move(opener_frame_token), std::move(disposition), std::move(rect), std::move(opened_by_user_gesture), std::move(callback));
}
void LocalMainFrameHostInterceptorForTesting::SetWindowRect(const ::gfx::Rect& bounds, SetWindowRectCallback callback) {
  GetForwardingInterface()->SetWindowRect(std::move(bounds), std::move(callback));
}
void LocalMainFrameHostInterceptorForTesting::DidFirstVisuallyNonEmptyPaint() {
  GetForwardingInterface()->DidFirstVisuallyNonEmptyPaint();
}
void LocalMainFrameHostInterceptorForTesting::DidAccessInitialMainDocument() {
  GetForwardingInterface()->DidAccessInitialMainDocument();
}
LocalMainFrameHostAsyncWaiter::LocalMainFrameHostAsyncWaiter(
    LocalMainFrameHost* proxy) : proxy_(proxy) {}

LocalMainFrameHostAsyncWaiter::~LocalMainFrameHostAsyncWaiter() = default;

void LocalMainFrameHostAsyncWaiter::UpdateTargetURL(
    const ::GURL& url) {
  base::RunLoop loop;
  proxy_->UpdateTargetURL(std::move(url),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void LocalMainFrameHostAsyncWaiter::ShowCreatedWindow(
    const ::blink::LocalFrameToken& opener_frame_token, ::WindowOpenDisposition disposition, const ::gfx::Rect& rect, bool opened_by_user_gesture) {
  base::RunLoop loop;
  proxy_->ShowCreatedWindow(std::move(opener_frame_token),std::move(disposition),std::move(rect),std::move(opened_by_user_gesture),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}
void LocalMainFrameHostAsyncWaiter::SetWindowRect(
    const ::gfx::Rect& bounds) {
  base::RunLoop loop;
  proxy_->SetWindowRect(std::move(bounds),
      base::BindOnce(
          [](base::RunLoop* loop) {
            loop->Quit();
          },
          &loop));
  loop.Run();
}





}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif