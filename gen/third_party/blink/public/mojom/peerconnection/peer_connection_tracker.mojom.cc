// third_party/blink/public/mojom/peerconnection/peer_connection_tracker.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/peerconnection/peer_connection_tracker.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/peerconnection/peer_connection_tracker.mojom-params-data.h"
#include "third_party/blink/public/mojom/peerconnection/peer_connection_tracker.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/peerconnection/peer_connection_tracker.mojom-import-headers.h"
#include "third_party/blink/public/mojom/peerconnection/peer_connection_tracker.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_PEERCONNECTION_PEER_CONNECTION_TRACKER_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_PEERCONNECTION_PEER_CONNECTION_TRACKER_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace mojom {
PeerConnectionInfo::PeerConnectionInfo()
    : lid(),
      rtc_configuration(),
      constraints(),
      url() {}

PeerConnectionInfo::PeerConnectionInfo(
    int32_t lid_in,
    const std::string& rtc_configuration_in,
    const std::string& constraints_in,
    const absl::optional<std::string>& url_in)
    : lid(std::move(lid_in)),
      rtc_configuration(std::move(rtc_configuration_in)),
      constraints(std::move(constraints_in)),
      url(std::move(url_in)) {}

PeerConnectionInfo::~PeerConnectionInfo() = default;

void PeerConnectionInfo::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "lid"), this->lid,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int32_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "rtc_configuration"), this->rtc_configuration,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "constraints"), this->constraints,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::string&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "url"), this->url,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const absl::optional<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool PeerConnectionInfo::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char PeerConnectionManager::Name_[] = "blink.mojom.PeerConnectionManager";

PeerConnectionManager::IPCStableHashFunction PeerConnectionManager::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPeerConnectionManager_OnSuspend_Name: {
      return &PeerConnectionManager::OnSuspend_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionManager_OnThermalStateChange_Name: {
      return &PeerConnectionManager::OnThermalStateChange_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionManager_OnSpeedLimitChange_Name: {
      return &PeerConnectionManager::OnSpeedLimitChange_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionManager_StartEventLog_Name: {
      return &PeerConnectionManager::StartEventLog_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionManager_StopEventLog_Name: {
      return &PeerConnectionManager::StopEventLog_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionManager_GetStandardStats_Name: {
      return &PeerConnectionManager::GetStandardStats_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionManager_GetLegacyStats_Name: {
      return &PeerConnectionManager::GetLegacyStats_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PeerConnectionManager::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPeerConnectionManager_OnSuspend_Name:
            return "Receive blink::mojom::PeerConnectionManager::OnSuspend";
      case internal::kPeerConnectionManager_OnThermalStateChange_Name:
            return "Receive blink::mojom::PeerConnectionManager::OnThermalStateChange";
      case internal::kPeerConnectionManager_OnSpeedLimitChange_Name:
            return "Receive blink::mojom::PeerConnectionManager::OnSpeedLimitChange";
      case internal::kPeerConnectionManager_StartEventLog_Name:
            return "Receive blink::mojom::PeerConnectionManager::StartEventLog";
      case internal::kPeerConnectionManager_StopEventLog_Name:
            return "Receive blink::mojom::PeerConnectionManager::StopEventLog";
      case internal::kPeerConnectionManager_GetStandardStats_Name:
            return "Receive blink::mojom::PeerConnectionManager::GetStandardStats";
      case internal::kPeerConnectionManager_GetLegacyStats_Name:
            return "Receive blink::mojom::PeerConnectionManager::GetLegacyStats";
    }
  } else {
    switch (message.name()) {
      case internal::kPeerConnectionManager_OnSuspend_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::OnSuspend";
      case internal::kPeerConnectionManager_OnThermalStateChange_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::OnThermalStateChange";
      case internal::kPeerConnectionManager_OnSpeedLimitChange_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::OnSpeedLimitChange";
      case internal::kPeerConnectionManager_StartEventLog_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::StartEventLog";
      case internal::kPeerConnectionManager_StopEventLog_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::StopEventLog";
      case internal::kPeerConnectionManager_GetStandardStats_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::GetStandardStats";
      case internal::kPeerConnectionManager_GetLegacyStats_Name:
            return "Receive reply blink::mojom::PeerConnectionManager::GetLegacyStats";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PeerConnectionManager::OnSuspend_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::OnSuspend");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionManager::OnThermalStateChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::OnThermalStateChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionManager::OnSpeedLimitChange_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::OnSpeedLimitChange");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionManager::StartEventLog_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::StartEventLog");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionManager::StopEventLog_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::StopEventLog");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionManager::GetStandardStats_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::GetStandardStats");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionManager::GetLegacyStats_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionManager::GetLegacyStats");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

PeerConnectionManagerProxy::PeerConnectionManagerProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PeerConnectionManagerProxy::OnSuspend(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::PeerConnectionManager::OnSuspend");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_OnSuspend_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_OnSuspend_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("OnSuspend");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionManagerProxy::OnThermalStateChange(
    DeviceThermalState in_thermal_state) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionManager::OnThermalStateChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("thermal_state"), in_thermal_state,
                        "<value of type DeviceThermalState>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_OnThermalStateChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_OnThermalStateChange_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<::blink::mojom::DeviceThermalState>(
      in_thermal_state, &params->thermal_state);

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("OnThermalStateChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionManagerProxy::OnSpeedLimitChange(
    int32_t in_speed_limit) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionManager::OnSpeedLimitChange", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("speed_limit"), in_speed_limit,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_OnSpeedLimitChange_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_OnSpeedLimitChange_Params_Data> params(
          message);
  params.Allocate();
  params->speed_limit = in_speed_limit;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("OnSpeedLimitChange");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionManagerProxy::StartEventLog(
    int32_t in_peer_connection_local_id, int32_t in_output_period_ms) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionManager::StartEventLog", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("peer_connection_local_id"), in_peer_connection_local_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("output_period_ms"), in_output_period_ms,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_StartEventLog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_StartEventLog_Params_Data> params(
          message);
  params.Allocate();
  params->peer_connection_local_id = in_peer_connection_local_id;
  params->output_period_ms = in_output_period_ms;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("StartEventLog");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionManagerProxy::StopEventLog(
    int32_t in_peer_connection_local_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionManager::StopEventLog", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("peer_connection_local_id"), in_peer_connection_local_id,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_StopEventLog_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_StopEventLog_Params_Data> params(
          message);
  params.Allocate();
  params->peer_connection_local_id = in_peer_connection_local_id;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("StopEventLog");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionManagerProxy::GetStandardStats(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::PeerConnectionManager::GetStandardStats");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_GetStandardStats_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_GetStandardStats_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("GetStandardStats");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionManagerProxy::GetLegacyStats(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::PeerConnectionManager::GetLegacyStats");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionManager_GetLegacyStats_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionManager_GetLegacyStats_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionManager::Name_);
  message.set_method_name("GetLegacyStats");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PeerConnectionManagerStubDispatch::Accept(
    PeerConnectionManager* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPeerConnectionManager_OnSuspend_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_OnSuspend_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_OnSuspend_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PeerConnectionManager_OnSuspend_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSuspend();
      return true;
    }
    case internal::kPeerConnectionManager_OnThermalStateChange_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_OnThermalStateChange_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_OnThermalStateChange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DeviceThermalState p_thermal_state{};
      PeerConnectionManager_OnThermalStateChange_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadThermalState(&p_thermal_state))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnThermalStateChange(
std::move(p_thermal_state));
      return true;
    }
    case internal::kPeerConnectionManager_OnSpeedLimitChange_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_OnSpeedLimitChange_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_OnSpeedLimitChange_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_speed_limit{};
      PeerConnectionManager_OnSpeedLimitChange_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_speed_limit = input_data_view.speed_limit();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnSpeedLimitChange(
std::move(p_speed_limit));
      return true;
    }
    case internal::kPeerConnectionManager_StartEventLog_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_StartEventLog_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_StartEventLog_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_peer_connection_local_id{};
      int32_t p_output_period_ms{};
      PeerConnectionManager_StartEventLog_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_peer_connection_local_id = input_data_view.peer_connection_local_id();
      if (success)
        p_output_period_ms = input_data_view.output_period_ms();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StartEventLog(
std::move(p_peer_connection_local_id), 
std::move(p_output_period_ms));
      return true;
    }
    case internal::kPeerConnectionManager_StopEventLog_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_StopEventLog_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_StopEventLog_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_peer_connection_local_id{};
      PeerConnectionManager_StopEventLog_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_peer_connection_local_id = input_data_view.peer_connection_local_id();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->StopEventLog(
std::move(p_peer_connection_local_id));
      return true;
    }
    case internal::kPeerConnectionManager_GetStandardStats_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_GetStandardStats_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_GetStandardStats_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PeerConnectionManager_GetStandardStats_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetStandardStats();
      return true;
    }
    case internal::kPeerConnectionManager_GetLegacyStats_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionManager_GetLegacyStats_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionManager_GetLegacyStats_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PeerConnectionManager_GetLegacyStats_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionManager::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetLegacyStats();
      return true;
    }
  }
  return false;
}

// static
bool PeerConnectionManagerStubDispatch::AcceptWithResponder(
    PeerConnectionManager* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPeerConnectionManager_OnSuspend_Name: {
      break;
    }
    case internal::kPeerConnectionManager_OnThermalStateChange_Name: {
      break;
    }
    case internal::kPeerConnectionManager_OnSpeedLimitChange_Name: {
      break;
    }
    case internal::kPeerConnectionManager_StartEventLog_Name: {
      break;
    }
    case internal::kPeerConnectionManager_StopEventLog_Name: {
      break;
    }
    case internal::kPeerConnectionManager_GetStandardStats_Name: {
      break;
    }
    case internal::kPeerConnectionManager_GetLegacyStats_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPeerConnectionManagerValidationInfo[] = {
    {&internal::PeerConnectionManager_OnSuspend_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionManager_OnThermalStateChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionManager_OnSpeedLimitChange_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionManager_StartEventLog_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionManager_StopEventLog_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionManager_GetStandardStats_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionManager_GetLegacyStats_Params_Data::Validate,
     nullptr /* no response */},
};

bool PeerConnectionManagerRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::PeerConnectionManager::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPeerConnectionManagerValidationInfo);
}

const char PeerConnectionTrackerHost::Name_[] = "blink.mojom.PeerConnectionTrackerHost";

PeerConnectionTrackerHost::IPCStableHashFunction PeerConnectionTrackerHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kPeerConnectionTrackerHost_AddPeerConnection_Name: {
      return &PeerConnectionTrackerHost::AddPeerConnection_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_RemovePeerConnection_Name: {
      return &PeerConnectionTrackerHost::RemovePeerConnection_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_UpdatePeerConnection_Name: {
      return &PeerConnectionTrackerHost::UpdatePeerConnection_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Name: {
      return &PeerConnectionTrackerHost::OnPeerConnectionSessionIdSet_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMedia_Name: {
      return &PeerConnectionTrackerHost::GetUserMedia_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMediaSuccess_Name: {
      return &PeerConnectionTrackerHost::GetUserMediaSuccess_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMediaFailure_Name: {
      return &PeerConnectionTrackerHost::GetUserMediaFailure_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_WebRtcEventLogWrite_Name: {
      return &PeerConnectionTrackerHost::WebRtcEventLogWrite_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_AddStandardStats_Name: {
      return &PeerConnectionTrackerHost::AddStandardStats_Sym::IPCStableHash;
    }
    case internal::kPeerConnectionTrackerHost_AddLegacyStats_Name: {
      return &PeerConnectionTrackerHost::AddLegacyStats_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* PeerConnectionTrackerHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kPeerConnectionTrackerHost_AddPeerConnection_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::AddPeerConnection";
      case internal::kPeerConnectionTrackerHost_RemovePeerConnection_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::RemovePeerConnection";
      case internal::kPeerConnectionTrackerHost_UpdatePeerConnection_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::UpdatePeerConnection";
      case internal::kPeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::OnPeerConnectionSessionIdSet";
      case internal::kPeerConnectionTrackerHost_GetUserMedia_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::GetUserMedia";
      case internal::kPeerConnectionTrackerHost_GetUserMediaSuccess_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::GetUserMediaSuccess";
      case internal::kPeerConnectionTrackerHost_GetUserMediaFailure_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::GetUserMediaFailure";
      case internal::kPeerConnectionTrackerHost_WebRtcEventLogWrite_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::WebRtcEventLogWrite";
      case internal::kPeerConnectionTrackerHost_AddStandardStats_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::AddStandardStats";
      case internal::kPeerConnectionTrackerHost_AddLegacyStats_Name:
            return "Receive blink::mojom::PeerConnectionTrackerHost::AddLegacyStats";
    }
  } else {
    switch (message.name()) {
      case internal::kPeerConnectionTrackerHost_AddPeerConnection_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::AddPeerConnection";
      case internal::kPeerConnectionTrackerHost_RemovePeerConnection_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::RemovePeerConnection";
      case internal::kPeerConnectionTrackerHost_UpdatePeerConnection_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::UpdatePeerConnection";
      case internal::kPeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::OnPeerConnectionSessionIdSet";
      case internal::kPeerConnectionTrackerHost_GetUserMedia_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::GetUserMedia";
      case internal::kPeerConnectionTrackerHost_GetUserMediaSuccess_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::GetUserMediaSuccess";
      case internal::kPeerConnectionTrackerHost_GetUserMediaFailure_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::GetUserMediaFailure";
      case internal::kPeerConnectionTrackerHost_WebRtcEventLogWrite_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::WebRtcEventLogWrite";
      case internal::kPeerConnectionTrackerHost_AddStandardStats_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::AddStandardStats";
      case internal::kPeerConnectionTrackerHost_AddLegacyStats_Name:
            return "Receive reply blink::mojom::PeerConnectionTrackerHost::AddLegacyStats";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t PeerConnectionTrackerHost::AddPeerConnection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::AddPeerConnection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::RemovePeerConnection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::RemovePeerConnection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::UpdatePeerConnection_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::UpdatePeerConnection");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::OnPeerConnectionSessionIdSet_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::OnPeerConnectionSessionIdSet");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::GetUserMedia_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::GetUserMedia");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::GetUserMediaSuccess_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::GetUserMediaSuccess");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::GetUserMediaFailure_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::GetUserMediaFailure");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::WebRtcEventLogWrite_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::WebRtcEventLogWrite");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::AddStandardStats_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::AddStandardStats");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t PeerConnectionTrackerHost::AddLegacyStats_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::PeerConnectionTrackerHost::AddLegacyStats");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

PeerConnectionTrackerHostProxy::PeerConnectionTrackerHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void PeerConnectionTrackerHostProxy::AddPeerConnection(
    PeerConnectionInfoPtr in_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::AddPeerConnection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("info"), in_info,
                        "<value of type PeerConnectionInfoPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_AddPeerConnection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_AddPeerConnection_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->info)::BaseType> info_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::PeerConnectionInfoDataView>(
      in_info, info_fragment);
  params->info.Set(
      info_fragment.is_null() ? nullptr : info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null info in PeerConnectionTrackerHost.AddPeerConnection request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("AddPeerConnection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::RemovePeerConnection(
    int32_t in_lid) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::RemovePeerConnection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("lid"), in_lid,
                        "<value of type int32_t>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_RemovePeerConnection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_RemovePeerConnection_Params_Data> params(
          message);
  params.Allocate();
  params->lid = in_lid;

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("RemovePeerConnection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::UpdatePeerConnection(
    int32_t in_lid, const std::string& in_type, const std::string& in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::UpdatePeerConnection", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("lid"), in_lid,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("type"), in_type,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_UpdatePeerConnection_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_UpdatePeerConnection_Params_Data> params(
          message);
  params.Allocate();
  params->lid = in_lid;
  mojo::internal::MessageFragment<
      typename decltype(params->type)::BaseType> type_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_type, type_fragment);
  params->type.Set(
      type_fragment.is_null() ? nullptr : type_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->type.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null type in PeerConnectionTrackerHost.UpdatePeerConnection request");
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in PeerConnectionTrackerHost.UpdatePeerConnection request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("UpdatePeerConnection");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::OnPeerConnectionSessionIdSet(
    int32_t in_lid, const std::string& in_session_id) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::OnPeerConnectionSessionIdSet", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("lid"), in_lid,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("session_id"), in_session_id,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Params_Data> params(
          message);
  params.Allocate();
  params->lid = in_lid;
  mojo::internal::MessageFragment<
      typename decltype(params->session_id)::BaseType> session_id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_session_id, session_id_fragment);
  params->session_id.Set(
      session_id_fragment.is_null() ? nullptr : session_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->session_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null session_id in PeerConnectionTrackerHost.OnPeerConnectionSessionIdSet request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("OnPeerConnectionSessionIdSet");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::GetUserMedia(
    int32_t in_request_id, bool in_audio, bool in_video, const std::string& in_audio_constraints, const std::string& in_video_constraints) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::GetUserMedia", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request_id"), in_request_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("audio"), in_audio,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("video"), in_video,
                        "<value of type bool>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("audio_constraints"), in_audio_constraints,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("video_constraints"), in_video_constraints,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_GetUserMedia_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_GetUserMedia_Params_Data> params(
          message);
  params.Allocate();
  params->request_id = in_request_id;
  params->audio = in_audio;
  params->video = in_video;
  mojo::internal::MessageFragment<
      typename decltype(params->audio_constraints)::BaseType> audio_constraints_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_audio_constraints, audio_constraints_fragment);
  params->audio_constraints.Set(
      audio_constraints_fragment.is_null() ? nullptr : audio_constraints_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->audio_constraints.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null audio_constraints in PeerConnectionTrackerHost.GetUserMedia request");
  mojo::internal::MessageFragment<
      typename decltype(params->video_constraints)::BaseType> video_constraints_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_video_constraints, video_constraints_fragment);
  params->video_constraints.Set(
      video_constraints_fragment.is_null() ? nullptr : video_constraints_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->video_constraints.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null video_constraints in PeerConnectionTrackerHost.GetUserMedia request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("GetUserMedia");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::GetUserMediaSuccess(
    int32_t in_request_id, const std::string& in_stream_id, const std::string& in_audio_track_info, const std::string& in_video_track_info) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::GetUserMediaSuccess", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request_id"), in_request_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("stream_id"), in_stream_id,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("audio_track_info"), in_audio_track_info,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("video_track_info"), in_video_track_info,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_GetUserMediaSuccess_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_GetUserMediaSuccess_Params_Data> params(
          message);
  params.Allocate();
  params->request_id = in_request_id;
  mojo::internal::MessageFragment<
      typename decltype(params->stream_id)::BaseType> stream_id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_stream_id, stream_id_fragment);
  params->stream_id.Set(
      stream_id_fragment.is_null() ? nullptr : stream_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->stream_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null stream_id in PeerConnectionTrackerHost.GetUserMediaSuccess request");
  mojo::internal::MessageFragment<
      typename decltype(params->audio_track_info)::BaseType> audio_track_info_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_audio_track_info, audio_track_info_fragment);
  params->audio_track_info.Set(
      audio_track_info_fragment.is_null() ? nullptr : audio_track_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->audio_track_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null audio_track_info in PeerConnectionTrackerHost.GetUserMediaSuccess request");
  mojo::internal::MessageFragment<
      typename decltype(params->video_track_info)::BaseType> video_track_info_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_video_track_info, video_track_info_fragment);
  params->video_track_info.Set(
      video_track_info_fragment.is_null() ? nullptr : video_track_info_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->video_track_info.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null video_track_info in PeerConnectionTrackerHost.GetUserMediaSuccess request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("GetUserMediaSuccess");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::GetUserMediaFailure(
    int32_t in_request_id, const std::string& in_error, const std::string& in_error_message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::GetUserMediaFailure", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("request_id"), in_request_id,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error"), in_error,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("error_message"), in_error_message,
                        "<value of type const std::string&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_GetUserMediaFailure_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_GetUserMediaFailure_Params_Data> params(
          message);
  params.Allocate();
  params->request_id = in_request_id;
  mojo::internal::MessageFragment<
      typename decltype(params->error)::BaseType> error_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error, error_fragment);
  params->error.Set(
      error_fragment.is_null() ? nullptr : error_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error in PeerConnectionTrackerHost.GetUserMediaFailure request");
  mojo::internal::MessageFragment<
      typename decltype(params->error_message)::BaseType> error_message_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_error_message, error_message_fragment);
  params->error_message.Set(
      error_message_fragment.is_null() ? nullptr : error_message_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->error_message.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null error_message in PeerConnectionTrackerHost.GetUserMediaFailure request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("GetUserMediaFailure");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::WebRtcEventLogWrite(
    int32_t in_lid, const std::vector<uint8_t>& in_output) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::WebRtcEventLogWrite", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("lid"), in_lid,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("output"), in_output,
                        "<value of type const std::vector<uint8_t>&>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_WebRtcEventLogWrite_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_WebRtcEventLogWrite_Params_Data> params(
          message);
  params.Allocate();
  params->lid = in_lid;
  mojo::internal::MessageFragment<
      typename decltype(params->output)::BaseType>
      output_fragment(params.message());
  const mojo::internal::ContainerValidateParams output_validate_params(
      0, false, nullptr);
  mojo::internal::Serialize<mojo::ArrayDataView<uint8_t>>(
      in_output, output_fragment, &output_validate_params);
  params->output.Set(
      output_fragment.is_null() ? nullptr : output_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->output.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null output in PeerConnectionTrackerHost.WebRtcEventLogWrite request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("WebRtcEventLogWrite");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::AddStandardStats(
    int32_t in_lid, ::base::Value::List in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::AddStandardStats", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("lid"), in_lid,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type ::base::Value::List>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_AddStandardStats_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_AddStandardStats_Params_Data> params(
          message);
  params.Allocate();
  params->lid = in_lid;
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::ListValueDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in PeerConnectionTrackerHost.AddStandardStats request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("AddStandardStats");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void PeerConnectionTrackerHostProxy::AddLegacyStats(
    int32_t in_lid, ::base::Value::List in_value) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::PeerConnectionTrackerHost::AddLegacyStats", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("lid"), in_lid,
                        "<value of type int32_t>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("value"), in_value,
                        "<value of type ::base::Value::List>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kPeerConnectionTrackerHost_AddLegacyStats_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::PeerConnectionTrackerHost_AddLegacyStats_Params_Data> params(
          message);
  params.Allocate();
  params->lid = in_lid;
  mojo::internal::MessageFragment<
      typename decltype(params->value)::BaseType> value_fragment(
          params.message());
  mojo::internal::Serialize<::mojo_base::mojom::ListValueDataView>(
      in_value, value_fragment);
  params->value.Set(
      value_fragment.is_null() ? nullptr : value_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->value.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null value in PeerConnectionTrackerHost.AddLegacyStats request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(PeerConnectionTrackerHost::Name_);
  message.set_method_name("AddLegacyStats");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool PeerConnectionTrackerHostStubDispatch::Accept(
    PeerConnectionTrackerHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kPeerConnectionTrackerHost_AddPeerConnection_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_AddPeerConnection_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_AddPeerConnection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      PeerConnectionInfoPtr p_info{};
      PeerConnectionTrackerHost_AddPeerConnection_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadInfo(&p_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddPeerConnection(
std::move(p_info));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_RemovePeerConnection_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_RemovePeerConnection_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_RemovePeerConnection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_lid{};
      PeerConnectionTrackerHost_RemovePeerConnection_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_lid = input_data_view.lid();
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->RemovePeerConnection(
std::move(p_lid));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_UpdatePeerConnection_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_UpdatePeerConnection_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_UpdatePeerConnection_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_lid{};
      std::string p_type{};
      std::string p_value{};
      PeerConnectionTrackerHost_UpdatePeerConnection_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_lid = input_data_view.lid();
      if (success && !input_data_view.ReadType(&p_type))
        success = false;
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->UpdatePeerConnection(
std::move(p_lid), 
std::move(p_type), 
std::move(p_value));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_lid{};
      std::string p_session_id{};
      PeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_lid = input_data_view.lid();
      if (success && !input_data_view.ReadSessionId(&p_session_id))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 3, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OnPeerConnectionSessionIdSet(
std::move(p_lid), 
std::move(p_session_id));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMedia_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_GetUserMedia_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_GetUserMedia_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_request_id{};
      bool p_audio{};
      bool p_video{};
      std::string p_audio_constraints{};
      std::string p_video_constraints{};
      PeerConnectionTrackerHost_GetUserMedia_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_request_id = input_data_view.request_id();
      if (success)
        p_audio = input_data_view.audio();
      if (success)
        p_video = input_data_view.video();
      if (success && !input_data_view.ReadAudioConstraints(&p_audio_constraints))
        success = false;
      if (success && !input_data_view.ReadVideoConstraints(&p_video_constraints))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 4, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetUserMedia(
std::move(p_request_id), 
std::move(p_audio), 
std::move(p_video), 
std::move(p_audio_constraints), 
std::move(p_video_constraints));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMediaSuccess_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_GetUserMediaSuccess_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_GetUserMediaSuccess_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_request_id{};
      std::string p_stream_id{};
      std::string p_audio_track_info{};
      std::string p_video_track_info{};
      PeerConnectionTrackerHost_GetUserMediaSuccess_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_request_id = input_data_view.request_id();
      if (success && !input_data_view.ReadStreamId(&p_stream_id))
        success = false;
      if (success && !input_data_view.ReadAudioTrackInfo(&p_audio_track_info))
        success = false;
      if (success && !input_data_view.ReadVideoTrackInfo(&p_video_track_info))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 5, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetUserMediaSuccess(
std::move(p_request_id), 
std::move(p_stream_id), 
std::move(p_audio_track_info), 
std::move(p_video_track_info));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMediaFailure_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_GetUserMediaFailure_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_GetUserMediaFailure_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_request_id{};
      std::string p_error{};
      std::string p_error_message{};
      PeerConnectionTrackerHost_GetUserMediaFailure_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_request_id = input_data_view.request_id();
      if (success && !input_data_view.ReadError(&p_error))
        success = false;
      if (success && !input_data_view.ReadErrorMessage(&p_error_message))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 6, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->GetUserMediaFailure(
std::move(p_request_id), 
std::move(p_error), 
std::move(p_error_message));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_WebRtcEventLogWrite_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_WebRtcEventLogWrite_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_WebRtcEventLogWrite_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_lid{};
      std::vector<uint8_t> p_output{};
      PeerConnectionTrackerHost_WebRtcEventLogWrite_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_lid = input_data_view.lid();
      if (success && !input_data_view.ReadOutput(&p_output))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 7, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->WebRtcEventLogWrite(
std::move(p_lid), 
std::move(p_output));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_AddStandardStats_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_AddStandardStats_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_AddStandardStats_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_lid{};
      ::base::Value::List p_value{};
      PeerConnectionTrackerHost_AddStandardStats_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_lid = input_data_view.lid();
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 8, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddStandardStats(
std::move(p_lid), 
std::move(p_value));
      return true;
    }
    case internal::kPeerConnectionTrackerHost_AddLegacyStats_Name: {

      DCHECK(message->is_serialized());
      internal::PeerConnectionTrackerHost_AddLegacyStats_Params_Data* params =
          reinterpret_cast<internal::PeerConnectionTrackerHost_AddLegacyStats_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      int32_t p_lid{};
      ::base::Value::List p_value{};
      PeerConnectionTrackerHost_AddLegacyStats_ParamsDataView input_data_view(params, message);
      
      if (success)
        p_lid = input_data_view.lid();
      if (success && !input_data_view.ReadValue(&p_value))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            PeerConnectionTrackerHost::Name_, 9, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->AddLegacyStats(
std::move(p_lid), 
std::move(p_value));
      return true;
    }
  }
  return false;
}

// static
bool PeerConnectionTrackerHostStubDispatch::AcceptWithResponder(
    PeerConnectionTrackerHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kPeerConnectionTrackerHost_AddPeerConnection_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_RemovePeerConnection_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_UpdatePeerConnection_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMedia_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMediaSuccess_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_GetUserMediaFailure_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_WebRtcEventLogWrite_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_AddStandardStats_Name: {
      break;
    }
    case internal::kPeerConnectionTrackerHost_AddLegacyStats_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kPeerConnectionTrackerHostValidationInfo[] = {
    {&internal::PeerConnectionTrackerHost_AddPeerConnection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_RemovePeerConnection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_UpdatePeerConnection_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_OnPeerConnectionSessionIdSet_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_GetUserMedia_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_GetUserMediaSuccess_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_GetUserMediaFailure_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_WebRtcEventLogWrite_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_AddStandardStats_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::PeerConnectionTrackerHost_AddLegacyStats_Params_Data::Validate,
     nullptr /* no response */},
};

bool PeerConnectionTrackerHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::PeerConnectionTrackerHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kPeerConnectionTrackerHostValidationInfo);
}



}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::PeerConnectionInfo::DataView, ::blink::mojom::PeerConnectionInfoPtr>::Read(
    ::blink::mojom::PeerConnectionInfo::DataView input,
    ::blink::mojom::PeerConnectionInfoPtr* output) {
  bool success = true;
  ::blink::mojom::PeerConnectionInfoPtr result(::blink::mojom::PeerConnectionInfo::New());
  
      if (success)
        result->lid = input.lid();
      if (success && !input.ReadRtcConfiguration(&result->rtc_configuration))
        success = false;
      if (success && !input.ReadConstraints(&result->constraints))
        success = false;
      if (success && !input.ReadUrl(&result->url))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void PeerConnectionManagerInterceptorForTesting::OnSuspend() {
  GetForwardingInterface()->OnSuspend();
}
void PeerConnectionManagerInterceptorForTesting::OnThermalStateChange(DeviceThermalState thermal_state) {
  GetForwardingInterface()->OnThermalStateChange(std::move(thermal_state));
}
void PeerConnectionManagerInterceptorForTesting::OnSpeedLimitChange(int32_t speed_limit) {
  GetForwardingInterface()->OnSpeedLimitChange(std::move(speed_limit));
}
void PeerConnectionManagerInterceptorForTesting::StartEventLog(int32_t peer_connection_local_id, int32_t output_period_ms) {
  GetForwardingInterface()->StartEventLog(std::move(peer_connection_local_id), std::move(output_period_ms));
}
void PeerConnectionManagerInterceptorForTesting::StopEventLog(int32_t peer_connection_local_id) {
  GetForwardingInterface()->StopEventLog(std::move(peer_connection_local_id));
}
void PeerConnectionManagerInterceptorForTesting::GetStandardStats() {
  GetForwardingInterface()->GetStandardStats();
}
void PeerConnectionManagerInterceptorForTesting::GetLegacyStats() {
  GetForwardingInterface()->GetLegacyStats();
}
PeerConnectionManagerAsyncWaiter::PeerConnectionManagerAsyncWaiter(
    PeerConnectionManager* proxy) : proxy_(proxy) {}

PeerConnectionManagerAsyncWaiter::~PeerConnectionManagerAsyncWaiter() = default;




void PeerConnectionTrackerHostInterceptorForTesting::AddPeerConnection(PeerConnectionInfoPtr info) {
  GetForwardingInterface()->AddPeerConnection(std::move(info));
}
void PeerConnectionTrackerHostInterceptorForTesting::RemovePeerConnection(int32_t lid) {
  GetForwardingInterface()->RemovePeerConnection(std::move(lid));
}
void PeerConnectionTrackerHostInterceptorForTesting::UpdatePeerConnection(int32_t lid, const std::string& type, const std::string& value) {
  GetForwardingInterface()->UpdatePeerConnection(std::move(lid), std::move(type), std::move(value));
}
void PeerConnectionTrackerHostInterceptorForTesting::OnPeerConnectionSessionIdSet(int32_t lid, const std::string& session_id) {
  GetForwardingInterface()->OnPeerConnectionSessionIdSet(std::move(lid), std::move(session_id));
}
void PeerConnectionTrackerHostInterceptorForTesting::GetUserMedia(int32_t request_id, bool audio, bool video, const std::string& audio_constraints, const std::string& video_constraints) {
  GetForwardingInterface()->GetUserMedia(std::move(request_id), std::move(audio), std::move(video), std::move(audio_constraints), std::move(video_constraints));
}
void PeerConnectionTrackerHostInterceptorForTesting::GetUserMediaSuccess(int32_t request_id, const std::string& stream_id, const std::string& audio_track_info, const std::string& video_track_info) {
  GetForwardingInterface()->GetUserMediaSuccess(std::move(request_id), std::move(stream_id), std::move(audio_track_info), std::move(video_track_info));
}
void PeerConnectionTrackerHostInterceptorForTesting::GetUserMediaFailure(int32_t request_id, const std::string& error, const std::string& error_message) {
  GetForwardingInterface()->GetUserMediaFailure(std::move(request_id), std::move(error), std::move(error_message));
}
void PeerConnectionTrackerHostInterceptorForTesting::WebRtcEventLogWrite(int32_t lid, const std::vector<uint8_t>& output) {
  GetForwardingInterface()->WebRtcEventLogWrite(std::move(lid), std::move(output));
}
void PeerConnectionTrackerHostInterceptorForTesting::AddStandardStats(int32_t lid, ::base::Value::List value) {
  GetForwardingInterface()->AddStandardStats(std::move(lid), std::move(value));
}
void PeerConnectionTrackerHostInterceptorForTesting::AddLegacyStats(int32_t lid, ::base::Value::List value) {
  GetForwardingInterface()->AddLegacyStats(std::move(lid), std::move(value));
}
PeerConnectionTrackerHostAsyncWaiter::PeerConnectionTrackerHostAsyncWaiter(
    PeerConnectionTrackerHost* proxy) : proxy_(proxy) {}

PeerConnectionTrackerHostAsyncWaiter::~PeerConnectionTrackerHostAsyncWaiter() = default;






}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif