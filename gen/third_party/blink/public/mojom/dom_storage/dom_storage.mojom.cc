// third_party/blink/public/mojom/dom_storage/dom_storage.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom-params-data.h"
#include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom-import-headers.h"
#include "third_party/blink/public/mojom/dom_storage/dom_storage.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_DOM_STORAGE_DOM_STORAGE_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_DOM_STORAGE_DOM_STORAGE_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace mojom {
const char DomStorageProvider::Name_[] = "blink.mojom.DomStorageProvider";

DomStorageProvider::IPCStableHashFunction DomStorageProvider::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kDomStorageProvider_BindDomStorage_Name: {
      return &DomStorageProvider::BindDomStorage_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* DomStorageProvider::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kDomStorageProvider_BindDomStorage_Name:
            return "Receive blink::mojom::DomStorageProvider::BindDomStorage";
    }
  } else {
    switch (message.name()) {
      case internal::kDomStorageProvider_BindDomStorage_Name:
            return "Receive reply blink::mojom::DomStorageProvider::BindDomStorage";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t DomStorageProvider::BindDomStorage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::DomStorageProvider::BindDomStorage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

DomStorageProviderProxy::DomStorageProviderProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void DomStorageProviderProxy::BindDomStorage(
    ::mojo::PendingReceiver<DomStorage> in_receiver, ::mojo::PendingRemote<DomStorageClient> in_client) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::DomStorageProvider::BindDomStorage", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<DomStorage>>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("client"), in_client,
                        "<value of type ::mojo::PendingRemote<DomStorageClient>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDomStorageProvider_BindDomStorage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::DomStorageProvider_BindDomStorage_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::DomStorageInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in DomStorageProvider.BindDomStorage request");
  mojo::internal::Serialize<mojo::InterfacePtrDataView<::blink::mojom::DomStorageClientInterfaceBase>>(
      in_client, &params->client, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->client),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid client in DomStorageProvider.BindDomStorage request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DomStorageProvider::Name_);
  message.set_method_name("BindDomStorage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool DomStorageProviderStubDispatch::Accept(
    DomStorageProvider* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kDomStorageProvider_BindDomStorage_Name: {

      DCHECK(message->is_serialized());
      internal::DomStorageProvider_BindDomStorage_Params_Data* params =
          reinterpret_cast<internal::DomStorageProvider_BindDomStorage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::mojo::PendingReceiver<DomStorage> p_receiver{};
      ::mojo::PendingRemote<DomStorageClient> p_client{};
      DomStorageProvider_BindDomStorage_ParamsDataView input_data_view(params, message);
      
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (success) {
        p_client =
            input_data_view.TakeClient<decltype(p_client)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DomStorageProvider::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindDomStorage(
std::move(p_receiver), 
std::move(p_client));
      return true;
    }
  }
  return false;
}

// static
bool DomStorageProviderStubDispatch::AcceptWithResponder(
    DomStorageProvider* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kDomStorageProvider_BindDomStorage_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kDomStorageProviderValidationInfo[] = {
    {&internal::DomStorageProvider_BindDomStorage_Params_Data::Validate,
     nullptr /* no response */},
};

bool DomStorageProviderRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::DomStorageProvider::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kDomStorageProviderValidationInfo);
}

const char DomStorage::Name_[] = "blink.mojom.DomStorage";

DomStorage::IPCStableHashFunction DomStorage::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kDomStorage_OpenLocalStorage_Name: {
      return &DomStorage::OpenLocalStorage_Sym::IPCStableHash;
    }
    case internal::kDomStorage_BindSessionStorageNamespace_Name: {
      return &DomStorage::BindSessionStorageNamespace_Sym::IPCStableHash;
    }
    case internal::kDomStorage_BindSessionStorageArea_Name: {
      return &DomStorage::BindSessionStorageArea_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* DomStorage::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kDomStorage_OpenLocalStorage_Name:
            return "Receive blink::mojom::DomStorage::OpenLocalStorage";
      case internal::kDomStorage_BindSessionStorageNamespace_Name:
            return "Receive blink::mojom::DomStorage::BindSessionStorageNamespace";
      case internal::kDomStorage_BindSessionStorageArea_Name:
            return "Receive blink::mojom::DomStorage::BindSessionStorageArea";
    }
  } else {
    switch (message.name()) {
      case internal::kDomStorage_OpenLocalStorage_Name:
            return "Receive reply blink::mojom::DomStorage::OpenLocalStorage";
      case internal::kDomStorage_BindSessionStorageNamespace_Name:
            return "Receive reply blink::mojom::DomStorage::BindSessionStorageNamespace";
      case internal::kDomStorage_BindSessionStorageArea_Name:
            return "Receive reply blink::mojom::DomStorage::BindSessionStorageArea";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t DomStorage::OpenLocalStorage_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::DomStorage::OpenLocalStorage");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DomStorage::BindSessionStorageNamespace_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::DomStorage::BindSessionStorageNamespace");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t DomStorage::BindSessionStorageArea_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::DomStorage::BindSessionStorageArea");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

DomStorageProxy::DomStorageProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void DomStorageProxy::OpenLocalStorage(
    const ::blink::StorageKey& in_storage_key, const ::blink::LocalFrameToken& in_local_frame_token, ::mojo::PendingReceiver<::blink::mojom::StorageArea> in_area) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::DomStorage::OpenLocalStorage", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("storage_key"), in_storage_key,
                        "<value of type const ::blink::StorageKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_frame_token"), in_local_frame_token,
                        "<value of type const ::blink::LocalFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("area"), in_area,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::StorageArea>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDomStorage_OpenLocalStorage_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::DomStorage_OpenLocalStorage_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->storage_key)::BaseType> storage_key_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::StorageKeyDataView>(
      in_storage_key, storage_key_fragment);
  params->storage_key.Set(
      storage_key_fragment.is_null() ? nullptr : storage_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->storage_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null storage_key in DomStorage.OpenLocalStorage request");
  mojo::internal::MessageFragment<
      typename decltype(params->local_frame_token)::BaseType> local_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_local_frame_token, local_frame_token_fragment);
  params->local_frame_token.Set(
      local_frame_token_fragment.is_null() ? nullptr : local_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->local_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null local_frame_token in DomStorage.OpenLocalStorage request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::StorageAreaInterfaceBase>>(
      in_area, &params->area, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->area),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid area in DomStorage.OpenLocalStorage request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DomStorage::Name_);
  message.set_method_name("OpenLocalStorage");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DomStorageProxy::BindSessionStorageNamespace(
    const std::string& in_namespace_id, ::mojo::PendingReceiver<::blink::mojom::SessionStorageNamespace> in_receiver) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::DomStorage::BindSessionStorageNamespace", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("namespace_id"), in_namespace_id,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("receiver"), in_receiver,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::SessionStorageNamespace>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDomStorage_BindSessionStorageNamespace_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::DomStorage_BindSessionStorageNamespace_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->namespace_id)::BaseType> namespace_id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_namespace_id, namespace_id_fragment);
  params->namespace_id.Set(
      namespace_id_fragment.is_null() ? nullptr : namespace_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->namespace_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null namespace_id in DomStorage.BindSessionStorageNamespace request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::SessionStorageNamespaceInterfaceBase>>(
      in_receiver, &params->receiver, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->receiver),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid receiver in DomStorage.BindSessionStorageNamespace request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DomStorage::Name_);
  message.set_method_name("BindSessionStorageNamespace");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void DomStorageProxy::BindSessionStorageArea(
    const ::blink::StorageKey& in_storage_key, const ::blink::LocalFrameToken& in_local_frame_token, const std::string& in_namespace_id, ::mojo::PendingReceiver<::blink::mojom::StorageArea> in_session_namespace) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::DomStorage::BindSessionStorageArea", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("storage_key"), in_storage_key,
                        "<value of type const ::blink::StorageKey&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("local_frame_token"), in_local_frame_token,
                        "<value of type const ::blink::LocalFrameToken&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("namespace_id"), in_namespace_id,
                        "<value of type const std::string&>");
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("session_namespace"), in_session_namespace,
                        "<value of type ::mojo::PendingReceiver<::blink::mojom::StorageArea>>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDomStorage_BindSessionStorageArea_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::DomStorage_BindSessionStorageArea_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->storage_key)::BaseType> storage_key_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::StorageKeyDataView>(
      in_storage_key, storage_key_fragment);
  params->storage_key.Set(
      storage_key_fragment.is_null() ? nullptr : storage_key_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->storage_key.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null storage_key in DomStorage.BindSessionStorageArea request");
  mojo::internal::MessageFragment<
      typename decltype(params->local_frame_token)::BaseType> local_frame_token_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::LocalFrameTokenDataView>(
      in_local_frame_token, local_frame_token_fragment);
  params->local_frame_token.Set(
      local_frame_token_fragment.is_null() ? nullptr : local_frame_token_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->local_frame_token.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null local_frame_token in DomStorage.BindSessionStorageArea request");
  mojo::internal::MessageFragment<
      typename decltype(params->namespace_id)::BaseType> namespace_id_fragment(
          params.message());
  mojo::internal::Serialize<mojo::StringDataView>(
      in_namespace_id, namespace_id_fragment);
  params->namespace_id.Set(
      namespace_id_fragment.is_null() ? nullptr : namespace_id_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->namespace_id.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null namespace_id in DomStorage.BindSessionStorageArea request");
  mojo::internal::Serialize<mojo::InterfaceRequestDataView<::blink::mojom::StorageAreaInterfaceBase>>(
      in_session_namespace, &params->session_namespace, &params.message());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      !mojo::internal::IsHandleOrInterfaceValid(params->session_namespace),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
      "invalid session_namespace in DomStorage.BindSessionStorageArea request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DomStorage::Name_);
  message.set_method_name("BindSessionStorageArea");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool DomStorageStubDispatch::Accept(
    DomStorage* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kDomStorage_OpenLocalStorage_Name: {

      DCHECK(message->is_serialized());
      internal::DomStorage_OpenLocalStorage_Params_Data* params =
          reinterpret_cast<internal::DomStorage_OpenLocalStorage_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::StorageKey p_storage_key{};
      ::blink::LocalFrameToken p_local_frame_token{};
      ::mojo::PendingReceiver<::blink::mojom::StorageArea> p_area{};
      DomStorage_OpenLocalStorage_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStorageKey(&p_storage_key))
        success = false;
      if (success && !input_data_view.ReadLocalFrameToken(&p_local_frame_token))
        success = false;
      if (success) {
        p_area =
            input_data_view.TakeArea<decltype(p_area)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DomStorage::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->OpenLocalStorage(
std::move(p_storage_key), 
std::move(p_local_frame_token), 
std::move(p_area));
      return true;
    }
    case internal::kDomStorage_BindSessionStorageNamespace_Name: {

      DCHECK(message->is_serialized());
      internal::DomStorage_BindSessionStorageNamespace_Params_Data* params =
          reinterpret_cast<internal::DomStorage_BindSessionStorageNamespace_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      std::string p_namespace_id{};
      ::mojo::PendingReceiver<::blink::mojom::SessionStorageNamespace> p_receiver{};
      DomStorage_BindSessionStorageNamespace_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadNamespaceId(&p_namespace_id))
        success = false;
      if (success) {
        p_receiver =
            input_data_view.TakeReceiver<decltype(p_receiver)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DomStorage::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindSessionStorageNamespace(
std::move(p_namespace_id), 
std::move(p_receiver));
      return true;
    }
    case internal::kDomStorage_BindSessionStorageArea_Name: {

      DCHECK(message->is_serialized());
      internal::DomStorage_BindSessionStorageArea_Params_Data* params =
          reinterpret_cast<internal::DomStorage_BindSessionStorageArea_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      ::blink::StorageKey p_storage_key{};
      ::blink::LocalFrameToken p_local_frame_token{};
      std::string p_namespace_id{};
      ::mojo::PendingReceiver<::blink::mojom::StorageArea> p_session_namespace{};
      DomStorage_BindSessionStorageArea_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadStorageKey(&p_storage_key))
        success = false;
      if (success && !input_data_view.ReadLocalFrameToken(&p_local_frame_token))
        success = false;
      if (success && !input_data_view.ReadNamespaceId(&p_namespace_id))
        success = false;
      if (success) {
        p_session_namespace =
            input_data_view.TakeSessionNamespace<decltype(p_session_namespace)>();
      }
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DomStorage::Name_, 2, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->BindSessionStorageArea(
std::move(p_storage_key), 
std::move(p_local_frame_token), 
std::move(p_namespace_id), 
std::move(p_session_namespace));
      return true;
    }
  }
  return false;
}

// static
bool DomStorageStubDispatch::AcceptWithResponder(
    DomStorage* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kDomStorage_OpenLocalStorage_Name: {
      break;
    }
    case internal::kDomStorage_BindSessionStorageNamespace_Name: {
      break;
    }
    case internal::kDomStorage_BindSessionStorageArea_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kDomStorageValidationInfo[] = {
    {&internal::DomStorage_OpenLocalStorage_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DomStorage_BindSessionStorageNamespace_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::DomStorage_BindSessionStorageArea_Params_Data::Validate,
     nullptr /* no response */},
};

bool DomStorageRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::DomStorage::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kDomStorageValidationInfo);
}

const char DomStorageClient::Name_[] = "blink.mojom.DomStorageClient";

DomStorageClient::IPCStableHashFunction DomStorageClient::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kDomStorageClient_ResetStorageAreaAndNamespaceConnections_Name: {
      return &DomStorageClient::ResetStorageAreaAndNamespaceConnections_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* DomStorageClient::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kDomStorageClient_ResetStorageAreaAndNamespaceConnections_Name:
            return "Receive blink::mojom::DomStorageClient::ResetStorageAreaAndNamespaceConnections";
    }
  } else {
    switch (message.name()) {
      case internal::kDomStorageClient_ResetStorageAreaAndNamespaceConnections_Name:
            return "Receive reply blink::mojom::DomStorageClient::ResetStorageAreaAndNamespaceConnections";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t DomStorageClient::ResetStorageAreaAndNamespaceConnections_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::DomStorageClient::ResetStorageAreaAndNamespaceConnections");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

DomStorageClientProxy::DomStorageClientProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void DomStorageClientProxy::ResetStorageAreaAndNamespaceConnections(
    ) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT0("mojom", "Send blink::mojom::DomStorageClient::ResetStorageAreaAndNamespaceConnections");
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kDomStorageClient_ResetStorageAreaAndNamespaceConnections_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::DomStorageClient_ResetStorageAreaAndNamespaceConnections_Params_Data> params(
          message);
  params.Allocate();

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(DomStorageClient::Name_);
  message.set_method_name("ResetStorageAreaAndNamespaceConnections");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool DomStorageClientStubDispatch::Accept(
    DomStorageClient* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kDomStorageClient_ResetStorageAreaAndNamespaceConnections_Name: {

      DCHECK(message->is_serialized());
      internal::DomStorageClient_ResetStorageAreaAndNamespaceConnections_Params_Data* params =
          reinterpret_cast<internal::DomStorageClient_ResetStorageAreaAndNamespaceConnections_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      DomStorageClient_ResetStorageAreaAndNamespaceConnections_ParamsDataView input_data_view(params, message);
      
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            DomStorageClient::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->ResetStorageAreaAndNamespaceConnections();
      return true;
    }
  }
  return false;
}

// static
bool DomStorageClientStubDispatch::AcceptWithResponder(
    DomStorageClient* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kDomStorageClient_ResetStorageAreaAndNamespaceConnections_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kDomStorageClientValidationInfo[] = {
    {&internal::DomStorageClient_ResetStorageAreaAndNamespaceConnections_Params_Data::Validate,
     nullptr /* no response */},
};

bool DomStorageClientRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::DomStorageClient::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kDomStorageClientValidationInfo);
}



}  // namespace mojom
}  // namespace blink


namespace mojo {

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void DomStorageProviderInterceptorForTesting::BindDomStorage(::mojo::PendingReceiver<DomStorage> receiver, ::mojo::PendingRemote<DomStorageClient> client) {
  GetForwardingInterface()->BindDomStorage(std::move(receiver), std::move(client));
}
DomStorageProviderAsyncWaiter::DomStorageProviderAsyncWaiter(
    DomStorageProvider* proxy) : proxy_(proxy) {}

DomStorageProviderAsyncWaiter::~DomStorageProviderAsyncWaiter() = default;




void DomStorageInterceptorForTesting::OpenLocalStorage(const ::blink::StorageKey& storage_key, const ::blink::LocalFrameToken& local_frame_token, ::mojo::PendingReceiver<::blink::mojom::StorageArea> area) {
  GetForwardingInterface()->OpenLocalStorage(std::move(storage_key), std::move(local_frame_token), std::move(area));
}
void DomStorageInterceptorForTesting::BindSessionStorageNamespace(const std::string& namespace_id, ::mojo::PendingReceiver<::blink::mojom::SessionStorageNamespace> receiver) {
  GetForwardingInterface()->BindSessionStorageNamespace(std::move(namespace_id), std::move(receiver));
}
void DomStorageInterceptorForTesting::BindSessionStorageArea(const ::blink::StorageKey& storage_key, const ::blink::LocalFrameToken& local_frame_token, const std::string& namespace_id, ::mojo::PendingReceiver<::blink::mojom::StorageArea> session_namespace) {
  GetForwardingInterface()->BindSessionStorageArea(std::move(storage_key), std::move(local_frame_token), std::move(namespace_id), std::move(session_namespace));
}
DomStorageAsyncWaiter::DomStorageAsyncWaiter(
    DomStorage* proxy) : proxy_(proxy) {}

DomStorageAsyncWaiter::~DomStorageAsyncWaiter() = default;




void DomStorageClientInterceptorForTesting::ResetStorageAreaAndNamespaceConnections() {
  GetForwardingInterface()->ResetStorageAreaAndNamespaceConnections();
}
DomStorageClientAsyncWaiter::DomStorageClientAsyncWaiter(
    DomStorageClient* proxy) : proxy_(proxy) {}

DomStorageClientAsyncWaiter::~DomStorageClientAsyncWaiter() = default;






}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif