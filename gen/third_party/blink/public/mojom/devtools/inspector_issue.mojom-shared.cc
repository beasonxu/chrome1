// third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include "third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared.h"

// Used to support stream output operator for enums.
// TODO(dcheng): Consider omitting this somehow if not needed.
#include <ostream>
#include <utility>

#include "base/strings/stringprintf.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/lib/validation_util.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/devtools/inspector_issue.mojom-params-data.h"
namespace blink {
namespace mojom {

static NOINLINE const char* InspectorIssueCodeToStringHelper(InspectorIssueCode value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case InspectorIssueCode::kCookieIssue:
      return "kCookieIssue";
    case InspectorIssueCode::kMixedContentIssue:
      return "kMixedContentIssue";
    case InspectorIssueCode::kBlockedByResponseIssue:
      return "kBlockedByResponseIssue";
    case InspectorIssueCode::kContentSecurityPolicyIssue:
      return "kContentSecurityPolicyIssue";
    case InspectorIssueCode::kSharedArrayBufferIssue:
      return "kSharedArrayBufferIssue";
    case InspectorIssueCode::kTrustedWebActivityIssue:
      return "kTrustedWebActivityIssue";
    case InspectorIssueCode::kHeavyAdIssue:
      return "kHeavyAdIssue";
    case InspectorIssueCode::kLowTextContrastIssue:
      return "kLowTextContrastIssue";
    case InspectorIssueCode::kFederatedAuthRequestIssue:
      return "kFederatedAuthRequestIssue";
    case InspectorIssueCode::kGenericIssue:
      return "kGenericIssue";
    default:
      return nullptr;
  }
}

std::string InspectorIssueCodeToString(InspectorIssueCode value) {
  const char *str = InspectorIssueCodeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown InspectorIssueCode value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, InspectorIssueCode value) {
  return os << InspectorIssueCodeToString(value);
}

static NOINLINE const char* HeavyAdResolutionStatusToStringHelper(HeavyAdResolutionStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case HeavyAdResolutionStatus::kHeavyAdBlocked:
      return "kHeavyAdBlocked";
    case HeavyAdResolutionStatus::kHeavyAdWarning:
      return "kHeavyAdWarning";
    default:
      return nullptr;
  }
}

std::string HeavyAdResolutionStatusToString(HeavyAdResolutionStatus value) {
  const char *str = HeavyAdResolutionStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown HeavyAdResolutionStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, HeavyAdResolutionStatus value) {
  return os << HeavyAdResolutionStatusToString(value);
}

static NOINLINE const char* HeavyAdReasonToStringHelper(HeavyAdReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case HeavyAdReason::kNetworkTotalLimit:
      return "kNetworkTotalLimit";
    case HeavyAdReason::kCpuTotalLimit:
      return "kCpuTotalLimit";
    case HeavyAdReason::kCpuPeakLimit:
      return "kCpuPeakLimit";
    default:
      return nullptr;
  }
}

std::string HeavyAdReasonToString(HeavyAdReason value) {
  const char *str = HeavyAdReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown HeavyAdReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, HeavyAdReason value) {
  return os << HeavyAdReasonToString(value);
}

static NOINLINE const char* MixedContentResolutionStatusToStringHelper(MixedContentResolutionStatus value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case MixedContentResolutionStatus::kMixedContentBlocked:
      return "kMixedContentBlocked";
    case MixedContentResolutionStatus::kMixedContentAutomaticallyUpgraded:
      return "kMixedContentAutomaticallyUpgraded";
    case MixedContentResolutionStatus::kMixedContentWarning:
      return "kMixedContentWarning";
    default:
      return nullptr;
  }
}

std::string MixedContentResolutionStatusToString(MixedContentResolutionStatus value) {
  const char *str = MixedContentResolutionStatusToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown MixedContentResolutionStatus value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, MixedContentResolutionStatus value) {
  return os << MixedContentResolutionStatusToString(value);
}

static NOINLINE const char* ContentSecurityPolicyViolationTypeToStringHelper(ContentSecurityPolicyViolationType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case ContentSecurityPolicyViolationType::kInlineViolation:
      return "kInlineViolation";
    case ContentSecurityPolicyViolationType::kEvalViolation:
      return "kEvalViolation";
    case ContentSecurityPolicyViolationType::kURLViolation:
      return "kURLViolation";
    case ContentSecurityPolicyViolationType::kTrustedTypesSinkViolation:
      return "kTrustedTypesSinkViolation";
    case ContentSecurityPolicyViolationType::kTrustedTypesPolicyViolation:
      return "kTrustedTypesPolicyViolation";
    case ContentSecurityPolicyViolationType::kWasmEvalViolation:
      return "kWasmEvalViolation";
    default:
      return nullptr;
  }
}

std::string ContentSecurityPolicyViolationTypeToString(ContentSecurityPolicyViolationType value) {
  const char *str = ContentSecurityPolicyViolationTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown ContentSecurityPolicyViolationType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, ContentSecurityPolicyViolationType value) {
  return os << ContentSecurityPolicyViolationTypeToString(value);
}

static NOINLINE const char* CookieOperationToStringHelper(CookieOperation value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case CookieOperation::kSetCookie:
      return "kSetCookie";
    case CookieOperation::kReadCookie:
      return "kReadCookie";
    default:
      return nullptr;
  }
}

std::string CookieOperationToString(CookieOperation value) {
  const char *str = CookieOperationToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown CookieOperation value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, CookieOperation value) {
  return os << CookieOperationToString(value);
}

static NOINLINE const char* CookieExclusionReasonToStringHelper(CookieExclusionReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case CookieExclusionReason::kExcludeSameSiteUnspecifiedTreatedAsLax:
      return "kExcludeSameSiteUnspecifiedTreatedAsLax";
    case CookieExclusionReason::kExcludeSameSiteNoneInsecure:
      return "kExcludeSameSiteNoneInsecure";
    case CookieExclusionReason::kExcludeSameSiteLax:
      return "kExcludeSameSiteLax";
    case CookieExclusionReason::kExcludeSameSiteStrict:
      return "kExcludeSameSiteStrict";
    case CookieExclusionReason::kExcludeDomainNonASCII:
      return "kExcludeDomainNonASCII";
    default:
      return nullptr;
  }
}

std::string CookieExclusionReasonToString(CookieExclusionReason value) {
  const char *str = CookieExclusionReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown CookieExclusionReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, CookieExclusionReason value) {
  return os << CookieExclusionReasonToString(value);
}

static NOINLINE const char* CookieWarningReasonToStringHelper(CookieWarningReason value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case CookieWarningReason::kWarnSameSiteUnspecifiedCrossSiteContext:
      return "kWarnSameSiteUnspecifiedCrossSiteContext";
    case CookieWarningReason::kWarnSameSiteNoneInsecure:
      return "kWarnSameSiteNoneInsecure";
    case CookieWarningReason::kWarnSameSiteUnspecifiedLaxAllowUnsafe:
      return "kWarnSameSiteUnspecifiedLaxAllowUnsafe";
    case CookieWarningReason::kWarnSameSiteStrictLaxDowngradeStrict:
      return "kWarnSameSiteStrictLaxDowngradeStrict";
    case CookieWarningReason::kWarnSameSiteStrictCrossDowngradeStrict:
      return "kWarnSameSiteStrictCrossDowngradeStrict";
    case CookieWarningReason::kWarnSameSiteStrictCrossDowngradeLax:
      return "kWarnSameSiteStrictCrossDowngradeLax";
    case CookieWarningReason::kWarnSameSiteLaxCrossDowngradeStrict:
      return "kWarnSameSiteLaxCrossDowngradeStrict";
    case CookieWarningReason::kWarnSameSiteLaxCrossDowngradeLax:
      return "kWarnSameSiteLaxCrossDowngradeLax";
    case CookieWarningReason::kWarnAttributeValueExceedsMaxSize:
      return "kWarnAttributeValueExceedsMaxSize";
    case CookieWarningReason::kWarnDomainNonASCII:
      return "kWarnDomainNonASCII";
    default:
      return nullptr;
  }
}

std::string CookieWarningReasonToString(CookieWarningReason value) {
  const char *str = CookieWarningReasonToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown CookieWarningReason value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, CookieWarningReason value) {
  return os << CookieWarningReasonToString(value);
}

static NOINLINE const char* SharedArrayBufferIssueTypeToStringHelper(SharedArrayBufferIssueType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case SharedArrayBufferIssueType::kTransferIssue:
      return "kTransferIssue";
    case SharedArrayBufferIssueType::kCreationIssue:
      return "kCreationIssue";
    default:
      return nullptr;
  }
}

std::string SharedArrayBufferIssueTypeToString(SharedArrayBufferIssueType value) {
  const char *str = SharedArrayBufferIssueTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown SharedArrayBufferIssueType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, SharedArrayBufferIssueType value) {
  return os << SharedArrayBufferIssueTypeToString(value);
}

static NOINLINE const char* TwaQualityEnforcementViolationTypeToStringHelper(TwaQualityEnforcementViolationType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case TwaQualityEnforcementViolationType::kHttpError:
      return "kHttpError";
    case TwaQualityEnforcementViolationType::kUnavailableOffline:
      return "kUnavailableOffline";
    case TwaQualityEnforcementViolationType::kDigitalAssetLinks:
      return "kDigitalAssetLinks";
    default:
      return nullptr;
  }
}

std::string TwaQualityEnforcementViolationTypeToString(TwaQualityEnforcementViolationType value) {
  const char *str = TwaQualityEnforcementViolationTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown TwaQualityEnforcementViolationType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, TwaQualityEnforcementViolationType value) {
  return os << TwaQualityEnforcementViolationTypeToString(value);
}

static NOINLINE const char* FederatedAuthRequestResultToStringHelper(FederatedAuthRequestResult value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case FederatedAuthRequestResult::kSuccess:
      return "kSuccess";
    case FederatedAuthRequestResult::kApprovalDeclined:
      return "kApprovalDeclined";
    case FederatedAuthRequestResult::kErrorDisabledInSettings:
      return "kErrorDisabledInSettings";
    case FederatedAuthRequestResult::kErrorTooManyRequests:
      return "kErrorTooManyRequests";
    case FederatedAuthRequestResult::kErrorFetchingManifestListHttpNotFound:
      return "kErrorFetchingManifestListHttpNotFound";
    case FederatedAuthRequestResult::kErrorFetchingManifestListNoResponse:
      return "kErrorFetchingManifestListNoResponse";
    case FederatedAuthRequestResult::kErrorFetchingManifestListInvalidResponse:
      return "kErrorFetchingManifestListInvalidResponse";
    case FederatedAuthRequestResult::kErrorManifestNotInManifestList:
      return "kErrorManifestNotInManifestList";
    case FederatedAuthRequestResult::kErrorManifestListTooBig:
      return "kErrorManifestListTooBig";
    case FederatedAuthRequestResult::kErrorFetchingManifestHttpNotFound:
      return "kErrorFetchingManifestHttpNotFound";
    case FederatedAuthRequestResult::kErrorFetchingManifestNoResponse:
      return "kErrorFetchingManifestNoResponse";
    case FederatedAuthRequestResult::kErrorFetchingManifestInvalidResponse:
      return "kErrorFetchingManifestInvalidResponse";
    case FederatedAuthRequestResult::kErrorFetchingClientMetadataHttpNotFound:
      return "kErrorFetchingClientMetadataHttpNotFound";
    case FederatedAuthRequestResult::kErrorFetchingClientMetadataNoResponse:
      return "kErrorFetchingClientMetadataNoResponse";
    case FederatedAuthRequestResult::kErrorFetchingClientMetadataInvalidResponse:
      return "kErrorFetchingClientMetadataInvalidResponse";
    case FederatedAuthRequestResult::kErrorFetchingAccountsHttpNotFound:
      return "kErrorFetchingAccountsHttpNotFound";
    case FederatedAuthRequestResult::kErrorFetchingAccountsNoResponse:
      return "kErrorFetchingAccountsNoResponse";
    case FederatedAuthRequestResult::kErrorFetchingAccountsInvalidResponse:
      return "kErrorFetchingAccountsInvalidResponse";
    case FederatedAuthRequestResult::kErrorFetchingIdTokenHttpNotFound:
      return "kErrorFetchingIdTokenHttpNotFound";
    case FederatedAuthRequestResult::kErrorFetchingIdTokenNoResponse:
      return "kErrorFetchingIdTokenNoResponse";
    case FederatedAuthRequestResult::kErrorFetchingIdTokenInvalidResponse:
      return "kErrorFetchingIdTokenInvalidResponse";
    case FederatedAuthRequestResult::kErrorCanceled:
      return "kErrorCanceled";
    case FederatedAuthRequestResult::kError:
      return "kError";
    default:
      return nullptr;
  }
}

std::string FederatedAuthRequestResultToString(FederatedAuthRequestResult value) {
  const char *str = FederatedAuthRequestResultToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown FederatedAuthRequestResult value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, FederatedAuthRequestResult value) {
  return os << FederatedAuthRequestResultToString(value);
}

static NOINLINE const char* GenericIssueErrorTypeToStringHelper(GenericIssueErrorType value) {
  // Defined in a helper function to ensure that Clang generates a lookup table.
  switch(value) {
    case GenericIssueErrorType::kCrossOriginPortalPostMessageError:
      return "kCrossOriginPortalPostMessageError";
    default:
      return nullptr;
  }
}

std::string GenericIssueErrorTypeToString(GenericIssueErrorType value) {
  const char *str = GenericIssueErrorTypeToStringHelper(value);
  if (!str) {
    return base::StringPrintf("Unknown GenericIssueErrorType value: %i", static_cast<int32_t>(value));
  }
  return str;
}

std::ostream& operator<<(std::ostream& os, GenericIssueErrorType value) {
  return os << GenericIssueErrorTypeToString(value);
}

namespace internal {


// static
bool AffectedCookie_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 32, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AffectedCookie_Data* object =
      static_cast<const AffectedCookie_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->name, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->name, validation_context,
                                         &name_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->path, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams path_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->path, validation_context,
                                         &path_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->domain, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams domain_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->domain, validation_context,
                                         &domain_validate_params)) {
    return false;
  }

  return true;
}

AffectedCookie_Data::AffectedCookie_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool AffectedRequest_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AffectedRequest_Data* object =
      static_cast<const AffectedRequest_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->request_id, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams request_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->request_id, validation_context,
                                         &request_id_validate_params)) {
    return false;
  }

  const mojo::internal::ContainerValidateParams url_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->url, validation_context,
                                         &url_validate_params)) {
    return false;
  }

  return true;
}

AffectedRequest_Data::AffectedRequest_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool AffectedFrame_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AffectedFrame_Data* object =
      static_cast<const AffectedFrame_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->frame_id, 1, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams frame_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->frame_id, validation_context,
                                         &frame_id_validate_params)) {
    return false;
  }

  return true;
}

AffectedFrame_Data::AffectedFrame_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool AffectedLocation_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 32, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const AffectedLocation_Data* object =
      static_cast<const AffectedLocation_Data*>(data);

  const mojo::internal::ContainerValidateParams script_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->script_id, validation_context,
                                         &script_id_validate_params)) {
    return false;
  }

  const mojo::internal::ContainerValidateParams url_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->url, validation_context,
                                         &url_validate_params)) {
    return false;
  }

  return true;
}

AffectedLocation_Data::AffectedLocation_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool BlockedByResponseIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 40, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const BlockedByResponseIssueDetails_Data* object =
      static_cast<const BlockedByResponseIssueDetails_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->request, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->request, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->parentFrame, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->blockedFrame, validation_context))
    return false;


  if (!::network::mojom::internal::BlockedByResponseReason_Data
        ::Validate(object->reason, validation_context))
    return false;

  return true;
}

BlockedByResponseIssueDetails_Data::BlockedByResponseIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool HeavyAdIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const HeavyAdIssueDetails_Data* object =
      static_cast<const HeavyAdIssueDetails_Data*>(data);


  if (!::blink::mojom::internal::HeavyAdResolutionStatus_Data
        ::Validate(object->resolution, validation_context))
    return false;


  if (!::blink::mojom::internal::HeavyAdReason_Data
        ::Validate(object->reason, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->frame, 3, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->frame, validation_context))
    return false;

  return true;
}

HeavyAdIssueDetails_Data::HeavyAdIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool MixedContentIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const MixedContentIssueDetails_Data* object =
      static_cast<const MixedContentIssueDetails_Data*>(data);


  if (!::blink::mojom::internal::RequestContextType_Data
        ::Validate(object->request_context, validation_context))
    return false;


  if (!::blink::mojom::internal::MixedContentResolutionStatus_Data
        ::Validate(object->resolution_status, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->insecure_url, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams insecure_url_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->insecure_url, validation_context,
                                         &insecure_url_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->main_resource_url, 4, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams main_resource_url_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->main_resource_url, validation_context,
                                         &main_resource_url_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidateStruct(object->request, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->frame, validation_context))
    return false;

  return true;
}

MixedContentIssueDetails_Data::MixedContentIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool ContentSecurityPolicyIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 56, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const ContentSecurityPolicyIssueDetails_Data* object =
      static_cast<const ContentSecurityPolicyIssueDetails_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->blocked_url, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->violated_directive, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams violated_directive_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->violated_directive, validation_context,
                                         &violated_directive_validate_params)) {
    return false;
  }


  if (!::blink::mojom::internal::ContentSecurityPolicyViolationType_Data
        ::Validate(object->content_security_policy_violation_type, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->frame_ancestor, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->affected_location, validation_context))
    return false;

  return true;
}

ContentSecurityPolicyIssueDetails_Data::ContentSecurityPolicyIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool CookieIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 64, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const CookieIssueDetails_Data* object =
      static_cast<const CookieIssueDetails_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->cookie, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->cookie, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->exclusion_reason, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams exclusion_reason_validate_params(
      0, ::blink::mojom::internal::CookieExclusionReason_Data::Validate);
  if (!mojo::internal::ValidateContainer(object->exclusion_reason, validation_context,
                                         &exclusion_reason_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->warning_reason, 3, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams warning_reason_validate_params(
      0, ::blink::mojom::internal::CookieWarningReason_Data::Validate);
  if (!mojo::internal::ValidateContainer(object->warning_reason, validation_context,
                                         &warning_reason_validate_params)) {
    return false;
  }


  if (!::blink::mojom::internal::CookieOperation_Data
        ::Validate(object->operation, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->site_for_cookies, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->cookie_url, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->request, validation_context))
    return false;

  return true;
}

CookieIssueDetails_Data::CookieIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool SharedArrayBufferIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const SharedArrayBufferIssueDetails_Data* object =
      static_cast<const SharedArrayBufferIssueDetails_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->affected_location, validation_context))
    return false;


  if (!::blink::mojom::internal::SharedArrayBufferIssueType_Data
        ::Validate(object->type, validation_context))
    return false;

  return true;
}

SharedArrayBufferIssueDetails_Data::SharedArrayBufferIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool TrustedWebActivityIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 40, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const TrustedWebActivityIssueDetails_Data* object =
      static_cast<const TrustedWebActivityIssueDetails_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->url, 1, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->url, validation_context))
    return false;


  if (!::blink::mojom::internal::TwaQualityEnforcementViolationType_Data
        ::Validate(object->violation_type, validation_context))
    return false;

  const mojo::internal::ContainerValidateParams package_name_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->package_name, validation_context,
                                         &package_name_validate_params)) {
    return false;
  }

  const mojo::internal::ContainerValidateParams signature_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->signature, validation_context,
                                         &signature_validate_params)) {
    return false;
  }

  return true;
}

TrustedWebActivityIssueDetails_Data::TrustedWebActivityIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool LowTextContrastIssue_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 48, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const LowTextContrastIssue_Data* object =
      static_cast<const LowTextContrastIssue_Data*>(data);

  if (!mojo::internal::ValidatePointerNonNullable(
          object->violating_node_selector, 2, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams violating_node_selector_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->violating_node_selector, validation_context,
                                         &violating_node_selector_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->font_size, 6, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams font_size_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->font_size, validation_context,
                                         &font_size_validate_params)) {
    return false;
  }

  if (!mojo::internal::ValidatePointerNonNullable(
          object->font_weight, 7, validation_context)) {
    return false;
  }
  const mojo::internal::ContainerValidateParams font_weight_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->font_weight, validation_context,
                                         &font_weight_validate_params)) {
    return false;
  }

  return true;
}

LowTextContrastIssue_Data::LowTextContrastIssue_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool FederatedAuthRequestIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 16, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const FederatedAuthRequestIssueDetails_Data* object =
      static_cast<const FederatedAuthRequestIssueDetails_Data*>(data);


  if (!::blink::mojom::internal::FederatedAuthRequestResult_Data
        ::Validate(object->status, validation_context))
    return false;

  return true;
}

FederatedAuthRequestIssueDetails_Data::FederatedAuthRequestIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool GenericIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const GenericIssueDetails_Data* object =
      static_cast<const GenericIssueDetails_Data*>(data);


  if (!::blink::mojom::internal::GenericIssueErrorType_Data
        ::Validate(object->error_type, validation_context))
    return false;

  const mojo::internal::ContainerValidateParams frame_id_validate_params(
      0, false, nullptr);
  if (!mojo::internal::ValidateContainer(object->frame_id, validation_context,
                                         &frame_id_validate_params)) {
    return false;
  }

  return true;
}

GenericIssueDetails_Data::GenericIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool InspectorIssueDetails_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 96, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const InspectorIssueDetails_Data* object =
      static_cast<const InspectorIssueDetails_Data*>(data);

  if (!mojo::internal::ValidateStruct(object->cookie_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->mixed_content_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->blocked_by_response_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->csp_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->sab_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->twa_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->heavy_ad_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->low_text_contrast_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->federated_auth_request_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->generic_issue_details, validation_context))
    return false;

  if (!mojo::internal::ValidateStruct(object->issue_id, validation_context))
    return false;

  return true;
}

InspectorIssueDetails_Data::InspectorIssueDetails_Data()
    : header_({sizeof(*this), 0}) {}


// static
bool InspectorIssueInfo_Data::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  if (!data)
    return true;
  if (!ValidateUnversionedStructHeaderAndSizeAndClaimMemory(
          data, 24, validation_context)) {
    return false;
  }

  // NOTE: The memory backing |object| may be smaller than |sizeof(*object)| if
  // the message comes from an older version.
  [[maybe_unused]] const InspectorIssueInfo_Data* object =
      static_cast<const InspectorIssueInfo_Data*>(data);


  if (!::blink::mojom::internal::InspectorIssueCode_Data
        ::Validate(object->code, validation_context))
    return false;

  if (!mojo::internal::ValidatePointerNonNullable(
          object->details, 2, validation_context)) {
    return false;
  }
  if (!mojo::internal::ValidateStruct(object->details, validation_context))
    return false;

  return true;
}

InspectorIssueInfo_Data::InspectorIssueInfo_Data()
    : header_({sizeof(*this), 0}) {}

}  // namespace internal
}  // namespace mojom
}  // namespace blink

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::InspectorIssueCode>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::InspectorIssueCode value) {
  return std::move(context).WriteString(::blink::mojom::InspectorIssueCodeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::HeavyAdResolutionStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::HeavyAdResolutionStatus value) {
  return std::move(context).WriteString(::blink::mojom::HeavyAdResolutionStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::HeavyAdReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::HeavyAdReason value) {
  return std::move(context).WriteString(::blink::mojom::HeavyAdReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::MixedContentResolutionStatus>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::MixedContentResolutionStatus value) {
  return std::move(context).WriteString(::blink::mojom::MixedContentResolutionStatusToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::ContentSecurityPolicyViolationType>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::ContentSecurityPolicyViolationType value) {
  return std::move(context).WriteString(::blink::mojom::ContentSecurityPolicyViolationTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::CookieOperation>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::CookieOperation value) {
  return std::move(context).WriteString(::blink::mojom::CookieOperationToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::CookieExclusionReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::CookieExclusionReason value) {
  return std::move(context).WriteString(::blink::mojom::CookieExclusionReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::CookieWarningReason>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::CookieWarningReason value) {
  return std::move(context).WriteString(::blink::mojom::CookieWarningReasonToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::SharedArrayBufferIssueType>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::SharedArrayBufferIssueType value) {
  return std::move(context).WriteString(::blink::mojom::SharedArrayBufferIssueTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::TwaQualityEnforcementViolationType>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::TwaQualityEnforcementViolationType value) {
  return std::move(context).WriteString(::blink::mojom::TwaQualityEnforcementViolationTypeToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::FederatedAuthRequestResult>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::FederatedAuthRequestResult value) {
  return std::move(context).WriteString(::blink::mojom::FederatedAuthRequestResultToString(value));
}

} // namespace perfetto

namespace perfetto {

// static
void TraceFormatTraits<::blink::mojom::GenericIssueErrorType>::WriteIntoTrace(
   perfetto::TracedValue context, ::blink::mojom::GenericIssueErrorType value) {
  return std::move(context).WriteString(::blink::mojom::GenericIssueErrorTypeToString(value));
}

} // namespace perfetto