// third_party/blink/public/mojom/devtools/inspector_issue.mojom-shared-internal.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_INTERNAL_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_INTERNAL_H_
#include "mojo/public/cpp/bindings/lib/array_internal.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/map_data_internal.h"
#include "mojo/public/cpp/bindings/lib/buffer.h"
#include "url/mojom/url.mojom-shared-internal.h"
#include "services/network/public/mojom/cookie_manager.mojom-shared-internal.h"
#include "services/network/public/mojom/blocked_by_response_reason.mojom-shared-internal.h"
#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-shared-internal.h"
#include "mojo/public/mojom/base/unguessable_token.mojom-shared-internal.h"
#include "mojo/public/cpp/bindings/lib/native_enum_data.h"
#include "mojo/public/interfaces/bindings/native_struct.mojom-shared-internal.h"
#include "base/component_export.h"



namespace mojo {
namespace internal {
class ValidationContext;
}
}
namespace blink {
namespace mojom {
namespace internal {
class AffectedCookie_Data;
class AffectedRequest_Data;
class AffectedFrame_Data;
class AffectedLocation_Data;
class BlockedByResponseIssueDetails_Data;
class HeavyAdIssueDetails_Data;
class MixedContentIssueDetails_Data;
class ContentSecurityPolicyIssueDetails_Data;
class CookieIssueDetails_Data;
class SharedArrayBufferIssueDetails_Data;
class TrustedWebActivityIssueDetails_Data;
class LowTextContrastIssue_Data;
class FederatedAuthRequestIssueDetails_Data;
class GenericIssueDetails_Data;
class InspectorIssueDetails_Data;
class InspectorIssueInfo_Data;

struct InspectorIssueCode_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct HeavyAdResolutionStatus_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct HeavyAdReason_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct MixedContentResolutionStatus_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct ContentSecurityPolicyViolationType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct CookieOperation_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct CookieExclusionReason_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct CookieWarningReason_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct SharedArrayBufferIssueType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct TwaQualityEnforcementViolationType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct FederatedAuthRequestResult_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

struct GenericIssueErrorType_Data {
 public:
  static bool constexpr kIsExtensible = false;

  static bool IsKnownValue(int32_t value) {
    switch (value) {
      case 0:
        return true;
    }
    return false;
  }

  static bool Validate(int32_t value,
                       mojo::internal::ValidationContext* validation_context) {
    if (kIsExtensible || IsKnownValue(value))
      return true;

    ReportValidationError(validation_context,
                          mojo::internal::VALIDATION_ERROR_UNKNOWN_ENUM_VALUE);
    return false;
  }
};

#pragma pack(push, 1)
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) AffectedCookie_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> name;
  mojo::internal::Pointer<mojo::internal::String_Data> path;
  mojo::internal::Pointer<mojo::internal::String_Data> domain;

 private:
  friend class mojo::internal::MessageFragment<AffectedCookie_Data>;

  AffectedCookie_Data();
  ~AffectedCookie_Data() = delete;
};
static_assert(sizeof(AffectedCookie_Data) == 32,
              "Bad sizeof(AffectedCookie_Data)");
// Used by AffectedCookie::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AffectedCookie_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AffectedCookie_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AffectedCookie_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AffectedCookie_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AffectedCookie_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) AffectedRequest_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> request_id;
  mojo::internal::Pointer<mojo::internal::String_Data> url;

 private:
  friend class mojo::internal::MessageFragment<AffectedRequest_Data>;

  AffectedRequest_Data();
  ~AffectedRequest_Data() = delete;
};
static_assert(sizeof(AffectedRequest_Data) == 24,
              "Bad sizeof(AffectedRequest_Data)");
// Used by AffectedRequest::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AffectedRequest_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AffectedRequest_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AffectedRequest_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AffectedRequest_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AffectedRequest_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) AffectedFrame_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> frame_id;

 private:
  friend class mojo::internal::MessageFragment<AffectedFrame_Data>;

  AffectedFrame_Data();
  ~AffectedFrame_Data() = delete;
};
static_assert(sizeof(AffectedFrame_Data) == 16,
              "Bad sizeof(AffectedFrame_Data)");
// Used by AffectedFrame::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AffectedFrame_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AffectedFrame_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AffectedFrame_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AffectedFrame_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AffectedFrame_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) AffectedLocation_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<mojo::internal::String_Data> script_id;
  mojo::internal::Pointer<mojo::internal::String_Data> url;
  uint32_t line;
  uint32_t column;

 private:
  friend class mojo::internal::MessageFragment<AffectedLocation_Data>;

  AffectedLocation_Data();
  ~AffectedLocation_Data() = delete;
};
static_assert(sizeof(AffectedLocation_Data) == 32,
              "Bad sizeof(AffectedLocation_Data)");
// Used by AffectedLocation::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct AffectedLocation_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  AffectedLocation_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~AffectedLocation_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<AffectedLocation_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    AffectedLocation_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) BlockedByResponseIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::AffectedRequest_Data> request;
  mojo::internal::Pointer<internal::AffectedFrame_Data> parentFrame;
  mojo::internal::Pointer<internal::AffectedFrame_Data> blockedFrame;
  int32_t reason;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<BlockedByResponseIssueDetails_Data>;

  BlockedByResponseIssueDetails_Data();
  ~BlockedByResponseIssueDetails_Data() = delete;
};
static_assert(sizeof(BlockedByResponseIssueDetails_Data) == 40,
              "Bad sizeof(BlockedByResponseIssueDetails_Data)");
// Used by BlockedByResponseIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct BlockedByResponseIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  BlockedByResponseIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~BlockedByResponseIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<BlockedByResponseIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    BlockedByResponseIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) HeavyAdIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t resolution;
  int32_t reason;
  mojo::internal::Pointer<internal::AffectedFrame_Data> frame;

 private:
  friend class mojo::internal::MessageFragment<HeavyAdIssueDetails_Data>;

  HeavyAdIssueDetails_Data();
  ~HeavyAdIssueDetails_Data() = delete;
};
static_assert(sizeof(HeavyAdIssueDetails_Data) == 24,
              "Bad sizeof(HeavyAdIssueDetails_Data)");
// Used by HeavyAdIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct HeavyAdIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  HeavyAdIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~HeavyAdIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<HeavyAdIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    HeavyAdIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) MixedContentIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t request_context;
  int32_t resolution_status;
  mojo::internal::Pointer<mojo::internal::String_Data> insecure_url;
  mojo::internal::Pointer<mojo::internal::String_Data> main_resource_url;
  mojo::internal::Pointer<internal::AffectedRequest_Data> request;
  mojo::internal::Pointer<internal::AffectedFrame_Data> frame;

 private:
  friend class mojo::internal::MessageFragment<MixedContentIssueDetails_Data>;

  MixedContentIssueDetails_Data();
  ~MixedContentIssueDetails_Data() = delete;
};
static_assert(sizeof(MixedContentIssueDetails_Data) == 48,
              "Bad sizeof(MixedContentIssueDetails_Data)");
// Used by MixedContentIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct MixedContentIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  MixedContentIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~MixedContentIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<MixedContentIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    MixedContentIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) ContentSecurityPolicyIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> blocked_url;
  mojo::internal::Pointer<mojo::internal::String_Data> violated_directive;
  uint8_t is_report_only : 1;
  uint8_t pad2_[3];
  int32_t content_security_policy_violation_type;
  mojo::internal::Pointer<internal::AffectedFrame_Data> frame_ancestor;
  mojo::internal::Pointer<internal::AffectedLocation_Data> affected_location;
  int32_t violating_node_id;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<ContentSecurityPolicyIssueDetails_Data>;

  ContentSecurityPolicyIssueDetails_Data();
  ~ContentSecurityPolicyIssueDetails_Data() = delete;
};
static_assert(sizeof(ContentSecurityPolicyIssueDetails_Data) == 56,
              "Bad sizeof(ContentSecurityPolicyIssueDetails_Data)");
// Used by ContentSecurityPolicyIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct ContentSecurityPolicyIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  ContentSecurityPolicyIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~ContentSecurityPolicyIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<ContentSecurityPolicyIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    ContentSecurityPolicyIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) CookieIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::AffectedCookie_Data> cookie;
  mojo::internal::Pointer<mojo::internal::Array_Data<int32_t>> exclusion_reason;
  mojo::internal::Pointer<mojo::internal::Array_Data<int32_t>> warning_reason;
  int32_t operation;
  uint8_t pad3_[4];
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> site_for_cookies;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> cookie_url;
  mojo::internal::Pointer<internal::AffectedRequest_Data> request;

 private:
  friend class mojo::internal::MessageFragment<CookieIssueDetails_Data>;

  CookieIssueDetails_Data();
  ~CookieIssueDetails_Data() = delete;
};
static_assert(sizeof(CookieIssueDetails_Data) == 64,
              "Bad sizeof(CookieIssueDetails_Data)");
// Used by CookieIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct CookieIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  CookieIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~CookieIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<CookieIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    CookieIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) SharedArrayBufferIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::AffectedLocation_Data> affected_location;
  uint8_t is_warning : 1;
  uint8_t pad1_[3];
  int32_t type;

 private:
  friend class mojo::internal::MessageFragment<SharedArrayBufferIssueDetails_Data>;

  SharedArrayBufferIssueDetails_Data();
  ~SharedArrayBufferIssueDetails_Data() = delete;
};
static_assert(sizeof(SharedArrayBufferIssueDetails_Data) == 24,
              "Bad sizeof(SharedArrayBufferIssueDetails_Data)");
// Used by SharedArrayBufferIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct SharedArrayBufferIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  SharedArrayBufferIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~SharedArrayBufferIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<SharedArrayBufferIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    SharedArrayBufferIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) TrustedWebActivityIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<::url::mojom::internal::Url_Data> url;
  int32_t violation_type;
  int32_t http_error_code;
  mojo::internal::Pointer<mojo::internal::String_Data> package_name;
  mojo::internal::Pointer<mojo::internal::String_Data> signature;

 private:
  friend class mojo::internal::MessageFragment<TrustedWebActivityIssueDetails_Data>;

  TrustedWebActivityIssueDetails_Data();
  ~TrustedWebActivityIssueDetails_Data() = delete;
};
static_assert(sizeof(TrustedWebActivityIssueDetails_Data) == 40,
              "Bad sizeof(TrustedWebActivityIssueDetails_Data)");
// Used by TrustedWebActivityIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct TrustedWebActivityIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  TrustedWebActivityIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~TrustedWebActivityIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<TrustedWebActivityIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    TrustedWebActivityIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) LowTextContrastIssue_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t violating_node_id;
  float contrast_ratio;
  mojo::internal::Pointer<mojo::internal::String_Data> violating_node_selector;
  float threshold_aa;
  float threshold_aaa;
  mojo::internal::Pointer<mojo::internal::String_Data> font_size;
  mojo::internal::Pointer<mojo::internal::String_Data> font_weight;

 private:
  friend class mojo::internal::MessageFragment<LowTextContrastIssue_Data>;

  LowTextContrastIssue_Data();
  ~LowTextContrastIssue_Data() = delete;
};
static_assert(sizeof(LowTextContrastIssue_Data) == 48,
              "Bad sizeof(LowTextContrastIssue_Data)");
// Used by LowTextContrastIssue::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct LowTextContrastIssue_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  LowTextContrastIssue_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~LowTextContrastIssue_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<LowTextContrastIssue_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    LowTextContrastIssue_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) FederatedAuthRequestIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t status;
  uint8_t padfinal_[4];

 private:
  friend class mojo::internal::MessageFragment<FederatedAuthRequestIssueDetails_Data>;

  FederatedAuthRequestIssueDetails_Data();
  ~FederatedAuthRequestIssueDetails_Data() = delete;
};
static_assert(sizeof(FederatedAuthRequestIssueDetails_Data) == 16,
              "Bad sizeof(FederatedAuthRequestIssueDetails_Data)");
// Used by FederatedAuthRequestIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct FederatedAuthRequestIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  FederatedAuthRequestIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~FederatedAuthRequestIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<FederatedAuthRequestIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    FederatedAuthRequestIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) GenericIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t error_type;
  uint8_t pad0_[4];
  mojo::internal::Pointer<mojo::internal::String_Data> frame_id;

 private:
  friend class mojo::internal::MessageFragment<GenericIssueDetails_Data>;

  GenericIssueDetails_Data();
  ~GenericIssueDetails_Data() = delete;
};
static_assert(sizeof(GenericIssueDetails_Data) == 24,
              "Bad sizeof(GenericIssueDetails_Data)");
// Used by GenericIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct GenericIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  GenericIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~GenericIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<GenericIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    GenericIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) InspectorIssueDetails_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  mojo::internal::Pointer<internal::CookieIssueDetails_Data> cookie_issue_details;
  mojo::internal::Pointer<internal::MixedContentIssueDetails_Data> mixed_content_issue_details;
  mojo::internal::Pointer<internal::BlockedByResponseIssueDetails_Data> blocked_by_response_issue_details;
  mojo::internal::Pointer<internal::ContentSecurityPolicyIssueDetails_Data> csp_issue_details;
  mojo::internal::Pointer<internal::SharedArrayBufferIssueDetails_Data> sab_issue_details;
  mojo::internal::Pointer<internal::TrustedWebActivityIssueDetails_Data> twa_issue_details;
  mojo::internal::Pointer<internal::HeavyAdIssueDetails_Data> heavy_ad_issue_details;
  mojo::internal::Pointer<internal::LowTextContrastIssue_Data> low_text_contrast_details;
  mojo::internal::Pointer<internal::FederatedAuthRequestIssueDetails_Data> federated_auth_request_details;
  mojo::internal::Pointer<internal::GenericIssueDetails_Data> generic_issue_details;
  mojo::internal::Pointer<::mojo_base::mojom::internal::UnguessableToken_Data> issue_id;

 private:
  friend class mojo::internal::MessageFragment<InspectorIssueDetails_Data>;

  InspectorIssueDetails_Data();
  ~InspectorIssueDetails_Data() = delete;
};
static_assert(sizeof(InspectorIssueDetails_Data) == 96,
              "Bad sizeof(InspectorIssueDetails_Data)");
// Used by InspectorIssueDetails::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct InspectorIssueDetails_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  InspectorIssueDetails_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~InspectorIssueDetails_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<InspectorIssueDetails_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    InspectorIssueDetails_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};
class COMPONENT_EXPORT(MOJOM_SHARED_BLINK_COMMON_EXPORT) InspectorIssueInfo_Data {
 public:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  mojo::internal::StructHeader header_;
  int32_t code;
  uint8_t pad0_[4];
  mojo::internal::Pointer<internal::InspectorIssueDetails_Data> details;

 private:
  friend class mojo::internal::MessageFragment<InspectorIssueInfo_Data>;

  InspectorIssueInfo_Data();
  ~InspectorIssueInfo_Data() = delete;
};
static_assert(sizeof(InspectorIssueInfo_Data) == 24,
              "Bad sizeof(InspectorIssueInfo_Data)");
// Used by InspectorIssueInfo::WrapAsMessage to lazily serialize the struct.
template <typename UserType, typename DataView>
struct InspectorIssueInfo_UnserializedMessageContext
    : public mojo::internal::UnserializedMessageContext {
 public:
  static const mojo::internal::UnserializedMessageContext::Tag kMessageTag;

  InspectorIssueInfo_UnserializedMessageContext(
    uint32_t message_name,
    uint32_t message_flags,
    UserType input)
      : mojo::internal::UnserializedMessageContext(&kMessageTag, message_name, message_flags)
      , user_data_(std::move(input)) {}
  ~InspectorIssueInfo_UnserializedMessageContext() override = default;

  UserType TakeData() {
    return std::move(user_data_);
  }

 private:
  // mojo::internal::UnserializedMessageContext:
  void Serialize(mojo::Message& message) override {
    mojo::internal::MessageFragment<InspectorIssueInfo_Data> fragment(message);
    mojo::internal::Serialize<DataView>(user_data_, fragment);
  }

  UserType user_data_;
};

template <typename UserType, typename DataView>
const mojo::internal::UnserializedMessageContext::Tag
    InspectorIssueInfo_UnserializedMessageContext<UserType, DataView>::kMessageTag = {};

#pragma pack(pop)

}  // namespace internal
}  // namespace mojom
}  // namespace blink

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_DEVTOOLS_INSPECTOR_ISSUE_MOJOM_SHARED_INTERNAL_H_