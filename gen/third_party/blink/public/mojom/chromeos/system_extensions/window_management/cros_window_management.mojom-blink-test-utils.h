// third_party/blink/public/mojom/chromeos/system_extensions/window_management/cros_window_management.mojom-blink-test-utils.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2019 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CHROMEOS_SYSTEM_EXTENSIONS_WINDOW_MANAGEMENT_CROS_WINDOW_MANAGEMENT_MOJOM_BLINK_TEST_UTILS_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CHROMEOS_SYSTEM_EXTENSIONS_WINDOW_MANAGEMENT_CROS_WINDOW_MANAGEMENT_MOJOM_BLINK_TEST_UTILS_H_

#include "third_party/blink/public/mojom/chromeos/system_extensions/window_management/cros_window_management.mojom-blink.h"
#include "third_party/blink/renderer/platform/platform_export.h"


namespace blink {
namespace mojom {
namespace blink {


class PLATFORM_EXPORT CrosWindowManagementFactoryInterceptorForTesting : public CrosWindowManagementFactory {
  virtual CrosWindowManagementFactory* GetForwardingInterface() = 0;
  void Create(::mojo::PendingAssociatedReceiver<CrosWindowManagement> receiver, ::mojo::PendingAssociatedRemote<CrosWindowManagementStartObserver> observer_remote) override;
};
class PLATFORM_EXPORT CrosWindowManagementFactoryAsyncWaiter {
 public:
  explicit CrosWindowManagementFactoryAsyncWaiter(CrosWindowManagementFactory* proxy);

  CrosWindowManagementFactoryAsyncWaiter(const CrosWindowManagementFactoryAsyncWaiter&) = delete;
  CrosWindowManagementFactoryAsyncWaiter& operator=(const CrosWindowManagementFactoryAsyncWaiter&) = delete;

  ~CrosWindowManagementFactoryAsyncWaiter();

 private:
  CrosWindowManagementFactory* const proxy_;
};


class PLATFORM_EXPORT CrosWindowManagementInterceptorForTesting : public CrosWindowManagement {
  virtual CrosWindowManagement* GetForwardingInterface() = 0;
  void GetAllWindows(GetAllWindowsCallback callback) override;
  void MoveTo(const ::base::UnguessableToken& id, int32_t x, int32_t y, MoveToCallback callback) override;
  void MoveBy(const ::base::UnguessableToken& id, int32_t delta_x, int32_t delta_y, MoveByCallback callback) override;
  void ResizeTo(const ::base::UnguessableToken& id, int32_t width, int32_t height, ResizeToCallback callback) override;
  void ResizeBy(const ::base::UnguessableToken& id, int32_t delta_width, int32_t delta_height, ResizeByCallback callback) override;
  void SetFullscreen(const ::base::UnguessableToken& id, bool fullscreen, SetFullscreenCallback callback) override;
  void Maximize(const ::base::UnguessableToken& id, MaximizeCallback callback) override;
  void Minimize(const ::base::UnguessableToken& id, MinimizeCallback callback) override;
  void Focus(const ::base::UnguessableToken& id, FocusCallback callback) override;
  void Close(const ::base::UnguessableToken& id, CloseCallback callback) override;
  void GetAllScreens(GetAllScreensCallback callback) override;
};
class PLATFORM_EXPORT CrosWindowManagementAsyncWaiter {
 public:
  explicit CrosWindowManagementAsyncWaiter(CrosWindowManagement* proxy);

  CrosWindowManagementAsyncWaiter(const CrosWindowManagementAsyncWaiter&) = delete;
  CrosWindowManagementAsyncWaiter& operator=(const CrosWindowManagementAsyncWaiter&) = delete;

  ~CrosWindowManagementAsyncWaiter();
  void GetAllWindows(
      WTF::Vector<CrosWindowInfoPtr>* out_result);
  void MoveTo(
      const ::base::UnguessableToken& id, int32_t x, int32_t y, CrosWindowManagementStatus* out_value);
  void MoveBy(
      const ::base::UnguessableToken& id, int32_t delta_x, int32_t delta_y, CrosWindowManagementStatus* out_value);
  void ResizeTo(
      const ::base::UnguessableToken& id, int32_t width, int32_t height, CrosWindowManagementStatus* out_value);
  void ResizeBy(
      const ::base::UnguessableToken& id, int32_t delta_width, int32_t delta_height, CrosWindowManagementStatus* out_value);
  void SetFullscreen(
      const ::base::UnguessableToken& id, bool fullscreen, CrosWindowManagementStatus* out_value);
  void Maximize(
      const ::base::UnguessableToken& id, CrosWindowManagementStatus* out_value);
  void Minimize(
      const ::base::UnguessableToken& id, CrosWindowManagementStatus* out_value);
  void Focus(
      const ::base::UnguessableToken& id, CrosWindowManagementStatus* out_value);
  void Close(
      const ::base::UnguessableToken& id, CrosWindowManagementStatus* out_value);
  void GetAllScreens(
      WTF::Vector<CrosScreenInfoPtr>* out_screens);

 private:
  CrosWindowManagement* const proxy_;
};


class PLATFORM_EXPORT CrosWindowManagementStartObserverInterceptorForTesting : public CrosWindowManagementStartObserver {
  virtual CrosWindowManagementStartObserver* GetForwardingInterface() = 0;
  void DispatchStartEvent() override;
  void DispatchAcceleratorEvent(AcceleratorEventPtr event) override;
};
class PLATFORM_EXPORT CrosWindowManagementStartObserverAsyncWaiter {
 public:
  explicit CrosWindowManagementStartObserverAsyncWaiter(CrosWindowManagementStartObserver* proxy);

  CrosWindowManagementStartObserverAsyncWaiter(const CrosWindowManagementStartObserverAsyncWaiter&) = delete;
  CrosWindowManagementStartObserverAsyncWaiter& operator=(const CrosWindowManagementStartObserverAsyncWaiter&) = delete;

  ~CrosWindowManagementStartObserverAsyncWaiter();

 private:
  CrosWindowManagementStartObserver* const proxy_;
};




}  // namespace blink
}  // namespace mojom
}  // namespace blink

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_CHROMEOS_SYSTEM_EXTENSIONS_WINDOW_MANAGEMENT_CROS_WINDOW_MANAGEMENT_MOJOM_BLINK_TEST_UTILS_H_