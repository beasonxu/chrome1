// third_party/blink/public/mojom/conversions/attribution_data_host.mojom.cc is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#if defined(__clang__)
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunused-private-field"
#endif

#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom.h"

#include <math.h>
#include <stdint.h>
#include <utility>

#include "base/debug/alias.h"
#include "base/hash/md5_constexpr.h"
#include "base/run_loop.h"
#include "base/strings/string_number_conversions.h"
#include "base/trace_event/trace_event.h"
#include "base/trace_event/typed_macros.h"
#include "mojo/public/cpp/bindings/lib/generated_code_util.h"
#include "mojo/public/cpp/bindings/lib/message_internal.h"
#include "mojo/public/cpp/bindings/lib/send_message_helper.h"
#include "mojo/public/cpp/bindings/lib/proxy_to_responder.h"
#include "mojo/public/cpp/bindings/lib/serialization_util.h"
#include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
#include "mojo/public/cpp/bindings/lib/validate_params.h"
#include "mojo/public/cpp/bindings/lib/validation_errors.h"
#include "mojo/public/cpp/bindings/mojo_buildflags.h"
#include "mojo/public/interfaces/bindings/interface_control_messages.mojom.h"
#include "third_party/perfetto/include/perfetto/tracing/traced_value.h"

#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-params-data.h"
#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-shared-message-ids.h"

#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-import-headers.h"
#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-test-utils.h"


#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_JUMBO_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_JUMBO_H_
#endif



namespace blink {
namespace mojom {
AttributionDebugKey::AttributionDebugKey()
    : value() {}

AttributionDebugKey::AttributionDebugKey(
    uint64_t value_in)
    : value(std::move(value_in)) {}

AttributionDebugKey::~AttributionDebugKey() = default;
size_t AttributionDebugKey::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->value);
  return seed;
}

void AttributionDebugKey::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionDebugKey::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AttributionFilterData::AttributionFilterData()
    : filter_values() {}

AttributionFilterData::AttributionFilterData(
    const base::flat_map<std::string, std::vector<std::string>>& filter_values_in)
    : filter_values(std::move(filter_values_in)) {}

AttributionFilterData::~AttributionFilterData() = default;

void AttributionFilterData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filter_values"), this->filter_values,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, std::vector<std::string>>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionFilterData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AttributionAggregatableTriggerData::AttributionAggregatableTriggerData()
    : key_piece(),
      source_keys(),
      filters(),
      not_filters() {}

AttributionAggregatableTriggerData::AttributionAggregatableTriggerData(
    const ::absl::uint128& key_piece_in,
    std::vector<std::string> source_keys_in,
    AttributionFilterDataPtr filters_in,
    AttributionFilterDataPtr not_filters_in)
    : key_piece(std::move(key_piece_in)),
      source_keys(std::move(source_keys_in)),
      filters(std::move(filters_in)),
      not_filters(std::move(not_filters_in)) {}

AttributionAggregatableTriggerData::~AttributionAggregatableTriggerData() = default;

void AttributionAggregatableTriggerData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "key_piece"), this->key_piece,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::absl::uint128&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_keys"), this->source_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const std::vector<std::string>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filters"), this->filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "not_filters"), this->not_filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionAggregatableTriggerData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AttributionSourceData::AttributionSourceData()
    : destination(),
      reporting_origin(),
      source_event_id(0ULL),
      expiry(),
      priority(0),
      debug_key(),
      filter_data(),
      aggregation_keys() {}

AttributionSourceData::AttributionSourceData(
    const ::url::Origin& destination_in,
    const ::url::Origin& reporting_origin_in,
    uint64_t source_event_id_in,
    absl::optional<::base::TimeDelta> expiry_in,
    int64_t priority_in,
    AttributionDebugKeyPtr debug_key_in,
    AttributionFilterDataPtr filter_data_in,
    const base::flat_map<std::string, ::absl::uint128>& aggregation_keys_in)
    : destination(std::move(destination_in)),
      reporting_origin(std::move(reporting_origin_in)),
      source_event_id(std::move(source_event_id_in)),
      expiry(std::move(expiry_in)),
      priority(std::move(priority_in)),
      debug_key(std::move(debug_key_in)),
      filter_data(std::move(filter_data_in)),
      aggregation_keys(std::move(aggregation_keys_in)) {}

AttributionSourceData::~AttributionSourceData() = default;

void AttributionSourceData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "destination"), this->destination,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_origin"), this->reporting_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "source_event_id"), this->source_event_id,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "expiry"), this->expiry,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type absl::optional<::base::TimeDelta>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "priority"), this->priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "debug_key"), this->debug_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionDebugKeyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filter_data"), this->filter_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregation_keys"), this->aggregation_keys,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, ::absl::uint128>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionSourceData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AttributionTriggerDedupKey::AttributionTriggerDedupKey()
    : value() {}

AttributionTriggerDedupKey::AttributionTriggerDedupKey(
    uint64_t value_in)
    : value(std::move(value_in)) {}

AttributionTriggerDedupKey::~AttributionTriggerDedupKey() = default;
size_t AttributionTriggerDedupKey::Hash(size_t seed) const {
  seed = mojo::internal::Hash(seed, this->value);
  return seed;
}

void AttributionTriggerDedupKey::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "value"), this->value,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionTriggerDedupKey::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
EventTriggerData::EventTriggerData()
    : data(0ULL),
      priority(0),
      dedup_key(),
      filters(),
      not_filters() {}

EventTriggerData::EventTriggerData(
    uint64_t data_in,
    int64_t priority_in,
    AttributionTriggerDedupKeyPtr dedup_key_in,
    AttributionFilterDataPtr filters_in,
    AttributionFilterDataPtr not_filters_in)
    : data(std::move(data_in)),
      priority(std::move(priority_in)),
      dedup_key(std::move(dedup_key_in)),
      filters(std::move(filters_in)),
      not_filters(std::move(not_filters_in)) {}

EventTriggerData::~EventTriggerData() = default;

void EventTriggerData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "data"), this->data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type uint64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "priority"), this->priority,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type int64_t>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "dedup_key"), this->dedup_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionTriggerDedupKeyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filters"), this->filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "not_filters"), this->not_filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool EventTriggerData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
AttributionTriggerData::AttributionTriggerData()
    : reporting_origin(),
      event_triggers(),
      filters(),
      not_filters(),
      aggregatable_trigger_data(),
      aggregatable_values(),
      debug_key() {}

AttributionTriggerData::AttributionTriggerData(
    const ::url::Origin& reporting_origin_in,
    std::vector<EventTriggerDataPtr> event_triggers_in,
    AttributionFilterDataPtr filters_in,
    AttributionFilterDataPtr not_filters_in,
    std::vector<AttributionAggregatableTriggerDataPtr> aggregatable_trigger_data_in,
    const base::flat_map<std::string, uint32_t>& aggregatable_values_in,
    AttributionDebugKeyPtr debug_key_in)
    : reporting_origin(std::move(reporting_origin_in)),
      event_triggers(std::move(event_triggers_in)),
      filters(std::move(filters_in)),
      not_filters(std::move(not_filters_in)),
      aggregatable_trigger_data(std::move(aggregatable_trigger_data_in)),
      aggregatable_values(std::move(aggregatable_values_in)),
      debug_key(std::move(debug_key_in)) {}

AttributionTriggerData::~AttributionTriggerData() = default;

void AttributionTriggerData::WriteIntoTrace(
    perfetto::TracedValue traced_context) const {
  [[maybe_unused]] auto dict = std::move(traced_context).WriteDictionary();
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "reporting_origin"), this->reporting_origin,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const ::url::Origin&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "event_triggers"), this->event_triggers,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<EventTriggerDataPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "filters"), this->filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "not_filters"), this->not_filters,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionFilterDataPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregatable_trigger_data"), this->aggregatable_trigger_data,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type std::vector<AttributionAggregatableTriggerDataPtr>>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "aggregatable_values"), this->aggregatable_values,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type const base::flat_map<std::string, uint32_t>&>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
  perfetto::WriteIntoTracedValueWithFallback(
    dict.AddItem(
      "debug_key"), this->debug_key,
#if BUILDFLAG(MOJO_TRACE_ENABLED)
      "<value of type AttributionDebugKeyPtr>"
#else
      "<value>"
#endif  // BUILDFLAG(MOJO_TRACE_ENABLED)
    );
}

bool AttributionTriggerData::Validate(
    const void* data,
    mojo::internal::ValidationContext* validation_context) {
  return Data_::Validate(data, validation_context);
}
const char AttributionDataHost::Name_[] = "blink.mojom.AttributionDataHost";

AttributionDataHost::IPCStableHashFunction AttributionDataHost::MessageToMethodInfo_(mojo::Message& message) {
#if !BUILDFLAG(IS_FUCHSIA)
  switch (message.name()) {
    case internal::kAttributionDataHost_SourceDataAvailable_Name: {
      return &AttributionDataHost::SourceDataAvailable_Sym::IPCStableHash;
    }
    case internal::kAttributionDataHost_TriggerDataAvailable_Name: {
      return &AttributionDataHost::TriggerDataAvailable_Sym::IPCStableHash;
    }
  }
#endif  // !BUILDFLAG(IS_FUCHSIA)
  return nullptr;
}


const char* AttributionDataHost::MessageToMethodName_(mojo::Message& message) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (!is_response) {
    switch (message.name()) {
      case internal::kAttributionDataHost_SourceDataAvailable_Name:
            return "Receive blink::mojom::AttributionDataHost::SourceDataAvailable";
      case internal::kAttributionDataHost_TriggerDataAvailable_Name:
            return "Receive blink::mojom::AttributionDataHost::TriggerDataAvailable";
    }
  } else {
    switch (message.name()) {
      case internal::kAttributionDataHost_SourceDataAvailable_Name:
            return "Receive reply blink::mojom::AttributionDataHost::SourceDataAvailable";
      case internal::kAttributionDataHost_TriggerDataAvailable_Name:
            return "Receive reply blink::mojom::AttributionDataHost::TriggerDataAvailable";
    }
  }
  return "Receive unknown mojo message";
#else
  bool is_response = message.has_flag(mojo::Message::kFlagIsResponse);
  if (is_response) {
    return "Receive mojo reply";
  } else {
    return "Receive mojo message";
  }
#endif // BUILDFLAG(MOJO_TRACE_ENABLED)
}

#if !BUILDFLAG(IS_FUCHSIA)
uint32_t AttributionDataHost::SourceDataAvailable_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::AttributionDataHost::SourceDataAvailable");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
uint32_t AttributionDataHost::TriggerDataAvailable_Sym::IPCStableHash() {
  // This method's address is used for indetifiying the mojo method name after
  // symbolization. So each IPCStableHash should have a unique address.
  // We cannot use NO_CODE_FOLDING() here - it relies on the uniqueness of
  // __LINE__ value, which is not unique accross different mojo modules.
  // The code below is very similar to NO_CODE_FOLDING, but it uses a unique
  // hash instead of __LINE__.
  constexpr uint32_t kHash = base::MD5Hash32Constexpr(
          "(Impl)blink::mojom::AttributionDataHost::TriggerDataAvailable");
  const uint32_t hash = kHash;
  base::debug::Alias(&hash);
  return hash;
}
# endif // !BUILDFLAG(IS_FUCHSIA)

AttributionDataHostProxy::AttributionDataHostProxy(mojo::MessageReceiverWithResponder* receiver)
    : receiver_(receiver) {
}

void AttributionDataHostProxy::SourceDataAvailable(
    AttributionSourceDataPtr in_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::AttributionDataHost::SourceDataAvailable", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type AttributionSourceDataPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAttributionDataHost_SourceDataAvailable_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::AttributionDataHost_SourceDataAvailable_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType> data_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AttributionSourceDataDataView>(
      in_data, data_fragment);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in AttributionDataHost.SourceDataAvailable request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AttributionDataHost::Name_);
  message.set_method_name("SourceDataAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

void AttributionDataHostProxy::TriggerDataAvailable(
    AttributionTriggerDataPtr in_data) {
#if BUILDFLAG(MOJO_TRACE_ENABLED)
  TRACE_EVENT1(
    "mojom", "Send blink::mojom::AttributionDataHost::TriggerDataAvailable", "input_parameters",
    [&](perfetto::TracedValue context){
      auto dict = std::move(context).WriteDictionary();
      perfetto::WriteIntoTracedValueWithFallback(
           dict.AddItem("data"), in_data,
                        "<value of type AttributionTriggerDataPtr>");
   });
#endif
  const bool kExpectsResponse = false;
  const bool kIsSync = false;
  const bool kAllowInterrupt = true;
  
  const uint32_t kFlags =
      ((kExpectsResponse) ? mojo::Message::kFlagExpectsResponse : 0) |
      ((kIsSync) ? mojo::Message::kFlagIsSync : 0) |
      ((kAllowInterrupt) ? 0 : mojo::Message::kFlagNoInterrupt);
  
  mojo::Message message(
      internal::kAttributionDataHost_TriggerDataAvailable_Name, kFlags, 0, 0, nullptr);
  mojo::internal::MessageFragment<
      ::blink::mojom::internal::AttributionDataHost_TriggerDataAvailable_Params_Data> params(
          message);
  params.Allocate();
  mojo::internal::MessageFragment<
      typename decltype(params->data)::BaseType> data_fragment(
          params.message());
  mojo::internal::Serialize<::blink::mojom::AttributionTriggerDataDataView>(
      in_data, data_fragment);
  params->data.Set(
      data_fragment.is_null() ? nullptr : data_fragment.data());
  MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
      params->data.is_null(),
      mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
      "null data in AttributionDataHost.TriggerDataAvailable request");

#if defined(ENABLE_IPC_FUZZER)
  message.set_interface_name(AttributionDataHost::Name_);
  message.set_method_name("TriggerDataAvailable");
#endif
  // This return value may be ignored as false implies the Connector has
  // encountered an error, which will be visible through other means.
  ::mojo::internal::SendMojoMessage(*receiver_, message);
}

// static
bool AttributionDataHostStubDispatch::Accept(
    AttributionDataHost* impl,
    mojo::Message* message) {
  switch (message->header()->name) {
    case internal::kAttributionDataHost_SourceDataAvailable_Name: {

      DCHECK(message->is_serialized());
      internal::AttributionDataHost_SourceDataAvailable_Params_Data* params =
          reinterpret_cast<internal::AttributionDataHost_SourceDataAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AttributionSourceDataPtr p_data{};
      AttributionDataHost_SourceDataAvailable_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AttributionDataHost::Name_, 0, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->SourceDataAvailable(
std::move(p_data));
      return true;
    }
    case internal::kAttributionDataHost_TriggerDataAvailable_Name: {

      DCHECK(message->is_serialized());
      internal::AttributionDataHost_TriggerDataAvailable_Params_Data* params =
          reinterpret_cast<internal::AttributionDataHost_TriggerDataAvailable_Params_Data*>(
              message->mutable_payload());
      
      bool success = true;
      AttributionTriggerDataPtr p_data{};
      AttributionDataHost_TriggerDataAvailable_ParamsDataView input_data_view(params, message);
      
      if (success && !input_data_view.ReadData(&p_data))
        success = false;
      if (!success) {
        ReportValidationErrorForMessage(
            message,
            mojo::internal::VALIDATION_ERROR_DESERIALIZATION_FAILED,
            AttributionDataHost::Name_, 1, false);
        return false;
      }
      // A null |impl| means no implementation was bound.
      DCHECK(impl);
      impl->TriggerDataAvailable(
std::move(p_data));
      return true;
    }
  }
  return false;
}

// static
bool AttributionDataHostStubDispatch::AcceptWithResponder(
    AttributionDataHost* impl,
    mojo::Message* message,
    std::unique_ptr<mojo::MessageReceiverWithStatus> responder) {
  [[maybe_unused]] const bool message_is_sync =
      message->has_flag(mojo::Message::kFlagIsSync);
  [[maybe_unused]] const uint64_t request_id = message->request_id();
  switch (message->header()->name) {
    case internal::kAttributionDataHost_SourceDataAvailable_Name: {
      break;
    }
    case internal::kAttributionDataHost_TriggerDataAvailable_Name: {
      break;
    }
  }
  return false;
}


static const mojo::internal::GenericValidationInfo kAttributionDataHostValidationInfo[] = {
    {&internal::AttributionDataHost_SourceDataAvailable_Params_Data::Validate,
     nullptr /* no response */},
    {&internal::AttributionDataHost_TriggerDataAvailable_Params_Data::Validate,
     nullptr /* no response */},
};

bool AttributionDataHostRequestValidator::Accept(mojo::Message* message) {
  const char* name = ::blink::mojom::AttributionDataHost::Name_;
  return mojo::internal::ValidateRequestGenericPacked(message, name, kAttributionDataHostValidationInfo);
}



}  // namespace mojom
}  // namespace blink


namespace mojo {


// static
bool StructTraits<::blink::mojom::AttributionDebugKey::DataView, ::blink::mojom::AttributionDebugKeyPtr>::Read(
    ::blink::mojom::AttributionDebugKey::DataView input,
    ::blink::mojom::AttributionDebugKeyPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionDebugKeyPtr result(::blink::mojom::AttributionDebugKey::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AttributionFilterData::DataView, ::blink::mojom::AttributionFilterDataPtr>::Read(
    ::blink::mojom::AttributionFilterData::DataView input,
    ::blink::mojom::AttributionFilterDataPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionFilterDataPtr result(::blink::mojom::AttributionFilterData::New());
  
      if (success && !input.ReadFilterValues(&result->filter_values))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AttributionAggregatableTriggerData::DataView, ::blink::mojom::AttributionAggregatableTriggerDataPtr>::Read(
    ::blink::mojom::AttributionAggregatableTriggerData::DataView input,
    ::blink::mojom::AttributionAggregatableTriggerDataPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionAggregatableTriggerDataPtr result(::blink::mojom::AttributionAggregatableTriggerData::New());
  
      if (success && !input.ReadKeyPiece(&result->key_piece))
        success = false;
      if (success && !input.ReadSourceKeys(&result->source_keys))
        success = false;
      if (success && !input.ReadFilters(&result->filters))
        success = false;
      if (success && !input.ReadNotFilters(&result->not_filters))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AttributionSourceData::DataView, ::blink::mojom::AttributionSourceDataPtr>::Read(
    ::blink::mojom::AttributionSourceData::DataView input,
    ::blink::mojom::AttributionSourceDataPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionSourceDataPtr result(::blink::mojom::AttributionSourceData::New());
  
      if (success && !input.ReadDestination(&result->destination))
        success = false;
      if (success && !input.ReadReportingOrigin(&result->reporting_origin))
        success = false;
      if (success)
        result->source_event_id = input.source_event_id();
      if (success && !input.ReadExpiry(&result->expiry))
        success = false;
      if (success)
        result->priority = input.priority();
      if (success && !input.ReadDebugKey(&result->debug_key))
        success = false;
      if (success && !input.ReadFilterData(&result->filter_data))
        success = false;
      if (success && !input.ReadAggregationKeys(&result->aggregation_keys))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AttributionTriggerDedupKey::DataView, ::blink::mojom::AttributionTriggerDedupKeyPtr>::Read(
    ::blink::mojom::AttributionTriggerDedupKey::DataView input,
    ::blink::mojom::AttributionTriggerDedupKeyPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionTriggerDedupKeyPtr result(::blink::mojom::AttributionTriggerDedupKey::New());
  
      if (success)
        result->value = input.value();
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::EventTriggerData::DataView, ::blink::mojom::EventTriggerDataPtr>::Read(
    ::blink::mojom::EventTriggerData::DataView input,
    ::blink::mojom::EventTriggerDataPtr* output) {
  bool success = true;
  ::blink::mojom::EventTriggerDataPtr result(::blink::mojom::EventTriggerData::New());
  
      if (success)
        result->data = input.data();
      if (success)
        result->priority = input.priority();
      if (success && !input.ReadDedupKey(&result->dedup_key))
        success = false;
      if (success && !input.ReadFilters(&result->filters))
        success = false;
      if (success && !input.ReadNotFilters(&result->not_filters))
        success = false;
  *output = std::move(result);
  return success;
}


// static
bool StructTraits<::blink::mojom::AttributionTriggerData::DataView, ::blink::mojom::AttributionTriggerDataPtr>::Read(
    ::blink::mojom::AttributionTriggerData::DataView input,
    ::blink::mojom::AttributionTriggerDataPtr* output) {
  bool success = true;
  ::blink::mojom::AttributionTriggerDataPtr result(::blink::mojom::AttributionTriggerData::New());
  
      if (success && !input.ReadReportingOrigin(&result->reporting_origin))
        success = false;
      if (success && !input.ReadEventTriggers(&result->event_triggers))
        success = false;
      if (success && !input.ReadFilters(&result->filters))
        success = false;
      if (success && !input.ReadNotFilters(&result->not_filters))
        success = false;
      if (success && !input.ReadAggregatableTriggerData(&result->aggregatable_trigger_data))
        success = false;
      if (success && !input.ReadAggregatableValues(&result->aggregatable_values))
        success = false;
      if (success && !input.ReadDebugKey(&result->debug_key))
        success = false;
  *output = std::move(result);
  return success;
}

}  // namespace mojo


// Symbols declared in the -test-utils.h header are defined here instead of a
// separate .cc file to save compile time.


namespace blink {
namespace mojom {


void AttributionDataHostInterceptorForTesting::SourceDataAvailable(AttributionSourceDataPtr data) {
  GetForwardingInterface()->SourceDataAvailable(std::move(data));
}
void AttributionDataHostInterceptorForTesting::TriggerDataAvailable(AttributionTriggerDataPtr data) {
  GetForwardingInterface()->TriggerDataAvailable(std::move(data));
}
AttributionDataHostAsyncWaiter::AttributionDataHostAsyncWaiter(
    AttributionDataHost* proxy) : proxy_(proxy) {}

AttributionDataHostAsyncWaiter::~AttributionDataHostAsyncWaiter() = default;






}  // namespace mojom
}  // namespace blink


#if defined(__clang__)
#pragma clang diagnostic pop
#endif