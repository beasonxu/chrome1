// third_party/blink/public/mojom/conversions/attribution_data_host.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_H_
#define THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-shared.h"
#include "third_party/blink/public/mojom/conversions/attribution_data_host.mojom-forward.h"
#include "mojo/public/mojom/base/int128.mojom.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "url/mojom/origin.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "third_party/blink/public/common/common_export.h"




namespace blink {
namespace mojom {

class AttributionDataHostProxy;

template <typename ImplRefTraits>
class AttributionDataHostStub;

class AttributionDataHostRequestValidator;


class BLINK_COMMON_EXPORT AttributionDataHost
    : public AttributionDataHostInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = AttributionDataHostInterfaceBase;
  using Proxy_ = AttributionDataHostProxy;

  template <typename ImplRefTraits>
  using Stub_ = AttributionDataHostStub<ImplRefTraits>;

  using RequestValidator_ = AttributionDataHostRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kSourceDataAvailableMinVersion = 0,
    kTriggerDataAvailableMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct SourceDataAvailable_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct TriggerDataAvailable_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~AttributionDataHost() = default;

  
  virtual void SourceDataAvailable(AttributionSourceDataPtr data) = 0;

  
  virtual void TriggerDataAvailable(AttributionTriggerDataPtr data) = 0;
};



class BLINK_COMMON_EXPORT AttributionDataHostProxy
    : public AttributionDataHost {
 public:
  using InterfaceType = AttributionDataHost;

  explicit AttributionDataHostProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void SourceDataAvailable(AttributionSourceDataPtr data) final;
  
  void TriggerDataAvailable(AttributionTriggerDataPtr data) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class BLINK_COMMON_EXPORT AttributionDataHostStubDispatch {
 public:
  static bool Accept(AttributionDataHost* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      AttributionDataHost* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<AttributionDataHost>>
class AttributionDataHostStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  AttributionDataHostStub() = default;
  ~AttributionDataHostStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AttributionDataHostStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return AttributionDataHostStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class BLINK_COMMON_EXPORT AttributionDataHostRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





class BLINK_COMMON_EXPORT AttributionDebugKey {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AttributionDebugKey, T>::value>;
  using DataView = AttributionDebugKeyDataView;
  using Data_ = internal::AttributionDebugKey_Data;

  template <typename... Args>
  static AttributionDebugKeyPtr New(Args&&... args) {
    return AttributionDebugKeyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AttributionDebugKeyPtr From(const U& u) {
    return mojo::TypeConverter<AttributionDebugKeyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AttributionDebugKey>::Convert(*this);
  }


  AttributionDebugKey();

  explicit AttributionDebugKey(
      uint64_t value);


  ~AttributionDebugKey();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AttributionDebugKeyPtr>
  AttributionDebugKeyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AttributionDebugKey::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AttributionDebugKey::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AttributionDebugKey::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AttributionDebugKey::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AttributionDebugKey_UnserializedMessageContext<
            UserType, AttributionDebugKey::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AttributionDebugKey::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AttributionDebugKey::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AttributionDebugKey_UnserializedMessageContext<
            UserType, AttributionDebugKey::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AttributionDebugKey::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionDebugKey::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionDebugKey::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AttributionDebugKey::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AttributionDebugKey::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}








class BLINK_COMMON_EXPORT AttributionTriggerDedupKey {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AttributionTriggerDedupKey, T>::value>;
  using DataView = AttributionTriggerDedupKeyDataView;
  using Data_ = internal::AttributionTriggerDedupKey_Data;

  template <typename... Args>
  static AttributionTriggerDedupKeyPtr New(Args&&... args) {
    return AttributionTriggerDedupKeyPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AttributionTriggerDedupKeyPtr From(const U& u) {
    return mojo::TypeConverter<AttributionTriggerDedupKeyPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AttributionTriggerDedupKey>::Convert(*this);
  }


  AttributionTriggerDedupKey();

  explicit AttributionTriggerDedupKey(
      uint64_t value);


  ~AttributionTriggerDedupKey();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AttributionTriggerDedupKeyPtr>
  AttributionTriggerDedupKeyPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AttributionTriggerDedupKey::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AttributionTriggerDedupKey::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AttributionTriggerDedupKey_UnserializedMessageContext<
            UserType, AttributionTriggerDedupKey::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AttributionTriggerDedupKey::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AttributionTriggerDedupKey::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AttributionTriggerDedupKey_UnserializedMessageContext<
            UserType, AttributionTriggerDedupKey::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AttributionTriggerDedupKey::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t value;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}










class BLINK_COMMON_EXPORT AttributionFilterData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AttributionFilterData, T>::value>;
  using DataView = AttributionFilterDataDataView;
  using Data_ = internal::AttributionFilterData_Data;

  template <typename... Args>
  static AttributionFilterDataPtr New(Args&&... args) {
    return AttributionFilterDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AttributionFilterDataPtr From(const U& u) {
    return mojo::TypeConverter<AttributionFilterDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AttributionFilterData>::Convert(*this);
  }


  AttributionFilterData();

  explicit AttributionFilterData(
      const base::flat_map<std::string, std::vector<std::string>>& filter_values);


  ~AttributionFilterData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AttributionFilterDataPtr>
  AttributionFilterDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AttributionFilterData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AttributionFilterData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AttributionFilterData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AttributionFilterData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AttributionFilterData_UnserializedMessageContext<
            UserType, AttributionFilterData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AttributionFilterData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AttributionFilterData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AttributionFilterData_UnserializedMessageContext<
            UserType, AttributionFilterData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AttributionFilterData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  base::flat_map<std::string, std::vector<std::string>> filter_values;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionFilterData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionFilterData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AttributionFilterData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AttributionFilterData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_COMMON_EXPORT AttributionAggregatableTriggerData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AttributionAggregatableTriggerData, T>::value>;
  using DataView = AttributionAggregatableTriggerDataDataView;
  using Data_ = internal::AttributionAggregatableTriggerData_Data;

  template <typename... Args>
  static AttributionAggregatableTriggerDataPtr New(Args&&... args) {
    return AttributionAggregatableTriggerDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AttributionAggregatableTriggerDataPtr From(const U& u) {
    return mojo::TypeConverter<AttributionAggregatableTriggerDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AttributionAggregatableTriggerData>::Convert(*this);
  }


  AttributionAggregatableTriggerData();

  AttributionAggregatableTriggerData(
      const ::absl::uint128& key_piece,
      std::vector<std::string> source_keys,
      AttributionFilterDataPtr filters,
      AttributionFilterDataPtr not_filters);

AttributionAggregatableTriggerData(const AttributionAggregatableTriggerData&) = delete;
AttributionAggregatableTriggerData& operator=(const AttributionAggregatableTriggerData&) = delete;

  ~AttributionAggregatableTriggerData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AttributionAggregatableTriggerDataPtr>
  AttributionAggregatableTriggerDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AttributionAggregatableTriggerData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AttributionAggregatableTriggerData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AttributionAggregatableTriggerData_UnserializedMessageContext<
            UserType, AttributionAggregatableTriggerData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AttributionAggregatableTriggerData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AttributionAggregatableTriggerData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AttributionAggregatableTriggerData_UnserializedMessageContext<
            UserType, AttributionAggregatableTriggerData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AttributionAggregatableTriggerData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::absl::uint128 key_piece;
  
  std::vector<std::string> source_keys;
  
  AttributionFilterDataPtr filters;
  
  AttributionFilterDataPtr not_filters;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_COMMON_EXPORT AttributionSourceData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AttributionSourceData, T>::value>;
  using DataView = AttributionSourceDataDataView;
  using Data_ = internal::AttributionSourceData_Data;

  template <typename... Args>
  static AttributionSourceDataPtr New(Args&&... args) {
    return AttributionSourceDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AttributionSourceDataPtr From(const U& u) {
    return mojo::TypeConverter<AttributionSourceDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AttributionSourceData>::Convert(*this);
  }


  AttributionSourceData();

  AttributionSourceData(
      const ::url::Origin& destination,
      const ::url::Origin& reporting_origin,
      uint64_t source_event_id,
      absl::optional<::base::TimeDelta> expiry,
      int64_t priority,
      AttributionDebugKeyPtr debug_key,
      AttributionFilterDataPtr filter_data,
      const base::flat_map<std::string, ::absl::uint128>& aggregation_keys);

AttributionSourceData(const AttributionSourceData&) = delete;
AttributionSourceData& operator=(const AttributionSourceData&) = delete;

  ~AttributionSourceData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AttributionSourceDataPtr>
  AttributionSourceDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AttributionSourceData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AttributionSourceData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AttributionSourceData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AttributionSourceData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AttributionSourceData_UnserializedMessageContext<
            UserType, AttributionSourceData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AttributionSourceData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AttributionSourceData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AttributionSourceData_UnserializedMessageContext<
            UserType, AttributionSourceData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AttributionSourceData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::url::Origin destination;
  
  ::url::Origin reporting_origin;
  
  uint64_t source_event_id;
  
  absl::optional<::base::TimeDelta> expiry;
  
  int64_t priority;
  
  AttributionDebugKeyPtr debug_key;
  
  AttributionFilterDataPtr filter_data;
  
  base::flat_map<std::string, ::absl::uint128> aggregation_keys;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionSourceData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionSourceData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AttributionSourceData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AttributionSourceData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class BLINK_COMMON_EXPORT EventTriggerData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<EventTriggerData, T>::value>;
  using DataView = EventTriggerDataDataView;
  using Data_ = internal::EventTriggerData_Data;

  template <typename... Args>
  static EventTriggerDataPtr New(Args&&... args) {
    return EventTriggerDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static EventTriggerDataPtr From(const U& u) {
    return mojo::TypeConverter<EventTriggerDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, EventTriggerData>::Convert(*this);
  }


  EventTriggerData();

  EventTriggerData(
      uint64_t data,
      int64_t priority,
      AttributionTriggerDedupKeyPtr dedup_key,
      AttributionFilterDataPtr filters,
      AttributionFilterDataPtr not_filters);

EventTriggerData(const EventTriggerData&) = delete;
EventTriggerData& operator=(const EventTriggerData&) = delete;

  ~EventTriggerData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = EventTriggerDataPtr>
  EventTriggerDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, EventTriggerData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, EventTriggerData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        EventTriggerData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        EventTriggerData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::EventTriggerData_UnserializedMessageContext<
            UserType, EventTriggerData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<EventTriggerData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return EventTriggerData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::EventTriggerData_UnserializedMessageContext<
            UserType, EventTriggerData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<EventTriggerData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t data;
  
  int64_t priority;
  
  AttributionTriggerDedupKeyPtr dedup_key;
  
  AttributionFilterDataPtr filters;
  
  AttributionFilterDataPtr not_filters;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, EventTriggerData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, EventTriggerData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, EventTriggerData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, EventTriggerData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class BLINK_COMMON_EXPORT AttributionTriggerData {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AttributionTriggerData, T>::value>;
  using DataView = AttributionTriggerDataDataView;
  using Data_ = internal::AttributionTriggerData_Data;

  template <typename... Args>
  static AttributionTriggerDataPtr New(Args&&... args) {
    return AttributionTriggerDataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AttributionTriggerDataPtr From(const U& u) {
    return mojo::TypeConverter<AttributionTriggerDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AttributionTriggerData>::Convert(*this);
  }


  AttributionTriggerData();

  AttributionTriggerData(
      const ::url::Origin& reporting_origin,
      std::vector<EventTriggerDataPtr> event_triggers,
      AttributionFilterDataPtr filters,
      AttributionFilterDataPtr not_filters,
      std::vector<AttributionAggregatableTriggerDataPtr> aggregatable_trigger_data,
      const base::flat_map<std::string, uint32_t>& aggregatable_values,
      AttributionDebugKeyPtr debug_key);

AttributionTriggerData(const AttributionTriggerData&) = delete;
AttributionTriggerData& operator=(const AttributionTriggerData&) = delete;

  ~AttributionTriggerData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AttributionTriggerDataPtr>
  AttributionTriggerDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AttributionTriggerData::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AttributionTriggerData::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AttributionTriggerData::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AttributionTriggerData::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AttributionTriggerData_UnserializedMessageContext<
            UserType, AttributionTriggerData::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AttributionTriggerData::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AttributionTriggerData::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AttributionTriggerData_UnserializedMessageContext<
            UserType, AttributionTriggerData::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AttributionTriggerData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::url::Origin reporting_origin;
  
  std::vector<EventTriggerDataPtr> event_triggers;
  
  AttributionFilterDataPtr filters;
  
  AttributionFilterDataPtr not_filters;
  
  std::vector<AttributionAggregatableTriggerDataPtr> aggregatable_trigger_data;
  
  base::flat_map<std::string, uint32_t> aggregatable_values;
  
  AttributionDebugKeyPtr debug_key;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AttributionTriggerData::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AttributionTriggerData::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AttributionTriggerData::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AttributionTriggerData::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
AttributionDebugKeyPtr AttributionDebugKey::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, AttributionDebugKey::EnableIfSame<T>*>
bool AttributionDebugKey::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, AttributionDebugKey::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
AttributionFilterDataPtr AttributionFilterData::Clone() const {
  return New(
      mojo::Clone(filter_values)
  );
}

template <typename T, AttributionFilterData::EnableIfSame<T>*>
bool AttributionFilterData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->filter_values, other_struct.filter_values))
    return false;
  return true;
}

template <typename T, AttributionFilterData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.filter_values < rhs.filter_values)
    return true;
  if (rhs.filter_values < lhs.filter_values)
    return false;
  return false;
}
template <typename StructPtrType>
AttributionAggregatableTriggerDataPtr AttributionAggregatableTriggerData::Clone() const {
  return New(
      mojo::Clone(key_piece),
      mojo::Clone(source_keys),
      mojo::Clone(filters),
      mojo::Clone(not_filters)
  );
}

template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>*>
bool AttributionAggregatableTriggerData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->key_piece, other_struct.key_piece))
    return false;
  if (!mojo::Equals(this->source_keys, other_struct.source_keys))
    return false;
  if (!mojo::Equals(this->filters, other_struct.filters))
    return false;
  if (!mojo::Equals(this->not_filters, other_struct.not_filters))
    return false;
  return true;
}

template <typename T, AttributionAggregatableTriggerData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.key_piece < rhs.key_piece)
    return true;
  if (rhs.key_piece < lhs.key_piece)
    return false;
  if (lhs.source_keys < rhs.source_keys)
    return true;
  if (rhs.source_keys < lhs.source_keys)
    return false;
  if (lhs.filters < rhs.filters)
    return true;
  if (rhs.filters < lhs.filters)
    return false;
  if (lhs.not_filters < rhs.not_filters)
    return true;
  if (rhs.not_filters < lhs.not_filters)
    return false;
  return false;
}
template <typename StructPtrType>
AttributionSourceDataPtr AttributionSourceData::Clone() const {
  return New(
      mojo::Clone(destination),
      mojo::Clone(reporting_origin),
      mojo::Clone(source_event_id),
      mojo::Clone(expiry),
      mojo::Clone(priority),
      mojo::Clone(debug_key),
      mojo::Clone(filter_data),
      mojo::Clone(aggregation_keys)
  );
}

template <typename T, AttributionSourceData::EnableIfSame<T>*>
bool AttributionSourceData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->destination, other_struct.destination))
    return false;
  if (!mojo::Equals(this->reporting_origin, other_struct.reporting_origin))
    return false;
  if (!mojo::Equals(this->source_event_id, other_struct.source_event_id))
    return false;
  if (!mojo::Equals(this->expiry, other_struct.expiry))
    return false;
  if (!mojo::Equals(this->priority, other_struct.priority))
    return false;
  if (!mojo::Equals(this->debug_key, other_struct.debug_key))
    return false;
  if (!mojo::Equals(this->filter_data, other_struct.filter_data))
    return false;
  if (!mojo::Equals(this->aggregation_keys, other_struct.aggregation_keys))
    return false;
  return true;
}

template <typename T, AttributionSourceData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.destination < rhs.destination)
    return true;
  if (rhs.destination < lhs.destination)
    return false;
  if (lhs.reporting_origin < rhs.reporting_origin)
    return true;
  if (rhs.reporting_origin < lhs.reporting_origin)
    return false;
  if (lhs.source_event_id < rhs.source_event_id)
    return true;
  if (rhs.source_event_id < lhs.source_event_id)
    return false;
  if (lhs.expiry < rhs.expiry)
    return true;
  if (rhs.expiry < lhs.expiry)
    return false;
  if (lhs.priority < rhs.priority)
    return true;
  if (rhs.priority < lhs.priority)
    return false;
  if (lhs.debug_key < rhs.debug_key)
    return true;
  if (rhs.debug_key < lhs.debug_key)
    return false;
  if (lhs.filter_data < rhs.filter_data)
    return true;
  if (rhs.filter_data < lhs.filter_data)
    return false;
  if (lhs.aggregation_keys < rhs.aggregation_keys)
    return true;
  if (rhs.aggregation_keys < lhs.aggregation_keys)
    return false;
  return false;
}
template <typename StructPtrType>
AttributionTriggerDedupKeyPtr AttributionTriggerDedupKey::Clone() const {
  return New(
      mojo::Clone(value)
  );
}

template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>*>
bool AttributionTriggerDedupKey::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->value, other_struct.value))
    return false;
  return true;
}

template <typename T, AttributionTriggerDedupKey::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.value < rhs.value)
    return true;
  if (rhs.value < lhs.value)
    return false;
  return false;
}
template <typename StructPtrType>
EventTriggerDataPtr EventTriggerData::Clone() const {
  return New(
      mojo::Clone(data),
      mojo::Clone(priority),
      mojo::Clone(dedup_key),
      mojo::Clone(filters),
      mojo::Clone(not_filters)
  );
}

template <typename T, EventTriggerData::EnableIfSame<T>*>
bool EventTriggerData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  if (!mojo::Equals(this->priority, other_struct.priority))
    return false;
  if (!mojo::Equals(this->dedup_key, other_struct.dedup_key))
    return false;
  if (!mojo::Equals(this->filters, other_struct.filters))
    return false;
  if (!mojo::Equals(this->not_filters, other_struct.not_filters))
    return false;
  return true;
}

template <typename T, EventTriggerData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  if (lhs.priority < rhs.priority)
    return true;
  if (rhs.priority < lhs.priority)
    return false;
  if (lhs.dedup_key < rhs.dedup_key)
    return true;
  if (rhs.dedup_key < lhs.dedup_key)
    return false;
  if (lhs.filters < rhs.filters)
    return true;
  if (rhs.filters < lhs.filters)
    return false;
  if (lhs.not_filters < rhs.not_filters)
    return true;
  if (rhs.not_filters < lhs.not_filters)
    return false;
  return false;
}
template <typename StructPtrType>
AttributionTriggerDataPtr AttributionTriggerData::Clone() const {
  return New(
      mojo::Clone(reporting_origin),
      mojo::Clone(event_triggers),
      mojo::Clone(filters),
      mojo::Clone(not_filters),
      mojo::Clone(aggregatable_trigger_data),
      mojo::Clone(aggregatable_values),
      mojo::Clone(debug_key)
  );
}

template <typename T, AttributionTriggerData::EnableIfSame<T>*>
bool AttributionTriggerData::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->reporting_origin, other_struct.reporting_origin))
    return false;
  if (!mojo::Equals(this->event_triggers, other_struct.event_triggers))
    return false;
  if (!mojo::Equals(this->filters, other_struct.filters))
    return false;
  if (!mojo::Equals(this->not_filters, other_struct.not_filters))
    return false;
  if (!mojo::Equals(this->aggregatable_trigger_data, other_struct.aggregatable_trigger_data))
    return false;
  if (!mojo::Equals(this->aggregatable_values, other_struct.aggregatable_values))
    return false;
  if (!mojo::Equals(this->debug_key, other_struct.debug_key))
    return false;
  return true;
}

template <typename T, AttributionTriggerData::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.reporting_origin < rhs.reporting_origin)
    return true;
  if (rhs.reporting_origin < lhs.reporting_origin)
    return false;
  if (lhs.event_triggers < rhs.event_triggers)
    return true;
  if (rhs.event_triggers < lhs.event_triggers)
    return false;
  if (lhs.filters < rhs.filters)
    return true;
  if (rhs.filters < lhs.filters)
    return false;
  if (lhs.not_filters < rhs.not_filters)
    return true;
  if (rhs.not_filters < lhs.not_filters)
    return false;
  if (lhs.aggregatable_trigger_data < rhs.aggregatable_trigger_data)
    return true;
  if (rhs.aggregatable_trigger_data < lhs.aggregatable_trigger_data)
    return false;
  if (lhs.aggregatable_values < rhs.aggregatable_values)
    return true;
  if (rhs.aggregatable_values < lhs.aggregatable_values)
    return false;
  if (lhs.debug_key < rhs.debug_key)
    return true;
  if (rhs.debug_key < lhs.debug_key)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace blink

namespace mojo {


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AttributionDebugKey::DataView,
                                         ::blink::mojom::AttributionDebugKeyPtr> {
  static bool IsNull(const ::blink::mojom::AttributionDebugKeyPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::AttributionDebugKeyPtr* output) { output->reset(); }

  static decltype(::blink::mojom::AttributionDebugKey::value) value(
      const ::blink::mojom::AttributionDebugKeyPtr& input) {
    return input->value;
  }

  static bool Read(::blink::mojom::AttributionDebugKey::DataView input, ::blink::mojom::AttributionDebugKeyPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AttributionFilterData::DataView,
                                         ::blink::mojom::AttributionFilterDataPtr> {
  static bool IsNull(const ::blink::mojom::AttributionFilterDataPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::AttributionFilterDataPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::AttributionFilterData::filter_values)& filter_values(
      const ::blink::mojom::AttributionFilterDataPtr& input) {
    return input->filter_values;
  }

  static bool Read(::blink::mojom::AttributionFilterData::DataView input, ::blink::mojom::AttributionFilterDataPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AttributionAggregatableTriggerData::DataView,
                                         ::blink::mojom::AttributionAggregatableTriggerDataPtr> {
  static bool IsNull(const ::blink::mojom::AttributionAggregatableTriggerDataPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::AttributionAggregatableTriggerDataPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::AttributionAggregatableTriggerData::key_piece)& key_piece(
      const ::blink::mojom::AttributionAggregatableTriggerDataPtr& input) {
    return input->key_piece;
  }

  static const decltype(::blink::mojom::AttributionAggregatableTriggerData::source_keys)& source_keys(
      const ::blink::mojom::AttributionAggregatableTriggerDataPtr& input) {
    return input->source_keys;
  }

  static const decltype(::blink::mojom::AttributionAggregatableTriggerData::filters)& filters(
      const ::blink::mojom::AttributionAggregatableTriggerDataPtr& input) {
    return input->filters;
  }

  static const decltype(::blink::mojom::AttributionAggregatableTriggerData::not_filters)& not_filters(
      const ::blink::mojom::AttributionAggregatableTriggerDataPtr& input) {
    return input->not_filters;
  }

  static bool Read(::blink::mojom::AttributionAggregatableTriggerData::DataView input, ::blink::mojom::AttributionAggregatableTriggerDataPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AttributionSourceData::DataView,
                                         ::blink::mojom::AttributionSourceDataPtr> {
  static bool IsNull(const ::blink::mojom::AttributionSourceDataPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::AttributionSourceDataPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::AttributionSourceData::destination)& destination(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->destination;
  }

  static const decltype(::blink::mojom::AttributionSourceData::reporting_origin)& reporting_origin(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->reporting_origin;
  }

  static decltype(::blink::mojom::AttributionSourceData::source_event_id) source_event_id(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->source_event_id;
  }

  static const decltype(::blink::mojom::AttributionSourceData::expiry)& expiry(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->expiry;
  }

  static decltype(::blink::mojom::AttributionSourceData::priority) priority(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->priority;
  }

  static const decltype(::blink::mojom::AttributionSourceData::debug_key)& debug_key(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->debug_key;
  }

  static const decltype(::blink::mojom::AttributionSourceData::filter_data)& filter_data(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->filter_data;
  }

  static const decltype(::blink::mojom::AttributionSourceData::aggregation_keys)& aggregation_keys(
      const ::blink::mojom::AttributionSourceDataPtr& input) {
    return input->aggregation_keys;
  }

  static bool Read(::blink::mojom::AttributionSourceData::DataView input, ::blink::mojom::AttributionSourceDataPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AttributionTriggerDedupKey::DataView,
                                         ::blink::mojom::AttributionTriggerDedupKeyPtr> {
  static bool IsNull(const ::blink::mojom::AttributionTriggerDedupKeyPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::AttributionTriggerDedupKeyPtr* output) { output->reset(); }

  static decltype(::blink::mojom::AttributionTriggerDedupKey::value) value(
      const ::blink::mojom::AttributionTriggerDedupKeyPtr& input) {
    return input->value;
  }

  static bool Read(::blink::mojom::AttributionTriggerDedupKey::DataView input, ::blink::mojom::AttributionTriggerDedupKeyPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::EventTriggerData::DataView,
                                         ::blink::mojom::EventTriggerDataPtr> {
  static bool IsNull(const ::blink::mojom::EventTriggerDataPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::EventTriggerDataPtr* output) { output->reset(); }

  static decltype(::blink::mojom::EventTriggerData::data) data(
      const ::blink::mojom::EventTriggerDataPtr& input) {
    return input->data;
  }

  static decltype(::blink::mojom::EventTriggerData::priority) priority(
      const ::blink::mojom::EventTriggerDataPtr& input) {
    return input->priority;
  }

  static const decltype(::blink::mojom::EventTriggerData::dedup_key)& dedup_key(
      const ::blink::mojom::EventTriggerDataPtr& input) {
    return input->dedup_key;
  }

  static const decltype(::blink::mojom::EventTriggerData::filters)& filters(
      const ::blink::mojom::EventTriggerDataPtr& input) {
    return input->filters;
  }

  static const decltype(::blink::mojom::EventTriggerData::not_filters)& not_filters(
      const ::blink::mojom::EventTriggerDataPtr& input) {
    return input->not_filters;
  }

  static bool Read(::blink::mojom::EventTriggerData::DataView input, ::blink::mojom::EventTriggerDataPtr* output);
};


template <>
struct BLINK_COMMON_EXPORT StructTraits<::blink::mojom::AttributionTriggerData::DataView,
                                         ::blink::mojom::AttributionTriggerDataPtr> {
  static bool IsNull(const ::blink::mojom::AttributionTriggerDataPtr& input) { return !input; }
  static void SetToNull(::blink::mojom::AttributionTriggerDataPtr* output) { output->reset(); }

  static const decltype(::blink::mojom::AttributionTriggerData::reporting_origin)& reporting_origin(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->reporting_origin;
  }

  static const decltype(::blink::mojom::AttributionTriggerData::event_triggers)& event_triggers(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->event_triggers;
  }

  static const decltype(::blink::mojom::AttributionTriggerData::filters)& filters(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->filters;
  }

  static const decltype(::blink::mojom::AttributionTriggerData::not_filters)& not_filters(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->not_filters;
  }

  static const decltype(::blink::mojom::AttributionTriggerData::aggregatable_trigger_data)& aggregatable_trigger_data(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->aggregatable_trigger_data;
  }

  static const decltype(::blink::mojom::AttributionTriggerData::aggregatable_values)& aggregatable_values(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->aggregatable_values;
  }

  static const decltype(::blink::mojom::AttributionTriggerData::debug_key)& debug_key(
      const ::blink::mojom::AttributionTriggerDataPtr& input) {
    return input->debug_key;
  }

  static bool Read(::blink::mojom::AttributionTriggerData::DataView input, ::blink::mojom::AttributionTriggerDataPtr* output);
};

}  // namespace mojo

#endif  // THIRD_PARTY_BLINK_PUBLIC_MOJOM_CONVERSIONS_ATTRIBUTION_DATA_HOST_MOJOM_H_