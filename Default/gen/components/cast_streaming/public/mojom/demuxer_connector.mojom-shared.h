// components/cast_streaming/public/mojom/demuxer_connector.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_CAST_STREAMING_PUBLIC_MOJOM_DEMUXER_CONNECTOR_MOJOM_SHARED_H_
#define COMPONENTS_CAST_STREAMING_PUBLIC_MOJOM_DEMUXER_CONNECTOR_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/cast_streaming/public/mojom/demuxer_connector.mojom-shared-internal.h"
#include "media/mojo/mojom/media_types.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"


#include "mojo/public/cpp/bindings/native_enum.h"
#include "mojo/public/cpp/bindings/lib/native_struct_serialization.h"




namespace cast_streaming {
namespace mojom {
class AudioStreamInfoDataView;

class VideoStreamInfoDataView;

class AudioStreamInitializationInfoDataView;

class VideoStreamInitializationInfoDataView;

class GetAudioBufferResponseDataView;
class GetVideoBufferResponseDataView;


}  // namespace mojom
}  // namespace cast_streaming

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::cast_streaming::mojom::AudioStreamInfoDataView> {
  using Data = ::cast_streaming::mojom::internal::AudioStreamInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::cast_streaming::mojom::VideoStreamInfoDataView> {
  using Data = ::cast_streaming::mojom::internal::VideoStreamInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::cast_streaming::mojom::AudioStreamInitializationInfoDataView> {
  using Data = ::cast_streaming::mojom::internal::AudioStreamInitializationInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::cast_streaming::mojom::VideoStreamInitializationInfoDataView> {
  using Data = ::cast_streaming::mojom::internal::VideoStreamInitializationInfo_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::cast_streaming::mojom::GetAudioBufferResponseDataView> {
  using Data = ::cast_streaming::mojom::internal::GetAudioBufferResponse_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

template <>
struct MojomTypeTraits<::cast_streaming::mojom::GetVideoBufferResponseDataView> {
  using Data = ::cast_streaming::mojom::internal::GetVideoBufferResponse_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace cast_streaming {
namespace mojom {
// Interface base classes. They are used for type safety check.
class AudioBufferRequesterInterfaceBase {};

using AudioBufferRequesterPtrDataView =
    mojo::InterfacePtrDataView<AudioBufferRequesterInterfaceBase>;
using AudioBufferRequesterRequestDataView =
    mojo::InterfaceRequestDataView<AudioBufferRequesterInterfaceBase>;
using AudioBufferRequesterAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<AudioBufferRequesterInterfaceBase>;
using AudioBufferRequesterAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<AudioBufferRequesterInterfaceBase>;
class VideoBufferRequesterInterfaceBase {};

using VideoBufferRequesterPtrDataView =
    mojo::InterfacePtrDataView<VideoBufferRequesterInterfaceBase>;
using VideoBufferRequesterRequestDataView =
    mojo::InterfaceRequestDataView<VideoBufferRequesterInterfaceBase>;
using VideoBufferRequesterAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<VideoBufferRequesterInterfaceBase>;
using VideoBufferRequesterAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<VideoBufferRequesterInterfaceBase>;
class DemuxerConnectorInterfaceBase {};

using DemuxerConnectorPtrDataView =
    mojo::InterfacePtrDataView<DemuxerConnectorInterfaceBase>;
using DemuxerConnectorRequestDataView =
    mojo::InterfaceRequestDataView<DemuxerConnectorInterfaceBase>;
using DemuxerConnectorAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<DemuxerConnectorInterfaceBase>;
using DemuxerConnectorAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<DemuxerConnectorInterfaceBase>;


class AudioStreamInfoDataView {
 public:
  AudioStreamInfoDataView() = default;

  AudioStreamInfoDataView(
      internal::AudioStreamInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDecoderConfigDataView(
      ::media::mojom::AudioDecoderConfigDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecoderConfig(UserType* output) {
    
    auto* pointer = data_->decoder_config.Get();
    return mojo::internal::Deserialize<::media::mojom::AudioDecoderConfigDataView>(
        pointer, output, message_);
  }
  mojo::ScopedDataPipeConsumerHandle TakeDataPipe() {
    mojo::ScopedDataPipeConsumerHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedDataPipeConsumerHandle>(
            &data_->data_pipe, &result, message_);
    DCHECK(ret);
    return result;
  }
 private:
  internal::AudioStreamInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoStreamInfoDataView {
 public:
  VideoStreamInfoDataView() = default;

  VideoStreamInfoDataView(
      internal::VideoStreamInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDecoderConfigDataView(
      ::media::mojom::VideoDecoderConfigDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDecoderConfig(UserType* output) {
    
    auto* pointer = data_->decoder_config.Get();
    return mojo::internal::Deserialize<::media::mojom::VideoDecoderConfigDataView>(
        pointer, output, message_);
  }
  mojo::ScopedDataPipeConsumerHandle TakeDataPipe() {
    mojo::ScopedDataPipeConsumerHandle result;
    bool ret =
        mojo::internal::Deserialize<mojo::ScopedDataPipeConsumerHandle>(
            &data_->data_pipe, &result, message_);
    DCHECK(ret);
    return result;
  }
 private:
  internal::VideoStreamInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class AudioStreamInitializationInfoDataView {
 public:
  AudioStreamInitializationInfoDataView() = default;

  AudioStreamInitializationInfoDataView(
      internal::AudioStreamInitializationInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  UserType TakeBufferRequester() {
    UserType result;
    bool ret =
        mojo::internal::Deserialize<mojo::InterfacePtrDataView<::cast_streaming::mojom::AudioBufferRequesterInterfaceBase>>(
            &data_->buffer_requester, &result, message_);
    DCHECK(ret);
    return result;
  }
  inline void GetStreamInitializationInfoDataView(
      AudioStreamInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStreamInitializationInfo(UserType* output) {
    
    auto* pointer = data_->stream_initialization_info.Get();
    return mojo::internal::Deserialize<::cast_streaming::mojom::AudioStreamInfoDataView>(
        pointer, output, message_);
  }
 private:
  internal::AudioStreamInitializationInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class VideoStreamInitializationInfoDataView {
 public:
  VideoStreamInitializationInfoDataView() = default;

  VideoStreamInitializationInfoDataView(
      internal::VideoStreamInitializationInfo_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  template <typename UserType>
  UserType TakeBufferRequester() {
    UserType result;
    bool ret =
        mojo::internal::Deserialize<mojo::InterfacePtrDataView<::cast_streaming::mojom::VideoBufferRequesterInterfaceBase>>(
            &data_->buffer_requester, &result, message_);
    DCHECK(ret);
    return result;
  }
  inline void GetStreamInitializationInfoDataView(
      VideoStreamInfoDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadStreamInitializationInfo(UserType* output) {
    
    auto* pointer = data_->stream_initialization_info.Get();
    return mojo::internal::Deserialize<::cast_streaming::mojom::VideoStreamInfoDataView>(
        pointer, output, message_);
  }
 private:
  internal::VideoStreamInitializationInfo_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GetAudioBufferResponseDataView {
 public:
  using Tag = internal::GetAudioBufferResponse_Data::GetAudioBufferResponse_Tag;

  GetAudioBufferResponseDataView() = default;

  GetAudioBufferResponseDataView(
      internal::GetAudioBufferResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_stream_info() const { return data_->tag == Tag::kStreamInfo; }
  inline void GetStreamInfoDataView(
      AudioStreamInfoDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadStreamInfo(UserType* output) const {
    
    CHECK(is_stream_info());
    return mojo::internal::Deserialize<::cast_streaming::mojom::AudioStreamInfoDataView>(
        data_->data.f_stream_info.Get(), output, message_);
  }
  bool is_buffer() const { return data_->tag == Tag::kBuffer; }
  inline void GetBufferDataView(
      ::media::mojom::DecoderBufferDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadBuffer(UserType* output) const {
    
    CHECK(is_buffer());
    return mojo::internal::Deserialize<::media::mojom::DecoderBufferDataView>(
        data_->data.f_buffer.Get(), output, message_);
  }

 private:
  internal::GetAudioBufferResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class GetVideoBufferResponseDataView {
 public:
  using Tag = internal::GetVideoBufferResponse_Data::GetVideoBufferResponse_Tag;

  GetVideoBufferResponseDataView() = default;

  GetVideoBufferResponseDataView(
      internal::GetVideoBufferResponse_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_stream_info() const { return data_->tag == Tag::kStreamInfo; }
  inline void GetStreamInfoDataView(
      VideoStreamInfoDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadStreamInfo(UserType* output) const {
    
    CHECK(is_stream_info());
    return mojo::internal::Deserialize<::cast_streaming::mojom::VideoStreamInfoDataView>(
        data_->data.f_stream_info.Get(), output, message_);
  }
  bool is_buffer() const { return data_->tag == Tag::kBuffer; }
  inline void GetBufferDataView(
      ::media::mojom::DecoderBufferDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadBuffer(UserType* output) const {
    
    CHECK(is_buffer());
    return mojo::internal::Deserialize<::media::mojom::DecoderBufferDataView>(
        data_->data.f_buffer.Get(), output, message_);
  }

 private:
  internal::GetVideoBufferResponse_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace cast_streaming

namespace std {

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::cast_streaming::mojom::AudioStreamInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::cast_streaming::mojom::AudioStreamInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::cast_streaming::mojom::internal::AudioStreamInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::decoder_config(input)) in_decoder_config = Traits::decoder_config(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decoder_config)::BaseType> decoder_config_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::AudioDecoderConfigDataView>(
        in_decoder_config, decoder_config_fragment);
    fragment->decoder_config.Set(
        decoder_config_fragment.is_null() ? nullptr : decoder_config_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->decoder_config.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null decoder_config in AudioStreamInfo struct");
    decltype(Traits::data_pipe(input)) in_data_pipe = Traits::data_pipe(input);
    mojo::internal::Serialize<mojo::ScopedDataPipeConsumerHandle>(
        in_data_pipe, &fragment->data_pipe, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->data_pipe),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid data_pipe in AudioStreamInfo struct");
  }

  static bool Deserialize(::cast_streaming::mojom::internal::AudioStreamInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::cast_streaming::mojom::AudioStreamInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::cast_streaming::mojom::VideoStreamInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::cast_streaming::mojom::VideoStreamInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::cast_streaming::mojom::internal::VideoStreamInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::decoder_config(input)) in_decoder_config = Traits::decoder_config(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->decoder_config)::BaseType> decoder_config_fragment(
            fragment.message());
    mojo::internal::Serialize<::media::mojom::VideoDecoderConfigDataView>(
        in_decoder_config, decoder_config_fragment);
    fragment->decoder_config.Set(
        decoder_config_fragment.is_null() ? nullptr : decoder_config_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->decoder_config.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null decoder_config in VideoStreamInfo struct");
    decltype(Traits::data_pipe(input)) in_data_pipe = Traits::data_pipe(input);
    mojo::internal::Serialize<mojo::ScopedDataPipeConsumerHandle>(
        in_data_pipe, &fragment->data_pipe, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->data_pipe),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid data_pipe in VideoStreamInfo struct");
  }

  static bool Deserialize(::cast_streaming::mojom::internal::VideoStreamInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::cast_streaming::mojom::VideoStreamInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::cast_streaming::mojom::AudioStreamInitializationInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::cast_streaming::mojom::AudioStreamInitializationInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::cast_streaming::mojom::internal::AudioStreamInitializationInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::buffer_requester(input)) in_buffer_requester = Traits::buffer_requester(input);
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::cast_streaming::mojom::AudioBufferRequesterInterfaceBase>>(
        in_buffer_requester, &fragment->buffer_requester, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->buffer_requester),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid buffer_requester in AudioStreamInitializationInfo struct");
    decltype(Traits::stream_initialization_info(input)) in_stream_initialization_info = Traits::stream_initialization_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->stream_initialization_info)::BaseType> stream_initialization_info_fragment(
            fragment.message());
    mojo::internal::Serialize<::cast_streaming::mojom::AudioStreamInfoDataView>(
        in_stream_initialization_info, stream_initialization_info_fragment);
    fragment->stream_initialization_info.Set(
        stream_initialization_info_fragment.is_null() ? nullptr : stream_initialization_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->stream_initialization_info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null stream_initialization_info in AudioStreamInitializationInfo struct");
  }

  static bool Deserialize(::cast_streaming::mojom::internal::AudioStreamInitializationInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::cast_streaming::mojom::AudioStreamInitializationInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::cast_streaming::mojom::VideoStreamInitializationInfoDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::cast_streaming::mojom::VideoStreamInitializationInfoDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::cast_streaming::mojom::internal::VideoStreamInitializationInfo_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::buffer_requester(input)) in_buffer_requester = Traits::buffer_requester(input);
    mojo::internal::Serialize<mojo::InterfacePtrDataView<::cast_streaming::mojom::VideoBufferRequesterInterfaceBase>>(
        in_buffer_requester, &fragment->buffer_requester, &fragment.message());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        !mojo::internal::IsHandleOrInterfaceValid(fragment->buffer_requester),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_INVALID_HANDLE,
        "invalid buffer_requester in VideoStreamInitializationInfo struct");
    decltype(Traits::stream_initialization_info(input)) in_stream_initialization_info = Traits::stream_initialization_info(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->stream_initialization_info)::BaseType> stream_initialization_info_fragment(
            fragment.message());
    mojo::internal::Serialize<::cast_streaming::mojom::VideoStreamInfoDataView>(
        in_stream_initialization_info, stream_initialization_info_fragment);
    fragment->stream_initialization_info.Set(
        stream_initialization_info_fragment.is_null() ? nullptr : stream_initialization_info_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->stream_initialization_info.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null stream_initialization_info in VideoStreamInitializationInfo struct");
  }

  static bool Deserialize(::cast_streaming::mojom::internal::VideoStreamInitializationInfo_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::cast_streaming::mojom::VideoStreamInitializationInfoDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::cast_streaming::mojom::GetAudioBufferResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::cast_streaming::mojom::GetAudioBufferResponseDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::cast_streaming::mojom::internal::GetAudioBufferResponse_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::cast_streaming::mojom::GetAudioBufferResponseDataView::Tag::kStreamInfo: {
        decltype(Traits::stream_info(input))
            in_stream_info = Traits::stream_info(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_stream_info)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::cast_streaming::mojom::AudioStreamInfoDataView>(
            in_stream_info, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null stream_info in GetAudioBufferResponse union");
        fragment->data.f_stream_info.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::cast_streaming::mojom::GetAudioBufferResponseDataView::Tag::kBuffer: {
        decltype(Traits::buffer(input))
            in_buffer = Traits::buffer(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_buffer)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::DecoderBufferDataView>(
            in_buffer, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null buffer in GetAudioBufferResponse union");
        fragment->data.f_buffer.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::cast_streaming::mojom::internal::GetAudioBufferResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::cast_streaming::mojom::GetAudioBufferResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::cast_streaming::mojom::GetVideoBufferResponseDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::cast_streaming::mojom::GetVideoBufferResponseDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::cast_streaming::mojom::internal::GetVideoBufferResponse_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::cast_streaming::mojom::GetVideoBufferResponseDataView::Tag::kStreamInfo: {
        decltype(Traits::stream_info(input))
            in_stream_info = Traits::stream_info(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_stream_info)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::cast_streaming::mojom::VideoStreamInfoDataView>(
            in_stream_info, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null stream_info in GetVideoBufferResponse union");
        fragment->data.f_stream_info.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::cast_streaming::mojom::GetVideoBufferResponseDataView::Tag::kBuffer: {
        decltype(Traits::buffer(input))
            in_buffer = Traits::buffer(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_buffer)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::media::mojom::DecoderBufferDataView>(
            in_buffer, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null buffer in GetVideoBufferResponse union");
        fragment->data.f_buffer.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::cast_streaming::mojom::internal::GetVideoBufferResponse_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::cast_streaming::mojom::GetVideoBufferResponseDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace cast_streaming {
namespace mojom {

inline void AudioStreamInfoDataView::GetDecoderConfigDataView(
    ::media::mojom::AudioDecoderConfigDataView* output) {
  auto pointer = data_->decoder_config.Get();
  *output = ::media::mojom::AudioDecoderConfigDataView(pointer, message_);
}


inline void VideoStreamInfoDataView::GetDecoderConfigDataView(
    ::media::mojom::VideoDecoderConfigDataView* output) {
  auto pointer = data_->decoder_config.Get();
  *output = ::media::mojom::VideoDecoderConfigDataView(pointer, message_);
}


inline void AudioStreamInitializationInfoDataView::GetStreamInitializationInfoDataView(
    AudioStreamInfoDataView* output) {
  auto pointer = data_->stream_initialization_info.Get();
  *output = AudioStreamInfoDataView(pointer, message_);
}


inline void VideoStreamInitializationInfoDataView::GetStreamInitializationInfoDataView(
    VideoStreamInfoDataView* output) {
  auto pointer = data_->stream_initialization_info.Get();
  *output = VideoStreamInfoDataView(pointer, message_);
}


inline void GetAudioBufferResponseDataView::GetStreamInfoDataView(
    AudioStreamInfoDataView* output) const {
  CHECK(is_stream_info());
  *output = AudioStreamInfoDataView(data_->data.f_stream_info.Get(), message_);
}
inline void GetAudioBufferResponseDataView::GetBufferDataView(
    ::media::mojom::DecoderBufferDataView* output) const {
  CHECK(is_buffer());
  *output = ::media::mojom::DecoderBufferDataView(data_->data.f_buffer.Get(), message_);
}

inline void GetVideoBufferResponseDataView::GetStreamInfoDataView(
    VideoStreamInfoDataView* output) const {
  CHECK(is_stream_info());
  *output = VideoStreamInfoDataView(data_->data.f_stream_info.Get(), message_);
}
inline void GetVideoBufferResponseDataView::GetBufferDataView(
    ::media::mojom::DecoderBufferDataView* output) const {
  CHECK(is_buffer());
  *output = ::media::mojom::DecoderBufferDataView(data_->data.f_buffer.Get(), message_);
}


}  // namespace mojom
}  // namespace cast_streaming

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

#endif  // COMPONENTS_CAST_STREAMING_PUBLIC_MOJOM_DEMUXER_CONNECTOR_MOJOM_SHARED_H_