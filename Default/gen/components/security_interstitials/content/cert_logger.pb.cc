// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cert_logger.proto

#include "cert_logger.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace chrome_browser_ssl {
PROTOBUF_CONSTEXPR CertLoggerInterstitialInfo::CertLoggerInterstitialInfo(
    ::_pbi::ConstantInitialized)
  : interstitial_reason_(0)

  , user_proceeded_(false)
  , overridable_(false)
  , interstitial_created_time_usec_(int64_t{0}){}
struct CertLoggerInterstitialInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertLoggerInterstitialInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertLoggerInterstitialInfoDefaultTypeInternal() {}
  union {
    CertLoggerInterstitialInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertLoggerInterstitialInfoDefaultTypeInternal _CertLoggerInterstitialInfo_default_instance_;
PROTOBUF_CONSTEXPR CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo(
    ::_pbi::ConstantInitialized)
  : network_time_queries_enabled_(false)
  , network_time_query_behavior_(0)
{}
struct CertLoggerFeaturesInfo_NetworkTimeQueryingInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertLoggerFeaturesInfo_NetworkTimeQueryingInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertLoggerFeaturesInfo_NetworkTimeQueryingInfoDefaultTypeInternal() {}
  union {
    CertLoggerFeaturesInfo_NetworkTimeQueryingInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertLoggerFeaturesInfo_NetworkTimeQueryingInfoDefaultTypeInternal _CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_default_instance_;
PROTOBUF_CONSTEXPR CertLoggerFeaturesInfo::CertLoggerFeaturesInfo(
    ::_pbi::ConstantInitialized)
  : network_time_querying_info_(nullptr)
  , trial_verification_info_(nullptr)
  , android_aia_fetching_status_(0)
{}
struct CertLoggerFeaturesInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertLoggerFeaturesInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertLoggerFeaturesInfoDefaultTypeInternal() {}
  union {
    CertLoggerFeaturesInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertLoggerFeaturesInfoDefaultTypeInternal _CertLoggerFeaturesInfo_default_instance_;
PROTOBUF_CONSTEXPR CertLoggerRequest::CertLoggerRequest(
    ::_pbi::ConstantInitialized)
  : public_key_hash_()
  , pin_()
  , cert_error_()
  , cert_status_()
  , hostname_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , cert_chain_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , unverified_cert_chain_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , chrome_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , os_type_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , os_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , hardware_model_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , os_architecture_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , process_architecture_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , interstitial_info_(nullptr)
  , features_info_(nullptr)
  , time_usec_(int64_t{0})
  , is_issued_by_known_root_(false)
  , is_retry_upload_(false)
  , is_enterprise_managed_(false)
  , chrome_channel_(0)
{}
struct CertLoggerRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CertLoggerRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CertLoggerRequestDefaultTypeInternal() {}
  union {
    CertLoggerRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CertLoggerRequestDefaultTypeInternal _CertLoggerRequest_default_instance_;
PROTOBUF_CONSTEXPR MacCertEvidenceInfo::MacCertEvidenceInfo(
    ::_pbi::ConstantInitialized)
  : status_codes_()
  , status_bits_(0u){}
struct MacCertEvidenceInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MacCertEvidenceInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MacCertEvidenceInfoDefaultTypeInternal() {}
  union {
    MacCertEvidenceInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MacCertEvidenceInfoDefaultTypeInternal _MacCertEvidenceInfo_default_instance_;
PROTOBUF_CONSTEXPR MacPlatformDebugInfo::MacPlatformDebugInfo(
    ::_pbi::ConstantInitialized)
  : status_chain_()
  , trust_result_(0u)
  , result_code_(0){}
struct MacPlatformDebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR MacPlatformDebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~MacPlatformDebugInfoDefaultTypeInternal() {}
  union {
    MacPlatformDebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 MacPlatformDebugInfoDefaultTypeInternal _MacPlatformDebugInfo_default_instance_;
PROTOBUF_CONSTEXPR WinPlatformDebugInfo::WinPlatformDebugInfo(
    ::_pbi::ConstantInitialized)
  : authroot_sequence_number_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , authroot_this_update_time_usec_(int64_t{0}){}
struct WinPlatformDebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WinPlatformDebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WinPlatformDebugInfoDefaultTypeInternal() {}
  union {
    WinPlatformDebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WinPlatformDebugInfoDefaultTypeInternal _WinPlatformDebugInfo_default_instance_;
PROTOBUF_CONSTEXPR ChromeRootStoreDebugInfo::ChromeRootStoreDebugInfo(
    ::_pbi::ConstantInitialized)
  : chrome_root_store_version_(int64_t{0}){}
struct ChromeRootStoreDebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromeRootStoreDebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromeRootStoreDebugInfoDefaultTypeInternal() {}
  union {
    ChromeRootStoreDebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromeRootStoreDebugInfoDefaultTypeInternal _ChromeRootStoreDebugInfo_default_instance_;
PROTOBUF_CONSTEXPR TrialVerificationInfo::TrialVerificationInfo(
    ::_pbi::ConstantInitialized)
  : public_key_hash_()
  , cert_error_()
  , cert_status_()
  , verify_flags_()
  , mac_combined_trust_debug_info_()
  , cert_chain_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , trial_der_verification_time_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , stapled_ocsp_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sct_list_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , mac_platform_debug_info_(nullptr)
  , win_platform_debug_info_(nullptr)
  , chrome_root_store_debug_info_(nullptr)
  , trial_verification_time_usec_(int64_t{0})
  , is_issued_by_known_root_(false)
  , mac_trust_impl_(0)
{}
struct TrialVerificationInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TrialVerificationInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TrialVerificationInfoDefaultTypeInternal() {}
  union {
    TrialVerificationInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TrialVerificationInfoDefaultTypeInternal _TrialVerificationInfo_default_instance_;
}  // namespace chrome_browser_ssl
namespace chrome_browser_ssl {
bool CertLoggerInterstitialInfo_InterstitialReason_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerInterstitialInfo_InterstitialReason_strings[8] = {};

static const char CertLoggerInterstitialInfo_InterstitialReason_names[] =
  "INTERSTITIAL_BLOCKED_INTERCEPTION"
  "INTERSTITIAL_CAPTIVE_PORTAL"
  "INTERSTITIAL_CLOCK"
  "INTERSTITIAL_LEGACY_TLS"
  "INTERSTITIAL_MITM_SOFTWARE"
  "INTERSTITIAL_SSL"
  "INTERSTITIAL_SUPERFISH"
  "UNKNOWN_INTERSTITIAL_REASON";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerInterstitialInfo_InterstitialReason_entries[] = {
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 0, 33}, 6 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 33, 27}, 2 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 60, 18}, 3 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 78, 23}, 7 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 101, 26}, 5 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 127, 16}, 1 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 143, 22}, 4 },
  { {CertLoggerInterstitialInfo_InterstitialReason_names + 165, 27}, 0 },
};

static const int CertLoggerInterstitialInfo_InterstitialReason_entries_by_number[] = {
  7, // 0 -> UNKNOWN_INTERSTITIAL_REASON
  5, // 1 -> INTERSTITIAL_SSL
  1, // 2 -> INTERSTITIAL_CAPTIVE_PORTAL
  2, // 3 -> INTERSTITIAL_CLOCK
  6, // 4 -> INTERSTITIAL_SUPERFISH
  4, // 5 -> INTERSTITIAL_MITM_SOFTWARE
  0, // 6 -> INTERSTITIAL_BLOCKED_INTERCEPTION
  3, // 7 -> INTERSTITIAL_LEGACY_TLS
};

const std::string& CertLoggerInterstitialInfo_InterstitialReason_Name(
    CertLoggerInterstitialInfo_InterstitialReason value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerInterstitialInfo_InterstitialReason_entries,
          CertLoggerInterstitialInfo_InterstitialReason_entries_by_number,
          8, CertLoggerInterstitialInfo_InterstitialReason_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerInterstitialInfo_InterstitialReason_entries,
      CertLoggerInterstitialInfo_InterstitialReason_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerInterstitialInfo_InterstitialReason_strings[idx].get();
}
bool CertLoggerInterstitialInfo_InterstitialReason_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertLoggerInterstitialInfo_InterstitialReason* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerInterstitialInfo_InterstitialReason_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerInterstitialInfo_InterstitialReason>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::UNKNOWN_INTERSTITIAL_REASON;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_SSL;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_CAPTIVE_PORTAL;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_CLOCK;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_SUPERFISH;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_MITM_SOFTWARE;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_BLOCKED_INTERCEPTION;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::INTERSTITIAL_LEGACY_TLS;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::InterstitialReason_MIN;
constexpr CertLoggerInterstitialInfo_InterstitialReason CertLoggerInterstitialInfo::InterstitialReason_MAX;
constexpr int CertLoggerInterstitialInfo::InterstitialReason_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_strings[4] = {};

static const char CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names[] =
  "NETWORK_TIME_FETCHES_BACKGROUND_ONLY"
  "NETWORK_TIME_FETCHES_IN_BACKGROUND_AND_ON_DEMAND"
  "NETWORK_TIME_FETCHES_ON_DEMAND_ONLY"
  "NETWORK_TIME_FETCHES_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries[] = {
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 0, 36}, 1 },
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 36, 48}, 3 },
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 84, 35}, 2 },
  { {CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_names + 119, 28}, 0 },
};

static const int CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries_by_number[] = {
  3, // 0 -> NETWORK_TIME_FETCHES_UNKNOWN
  0, // 1 -> NETWORK_TIME_FETCHES_BACKGROUND_ONLY
  2, // 2 -> NETWORK_TIME_FETCHES_ON_DEMAND_ONLY
  1, // 3 -> NETWORK_TIME_FETCHES_IN_BACKGROUND_AND_ON_DEMAND
};

const std::string& CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_Name(
    CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries,
          CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries_by_number,
          4, CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries,
      CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_strings[idx].get();
}
bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_UNKNOWN;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_BACKGROUND_ONLY;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_ON_DEMAND_ONLY;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NETWORK_TIME_FETCHES_IN_BACKGROUND_AND_ON_DEMAND;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NetworkTimeFetchBehavior_MIN;
constexpr CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NetworkTimeFetchBehavior_MAX;
constexpr int CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::NetworkTimeFetchBehavior_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_strings[3] = {};

static const char CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names[] =
  "ANDROID_AIA_FETCHING_DISABLED"
  "ANDROID_AIA_FETCHING_ENABLED"
  "ANDROID_AIA_FETCHING_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries[] = {
  { {CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names + 0, 29}, 2 },
  { {CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names + 29, 28}, 1 },
  { {CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_names + 57, 28}, 0 },
};

static const int CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries_by_number[] = {
  2, // 0 -> ANDROID_AIA_FETCHING_UNKNOWN
  1, // 1 -> ANDROID_AIA_FETCHING_ENABLED
  0, // 2 -> ANDROID_AIA_FETCHING_DISABLED
};

const std::string& CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_Name(
    CertLoggerFeaturesInfo_AndroidAIAFetchingStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries,
          CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries_by_number,
          3, CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries,
      CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_strings[idx].get();
}
bool CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertLoggerFeaturesInfo_AndroidAIAFetchingStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerFeaturesInfo_AndroidAIAFetchingStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::ANDROID_AIA_FETCHING_UNKNOWN;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::ANDROID_AIA_FETCHING_ENABLED;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::ANDROID_AIA_FETCHING_DISABLED;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::AndroidAIAFetchingStatus_MIN;
constexpr CertLoggerFeaturesInfo_AndroidAIAFetchingStatus CertLoggerFeaturesInfo::AndroidAIAFetchingStatus_MAX;
constexpr int CertLoggerFeaturesInfo::AndroidAIAFetchingStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CertLoggerRequest_CertError_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerRequest_CertError_strings[17] = {};

static const char CertLoggerRequest_CertError_names[] =
  "ERR_CERTIFICATE_TRANSPARENCY_REQUIRED"
  "ERR_CERT_AUTHORITY_INVALID"
  "ERR_CERT_COMMON_NAME_INVALID"
  "ERR_CERT_DATE_INVALID"
  "ERR_CERT_INVALID"
  "ERR_CERT_KNOWN_INTERCEPTION_BLOCKED"
  "ERR_CERT_NAME_CONSTRAINT_VIOLATION"
  "ERR_CERT_NON_UNIQUE_NAME"
  "ERR_CERT_NO_REVOCATION_MECHANISM"
  "ERR_CERT_REVOKED"
  "ERR_CERT_SYMANTEC_LEGACY"
  "ERR_CERT_UNABLE_TO_CHECK_REVOCATION"
  "ERR_CERT_VALIDITY_TOO_LONG"
  "ERR_CERT_WEAK_KEY"
  "ERR_CERT_WEAK_SIGNATURE_ALGORITHM"
  "ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN"
  "UNKNOWN_CERT_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerRequest_CertError_entries[] = {
  { {CertLoggerRequest_CertError_names + 0, 37}, 14 },
  { {CertLoggerRequest_CertError_names + 37, 26}, 4 },
  { {CertLoggerRequest_CertError_names + 63, 28}, 5 },
  { {CertLoggerRequest_CertError_names + 91, 21}, 9 },
  { {CertLoggerRequest_CertError_names + 112, 16}, 2 },
  { {CertLoggerRequest_CertError_names + 128, 35}, 16 },
  { {CertLoggerRequest_CertError_names + 163, 34}, 6 },
  { {CertLoggerRequest_CertError_names + 197, 24}, 13 },
  { {CertLoggerRequest_CertError_names + 221, 32}, 12 },
  { {CertLoggerRequest_CertError_names + 253, 16}, 1 },
  { {CertLoggerRequest_CertError_names + 269, 24}, 15 },
  { {CertLoggerRequest_CertError_names + 293, 35}, 11 },
  { {CertLoggerRequest_CertError_names + 328, 26}, 10 },
  { {CertLoggerRequest_CertError_names + 354, 17}, 8 },
  { {CertLoggerRequest_CertError_names + 371, 33}, 7 },
  { {CertLoggerRequest_CertError_names + 404, 36}, 3 },
  { {CertLoggerRequest_CertError_names + 440, 18}, 0 },
};

static const int CertLoggerRequest_CertError_entries_by_number[] = {
  16, // 0 -> UNKNOWN_CERT_ERROR
  9, // 1 -> ERR_CERT_REVOKED
  4, // 2 -> ERR_CERT_INVALID
  15, // 3 -> ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN
  1, // 4 -> ERR_CERT_AUTHORITY_INVALID
  2, // 5 -> ERR_CERT_COMMON_NAME_INVALID
  6, // 6 -> ERR_CERT_NAME_CONSTRAINT_VIOLATION
  14, // 7 -> ERR_CERT_WEAK_SIGNATURE_ALGORITHM
  13, // 8 -> ERR_CERT_WEAK_KEY
  3, // 9 -> ERR_CERT_DATE_INVALID
  12, // 10 -> ERR_CERT_VALIDITY_TOO_LONG
  11, // 11 -> ERR_CERT_UNABLE_TO_CHECK_REVOCATION
  8, // 12 -> ERR_CERT_NO_REVOCATION_MECHANISM
  7, // 13 -> ERR_CERT_NON_UNIQUE_NAME
  0, // 14 -> ERR_CERTIFICATE_TRANSPARENCY_REQUIRED
  10, // 15 -> ERR_CERT_SYMANTEC_LEGACY
  5, // 16 -> ERR_CERT_KNOWN_INTERCEPTION_BLOCKED
};

const std::string& CertLoggerRequest_CertError_Name(
    CertLoggerRequest_CertError value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerRequest_CertError_entries,
          CertLoggerRequest_CertError_entries_by_number,
          17, CertLoggerRequest_CertError_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerRequest_CertError_entries,
      CertLoggerRequest_CertError_entries_by_number,
      17, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerRequest_CertError_strings[idx].get();
}
bool CertLoggerRequest_CertError_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertLoggerRequest_CertError* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerRequest_CertError_entries, 17, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerRequest_CertError>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertLoggerRequest_CertError CertLoggerRequest::UNKNOWN_CERT_ERROR;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_REVOKED;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_SSL_PINNED_KEY_NOT_IN_CERT_CHAIN;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_AUTHORITY_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_COMMON_NAME_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_NAME_CONSTRAINT_VIOLATION;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_WEAK_SIGNATURE_ALGORITHM;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_WEAK_KEY;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_DATE_INVALID;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_VALIDITY_TOO_LONG;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_UNABLE_TO_CHECK_REVOCATION;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_NO_REVOCATION_MECHANISM;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_NON_UNIQUE_NAME;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERTIFICATE_TRANSPARENCY_REQUIRED;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_SYMANTEC_LEGACY;
constexpr CertLoggerRequest_CertError CertLoggerRequest::ERR_CERT_KNOWN_INTERCEPTION_BLOCKED;
constexpr CertLoggerRequest_CertError CertLoggerRequest::CertError_MIN;
constexpr CertLoggerRequest_CertError CertLoggerRequest::CertError_MAX;
constexpr int CertLoggerRequest::CertError_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CertLoggerRequest_ChromeChannel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerRequest_ChromeChannel_strings[6] = {};

static const char CertLoggerRequest_ChromeChannel_names[] =
  "CHROME_CHANNEL_BETA"
  "CHROME_CHANNEL_CANARY"
  "CHROME_CHANNEL_DEV"
  "CHROME_CHANNEL_NONE"
  "CHROME_CHANNEL_STABLE"
  "CHROME_CHANNEL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerRequest_ChromeChannel_entries[] = {
  { {CertLoggerRequest_ChromeChannel_names + 0, 19}, 4 },
  { {CertLoggerRequest_ChromeChannel_names + 19, 21}, 3 },
  { {CertLoggerRequest_ChromeChannel_names + 40, 18}, 2 },
  { {CertLoggerRequest_ChromeChannel_names + 58, 19}, 0 },
  { {CertLoggerRequest_ChromeChannel_names + 77, 21}, 5 },
  { {CertLoggerRequest_ChromeChannel_names + 98, 22}, 1 },
};

static const int CertLoggerRequest_ChromeChannel_entries_by_number[] = {
  3, // 0 -> CHROME_CHANNEL_NONE
  5, // 1 -> CHROME_CHANNEL_UNKNOWN
  2, // 2 -> CHROME_CHANNEL_DEV
  1, // 3 -> CHROME_CHANNEL_CANARY
  0, // 4 -> CHROME_CHANNEL_BETA
  4, // 5 -> CHROME_CHANNEL_STABLE
};

const std::string& CertLoggerRequest_ChromeChannel_Name(
    CertLoggerRequest_ChromeChannel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerRequest_ChromeChannel_entries,
          CertLoggerRequest_ChromeChannel_entries_by_number,
          6, CertLoggerRequest_ChromeChannel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerRequest_ChromeChannel_entries,
      CertLoggerRequest_ChromeChannel_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerRequest_ChromeChannel_strings[idx].get();
}
bool CertLoggerRequest_ChromeChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertLoggerRequest_ChromeChannel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerRequest_ChromeChannel_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerRequest_ChromeChannel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_NONE;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_UNKNOWN;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_DEV;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_CANARY;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_BETA;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::CHROME_CHANNEL_STABLE;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::ChromeChannel_MIN;
constexpr CertLoggerRequest_ChromeChannel CertLoggerRequest::ChromeChannel_MAX;
constexpr int CertLoggerRequest::ChromeChannel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CertLoggerRequest_CertStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CertLoggerRequest_CertStatus_strings[6] = {};

static const char CertLoggerRequest_CertStatus_names[] =
  "STATUS_CT_COMPLIANCE_FAILED"
  "STATUS_IS_EV"
  "STATUS_KNOWN_INTERCEPTION_DETECTED"
  "STATUS_REV_CHECKING_ENABLED"
  "STATUS_SHA1_SIGNATURE_PRESENT"
  "UNKNOWN_CERT_STATUS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CertLoggerRequest_CertStatus_entries[] = {
  { {CertLoggerRequest_CertStatus_names + 0, 27}, 4 },
  { {CertLoggerRequest_CertStatus_names + 27, 12}, 1 },
  { {CertLoggerRequest_CertStatus_names + 39, 34}, 5 },
  { {CertLoggerRequest_CertStatus_names + 73, 27}, 2 },
  { {CertLoggerRequest_CertStatus_names + 100, 29}, 3 },
  { {CertLoggerRequest_CertStatus_names + 129, 19}, 0 },
};

static const int CertLoggerRequest_CertStatus_entries_by_number[] = {
  5, // 0 -> UNKNOWN_CERT_STATUS
  1, // 1 -> STATUS_IS_EV
  3, // 2 -> STATUS_REV_CHECKING_ENABLED
  4, // 3 -> STATUS_SHA1_SIGNATURE_PRESENT
  0, // 4 -> STATUS_CT_COMPLIANCE_FAILED
  2, // 5 -> STATUS_KNOWN_INTERCEPTION_DETECTED
};

const std::string& CertLoggerRequest_CertStatus_Name(
    CertLoggerRequest_CertStatus value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CertLoggerRequest_CertStatus_entries,
          CertLoggerRequest_CertStatus_entries_by_number,
          6, CertLoggerRequest_CertStatus_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CertLoggerRequest_CertStatus_entries,
      CertLoggerRequest_CertStatus_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CertLoggerRequest_CertStatus_strings[idx].get();
}
bool CertLoggerRequest_CertStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CertLoggerRequest_CertStatus* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CertLoggerRequest_CertStatus_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CertLoggerRequest_CertStatus>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::UNKNOWN_CERT_STATUS;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_IS_EV;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_REV_CHECKING_ENABLED;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_SHA1_SIGNATURE_PRESENT;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_CT_COMPLIANCE_FAILED;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::STATUS_KNOWN_INTERCEPTION_DETECTED;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::CertStatus_MIN;
constexpr CertLoggerRequest_CertStatus CertLoggerRequest::CertStatus_MAX;
constexpr int CertLoggerRequest::CertStatus_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TrialVerificationInfo_VerifyFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrialVerificationInfo_VerifyFlags_strings[8] = {};

static const char TrialVerificationInfo_VerifyFlags_names[] =
  "UNKNOWN_VERIFY_FLAG"
  "VERIFY_CERT_IO_ENABLED"
  "VERIFY_DISABLE_SYMANTEC_ENFORCEMENT"
  "VERIFY_ENABLE_SHA1_LOCAL_ANCHORS"
  "VERIFY_EV_CERT"
  "VERIFY_REV_CHECKING_ENABLED"
  "VERIFY_REV_CHECKING_ENABLED_EV_ONLY"
  "VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrialVerificationInfo_VerifyFlags_entries[] = {
  { {TrialVerificationInfo_VerifyFlags_names + 0, 19}, 0 },
  { {TrialVerificationInfo_VerifyFlags_names + 19, 22}, 3 },
  { {TrialVerificationInfo_VerifyFlags_names + 41, 35}, 7 },
  { {TrialVerificationInfo_VerifyFlags_names + 76, 32}, 6 },
  { {TrialVerificationInfo_VerifyFlags_names + 108, 14}, 2 },
  { {TrialVerificationInfo_VerifyFlags_names + 122, 27}, 1 },
  { {TrialVerificationInfo_VerifyFlags_names + 149, 35}, 4 },
  { {TrialVerificationInfo_VerifyFlags_names + 184, 42}, 5 },
};

static const int TrialVerificationInfo_VerifyFlags_entries_by_number[] = {
  0, // 0 -> UNKNOWN_VERIFY_FLAG
  5, // 1 -> VERIFY_REV_CHECKING_ENABLED
  4, // 2 -> VERIFY_EV_CERT
  1, // 3 -> VERIFY_CERT_IO_ENABLED
  6, // 4 -> VERIFY_REV_CHECKING_ENABLED_EV_ONLY
  7, // 5 -> VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS
  3, // 6 -> VERIFY_ENABLE_SHA1_LOCAL_ANCHORS
  2, // 7 -> VERIFY_DISABLE_SYMANTEC_ENFORCEMENT
};

const std::string& TrialVerificationInfo_VerifyFlags_Name(
    TrialVerificationInfo_VerifyFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrialVerificationInfo_VerifyFlags_entries,
          TrialVerificationInfo_VerifyFlags_entries_by_number,
          8, TrialVerificationInfo_VerifyFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrialVerificationInfo_VerifyFlags_entries,
      TrialVerificationInfo_VerifyFlags_entries_by_number,
      8, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrialVerificationInfo_VerifyFlags_strings[idx].get();
}
bool TrialVerificationInfo_VerifyFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrialVerificationInfo_VerifyFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrialVerificationInfo_VerifyFlags_entries, 8, name, &int_value);
  if (success) {
    *value = static_cast<TrialVerificationInfo_VerifyFlags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::UNKNOWN_VERIFY_FLAG;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_REV_CHECKING_ENABLED;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_EV_CERT;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_CERT_IO_ENABLED;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_REV_CHECKING_ENABLED_EV_ONLY;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_REV_CHECKING_REQUIRED_LOCAL_ANCHORS;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_ENABLE_SHA1_LOCAL_ANCHORS;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VERIFY_DISABLE_SYMANTEC_ENFORCEMENT;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VerifyFlags_MIN;
constexpr TrialVerificationInfo_VerifyFlags TrialVerificationInfo::VerifyFlags_MAX;
constexpr int TrialVerificationInfo::VerifyFlags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TrialVerificationInfo_MacTrustFlags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrialVerificationInfo_MacTrustFlags_strings[13] = {};

static const char TrialVerificationInfo_MacTrustFlags_names[] =
  "MAC_COPY_TRUST_SETTINGS_ERROR"
  "MAC_TRUST_SETTINGS_ARRAY_EMPTY"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_ALLOWED_ERROR"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_APPLICATION"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_KEY_USAGE"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY_STRING"
  "MAC_TRUST_SETTINGS_DICT_CONTAINS_RESULT"
  "MAC_TRUST_SETTINGS_DICT_EMPTY"
  "MAC_TRUST_SETTINGS_DICT_INVALID_POLICY_TYPE"
  "MAC_TRUST_SETTINGS_DICT_INVALID_RESULT_TYPE"
  "MAC_TRUST_SETTINGS_DICT_UNKNOWN_KEY"
  "UNKNOWN_MAC_TRUST_FLAG";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrialVerificationInfo_MacTrustFlags_entries[] = {
  { {TrialVerificationInfo_MacTrustFlags_names + 0, 29}, 12 },
  { {TrialVerificationInfo_MacTrustFlags_names + 29, 30}, 1 },
  { {TrialVerificationInfo_MacTrustFlags_names + 59, 46}, 11 },
  { {TrialVerificationInfo_MacTrustFlags_names + 105, 44}, 6 },
  { {TrialVerificationInfo_MacTrustFlags_names + 149, 42}, 8 },
  { {TrialVerificationInfo_MacTrustFlags_names + 191, 39}, 4 },
  { {TrialVerificationInfo_MacTrustFlags_names + 230, 46}, 7 },
  { {TrialVerificationInfo_MacTrustFlags_names + 276, 39}, 9 },
  { {TrialVerificationInfo_MacTrustFlags_names + 315, 29}, 2 },
  { {TrialVerificationInfo_MacTrustFlags_names + 344, 43}, 5 },
  { {TrialVerificationInfo_MacTrustFlags_names + 387, 43}, 10 },
  { {TrialVerificationInfo_MacTrustFlags_names + 430, 35}, 3 },
  { {TrialVerificationInfo_MacTrustFlags_names + 465, 22}, 0 },
};

static const int TrialVerificationInfo_MacTrustFlags_entries_by_number[] = {
  12, // 0 -> UNKNOWN_MAC_TRUST_FLAG
  1, // 1 -> MAC_TRUST_SETTINGS_ARRAY_EMPTY
  8, // 2 -> MAC_TRUST_SETTINGS_DICT_EMPTY
  11, // 3 -> MAC_TRUST_SETTINGS_DICT_UNKNOWN_KEY
  5, // 4 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY
  9, // 5 -> MAC_TRUST_SETTINGS_DICT_INVALID_POLICY_TYPE
  3, // 6 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_APPLICATION
  6, // 7 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY_STRING
  4, // 8 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_KEY_USAGE
  7, // 9 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_RESULT
  10, // 10 -> MAC_TRUST_SETTINGS_DICT_INVALID_RESULT_TYPE
  2, // 11 -> MAC_TRUST_SETTINGS_DICT_CONTAINS_ALLOWED_ERROR
  0, // 12 -> MAC_COPY_TRUST_SETTINGS_ERROR
};

const std::string& TrialVerificationInfo_MacTrustFlags_Name(
    TrialVerificationInfo_MacTrustFlags value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrialVerificationInfo_MacTrustFlags_entries,
          TrialVerificationInfo_MacTrustFlags_entries_by_number,
          13, TrialVerificationInfo_MacTrustFlags_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrialVerificationInfo_MacTrustFlags_entries,
      TrialVerificationInfo_MacTrustFlags_entries_by_number,
      13, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrialVerificationInfo_MacTrustFlags_strings[idx].get();
}
bool TrialVerificationInfo_MacTrustFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrialVerificationInfo_MacTrustFlags* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrialVerificationInfo_MacTrustFlags_entries, 13, name, &int_value);
  if (success) {
    *value = static_cast<TrialVerificationInfo_MacTrustFlags>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::UNKNOWN_MAC_TRUST_FLAG;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_ARRAY_EMPTY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_EMPTY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_UNKNOWN_KEY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_INVALID_POLICY_TYPE;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_APPLICATION;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_POLICY_STRING;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_KEY_USAGE;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_RESULT;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_INVALID_RESULT_TYPE;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_TRUST_SETTINGS_DICT_CONTAINS_ALLOWED_ERROR;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MAC_COPY_TRUST_SETTINGS_ERROR;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MacTrustFlags_MIN;
constexpr TrialVerificationInfo_MacTrustFlags TrialVerificationInfo::MacTrustFlags_MAX;
constexpr int TrialVerificationInfo::MacTrustFlags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool TrialVerificationInfo_MacTrustImplType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> TrialVerificationInfo_MacTrustImplType_strings[5] = {};

static const char TrialVerificationInfo_MacTrustImplType_names[] =
  "MAC_TRUST_IMPL_DOMAIN_CACHE"
  "MAC_TRUST_IMPL_DOMAIN_CACHE_FULL_CERTS"
  "MAC_TRUST_IMPL_MRU_CACHE"
  "MAC_TRUST_IMPL_SIMPLE"
  "MAC_TRUST_IMPL_UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry TrialVerificationInfo_MacTrustImplType_entries[] = {
  { {TrialVerificationInfo_MacTrustImplType_names + 0, 27}, 1 },
  { {TrialVerificationInfo_MacTrustImplType_names + 27, 38}, 4 },
  { {TrialVerificationInfo_MacTrustImplType_names + 65, 24}, 3 },
  { {TrialVerificationInfo_MacTrustImplType_names + 89, 21}, 2 },
  { {TrialVerificationInfo_MacTrustImplType_names + 110, 22}, 0 },
};

static const int TrialVerificationInfo_MacTrustImplType_entries_by_number[] = {
  4, // 0 -> MAC_TRUST_IMPL_UNKNOWN
  0, // 1 -> MAC_TRUST_IMPL_DOMAIN_CACHE
  3, // 2 -> MAC_TRUST_IMPL_SIMPLE
  2, // 3 -> MAC_TRUST_IMPL_MRU_CACHE
  1, // 4 -> MAC_TRUST_IMPL_DOMAIN_CACHE_FULL_CERTS
};

const std::string& TrialVerificationInfo_MacTrustImplType_Name(
    TrialVerificationInfo_MacTrustImplType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          TrialVerificationInfo_MacTrustImplType_entries,
          TrialVerificationInfo_MacTrustImplType_entries_by_number,
          5, TrialVerificationInfo_MacTrustImplType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      TrialVerificationInfo_MacTrustImplType_entries,
      TrialVerificationInfo_MacTrustImplType_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     TrialVerificationInfo_MacTrustImplType_strings[idx].get();
}
bool TrialVerificationInfo_MacTrustImplType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TrialVerificationInfo_MacTrustImplType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      TrialVerificationInfo_MacTrustImplType_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<TrialVerificationInfo_MacTrustImplType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MAC_TRUST_IMPL_UNKNOWN;
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MAC_TRUST_IMPL_DOMAIN_CACHE;
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MAC_TRUST_IMPL_SIMPLE;
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MAC_TRUST_IMPL_MRU_CACHE;
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MAC_TRUST_IMPL_DOMAIN_CACHE_FULL_CERTS;
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MacTrustImplType_MIN;
constexpr TrialVerificationInfo_MacTrustImplType TrialVerificationInfo::MacTrustImplType_MAX;
constexpr int TrialVerificationInfo::MacTrustImplType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class CertLoggerInterstitialInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerInterstitialInfo>()._has_bits_);
  static void set_has_interstitial_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_user_proceeded(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_overridable(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_interstitial_created_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CertLoggerInterstitialInfo::CertLoggerInterstitialInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.CertLoggerInterstitialInfo)
}
CertLoggerInterstitialInfo::CertLoggerInterstitialInfo(const CertLoggerInterstitialInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&interstitial_reason_, &from.interstitial_reason_,
    static_cast<size_t>(reinterpret_cast<char*>(&interstitial_created_time_usec_) -
    reinterpret_cast<char*>(&interstitial_reason_)) + sizeof(interstitial_created_time_usec_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerInterstitialInfo)
}

inline void CertLoggerInterstitialInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&interstitial_reason_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&interstitial_created_time_usec_) -
    reinterpret_cast<char*>(&interstitial_reason_)) + sizeof(interstitial_created_time_usec_));
}

CertLoggerInterstitialInfo::~CertLoggerInterstitialInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerInterstitialInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertLoggerInterstitialInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CertLoggerInterstitialInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertLoggerInterstitialInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&interstitial_reason_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interstitial_created_time_usec_) -
        reinterpret_cast<char*>(&interstitial_reason_)) + sizeof(interstitial_created_time_usec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertLoggerInterstitialInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerInterstitialInfo_InterstitialReason_IsValid(val))) {
            _internal_set_interstitial_reason(static_cast<::chrome_browser_ssl::CertLoggerInterstitialInfo_InterstitialReason>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool user_proceeded = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_user_proceeded(&has_bits);
          user_proceeded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool overridable = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_overridable(&has_bits);
          overridable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 interstitial_created_time_usec = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_interstitial_created_time_usec(&has_bits);
          interstitial_created_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertLoggerInterstitialInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_interstitial_reason(), target);
  }

  // optional bool user_proceeded = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_user_proceeded(), target);
  }

  // optional bool overridable = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_overridable(), target);
  }

  // optional int64 interstitial_created_time_usec = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_interstitial_created_time_usec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.CertLoggerInterstitialInfo)
  return target;
}

size_t CertLoggerInterstitialInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .chrome_browser_ssl.CertLoggerInterstitialInfo.InterstitialReason interstitial_reason = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_interstitial_reason());
    }

    // optional bool user_proceeded = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool overridable = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int64 interstitial_created_time_usec = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_interstitial_created_time_usec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerInterstitialInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertLoggerInterstitialInfo*>(
      &from));
}

void CertLoggerInterstitialInfo::MergeFrom(const CertLoggerInterstitialInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      interstitial_reason_ = from.interstitial_reason_;
    }
    if (cached_has_bits & 0x00000002u) {
      user_proceeded_ = from.user_proceeded_;
    }
    if (cached_has_bits & 0x00000004u) {
      overridable_ = from.overridable_;
    }
    if (cached_has_bits & 0x00000008u) {
      interstitial_created_time_usec_ = from.interstitial_created_time_usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertLoggerInterstitialInfo::CopyFrom(const CertLoggerInterstitialInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerInterstitialInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerInterstitialInfo::IsInitialized() const {
  return true;
}

void CertLoggerInterstitialInfo::InternalSwap(CertLoggerInterstitialInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertLoggerInterstitialInfo, interstitial_created_time_usec_)
      + sizeof(CertLoggerInterstitialInfo::interstitial_created_time_usec_)
      - PROTOBUF_FIELD_OFFSET(CertLoggerInterstitialInfo, interstitial_reason_)>(
          reinterpret_cast<char*>(&interstitial_reason_),
          reinterpret_cast<char*>(&other->interstitial_reason_));
}

std::string CertLoggerInterstitialInfo::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerInterstitialInfo";
}


// ===================================================================

class CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerFeaturesInfo_NetworkTimeQueryingInfo>()._has_bits_);
  static void set_has_network_time_queries_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_network_time_query_behavior(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
}
CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo(const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&network_time_queries_enabled_, &from.network_time_queries_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&network_time_query_behavior_) -
    reinterpret_cast<char*>(&network_time_queries_enabled_)) + sizeof(network_time_query_behavior_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
}

inline void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&network_time_queries_enabled_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&network_time_query_behavior_) -
    reinterpret_cast<char*>(&network_time_queries_enabled_)) + sizeof(network_time_query_behavior_));
}

CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::~CertLoggerFeaturesInfo_NetworkTimeQueryingInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&network_time_queries_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&network_time_query_behavior_) -
        reinterpret_cast<char*>(&network_time_queries_enabled_)) + sizeof(network_time_query_behavior_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool network_time_queries_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_network_time_queries_enabled(&has_bits);
          network_time_queries_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior_IsValid(val))) {
            _internal_set_network_time_query_behavior(static_cast<::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo_NetworkTimeFetchBehavior>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool network_time_queries_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_network_time_queries_enabled(), target);
  }

  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_network_time_query_behavior(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  return target;
}

size_t CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool network_time_queries_enabled = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo.NetworkTimeFetchBehavior network_time_query_behavior = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_network_time_query_behavior());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo*>(
      &from));
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::MergeFrom(const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      network_time_queries_enabled_ = from.network_time_queries_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      network_time_query_behavior_ = from.network_time_query_behavior_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::CopyFrom(const CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::IsInitialized() const {
  return true;
}

void CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::InternalSwap(CertLoggerFeaturesInfo_NetworkTimeQueryingInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertLoggerFeaturesInfo_NetworkTimeQueryingInfo, network_time_query_behavior_)
      + sizeof(CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::network_time_query_behavior_)
      - PROTOBUF_FIELD_OFFSET(CertLoggerFeaturesInfo_NetworkTimeQueryingInfo, network_time_queries_enabled_)>(
          reinterpret_cast<char*>(&network_time_queries_enabled_),
          reinterpret_cast<char*>(&other->network_time_queries_enabled_));
}

std::string CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo";
}


// ===================================================================

class CertLoggerFeaturesInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerFeaturesInfo>()._has_bits_);
  static const ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo& network_time_querying_info(const CertLoggerFeaturesInfo* msg);
  static void set_has_network_time_querying_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_android_aia_fetching_status(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::chrome_browser_ssl::TrialVerificationInfo& trial_verification_info(const CertLoggerFeaturesInfo* msg);
  static void set_has_trial_verification_info(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo&
CertLoggerFeaturesInfo::_Internal::network_time_querying_info(const CertLoggerFeaturesInfo* msg) {
  return *msg->network_time_querying_info_;
}
const ::chrome_browser_ssl::TrialVerificationInfo&
CertLoggerFeaturesInfo::_Internal::trial_verification_info(const CertLoggerFeaturesInfo* msg) {
  return *msg->trial_verification_info_;
}
CertLoggerFeaturesInfo::CertLoggerFeaturesInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.CertLoggerFeaturesInfo)
}
CertLoggerFeaturesInfo::CertLoggerFeaturesInfo(const CertLoggerFeaturesInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_network_time_querying_info()) {
    network_time_querying_info_ = new ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo(*from.network_time_querying_info_);
  } else {
    network_time_querying_info_ = nullptr;
  }
  if (from._internal_has_trial_verification_info()) {
    trial_verification_info_ = new ::chrome_browser_ssl::TrialVerificationInfo(*from.trial_verification_info_);
  } else {
    trial_verification_info_ = nullptr;
  }
  android_aia_fetching_status_ = from.android_aia_fetching_status_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerFeaturesInfo)
}

inline void CertLoggerFeaturesInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&network_time_querying_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&android_aia_fetching_status_) -
    reinterpret_cast<char*>(&network_time_querying_info_)) + sizeof(android_aia_fetching_status_));
}

CertLoggerFeaturesInfo::~CertLoggerFeaturesInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerFeaturesInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertLoggerFeaturesInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete network_time_querying_info_;
  if (this != internal_default_instance()) delete trial_verification_info_;
}

void CertLoggerFeaturesInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertLoggerFeaturesInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(network_time_querying_info_ != nullptr);
      network_time_querying_info_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(trial_verification_info_ != nullptr);
      trial_verification_info_->Clear();
    }
  }
  android_aia_fetching_status_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertLoggerFeaturesInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_network_time_querying_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerFeaturesInfo_AndroidAIAFetchingStatus_IsValid(val))) {
            _internal_set_android_aia_fetching_status(static_cast<::chrome_browser_ssl::CertLoggerFeaturesInfo_AndroidAIAFetchingStatus>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_trial_verification_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertLoggerFeaturesInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::network_time_querying_info(this),
        _Internal::network_time_querying_info(this).GetCachedSize(), target, stream);
  }

  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_android_aia_fetching_status(), target);
  }

  // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::trial_verification_info(this),
        _Internal::trial_verification_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.CertLoggerFeaturesInfo)
  return target;
}

size_t CertLoggerFeaturesInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.NetworkTimeQueryingInfo network_time_querying_info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *network_time_querying_info_);
    }

    // optional .chrome_browser_ssl.TrialVerificationInfo trial_verification_info = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trial_verification_info_);
    }

    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo.AndroidAIAFetchingStatus android_aia_fetching_status = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_android_aia_fetching_status());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerFeaturesInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertLoggerFeaturesInfo*>(
      &from));
}

void CertLoggerFeaturesInfo::MergeFrom(const CertLoggerFeaturesInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_network_time_querying_info()->::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo::MergeFrom(from._internal_network_time_querying_info());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_trial_verification_info()->::chrome_browser_ssl::TrialVerificationInfo::MergeFrom(from._internal_trial_verification_info());
    }
    if (cached_has_bits & 0x00000004u) {
      android_aia_fetching_status_ = from.android_aia_fetching_status_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertLoggerFeaturesInfo::CopyFrom(const CertLoggerFeaturesInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerFeaturesInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerFeaturesInfo::IsInitialized() const {
  return true;
}

void CertLoggerFeaturesInfo::InternalSwap(CertLoggerFeaturesInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertLoggerFeaturesInfo, android_aia_fetching_status_)
      + sizeof(CertLoggerFeaturesInfo::android_aia_fetching_status_)
      - PROTOBUF_FIELD_OFFSET(CertLoggerFeaturesInfo, network_time_querying_info_)>(
          reinterpret_cast<char*>(&network_time_querying_info_),
          reinterpret_cast<char*>(&other->network_time_querying_info_));
}

std::string CertLoggerFeaturesInfo::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerFeaturesInfo";
}


// ===================================================================

class CertLoggerRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CertLoggerRequest>()._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cert_chain(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::chrome_browser_ssl::CertLoggerInterstitialInfo& interstitial_info(const CertLoggerRequest* msg);
  static void set_has_interstitial_info(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_unverified_cert_chain(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_issued_by_known_root(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::chrome_browser_ssl::CertLoggerFeaturesInfo& features_info(const CertLoggerRequest* msg);
  static void set_has_features_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_retry_upload(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_chrome_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_enterprise_managed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_chrome_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_hardware_model_name(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_os_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_process_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000803) ^ 0x00000803) != 0;
  }
};

const ::chrome_browser_ssl::CertLoggerInterstitialInfo&
CertLoggerRequest::_Internal::interstitial_info(const CertLoggerRequest* msg) {
  return *msg->interstitial_info_;
}
const ::chrome_browser_ssl::CertLoggerFeaturesInfo&
CertLoggerRequest::_Internal::features_info(const CertLoggerRequest* msg) {
  return *msg->features_info_;
}
CertLoggerRequest::CertLoggerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  public_key_hash_(arena),
  pin_(arena),
  cert_error_(arena),
  cert_status_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.CertLoggerRequest)
}
CertLoggerRequest::CertLoggerRequest(const CertLoggerRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      public_key_hash_(from.public_key_hash_),
      pin_(from.pin_),
      cert_error_(from.cert_error_),
      cert_status_(from.cert_status_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  hostname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hostname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    hostname_.Set(from._internal_hostname(), 
      GetArenaForAllocation());
  }
  cert_chain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cert_chain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert_chain()) {
    cert_chain_.Set(from._internal_cert_chain(), 
      GetArenaForAllocation());
  }
  unverified_cert_chain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    unverified_cert_chain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_unverified_cert_chain()) {
    unverified_cert_chain_.Set(from._internal_unverified_cert_chain(), 
      GetArenaForAllocation());
  }
  chrome_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    chrome_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_chrome_version()) {
    chrome_version_.Set(from._internal_chrome_version(), 
      GetArenaForAllocation());
  }
  os_type_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    os_type_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_type()) {
    os_type_.Set(from._internal_os_type(), 
      GetArenaForAllocation());
  }
  os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_version()) {
    os_version_.Set(from._internal_os_version(), 
      GetArenaForAllocation());
  }
  hardware_model_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hardware_model_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hardware_model_name()) {
    hardware_model_name_.Set(from._internal_hardware_model_name(), 
      GetArenaForAllocation());
  }
  os_architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    os_architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_os_architecture()) {
    os_architecture_.Set(from._internal_os_architecture(), 
      GetArenaForAllocation());
  }
  process_architecture_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    process_architecture_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_process_architecture()) {
    process_architecture_.Set(from._internal_process_architecture(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_interstitial_info()) {
    interstitial_info_ = new ::chrome_browser_ssl::CertLoggerInterstitialInfo(*from.interstitial_info_);
  } else {
    interstitial_info_ = nullptr;
  }
  if (from._internal_has_features_info()) {
    features_info_ = new ::chrome_browser_ssl::CertLoggerFeaturesInfo(*from.features_info_);
  } else {
    features_info_ = nullptr;
  }
  ::memcpy(&time_usec_, &from.time_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&chrome_channel_) -
    reinterpret_cast<char*>(&time_usec_)) + sizeof(chrome_channel_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.CertLoggerRequest)
}

inline void CertLoggerRequest::SharedCtor() {
hostname_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hostname_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cert_chain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cert_chain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
unverified_cert_chain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  unverified_cert_chain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
chrome_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  chrome_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
os_type_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  os_type_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
hardware_model_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hardware_model_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
os_architecture_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  os_architecture_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
process_architecture_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  process_architecture_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&interstitial_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&chrome_channel_) -
    reinterpret_cast<char*>(&interstitial_info_)) + sizeof(chrome_channel_));
}

CertLoggerRequest::~CertLoggerRequest() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.CertLoggerRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CertLoggerRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hostname_.Destroy();
  cert_chain_.Destroy();
  unverified_cert_chain_.Destroy();
  chrome_version_.Destroy();
  os_type_.Destroy();
  os_version_.Destroy();
  hardware_model_name_.Destroy();
  os_architecture_.Destroy();
  process_architecture_.Destroy();
  if (this != internal_default_instance()) delete interstitial_info_;
  if (this != internal_default_instance()) delete features_info_;
}

void CertLoggerRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CertLoggerRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.CertLoggerRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_key_hash_.Clear();
  pin_.Clear();
  cert_error_.Clear();
  cert_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      cert_chain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      unverified_cert_chain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      chrome_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      os_type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      hardware_model_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      os_architecture_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      process_architecture_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(interstitial_info_ != nullptr);
      interstitial_info_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(features_info_ != nullptr);
      features_info_->Clear();
    }
  }
  if (cached_has_bits & 0x0000f800u) {
    ::memset(&time_usec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chrome_channel_) -
        reinterpret_cast<char*>(&time_usec_)) + sizeof(chrome_channel_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CertLoggerRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hostname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string cert_chain = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cert_chain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int64 time_usec = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_time_usec(&has_bits);
          time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string public_key_hash = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_public_key_hash();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string pin = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_pin();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid(val))) {
              _internal_add_cert_error(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertError>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_cert_error(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid, &_internal_metadata_, 6);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_interstitial_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string unverified_cert_chain = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_unverified_cert_chain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_issued_by_known_root = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_issued_by_known_root(&has_bits);
          is_issued_by_known_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_features_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_retry_upload = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_retry_upload(&has_bits);
          is_retry_upload_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_ChromeChannel_IsValid(val))) {
            _internal_set_chrome_channel(static_cast<::chrome_browser_ssl::CertLoggerRequest_ChromeChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enterprise_managed = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_enterprise_managed(&has_bits);
          is_enterprise_managed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid(val))) {
              _internal_add_cert_status(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertStatus>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_cert_status(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid, &_internal_metadata_, 14);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string chrome_version = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_chrome_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_type = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_os_type();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_version = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hardware_model_name = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_hardware_model_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string os_architecture = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_os_architecture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string process_architecture = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_process_architecture();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CertLoggerRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.CertLoggerRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hostname(), target);
  }

  // required string cert_chain = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cert_chain(), target);
  }

  // required int64 time_usec = 3;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_time_usec(), target);
  }

  // repeated string public_key_hash = 4;
  for (int i = 0, n = this->_internal_public_key_hash_size(); i < n; i++) {
    const auto& s = this->_internal_public_key_hash(i);
    target = stream->WriteString(4, s, target);
  }

  // repeated string pin = 5;
  for (int i = 0, n = this->_internal_pin_size(); i < n; i++) {
    const auto& s = this->_internal_pin(i);
    target = stream->WriteString(5, s, target);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
  for (int i = 0, n = this->_internal_cert_error_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_cert_error(i), target);
  }

  // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::interstitial_info(this),
        _Internal::interstitial_info(this).GetCachedSize(), target, stream);
  }

  // optional string unverified_cert_chain = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_unverified_cert_chain(), target);
  }

  // optional bool is_issued_by_known_root = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_is_issued_by_known_root(), target);
  }

  // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::features_info(this),
        _Internal::features_info(this).GetCachedSize(), target, stream);
  }

  // optional bool is_retry_upload = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(11, this->_internal_is_retry_upload(), target);
  }

  // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_chrome_channel(), target);
  }

  // optional bool is_enterprise_managed = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_is_enterprise_managed(), target);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
  for (int i = 0, n = this->_internal_cert_status_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_cert_status(i), target);
  }

  // optional string chrome_version = 15;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_chrome_version(), target);
  }

  // optional string os_type = 16;
  if (cached_has_bits & 0x00000010u) {
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_os_type(), target);
  }

  // optional string os_version = 17;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_os_version(), target);
  }

  // optional string hardware_model_name = 18;
  if (cached_has_bits & 0x00000040u) {
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_hardware_model_name(), target);
  }

  // optional string os_architecture = 19;
  if (cached_has_bits & 0x00000080u) {
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_os_architecture(), target);
  }

  // optional string process_architecture = 20;
  if (cached_has_bits & 0x00000100u) {
    target = stream->WriteStringMaybeAliased(
        20, this->_internal_process_architecture(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.CertLoggerRequest)
  return target;
}

size_t CertLoggerRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:chrome_browser_ssl.CertLoggerRequest)
  size_t total_size = 0;

  if (_internal_has_hostname()) {
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  if (_internal_has_cert_chain()) {
    // required string cert_chain = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cert_chain());
  }

  if (_internal_has_time_usec()) {
    // required int64 time_usec = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_usec());
  }

  return total_size;
}
size_t CertLoggerRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.CertLoggerRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000803) ^ 0x00000803) == 0) {  // All required fields are present.
    // required string hostname = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());

    // required string cert_chain = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cert_chain());

    // required int64 time_usec = 3;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_time_usec());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string public_key_hash = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(public_key_hash_.size());
  for (int i = 0, n = public_key_hash_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      public_key_hash_.Get(i));
  }

  // repeated string pin = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(pin_.size());
  for (int i = 0, n = pin_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      pin_.Get(i));
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 6;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_cert_error_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_cert_error(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 14;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_cert_status_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_cert_status(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000fcu) {
    // optional string unverified_cert_chain = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_unverified_cert_chain());
    }

    // optional string chrome_version = 15;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_chrome_version());
    }

    // optional string os_type = 16;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_type());
    }

    // optional string os_version = 17;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_version());
    }

    // optional string hardware_model_name = 18;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hardware_model_name());
    }

    // optional string os_architecture = 19;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_os_architecture());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional string process_architecture = 20;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_process_architecture());
    }

    // optional .chrome_browser_ssl.CertLoggerInterstitialInfo interstitial_info = 7;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *interstitial_info_);
    }

    // optional .chrome_browser_ssl.CertLoggerFeaturesInfo features_info = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *features_info_);
    }

  }
  if (cached_has_bits & 0x0000f000u) {
    // optional bool is_issued_by_known_root = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_retry_upload = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_enterprise_managed = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional .chrome_browser_ssl.CertLoggerRequest.ChromeChannel chrome_channel = 12;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_chrome_channel());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CertLoggerRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CertLoggerRequest*>(
      &from));
}

void CertLoggerRequest::MergeFrom(const CertLoggerRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.CertLoggerRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  public_key_hash_.MergeFrom(from.public_key_hash_);
  pin_.MergeFrom(from.pin_);
  cert_error_.MergeFrom(from.cert_error_);
  cert_status_.MergeFrom(from.cert_status_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_cert_chain(from._internal_cert_chain());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_unverified_cert_chain(from._internal_unverified_cert_chain());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_chrome_version(from._internal_chrome_version());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_os_type(from._internal_os_type());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_os_version(from._internal_os_version());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_hardware_model_name(from._internal_hardware_model_name());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_os_architecture(from._internal_os_architecture());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_set_process_architecture(from._internal_process_architecture());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_interstitial_info()->::chrome_browser_ssl::CertLoggerInterstitialInfo::MergeFrom(from._internal_interstitial_info());
    }
    if (cached_has_bits & 0x00000400u) {
      _internal_mutable_features_info()->::chrome_browser_ssl::CertLoggerFeaturesInfo::MergeFrom(from._internal_features_info());
    }
    if (cached_has_bits & 0x00000800u) {
      time_usec_ = from.time_usec_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_issued_by_known_root_ = from.is_issued_by_known_root_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_retry_upload_ = from.is_retry_upload_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_enterprise_managed_ = from.is_enterprise_managed_;
    }
    if (cached_has_bits & 0x00008000u) {
      chrome_channel_ = from.chrome_channel_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CertLoggerRequest::CopyFrom(const CertLoggerRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.CertLoggerRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CertLoggerRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CertLoggerRequest::InternalSwap(CertLoggerRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  public_key_hash_.InternalSwap(&other->public_key_hash_);
  pin_.InternalSwap(&other->pin_);
  cert_error_.InternalSwap(&other->cert_error_);
  cert_status_.InternalSwap(&other->cert_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hostname_, lhs_arena,
      &other->hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cert_chain_, lhs_arena,
      &other->cert_chain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &unverified_cert_chain_, lhs_arena,
      &other->unverified_cert_chain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &chrome_version_, lhs_arena,
      &other->chrome_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &os_type_, lhs_arena,
      &other->os_type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &os_version_, lhs_arena,
      &other->os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &hardware_model_name_, lhs_arena,
      &other->hardware_model_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &os_architecture_, lhs_arena,
      &other->os_architecture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &process_architecture_, lhs_arena,
      &other->process_architecture_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CertLoggerRequest, chrome_channel_)
      + sizeof(CertLoggerRequest::chrome_channel_)
      - PROTOBUF_FIELD_OFFSET(CertLoggerRequest, interstitial_info_)>(
          reinterpret_cast<char*>(&interstitial_info_),
          reinterpret_cast<char*>(&other->interstitial_info_));
}

std::string CertLoggerRequest::GetTypeName() const {
  return "chrome_browser_ssl.CertLoggerRequest";
}


// ===================================================================

class MacCertEvidenceInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MacCertEvidenceInfo>()._has_bits_);
  static void set_has_status_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

MacCertEvidenceInfo::MacCertEvidenceInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  status_codes_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.MacCertEvidenceInfo)
}
MacCertEvidenceInfo::MacCertEvidenceInfo(const MacCertEvidenceInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      status_codes_(from.status_codes_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  status_bits_ = from.status_bits_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.MacCertEvidenceInfo)
}

inline void MacCertEvidenceInfo::SharedCtor() {
status_bits_ = 0u;
}

MacCertEvidenceInfo::~MacCertEvidenceInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.MacCertEvidenceInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MacCertEvidenceInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MacCertEvidenceInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MacCertEvidenceInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.MacCertEvidenceInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_codes_.Clear();
  status_bits_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MacCertEvidenceInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 status_bits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_status_bits(&has_bits);
          status_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 status_codes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_status_codes(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_status_codes(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MacCertEvidenceInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.MacCertEvidenceInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 status_bits = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_status_bits(), target);
  }

  // repeated int32 status_codes = 2;
  for (int i = 0, n = this->_internal_status_codes_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_status_codes(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.MacCertEvidenceInfo)
  return target;
}

size_t MacCertEvidenceInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.MacCertEvidenceInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 status_codes = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->status_codes_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_status_codes_size());
    total_size += data_size;
  }

  // optional uint32 status_bits = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_status_bits());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MacCertEvidenceInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MacCertEvidenceInfo*>(
      &from));
}

void MacCertEvidenceInfo::MergeFrom(const MacCertEvidenceInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.MacCertEvidenceInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  status_codes_.MergeFrom(from.status_codes_);
  if (from._internal_has_status_bits()) {
    _internal_set_status_bits(from._internal_status_bits());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MacCertEvidenceInfo::CopyFrom(const MacCertEvidenceInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.MacCertEvidenceInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MacCertEvidenceInfo::IsInitialized() const {
  return true;
}

void MacCertEvidenceInfo::InternalSwap(MacCertEvidenceInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  status_codes_.InternalSwap(&other->status_codes_);
  swap(status_bits_, other->status_bits_);
}

std::string MacCertEvidenceInfo::GetTypeName() const {
  return "chrome_browser_ssl.MacCertEvidenceInfo";
}


// ===================================================================

class MacPlatformDebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<MacPlatformDebugInfo>()._has_bits_);
  static void set_has_trust_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_result_code(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

MacPlatformDebugInfo::MacPlatformDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  status_chain_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.MacPlatformDebugInfo)
}
MacPlatformDebugInfo::MacPlatformDebugInfo(const MacPlatformDebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      status_chain_(from.status_chain_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&trust_result_, &from.trust_result_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&trust_result_)) + sizeof(result_code_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.MacPlatformDebugInfo)
}

inline void MacPlatformDebugInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&trust_result_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_code_) -
    reinterpret_cast<char*>(&trust_result_)) + sizeof(result_code_));
}

MacPlatformDebugInfo::~MacPlatformDebugInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.MacPlatformDebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void MacPlatformDebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void MacPlatformDebugInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void MacPlatformDebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.MacPlatformDebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  status_chain_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&trust_result_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_code_) -
        reinterpret_cast<char*>(&trust_result_)) + sizeof(result_code_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* MacPlatformDebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 trust_result = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_trust_result(&has_bits);
          trust_result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 result_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_result_code(&has_bits);
          result_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_status_chain(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* MacPlatformDebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.MacPlatformDebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 trust_result = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_trust_result(), target);
  }

  // optional int32 result_code = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_result_code(), target);
  }

  // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_status_chain_size()); i < n; i++) {
    const auto& repfield = this->_internal_status_chain(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.MacPlatformDebugInfo)
  return target;
}

size_t MacPlatformDebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.MacPlatformDebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .chrome_browser_ssl.MacCertEvidenceInfo status_chain = 3;
  total_size += 1UL * this->_internal_status_chain_size();
  for (const auto& msg : this->status_chain_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 trust_result = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_trust_result());
    }

    // optional int32 result_code = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_result_code());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void MacPlatformDebugInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const MacPlatformDebugInfo*>(
      &from));
}

void MacPlatformDebugInfo::MergeFrom(const MacPlatformDebugInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.MacPlatformDebugInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  status_chain_.MergeFrom(from.status_chain_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      trust_result_ = from.trust_result_;
    }
    if (cached_has_bits & 0x00000002u) {
      result_code_ = from.result_code_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void MacPlatformDebugInfo::CopyFrom(const MacPlatformDebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.MacPlatformDebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MacPlatformDebugInfo::IsInitialized() const {
  return true;
}

void MacPlatformDebugInfo::InternalSwap(MacPlatformDebugInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  status_chain_.InternalSwap(&other->status_chain_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(MacPlatformDebugInfo, result_code_)
      + sizeof(MacPlatformDebugInfo::result_code_)
      - PROTOBUF_FIELD_OFFSET(MacPlatformDebugInfo, trust_result_)>(
          reinterpret_cast<char*>(&trust_result_),
          reinterpret_cast<char*>(&other->trust_result_));
}

std::string MacPlatformDebugInfo::GetTypeName() const {
  return "chrome_browser_ssl.MacPlatformDebugInfo";
}


// ===================================================================

class WinPlatformDebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<WinPlatformDebugInfo>()._has_bits_);
  static void set_has_authroot_this_update_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_authroot_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

WinPlatformDebugInfo::WinPlatformDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.WinPlatformDebugInfo)
}
WinPlatformDebugInfo::WinPlatformDebugInfo(const WinPlatformDebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  authroot_sequence_number_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    authroot_sequence_number_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_authroot_sequence_number()) {
    authroot_sequence_number_.Set(from._internal_authroot_sequence_number(), 
      GetArenaForAllocation());
  }
  authroot_this_update_time_usec_ = from.authroot_this_update_time_usec_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.WinPlatformDebugInfo)
}

inline void WinPlatformDebugInfo::SharedCtor() {
authroot_sequence_number_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  authroot_sequence_number_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
authroot_this_update_time_usec_ = int64_t{0};
}

WinPlatformDebugInfo::~WinPlatformDebugInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.WinPlatformDebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void WinPlatformDebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  authroot_sequence_number_.Destroy();
}

void WinPlatformDebugInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void WinPlatformDebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.WinPlatformDebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    authroot_sequence_number_.ClearNonDefaultToEmpty();
  }
  authroot_this_update_time_usec_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* WinPlatformDebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 authroot_this_update_time_usec = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_authroot_this_update_time_usec(&has_bits);
          authroot_this_update_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes authroot_sequence_number = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_authroot_sequence_number();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* WinPlatformDebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.WinPlatformDebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 authroot_this_update_time_usec = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_authroot_this_update_time_usec(), target);
  }

  // optional bytes authroot_sequence_number = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_authroot_sequence_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.WinPlatformDebugInfo)
  return target;
}

size_t WinPlatformDebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.WinPlatformDebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes authroot_sequence_number = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_authroot_sequence_number());
    }

    // optional int64 authroot_this_update_time_usec = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_authroot_this_update_time_usec());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void WinPlatformDebugInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const WinPlatformDebugInfo*>(
      &from));
}

void WinPlatformDebugInfo::MergeFrom(const WinPlatformDebugInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.WinPlatformDebugInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_authroot_sequence_number(from._internal_authroot_sequence_number());
    }
    if (cached_has_bits & 0x00000002u) {
      authroot_this_update_time_usec_ = from.authroot_this_update_time_usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void WinPlatformDebugInfo::CopyFrom(const WinPlatformDebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.WinPlatformDebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WinPlatformDebugInfo::IsInitialized() const {
  return true;
}

void WinPlatformDebugInfo::InternalSwap(WinPlatformDebugInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &authroot_sequence_number_, lhs_arena,
      &other->authroot_sequence_number_, rhs_arena
  );
  swap(authroot_this_update_time_usec_, other->authroot_this_update_time_usec_);
}

std::string WinPlatformDebugInfo::GetTypeName() const {
  return "chrome_browser_ssl.WinPlatformDebugInfo";
}


// ===================================================================

class ChromeRootStoreDebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromeRootStoreDebugInfo>()._has_bits_);
  static void set_has_chrome_root_store_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChromeRootStoreDebugInfo::ChromeRootStoreDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.ChromeRootStoreDebugInfo)
}
ChromeRootStoreDebugInfo::ChromeRootStoreDebugInfo(const ChromeRootStoreDebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  chrome_root_store_version_ = from.chrome_root_store_version_;
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.ChromeRootStoreDebugInfo)
}

inline void ChromeRootStoreDebugInfo::SharedCtor() {
chrome_root_store_version_ = int64_t{0};
}

ChromeRootStoreDebugInfo::~ChromeRootStoreDebugInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromeRootStoreDebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ChromeRootStoreDebugInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChromeRootStoreDebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  chrome_root_store_version_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromeRootStoreDebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 chrome_root_store_version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_chrome_root_store_version(&has_bits);
          chrome_root_store_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromeRootStoreDebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 chrome_root_store_version = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_chrome_root_store_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  return target;
}

size_t ChromeRootStoreDebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int64 chrome_root_store_version = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_chrome_root_store_version());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromeRootStoreDebugInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromeRootStoreDebugInfo*>(
      &from));
}

void ChromeRootStoreDebugInfo::MergeFrom(const ChromeRootStoreDebugInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_chrome_root_store_version()) {
    _internal_set_chrome_root_store_version(from._internal_chrome_root_store_version());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromeRootStoreDebugInfo::CopyFrom(const ChromeRootStoreDebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.ChromeRootStoreDebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromeRootStoreDebugInfo::IsInitialized() const {
  return true;
}

void ChromeRootStoreDebugInfo::InternalSwap(ChromeRootStoreDebugInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(chrome_root_store_version_, other->chrome_root_store_version_);
}

std::string ChromeRootStoreDebugInfo::GetTypeName() const {
  return "chrome_browser_ssl.ChromeRootStoreDebugInfo";
}


// ===================================================================

class TrialVerificationInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<TrialVerificationInfo>()._has_bits_);
  static void set_has_cert_chain(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_issued_by_known_root(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_mac_trust_impl(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_trial_verification_time_usec(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_trial_der_verification_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::chrome_browser_ssl::MacPlatformDebugInfo& mac_platform_debug_info(const TrialVerificationInfo* msg);
  static void set_has_mac_platform_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_stapled_ocsp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_sct_list(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::chrome_browser_ssl::WinPlatformDebugInfo& win_platform_debug_info(const TrialVerificationInfo* msg);
  static void set_has_win_platform_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::chrome_browser_ssl::ChromeRootStoreDebugInfo& chrome_root_store_debug_info(const TrialVerificationInfo* msg);
  static void set_has_chrome_root_store_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::chrome_browser_ssl::MacPlatformDebugInfo&
TrialVerificationInfo::_Internal::mac_platform_debug_info(const TrialVerificationInfo* msg) {
  return *msg->mac_platform_debug_info_;
}
const ::chrome_browser_ssl::WinPlatformDebugInfo&
TrialVerificationInfo::_Internal::win_platform_debug_info(const TrialVerificationInfo* msg) {
  return *msg->win_platform_debug_info_;
}
const ::chrome_browser_ssl::ChromeRootStoreDebugInfo&
TrialVerificationInfo::_Internal::chrome_root_store_debug_info(const TrialVerificationInfo* msg) {
  return *msg->chrome_root_store_debug_info_;
}
TrialVerificationInfo::TrialVerificationInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  public_key_hash_(arena),
  cert_error_(arena),
  cert_status_(arena),
  verify_flags_(arena),
  mac_combined_trust_debug_info_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:chrome_browser_ssl.TrialVerificationInfo)
}
TrialVerificationInfo::TrialVerificationInfo(const TrialVerificationInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      public_key_hash_(from.public_key_hash_),
      cert_error_(from.cert_error_),
      cert_status_(from.cert_status_),
      verify_flags_(from.verify_flags_),
      mac_combined_trust_debug_info_(from.mac_combined_trust_debug_info_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  cert_chain_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cert_chain_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert_chain()) {
    cert_chain_.Set(from._internal_cert_chain(), 
      GetArenaForAllocation());
  }
  trial_der_verification_time_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    trial_der_verification_time_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_trial_der_verification_time()) {
    trial_der_verification_time_.Set(from._internal_trial_der_verification_time(), 
      GetArenaForAllocation());
  }
  stapled_ocsp_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    stapled_ocsp_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_stapled_ocsp()) {
    stapled_ocsp_.Set(from._internal_stapled_ocsp(), 
      GetArenaForAllocation());
  }
  sct_list_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sct_list_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sct_list()) {
    sct_list_.Set(from._internal_sct_list(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_mac_platform_debug_info()) {
    mac_platform_debug_info_ = new ::chrome_browser_ssl::MacPlatformDebugInfo(*from.mac_platform_debug_info_);
  } else {
    mac_platform_debug_info_ = nullptr;
  }
  if (from._internal_has_win_platform_debug_info()) {
    win_platform_debug_info_ = new ::chrome_browser_ssl::WinPlatformDebugInfo(*from.win_platform_debug_info_);
  } else {
    win_platform_debug_info_ = nullptr;
  }
  if (from._internal_has_chrome_root_store_debug_info()) {
    chrome_root_store_debug_info_ = new ::chrome_browser_ssl::ChromeRootStoreDebugInfo(*from.chrome_root_store_debug_info_);
  } else {
    chrome_root_store_debug_info_ = nullptr;
  }
  ::memcpy(&trial_verification_time_usec_, &from.trial_verification_time_usec_,
    static_cast<size_t>(reinterpret_cast<char*>(&mac_trust_impl_) -
    reinterpret_cast<char*>(&trial_verification_time_usec_)) + sizeof(mac_trust_impl_));
  // @@protoc_insertion_point(copy_constructor:chrome_browser_ssl.TrialVerificationInfo)
}

inline void TrialVerificationInfo::SharedCtor() {
cert_chain_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cert_chain_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
trial_der_verification_time_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  trial_der_verification_time_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
stapled_ocsp_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  stapled_ocsp_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sct_list_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sct_list_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&mac_platform_debug_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mac_trust_impl_) -
    reinterpret_cast<char*>(&mac_platform_debug_info_)) + sizeof(mac_trust_impl_));
}

TrialVerificationInfo::~TrialVerificationInfo() {
  // @@protoc_insertion_point(destructor:chrome_browser_ssl.TrialVerificationInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TrialVerificationInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  cert_chain_.Destroy();
  trial_der_verification_time_.Destroy();
  stapled_ocsp_.Destroy();
  sct_list_.Destroy();
  if (this != internal_default_instance()) delete mac_platform_debug_info_;
  if (this != internal_default_instance()) delete win_platform_debug_info_;
  if (this != internal_default_instance()) delete chrome_root_store_debug_info_;
}

void TrialVerificationInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TrialVerificationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:chrome_browser_ssl.TrialVerificationInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  public_key_hash_.Clear();
  cert_error_.Clear();
  cert_status_.Clear();
  verify_flags_.Clear();
  mac_combined_trust_debug_info_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      cert_chain_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      trial_der_verification_time_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      stapled_ocsp_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      sct_list_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(mac_platform_debug_info_ != nullptr);
      mac_platform_debug_info_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(win_platform_debug_info_ != nullptr);
      win_platform_debug_info_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(chrome_root_store_debug_info_ != nullptr);
      chrome_root_store_debug_info_->Clear();
    }
  }
  trial_verification_time_usec_ = int64_t{0};
  if (cached_has_bits & 0x00000300u) {
    ::memset(&is_issued_by_known_root_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mac_trust_impl_) -
        reinterpret_cast<char*>(&is_issued_by_known_root_)) + sizeof(mac_trust_impl_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TrialVerificationInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cert_chain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cert_chain();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string public_key_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_public_key_hash();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid(val))) {
              _internal_add_cert_error(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertError>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_cert_error(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertError_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_issued_by_known_root = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_issued_by_known_root(&has_bits);
          is_issued_by_known_root_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid(val))) {
              _internal_add_cert_status(static_cast<::chrome_browser_ssl::CertLoggerRequest_CertStatus>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_cert_status(), ptr, ctx, ::chrome_browser_ssl::CertLoggerRequest_CertStatus_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags_IsValid(val))) {
              _internal_add_verify_flags(static_cast<::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_verify_flags(), ptr, ctx, ::chrome_browser_ssl::TrialVerificationInfo_VerifyFlags_IsValid, &_internal_metadata_, 6);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags_IsValid(val))) {
              _internal_add_mac_combined_trust_debug_info(static_cast<::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_mac_combined_trust_debug_info(), ptr, ctx, ::chrome_browser_ssl::TrialVerificationInfo_MacTrustFlags_IsValid, &_internal_metadata_, 7);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 trial_verification_time_usec = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_trial_verification_time_usec(&has_bits);
          trial_verification_time_usec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string trial_der_verification_time = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_trial_der_verification_time();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_mac_platform_debug_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes stapled_ocsp = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_stapled_ocsp();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes sct_list = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_sct_list();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.TrialVerificationInfo.MacTrustImplType mac_trust_impl = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::chrome_browser_ssl::TrialVerificationInfo_MacTrustImplType_IsValid(val))) {
            _internal_set_mac_trust_impl(static_cast<::chrome_browser_ssl::TrialVerificationInfo_MacTrustImplType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.WinPlatformDebugInfo win_platform_debug_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_win_platform_debug_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .chrome_browser_ssl.ChromeRootStoreDebugInfo chrome_root_store_debug_info = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_chrome_root_store_debug_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TrialVerificationInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:chrome_browser_ssl.TrialVerificationInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cert_chain = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cert_chain(), target);
  }

  // repeated string public_key_hash = 2;
  for (int i = 0, n = this->_internal_public_key_hash_size(); i < n; i++) {
    const auto& s = this->_internal_public_key_hash(i);
    target = stream->WriteString(2, s, target);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
  for (int i = 0, n = this->_internal_cert_error_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_cert_error(i), target);
  }

  // optional bool is_issued_by_known_root = 4;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_issued_by_known_root(), target);
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
  for (int i = 0, n = this->_internal_cert_status_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_cert_status(i), target);
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
  for (int i = 0, n = this->_internal_verify_flags_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_verify_flags(i), target);
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
  for (int i = 0, n = this->_internal_mac_combined_trust_debug_info_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_mac_combined_trust_debug_info(i), target);
  }

  // optional int64 trial_verification_time_usec = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_trial_verification_time_usec(), target);
  }

  // optional string trial_der_verification_time = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_trial_der_verification_time(), target);
  }

  // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::mac_platform_debug_info(this),
        _Internal::mac_platform_debug_info(this).GetCachedSize(), target, stream);
  }

  // optional bytes stapled_ocsp = 11;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        11, this->_internal_stapled_ocsp(), target);
  }

  // optional bytes sct_list = 12;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        12, this->_internal_sct_list(), target);
  }

  // optional .chrome_browser_ssl.TrialVerificationInfo.MacTrustImplType mac_trust_impl = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      13, this->_internal_mac_trust_impl(), target);
  }

  // optional .chrome_browser_ssl.WinPlatformDebugInfo win_platform_debug_info = 14;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::win_platform_debug_info(this),
        _Internal::win_platform_debug_info(this).GetCachedSize(), target, stream);
  }

  // optional .chrome_browser_ssl.ChromeRootStoreDebugInfo chrome_root_store_debug_info = 15;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::chrome_root_store_debug_info(this),
        _Internal::chrome_root_store_debug_info(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:chrome_browser_ssl.TrialVerificationInfo)
  return target;
}

size_t TrialVerificationInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:chrome_browser_ssl.TrialVerificationInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string public_key_hash = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(public_key_hash_.size());
  for (int i = 0, n = public_key_hash_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      public_key_hash_.Get(i));
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertError cert_error = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_cert_error_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_cert_error(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.CertLoggerRequest.CertStatus cert_status = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_cert_status_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_cert_status(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.VerifyFlags verify_flags = 6;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_verify_flags_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_verify_flags(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .chrome_browser_ssl.TrialVerificationInfo.MacTrustFlags mac_combined_trust_debug_info = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_mac_combined_trust_debug_info_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_mac_combined_trust_debug_info(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string cert_chain = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cert_chain());
    }

    // optional string trial_der_verification_time = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_trial_der_verification_time());
    }

    // optional bytes stapled_ocsp = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_stapled_ocsp());
    }

    // optional bytes sct_list = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_sct_list());
    }

    // optional .chrome_browser_ssl.MacPlatformDebugInfo mac_platform_debug_info = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *mac_platform_debug_info_);
    }

    // optional .chrome_browser_ssl.WinPlatformDebugInfo win_platform_debug_info = 14;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *win_platform_debug_info_);
    }

    // optional .chrome_browser_ssl.ChromeRootStoreDebugInfo chrome_root_store_debug_info = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *chrome_root_store_debug_info_);
    }

    // optional int64 trial_verification_time_usec = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_trial_verification_time_usec());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool is_issued_by_known_root = 4;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional .chrome_browser_ssl.TrialVerificationInfo.MacTrustImplType mac_trust_impl = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_mac_trust_impl());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TrialVerificationInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TrialVerificationInfo*>(
      &from));
}

void TrialVerificationInfo::MergeFrom(const TrialVerificationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:chrome_browser_ssl.TrialVerificationInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  public_key_hash_.MergeFrom(from.public_key_hash_);
  cert_error_.MergeFrom(from.cert_error_);
  cert_status_.MergeFrom(from.cert_status_);
  verify_flags_.MergeFrom(from.verify_flags_);
  mac_combined_trust_debug_info_.MergeFrom(from.mac_combined_trust_debug_info_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_cert_chain(from._internal_cert_chain());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_trial_der_verification_time(from._internal_trial_der_verification_time());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_stapled_ocsp(from._internal_stapled_ocsp());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_sct_list(from._internal_sct_list());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_mac_platform_debug_info()->::chrome_browser_ssl::MacPlatformDebugInfo::MergeFrom(from._internal_mac_platform_debug_info());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_win_platform_debug_info()->::chrome_browser_ssl::WinPlatformDebugInfo::MergeFrom(from._internal_win_platform_debug_info());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_chrome_root_store_debug_info()->::chrome_browser_ssl::ChromeRootStoreDebugInfo::MergeFrom(from._internal_chrome_root_store_debug_info());
    }
    if (cached_has_bits & 0x00000080u) {
      trial_verification_time_usec_ = from.trial_verification_time_usec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      is_issued_by_known_root_ = from.is_issued_by_known_root_;
    }
    if (cached_has_bits & 0x00000200u) {
      mac_trust_impl_ = from.mac_trust_impl_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TrialVerificationInfo::CopyFrom(const TrialVerificationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:chrome_browser_ssl.TrialVerificationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrialVerificationInfo::IsInitialized() const {
  return true;
}

void TrialVerificationInfo::InternalSwap(TrialVerificationInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  public_key_hash_.InternalSwap(&other->public_key_hash_);
  cert_error_.InternalSwap(&other->cert_error_);
  cert_status_.InternalSwap(&other->cert_status_);
  verify_flags_.InternalSwap(&other->verify_flags_);
  mac_combined_trust_debug_info_.InternalSwap(&other->mac_combined_trust_debug_info_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cert_chain_, lhs_arena,
      &other->cert_chain_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &trial_der_verification_time_, lhs_arena,
      &other->trial_der_verification_time_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &stapled_ocsp_, lhs_arena,
      &other->stapled_ocsp_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sct_list_, lhs_arena,
      &other->sct_list_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(TrialVerificationInfo, mac_trust_impl_)
      + sizeof(TrialVerificationInfo::mac_trust_impl_)
      - PROTOBUF_FIELD_OFFSET(TrialVerificationInfo, mac_platform_debug_info_)>(
          reinterpret_cast<char*>(&mac_platform_debug_info_),
          reinterpret_cast<char*>(&other->mac_platform_debug_info_));
}

std::string TrialVerificationInfo::GetTypeName() const {
  return "chrome_browser_ssl.TrialVerificationInfo";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace chrome_browser_ssl
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerInterstitialInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerInterstitialInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::CertLoggerInterstitialInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::CertLoggerFeaturesInfo_NetworkTimeQueryingInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerFeaturesInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerFeaturesInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::CertLoggerFeaturesInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::CertLoggerRequest*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::CertLoggerRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::CertLoggerRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::MacCertEvidenceInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::MacCertEvidenceInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::MacCertEvidenceInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::MacPlatformDebugInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::MacPlatformDebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::MacPlatformDebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::WinPlatformDebugInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::WinPlatformDebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::WinPlatformDebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::ChromeRootStoreDebugInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::ChromeRootStoreDebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::ChromeRootStoreDebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::chrome_browser_ssl::TrialVerificationInfo*
Arena::CreateMaybeMessage< ::chrome_browser_ssl::TrialVerificationInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::chrome_browser_ssl::TrialVerificationInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
