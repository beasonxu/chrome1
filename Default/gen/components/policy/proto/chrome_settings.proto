//
// DO NOT MODIFY THIS FILE DIRECTLY!
// IT IS GENERATED BY generate_policy_source.py
// FROM gen/chrome/app/policy/policy_templates.json
//


syntax = "proto2";

option optimize_for = LITE_RUNTIME;

package enterprise_management;

option go_package="chromium/policy/enterprise_management_proto";

// For StringList and PolicyOptions.
import "policy_common_definitions.proto";

// PBs for individual settings.

// Configure the home page URL
//
// Setting the policy sets the default homepage URL in Google Chrome. You open
// the homepage using the Home button. On desktop, the RestoreOnStartup policies
// control the pages that open on startup.
//
// If the homepage is set to the New Tab Page, by the user or
// HomepageIsNewTabPage, this policy has no effect.
//
// The URL needs a standard scheme, such as http://example.com or
// https://example.com. When this policy is set, users can't change their
// homepage URL in Google Chrome.
//
// Leaving both HomepageLocation and HomepageIsNewTabPage unset lets users
// choose their homepage.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain domain, running on
// Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS,
// this functionality is only available on instances that are managed via MDM,
// or joined to a domain via MCX.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message HomepageLocationProto {
  optional PolicyOptions policy_options = 1;
  optional string HomepageLocation = 2;
}

// Use New Tab Page as homepage
//
// Setting the policy to Enabled makes the New Tab page the user's homepage,
// ignoring any homepage URL location. Setting the policy to Disabled means that
// their homepage is never the New Tab page, unless the user's homepage URL is
// set to chrome://newtab.
//
// If you set the policy, users can't change their homepage type in Google
// Chrome. If not set, the user decides whether or not the New Tab page is their
// homepage.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain domain, running on
// Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS,
// this functionality is only available on instances that are managed via MDM,
// or joined to a domain via MCX.
//
// Valid values:
//   True: Use New Tab Page as homepage
//   False: Do not use New Tab Page as homepage
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message HomepageIsNewTabPageProto {
  optional PolicyOptions policy_options = 1;
  optional bool HomepageIsNewTabPage = 2;
}

// Configure the New Tab page URL
//
// Setting the policy configures the default New Tab page URL and prevents users
// from changing it.
//
// The New Tab page opens with new tabs and windows.
//
// This policy doesn't decide which pages open on start up. Those are controlled
// by the RestoreOnStartup policies. This policy does affect the homepage, if
// that's set to open the New Tab page, as well as the startup page if it's set
// to open the New Tab page.
//
// It is a best practice to provide fully canonicalized URL, if the URL is not
// fully canonicalized Google Chrome will default to https://.
//
// Leaving the policy unset or empty puts the default New Tab page in use.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain domain, running on
// Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS,
// this functionality is only available on instances that are managed via MDM,
// or joined to a domain via MCX.
//
// Supported on: chrome_os, fuchsia, ios, linux, mac, win
message NewTabPageLocationProto {
  optional PolicyOptions policy_options = 1;
  optional string NewTabPageLocation = 2;
}

// Set Google Chrome as Default Browser
//
// Setting the policy to True has Google Chrome always check whether it's the
// default browser on startup and, if possible, automatically register itself.
// Setting the policy to False stops Google Chrome from ever checking if it's
// the default and turns user controls off for this option.
//
// Leaving the policy unset means Google Chrome lets users control whether it's
// the default and, if not, whether user notifications should appear.
//
// Note: For Microsoft®Windows® administrators, turning this setting on only
// works for machines running Windows 7. For later versions, you must deploy a
// "default application associations" file that makes Google Chrome the handler
// for the https and http protocols (and, optionally, the ftp protocol and other
// file formats). See Chrome Help (
// https://support.google.com/chrome?p=make_chrome_default_win ).
//
// Valid values:
//   True: Enable the default browser check on startup
//   False: Disable the default browser check on startup
//
// Supported on: fuchsia, linux, mac, win
message DefaultBrowserSettingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DefaultBrowserSettingEnabled = 2;
}

// Application locale
//
// Setting the policy specifies the locale Google Chrome uses.
//
// Turning it off or leaving it unset means the locale will be the first valid
// locale from:
// 1) The user specified locale (if configured).
// 2) The system locale.
// 3) The fallback locale (en-US).
//
// Supported on: win
message ApplicationLocaleValueProto {
  optional PolicyOptions policy_options = 1;
  optional string ApplicationLocaleValue = 2;
}

// Enable alternate error pages
//
// Setting the policy to True means Google Chrome uses alternate error pages
// built into (such as "page not found"). Setting the policy to False means
// Google Chrome never uses alternate error pages.
//
// If you set the policy, users can't change it. If not set, the policy is on,
// but users can change this setting.
//
// Valid values:
//   True: Enable alternate error pages
//   False: Disable alternate error pages
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AlternateErrorPagesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AlternateErrorPagesEnabled = 2;
}

// Enable search suggestions
//
// Setting the policy to True turns on search suggestions in Google Chrome's
// address bar. Setting the policy to False turns off these search suggestions.
//
// Suggestions based on bookmarks or history are unaffected by the policy.
//
// If you set the policy, users can't change it. If not set, search suggestions
// are on at first, but users can turn them off any time.
//
// Valid values:
//   True: Enable search suggestions
//   False: Disable search suggestions
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message SearchSuggestEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SearchSuggestEnabled = 2;
}

// Enable Native Window Occlusion
//
// This policy is deprecated, please use the 'WindowOcclusionEnabled' policy
// instead.
//
// Enables native window occlusion in Google Chrome.
//
// If you enable this setting, to reduce CPU and power consumption Google Chrome
// will detect when a window is covered by other windows, and will suspend work
// painting pixels.
//
// If you disable this setting Google Chrome will not detect when a window is
// covered by other windows.
//
// If this policy is left not set, occlusion detection will be enabled.
//
// Valid values:
//   True: Detect covered window and suspend its painting
//   False: Do not detect covered window
//
// Supported on:
message NativeWindowOcclusionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NativeWindowOcclusionEnabled = 2;
}

// Enable Window Occlusion
//
// Enables window occlusion in Google Chrome.
//
// If you enable this setting, to reduce CPU and power consumption Google Chrome
// will detect when a window is covered by other windows, and will suspend work
// painting pixels.
//
// If you disable this setting Google Chrome will not detect when a window is
// covered by other windows.
//
// If this policy is left not set, occlusion detection will be enabled.
//
// Valid values:
//   True: Detect covered window and suspend its painting
//   False: Do not detect covered window
//
// Supported on: win
message WindowOcclusionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WindowOcclusionEnabled = 2;
}

// Enable network prediction
//
// This policy is deprecated in M48 in favor of NetworkPredictionOptions, and
// removed in M54.
//
// Enables network prediction in Google Chrome and prevents users from changing
// this setting.
//
// This controls not only DNS prefetching but also TCP and SSL preconnection and
// prerendering of web pages. The policy name refers to DNS prefetching for
// historical reasons.
//
// If you enable or disable this setting, users cannot change or override this
// setting in Google Chrome.
//
// If this policy is left not set, this will be enabled but the user will be
// able to change it.
//
// Supported on:
message DnsPrefetchingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DnsPrefetchingEnabled = 2;
}

// Enable network prediction
//
// This policy controls network prediction in Google Chrome. It controls DNS
// prefetching, TCP, and SSL preconnection and prerendering of webpages.
//
// If you set the policy, users can't change it. Leaving it unset turns on
// network prediction, but the user can change it.
//
// Valid values:
//   0: Predict network actions on any network connection
//   1: Predict network actions on any network that is not cellular.
//           (Deprecated in 50, removed in 52. After 52, if value 1 is set, it
// will be treated as 0 - predict network actions on any network connection.)
//   2: Do not predict network actions on any network connection
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message NetworkPredictionOptionsProto {
  optional PolicyOptions policy_options = 1;
  optional int64 NetworkPredictionOptions = 2;
}

// Enable WPAD optimization
//
// Setting the policy to Enabled or leaving it unset turns on WPAD (Web Proxy
// Auto-Discovery) optimization in Google Chrome.
//
// Setting the policy to Disabled turns off WPAD optimization, causing Google
// Chrome to wait longer for DNS-based WPAD servers.
//
// Whether or not this policy is set, users can't change the WPAD optimization
// setting.
//
// Valid values:
//   True: Enable Web Proxy Auto-Discovery (WPAD) optimizations
//   False: Disable Web Proxy Auto-Discovery (WPAD) optimization
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WPADQuickCheckEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WPADQuickCheckEnabled = 2;
}

// Disable SPDY protocol
//
// This policy is deprecated in M53 and removed in M54, because SPDY/3.1 support
// is removed.
//
// Disables use of the SPDY protocol in Google Chrome.
//
// If this policy is enabled the SPDY protocol will not be available in Google
// Chrome.
//
// Setting this policy to disabled will allow the usage of SPDY.
//
// If this policy is left not set, SPDY will be available.
//
// Supported on:
message DisableSpdyProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisableSpdy = 2;
}

// Disable URL protocol schemes
//
// This policy is deprecated, please use URLBlocklist instead.
//
// Disables the listed protocol schemes in Google Chrome.
//
// URLs using a scheme from this list will not load and can not be navigated to.
//
// If this policy is left not set or the list is empty all schemes will be
// accessible in Google Chrome.
//
// Supported on: chrome_os, linux, mac, win
message DisabledSchemesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList DisabledSchemes = 2;
}

// Enables auto-select for multi screen captures
//
// The getDisplayMediaSet API allows web applications to capture multiple
// surfaces at once.
// This policy unlocks the autoSelectAllScreens property for web applications at
// defined origins.
// If the autoSelectAllScreens property is defined in a getDisplayMediaSet
// request, all screen surfaces are automatically captured without requiring
// explicit user permission.
// If the policy is not set, autoSelectAllScreens is not available for any web
// application.
//
// Supported on: chrome_os
message GetDisplayMediaSetSelectAllScreensAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList GetDisplayMediaSetSelectAllScreensAllowedForUrls = 2;
}

// Enable globally scoped HTTP auth cache
//
// This policy configures a single global per profile cache with HTTP server
// authentication credentials.
//
// If this policy is unset or disabled, the browser will use the default
// behavior of cross-site auth, which as of version 80, will be to scope HTTP
// server authentication credentials by top-level site, so if two sites use
// resources from the same authenticating domain, credentials will need to be
// provided independently in the context of both sites. Cached proxy credentials
// will be reused across sites.
//
// If the policy is enabled, HTTP auth credentials entered in the context of one
// site will automatically be used in the context of another.
//
// Enabling this policy leaves sites open to some types of cross-site attacks,
// and allows users to be tracked across sites even without cookies by adding
// entries to the HTTP auth cache using credentials embedded in URLs.
//
// This policy is intended to give enterprises depending on the legacy behavior
// a chance to update their login procedures, and will be removed in the future.
//
// Valid values:
//   True: Enable globally scoped HTTP authentication cache
//   False: Disable globally scoped HTTP authentication cache
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message GloballyScopeHTTPAuthCacheEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool GloballyScopeHTTPAuthCacheEnabled = 2;
}

// DNS interception checks enabled
//
// This policy configures a local switch that can be used to disable DNS
// interception checks. The checks attempt to discover whether the browser is
// behind a proxy that redirects unknown host names.
//
// This detection may not be necessary in an enterprise environment where the
// network configuration is known, since it causes some amount of DNS and HTTP
// traffic on start-up and each DNS configuration change.
//
// When this policy is not set, or is enabled, the DNS interception checks are
// performed. When explicitly disabled, they're not.
//
// Valid values:
//   True: Perform DNS interception checks
//   False: Do not perform DNS interception checks
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DNSInterceptionChecksEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DNSInterceptionChecksEnabled = 2;
}

// Intranet Redirection Behavior
//
// This policy configures behavior for intranet redirection via DNS interception
// checks. The checks attempt to discover whether the browser is behind a proxy
// that redirects unknown host names.
//
// If this policy is not set, the browser will use the default behavior of DNS
// interception checks and intranet redirect suggestions. In M88, they are
// enabled by default but will be disabled by default in the future release.
//
// DNSInterceptionChecksEnabled is a related policy that may also disable DNS
// interception checks; this policy is a more flexible version which may
// separately control intranet redirection infobars and may be expanded in the
// future.
// If either DNSInterceptionChecksEnabled or this policy requests to disable
// interception checks, the checks will be disabled.
//
// Valid values:
//   0: Use default browser behavior.
//   1: Disable DNS interception checks and did-you-mean "http://intranetsite/"
// infobars.
//   2: Disable DNS interception checks; allow did-you-mean
// "http://intranetsite/" infobars.
//   3: Allow DNS interception checks and did-you-mean "http://intranetsite/"
// infobars.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message IntranetRedirectBehaviorProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IntranetRedirectBehavior = 2;
}

// Enable HTTP/0.9 support on non-default ports
//
// This policy is deprecated, and slated for removal in Chrome 78, with no
// replacement.
//
// This policy enables HTTP/0.9 on ports other than 80 for HTTP and 443 for
// HTTPS.
//
// This policy is disabled by default, and if enabled, leaves users open to the
// security issue https://crbug.com/600352.
//
// This policy is intended to give enterprises a chance to migrate exising
// servers off of HTTP/0.9, and will be removed in the future.
//
// If this policy is not set, HTTP/0.9 will be disabled on non-default ports.
//
// Valid values:
//   True: Enable HTTP/0.9 support on non-default ports
//   False: Disable HTTP/0.9 support on non-default ports
//
// Supported on:
message Http09OnNonDefaultPortsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool Http09OnNonDefaultPortsEnabled = 2;
}

// Enable JavaScript
//
// This policy is deprecated, please use DefaultJavaScriptSetting instead.
//
// Can be used to disabled JavaScript in Google Chrome.
//
// If this setting is disabled, web pages cannot use JavaScript and the user
// cannot change that setting.
//
// If this setting is enabled or not set, web pages can use JavaScript but the
// user can change that setting.
//
// Valid values:
//   True: Enable JavaScript
//   False: Disable JavaScript
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message JavascriptEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool JavascriptEnabled = 2;
}

// Enable Incognito mode
//
// This policy is deprecated. Please, use IncognitoModeAvailability instead.
// Enables Incognito mode in Google Chrome.
//
// If this setting is enabled or not configured, users can open web pages in
// incognito mode.
//
// If this setting is disabled, users cannot open web pages in incognito mode.
//
// If this policy is left not set, this will be enabled and the user will be
// able to use incognito mode.
//
// Valid values:
//   True: Enable Incognito mode
//   False: Disable Incognito mode
//
// Supported on: android, chrome_os, linux, mac, win
message IncognitoEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool IncognitoEnabled = 2;
}

// Incognito mode availability
//
// Specifies whether the user may open pages in Incognito mode in Google Chrome.
//
// If 'Enabled' is selected or the policy is left unset, pages may be opened in
// Incognito mode.
//
// If 'Disabled' is selected, pages may not be opened in Incognito mode.
//
// If 'Forced' is selected, pages may be opened ONLY in Incognito mode. Note
// that 'Forced' does not work for Android-on-Chrome
//
// Note: On iOS, if the policy is changed during a session, it will only take
// effect on relaunch.
//
// Valid values:
//   0: Incognito mode available
//   1: Incognito mode disabled
//   2: Incognito mode forced
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message IncognitoModeAvailabilityProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IncognitoModeAvailability = 2;
}

// Disable saving browser history
//
// Setting the policy to Enabled means browsing history is not saved, tab
// syncing is off and users can't change this setting.
//
// Setting the policy to Disabled or leaving it unset saves browsing history.
//
// Valid values:
//   True: Disable saving browser history
//   False: Enable saving browser history
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message SavingBrowserHistoryDisabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SavingBrowserHistoryDisabled = 2;
}

// Enable deleting browser and download history
//
// Setting the policy to Enabled or leaving it unset means browser history and
// download history can be deleted in Chrome, and users can't change this
// setting.
//
// Setting the policy to Disabled means browser history and download history
// can't be deleted. Even with this policy off, the browsing and download
// history are not guaranteed to be retained. Users may be able to edit or
// delete the history database files directly, and the browser itself may expire
// or archive any or all history items at any time.
//
// Valid values:
//   True: Enable deleting browser and download history
//   False: Disable deleting browser and download history
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AllowDeletingBrowserHistoryProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowDeletingBrowserHistory = 2;
}

// Show Journeys on the Chrome history page
//
// This policy controls the visibility of Journeys on the Chrome history page.
//
// If the policy is set to Enabled, Journeys will be visible at
// chrome://history/journeys.
//
// If the policy is set to Disabled, Journeys will not be visible at
// chrome://history/journeys.
//
// If the policy is left unset, Journeys will be visible at
// chrome://history/journeys by default and users can change the visibility of
// Journeys.
//
// Please note, if ComponentUpdatesEnabled policy is set to Disabled, but
// HistoryClustersVisible is set to Enabled or unset, Journeys will still be
// available at chrome://history/journeys, but may be absent from the omnibox,
// and less relevant to the user.
//
// Valid values:
//   True: Journeys will be visible at chrome://history/journeys.
//   False: Journeys will not be visible at chrome://history/journeys.
//   None: Journeys will be visible at chrome://history/journeys by default and
// users can change the visibility of Journeys.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message HistoryClustersVisibleProto {
  optional PolicyOptions policy_options = 1;
  optional bool HistoryClustersVisible = 2;
}

// Allow Dinosaur Easter Egg Game
//
// Setting the policy to True allows users to play the dinosaur game. Setting
// the policy to False means users can't play the dinosaur easter egg game when
// device is offline.
//
// Leaving the policy unset means users can't play the game on enrolled Google
// ChromeOS, but can under other circumstances.
//
// Valid values:
//   True: Enable dinosaur easter egg game
//   False: Disable dinosaur easter egg game
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AllowDinosaurEasterEggProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowDinosaurEasterEgg = 2;
}

// Use a default referrer policy of no-referrer-when-downgrade.
//
// This enterprise policy is for short-term adaptation and will be removed in
// Google Chrome version 88.
//
// Chrome's default referrer policy is being strengthened from its current value
// of no-referrer-when-downgrade to the more secure strict-origin-when-cross-
// origin through a gradual rollout targeting Chrome 85 stable.
//
// Before the rollout, this enterprise policy will have no effect. After the
// rollout, when this enterprise policy is enabled, Chrome's default referrer
// policy will be set to its previous value of no-referrer-when-downgrade.
//
// This enterprise policy is disabled by default.
//
// Valid values:
//   True: Use a default referrer policy of no-referrer-when-downgrade
//   False: Do not use a default referrer policy of no-referrer-when-downgrade
//
// Supported on:
message ForceLegacyDefaultReferrerPolicyProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceLegacyDefaultReferrerPolicy = 2;
}

// Enable firewall traversal from remote access client
//
// This policy is no longer supported.
// Enables usage of STUN and relay servers when connecting to a remote client.
//
// If this setting is enabled, then this machine can discover and connect to
// remote host machines even if they are separated by a firewall.
//
// If this setting is disabled and outgoing UDP connections are filtered by the
// firewall, then this machine can only connect to host machines within the
// local network.
//
// Supported on:
message RemoteAccessClientFirewallTraversalProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessClientFirewallTraversal = 2;
}

// Configure the required domain name for remote access clients
//
// This policy is deprecated. Please use RemoteAccessHostClientDomainList
// instead.
//
// Supported on: chrome_os, linux, mac, win
message RemoteAccessHostClientDomainProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostClientDomain = 2;
}

// Configure the required domain names for remote access clients
//
// Setting the policy specifies the client domain names that are imposed on
// remote access clients, and users can't change them. Only clients from one of
// the specified domains can connect to the host.
//
// Setting the policy to an empty list or leaving it unset applies the default
// policy for the connection type. For remote assistance, this allows clients
// from any domain to connect to the host. For anytime remote access, only the
// host owner can connect.
//
// See also RemoteAccessHostDomainList.
//
// Note: This setting overrides RemoteAccessHostClientDomain, if present.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostClientDomainListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RemoteAccessHostClientDomainList = 2;
}

// Enable firewall traversal from remote access host
//
// Setting the policy to Enabled or leaving it unset allows the usage of STUN
// servers, letting remote clients discover and connect to this machine, even if
// separated by a firewall.
//
// Setting the policy to Disabled when outgoing UDP connections are filtered by
// the firewall means the machine only allows connections from client machines
// within the local network.
//
// Valid values:
//   True: Enable firewall traversal from remote access host
//   False: Disable firewall traversal from remote access host
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostFirewallTraversalProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostFirewallTraversal = 2;
}

// Configure the required domain name for remote access hosts
//
// This policy is deprecated. Please use RemoteAccessHostDomainList instead.
//
// Supported on: chrome_os, linux, mac, win
message RemoteAccessHostDomainProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostDomain = 2;
}

// Configure the required domain names for remote access hosts
//
// Setting the policy specifies the host domain names that are imposed on remote
// access hosts, and users can't change them. Hosts can be shared only using
// accounts registered on one of the specified domain names.
//
// Setting the policy to an empty list or leaving it unset means hosts can be
// shared using any account.
//
// See also RemoteAccessHostClientDomainList.
//
// Note: This setting will override RemoteAccessHostDomain, if present.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostDomainListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RemoteAccessHostDomainList = 2;
}

// Enable two-factor authentication for remote access hosts
//
// Enables two-factor authentication for remote access hosts instead of a user-
// specified PIN.
//
// If this setting is enabled, then users must provide a valid two-factor code
// when accessing a host.
//
// If this setting is disabled or not set, then two-factor will not be enabled
// and the default behavior of having a user-defined PIN will be used.
//
// Supported on:
message RemoteAccessHostRequireTwoFactorProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostRequireTwoFactor = 2;
}

// Configure the TalkGadget prefix for remote access hosts
//
// Configures the TalkGadget prefix that will be used by remote access hosts and
// prevents users from changing it.
//
// If specified, this prefix is prepended to the base TalkGadget name to create
// a full domain name for the TalkGadget. The base TalkGadget domain name is
// '.talkgadget.google.com'.
//
// If this setting is enabled, then hosts will use the custom domain name when
// accessing the TalkGadget instead of the default domain name.
//
// If this setting is disabled or not set, then the default TalkGadget domain
// name ('chromoting-host.talkgadget.google.com') will be used for all hosts.
//
// Remote access clients are not affected by this policy setting. They will
// always use 'chromoting-client.talkgadget.google.com' to access the
// TalkGadget.
//
// Supported on:
message RemoteAccessHostTalkGadgetPrefixProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostTalkGadgetPrefix = 2;
}

// Enable curtaining of remote access hosts
//
// Setting the policy to Enabled turns off remote access hosts' physical input
// and output devices during a remote connection.
//
// Setting the policy to Disabled or leaving it unset lets both local and remote
// users interact with the host while it's shared.
//
// Valid values:
//   True: Enable curtaining of the remote access host
//   False: Disable curtaining of the remote access host
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostRequireCurtainProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostRequireCurtain = 2;
}

// Enable or disable PIN-less authentication for remote access hosts
//
// Setting the policy to Enabled or leaving it unset lets users pair clients and
// hosts at connection time, eliminating the need to enter a PIN every time.
//
// Setting the policy to Disabled makes this feature unavailable.
//
// Valid values:
//   True: Enable PIN-less authentication for the remote access host
//   False: Disable PIN-less authentication for the remote access host
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostAllowClientPairingProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowClientPairing = 2;
}

// Allow gnubby authentication for remote access hosts
//
// Setting the policy to Enabled means gnubby authentication requests will be
// proxied across a remote host connection.
//
// Setting the policy to Disabled or leaving it unset means gnubby
// authentication requests won't be proxied.
//
// Note that this feature requires additional components which are not available
// outside of the Google network environment in order to work properly.
//
// Valid values:
//   True: Enable gnubby authentication for the remote access host
//   False: Disable gnubby authentication for the remote access host
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostAllowGnubbyAuthProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowGnubbyAuth = 2;
}

// Enable the use of relay servers by the remote access host
//
// If RemoteAccessHostFirewallTraversal is set to Enabled, setting
// RemoteAccessHostAllowRelayedConnection to Enabled or leaving it unset allows
// the use of remote clients to use relay servers to connect to this machine
// when a direct connection is not available, for example, because of firewall
// restrictions.
//
// Setting the policy to Disabled doesn't turn remote access off, but only
// allows connections from the same network (not NAT traversal or relay).
//
// Valid values:
//   True: Enable the use of relay servers by the remote access host
//   False: Disable the use of relay servers by the remote access host
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostAllowRelayedConnectionProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowRelayedConnection = 2;
}

// Restrict the UDP port range used by the remote access host
//
// Setting the policy restricts the UDP port range used by the remote access
// host in this machine.
//
// Leaving the policy unset or set to an empty string means the remote access
// host can use any available port.
//
// Note: If RemoteAccessHostFirewallTraversal is Disabled, the remote access
// host will use UDP ports in the 12400-12409 range.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostUdpPortRangeProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostUdpPortRange = 2;
}

// Require that the name of the local user and the remote access host owner
// match
//
// Setting the policy to Enabled has the remote access host compare the name of
// the local user the host is associated with and the name of the Google Account
// registered as the host owner ("johndoe," if the host is owned by
// "johndoe@example.com"). This host won't start if the host owner's name
// differs from the name of the local user that the host is associated with. To
// enforce that the owner's Google Account is associated with a specific domain,
// use the policy with RemoteAccessHostDomain.
//
// Setting the policy to Disabled or leaving it unset means the remote access
// host can be associated with any local user.
//
// Valid values:
//   True: Require matching local user and remote access host owner
//   False: Do not require matching local user and remote access host owner
//
// Supported on: linux, mac
message RemoteAccessHostMatchUsernameProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostMatchUsername = 2;
}

// URL where remote access clients should obtain their authentication token
//
// Setting the policy means the remote access host requires authenticating
// clients to get an authentication token from this URL to connect.
//
// This feature is disabled if empty or not set.
//
// Note: This policy must be used with RemoteAccessHostTokenValidationUrl.
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostTokenUrlProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostTokenUrl = 2;
}

// URL for validating remote access client authentication token
//
// Setting the policy means the remote access host uses this URL to validate
// authentication tokens from remote access clients to accept connections. This
// feature is disabled if empty or not set.
//
// Note: Use the policy with RemoteAccessHostTokenUrl.
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostTokenValidationUrlProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostTokenValidationUrl = 2;
}

// Client certificate for connecting to RemoteAccessHostTokenValidationUrl
//
// Setting the policy means the remote access host uses a client certificate
// with the given issuer CN to authenticate to
// RemoteAccessHostTokenValidationUrl. To use any available client certificate,
// set it to *. This feature is disabled if empty or not set.
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostTokenValidationCertificateIssuerProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostTokenValidationCertificateIssuer = 2;
}

// Policy overrides for Debug builds of the remote access host
//
// Overrides policies on Debug builds of the remote access host.
//
// The value is parsed as a JSON dictionary of policy name to policy value
// mappings.
//
// Supported on:
message RemoteAccessHostDebugOverridePoliciesProto {
  optional PolicyOptions policy_options = 1;
  optional string RemoteAccessHostDebugOverridePolicies = 2;
}

// Allow remote users to interact with elevated windows in remote assistance
// sessions
//
// Setting the policy to Enabled means the remote assistance host runs in a
// process with uiAccess permissions. This lets remote users interact with
// elevated windows on the local user's desktop.
//
// Setting the policy to Disabled or leaving it unset means the remote
// assistance host runs in the user's context, and remote users can't interact
// with elevated windows on the desktop.
//
// Valid values:
//   True: Enable remote user interaction with elevated windows in remote
// assistance sessions
//   False: Disable remote user interaction with elevated windows in remote
// assistance sessions
//
// Supported on: win
message RemoteAccessHostAllowUiAccessForRemoteAssistanceProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowUiAccessForRemoteAssistance = 2;
}

// Allow remote access users to transfer files to/from the host
//
// Setting the policy to Enabled or leaving it unset allows users connected to a
// remote access host to transfer files between the client and the host. This
// doesn't apply to remote assistance connections, which don't support file
// transfer.
//
// Setting the policy to Disabled disallows file transfer.
//
// Valid values:
//   True: Enable remote access users to transfer files to and from the remote
// host
//   False: Disable remote access users from transferring files to and from the
// remote host
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostAllowFileTransferProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowFileTransfer = 2;
}

// Enable connection-related UI on the host desktop when a connection is active
//
// If this policy is disabled, connection related UI (e.g. the disconnect
// window) will not be shown for non-curtained remote access connections.
// Curtained remote access sessions and remote support sessions are not affected
// by this policy.
//
// This policy has no effect if it is set to true, left empty, or is not set.
//
// Valid values:
//   True: Enable connection-related UI on the remote host desktop when a
// connection is active
//   False: Disable connection-related UI on the remote host desktop when a
// connection is active
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostEnableUserInterfaceProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostEnableUserInterface = 2;
}

// Allow remote access connections to this machine
//
// If this policy is Disabled, the remote access host service cannot be started
// or configured to accept incoming connections.  This policy does not affect
// remote support scenarios.
//
// This policy has no effect if it is set to Enabled, left empty, or is not set.
//
// Valid values:
//   True: Allow remote access connections to this machine
//   False: Prevent remote access connections to this machine
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostAllowRemoteAccessConnectionsProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowRemoteAccessConnections = 2;
}

// Maximum session duration allowed for remote access connections
//
// If this policy is set, remote access connections will automatically
// disconnect after the number of minutes defined in the policy have elapsed.
// This does not prevent the client from reconnecting after the maximum session
// duration has been reached. Setting the policy to a value that is not within
// the min/max range may prevent the host from starting. This policy does not
// affect remote support scenarios.
//
// This policy has no effect if it is not set. In this case, remote access
// connections will have no maximum duration on this machine.
//
// Supported on: fuchsia, linux, mac, win
message RemoteAccessHostMaximumSessionDurationMinutesProto {
  optional PolicyOptions policy_options = 1;
  optional int64 RemoteAccessHostMaximumSessionDurationMinutes = 2;
}

// The maximum size, in bytes, that can be transferred between client and host
// via clipboard synchronization
//
// If this policy is set, clipboard data sent to and from the host will be
// truncated to the limit set by this policy.
//
// If a value of 0 is set, then clipboard sync is disabled.
//
// This policy affects both remote access and remote support scenarios.
//
// This policy has no effect if it is not set.
//
// Setting the policy to a value that is not within the min/max range may
// prevent the host from starting.
//
// Please note that the actual upper bound for the clipboard size is based on
// the maximum WebRTC data channel message size which this policy does not
// control.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostClipboardSizeBytesProto {
  optional PolicyOptions policy_options = 1;
  optional int64 RemoteAccessHostClipboardSizeBytes = 2;
}

// Allow remote support connections to this machine
//
// If this policy is disabled, the remote support host cannot be started or
// configured to accept incoming connections.
//
// This policy does not affect remote access scenarios.
//
// This policy does not prevent enterprise admins from connecting to managed
// Google ChromeOS devices.
//
// This policy has no effect if enabled, left empty, or is not set.
//
// Valid values:
//   True: Allow remote support connections to this machine
//   False: Prevent remote support connections to this machine
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteAccessHostAllowRemoteSupportConnectionsProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteAccessHostAllowRemoteSupportConnections = 2;
}

// Enable printing
//
// Setting the policy to Enabled or leaving it unset lets users print in Google
// Chrome, and users can't change this setting.
//
// Setting the policy to Disabled means users can't print from Google Chrome.
// Printing is off in the three dots menu, extensions, and JavaScript
// applications.
//
// Valid values:
//   True: Enable printing
//   False: Disable printing
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PrintingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrintingEnabled = 2;
}

// Enable Google Cloud Print proxy
//
// Setting the policy to Enabled or leaving it unset lets Google Chrome act as a
// proxy between Google Cloud Print and legacy printers connected to the
// machine. Using their Google Account, users may turn on the cloud print proxy
// by authentication.
//
// Setting the policy to Disabled means users can't turn on the proxy, and the
// machine can't share its printers with Google Cloud Print.
//
// Valid values:
//   True: Enable Google Cloud Print proxy
//   False: Disable Google Cloud Print proxy
//
// Supported on: fuchsia, linux, mac, win
message CloudPrintProxyEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudPrintProxyEnabled = 2;
}

// Restrict printing color mode
//
// Setting the policy sets printing to color only, monochrome only, or no color
// mode restriction. Leaving the policy unset results in no restriction.
//
// Valid values:
//   any: Allow all color modes
//   color: Color printing only
//   monochrome: Monochrome printing only
//
// Supported on: chrome_os
message PrintingAllowedColorModesProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingAllowedColorModes = 2;
}

// Restrict printing duplex mode
//
// Setting the policy restricts printing duplex mode.
//
// Leaving the policy unset or empty results in no restriction.
//
// Valid values:
//   any: Allow all duplex modes
//   simplex: Simplex printing only
//   duplex: Duplex printing only
//
// Supported on: chrome_os
message PrintingAllowedDuplexModesProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingAllowedDuplexModes = 2;
}

// Restrict PIN printing mode
//
// Restricts PIN printing mode. Unset policy is treated as no restriction. If
// the mode is unavailable this policy is ignored. Note that PIN printing
// feature is enabled only for printers that use one of IPPS, HTTPS, USB or IPP-
// over-USB protocols.
//
// Valid values:
//   any: Allow printing both with and without PIN
//   pin: Allow printing only with PIN
//   no_pin: Allow printing only without PIN
//
// Supported on: chrome_os
message PrintingAllowedPinModesProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingAllowedPinModes = 2;
}

// Restrict background graphics printing mode
//
// Restricts background graphics printing mode. Unset policy is treated as no
// restriction.
//
// Valid values:
//   any: Allow printing both with and without background graphics
//   enabled: Allow printing only with background graphics
//   disabled: Allow printing only without background graphics
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PrintingAllowedBackgroundGraphicsModesProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingAllowedBackgroundGraphicsModes = 2;
}

// Default printing color mode
//
// Setting the policy overrides the default printing color mode. If the mode is
// unavailable, this policy is ignored.
//
// Valid values:
//   color: Enable color printing
//   monochrome: Enable monochrome printing
//
// Supported on: chrome_os
message PrintingColorDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingColorDefault = 2;
}

// Default printing duplex mode
//
// Setting the policy overrides the default printing duplex mode. If the mode is
// unavailable, this policy is ignored.
//
// Valid values:
//   simplex: Enable simplex printing
//   short-edge: Enable short edge duplex printing
//   long-edge: Enable long edge duplex printing
//
// Supported on: chrome_os
message PrintingDuplexDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingDuplexDefault = 2;
}

// Default PIN printing mode
//
// Overrides default PIN printing mode. If the mode is unavailable this policy
// is ignored.
//
// Valid values:
//   pin: Enable PIN printing by default
//   no_pin: Disable PIN printing by default
//
// Supported on: chrome_os
message PrintingPinDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingPinDefault = 2;
}

// Default background graphics printing mode
//
// Overrides default background graphics printing mode.
//
// Valid values:
//   enabled: Enable background graphics printing mode by default
//   disabled: Disable background graphics printing mode by default
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PrintingBackgroundGraphicsDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingBackgroundGraphicsDefault = 2;
}

// Default printing page size
//
// Overrides default printing page size.
//
// name should contain one of the listed formats or 'custom' if required paper
// size is not in the list. If 'custom' value is provided custom_size property
// should be specified. It describes the desired height and width in
// micrometers. Otherwise custom_size property shouldn't be specified. Policy
// that violates these rules is ignored.
//
// If the page size is unavailable on the printer chosen by the user this policy
// is ignored.
//
// Value schema:
// {
//     "properties": {
//         "custom_size": {
//             "properties": {
//                 "height": {
//                     "description": "Height of the page in micrometers",
//                     "type": "integer"
//                 },
//                 "width": {
//                     "description": "Width of the page in micrometers",
//                     "type": "integer"
//                 }
//             },
//             "required": [
//                 "width",
//                 "height"
//             ],
//             "type": "object"
//         },
//         "name": {
//             "enum": [
//                 "custom",
//                 "asme_f_28x40in",
//                 "iso_2a0_1189x1682mm",
//                 "iso_a0_841x1189mm",
//                 "iso_a10_26x37mm",
//                 "iso_a1_594x841mm",
//                 "iso_a2_420x594mm",
//                 "iso_a3_297x420mm",
//                 "iso_a4-extra_235.5x322.3mm",
//                 "iso_a4-tab_225x297mm",
//                 "iso_a4_210x297mm",
//                 "iso_a5-extra_174x235mm",
//                 "iso_a5_148x210mm",
//                 "iso_a6_105x148mm",
//                 "iso_a7_74x105mm",
//                 "iso_a8_52x74mm",
//                 "iso_a9_37x52mm",
//                 "iso_b0_1000x1414mm",
//                 "iso_b10_31x44mm",
//                 "iso_b1_707x1000mm",
//                 "iso_b2_500x707mm",
//                 "iso_b3_353x500mm",
//                 "iso_b4_250x353mm",
//                 "iso_b5-extra_201x276mm",
//                 "iso_b5_176x250mm",
//                 "iso_b6_125x176mm",
//                 "iso_b6c4_125x324mm",
//                 "iso_b7_88x125mm",
//                 "iso_b8_62x88mm",
//                 "iso_b9_44x62mm",
//                 "iso_c0_917x1297mm",
//                 "iso_c10_28x40mm",
//                 "iso_c1_648x917mm",
//                 "iso_c2_458x648mm",
//                 "iso_c3_324x458mm",
//                 "iso_c4_229x324mm",
//                 "iso_c5_162x229mm",
//                 "iso_c6_114x162mm",
//                 "iso_c6c5_114x229mm",
//                 "iso_c7_81x114mm",
//                 "iso_c7c6_81x162mm",
//                 "iso_c8_57x81mm",
//                 "iso_c9_40x57mm",
//                 "iso_dl_110x220mm",
//                 "jis_exec_216x330mm",
//                 "jpn_chou2_111.1x146mm",
//                 "jpn_chou3_120x235mm",
//                 "jpn_chou4_90x205mm",
//                 "jpn_hagaki_100x148mm",
//                 "jpn_kahu_240x322.1mm",
//                 "jpn_kaku2_240x332mm",
//                 "jpn_oufuku_148x200mm",
//                 "jpn_you4_105x235mm",
//                 "na_10x11_10x11in",
//                 "na_10x13_10x13in",
//                 "na_10x14_10x14in",
//                 "na_10x15_10x15in",
//                 "na_11x12_11x12in",
//                 "na_11x15_11x15in",
//                 "na_12x19_12x19in",
//                 "na_5x7_5x7in",
//                 "na_6x9_6x9in",
//                 "na_7x9_7x9in",
//                 "na_9x11_9x11in",
//                 "na_a2_4.375x5.75in",
//                 "na_arch-a_9x12in",
//                 "na_arch-b_12x18in",
//                 "na_arch-c_18x24in",
//                 "na_arch-d_24x36in",
//                 "na_arch-e_36x48in",
//                 "na_b-plus_12x19.17in",
//                 "na_c5_6.5x9.5in",
//                 "na_c_17x22in",
//                 "na_d_22x34in",
//                 "na_e_34x44in",
//                 "na_edp_11x14in",
//                 "na_eur-edp_12x14in",
//                 "na_f_44x68in",
//                 "na_fanfold-eur_8.5x12in",
//                 "na_fanfold-us_11x14.875in",
//                 "na_foolscap_8.5x13in",
//                 "na_govt-legal_8x13in",
//                 "na_govt-letter_8x10in",
//                 "na_index-3x5_3x5in",
//                 "na_index-4x6-ext_6x8in",
//                 "na_index-4x6_4x6in",
//                 "na_index-5x8_5x8in",
//                 "na_invoice_5.5x8.5in",
//                 "na_ledger_11x17in",
//                 "na_legal-extra_9.5x15in",
//                 "na_legal_8.5x14in",
//                 "na_letter-extra_9.5x12in",
//                 "na_letter-plus_8.5x12.69in",
//                 "na_letter_8.5x11in",
//                 "na_number-10_4.125x9.5in",
//                 "na_number-11_4.5x10.375in",
//                 "na_number-12_4.75x11in",
//                 "na_number-14_5x11.5in",
//                 "na_personal_3.625x6.5in",
//                 "na_super-a_8.94x14in",
//                 "na_super-b_13x19in",
//                 "na_wide-format_30x42in",
//                 "om_dai-pa-kai_275x395mm",
//                 "om_folio-sp_215x315mm",
//                 "om_invite_220x220mm",
//                 "om_italian_110x230mm",
//                 "om_juuro-ku-kai_198x275mm",
//                 "om_large-photo_200x300",
//                 "om_pa-kai_267x389mm",
//                 "om_postfix_114x229mm",
//                 "om_small-photo_100x150mm",
//                 "prc_10_324x458mm",
//                 "prc_16k_146x215mm",
//                 "prc_1_102x165mm",
//                 "prc_2_102x176mm",
//                 "prc_32k_97x151mm",
//                 "prc_3_125x176mm",
//                 "prc_4_110x208mm",
//                 "prc_5_110x220mm",
//                 "prc_6_120x320mm",
//                 "prc_7_160x230mm",
//                 "prc_8_120x309mm",
//                 "roc_16k_7.75x10.75in",
//                 "roc_8k_10.75x15.5in",
//                 "jis_b0_1030x1456mm",
//                 "jis_b1_728x1030mm",
//                 "jis_b2_515x728mm",
//                 "jis_b3_364x515mm",
//                 "jis_b4_257x364mm",
//                 "jis_b5_182x257mm",
//                 "jis_b6_128x182mm",
//                 "jis_b7_91x128mm",
//                 "jis_b8_64x91mm",
//                 "jis_b9_45x64mm",
//                 "jis_b10_32x45mm"
//             ],
//             "type": "string"
//         }
//     },
//     "required": [
//         "name"
//     ],
//     "type": "object"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PrintingPaperSizeDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintingPaperSizeDefault = 2;
}

// Send username and filename to native printers
//
// Send username and filename to native printers server with every print job.
// The default is not to send.
//
// Setting this policy to true also disables printers that use protocols other
// than IPPS, USB, or IPP-over-USB since username and filename shouldn't be sent
// over the network openly.
//
// Valid values:
//   True: Enable sending username and filename to native printers
//   False: Disable sending username and filename to native printers
//
// Supported on: chrome_os
message PrintingSendUsernameAndFilenameEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrintingSendUsernameAndFilenameEnabled = 2;
}

// Maximal number of sheets allowed to use for a single print job
//
// Specifies the maximal number of sheets user is allowed to print for a single
// print job.
//
// If not set, no limitations are applied and user can print any documents.
//
// Supported on: chrome_os
message PrintingMaxSheetsAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PrintingMaxSheetsAllowed = 2;
}

// Allows the AppCache feature to be re-enabled even if it is off by default.
//
// If set to true, this will force AppCache to be enabled, even when AppCache in
// Chrome is not available by default.
//
// If unset or set to false, AppCache will follow Chrome's defaults.
//
// Valid values:
//   True: Force AppCache to be enabled
//   False: Use default AppCache behavior
//
// Supported on:
message AppCacheForceEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AppCacheForceEnabled = 2;
}

// Set the time period in days for storing print jobs metadata
//
// This policy controls how long print jobs metadata is stored on the device, in
// days.
//
// When this policy is set to a value of -1, the print jobs metadata is stored
// indefinitely. When this policy is set to a value of 0, the print jobs
// metadata is not stored at all. When this policy is set to any other value, it
// specifies the period of time during which the metadata of completed print
// jobs is stored on the device.
//
// If not set, the default period of 90 days is used for Google ChromeOS
// devices.
//
// The policy value should be specified in days.
//
// Supported on: chrome_os
message PrintJobHistoryExpirationPeriodProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PrintJobHistoryExpirationPeriod = 2;
}

// Extensions allowed to skip confirmation dialog when sending print jobs via
// chrome.printing API
//
// This policy specifies the allowed extensions to skip print job confirmation
// dialog when they use the Printing API function chrome.printing.submitJob()
// for sending a print job.
//
// If an extension is not in the list, or the list is not set, the print job
// confirmation dialog will be shown to the user for every
// chrome.printing.submitJob() function call.
//
// This policy is deprecated, please use PrintingAPIExtensionsAllowlist instead.
//
// Supported on:
message PrintingAPIExtensionsWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PrintingAPIExtensionsWhitelist = 2;
}

// Extensions allowed to skip confirmation dialog when sending print jobs via
// chrome.printing API
//
// This policy specifies the allowed extensions to skip print job confirmation
// dialog when they use the Printing API function chrome.printing.submitJob()
// for sending a print job.
//
// If an extension is not in the list, or the list is not set, the print job
// confirmation dialog will be shown to the user for every
// chrome.printing.submitJob() function call.
//
// Supported on: chrome_os
message PrintingAPIExtensionsAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PrintingAPIExtensionsAllowlist = 2;
}

// Force SafeSearch
//
// This policy is deprecated, please use ForceGoogleSafeSearch and
// ForceYouTubeRestrict instead. This policy is ignored if either the
// ForceGoogleSafeSearch, the ForceYouTubeRestrict or the (deprecated)
// ForceYouTubeSafetyMode policies are set.
//
// Forces queries in Google Web Search to be done with SafeSearch set to active
// and prevents users from changing this setting. This setting also forces
// Moderate Restricted Mode on YouTube.
//
// If you enable this setting, SafeSearch in Google Search and Moderate
// Restricted Mode YouTube is always active.
//
// If you disable this setting or do not set a value, SafeSearch in Google
// Search and Restricted Mode in YouTube is not enforced.
//
// Valid values:
//   True: Force the use of SafeSearch in Google Search and YouTube Restricted
// Mode to be at least Moderate
//   False: Do not enforce the use of SafeSearch in Google Search or YouTube
// Restricted Mode
//
// Supported on: android, chrome_os, linux, mac, win
message ForceSafeSearchProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceSafeSearch = 2;
}

// Force Google SafeSearch
//
// Setting the policy to Enabled means SafeSearch in Google Search is always
// active, and users can't change this setting.
//
// Setting the policy to Disabled or leaving it unset means SafeSearch in Google
// Search is not enforced.
//
// Valid values:
//   True: Force the use of SafeSearch in Google Search
//   False: Do not enforce the use of SafeSearch in Google Search
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ForceGoogleSafeSearchProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceGoogleSafeSearch = 2;
}

// Force YouTube Safety Mode
//
// This policy is deprecated. Consider using ForceYouTubeRestrict, which
// overrides this policy and allows more fine-grained tuning.
//
// Forces YouTube Moderate Restricted Mode and prevents users from changing this
// setting.
//
// If this setting is enabled, Restricted Mode on YouTube is always enforced to
// be at least Moderate.
//
// If this setting is disabled or no value is set, Restricted Mode on YouTube is
// not enforced by Google Chrome. External policies such as YouTube policies
// might still enforce Restricted Mode, though.
//
// Valid values:
//   True: Force YouTube Restricted Mode to be at least Moderate
//   False: Do not enforce YouTube Restricted Mode
//
// Supported on: android, chrome_os, linux, mac, win
message ForceYouTubeSafetyModeProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceYouTubeSafetyMode = 2;
}

// Force minimum YouTube Restricted Mode
//
// Setting the policy enforces a minimum Restricted mode on YouTube and prevents
// users from picking a less restricted mode. If you set it to:
//
// * Strict, Strict Restricted mode on YouTube is always active.
//
// * Moderate, the user may only pick Moderate Restricted mode and Strict
// Restricted mode on YouTube, but can't turn off Restricted mode.
//
// * Off or if no value is set, Restricted mode on YouTube isn't enforced by
// Chrome. External policies such as YouTube policies might still enforce
// Restricted mode.
//
// Valid values:
//   0: Do not enforce Restricted Mode on YouTube
//   1: Enforce at least Moderate Restricted Mode on YouTube
//   2: Enforce Strict Restricted Mode for YouTube
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ForceYouTubeRestrictProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ForceYouTubeRestrict = 2;
}

// Enable Safe Browsing
//
// This policy is deprecated in Google Chrome 83, please use
// SafeBrowsingProtectionLevel instead.
//
// Setting the policy to Enabled keeps Chrome's Safe Browsing feature on.
// Setting the policy to Disabled keeps Safe Browsing off.
//
// If you set this policy, users can't change it or override the "Enable
// phishing and malware protection" setting in Chrome. If not set, "Enable
// phishing and malware protection" is set to True, but the user can change it.
//
// See more about Safe Browsing ( https://developers.google.com/safe-browsing ).
//
// If the policy SafeBrowsingProtectionLevel is set, the value of the policy
// SafeBrowsingEnabled is ignored.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Valid values:
//   True: Enable Safe Browsing
//   False: Disable Safe Browsing
//
// Supported on: android, chrome_os, ios, linux, mac, win
message SafeBrowsingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SafeBrowsingEnabled = 2;
}

// Safe Browsing Protection Level
//
// Allows you to control whether Google Chrome's Safe Browsing feature is
// enabled and the mode it operates in.
//
// If this policy is set to 'NoProtection' (value 0), Safe Browsing is never
// active.
//
// If this policy is set to 'StandardProtection' (value 1, which is the
// default), Safe Browsing is always active in the standard mode.
//
// If this policy is set to 'EnhancedProtection' (value 2), Safe Browsing is
// always active in the enhanced mode, which provides better security, but
// requires sharing more browsing information with Google.
//
// If you set this policy as mandatory, users cannot change or override the Safe
// Browsing setting in Google Chrome.
//
// If this policy is left not set, Safe Browsing will operate in Standard
// Protection mode but users can change this setting.
//
// See https://developers.google.com/safe-browsing for more info on Safe
// Browsing.
//
// Valid values:
//   0: Safe Browsing is never active.
//   1: Safe Browsing is active in the standard mode.
//   2: Safe Browsing is active in the enhanced mode. This mode provides better
// security, but requires sharing more browsing information with Google.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message SafeBrowsingProtectionLevelProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SafeBrowsingProtectionLevel = 2;
}

// Enable reporting of usage and crash-related data
//
// When this policy is enabled, anonymous reporting of usage and crash-related
// data about Chrome to Google is enabled by default. Users will still be able
// to change this setting in the Chrome settings.
//
// When this policy is disabled, anonymous reporting is disabled and no usage or
// crash data is sent to Google. Users won't be able to change this setting.
//
// When this policy isn't set, users can choose the anonymous reporting behavior
// at installation or first run, and can later change the setting in the Chrome
// settings.
//
// This policy is available only on Windows instances that are joined to a
// Microsoft® Active Directory® domain or Windows 10 Pro or Enterprise instances
// that are enrolled for device management, and macOS instances that are managed
// via MDM or joined to a domain via MCX.
//
// (For Google ChromeOS, see DeviceMetricsReportingEnabled.)
//
// Valid values:
//   True: Enable reporting of usage and crash-related data
//   False: Disable reporting of usage and crash-related data
//
// Supported on: android, fuchsia, ios, linux, mac, win
message MetricsReportingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool MetricsReportingEnabled = 2;
}

// Enable saving passwords to the password manager
//
// Setting the policy to Enabled means users have Google Chrome remember
// passwords and provide them the next time they sign in to a site.
//
// Setting the policy to Disabled means users can't save new passwords, but
// previously saved passwords will still work.
//
// If the policy is set, users can't change it in Google Chrome. If not set, the
// user can turn off password saving.
//
// Valid values:
//   True: Enable saving passwords using the password manager
//   False: Disable saving passwords using the password manager
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PasswordManagerEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PasswordManagerEnabled = 2;
}

// Allow users to show passwords in Password Manager (deprecated)
//
// The associated setting was used before reauthentication on viewing passwords
// was introduced. Since then, the setting and hence this policy had no effect
// on the behavior of Chrome. The current behavior of Chrome is now the same as
// if the policy was set to disable showing passwords in clear text in the
// password manager settings page. That means that the settings page contains
// just a placeholder, and only upon the user clicking "Show" (and
// reauthenticating, if applicable) Chrome shows the password. Original
// description of the policy follows below.
//
// Controls whether the user may show passwords in clear text in the password
// manager.
//
// If you disable this setting, the password manager does not allow showing
// stored passwords in clear text in the password manager window.
//
// If you enable or do not set this policy, users can view their passwords in
// clear text in the password manager.
//
// Supported on:
message PasswordManagerAllowShowPasswordsProto {
  optional PolicyOptions policy_options = 1;
  optional bool PasswordManagerAllowShowPasswords = 2;
}

// Enable leak detection for entered credentials
//
// Setting the policy to Enabled lets users have Google Chrome check whether
// usernames and passwords entered were part of a leak.
//
// If the policy is set, users can't change it in Google Chrome. If not set,
// credential leak checking is allowed, but the user can turn it off.
//
// This behavior will not trigger if Safe Browsing is disabled (either by policy
// or by the user). In order to force Safe Browsing on, use the
// SafeBrowsingEnabled policy or the SafeBrowsingProtectionLevel policy.
//
// Valid values:
//   True: Enable password leak detection
//   False: Disable password leak detection
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message PasswordLeakDetectionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PasswordLeakDetectionEnabled = 2;
}

// Enable dismissing compromised password alerts for entered credentials
//
// Setting the policy to Enabled or leaving it unset gives the user the option
// to dismiss/restore compromised password alerts.
//
// If you disable this setting, users will not be able to dismiss alerts about
// compromised passwords. If enabled, users will be able to dismiss alerts about
// compromised passwords.
//
// Valid values:
//   True: Enable dismissing compromised password alerts
//   False: Disable dismissing compromised password alerts
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PasswordDismissCompromisedAlertEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PasswordDismissCompromisedAlertEnabled = 2;
}

// Enable AutoFill
//
// This policy is deprecated in M70, please use AutofillAddressEnabled and
// AutofillCreditCardEnabled instead.
//
// Enables Google Chrome's AutoFill feature and allows users to auto complete
// web forms using previously stored information such as address or credit card
// information.
//
// If you disable this setting, AutoFill will be inaccessible to users.
//
// If you enable this setting or do not set a value, AutoFill will remain under
// the control of the user. This will allow them to configure AutoFill profiles
// and to switch AutoFill on or off at their own discretion.
//
// Valid values:
//   True: Enable AutoFill
//   False: Disable AutoFill
//
// Supported on: android, chrome_os, linux, mac, win
message AutoFillEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AutoFillEnabled = 2;
}

// Enable AutoFill for addresses
//
// Setting the policy to True or leaving it unset gives users control of
// Autofill for addresses in the UI.
//
// Setting the policy to False means Autofill never suggests or fills address
// information, nor does it save additional address information that users
// submit while browsing the web.
//
// Valid values:
//   True: Enable AutoFill for addresses
//   False: Disable AutoFill for addresses
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message AutofillAddressEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AutofillAddressEnabled = 2;
}

// Enable AutoFill for credit cards
//
// Setting the policy to True or leaving it unset means users can control
// autofill suggestions for credit cards in the UI.
//
// Setting the policy to False means autofill never suggests or fills credit
// card information, nor will it save additional credit card information that
// users might submit while browsing the web.
//
// Valid values:
//   True: Enable AutoFill for credit cards
//   False: Disable AutoFill for credit cards
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message AutofillCreditCardEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AutofillCreditCardEnabled = 2;
}

// Specify a list of disabled plugins
//
// This policy is deprecated. Please use the DefaultPluginsSetting to control
// the availability of the Flash plugin and AlwaysOpenPdfExternally to control
// whether the integrated PDF viewer should be used for opening PDF files.
//
// Specifies a list of plugins that are disabled in Google Chrome and prevents
// users from changing this setting.
//
// The wildcard characters '*' and '?' can be used to match sequences of
// arbitrary characters. '*' matches an arbitrary number of characters while '?'
// specifies an optional single character, i.e. matches zero or one characters.
// The escape character is '\', so to match actual '*', '?', or '\' characters,
// you can put a '\' in front of them.
//
// If you enable this setting, the specified list of plugins is never used in
// Google Chrome. The plugins are marked as disabled in 'about:plugins' and
// users cannot enable them.
//
// Note that this policy can be overridden by EnabledPlugins and
// DisabledPluginsExceptions.
//
// If this policy is left not set the user can use any plugin installed on the
// system except for hard-coded incompatible, outdated or dangerous plugins.
//
// Supported on:
message DisabledPluginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList DisabledPlugins = 2;
}

// Specify a list of enabled plugins
//
// This policy is deprecated. Please use the DefaultPluginsSetting to control
// the availability of the Flash plugin and AlwaysOpenPdfExternally to control
// whether the integrated PDF viewer should be used for opening PDF files.
//
// Specifies a list of plugins that are enabled in Google Chrome and prevents
// users from changing this setting.
//
// The wildcard characters '*' and '?' can be used to match sequences of
// arbitrary characters. '*' matches an arbitrary number of characters while '?'
// specifies an optional single character, i.e. matches zero or one characters.
// The escape character is '\', so to match actual '*', '?', or '\' characters,
// you can put a '\' in front of them.
//
// The specified list of plugins is always used in Google Chrome if they are
// installed. The plugins are marked as enabled in 'about:plugins' and users
// cannot disable them.
//
// Note that this policy overrides both DisabledPlugins and
// DisabledPluginsExceptions.
//
// If this policy is left not set the user can disable any plugin installed on
// the system.
//
// Supported on:
message EnabledPluginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList EnabledPlugins = 2;
}

// Specify a list of plugins that the user can enable or disable
//
// This policy is deprecated. Please use the DefaultPluginsSetting to control
// the availability of the Flash plugin and AlwaysOpenPdfExternally to control
// whether the integrated PDF viewer should be used for opening PDF files.
//
// Specifies a list of plugins that user can enable or disable in Google Chrome.
//
// The wildcard characters '*' and '?' can be used to match sequences of
// arbitrary characters. '*' matches an arbitrary number of characters while '?'
// specifies an optional single character, i.e. matches zero or one characters.
// The escape character is '\', so to match actual '*', '?', or '\' characters,
// you can put a '\' in front of them.
//
// If you enable this setting, the specified list of plugins can be used in
// Google Chrome. Users can enable or disable them in 'about:plugins', even if
// the plugin also matches a pattern in DisabledPlugins. Users can also enable
// and disable plugins that don't match any patterns in DisabledPlugins,
// DisabledPluginsExceptions and EnabledPlugins.
//
// This policy is meant to allow for strict plugin blocking where the
// 'DisabledPlugins' list contains wildcarded entries like disable all plugins
// '*' or disable all Java plugins '*Java*' but the administrator wishes to
// enable some particular version like 'IcedTea Java 2.3'. This particular
// versions can be specified in this policy.
//
// Note that both the plugin name and the plugin's group name have to be
// exempted. Each plugin group is shown in a separate section in about:plugins;
// each section may have one or more plugins. For example, the "Shockwave Flash"
// plugin belongs to the "Adobe Flash Player" group, and both names have to have
// a match in the exceptions list if that plugin is to be exempted from the
// blocklist.
//
// If this policy is left not set any plugin that matches the patterns in the
// 'DisabledPlugins' will be locked disabled and the user won't be able to
// enable them.
//
// Supported on:
message DisabledPluginsExceptionsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList DisabledPluginsExceptions = 2;
}

// Always Open PDF files externally
//
// Setting the policy to Enabled turns the internal PDF viewer off in Google
// Chrome, treats PDF files as a download, and lets users open PDFs with the
// default application.
//
// Setting the policy to Disabled means that unless users turns off the PDF
// plugin, it will open PDF files.
//
// If you set the policy, users can't change it in Google Chrome. If not set,
// users can choose whether to open PDF externally or not.
//
// Valid values:
//   True: Always open PDF files using an external PDF viewer
//   False: Always open PDF files using the internal PDF viewer
//
// Supported on: fuchsia, linux, mac, win
message AlwaysOpenPdfExternallyProto {
  optional PolicyOptions policy_options = 1;
  optional bool AlwaysOpenPdfExternally = 2;
}

// Specify whether the plugin finder should be disabled (deprecated)
//
// This policy has been removed as of Google Chrome 64.
//
// Automatic search and installation of missing plugins is no longer supported.
//
// Valid values:
//   True: Enable the plugin finder
//   False: Disable the plugin finder
//
// Supported on:
message DisablePluginFinderProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisablePluginFinder = 2;
}

// Disable synchronization of data with Google
//
// Setting the policy to Enabled turns off data synchronization in Google Chrome
// using Google-hosted synchronization services.
// To fully turn off Chrome Sync services, we recommend that you turn off the
// service in the Google Admin console.
//
// If the policy is set to Disabled or not set, users are allowed to choose
// whether to use Chrome Sync.
//
// Note: Do not turn on this policy when RoamingProfileSupportEnabled is
// Enabled, because that feature shares the same client-side functionality. The
// Google-hosted synchronization is off completely in this case.
//
// Valid values:
//   True: Disable Chrome Sync
//   False: Allow users to choose whether to enable Chrome Sync
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message SyncDisabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SyncDisabled = 2;
}

// List of types that should be excluded from synchronization
//
// If this policy is set all specified data types will be excluded from
// synchronization both for Chrome Sync as well as for roaming profile
// synchronization. This can be beneficial to reduce the size of the roaming
// profile or limit the type of data uploaded to the Chrome Sync Servers.
//
// The current data types for this policy are: "bookmarks", "readingList",
// "preferences", "passwords", "autofill", "themes", "typedUrls", "extensions",
// "apps", "tabs", "wifiConfigurations". Those names are case sensitive!
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message SyncTypesListDisabledProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SyncTypesListDisabled = 2;
}

// Enable the creation of roaming copies for Google Chrome profile data
//
// If you enable this setting, the settings stored in Google Chrome profiles
// like bookmarks, autofill data, passwords, etc. will also be written to a file
// stored in the Roaming user profile folder or a location specified by the
// Administrator through the RoamingProfileLocation policy. Enabling this policy
// disables cloud sync.
//
// If this policy is disabled or left not set only the regular local profiles
// will be used.
//
// Valid values:
//   True: Enable creation of roaming profiles
//   False: Disable creation of roaming profiles
//
// Supported on: fuchsia, linux, mac, win
message RoamingProfileSupportEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool RoamingProfileSupportEnabled = 2;
}

// Set the roaming profile directory
//
// Configures the directory that Google Chrome will use for storing the roaming
// copy of the profiles.
//
// If you set this policy, Google Chrome will use the provided directory to
// store the roaming copy of the profiles if the RoamingProfileSupportEnabled
// policy has been enabled. If the RoamingProfileSupportEnabled policy is
// disabled or left unset the value stored in this policy is not used.
//
// See https://www.chromium.org/administrators/policy-list-3/user-data-
// directory-variables for a list of variables that can be used.
//
// On non-Windows platforms, this policy must be set for roaming profiles to
// work.
//
// On Windows, if this policy is left unset, the default roaming profile path
// will be used.
//
// Supported on: linux, mac, win
message RoamingProfileLocationProto {
  optional PolicyOptions policy_options = 1;
  optional string RoamingProfileLocation = 2;
}

// Allow sign in to Google Chrome
//
// This policy is deprecated, consider using BrowserSignin instead.
//
// Allows the user to sign in to Google Chrome.
//
// Setting this policy to Enabled will allow the user to sign in to Google
// Chrome.
// Setting this policy to Disabled will prevent sign in. It also blocks apps and
// extensions that use the chrome.identity API from functioning. To avoid that,
// use SyncDisabled instead.
//
// Valid values:
//   True: Allow users to sign in to Google Chrome
//   False: Prevent users from signing in to Google Chrome
//
// Supported on: android, linux, mac, win
message SigninAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SigninAllowed = 2;
}

// Enable the old web-based signin flow
//
// This setting was named EnableWebBasedSignin prior to Chrome 42, and support
// for it will be removed entirely in Chrome 43.
//
// This setting is useful for enterprise customers who are using SSO solutions
// that are not compatible with the new inline signin flow yet.
// If you enable this setting, the old web-based signin flow would be used.
// If you disable this setting or leave it not set, the new inline signin flow
// would be used by default. Users may still enable the old web-based signin
// flow through the command line flag --enable-web-based-signin.
//
// The experimental setting will be removed in the future when the inline signin
// fully supports all SSO signin flows.
//
// Supported on:
message EnableDeprecatedWebBasedSigninProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableDeprecatedWebBasedSignin = 2;
}

// Set user data directory
//
// Configures the directory that Google Chrome will use for storing user data.
//
// If you set this policy, Google Chrome will use the provided directory
// regardless whether the user has specified the '--user-data-dir' flag or not.
// To avoid data loss or other unexpected errors this policy should not be set
// to a directory used for other purposes, because Google Chrome manages its
// contents.
//
// See https://support.google.com/chrome/a?p=Supported_directory_variables for a
// list of variables that can be used.
//
// If this policy is left not set the default profile path will be used and the
// user will be able to override it with the '--user-data-dir' command line
// flag.
//
// Supported on: mac, win
message UserDataDirProto {
  optional PolicyOptions policy_options = 1;
  optional string UserDataDir = 2;
}

// Set disk cache directory
//
// Setting the policy has Google Chrome use the directory you provide for
// storing cached files on the disk—whether or not users specify the --disk-
// cache-dir flag.
//
// If not set, Google Chrome uses the default cache directory, but users can
// change that setting with the --disk-cache-dir command line flag.
//
// Google Chrome manages the contents of a volume's root directory. So to avoid
// data loss or other errors, do not set this policy to the root directory or
// any directory used for other purposes. See the variables you can use (
// https://www.chromium.org/administrators/policy-list-3/user-data-directory-
// variables ).
//
// Supported on: fuchsia, linux, mac, win
message DiskCacheDirProto {
  optional PolicyOptions policy_options = 1;
  optional string DiskCacheDir = 2;
}

// Set disk cache size in bytes
//
// Setting the policy to None has Google Chrome use the default cache size for
// storing cached files on the disk. Users can't change it.
//
// If you set the policy, Google Chrome uses the cache size you provide—whether
// or not users specify the --disk-cache-size flag. (Values below a few
// megabytes are rounded up.)
//
// If not set, Google Chrome uses the default size. Users can change that
// setting using the --disk-cache-size flag.
//
// Note: The value specified in this policy is used as a hint to various cache
// subsystems in the browser. Therefore the actual total disk consumption of all
// caches will be higher but within the same order of magnitude as the value
// specified.
//
// Supported on: fuchsia, linux, mac, win
message DiskCacheSizeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DiskCacheSize = 2;
}

// Set media disk cache size in bytes
//
// Setting the policy configures the cache size that Google Chrome uses for
// storing cached media files on the disk, regardless of whether or not users
// specify the --media-cache-size flag. The value specified in this policy isn't
// a hard boundary, but a suggestion to the caching system. Any value below a
// few megabytes is rounded up.
//
// Setting the value of the policy to 0 uses the default cache size, and users
// can't change it.
//
// Leaving the policy unset uses the default cache size and users can change it
// with the --media-cache-size flag.
//
// Supported on:
message MediaCacheSizeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 MediaCacheSize = 2;
}

// Enable download bubble UI
//
// Setting the policy to Enabled or leaving it unset shows the new download
// bubble UI in Google Chrome.
//
// Setting the policy to Disabled means Google Chrome keeps showing the old
// download shelf UI.
//
// Valid values:
//   True: Enable download bubble UI
//   False: Disable download bubble UI
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DownloadBubbleEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DownloadBubbleEnabled = 2;
}

// Allow download restrictions
//
// Setting the policy means users can't bypass download security decisions.
//
// There are many types of download warnings within Chrome, which roughly break
// down into these categories (learn more about Safe Browsing verdicts
// https://support.google.com/chrome/?p=ib_download_blocked):
//
// * Malicious, as flagged by the Safe Browsing server
// * Uncommon or unwanted, as flagged by the Safe Browsing server
// * A dangerous file type (e.g. all SWF downloads and many EXE downloads)
//
// Setting the policy blocks different subsets of these, depending on it's
// value:
//
// 0: No special restrictions. Default.
//
// 1: Blocks malicious files flagged by the Safe Browsing server AND Blocks all
// dangerous file types. Only recommended for OUs/browsers/users that have a
// high tolerance for False Positives.
//
// 2: Blocks malicious files flagged by the Safe Browsing server AND Blocks
// uncommon or unwanted files flagged by the Safe Browsing server AND Blocks all
// dangerous file types. Only recommended for OUs/browsers/users that have a
// high tolerance for False Positives.
//
// 3: Blocks all downloads. Not recommended, except for special use cases.
//
// 4: Blocks malicious files flagged by the Safe Browsing server, does not block
// dangerous file types. Recommended.
//
// Note: These restrictions apply to downloads triggered from webpage content,
// as well as the Download link... menu option. They don't apply to the download
// of the currently displayed page or to saving as PDF from the printing
// options. Read more about Safe Browsing ( https://developers.google.com/safe-
// browsing ).
//
// Valid values:
//   0: No special restrictions. Default.
//   1: Block malicious downloads and dangerous file types.
//   2: Block malicious downloads, uncommon or unwanted downloads and dangerous
// file types.
//   3: Block all downloads.
//   4: Block malicious downloads. Recommended.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DownloadRestrictionsProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DownloadRestrictions = 2;
}

// Set download directory
//
// Setting the policy sets up the directory Chrome uses for downloading files.
// It uses the provided directory, whether or not users specify one or turned on
// the flag to be prompted for download location every time.
//
// This policy overrides the DefaultDownloadDirectory policy.
//
// Leaving the policy unset means Chrome uses the default download directory,
// and users can change it.
//
// Note: See a list of variables you can use (
// https://www.chromium.org/administrators/policy-list-3/user-data-directory-
// variables ).
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DownloadDirectoryProto {
  optional PolicyOptions policy_options = 1;
  optional string DownloadDirectory = 2;
}

// List of file types that should be automatically opened on download
//
// List of file types that should be automatically opened on download. The
// leading separator should not be included when listing the file type, so list
// "txt" instead of ".txt".
//
// Files with types that should be automatically opened will still be subject to
// the enabled safe browsing checks and won't be opened if they fail those
// checks.
//
// If this policy isn't set, only file types that a user has already specified
// to automatically be opened will do so when downloaded.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AutoOpenFileTypesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AutoOpenFileTypes = 2;
}

// URLs where AutoOpenFileTypes can apply
//
// List of URLs specifying which urls AutoOpenFileTypes will apply to. This
// policy has no impact on automatically open values set by users.
//
// If this policy is set, files will only automatically open by policy if the
// url is part of this set and the file type is listed in AutoOpenFileTypes. If
// either condition is false the download won't automatically open by policy.
//
// If this policy isn't set, all downloads where the file type is in
// AutoOpenFileTypes will automatically open.
//
// A URL pattern has to be formatted according to
// https://www.chromium.org/administrators/url-blocklist-filter-format.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AutoOpenAllowedForURLsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AutoOpenAllowedForURLs = 2;
}

// Define a list of protocols that can launch an external application from
// listed origins without prompting the user
//
// Allows you to set a list of protocols, and for each protocol an associated
// list of allowed origin patterns, that can launch an external application
// without prompting the user. The trailing separator should not be included
// when listing the protocol, so list "skype" instead of "skype:" or "skype://".
//
// If this policy is set, a protocol will only be permitted to launch an
// external application without prompting by policy if the protocol is listed,
// and the origin of the site trying to launch the protocol matches one of the
// origin patterns in that protocol's allowed_origins list. If either condition
// is false the external protocol launch prompt will not be omitted by policy.
//
// If this policy is not set, no protocols can launch without a prompt by
// default. Users may opt out of prompts on a per-protocol/per-site basis unless
// the ExternalProtocolDialogShowAlwaysOpenCheckbox policy is set to Disabled.
// This policy has no impact on per-protocol/per-site prompt exemptions set by
// users.
//
// The origin matching patterns use a similar format to those for the
// 'URLBlocklist' policy, which are documented at
// http://www.chromium.org/administrators/url-blocklist-filter-format.
//
// However, origin matching patterns for this policy cannot contain "/path" or
// "@query" elements. Any pattern that does contain a "/path" or "@query"
// element will be ignored.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "allowed_origins": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "protocol": {
//                 "type": "string"
//             }
//         },
//         "required": [
//             "protocol",
//             "allowed_origins"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: fuchsia, linux, mac, win
message AutoLaunchProtocolsFromOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional string AutoLaunchProtocolsFromOrigins = 2;
}

// Enable Safe Browsing for trusted sources
//
// Setting the policy to Enabled or leaving it unset means downloaded files are
// sent to be analyzed by Safe Browsing, even when it's from a trusted source.
//
// Setting the policy to Disabled means downloaded files won't be sent to be
// analyzed by Safe Browsing when it's from a trusted source.
//
// These restrictions apply to downloads triggered from webpage content, as well
// as the Download link menu option. These restrictions don't apply to the save
// or download of the currently displayed page or to saving as PDF from the
// printing options.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Valid values:
//   True: Perform Safe Browsing checks on all downloaded files
//   False: Skip Safe Browsing checks for files download from trusted sources
//
// Supported on: win
message SafeBrowsingForTrustedSourcesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SafeBrowsingForTrustedSourcesEnabled = 2;
}

// Clear site data on browser shutdown (deprecated)
//
// This policy has been retired as of Google Chrome version 29.
//
// Supported on:
message ClearSiteDataOnExitProto {
  optional PolicyOptions policy_options = 1;
  optional bool ClearSiteDataOnExit = 2;
}

// Captive portal authentication ignores proxy
//
// Setting the policy to Enabled lets Google ChromeOS bypass any proxy for
// captive portal authentication. These authentication webpages, starting from
// the captive portal sign-in page until Chrome detects a successful internet
// connection, open in a separate window, ignoring all policy settings and
// restrictions for the current user. This policy only takes effect if a proxy
// is set up (by policy, extension, or the user in chrome://settings).
//
// Setting the policy to Disabled or leaving it unset means any captive portal
// authentication pages are shown in a (regular) new browser tab, using the
// current user's proxy settings.
//
// Valid values:
//   True: Allow captive portal authentication to ignore proxy settings
//   False: Prevent captive portal authentication from ignoring proxy settings
//
// Supported on: chrome_os
message CaptivePortalAuthenticationIgnoresProxyProto {
  optional PolicyOptions policy_options = 1;
  optional bool CaptivePortalAuthenticationIgnoresProxy = 2;
}

// Choose how to specify proxy server settings
//
// This policy is deprecated, please use ProxySettings instead.
//
// Setting the policy to Enabled lets you specify the proxy server Chrome uses
// and prevents users from changing proxy settings. Chrome and ARC-apps ignore
// all proxy-related options specified from the command line. The policy only
// takes effect if the ProxySettings policy isn't specified.
//
// Other options are ignored if you choose:
// * direct = Never use a proxy server and always connect directly
// * system = Use system proxy settings
// * auto_detect = Auto detect the proxy server
//
// If you choose to use:
// * fixed_servers = Fixed proxy servers. You can specify further options with
// ProxyServer and ProxyBypassList. Only the HTTP proxy server with the highest
// priority is available for ARC-apps.
// * pac_script =  A .pac proxy script. Use ProxyPacUrl to set the URL to a
// proxy .pac file.
//
// Leaving the policy unset lets users choose the proxy settings.
//
// Note: For detailed examples, visit The Chromium Projects (
// https://www.chromium.org/developers/design-documents/network-settings#TOC-
// Command-line-options-for-proxy-sett ).
//
// Valid values:
//   direct: Never use a proxy
//   auto_detect: Auto detect proxy settings
//   pac_script: Use a .pac proxy script
//   fixed_servers: Use fixed proxy servers
//   system: Use system proxy settings
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ProxyModeProto {
  optional PolicyOptions policy_options = 1;
  optional string ProxyMode = 2;
}

// Choose how to specify proxy server settings
//
// This policy is deprecated, use ProxyMode instead.
//
// Allows you to specify the proxy server used by Google Chrome and prevents
// users from changing proxy settings.
//
// This policy only takes effect  if the ProxySettings policy has not been
// specified.
//
// If you choose to never use a proxy server and always connect directly, all
// other options are ignored.
//
// If you choose to use system proxy settings or auto detect the proxy server,
// all other options are ignored.
//
// If you choose manual proxy settings, you can specify further options in
// 'Address or URL of proxy server', 'URL to a proxy .pac file' and 'Comma-
// separated list of proxy bypass rules'. Only the HTTP proxy server with the
// highest priority is available for ARC-apps.
//
// For detailed examples, visit:
// https://www.chromium.org/developers/design-documents/network-settings#TOC-
// Command-line-options-for-proxy-sett.
//
// If you enable this setting, Google Chrome ignores all proxy-related options
// specified from the command line.
//
// Leaving this policy not set will allow the users to choose the proxy settings
// on their own.
//
// Valid values:
//   0: Never use a proxy
//   1: Auto detect proxy settings
//   2: Manually specify proxy settings
//   3: Use system proxy settings
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ProxyServerModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ProxyServerMode = 2;
}

// Address or URL of proxy server
//
// This policy is deprecated, please use ProxySettings instead.
//
// Setting the policy lets you specify the URL of the proxy server. This policy
// only takes effect if the ProxySettings policy isn't specified and you
// selected fixed_servers with ProxyMode.
//
// Leave this policy unset if you selected any other mode for setting proxy
// policies.
//
// Note: For detailed examples, visit The Chromium Projects (
// https://www.chromium.org/developers/design-documents/network-settings#TOC-
// Command-line-options-for-proxy-sett ).
//
// Supported on: android, chrome_os, linux, mac, win
message ProxyServerProto {
  optional PolicyOptions policy_options = 1;
  optional string ProxyServer = 2;
}

// URL to a proxy .pac file
//
// This policy is deprecated, please use ProxySettings instead.
//
// Setting the policy lets you specify a URL to a proxy .pac file. This policy
// only takes effect if the ProxySettings policy isn't specified and you
// selected pac_script with ProxyMode.
//
// Leave this policy unset if you selected any other mode for setting proxy
// policies.
//
// Note: For detailed examples, visit The Chromium Projects (
// https://www.chromium.org/developers/design-documents/network-settings#TOC-
// Command-line-options-for-proxy-sett ).
//
// Supported on: android, chrome_os, linux, mac, win
message ProxyPacUrlProto {
  optional PolicyOptions policy_options = 1;
  optional string ProxyPacUrl = 2;
}

// Proxy bypass rules
//
// This policy is deprecated, please use ProxySettings instead.
//
// Setting the policy means Google Chrome bypasses any proxy for the list of
// hosts given here. This policy only takes effect if the ProxySettings policy
// isn't specified and you specified either fixed_servers or pac_script for
// ProxyMode.
//
// Leave this policy unset if you selected any other mode for setting proxy
// policies.
//
// Note: For more detailed examples, visit The Chromium Projects (
// https://www.chromium.org/developers/design-documents/network-settings#TOC-
// Command-line-options-for-proxy-sett ).
//
// Supported on: android, chrome_os, linux, mac, win
message ProxyBypassListProto {
  optional PolicyOptions policy_options = 1;
  optional string ProxyBypassList = 2;
}

// Proxy settings
//
// Setting the policy configures the proxy settings for Chrome and ARC-apps,
// which ignore all proxy-related options specified from the command line.
//
// Leaving the policy unset lets users choose their proxy settings.
//
// Setting the ProxySettings policy accepts the following fields:
// * ProxyMode, which lets you specify the proxy server Chrome uses and prevents
// users from changing proxy settings
// * ProxyPacUrl, a URL to a proxy .pac file
// * ProxyPacMandatory, which prevents the network stack from falling back to
// direct connections with invalid or unavailable PAC script
// * ProxyServer, a URL of the proxy server
// * ProxyBypassList, a list of hosts for which the proxy will be bypassed
//
// The ProxyServerMode field is deprecated in favor of the ProxyMode field.
//
// For ProxyMode, if you choose the value:
// * direct, a proxy is never used and all other fields are ignored.
// * system, the systems's proxy is used and all other fields are ignored.
// * auto_detect, all other fields are ignored.
// * fixed_servers, the ProxyServer and ProxyBypassList fields are used.
// * pac_script, the ProxyPacUrl, ProxyPacMandatory and ProxyBypassList fields
// are used.
//
// Note: For more detailed examples, visit The Chromium Projects (
// https://www.chromium.org/developers/design-documents/network-settings#TOC-
// Command-line-options-for-proxy-sett ).
//
// Value schema:
// {
//     "properties": {
//         "ProxyBypassList": {
//             "type": "string"
//         },
//         "ProxyMode": {
//             "enum": [
//                 "direct",
//                 "auto_detect",
//                 "pac_script",
//                 "fixed_servers",
//                 "system"
//             ],
//             "type": "string"
//         },
//         "ProxyPacMandatory": {
//             "type": "boolean"
//         },
//         "ProxyPacUrl": {
//             "type": "string"
//         },
//         "ProxyServer": {
//             "type": "string"
//         },
//         "ProxyServerMode": {
//             "$ref": "ProxyServerMode"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ProxySettingsProto {
  optional PolicyOptions policy_options = 1;
  optional string ProxySettings = 2;
}

// Supported authentication schemes
//
// Setting the policy specifies which HTTP authentication schemes Google Chrome
// supports.
//
// Leaving the policy unset employs all 4 schemes.
//
// Valid values:
//
// * basic
//
// * digest
//
// * ntlm
//
// * negotiate
//
// Note: Separate multiple values with commas.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AuthSchemesProto {
  optional PolicyOptions policy_options = 1;
  optional string AuthSchemes = 2;
}

// List of origins allowing all HTTP authentication
//
// Setting the policy specifies for which origins to allow all the HTTP
// authentication schemes Google Chrome supports regardless of the AuthSchemes
// policy.
//
// Format the origin pattern according to this format
// (https://www.chromium.org/administrators/url-blocklist-filter-format). Up to
// 1,000 exceptions can be defined in AllHttpAuthSchemesAllowedForOrigins.
// Wildcards are allowed for the whole origin or parts of the origin, either the
// scheme, host, port.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AllHttpAuthSchemesAllowedForOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AllHttpAuthSchemesAllowedForOrigins = 2;
}

// Disable CNAME lookup when negotiating Kerberos authentication
//
// Setting the policy to Enabled skips CNAME lookup. The server name is used as
// entered when generating the Kerberos SPN.
//
// Setting the policy to Disabled or leaving it unset means CNAME lookup
// determines the canonical name of the server when generating the Kerberos SPN.
//
// Valid values:
//   True: Disable CNAME lookup during Kerberos authentication
//   False: Use CNAME lookup during Kerberos authentication
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DisableAuthNegotiateCnameLookupProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisableAuthNegotiateCnameLookup = 2;
}

// Include non-standard port in Kerberos SPN
//
// Setting the policy to Enabled and entering a nonstandard port (in other
// words, a port other than 80 or 443) includes it in the generated Kerberos
// SPN.
//
// Setting the policy to Disabled or leaving it unset means the generated
// Kerberos SPN won't include a port.
//
// Valid values:
//   True: Include non-standard port in generated Kerberos SPN
//   False: Do not include port in generated Kerberos SPN
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message EnableAuthNegotiatePortProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableAuthNegotiatePort = 2;
}

// Allow Basic authentication for HTTP
//
// Setting the policy to Enabled or leaving it unset will allow Basic
// authentication challenges received over non-secure HTTP.
//
// Setting the policy to Disabled forbids non-secure HTTP requests from using
// the Basic authentication scheme; only secure HTTPS is allowed.
//
// This policy setting is ignored (and Basic is always forbidden) if the
// AuthSchemes policy is set and does not include Basic.
//
// Valid values:
//   True: Basic authentication is allowed on HTTP connections
//   False: Non-secure HTTP connections are not permitted to use Basic
// authentication; HTTPS is required
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message BasicAuthOverHttpEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BasicAuthOverHttpEnabled = 2;
}

// Authentication server whitelist
//
// This policy is deprecated, please use the 'AuthServerAllowlist' policy
// instead.
//
// Setting the policy specifies which servers should be allowed for integrated
// authentication. Integrated authentication is only on when Google Chrome gets
// an authentication challenge from a proxy or from a server in this permitted
// list.
//
// Leaving the policy unset means Google Chrome tries to detect if a server is
// on the intranet. Only then will it respond to IWA requests. If a server is
// detected as internet, then Google Chrome ignores IWA requests from it.
//
// Note: Separate multiple server names with commas. Wildcards, *, are allowed.
//
// Supported on:
message AuthServerWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional string AuthServerWhitelist = 2;
}

// Authentication server allowlist
//
// Setting the policy specifies which servers should be allowed for integrated
// authentication. Integrated authentication is only on when Google Chrome gets
// an authentication challenge from a proxy or from a server in this permitted
// list.
//
// Leaving the policy unset means Google Chrome tries to detect if a server is
// on the intranet. Only then will it respond to IWA requests. If a server is
// detected as internet, then Google Chrome ignores IWA requests from it.
//
// Note: Separate multiple server names with commas. Wildcards, *, are allowed.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AuthServerAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional string AuthServerAllowlist = 2;
}

// Kerberos delegation server whitelist
//
// This policy is deprecated, please use the 'AuthNegotiateDelegateAllowlist'
// policy instead.
//
// Setting the policy assigns servers that Google Chrome may delegate to.
// Separate multiple server names with commas. Wildcards, *, are allowed.
//
// Leaving the policy unset means Google Chrome won't delegate user credentials,
// even if a server is detected as intranet.
//
// Supported on:
message AuthNegotiateDelegateWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional string AuthNegotiateDelegateWhitelist = 2;
}

// Kerberos delegation server allowlist
//
// Setting the policy assigns servers that Google Chrome may delegate to.
// Separate multiple server names with commas. Wildcards, *, are allowed.
//
// Leaving the policy unset means Google Chrome won't delegate user credentials,
// even if a server is detected as intranet.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AuthNegotiateDelegateAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional string AuthNegotiateDelegateAllowlist = 2;
}

// Use KDC policy to delegate credentials.
//
// Setting the policy to Enabled means HTTP authentication respects approval by
// KDC policy. In other words, Google Chrome delegates user credentials to the
// service being accessed if the KDC sets OK-AS-DELEGATE on the service ticket.
// See RFC 5896 ( https://tools.ietf.org/html/rfc5896.html ). The service should
// also be allowed by AuthNegotiateDelegateAllowlist.
//
// Setting the policy to Disabled or leaving it unset means KDC policy is
// ignored on supported platforms and only AuthNegotiateDelegateAllowlist is
// respected.
//
// On Microsoft® Windows®, KDC policy is always respected.
//
// Valid values:
//   True: Use KDC policy approval during HTTP authentication
//   False: Ignore KDC policy approval during HTTP authentication
//
// Supported on: chrome_os, linux, mac
message AuthNegotiateDelegateByKdcPolicyProto {
  optional PolicyOptions policy_options = 1;
  optional bool AuthNegotiateDelegateByKdcPolicy = 2;
}

// Browser experiments icon in toolbar
//
// Setting the policy to Enabled or leaving the policy unset means that users
// can access browser experimental features through an icon in the toolbar
//
// Setting the policy to Disabled removes the browser experimental features icon
// from the toolbar.
//
// chrome://flags and any other means of turning off and on browser features
// will still behave as expected regardless of whether this policy is Enabled or
// Disabled.
//
// Valid values:
//   True: Enable browser experimental features toolbar entrypoint
//   False: Disable browser experimental features toolbar entrypoint
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message BrowserLabsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserLabsEnabled = 2;
}

// GSSAPI library name
//
// Setting the policy specifies which GSSAPI library to use for HTTP
// authentication. Set the policy to either a library name or a full path.
//
// Leaving the policy unset means Google Chrome uses a default library name.
//
// Supported on: linux
message GSSAPILibraryNameProto {
  optional PolicyOptions policy_options = 1;
  optional string GSSAPILibraryName = 2;
}

// Account type for HTTP Negotiate authentication
//
// Setting the policy specifies the type of accounts provided by the Android
// authentication app that supports HTTP Negotiate authentication (such as
// Kerberos authentication). This information should be available from the
// supplier of the authentication app. For details, see The Chromium Projects (
// https://goo.gl/hajyfN )
//
// Leaving the policy unset turns off HTTP Negotiate authentication on Android.
//
// Supported on: android
message AuthAndroidNegotiateAccountTypeProto {
  optional PolicyOptions policy_options = 1;
  optional string AuthAndroidNegotiateAccountType = 2;
}

// Cross-origin HTTP Authentication prompts
//
// Setting the policy to Enabled allows third-party images on a page to show an
// authentication prompt.
//
// Setting the policy to Disabled or leaving it unset renders third-party images
// unable to show an authentication prompt.
//
// Typically, this policy is Disabled as a phishing defense.
//
// Valid values:
//   True: Allow third-party images to show an authentication prompt
//   False: Prevent third-party images from showing an authentication prompt
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AllowCrossOriginAuthPromptProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowCrossOriginAuthPrompt = 2;
}

// Enable NTLMv2 authentication.
//
// Setting the policy to Enabled or leaving it unset turns NTLMv2 on.
//
// Setting the policy to Disabled turns NTLMv2 off.
//
// All recent versions of Samba and Microsoft® Windows® servers support NTLMv2.
// This should only be turned off for backward compatibility as it reduces the
// security of authentication.
//
// Valid values:
//   True: Turn NTLMv2 on
//   False: Turn NTLMv2 off
//
// Supported on: android, chrome_os, linux, mac
message NtlmV2EnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NtlmV2Enabled = 2;
}

// Configure extension installation blacklist
//
// This policy is deprecated, please use the 'ExtensionInstallBlocklist' policy
// instead.
//
// Setting the policy specifies which extensions users can't install. Extensions
// already installed are turned off, if prohibited, without a way for users to
// turn them on. If a prohibited extension gets removed from the blocked list,
// it's automatically re-enabled. Use a value of * to prohibit all extensions,
// except those explicitly allowed.
//
// If the policy is unset, users can install any extension in Google Chrome.
//
// Supported on:
message ExtensionInstallBlacklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionInstallBlacklist = 2;
}

// Configure extension installation blocklist
//
// Allows you to specify which extensions the users can NOT install. Extensions
// already installed will be disabled if blocked, without a way for the user to
// enable them. Once an extension disabled due to the blocklist is removed from
// it, it will automatically get re-enabled.
//
// A blocklist value of '*' means all extensions are blocked unless they are
// explicitly listed in the allowlist.
//
// If this policy is left not set the user can install any extension in Google
// Chrome.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExtensionInstallBlocklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionInstallBlocklist = 2;
}

// Configure extension installation allow list
//
// Setting the policy specifies which extensions are not subject to the
// blocklist.
//
// A blocklist value of * means all extensions are blocked and users can only
// install extensions listed in the allow list.
//
// By default, all extensions are allowed. But, if you prohibited extensions by
// policy, use the list of allowed extensions to change that policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExtensionInstallAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionInstallAllowlist = 2;
}

// Configure extension installation whitelist
//
// This policy is deprecated, please use the 'ExtensionInstallAllowlist' policy
// instead.
//
// Setting the policy specifies which extensions are exempt from the list of
// prohibited extensions. Use a value of * for ExtensionInstallBlacklist to
// prohibit all extensions, and users can only install explicitly allowed
// extensions. By default, all extensions are allowed. But, if you prohibited
// extensions by policy, use the list of allowed extensions to change that
// policy.
//
// Supported on:
message ExtensionInstallWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionInstallWhitelist = 2;
}

// Configure the list of force-installed apps and extensions
//
// Setting the policy specifies a list of apps and extensions that install
// silently, without user interaction, and which users can't uninstall or turn
// off. Permissions are granted implicitly, including for the
// enterprise.deviceAttributes and enterprise.platformKeys extension APIs.
// (These 2 APIs aren't available to apps and extensions that aren't force-
// installed.)
//
// Leaving the policy unset means no apps or extensions are autoinstalled, and
// users can uninstall any app or extension in Google Chrome.
//
// This policy supersedes ExtensionInstallBlocklist policy. If a previously
// force-installed app or extension is removed from this list, Google Chrome
// automatically uninstalls it.
//
// On Microsoft® Windows® instances, apps and extensions from outside the Chrome
// Web Store can only be forced installed if the instance is joined to a
// Microsoft® Active Directory® domain, running on Windows 10 Pro, or enrolled
// in Chrome Browser Cloud Management.
//
// On macOS instances, apps and extensions from outside the Chrome Web Store can
// only be force installed if the instance is managed via MDM, or joined to a
// domain via MCX.
//
// The source code of any extension may be altered by users through developer
// tools, potentially rendering the extension dysfunctional. If this is a
// concern, set the DeveloperToolsDisabled policy.
//
// Each list item of the policy is a string that contains an extension ID and,
// optionally, an "update" URL separated by a semicolon (;). The extension ID is
// the 32-letter string found, for example, on chrome://extensions when in
// Developer mode. If specified, the "update" URL should point to an Update
// Manifest XML document ( https://developer.chrome.com/extensions/autoupdate ).
// By default, the Chrome Web Store's update URL is used. The "update" URL set
// in this policy is only used for the initial installation; subsequent updates
// of the extension use the update URL in the extension's manifest.
//
// Note: This policy doesn't apply to Incognito mode. Read about hosting
// extensions ( https://developer.chrome.com/extensions/hosting ).
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExtensionInstallForcelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionInstallForcelist = 2;
}

// Configure extension, app, and user script install sources
//
// Setting the policy specifies which URLs may install extensions, apps, and
// themes. Before Google Chrome 21, users could click on a link to a *.crx file,
// and Google Chrome would offer to install the file after a few warnings.
// Afterwards, such files must be downloaded and dragged to the Google Chrome
// settings page. This setting allows specific URLs to have the old, easier
// installation flow.
//
// Each item in this list is an extension-style match pattern (see
// https://developer.chrome.com/extensions/match_patterns). Users can easily
// install items from any URL that matches an item in this list. Both the
// location of the *.crx file and the page where the download is started from
// (the referrer) must be allowed by these patterns.
//
// ExtensionInstallBlocklist takes precedence over this policy. That is, an
// extension on the blocklist won't be installed, even if it happens from a site
// on this list.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExtensionInstallSourcesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionInstallSources = 2;
}

// Allow insecure algorithms in integrity checks on extension updates and
// installs
//
// Setting the policy to Enabled means Google Chrome permits installation and
// updates for extensions hosted outside the Chrome Web Store, the content of
// which might only be minimally protected.
//
// Setting the policy to Disabled means Google Chrome won't permit fresh
// installation of (and updates to) such extensions. The policy has no effect in
// Google Chrome 78 and later.
//
// Leaving this policy unset means it is Enabled in Google Chrome 73 to 75, and
// Disabled in Google Chrome 76 and 77.
//
// Valid values:
//   True: Allow installation and updates for extensions hosted outside of
// Chrome Web Store
//   False: Prevent installation and updates for extensions hosted outside of
// Chrome Web Store
//
// Supported on: fuchsia
message ExtensionAllowInsecureUpdatesProto {
  optional PolicyOptions policy_options = 1;
  optional bool ExtensionAllowInsecureUpdates = 2;
}

// Configure allowed app/extension types
//
// Setting the policy controls which apps and extensions may be installed in
// Google Chrome, which hosts they can interact with, and limits runtime access.
//
// Leaving the policy unset results in no restrictions on the acceptable
// extension and app types.
//
// Extensions and apps which have a type that's not on the list won't be
// installed. Each value should be one of these strings:
//
// * "extension"
//
// * "theme"
//
// * "user_script"
//
// * "hosted_app"
//
// * "legacy_packaged_app"
//
// * "platform_app"
//
// See the Google Chrome extensions documentation for more information on these
// types.
//
// Versions earlier than 75 that use multiple comma separated extension IDs
// aren't supported and are skipped. The rest of the policy applies.
//
// Note: This policy also affects extensions and apps to be force-installed
// using ExtensionInstallForcelist.
//
// Valid values:
//   extension: Extension
//   theme: Theme
//   user_script: User script
//   hosted_app: Hosted app
//   legacy_packaged_app: Legacy packaged app
//   platform_app: Platform app
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExtensionAllowedTypesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExtensionAllowedTypes = 2;
}

// Extension management settings
//
// Setting the policy controls extension management settings for Google Chrome,
// including any controlled by existing extension-related policies. The policy
// supersedes any legacy policies that might be set.
//
// This policy maps an extension ID or an update URL to its specific setting
// only. A default configuration can be set for the special ID "*", which
// applies to all extensions without a custom configuration in this policy. With
// an update URL, configuration applies to extensions with the exact update URL
// stated in the extension manifest (
// http://support.google.com/chrome/a?p=Configure_ExtensionSettings_policy ). If
// the 'override_update_url' flag is set to true, the extension is installed and
// updated using the "update" URL specified in the ExtensionInstallForcelist
// policy or in 'update_url' field in this policy. The flag
// 'override_update_url' is ignored if the 'update_url' is a Chrome Web Store
// url.
//
// Note: For Microsoft® Windows® instances not joined to a Microsoft® Active
// Directory® domain and macOS instances not managed via MDM or joined to a
// domain via MCX, forced installation is limited to apps and extensions listed
// in the Chrome Web Store.
//
// Value schema:
// {
//     "patternProperties": {
//         "^[a-p]{32}(?:,[a-p]{32})*,?$": {
//             "properties": {
//                 "allowed_permissions": {
//                     "$ref": "ListOfPermissions"
//                 },
//                 "blocked_install_message": {
//                     "description": "text that will be displayed to the user
// in the chrome webstore if installation is blocked.",
//                     "type": "string"
//                 },
//                 "blocked_permissions": {
//                     "id": "ListOfPermissions",
//                     "items": {
//                         "pattern": "^[a-z][a-zA-Z0-9.]*$",
//                         "type": "string"
//                     },
//                     "type": "array"
//                 },
//                 "installation_mode": {
//                     "enum": [
//                         "blocked",
//                         "allowed",
//                         "force_installed",
//                         "normal_installed",
//                         "removed"
//                     ],
//                     "type": "string"
//                 },
//                 "minimum_version_required": {
//                     "pattern": "^[0-9]+([.][0-9]+)*$",
//                     "type": "string"
//                 },
//                 "override_update_url": {
//                     "type": "boolean"
//                 },
//                 "runtime_allowed_hosts": {
//                     "$ref": "ListOfUrlPatterns"
//                 },
//                 "runtime_blocked_hosts": {
//                     "id": "ListOfUrlPatterns",
//                     "items": {
//                         "type": "string"
//                     },
//                     "type": "array"
//                 },
//                 "toolbar_pin": {
//                     "enum": [
//                         "force_pinned",
//                         "default_unpinned"
//                     ],
//                     "type": "string"
//                 },
//                 "update_url": {
//                     "type": "string"
//                 }
//             },
//             "type": "object"
//         },
//         "^update_url:": {
//             "properties": {
//                 "allowed_permissions": {
//                     "$ref": "ListOfPermissions"
//                 },
//                 "blocked_permissions": {
//                     "$ref": "ListOfPermissions"
//                 },
//                 "installation_mode": {
//                     "enum": [
//                         "blocked",
//                         "allowed",
//                         "removed"
//                     ],
//                     "type": "string"
//                 }
//             },
//             "type": "object"
//         }
//     },
//     "properties": {
//         "*": {
//             "properties": {
//                 "allowed_types": {
//                     "$ref": "ExtensionAllowedTypes"
//                 },
//                 "blocked_install_message": {
//                     "type": "string"
//                 },
//                 "blocked_permissions": {
//                     "$ref": "ListOfPermissions"
//                 },
//                 "install_sources": {
//                     "$ref": "ExtensionInstallSources"
//                 },
//                 "installation_mode": {
//                     "enum": [
//                         "blocked",
//                         "allowed",
//                         "removed"
//                     ],
//                     "type": "string"
//                 },
//                 "runtime_allowed_hosts": {
//                     "$ref": "ListOfUrlPatterns"
//                 },
//                 "runtime_blocked_hosts": {
//                     "$ref": "ListOfUrlPatterns"
//                 }
//             },
//             "type": "object"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExtensionSettingsProto {
  optional PolicyOptions policy_options = 1;
  optional string ExtensionSettings = 2;
}

// Blocks external extensions from being installed
//
// Controls external extensions installation.
//
// Setting this policy to Enabled blocks external extensions from being
// installed.
//
// Setting this policy to Disabled or leaving it unset allows external
// extensions to be installed.
//
// External extensions and their installation are documented at
// https://developer.chrome.com/apps/external_extensions.
//
// Valid values:
//   True: Block installation of external extensions
//   False: Allow installation of external extensions
//
// Supported on: fuchsia, linux, mac, win
message BlockExternalExtensionsProto {
  optional PolicyOptions policy_options = 1;
  optional bool BlockExternalExtensions = 2;
}

// Show Home button on toolbar
//
// Setting the policy to Enabled shows the Home button on Google Chrome's
// toolbar. Setting the policy to Disabled keeps the Home button from appearing.
//
// If you set the policy, users can't change it in Google Chrome. If not set,
// users chooses whether to show the Home button.
//
// Valid values:
//   True: Show the Home button on the toolbar
//   False: Hide the Home button from the toolbar
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ShowHomeButtonProto {
  optional PolicyOptions policy_options = 1;
  optional bool ShowHomeButton = 2;
}

// Disable Developer Tools
//
// This policy is deprecated in M68, please use DeveloperToolsAvailability
// instead.
//
// Disables the Developer Tools and the JavaScript console.
//
// If you enable this setting, the Developer Tools can not be accessed and web-
// site elements can not be inspected anymore. Any keyboard shortcuts and any
// menu or context menu entries to open the Developer Tools or the JavaScript
// Console will be disabled.
//
// Setting this option to disabled or leaving it not set allows the user to use
// the Developer Tools and the JavaScript console.
//
// If the policy DeveloperToolsAvailability is set, the value of the policy
// DeveloperToolsDisabled is ignored.
//
// Valid values:
//   True: Disable Developer Tools
//   False: Enable Developer Tools
//
// Supported on: chrome_os, linux, mac, win
message DeveloperToolsDisabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DeveloperToolsDisabled = 2;
}

// Control where Developer Tools can be used
//
// Setting the policy to 0 (the default) means you can access the developer
// tools and the JavaScript console, but not in the context of extensions
// installed by enterprise policy. Setting the policy to 1 means you can access
// the developer tools and the JavaScript console in all contexts, including
// that of extensions installed by enterprise policy. Setting the policy to 2
// means you can't acess developer tools, and you can't inspect website
// elements.
//
// This setting also turns off keyboard shortcuts and menu or context menu
// entries to open developer tools or the JavaScript console.
//
// As of Google Chrome version 99, this setting also controls entry points for
// the 'View page source' feature. If you set this policy to
// 'DeveloperToolsDisallowed' (value 2), users cannot access source viewing via
// keyboard shortcut or the context menu. To fully block source viewing, you
// must also add 'view-source:*' to the URLBlocklist policy.
//
// Valid values:
//   0: Disallow usage of the Developer Tools on extensions installed by
// enterprise policy, allow usage of the Developer Tools in other contexts
//   1: Allow usage of the Developer Tools
//   2: Disallow usage of the Developer Tools
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DeveloperToolsAvailabilityProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DeveloperToolsAvailability = 2;
}

// Allow remote debugging
//
// Controls whether users may use remote debugging.
//
// If this policy is set to Enabled or not set, users may use remote debugging
// by specifying --remote-debugging-port and --remote-debugging-pipe command
// line switches.
//
// If this policy is set to Disabled, users are not allowed to use remote
// debugging.
//
// Valid values:
//   True: Allow use of the remote debugging
//   False: Do not allow use of the remote debugging
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RemoteDebuggingAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool RemoteDebuggingAllowed = 2;
}

// Control use of the Headless Mode
//
// Setting this policy to Enabled or leaving the policy unset allows use of the
// headless mode. Setting this policy to Disabled denies use of the headless
// mode.
//
// Valid values:
//   1: Allow use of the Headless Mode
//   2: Do not allow use of the Headless Mode
//
// Supported on: fuchsia, linux, mac, win
message HeadlessModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 HeadlessMode = 2;
}

// Action on startup
//
// Setting the policy lets you specify system behavior on startup. Turning this
// setting off amounts to leaving it unset as Google Chrome must have specified
// start up behavior.
//
// If you set the policy, users can't change it in Google Chrome. If not set,
// users can change it.
//
// Setting this policy to RestoreOnStartupIsLastSession or
// RestoreOnStartupIsLastSessionAndURLs turns off some settings that rely on
// sessions or that perform actions on exit, such as clearing browsing data on
// exit or session-only cookies.
//
// If this policy is set to RestoreOnStartupIsLastSessionAndURLs, browser will
// restore previous session and open a separate window to show URLs that are set
// from RestoreOnStartupURLs. Note that users can choose to keep those URLs open
// and they will also be restored in the future session.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain domain, running on
// Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS,
// this functionality is only available on instances that are managed via MDM,
// or joined to a domain via MCX.
//
// Valid values:
//   5: Open New Tab Page
//   1: Restore the last session
//   4: Open a list of URLs
//   6: Open a list of URLs and restore the last session
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RestoreOnStartupProto {
  optional PolicyOptions policy_options = 1;
  optional int64 RestoreOnStartup = 2;
}

// URLs to open on startup
//
// If RestoreOnStartup is set to RestoreOnStartupIsURLs, then setting
// RestoreOnStartupURLs to a list of URLs specify which URLs open.
//
// If not set, the New Tab page opens on start up.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain domain, running on
// Windows 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS,
// this functionality is only available on instances that are managed via MDM,
// or joined to a domain via MCX.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RestoreOnStartupURLsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RestoreOnStartupURLs = 2;
}

// Block third party cookies
//
// Setting the policy to Enabled prevents webpage elements that aren't from the
// domain that's in the browser's address bar from setting cookies. Setting the
// policy to Disabled lets those elements set cookies and prevents users from
// changing this setting.
//
// Leaving it unset turns third-party cookies on, but users can change this
// setting.
//
// Valid values:
//   True: Block 3rd party cookies
//   False: Allow 3rd party cookies
//   None: Allow 3rd party cookies, but allow the user to change this setting
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message BlockThirdPartyCookiesProto {
  optional PolicyOptions policy_options = 1;
  optional bool BlockThirdPartyCookies = 2;
}

// Enable the default search provider
//
// Setting the policy to Enabled means a default search is performed when a user
// enters non-URL text in the address bar. To specify the default search
// provider, set the rest of the default search policies. If you leave those
// policies empty, the user can choose the default provider. Setting the policy
// to Disabled means there's no search when the user enters non-URL text in the
// address bar.
//
// If you set the policy, users can't change it in Google Chrome. If not set,
// the default search provider is on, and users can set the search provider
// list.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Valid values:
//   True: Enable the default search provider
//   False: Disable the default search provider
//   None: Enable the default search provider and allow users to modify the
// search provier list
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DefaultSearchProviderEnabled = 2;
}

// Allow default search provider context menu search access
//
// Enables the use of a default search provider on the context menu.
//
// If you set this policy to disabled the search context menu item that relies
// on your default search provider will not be available.
//
// If this policy is set to enabled or not set, the context menu item for your
// default search provider will be available.
//
// The policy value is only appled when the DefaultSearchProviderEnabled policy
// is enabled, and is not applicable otherwise.
//
// Valid values:
//   True: Enable access to the default search provider context menu
//   False: Disable access to the default search provider context menu
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultSearchProviderContextMenuAccessAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool DefaultSearchProviderContextMenuAccessAllowed = 2;
}

// Default search provider name
//
// If DefaultSearchProviderEnabled is on, then setting DefaultSearchProviderName
// specifies the default search provider's name.
//
// Leaving DefaultSearchProviderName unset means the hostname specified by the
// search URL is used.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderNameProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderName = 2;
}

// Default search provider keyword
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderKeyword specifies the keyword or shortcut used in the
// address bar to trigger the search for this provider.
//
// Leaving DefaultSearchProviderKeyword unset means no keyword activates the
// search provider.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderKeywordProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderKeyword = 2;
}

// Default search provider search URL
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderSearchURL specifies the URL of the search engine used
// during a default search. The URL should include the string '{searchTerms}',
// replaced in the query by the user's search terms.
//
// You can specify Google's search URL as: '{google:baseURL}search?q={searchTerm
// s}&amp;{google:RLZ}{google:originalQueryForSuggestion}{google:assistedQuerySt
// ats}{google:searchFieldtrialParameter}{google:searchClient}{google:sourceId}i
// e={inputEncoding}'.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderSearchURLProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderSearchURL = 2;
}

// Default search provider suggest URL
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderSuggestURL specifies the URL of the search engine to
// provide search suggestions. The URL should include the string
// '{searchTerms}', replaced in the query by the user's search terms.
//
// You can specify Google's search URL as:
// '{google:baseURL}complete/search?output=chrome&amp;q={searchTerms}'.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderSuggestURLProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderSuggestURL = 2;
}

// Default search provider instant URL
//
// Specifies the URL of the search engine used to provide instant results. The
// URL should contain the string '{searchTerms}', which will be replaced at
// query time by the text the user has entered so far.
//
// This policy is optional. If not set, no instant search results will be
// provided.
//
// Google's instant results URL can be specified as:
// '{google:baseURL}suggest?q={searchTerms}'.
//
// This policy is only respected if the 'DefaultSearchProviderEnabled' policy is
// enabled.
//
// Supported on:
message DefaultSearchProviderInstantURLProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderInstantURL = 2;
}

// Default search provider icon
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderIconURL specifies the default search provider's favorite
// icon URL.
//
// Leaving DefaultSearchProviderIconURL unset means there's no icon for the
// search provider.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderIconURLProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderIconURL = 2;
}

// Default search provider encodings
//
// If DefaultSearchProviderEnabled is on, setting DefaultSearchProviderEncodings
// specifies the character encodings supported by the search provider. Encodings
// are code page names such as UTF-8, GB2312, and ISO-8859-1. They're tried in
// the order provided.
//
// Leaving DefaultSearchProviderEncodings unset puts UTF-8 in use.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderEncodingsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList DefaultSearchProviderEncodings = 2;
}

// List of alternate URLs for the default search provider
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderAlternateURLs specifies a list of alternate URLs for
// extracting search terms from the search engine. The URLs should include the
// string '{searchTerms}'.
//
// Leaving DefaultSearchProviderAlternateURLs unset means no alternate URLs are
// used to extract search terms.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderAlternateURLsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList DefaultSearchProviderAlternateURLs = 2;
}

// Parameter controlling search term placement for the default search provider
//
// If this policy is set and a search URL suggested from the omnibox contains
// this parameter in the query string or in the fragment identifier, then the
// suggestion will show the search terms and search provider instead of the raw
// search URL.
//
// This policy is optional. If not set, no search term replacement will be
// performed.
//
// This policy is only respected if the 'DefaultSearchProviderEnabled' policy is
// enabled.
//
// Supported on:
message DefaultSearchProviderSearchTermsReplacementKeyProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderSearchTermsReplacementKey = 2;
}

// Parameter providing search-by-image feature for the default search provider
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderImageURL specifies the URL of the search engine used for
// image search. (If DefaultSearchProviderImageURLPostParams is set, then image
// search requests use the POST method instead.)
//
// Leaving DefaultSearchProviderImageURL unset means no image search is used.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderImageURLProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderImageURL = 2;
}

// Default search provider new tab page URL
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderNewTabURL specifies the URL of the search engine used to
// provide a New Tab page.
//
// Leaving DefaultSearchProviderNewTabURL unset means no new tab page is
// provided.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderNewTabURLProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderNewTabURL = 2;
}

// Parameters for search URL which uses POST
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderSearchURLPostParams specifies the parameters when
// searching a URL with POST. It consists of comma-separated, name-value pairs.
// If a value is a template parameter, such as '{searchTerms}', real search
// terms data replaces it.
//
// Leaving DefaultSearchProviderSearchURLPostParams unset means search requests
// are sent using the GET method.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderSearchURLPostParamsProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderSearchURLPostParams = 2;
}

// Parameters for suggest URL which uses POST
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderSuggestURLPostParams specifies the parameters during
// suggestion search with POST. It consists of comma-separated, name-value
// pairs. If a value is a template parameter, such as '{searchTerms}', real
// search terms data replaces it.
//
// Leaving DefaultSearchProviderSuggestURLPostParams unset unset means suggest
// search requests are sent using the GET method.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderSuggestURLPostParamsProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderSuggestURLPostParams = 2;
}

// Parameters for instant URL which uses POST
//
// Specifies the parameters used when doing instant search with POST. It
// consists of comma-separated name/value pairs. If a value is a template
// parameter, like {searchTerms} in above example, it will be replaced with real
// search terms data.
//
// This policy is optional. If not set, instant search request will be sent
// using the GET method.
//
// This policy is only respected if the 'DefaultSearchProviderEnabled' policy is
// enabled.
//
// Supported on:
message DefaultSearchProviderInstantURLPostParamsProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderInstantURLPostParams = 2;
}

// Parameters for image URL which uses POST
//
// If DefaultSearchProviderEnabled is on, then setting
// DefaultSearchProviderImageURLPostParams specifies the parameters during image
// search with POST. It consists of comma-separated, name-value pairs. If a
// value is a template parameter, such as {imageThumbnail}, real image thumbnail
// data replaces it.
//
// Leaving DefaultSearchProviderImageURLPostParams unset means image search
// request is sent using the GET method.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultSearchProviderImageURLPostParamsProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultSearchProviderImageURLPostParams = 2;
}

// Default cookies setting
//
// Unless the RestoreOnStartup policy is set to permanently restore URLs from
// previous sessions, then setting CookiesSessionOnlyForUrls lets you make a
// list of URL patterns that specify sites that can and can't set cookies for
// one session.
//
// Leaving the policy unset results in the use of DefaultCookiesSetting for all
// sites, if it's set. If not, the user's personal setting applies. URLs not
// covered by the patterns specified also result in the use of defaults.
//
// While no specific policy takes precedence, see CookiesBlockedForUrls and
// CookiesAllowedForUrls. URL patterns among these 3 policies must not conflict.
//
// Valid values:
//   1: Allow all sites to set local data
//   2: Do not allow any site to set local data
//   4: Keep cookies for the duration of the session
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultCookiesSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultCookiesSetting = 2;
}

// Default images setting
//
// Setting the policy to 1 lets all websites display images. Setting the policy
// to 2 denies image display.
//
// Leaving it unset allows images, but users can change this setting.
//
// Valid values:
//   1: Allow all sites to show all images
//   2: Do not allow any site to show images
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultImagesSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultImagesSetting = 2;
}

// Default JavaScript setting
//
// Setting the policy to 1 lets websites run JavaScript. Setting the policy to 2
// denies JavaScript.
//
// Leaving it unset allows JavaScript, but users can change this setting.
//
// Valid values:
//   1: Allow all sites to run JavaScript
//   2: Do not allow any site to run JavaScript
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultJavaScriptSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultJavaScriptSetting = 2;
}

// Default Flash setting
//
// This policy is deprecated in M88, Flash is no longer supported by Chrome.
// Setting the policy to 1 lets you set whether all websites can automatically
// run the Flash plugin. Setting the policy to 2 denies this plugin for all
// websites. Click to play lets the Flash plugin run, but users click on the
// placeholder to start it.
//
// Leaving the policy unset uses BlockPlugins and lets users change this
// setting.
//
// Note: Automatic playback is only for domains explicitly listed in the
// PluginsAllowedForUrls policy. To turn automatic playback on for all sites,
// add http://* and https://* to this list.
//
// Valid values:
//   1: Allow all sites to automatically run the Flash plugin
//   2: Block the Flash plugin
//   3: Click to play
//
// Supported on:
message DefaultPluginsSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultPluginsSetting = 2;
}

// Default pop-ups setting
//
// Setting the policy to 1 lets websites display pop-ups. Setting the policy to
// 2 denies pop-ups.
//
// Leaving it unset means BlockPopups applies, but users can change this
// setting.
//
// Valid values:
//   1: Allow all sites to show pop-ups
//   2: Do not allow any site to show pop-ups
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DefaultPopupsSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultPopupsSetting = 2;
}

// Default notification setting
//
// Setting the policy to 1 lets websites display desktop notifications. Setting
// the policy to 2 denies desktop notifications.
//
// Leaving it unset means AskNotifications applies, but users can change this
// setting.
//
// Valid values:
//   1: Allow sites to show desktop notifications
//   2: Do not allow any site to show desktop notifications
//   3: Ask every time a site wants to show desktop notifications
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultNotificationsSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultNotificationsSetting = 2;
}

// Default geolocation setting
//
// Setting the policy to 1 lets sites track the users' physical location as the
// default state. Setting the policy to 2 denies this tracking by default. You
// can set the policy to ask whenever a site wants to track the users' physical
// location.
//
// Leaving the policy unset means the AskGeolocation policy applies, but users
// can change this setting.
//
// Valid values:
//   1: Allow sites to track the users' physical location
//   2: Do not allow any site to track the users' physical location
//   3: Ask whenever a site wants to track the users' physical location
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultGeolocationSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultGeolocationSetting = 2;
}

// Default mediastream setting
//
// Allows you to set whether websites are allowed to get access to media capture
// devices. Access to media capture devices can be allowed by default, or the
// user can be asked every time a website wants to get access to media capture
// devices.
//
// If this policy is left not set, 'PromptOnAccess' will be used and the user
// will be able to change it.
//
// Valid values:
//   2: Do not allow any site to access the camera and microphone
//   3: Ask every time a site wants to access the camera and/or microphone
//
// Supported on: chrome_os, linux, mac, win
message DefaultMediaStreamSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultMediaStreamSetting = 2;
}

// Control use of the Web Bluetooth API
//
// Setting the policy to 3 lets websites ask for access to nearby Bluetooth
// devices. Setting the policy to 2 denies access to nearby Bluetooth devices.
//
// Leaving the policy unset lets sites ask for access, but users can change this
// setting.
//
// Valid values:
//   2: Do not allow any site to request access to Bluetooth devices via the Web
// Bluetooth API
//   3: Allow sites to ask the user to grant access to a nearby Bluetooth device
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultWebBluetoothGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultWebBluetoothGuardSetting = 2;
}

// Default key generation setting
//
// Allows you to set whether websites are allowed to use key generation. Using
// key generation can be either allowed for all websites or denied for all
// websites.
//
// If this policy is left not set, 'BlockKeygen' will be used and the user will
// be able to change it.
//
// Valid values:
//   1: Allow all sites to use key generation
//   2: Do not allow any site to use key generation
//
// Supported on:
message DefaultKeygenSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultKeygenSetting = 2;
}

// Default sensors setting
//
// Setting the policy to 1 lets websites access and use sensors such as motion
// and light. Setting the policy to 2 denies acess to sensors.
//
// Leaving it unset means AllowSensors applies, but users can change this
// setting.
//
// Valid values:
//   1: Allow sites to access sensors
//   2: Do not allow any site to access sensors
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultSensorsSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultSensorsSetting = 2;
}

// Control use of the WebUSB API
//
// Setting the policy to 3 lets websites ask for access to connected USB
// devices. Setting the policy to 2 denies access to connected USB devices.
//
// Leaving it unset lets websites ask for access, but users can change this
// setting.
//
// Valid values:
//   2: Do not allow any site to request access to USB devices via the WebUSB
// API
//   3: Allow sites to ask the user to grant access to a connected USB device
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultWebUsbGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultWebUsbGuardSetting = 2;
}

// Automatically grant permission to these sites to connect to USB devices with
// the given vendor and product IDs.
//
// Setting the policy lets you list the URL patterns that specify which sites
// are automatically granted permission to access a USB device with the given
// vendor and product IDs. Each item in the list requires both devices and urls
// fields for the policy to be valid. Each item in the devices field can have a
// vendor_id and product_id field. Omitting the vendor_id field will create a
// policy matching any device. Omitting the product_id field will create a
// policy matching any device with the given vendor ID. A policy which has a
// product_id field without a vendor_id field is invalid.
//
// The USB permission model will grant the specified URL permission to access
// the USB device as a top-level origin. If embedded frames need to access USB
// devices, the 'usb' feature-policy header should be used to grant access. The
// URL must be valid, otherwise the policy is ignored.
//
// Deprecated: The USB permission model used to support specifying both the
// requesting and embedding URLs. This is deprecated and only supported for
// backwards compatiblity in this manner: if both a requesting and embedding URL
// is specified, then the embedding URL will be granted the permission as top-
// level origin and the requsting URL will be ignored entirely.
//
// This policy overrides DefaultWebUsbGuardSetting, WebUsbAskForUrls,
// WebUsbBlockedForUrls and the user's preferences.
//
// This policy only affects access to USB devices through the WebUSB API. To
// grant access to USB devices through the Web Serial API see the
// SerialAllowUsbDevicesForUrls policy.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "devices": {
//                 "items": {
//                     "properties": {
//                         "product_id": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "vendor_id": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "urls": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             }
//         },
//         "required": [
//             "devices",
//             "urls"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message WebUsbAllowDevicesForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional string WebUsbAllowDevicesForUrls = 2;
}

// Allow WebUSB on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can ask users to grant them access to a USB device.
//
// Leaving the policy unset means DefaultWebUsbGuardSetting applies for all
// sites, if it's set. If not, users' personal settings apply.
//
// URL patterns must not conflict with WebUsbAskForUrls. Neither policy takes
// precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message WebUsbAskForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebUsbAskForUrls = 2;
}

// Block WebUSB on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can't ask users to grant them access to a USB device.
//
// Leaving the policy unset means DefaultWebUsbGuardSetting applies for all
// sites, if it's set. If not, the user's personal setting applies.
//
// URL patterns can't conflict with WebUsbAskForUrls. Neither policy takes
// precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message WebUsbBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebUsbBlockedForUrls = 2;
}

// Control use of the Serial API
//
// Setting the policy to 3 lets websites ask for access to serial ports. Setting
// the policy to 2 denies access to serial ports.
//
// Leaving it unset lets websites ask for access, but users can change this
// setting.
//
// Valid values:
//   2: Do not allow any site to request access to serial ports via the Serial
// API
//   3: Allow sites to ask the user to grant access to a serial port
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultSerialGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultSerialGuardSetting = 2;
}

// Allow the Serial API on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can ask users to grant them access to a serial port.
//
// Leaving the policy unset means DefaultSerialGuardSetting applies for all
// sites, if it's set. If not, users' personal settings apply.
//
// For URL patterns which do not match the policy SerialBlockedForUrls (if there
// is a match), DefaultSerialGuardSetting (if set), or the users' personal
// settings take precedence, in that order.
//
// URL patterns must not conflict with SerialBlockedForUrls. Neither policy
// takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SerialAskForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SerialAskForUrls = 2;
}

// Block the Serial API on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can't ask users to grant them access to a serial port.
//
// Leaving the policy unset means DefaultSerialGuardSetting applies for all
// sites, if it's set. If not, the user's personal setting applies.
//
// For URL patterns which do not match the policy SerialAskForUrls (if there is
// a match), DefaultSerialGuardSetting (if set), or the users' personal settings
// take precedence, in that order.
//
// URL patterns can't conflict with SerialAskForUrls. Neither policy takes
// precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SerialBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SerialBlockedForUrls = 2;
}

// Automatically grant permission to sites to connect all serial ports.
//
// Setting the policy allows you to list sites which are automatically granted
// permission to access all available serial ports.
//
// The URLs must be valid, otherwise the policy is ignored. Only the origin
// (scheme, host and port) of the URL is considered.
//
// On Google ChromeOS, this policy only applies to affiliated users.
//
// This policy overrides DefaultSerialGuardSetting, SerialAskForUrls,
// SerialBlockedForUrls and the user's preferences.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SerialAllowAllPortsForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SerialAllowAllPortsForUrls = 2;
}

// Automatically grant permission to sites to connect to USB serial devices.
//
// Setting the policy allows you to list sites which are automatically granted
// permission to access USB serial devices with vendor and product IDs matching
// the vendor_id and product_id fields. Omitting the product_id field allows the
// given sites permission to access devices with a vendor ID matching the
// vendor_id field and any product ID.
//
// The URLs must be valid, otherwise the policy is ignored. Only the origin
// (scheme, host and port) of the URL is considered.
//
// On ChromeOS, this policy only applies to affiliated users.
//
// This policy overrides DefaultSerialGuardSetting, SerialAskForUrls,
// SerialBlockedForUrls and the user's preferences.
//
// This policy only affects access to USB devices through the Web Serial API. To
// grant access to USB devices through the WebUSB API see the
// WebUsbAllowDevicesForUrls policy.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "devices": {
//                 "items": {
//                     "properties": {
//                         "product_id": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "vendor_id": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         }
//                     },
//                     "required": [
//                         "vendor_id"
//                     ],
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "urls": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             }
//         },
//         "required": [
//             "devices",
//             "urls"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SerialAllowUsbDevicesForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional string SerialAllowUsbDevicesForUrls = 2;
}

// Control use of the WebHID API
//
// Setting the policy to 3 lets websites ask for access to HID devices. Setting
// the policy to 2 denies access to HID devices.
//
// Leaving it unset lets websites ask for access, but users can change this
// setting.
//
// This policy can be overridden for specific url patterns using the
// WebHidAskForUrls and WebHidBlockedForUrls policies.
//
// Valid values:
//   2: Do not allow any site to request access to HID devices via the WebHID
// API
//   3: Allow sites to ask the user to grant access to a HID device
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultWebHidGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultWebHidGuardSetting = 2;
}

// Allow the WebHID API on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can ask users to grant them access to a HID device.
//
// Leaving the policy unset means DefaultWebHidGuardSetting applies for all
// sites, if it's set. If not, users' personal settings apply.
//
// For URL patterns which do not match the policy, the following take
// precedence, in this order:
//
// * WebHidBlockedForUrls (if there is a match),
//
// * DefaultWebHidGuardSetting (if set), or
//
// * Users' personal settings.
//
// URL patterns must not conflict with WebHidBlockedForUrls. Neither policy
// takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebHidAskForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebHidAskForUrls = 2;
}

// Block the WebHID API on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can't ask users to grant them access to a HID device.
//
// Leaving the policy unset means DefaultWebHidGuardSetting applies for all
// sites, if it's set. If not, users' personal settings apply.
//
// For URL patterns which do not match the policy, the following take
// precedence, in this order:
//
// * WebHidAskForUrls (if there is a match),
//
// * DefaultWebHidGuardSetting (if set), or
//
// * Users' personal settings.
//
// URL patterns can't conflict with WebHidAskForUrls. Neither policy takes
// precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebHidBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebHidBlockedForUrls = 2;
}

// Automatically grant permission to sites to connect to any HID device.
//
// Setting the policy allows you to list sites which are automatically granted
// permission to access all available devices.
//
// The URLs must be valid, otherwise the policy is ignored. Only the origin
// (scheme, host and port) of the URL is considered.
//
// On ChromeOS, this policy only applies to affiliated users.
//
// This policy overrides DefaultWebHidGuardSetting, WebHidAskForUrls,
// WebHidBlockedForUrls and the user's preferences.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebHidAllowAllDevicesForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebHidAllowAllDevicesForUrls = 2;
}

// Automatically grant permission to these sites to connect to HID devices with
// the given vendor and product IDs.
//
// Setting the policy lets you list the URLs that specify which sites are
// automatically granted permission to access a HID device with the given vendor
// and product IDs. Each item in the list requires both devices and urls fields
// for the item to be valid, otherwise the item is ignored. Each item in the
// devices field must have a vendor_id and may have a product_id field. Omitting
// the product_id field will create a policy matching any device with the
// specified vendor ID. An item which has a product_id field without a vendor_id
// field is invalid and is ignored.
//
// Leaving the policy unset means DefaultWebHidGuardSetting applies, if it's
// set. If not, the user's personal setting applies.
//
// URLs in this policy shouldn't conflict with those configured through
// WebHidBlockedForUrls. If they do, this policy takes precedence over
// WebHidBlockedForUrls.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "devices": {
//                 "items": {
//                     "properties": {
//                         "product_id": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "vendor_id": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         }
//                     },
//                     "required": [
//                         "vendor_id"
//                     ],
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "urls": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             }
//         },
//         "required": [
//             "devices",
//             "urls"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebHidAllowDevicesForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional string WebHidAllowDevicesForUrls = 2;
}

// Automatically grant permission to these sites to connect to HID devices
// containing top-level collections with the given HID usage.
//
// Setting the policy lets you list the URLs that specify which sites are
// automatically granted permission to access a HID device containing a top-
// level collection with the given HID usage. Each item in the list requires
// both usages and urls fields for the policy to be valid. Each item in the
// usages field must have a usage_page and may have a usage field. Omitting the
// usage field will create a policy matching any device containing a top-level
// collection with a usage from the specified usage page. An item which has a
// usage field without a usage_page field is invalid and is ignored.
//
// Leaving the policy unset means DefaultWebHidGuardSetting applies, if it's
// set. If not, the user's personal setting applies.
//
// URLs in this policy shouldn't conflict with those configured through
// WebHidBlockedForUrls. If they do, this policy takes precedence over
// WebHidBlockedForUrls.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "urls": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "usages": {
//                 "items": {
//                     "properties": {
//                         "usage": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "usage_page": {
//                             "maximum": 65535,
//                             "minimum": 0,
//                             "type": "integer"
//                         }
//                     },
//                     "required": [
//                         "usage_page"
//                     ],
//                     "type": "object"
//                 },
//                 "type": "array"
//             }
//         },
//         "required": [
//             "usages",
//             "urls"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebHidAllowDevicesWithHidUsagesForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional string WebHidAllowDevicesWithHidUsagesForUrls = 2;
}

// Control use of the File Handling API
//
// Setting the policy to AskFileHandling lets web apps ask for access to file
// types via the File Handling API. Setting the policy to BlockFileHandling
// denies access to file types.
//
// Leaving it unset lets web apps ask for access, but users can change this
// setting.
//
// Valid values:
//   2: Do not allow any web app to access file types via the File Handling API
//   3: Allow web apps to ask the user to grant access to file types via the
// File Handling API
//
// Supported on:
message DefaultFileHandlingGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultFileHandlingGuardSetting = 2;
}

// Allow the File Handling API on these web apps
//
// Setting the policy lets you list the URL patterns that specify which web apps
// are granted access to file types.
//
// Leaving the policy unset means DefaultFileHandlingGuardSetting applies for
// all web apps, if it's set. If not, users' personal settings apply.
//
// For URL patterns which match neither FileHandlingAllowedForUrls nor
// FileHandlingBlockedForUrls, DefaultFileHandlingGuardSetting, or the users'
// personal settings, will be used, in that order.
//
// URL patterns must not conflict with FileHandlingBlockedForUrls. Neither
// policy takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on:
message FileHandlingAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList FileHandlingAllowedForUrls = 2;
}

// Block the File Handling API on these web apps
//
// Setting the policy lets you list the URL patterns that specify which web apps
// can't ask users to grant them access to file types.
//
// Leaving the policy unset means DefaultFileHandlingGuardSetting applies for
// all web apps, if it's set. If not, the user's personal setting applies.
//
// For URL patterns which match neither FileHandlingAllowedForUrls nor
// FileHandlingBlockedForUrls, DefaultFileHandlingGuardSetting, or the users'
// personal settings, will be used, in that order.
//
// URL patterns must not conflict with FileHandlingAllowedForUrls. Neither
// policy takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on:
message FileHandlingBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList FileHandlingBlockedForUrls = 2;
}

// Control use of the File System API for reading
//
// Setting the policy to 3 lets websites ask for read access to files and
// directories in the host operating system's file system via the File System
// API. Setting the policy to 2 denies access.
//
// Leaving it unset lets websites ask for access, but users can change this
// setting.
//
// Valid values:
//   2: Do not allow any site to request read access to files and directories
// via the File System API
//   3: Allow sites to ask the user to grant read access to files and
// directories via the File System API
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultFileSystemReadGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultFileSystemReadGuardSetting = 2;
}

// Control use of the File System API for writing
//
// Setting the policy to 3 lets websites ask for write access to files and
// directories in the host operating system's file system. Setting the policy to
// 2 denies access.
//
// Leaving it unset lets websites ask for access, but users can change this
// setting.
//
// Valid values:
//   2: Do not allow any site to request write access to files and directories
//   3: Allow sites to ask the user to grant write access to files and
// directories
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultFileSystemWriteGuardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultFileSystemWriteGuardSetting = 2;
}

// Allow read access via the File System API on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can ask users to grant them read access to files or directories in the host
// operating system's file system via the File System API.
//
// Leaving the policy unset means DefaultFileSystemReadGuardSetting applies for
// all sites, if it's set. If not, users' personal settings apply.
//
// URL patterns must not conflict with FileSystemReadBlockedForUrls. Neither
// policy takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message FileSystemReadAskForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList FileSystemReadAskForUrls = 2;
}

// Block read access via the File System API on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can't ask users to grant them read access to files or directories in the host
// operating system's file system via the File System API.
//
// Leaving the policy unset means DefaultFileSystemReadGuardSetting applies for
// all sites, if it's set. If not, users' personal settings apply.
//
// URL patterns can't conflict with FileSystemReadAskForUrls. Neither policy
// takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message FileSystemReadBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList FileSystemReadBlockedForUrls = 2;
}

// Allow write access to files and directories on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can ask users to grant them write access to files or directories in the host
// operating system's file system.
//
// Leaving the policy unset means DefaultFileSystemWriteGuardSetting applies for
// all sites, if it's set. If not, users' personal settings apply.
//
// URL patterns must not conflict with FileSystemWriteBlockedForUrls. Neither
// policy takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message FileSystemWriteAskForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList FileSystemWriteAskForUrls = 2;
}

// Block write access to files and directories on these sites
//
// Setting the policy lets you list the URL patterns that specify which sites
// can't ask users to grant them write access to files or directories in the
// host operating system's file system.
//
// Leaving the policy unset means DefaultFileSystemWriteGuardSetting applies for
// all sites, if it's set. If not, users' personal settings apply.
//
// URL patterns can't conflict with FileSystemWriteAskForUrls. Neither policy
// takes precedence if a URL matches with both.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message FileSystemWriteBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList FileSystemWriteBlockedForUrls = 2;
}

// Automatically select client certificates for these sites
//
// Setting the policy lets you make a list of URL patterns that specify sites
// for which Chrome can automatically select a client certificate. The value is
// an array of stringified JSON dictionaries, each with the form { "pattern":
// "$URL_PATTERN", "filter" : $FILTER }, where $URL_PATTERN is a content setting
// pattern. $FILTER restricts the client certificates the browser automatically
// selects from. Independent of the filter, only certificates that match the
// server's certificate request are selected.
//
// Examples for the usage of the $FILTER section:
//
// * When $FILTER is set to { "ISSUER": { "CN": "$ISSUER_CN" } }, only client
// certificates issued by a certificate with the CommonName $ISSUER_CN are
// selected.
//
// * When $FILTER contains both the "ISSUER" and the "SUBJECT" sections, only
// client certificates that satisfy both conditions are selected.
//
// * When $FILTER contains a "SUBJECT" section with the "O" value, a certificate
// needs at least one organization matching the specified value to be selected.
//
// * When $FILTER contains a "SUBJECT" section with a "OU" value, a certificate
// needs at least one organizational unit matching the specified value to be
// selected.
//
// * When $FILTER is set to {}, the selection of client certificates is not
// additionally restricted. Note that filters provided by the web server still
// apply.
//
// Leaving the policy unset means there's no autoselection for any site.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AutoSelectCertificateForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AutoSelectCertificateForUrls = 2;
}

// Allow cookies on these sites
//
// Allows you to set a list of url patterns that specify sites which are allowed
// to set cookies.
//
// If this policy is left not set the global default value will be used for all
// sites either from the DefaultCookiesSetting policy if it is set, or the
// user's personal configuration otherwise.
//
// See also policies CookiesBlockedForUrls and CookiesSessionOnlyForUrls. Note
// that there must be no conflicting URL patterns between these three policies -
// it is unspecified which policy takes precedence.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CookiesAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CookiesAllowedForUrls = 2;
}

// Block cookies on these sites
//
// Setting the policy lets you make a list of URL patterns that specify sites
// that can't set cookies.
//
// Leaving the policy unset results in the use of DefaultCookiesSetting for all
// sites, if it's set. If not, the user's personal setting applies.
//
// While no specific policy takes precedence, see CookiesAllowedForUrls and
// CookiesSessionOnlyForUrls. URL patterns among these 3 policies must not
// conflict.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CookiesBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CookiesBlockedForUrls = 2;
}

// Limit cookies from matching URLs to the current session
//
// Unless the RestoreOnStartup policy is set to permanently restore URLs from
// previous sessions, then setting CookiesSessionOnlyForUrls lets you make a
// list of URL patterns that specify sites that can and can't set cookies for
// one session.
//
// Leaving the policy unset results in the use of DefaultCookiesSetting for all
// sites, if it's set. If not, the user's personal setting applies. URLs not
// covered by the patterns specified also result in the use of defaults.
//
// While no specific policy takes precedence, see CookiesBlockedForUrls and
// CookiesAllowedForUrls. URL patterns among these 3 policies must not conflict.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CookiesSessionOnlyForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CookiesSessionOnlyForUrls = 2;
}

// Allow images on these sites
//
// Setting the policy lets you set a list of URL patterns that specify sites
// that may display images.
//
// Leaving the policy unset means DefaultImagesSetting applies for all sites, if
// it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Note that previously this policy was erroneously enabled on Android, but this
// functionality has never been fully supported on Android.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ImagesAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ImagesAllowedForUrls = 2;
}

// Block images on these sites
//
// Setting the policy lets you set a list of URL patterns that specify sites
// that can't display images.
//
// Leaving the policy unset means DefaultImagesSetting applies for all sites, if
// it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Note that previously this policy was erroneously enabled on Android, but this
// functionality has never been fully supported on Android.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ImagesBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ImagesBlockedForUrls = 2;
}

// Allow JavaScript on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can run JavaScript.
//
// Leaving the policy unset means DefaultJavaScriptSetting applies for all
// sites, if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message JavaScriptAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList JavaScriptAllowedForUrls = 2;
}

// Block JavaScript on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can't run JavaScript.
//
// Leaving the policy unset means DefaultJavaScriptSetting applies for all
// sites, if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message JavaScriptBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList JavaScriptBlockedForUrls = 2;
}

// Default clipboard setting
//
// Setting the policy to 2 blocks sites from using the clipboard site
// permission. Setting the policy to 3 or leaving it unset lets the user change
// the setting and decide if the clipboard APIs are available when a site wants
// to use one.
//
// This policy can be overridden for specific URL patterns using the
// ClipboardAllowedForUrls and ClipboardBlockedForUrls policies.
//
// This policy only affects clipboard operations controlled by the clipboard
// site permission, and does not affect sanitized clipboard writes or trusted
// copy and paste operations.
//
// Valid values:
//   2: Do not allow any site to use the clipboard site permission
//   3: Allow sites to ask the user to grant the clipboard site permission
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultClipboardSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultClipboardSetting = 2;
}

// Allow clipboard on these sites
//
// Setting the policy lets you set a list of URL patterns that specify sites
// that can use the clipboard site permission. This does not include all
// clipboard operations on origins matching the patterns. For instance, users
// will still be able to paste using keyboard shortcuts as this isn't gated by
// the clipboard site permission.
//
//
// Leaving the policy unset means DefaultClipboardSetting applies for all sites,
// if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ClipboardAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ClipboardAllowedForUrls = 2;
}

// Block clipboard on these sites
//
// Setting the policy lets you set a list of URL patterns that specify sites
// that can't use the clipboard site permission. This does not include all
// clipboard operations on origins matching the patterns. For instance, users
// will still be able to paste using keyboard shortcuts as this isn't gated by
// the clipboard site permission.
//
// Leaving the policy unset means DefaultClipboardSetting applies for all sites,
// if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ClipboardBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ClipboardBlockedForUrls = 2;
}

// Allow key generation on these sites
//
// Allows you to set a list of url patterns that specify sites which are allowed
// to use key generation. If a url pattern is in 'KeygenBlockedForUrls', that
// overrides these exceptions.
//
// If this policy is left not set the global default value will be used for all
// sites either from the 'DefaultKeygenSetting' policy if it is set, or the
// user's personal configuration otherwise.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on:
message KeygenAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList KeygenAllowedForUrls = 2;
}

// Block key generation on these sites
//
// Allows you to set a list of url patterns that specify sites which are not
// allowed to use key generation. If a url pattern is in 'KeygenAllowedForUrls',
// this policy overrides these exceptions.
//
// If this policy is left not set the global default value will be used for all
// sites either from the 'DefaultKeygenSetting' policy if it is set, or the
// user's personal configuration otherwise.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on:
message KeygenBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList KeygenBlockedForUrls = 2;
}

// Default legacy SameSite cookie behavior setting
//
// This policy is deprecated, if you still require legacy cookie behavior please
// use LegacySameSiteCookieBehaviorEnabledForDomainList. Allows you to revert
// all cookies to legacy SameSite behavior. Reverting to legacy behavior causes
// cookies that don't specify a SameSite attribute to be treated as if they were
// "SameSite=None", removes the requirement for "SameSite=None" cookies to carry
// the "Secure" attribute, and skips the scheme comparison when evaluating if
// two sites are same-site. See https://www.chromium.org/administrators/policy-
// list-3/cookie-legacy-samesite-policies for full description.
//
// When this policy is not set, the default SameSite behavior for cookies will
// depend on the user's personal configuration for the SameSite-by-default
// feature, the Cookies-without-SameSite-must-be-secure feature, and the
// Schemeful Same-Site feature which may be set by a field trial or by enabling
// or disabling the same-site-by-default-cookies flag, the cookies-without-same-
// site-must-be-secure flag, or the schemeful-same-site flag, respectively.
//
// Valid values:
//   1: Revert to legacy SameSite behavior for cookies on all sites
//   2: Use SameSite-by-default behavior for cookies on all sites
//
// Supported on:
message LegacySameSiteCookieBehaviorEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional int64 LegacySameSiteCookieBehaviorEnabled = 2;
}

// Revert to legacy SameSite behavior for cookies on these sites
//
// Cookies set for domains matching these patterns will revert to legacy
// SameSite behavior. Reverting to legacy behavior causes cookies that don't
// specify a SameSite attribute to be treated as if they were "SameSite=None",
// removes the requirement for "SameSite=None" cookies to carry the "Secure"
// attribute, and skips the scheme comparison when evaluating if two sites are
// same-site. See https://www.chromium.org/administrators/policy-list-3/cookie-
// legacy-samesite-policies for full description.
//
// For cookies on domains not covered by the patterns specified here, or for all
// cookies if this policy is not set, the global default value will be the
// user's personal configuration.
//
// For detailed information on valid patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Note that patterns you list here are treated as domains, not URLs, so you
// should not specify a scheme or port.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message LegacySameSiteCookieBehaviorEnabledForDomainListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList LegacySameSiteCookieBehaviorEnabledForDomainList = 2;
}

// Allow Google Lens camera assisted search
//
// Leaving the policy unset or setting it to Enabled allows users to search with
// their cameras using Google Lens. Setting the policy to Disabled means users
// can't see the Google Lens button in the search box when Google Lens camera
// assisted search is supported.
//
// Valid values:
//   True: Enable Google Lens camera assisted search for Enterprise user
//   False: Disable Google Lens camera assisted search for Enterprise user
//
// Supported on: android
message LensCameraAssistedSearchEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LensCameraAssistedSearchEnabled = 2;
}

// Allow Google Lens region search menu item to be shown in context menu if
// supported.
//
// Leaving the policy unset or setting it to Enabled allows users to view and
// use the Google Lens region search menu item in the context menu. Setting the
// policy to Disabled means users will not see the Google Lens region search
// menu item in the context menu when Google Lens region search is supported.
//
// Valid values:
//   True: Enable Google Lens region search.
//   False: Disable Google Lens region search.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message LensRegionSearchEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LensRegionSearchEnabled = 2;
}

// Allow showing the most recent default search engine results page in a Browser
// side panel
//
// Setting the policy to Enabled or leaving the policy unset means that users
// can bring up their most recent default search engine results page in a side
// panel via toggling an icon in the toolbar.
//
// Setting the policy to Disabled removes the icon from the toolbar that opens
// the side panel with the default search engine results page.
//
// Valid values:
//   True: Enable showing default search engine results pages in a Browser side
// panel.
//   False: Disable showing default search engine results pages in a Browser
// side panel.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SideSearchEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SideSearchEnabled = 2;
}

// Specifies whether to allow websites to make requests to more-private network
// endpoints in an insecure manner
//
// Controls whether websites are allowed to make requests to more-private
// network endpoints in an insecure manner.
//
// When this policy is set to true, all Private Network Access checks are
// disabled for all origins. This may allow attackers to perform CSRF attacks on
// private network servers.
//
// When this policy is either not set or set to false, the default behavior for
// requests to more-private network endpoints will depend on the user's personal
// configuration for the BlockInsecurePrivateNetworkRequests,
// PrivateNetworkAccessSendPreflights, and
// PrivateNetworkAccessRespectPreflightResults feature flags, which may be set
// by field trials or on the command line.
//
// This policy relates to the Private Network Access specification. See
// https://wicg.github.io/private-network-access/ for more details.
//
// A network endpoint is more private than another if:
// 1) Its IP address is localhost and the other is not.
// 2) Its IP address is private and the other is public.
// In the future, depending on spec evolution, this policy might apply to all
// cross-origin requests directed at private IPs or localhost.
//
// When this policy is set to true, websites are allowed to make requests to any
// network endpoint, subject to other cross-origin checks.
//
// Valid values:
//   True: Allow insecure websites to make requests to any network endpoint
//   False: Use default behavior when determining if insecure websites can make
// requests to any network endpoint
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message InsecurePrivateNetworkRequestsAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool InsecurePrivateNetworkRequestsAllowed = 2;
}

// Allow the listed sites to make requests to more-private network endpoints in
// an insecure manner.
//
// List of URL patterns. Requests initiated from websites served by matching
// origins are not subject to Private Network Access checks.
//
// If unset, this policy behaves as if set to the empty list.
//
// For origins not covered by the patterns specified here, the global default
// value will be used either from the InsecurePrivateNetworkRequestsAllowed
// policy, if it is set, or the user's personal configuration otherwise.
//
// For detailed information on valid URL patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message InsecurePrivateNetworkRequestsAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList InsecurePrivateNetworkRequestsAllowedForUrls = 2;
}

// Allow the Flash plugin on these sites
//
// This policy is deprecated in M88, Flash is no longer supported by Chrome.
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can run the Flash plugin.
//
// Leaving the policy unset means DefaultPluginsSetting applies for all sites,
// if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// However, starting in M85, patterns with '*' and '[*.]' wildcards in the host
// are no longer supported for this policy.
//
// Supported on:
message PluginsAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PluginsAllowedForUrls = 2;
}

// Block the Flash plugin on these sites
//
// This policy is deprecated in M88, Flash is no longer supported by Chrome.
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can't run the Flash plugin.
//
// Leaving the policy unset means DefaultPluginsSetting applies for all sites,
// if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// However, starting in M85, patterns with '*' and '[*.]' wildcards in the host
// are no longer supported for this policy.
//
// Supported on:
message PluginsBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PluginsBlockedForUrls = 2;
}

// Allow pop-ups on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can open pop-ups.
//
// Leaving the policy unset means DefaultPopupsSetting applies for all sites, if
// it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.  * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PopupsAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PopupsAllowedForUrls = 2;
}

// Register protocol handlers
//
// Setting the policy (as recommended only) lets you register a list of protocol
// handlers, which merge with the ones that the user registers, putting both
// sets in use. Set the property "protocol" to the scheme, such as "mailto", and
// set the property "URL" to the URL pattern of the application that handles the
// scheme specified in the "protocol" field. The pattern can include a "%s"
// placeholder, which the handled URL replaces.
//
// Users can't remove a protocol handler registered by policy. However, by
// installing a new default handler, they can change the protocol handlers
// installed by policy.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "default": {
//                 "description": "A boolean flag indicating if the protocol
// handler should be set as the default.",
//                 "type": "boolean"
//             },
//             "protocol": {
//                 "description": "The protocol for the protocol handler.",
//                 "type": "string"
//             },
//             "url": {
//                 "description": "The URL of the protocol handler.",
//                 "type": "string"
//             }
//         },
//         "required": [
//             "protocol",
//             "url"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
//
// Note: this policy must have a RECOMMENDED PolicyMode set in PolicyOptions.
message RegisteredProtocolHandlersProto {
  optional PolicyOptions policy_options = 1;
  optional string RegisteredProtocolHandlers = 2;
}

// Block pop-ups on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can't open pop-ups.
//
// Leaving the policy unset means DefaultPopupsSetting applies for all sites, if
// it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PopupsBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PopupsBlockedForUrls = 2;
}

// Allow notifications on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can display notifications.
//
// Leaving the policy unset means DefaultNotificationsSetting applies for all
// sites, if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message NotificationsAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NotificationsAllowedForUrls = 2;
}

// Block notifications on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can't display notifications.
//
// Leaving the policy unset means DefaultNotificationsSetting applies for all
// sites, if it's set. If not, the user's personal setting applies.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.  * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message NotificationsBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NotificationsBlockedForUrls = 2;
}

// Allow access to sensors on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can access sensors like motion and light sensors.
//
// Leaving the policy unset means DefaultSensorsSetting applies for all sites,
// if it's set. If not, the user's personal setting applies.
//
// If the same URL pattern exists in both this policy and the
// SensorsBlockedForUrls policy, the latter is prioritized and access to motion
// or light sensors will be blocked.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SensorsAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SensorsAllowedForUrls = 2;
}

// Block access to sensors on these sites
//
// Setting the policy lets you set a list of URL patterns that specify the sites
// that can't access sensors like motion and light sensors.
//
// Leaving the policy unset means DefaultSensorsSetting applies for all sites,
// if it's set. If not, the user's personal setting applies.
//
// If the same URL pattern exists in both this policy and the
// SensorsAllowedForUrls policy, this policy is prioritized and access to motion
// or light sensors will be blocked.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SensorsBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SensorsBlockedForUrls = 2;
}

// Configure native messaging blocklist
//
// This policy is deprecated, please use the 'NativeMessagingBlocklist' policy
// instead.
//
// Setting the policy specifies which native messaging hosts shouldn't be
// loaded. A deny list value of * means all native messaging hosts are denied,
// unless they're explicitly allowed.
//
// Leaving the policy unset means Google Chrome loads all installed native
// messaging hosts.
//
// Supported on:
message NativeMessagingBlacklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativeMessagingBlacklist = 2;
}

// Configure native messaging blocklist
//
// Setting the policy specifies which native messaging hosts shouldn't be
// loaded. A deny list value of * means all native messaging hosts are denied,
// unless they're explicitly allowed.
//
// Leaving the policy unset means Google Chrome loads all installed native
// messaging hosts.
//
// Supported on: fuchsia, linux, mac, win
message NativeMessagingBlocklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativeMessagingBlocklist = 2;
}

// Configure native messaging whitelist
//
// This policy is deprecated, please use the 'NativeMessagingAllowlist' policy
// instead.
//
// Setting the policy specifies which native messaging hosts aren't subject to
// the deny list. A deny list value of * means all native messaging hosts are
// denied, unless they're explicitly allowed.
//
// All native messaging hosts are allowed by default. But, if all native
// messaging hosts are denied by policy, the admin can use the allow list to
// change that policy.
//
// Supported on:
message NativeMessagingWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativeMessagingWhitelist = 2;
}

// Configure native messaging allowlist
//
// Setting the policy specifies which native messaging hosts aren't subject to
// the deny list. A deny list value of * means all native messaging hosts are
// denied, unless they're explicitly allowed.
//
// All native messaging hosts are allowed by default. But, if all native
// messaging hosts are denied by policy, the admin can use the allow list to
// change that policy.
//
// Supported on: fuchsia, linux, mac, win
message NativeMessagingAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativeMessagingAllowlist = 2;
}

// Allow user-level Native Messaging hosts (installed without admin permissions)
//
// Setting the policy to Enabled or leaving it unset means Google Chrome can use
// native messaging hosts installed at the user level.
//
// Setting the policy to Disabled means Google Chrome can only use these hosts
// if installed at the system level.
//
// Valid values:
//   True: Allow both user-level and system-level native messaging hosts
//   False: Allow only system-level native messaging hosts
//
// Supported on: fuchsia, linux, mac, win
message NativeMessagingUserLevelHostsProto {
  optional PolicyOptions policy_options = 1;
  optional bool NativeMessagingUserLevelHosts = 2;
}

// Disable support for 3D graphics APIs
//
// Setting the policy to True (or setting HardwareAccelerationModeEnabled to
// False) prevents webpages from accessing the WebGL API, and plugins can't use
// the Pepper 3D API.
//
// Setting the policy to False or leaving it unset lets webpages use the WebGL
// API and plugins use the Pepper 3D API, but the browser's default settings
// might still require command line arguments to use these APIs.
//
// Valid values:
//   True: Disable support for 3D graphics APIs
//   False: Enable support for 3D graphics APIs
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message Disable3DAPIsProto {
  optional PolicyOptions policy_options = 1;
  optional bool Disable3DAPIs = 2;
}

// Refresh rate for user policy
//
// Setting the policy specifies the period in milliseconds at which the device
// management service is queried for user policy information. Valid values range
// from 1,800,000 (30 minutes) to 86,400,000 (1 day). Values outside this range
// will be clamped to the respective boundary.
//
// Leaving the policy unset uses the default value of 3 hours.
//
// Note: Policy notifications force a refresh when the policy changes, making
// frequent refreshes unnecessary. So, if the platform supports these
// notifications, the refresh delay is 24 hours (ignoring defaults and the value
// of this policy).
//
// Supported on: chrome_os, fuchsia, ios, linux, mac, win
message PolicyRefreshRateProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PolicyRefreshRate = 2;
}

// Maximum fetch delay after a policy invalidation
//
// Setting the policy specifies the maximum delay in milliseconds between
// receiving a policy invalidation and fetching the new policy from the device
// management service. Valid values range from 1,000 (1 second) to 300,000 (5
// minutes). Values outside this range will be clamped to the respective
// boundary.
//
// Leaving the policy unset means Google Chrome uses the default value of 10
// seconds.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message MaxInvalidationFetchDelayProto {
  optional PolicyOptions policy_options = 1;
  optional int64 MaxInvalidationFetchDelay = 2;
}

// Default HTML renderer for Google Chrome Frame
//
// Allows you to configure the default HTML renderer when Google Chrome Frame is
// installed.
// The default setting used when this policy is left not set is to allow the
// host browser do the rendering, but you can optionally override this and have
// Google Chrome Frame render HTML pages by default.
//
// Valid values:
//   0: Use the host browser by default
//   1: Use Google Chrome Frame by default
//
// Supported on:
message ChromeFrameRendererSettingsProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ChromeFrameRendererSettings = 2;
}

// Always render the following URL patterns in Google Chrome Frame
//
// Customize the list of URL patterns that should always be rendered by Google
// Chrome Frame.
//
// If this policy is not set the default renderer will be used for all sites as
// specified by the 'ChromeFrameRendererSettings' policy.
//
// For example patterns see https://www.chromium.org/developers/how-tos/chrome-
// frame-getting-started.
//
// Supported on:
message RenderInChromeFrameListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RenderInChromeFrameList = 2;
}

// Always render the following URL patterns in the host browser
//
// Customize the list of URL patterns that should always be rendered by the host
// browser.
//
// If this policy is not set the default renderer will be used for all sites as
// specified by the 'ChromeFrameRendererSettings' policy.
//
// For example patterns see https://www.chromium.org/developers/how-tos/chrome-
// frame-getting-started.
//
// Supported on:
message RenderInHostListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RenderInHostList = 2;
}

// Additional command line parameters for Google Chrome
//
// Allows you to specify additional parameters that are used when Google Chrome
// Frame launches Google Chrome.
//
// If this policy is not set the default command line will be used.
//
// Supported on:
message AdditionalLaunchParametersProto {
  optional PolicyOptions policy_options = 1;
  optional string AdditionalLaunchParameters = 2;
}

// Skip the meta tag check in Google Chrome Frame
//
// Normally pages with X-UA-Compatible set to chrome=1 will be rendered in
// Google Chrome Frame regardless of the 'ChromeFrameRendererSettings' policy.
//
// If you enable this setting, pages will not be scanned for meta tags.
//
// If you disable this setting, pages will be scanned for meta tags.
//
// If this policy is not set, pages will be scanned for meta tags.
//
// Supported on:
message SkipMetadataCheckProto {
  optional PolicyOptions policy_options = 1;
  optional bool SkipMetadataCheck = 2;
}

// Allow Google Chrome Frame to handle the listed content types
//
// If this policy is set, the specified content types are handled by Google
// Chrome Frame.
//
// If this policy is not set, the default renderer is used for all sites. (The
// ChromeFrameRendererSettings policy may be used to configure the default
// renderer.)
//
// Supported on:
message ChromeFrameContentTypesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ChromeFrameContentTypes = 2;
}

// Enable lock when the device become idle or suspended
//
// Setting the policy to Enabled means Google ChromeOS asks users for a password
// to unlock the device when it becomes idle.
//
// Setting the policy to Disabled means users are not asked for a password to
// unlock the device from sleep.
//
// Leaving the policy unset lets the user choose whether to be prompted for a
// password to unlock the device from sleep.
//
// Valid values:
//   True: Lock the device when it becomes idle or suspended
//   False: Prevent the device from locking when it becomes idle or suspended
//   None: Allow users to decide whether the device should lock when it becomes
// idle or suspended
//
// Supported on: chrome_os
message ChromeOsLockOnIdleSuspendProto {
  optional PolicyOptions policy_options = 1;
  optional bool ChromeOsLockOnIdleSuspend = 2;
}

// Control the user behavior in a multiprofile session
//
// Control the user behavior in a multiprofile session on Google ChromeOS
// devices.
//
// If this policy is set to 'MultiProfileUserBehaviorUnrestricted', the user can
// be either primary or secondary user in a multiprofile session.
//
// If this policy is set to 'MultiProfileUserBehaviorMustBePrimary', the user
// can only be the primary user in a multiprofile session.
//
// If this policy is set to 'MultiProfileUserBehaviorNotAllowed', the user
// cannot be part of a multiprofile session.
//
// If you set this setting, users cannot change or override it.
//
// If the setting is changed while the user is signed into a multiprofile
// session, all users in the session will be checked against their corresponding
// settings. The session will be closed if any one of the users is no longer
// allowed to be in the session.
//
// If the policy is left not set, the default value
// 'MultiProfileUserBehaviorMustBePrimary' applies for enterprise-managed users
// and 'MultiProfileUserBehaviorUnrestricted' will be used for non-managed
// users.
//
// Valid values:
//   unrestricted: Allow enterprise user to be both primary and secondary
// (Default behavior for non-managed users)
//   primary-only: Allow enterprise user to be primary multiprofile user only
// (Default behavior for enterprise-managed users)
//   not-allowed: Do not allow enterprise user to be part of multiprofile
// (primary or secondary)
//
// Supported on: chrome_os
message ChromeOsMultiProfileUserBehaviorProto {
  optional PolicyOptions policy_options = 1;
  optional string ChromeOsMultiProfileUserBehavior = 2;
}

// Allow Sign-in To Additional Google Accounts
//
// This setting allows users to switch between Google Accounts within the
// content area of their browser window and in Android applications, after they
// sign into their Google ChromeOS device.
//
// If this policy is set to false, signing in to a different Google Account from
// a non-Incognito browser content area and Android applications will not be
// allowed.
//
// If this policy is unset or set to true, the default behavior will be used:
// signing in to a different Google Account from the browser content area and
// Android applications will be allowed, except for child accounts where it will
// be blocked for non-Incognito content area.
//
// In case signing in to a different account shouldn't be allowed via the
// Incognito mode, consider blocking that mode using the
// IncognitoModeAvailability policy.
//
// Note that users will be able to access Google services in an unauthenticated
// state by blocking their cookies.
//
// Valid values:
//   True: Enable signing in with additional Google accounts
//   False: Disable signing in with additional Google accounts
//
// Supported on: chrome_os
message SecondaryGoogleAccountSigninAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SecondaryGoogleAccountSigninAllowed = 2;
}

// Add restrictions on a managed account's usage as a secondary account on
// ChromeOS
//
// If this policy is set to 'all' or not set, all usages of managed accounts are
// allowed. This may result in a managed account being a secondary account,
// which would only receive policies when the account is signed-in as a primary
// account in a browser Profile.
// Policies set to the account won't be enforced in the following scenarios:
// -  Being a secondary account at the OS level (Account Settings)
// -  Being a secondary account in a browser Profile
//
// If this policy is set to 'primary_account_signin' on an account, this account
// will be allowed to sign in as a primary account only. It won't be allowed to
// sign in as a secondary account.
//
// Valid values:
//   all: All usages of managed accounts are allowed
//   primary_account_signin: Block addition of a managed account as Secondary
// Account on ChromeOS (in-session)
//
// Supported on: chrome_os
message SecondaryGoogleAccountUsageProto {
  optional PolicyOptions policy_options = 1;
  optional string SecondaryGoogleAccountUsage = 2;
}

// Force logout the user when their account becomes unauthenticated
//
// Force logout the user when their primary account's authentication token
// becomes invalid.
// This policy can protect the user from access to restricted content on Google
// web properties.
// If this policy is set to True, the user will be logged out as soon as their
// authentication token becomes invalid and attempts to restore this token fail.
// If this policy is set to False or unset, the user can continue working in an
// unauthenticated state.
//
// Valid values:
//   True: Log the user out as soon as their account becomes unauthenticated
//   False: Allow the user to remain logged in after their account becomes
// unauthenticated
//
// Supported on: chrome_os
message ForceLogoutUnauthenticatedUserEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceLogoutUnauthenticatedUserEnabled = 2;
}

// Action on security token removal (e.g., smart card) for Google ChromeOS.
//
// Specifies what happens when a user who is authenticating via a security token
// (e.g., with a smart card) removes that token while in a session. IGNORE:
// Nothing happens. LOCK: The screen is locked until the user authenticates
// again. LOGOUT: The session is ended and the user is logged out. If this
// policy is not set, it defaults to IGNORE.
//
// Valid values:
//   IGNORE: No action happens.
//   LOGOUT: Log the user out.
//   LOCK: Lock the current session.
//
// Supported on: chrome_os
message SecurityTokenSessionBehaviorProto {
  optional PolicyOptions policy_options = 1;
  optional string SecurityTokenSessionBehavior = 2;
}

// Duration of the notification on smart card removal for Google ChromeOS.
//
// This policy only takes effect when the policy SecurityTokenSessionBehavior is
// set to LOCK or LOGOUT, and a user who authenticates via a smart card removes
// that smart card. Then, this policy specifies for how many seconds a
// notification which informs the user of the impending action is displayed.
// This notification is blocking the screen. The action will only happen after
// this notification expires. The user can prevent the action from happening by
// re-inserting the smart card before the notification expires. If this policy
// is set to zero, no notification will be displayed and the action happens
// immediately.
//
// Supported on: chrome_os
message SecurityTokenSessionNotificationSecondsProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SecurityTokenSessionNotificationSeconds = 2;
}

// Do not set window.opener for links targeting _blank
//
// Setting the policy to Disabled allows pop-ups targeting _blank to access (via
// JavaScript) the page that requested to open the pop-up.
//
// Setting the policy to Enabled or leaving it unset causes the window.opener
// property to be set to null unless the anchor specifies rel="opener".
//
// This policy was removed in Google Chrome version 102.
//
// See https://chromestatus.com/feature/6140064063029248.
//
// Valid values:
//   True: Only allow pop-ups opened with a target of _blank to interact with
// the page that opened the pop-up if the opener page explicitly opts-in to such
// interaction
//   False: Allow all pop-ups opened with a target of _blank to interact the
// page that requested to open the pop-up unless the opener page explicitly
// opts-out of such interaction
//
// Supported on:
message TargetBlankImpliesNoOpenerProto {
  optional PolicyOptions policy_options = 1;
  optional bool TargetBlankImpliesNoOpener = 2;
}

// Enable Instant
//
// Enables Google Chrome's Instant feature and prevents users from changing this
// setting.
//
// If you enable this setting, Google Chrome Instant is enabled.
//
// If you disable this setting, Google Chrome Instant is disabled.
//
// If you enable or disable this setting, users cannot change or override this
// setting.
//
// If this setting is left not set the user can decide to use this function or
// not.
//
// This setting has been removed from Google Chrome 29 and higher versions.
//
// Supported on:
message InstantEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool InstantEnabled = 2;
}

// Enable App Recommendations in Zero State of Search Box
//
// Setting this policy to Enabled will cause recommendations for apps previously
// installed by the user on other devices. These recommendations will appear in
// the launcher after the local app recomendations, if no search text has been
// entered.
//
// Setting this policy as Disabled or leaving it unset means these
// recommendations do not appear.
//
// If this policy is set, users cannot change it.
//
// Valid values:
//   True: Show app recommendations in the Google ChromeOS launcher
//   False: Do not show app recommendations in the Google ChromeOS launcher
//
// Supported on: chrome_os
message AppRecommendationZeroStateEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AppRecommendationZeroStateEnabled = 2;
}

// Enable Translate
//
// Setting the policy to True provides translation functionality when it's
// appropriate for users by showing an integrated translate toolbar in Google
// Chrome and a translate option on the right-click context menu. Setting the
// policy to False shuts off all built-in translate features.
//
// If you set the policy, users can't change this function. Leaving it unset
// lets them change the setting.
//
// Valid values:
//   True: Always offer translation
//   False: Never offer translation
//   None: Allow the user to decide
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message TranslateEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool TranslateEnabled = 2;
}

// Allow running plugins that are outdated
//
// This policy is deprecated in M88, Flash is no longer supported by Chrome.
// Setting the policy to Enabled means outdated plugins are used as normal
// plugins. Setting the policy to Disabled means outdated plugins aren't used.
//
// Leaving the policy unset means users will be asked for permission to run
// outdated plugins.
//
// Valid values:
//   True: Allow outdated Flash to be used as normal Flash
//   False: Disallow outdated Flash
//   None: Ask user for permission to run outdated Flash
//
// Supported on:
message AllowOutdatedPluginsProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowOutdatedPlugins = 2;
}

// Always runs plugins that require authorization (deprecated)
//
// If you enable this setting, plugins that are not outdated always run.
//
// If this setting is disabled or not set, users will be asked for permission to
// run plugins that require authorization. These are plugins that can compromise
// security.
//
// Valid values:
//   True: Always run plugins that are not outdated
//   False: Ask user for permission to run plugins that require authorization
//
// Supported on:
message AlwaysAuthorizePluginsProto {
  optional PolicyOptions policy_options = 1;
  optional bool AlwaysAuthorizePlugins = 2;
}

// Extend Flash content setting to all content (deprecated)
//
// This policy has been removed since Google Chrome version 89 because Flash has
// been deprecated.
//
// Setting the policy to True runs all Flash content embedded on websites that
// allow Flash, including content from other origins or small content.
//
// Setting the policy to False or leaving it unset might block Flash content
// from other origins or small content.
//
// Note: To control which websites can run Flash, see these policies:
// DefaultPluginsSetting, PluginsAllowedForUrls, and PluginsBlockedForUrls.
//
// Valid values:
//   True: Run all Flash content
//   False: Allow certain Flash content to be blocked
//
// Supported on:
message RunAllFlashInAllowModeProto {
  optional PolicyOptions policy_options = 1;
  optional bool RunAllFlashInAllowMode = 2;
}

// Enable Bookmark Bar
//
// Setting the policy to True displays a bookmark bar in Google Chrome. Setting
// the policy to False means users never see the bookmark bar.
//
// If you set the policy, users can't change it. If not set, users decide
// whether to use this function.
//
// Valid values:
//   True: Enable bookmark bar
//   False: Disable bookmark bar
//   None: Allow the user to decide
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message BookmarkBarEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BookmarkBarEnabled = 2;
}

// Enable or disable bookmark editing
//
// Setting the policy to True or leaving it unset lets users add, remove, or
// modify bookmarks.
//
// Setting the policy to False means users can't add, remove, or modify
// bookmarks. They can still use existing bookmarks.
//
// Valid values:
//   True: Enable bookmark editing
//   False: Disable bookmark editing
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message EditBookmarksEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool EditBookmarksEnabled = 2;
}

// Show the apps shortcut in the bookmark bar
//
// Setting the policy to True displays the apps shortcut. Setting the policy to
// False means this shortcut never appears.
//
// If you set the policy, users can't change it. If not set, users decide to
// show or hide the apps shortcut from the bookmark bar context menu.
//
// Valid values:
//   True: Show the apps shortcut in the bookmark bar
//   False: Do not show the apps shortcut in the bookmark bar
//   None: Allow the user to decide
//
// Supported on: fuchsia, linux, mac, win
message ShowAppsShortcutInBookmarkBarProto {
  optional PolicyOptions policy_options = 1;
  optional bool ShowAppsShortcutInBookmarkBar = 2;
}

// Allow invocation of file selection dialogs
//
// Setting the policy to Enabled or leaving it unset means Chrome can display,
// and users can open, file selection dialogs.
//
// Setting the policy to Disabled means that whenever users perform actions
// provoking a file selection dialog, such as importing bookmarks, uploading
// files, and saving links, a message appears instead. The user is assumed to
// have clicked Cancel on the file selection dialog.
//
// Valid values:
//   True: Allow file selection dialogs
//   False: Prevent file selection dialogs
//
// Supported on: fuchsia, linux, mac, win
message AllowFileSelectionDialogsProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowFileSelectionDialogs = 2;
}

// URLs/domains automatically permitted direct Security Key attestation
//
// Setting the policy specifies URLs and domains for which no prompt appears
// when attestation certificates from Security Keys are requested. A signal is
// also sent to the Security Key indicating that individual attestation may be
// used. Without this, when sites request attestation of Security Keys, users
// are prompted in Google Chrome version 65 and later.
//
// URLs will only match as U2F appIDs. Domains only match as webauthn RP IDs. So
// to cover both U2F and webauthn APIs, list the appID URL and domain for a
// given site.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SecurityKeyPermitAttestationProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SecurityKeyPermitAttestation = 2;
}

// Allow using the deprecated U2F Security Key API
//
// If set to Enabled, the deprecated U2F Security Key API can be used and the
// deprecation reminder prompt shown for U2F API requests is suppressed.
//
// If the policy is set to Disabled or left unset, the default behavior will
// apply.
//
// The U2F Security Key API is deprecated and it will be disabled by default in
// Chrome 98.
//
// This is a temporary opt-out mechanism. The U2F API will be removed from
// Chrome in Chrome 104, at which point this policy will cease to be supported.
//
// For more information about the deprecation of the U2F Security Key API,
// please refer to https://groups.google.com/a/chromium.org/g/blink-
// dev/c/xHC3AtU_65A.
//
// Valid values:
//   True: Allow using the U2F Security Key API.
//   False: Apply default settings for U2F API deprecation.
//
// Supported on:
message U2fSecurityKeyApiEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool U2fSecurityKeyApiEnabled = 2;
}

// Allow Chrome Remote Desktop to execute WebAuthn API requests proxied from a
// remote host.
//
// If set to Enabled, Chrome Remote Desktop may execute WebAuthn API requests
// that originate from a browsing session on a remote host.
//
// If the policy is set to Disabled or left unset, the default behavior will
// apply.
//
// Note that this feature is only supported inside Google's internal network
// environment.
//
// Valid values:
//   True: Allow CRD to execute WebAuthn API requests proxied from a remote
// host.
//   False: Do not allow CRD to execute WebAuthn API requests proxied from a
// remote host.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebAuthenticationRemoteProxiedRequestsAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebAuthenticationRemoteProxiedRequestsAllowed = 2;
}

// Set Google Chrome Frame user data directory
//
// Configures the directory that Google Chrome Frame will use for storing user
// data.
//
// If you set this policy, Google Chrome Frame will use the provided directory.
//
// See https://support.google.com/chrome/a?p=Supported_directory_variables for a
// list of variables that can be used.
//
// If this setting is left not set the default profile directory will be used.
//
// Supported on:
message GCFUserDataDirProto {
  optional PolicyOptions policy_options = 1;
  optional string GCFUserDataDir = 2;
}

// Import bookmarks from default browser on first run
//
// Setting the policy to Enabled imports bookmarks from the previous default
// browser on first run. Setting the policy to Disabled or leaving it unset
// means no bookmarks are imported on first run.
//
// Users can trigger an import dialog and the bookmarks checkbox will be checked
// or unchecked to match this policy's value.
//
// Valid values:
//   True: Enable import of bookmarks on first run
//   False: Disable import of bookmarks on first run
//
// Supported on: fuchsia, linux, mac, win
message ImportBookmarksProto {
  optional PolicyOptions policy_options = 1;
  optional bool ImportBookmarks = 2;
}

// Import browsing history from default browser on first run
//
// Setting the policy to Enabled imports browsing history from the previous
// default browser on first run. Setting the policy to Disabled or leaving it
// unset means no browsing history is imported on first run.
//
// Users can trigger an import dialog and the browsing history checkbox will be
// checked or unchecked to match this policy's value.
//
// Valid values:
//   True: Enable import of browsing history on first run
//   False: Disable import of browsing history on first run
//
// Supported on: fuchsia, linux, mac, win
message ImportHistoryProto {
  optional PolicyOptions policy_options = 1;
  optional bool ImportHistory = 2;
}

// Import of homepage from default browser on first run
//
// Setting the policy to Enabled imports the homepage from the previous default
// browser on first run. Setting the policy to Disabled or leaving it unset
// means the homepage isn't imported on first run.
//
// Users can trigger an import dialog and the homepage checkbox will be checked
// or unchecked to match this policy's value.
//
// Valid values:
//   True: Enable import of homepage on first run
//   False: Disable import of homepage on first run
//
// Supported on: fuchsia, linux, mac, win
message ImportHomepageProto {
  optional PolicyOptions policy_options = 1;
  optional bool ImportHomepage = 2;
}

// Import search engines from default browser on first run
//
// Setting the policy to Enabled imports the default search engine from the
// previous default browser on first run. Setting the policy to Disabled or
// leaving it unset means the default search engine isn't imported on first run.
//
// Users can trigger an import dialog and the default search engine checkbox
// will be checked or unchecked to match this policy's value.
//
// Valid values:
//   True: Enable import of default search engine on first run
//   False: Disable import of default search engine on first run
//
// Supported on: fuchsia, linux, mac, win
message ImportSearchEngineProto {
  optional PolicyOptions policy_options = 1;
  optional bool ImportSearchEngine = 2;
}

// Import saved passwords from default browser on first run
//
// Setting the policy to Enabled imports saved passwords from the previous
// default browser on first run. Setting the policy to Disabled or leaving it
// unset means no saved passwords are imported on first run.
//
// Users can trigger an import dialog and the saved passwords checkbox will be
// checked or unchecked to match this policy's value.
//
// Valid values:
//   True: Enable import of saved passwords on first run
//   False: Disable import of saved passwords on first run
//
// Supported on: fuchsia, linux, mac, win
message ImportSavedPasswordsProto {
  optional PolicyOptions policy_options = 1;
  optional bool ImportSavedPasswords = 2;
}

// Import autofill form data from default browser on first run
//
// Setting the policy to Enabled imports autofill form data from the previous
// default browser on first run. Setting the policy to Disabled or leaving it
// unset means no autofill form data is imported on first run.
//
// Users can trigger an import dialog and the autofill form data checkbox will
// be checked or unchecked to match this policy's value.
//
// Valid values:
//   True: Enable import of autofill form data on first run
//   False: Disable import of autofill form data on first run
//
// Supported on: fuchsia, linux, mac, win
message ImportAutofillFormDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ImportAutofillFormData = 2;
}

// Maximal number of concurrent connections to the proxy server
//
// Setting the policy specifies the maximal number of simultaneous connections
// to the proxy server. Some proxy servers can't handle a high number of
// concurrent connections per client, which is solved by setting this policy to
// a lower value. The value should be lower than 100 and higher than 6. Some web
// apps are known to consume many connections with hanging GETs, so setting a
// value below 32 may lead to browser networking hangs if there are too many web
// apps with hanging connections open. Lower below the default at your own risk.
//
// Leaving the policy unset means a default of 32 is used.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message MaxConnectionsPerProxyProto {
  optional PolicyOptions policy_options = 1;
  optional int64 MaxConnectionsPerProxy = 2;
}

// Prevent app promotions from appearing on the new tab page
//
// When set to True, promotions for Chrome Web Store apps will not appear on the
// new tab page.
//
// Setting this option to False or leaving it not set will make the promotions
// for Chrome Web Store apps appear on the new tab page
//
// Supported on:
message HideWebStorePromoProto {
  optional PolicyOptions policy_options = 1;
  optional bool HideWebStorePromo = 2;
}

// Block access to a list of URLs
//
// This policy is deprecated, please use the 'URLBlocklist' policy instead.
//
// Setting the policy prevents webpages with prohibited URLs from loading. It
// provides a list of URL patterns that specify forbidden URLs. Leaving the
// policy unset means no URLs are prohibited in the browser. Format the URL
// pattern according to this format (
// https://www.chromium.org/administrators/url-blocklist-filter-format ). Up to
// 1,000 exceptions can be defined in URLAllowlist.
//
// From Google Chrome version 73, you can block javascript://* URLs. However, it
// affects only JavaScript entered in the address bar (or, for example,
// bookmarklets). In-page JavaScript URLs with dynamically loaded data aren't
// subject to this policy. For example, if you block example.com/abc, then
// example.com can still load example.com/abc using XMLHTTPRequest.
//
// Note: Blocking internal chrome://* URLs can lead to unexpected errors.
//
// Supported on:
message URLBlacklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList URLBlacklist = 2;
}

// Allow access to a list of URLs
//
// This policy is deprecated, please use the 'URLAllowlist' policy instead.
//
// Setting the policy provides access to the listed URLs, as exceptions to the
// URL blocklist. See that policy's description for the format of entries of
// this list. For example, setting URLBlocklist to * will block all requests,
// and you can use this policy to allow access to a limited list of URLs. Use it
// to open exceptions to certain schemes, subdomains of other domains, ports, or
// specific paths, using the format specified at (
// https://www.chromium.org/administrators/url-blocklist-filter-format ). The
// most specific filter determines if a URL is blocked or allowed. The allowlist
// takes precedence over blocklist. This policy is limited to 1,000 entries.
//
// This policy also allows enabling the automatic invocation by the browser of
// external application registered as protocol handlers for the listed protocols
// like "tel:" or "ssh:".
//
// Leaving the policy unset allows no exceptions.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on:
message URLWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList URLWhitelist = 2;
}

// Block access to a list of URLs
//
// Setting the policy prevents webpages with prohibited URLs from loading. It
// provides a list of URL patterns that specify forbidden URLs. Leaving the
// policy unset means no URLs are prohibited in the browser. Format the URL
// pattern according to this format (
// https://www.chromium.org/administrators/url-blocklist-filter-format ). Up to
// 1,000 exceptions can be defined in URLAllowlist.
//
// From Google Chrome version 73, you can block javascript://* URLs. However, it
// affects only JavaScript entered in the address bar (or, for example,
// bookmarklets). In-page JavaScript URLs with dynamically loaded data aren't
// subject to this policy. For example, if you block example.com/abc, then
// example.com can still load example.com/abc using XMLHTTPRequest.
//
// From Google Chrome version 92, this policy is also supported in the headless
// mode.
//
// Note: Blocking internal chrome://* and chrome-untrusted://* URLs can lead to
// unexpected errors or may be circumvented in special cases. Instead of
// blocking certain internal URLs, see if there are more specific policies
// available. Common cases: Instead of blocking chrome://settings/certificates,
// use CACertificateManagementAllowed. Instead of blocking chrome-
// untrusted://crosh, use SystemFeaturesDisableList.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message URLBlocklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList URLBlocklist = 2;
}

// Allow access to a list of URLs
//
// Setting the policy provides access to the listed URLs, as exceptions to
// URLBlocklist. See that policy's description for the format of entries of this
// list. For example, setting URLBlocklist to * will block all requests, and you
// can use this policy to allow access to a limited list of URLs. Use it to open
// exceptions to certain schemes, subdomains of other domains, ports, or
// specific paths, using the format specified at (
// https://www.chromium.org/administrators/url-blocklist-filter-format ). The
// most specific filter determines if a URL is blocked or allowed. The
// URLAllowlist policy takes precedence over URLBlocklist. This policy is
// limited to 1,000 entries.
//
// This policy also allows enabling the automatic invocation by the browser of
// external application registered as protocol handlers for the listed protocols
// like "tel:" or "ssh:".
//
// Leaving the policy unset allows no exceptions to URLBlocklist.
//
// From Google Chrome version 92, this policy is also supported in the headless
// mode.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message URLAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList URLAllowlist = 2;
}

// Enables the concept of policy atomic groups
//
// Setting the policy to Enabled means policies coming from an atomic group that
// don't share the source with the highest priority from that group get ignored.
//
// Setting the policy to Disabled means no policy is ignored because of its
// source. Policies are ignored only if there's a conflict, and the policy
// doesn't have the highest priority.
//
// If this policy is set from a cloud source, it can't target a specific user.
//
// Valid values:
//   True: Enable policy atomic groups
//   False: Disable policy atomic groups
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PolicyAtomicGroupsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PolicyAtomicGroupsEnabled = 2;
}

// Allow merging list policies from different sources
//
// Setting the policy allows merging of selected policies when they come from
// different sources, with the same scopes and level.
//
// Use the wildcard character '*' to allow merging of all list policies.
//
// If a policy is in the list and there's conflict between sources with:
//
// * The same scopes and level: The values merge into a new policy list.
//
// * Different scopes or level: The policy with the highest priority applies.
//
// If a policy isn't in the list and there's conflict between sources, scopes,
// or level, the policy with the highest priority applies.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PolicyListMultipleSourceMergeListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PolicyListMultipleSourceMergeList = 2;
}

// Allow merging dictionary policies from different sources
//
// Setting the policy allows merging of selected policies when they come from
// different sources, with the same scopes and level. This merging is in the
// first level keys of the dictionary from each source. The key coming from the
// highest priority source takes precedence.
//
// Use the wildcard character '*' to allow merging of all supported dictionary
// policies.
//
// If a policy is in the list and there's conflict between sources with:
//
// * The same scopes and level: The values merge into a new policy dictionary.
//
// * Different scopes or level: The policy with the highest priority applies.
//
// If a policy isn't in the list and there's conflict between sources, scopes,
// or level, the policy with the highest priority applies.
//
// Valid values:
//   ContentPackManualBehaviorURLs: Managed user manual exception URLs
//   DeviceLoginScreenPowerManagement: Power management on the login screen
//   ExtensionSettings: Extension management settings
//   KeyPermissions: Key Permissions
//   PowerManagementIdleSettings: Power management settings when the user
// becomes idle
//   ScreenBrightnessPercent: Screen brightness percent
//   ScreenLockDelays: Screen lock delays
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message PolicyDictionaryMultipleSourceMergeListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PolicyDictionaryMultipleSourceMergeList = 2;
}

// Enables merging of user cloud policies into machine-level policies
//
// Setting the policy to Enabled allows policies associated with a Google
// Workspace account to be merged into machine-level policies.
//
// Only policies originating from secure users can be merged. A secure user is
// affiliated with the organization that manages their browser using Chrome
// Browser Cloud Management. All other user-level policies will always be
// ignored.
//
// Policies that need to be merged also need to be set in either
// PolicyListMultipleSourceMergeList or PolicyDictionaryMultipleSourceMergeList.
// This policy will be ignored if neither of the two aforementioned policies is
// configured.
//
// Leaving the policy unset or setting it to Disabled prevents user-level cloud
// policies from being merged with policies from any other sources.
//
// Valid values:
//   True: Enable merging of user-level cloud policies.
//   False: Disable merging of user-level cloud policies.
//
// Supported on: android, fuchsia, ios, linux, mac, win
message CloudUserPolicyMergeProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudUserPolicyMerge = 2;
}

// Enables experimental policies
//
// Allows Google Chrome to load experimental policies.
//
// WARNING: Experimental policies are unsupported and subject to change or be
// removed without notice in future version of the browser!
//
// An experimental policy may not be finished or still have known or unknown
// defects. It may be changed or even removed without any notification. By
// enabling experimental policies, you could lose browser data or compromise
// your security or privacy.
//
// If a policy is not in the list and it's not officially released, its value
// will be ignored on Beta and Stable channel.
//
// If a policy is in the list and it's not officially released, its value will
// be applied.
//
// This policy has no effect on already released policies.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message EnableExperimentalPoliciesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList EnableExperimentalPolicies = 2;
}

// Allow policy scope detection on macOS
//
// Controls whether browser can detect mandatory policy scope on macOS or not.
//
// If the policy is set to Enabled or not set, each policy's scope will be
// determined by the scope of macOS managed profile.
// If the policy is set to Disabled, all policies will be reconized as machine
// scope policy.
//
// This policy is temporary in order to facilitate smooth transition to properly
// scoped policies on macOS and will be removed in Google Chrome 107.
//
//
// Valid values:
//   True: Allow Policy scope detection.
//   False: Block Policy scope detection.
//
// Supported on: mac
message PolicyScopeDetectionProto {
  optional PolicyOptions policy_options = 1;
  optional bool PolicyScopeDetection = 2;
}

// User-level network configuration
//
// Setting the policy allows pushing network configuration per-user for each
// Google Chrome device. The network configuration is a JSON-formatted string,
// as defined by the Open Network Configuration format.
//
// Supported on: chrome_os
message OpenNetworkConfigurationProto {
  optional PolicyOptions policy_options = 1;
  optional string OpenNetworkConfiguration = 2;
}

// Enable submission of documents to Google Cloud Print
//
// Setting the policy to Enabled or leaving it unset lets users print to Google
// Cloud Print from the Google Chrome print dialog. Google Chrome can submit
// documents to Google Cloud Print for printing. This doesn't prevent users from
// submitting print jobs on websites.
//
// Setting the policy to Disabled means users can't print to Google Cloud Print
// from the Google Chrome print dialog.
//
// In order to keep Google Cloud Print destinations discoverable, this policy
// must be set to Enabled and cloud must not be included in the
// PrinterTypeDenyList policy.
//
// Valid values:
//   True: Enable submission of documents to Google Cloud Print
//   False: Disable submission of documents to Google Cloud Print
//
// Supported on:
message CloudPrintSubmitEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudPrintSubmitEnabled = 2;
}

// Enterprise web store URL (deprecated)
//
// This setting has been retired as of Google Chrome version 29. The recommended
// way to set up organization-hosted extension/app collections is to include the
// site hosting the CRX packages in ExtensionInstallSources and put direct
// download links to the packages on a web page. A launcher for that web page
// can be created using the ExtensionInstallForcelist policy.
//
// Supported on:
message EnterpriseWebStoreURLProto {
  optional PolicyOptions policy_options = 1;
  optional string EnterpriseWebStoreURL = 2;
}

// Enterprise web store name (deprecated)
//
// This setting has been retired as of Google Chrome version 29. The recommended
// way to set up organization-hosted extension/app collections is to include the
// site hosting the CRX packages in ExtensionInstallSources and put direct
// download links to the packages on a web page. A launcher for that web page
// can be created using the ExtensionInstallForcelist policy.
//
// Supported on:
message EnterpriseWebStoreNameProto {
  optional PolicyOptions policy_options = 1;
  optional string EnterpriseWebStoreName = 2;
}

// Disable Print Preview
//
// Setting the policy to Enabled has Google Chrome open the system print dialog
// instead of the built-in print preview when users request a printout.
//
// Setting the policy to Disabled or leaving it unset has print commands trigger
// the print preview screen.
//
// Valid values:
//   True: Disable print preview
//   False: Enable print preview
//
// Supported on: fuchsia, linux, mac, win
message DisablePrintPreviewProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisablePrintPreview = 2;
}

// Print Headers and Footers
//
// Setting the policy to Enabled turns headers and footers on in print preview.
// Setting the policy to Disabled turns them off in print preview.
//
// If you set the policy, users can't change it. If unset, users decides whether
// headers and footers appear.
//
// Valid values:
//   True: Show headers and footers in print preview
//   False: Hide headers and footers in print preview
//   None: Allow the user to decide
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PrintHeaderFooterProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrintHeaderFooter = 2;
}

// Default printer selection rules
//
// Setting the policy sets the rules for selecting the default printer in Google
// Chrome, overriding the default rules. Printer selection occurs the first time
// users try to print, when Google Chrome seeks a printer matching the specified
// attributes. In case of a less than perfect match, Google Chrome can be set to
// select any matching printer, depending on the order printers are discovered.
//
// Leaving the policy unset or set to attributes for which there's no match
// means the built-in PDF printer is the default. If there's no PDF printer,
// Google Chrome defaults to none.
//
// Printers connected to Google Cloud Print are considered "cloud", the rest of
// the printers are classified as "local".
//
// Note: Omitting a field means all values match. For example, not specifying
// connectivity causes Print Preview to start discovery of all kinds of
// printers, "local" and "cloud". Regular expression patterns must follow the
// JavaScript RegExp syntax, and matches are case sensistive.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultPrinterSelectionProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultPrinterSelection = 2;
}

// Disable TLS False Start
//
// Specifies whether the TLS False Start optimization should be disabled. For
// historical reasons, this policy is named DisableSSLRecordSplitting.
//
// If the policy is not set, or is set to false, then TLS False Start will be
// enabled. If it is set to true, TLS False Start will be disabled.
//
// Supported on:
message DisableSSLRecordSplittingProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisableSSLRecordSplitting = 2;
}

// Enable online OCSP/CRL checks
//
// Setting the policy to True means online OCSP/CRL checks are performed.
//
// Setting the policy to False or leaving it unset means Google Chrome won't
// perform online revocation checks in Google Chrome 19 and later.
//
// Note: OCSP/CRL checks provide no effective security benefit.
//
// Valid values:
//   True: Allow online OCSP/CRL checks to be performed
//   False: Prevent online OCSP/CRL checks from being performed
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message EnableOnlineRevocationChecksProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableOnlineRevocationChecks = 2;
}

// Require online OCSP/CRL checks for local trust anchors
//
// Setting the policy to True means Google Chrome always performs revocation
// checking for successfully validated server certificates signed by locally
// installed CA certificates. If Google Chrome can't get revocation status
// information, Google Chrome treats these certificates as revoked (hard-fail).
//
// Setting the policy to False or leaving it unset means Google Chrome uses
// existing online revocation-checking settings.
//
// Valid values:
//   True: Perform revocation checks for successfully validated server
// certificates signed by locally installed CA certificates
//   False: Use existing online revocation-checking settings
//
// Supported on: chrome_os, fuchsia, linux, win
message RequireOnlineRevocationChecksForLocalAnchorsProto {
  optional PolicyOptions policy_options = 1;
  optional bool RequireOnlineRevocationChecksForLocalAnchors = 2;
}

// Allow SHA-1 signed certificates issued by local trust anchors
//
// When this setting is enabled, Google Chrome allows SHA-1 signed certificates
// as long as they successfully validate and chain to a locally-installed CA
// certificates.
//
// Note that this policy depends on the operating system certificate
// verification stack allowing SHA-1 signatures. If an OS update changes the OS
// handling of SHA-1 certificates, this policy may no longer have effect.
// Further, this policy is intended as a temporary workaround to give
// enterprises more time to move away from SHA-1.  This policy will be removed
// on or around January 1st 2019.
//
// If this policy is not set, or it is set to false, then Google Chrome follows
// the publicly announced SHA-1 deprecation schedule.
//
// Valid values:
//   True: Allow SHA-1 signed certificates issued by local trust anchors
//   False: Disallow SHA-1 signed certificates
//
// Supported on:
message EnableSha1ForLocalAnchorsProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableSha1ForLocalAnchors = 2;
}

// Allow certificates issued by local trust anchors without
// subjectAlternativeName extension
//
// When this setting is enabled, Google Chrome will use the commonName of a
// server certificate to match a hostname if the certificate is missing a
// subjectAlternativeName extension, as long as it successfully validates and
// chains to a locally-installed CA certificates.
//
// Note that this is not recommended, as this may allow bypassing the
// nameConstraints extension that restricts the hostnames that a given
// certificate can be authorized for.
//
// If this policy is not set, or is set to false, server certificates that lack
// a subjectAlternativeName extension containing either a DNS name or IP address
// will not be trusted.
//
// Valid values:
//   True: Allow certificates lacking a subjectAlternativeName extension when
// issued by local trust anchors
//   False: Disallow certificates lacking a subjectAlternativeName extension
//
// Supported on:
message EnableCommonNameFallbackForLocalAnchorsProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableCommonNameFallbackForLocalAnchors = 2;
}

// Enable trust in Symantec Corporation's Legacy PKI Infrastructure
//
// When this setting is enabled, Google Chrome allows certificates issued by
// Symantec Corporation's Legacy PKI operations to be trusted if they otherwise
// successfully validate and chain to a recognized CA certificate.
//
// Note that this policy depends on the operating system still recognizing
// certificates from Symantec's legacy infrastructure. If an OS update changes
// the OS handling of such certificates, this policy no longer has effect.
// Further, this policy is intended as a temporary workaround to give
// enterprises more time to transition away from legacy Symantec certificates.
// This policy will be removed on or around January 1st 2019.
//
// If this policy is not set, or it is set to false, then Google Chrome follows
// the publicly announced deprecation schedule.
//
// See https://g.co/chrome/symantecpkicerts for more details on this
// deprecation.
//
// Valid values:
//   True: Enable trust in certificates issued by Symantec Corporation Legacy
// PKI
//   False: Disable trust in certificates issued by Symantec Corporation Legacy
// PKI
//
// Supported on:
message EnableSymantecLegacyInfrastructureProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableSymantecLegacyInfrastructure = 2;
}

// Determines whether the built-in certificate verifier will be used to verify
// server certificates
//
// When this setting is enabled, Google Chrome will perform verification of
// server certificates using the built-in certificate verifier.
// When this setting is disabled, Google Chrome will perform verification of
// server certificates using the legacy certificate verifier provided by the
// platform, unless ChromeRootStoreEnabled is enabled.
// When this setting is not set, the built-in or the legacy certificate verifier
// may be used.
//
// This policy is planned to be removed in Google Chrome for macOS version 107,
// when support for the legacy certificate verifier on macOS is planned to be
// removed.
//
// Valid values:
//   True: Use the built-in certificate verifier
//   False: Use the legacy platform certificate verifier
//   None: Use any certificate verifier
//
// Supported on: mac
message BuiltinCertificateVerifierEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BuiltinCertificateVerifierEnabled = 2;
}

// Determines whether the Chrome Root Store and built-in certificate verifier
// will be used to verify server certificates
//
// When this setting is enabled, Google Chrome will perform verification of
// server certificates using the built-in certificate verifier with the Chrome
// Root Store as the source of public trust.
// When this setting is disabled, Google Chrome will not use the Chrome Root
// Store. Verification may use the system certificate verifier, or the builtin
// verifier if the BuiltinCertificateVerifierEnabled policy is available and not
// disabled.
// When this setting is not set, the Chrome Root Store or system provided roots
// may be used.
//
// This policy is planned to be removed in Google Chrome for Microsoft® Windows®
// and macOS version 111, when support for using the platform supplied
// certificate verifier and roots are planned to be removed.
//
// Valid values:
//   True: Use the Chrome Root Store.
//   False: Do not use the Chrome Root Store.
//   None: Chrome Root Store may be used depending on feature launch process.
//
// Supported on: mac, win
message ChromeRootStoreEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ChromeRootStoreEnabled = 2;
}

// Ephemeral profile
//
// If set to enabled this policy forces the profile to be switched to ephemeral
// mode. If this policy is specified as an OS policy (e.g. GPO on Windows) it
// will apply to every profile on the system; if the policy is set as a Cloud
// policy it will apply only to a profile signed in with a managed account.
//
// In this mode the profile data is persisted on disk only for the length of the
// user session. Features like browser history, extensions and their data, web
// data like cookies and web databases are not preserved after the browser is
// closed. However this does not prevent the user from downloading any data to
// disk manually, save pages or print them.
//
// If the user has enabled sync all this data is preserved in their sync profile
// just like with regular profiles. Incognito mode is also available if not
// explicitly disabled by policy.
//
// If the policy is set to disabled or left not set signing in leads to regular
// profiles.
//
// Valid values:
//   True: Clear profile data on disk when user session ends
//   False: Persist profile data on disk when user session ends
//
// Supported on: fuchsia, linux, mac, win
message ForceEphemeralProfilesProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceEphemeralProfiles = 2;
}

// Limit the time for which a user authenticated via GAIA without SAML can log
// in offline
//
// During login, Google ChromeOS can authenticate against a server (online) or
// using a cached password (offline).
//
// When this policy is set to a value of -1, this policy will not enforce online
// authentication and will allow the user to use offline authentication until a
// different reason than this policy enforces an online login. If the policy is
// set to a value of 0, online login will always be required. When this policy
// is set to any other value, it specifies the length of time since the last
// online authentication after which the user must use online authentication
// again in the next sign-in.
//
// Leaving this policy not set will make Google ChromeOS use offline login.
//
// This policy affects only users who authenticated using GAIA without SAML.
//
// The policy value should be specified in days.
//
// Supported on: chrome_os
message GaiaOfflineSigninTimeLimitDaysProto {
  optional PolicyOptions policy_options = 1;
  optional int64 GaiaOfflineSigninTimeLimitDays = 2;
}

// Limit the time for which a user authenticated via SAML can log in offline
//
// During login, Google ChromeOS can authenticate against a server (online) or
// using a cached password (offline).
//
// When this policy is set to a value of -1, the user can authenticate offline
// indefinitely. When this policy is set to any other value, it specifies the
// length of time since the last online authentication after which the user must
// use online authentication again.
//
// Leaving this policy not set will make Google ChromeOS use a default time
// limit of 14 days after which the user must use online authentication again.
//
// This policy affects only users who authenticated using SAML.
//
// The policy value should be specified in seconds.
//
// Supported on: chrome_os
message SAMLOfflineSigninTimeLimitProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SAMLOfflineSigninTimeLimit = 2;
}

// Limit the time for which a user authenticated via GAIA without SAML can log
// in offline at the lock screen
//
// While logging in through the lock screen, Google ChromeOS can authenticate
// against a server (online) or using a cached password (offline).
//
// When this policy is set to -2, it will match the value of the login screen
// offline signin time limit which comes from GaiaOfflineSigninTimeLimitDays.
//
// When the policy is unset, or set to a value of -1, it will not enforce online
// authentication on the lock screen and will allow the user to use offline
// authentication unless a different reason than this policy enforces an online
// authentication.
//
// If the policy is set to a value of 0, online authentication will always be
// required.
//
// When this policy is set to any other value, it specifies the number of days
// since the last online authentication after which the user must use online
// authentication again in the next login through the lock screen.
//
// This policy affects users who authenticated using GAIA without SAML.
//
// The policy value should be specified in days.
//
// Supported on: chrome_os
message GaiaLockScreenOfflineSigninTimeLimitDaysProto {
  optional PolicyOptions policy_options = 1;
  optional int64 GaiaLockScreenOfflineSigninTimeLimitDays = 2;
}

// Limit the time for which a user authenticated via SAML can log in offline at
// the lock screen
//
// While logging in through the lock screen, Google ChromeOS can authenticate
// against a server (online) or using a cached password (offline).
//
// When this policy is set to -2, it will match the value of the login screen
// offline signin time limit which comes from SAMLOfflineSigninTimeLimit.
//
// When the policy is unset or set to a value of -1, it will not enforce online
// authentication on the lock screen and will allow the user to use offline
// authentication unless a different reason than this policy enforces an online
// authentication.
//
// If the policy is set to a value of 0, online authentication will always be
// required.
//
// When this policy is set to any other value, it specifies the number of days
// since the last online authentication after which the user must use online
// authentication again in the next login through the lock screen.
//
// This policy affects users who authenticated using SAML.
//
// The policy value should be specified in days.
//
// Supported on: chrome_os
message SamlLockScreenOfflineSigninTimeLimitDaysProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SamlLockScreenOfflineSigninTimeLimitDays = 2;
}

// Report information about status of Android
//
// If Android apps are on, then setting the policy to True has enrolled devices
// report Android status information.
//
// Setting the policy to Disabled or leaving it unset means enrolled devices
// don't report Android status information
//
// Supported on: chrome_os
message ReportArcStatusEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportArcStatusEnabled = 2;
}

// Report information about usage of Linux apps
//
// If Linux app support is on, setting the policy to Enabled sends information
// about Linux apps usage back to the server.
//
// Setting the policy to Disabled or leaving it unset means no usage information
// is reported.
//
// Supported on: chrome_os
message ReportCrostiniUsageEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportCrostiniUsageEnabled = 2;
}

// Allow managed session on device
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 88. Public sessions are no longer supported. Please use
// DeviceLocalAccounts to configure managed-guest sessions instead.
// If this policy is set to false, managed guest session will behave as
// documented in https://support.google.com/chrome/a/answer/3017014 - the
// standard "Public Session".
//
// If this policy is set to true or left unset, managed guest session will take
// on "Managed Session" behaviour which lifts many of the restrictions that are
// in place for regular "Public Sessions".
//
// If this policy is set, the user cannot change or override it.
//
// Supported on: chrome_os
message DeviceLocalAccountManagedSessionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DeviceLocalAccountManagedSessionEnabled = 2;
}

// Reduce Managed-guest session auto-launch notifications
//
// Note that this policy is deprecated in M87 and removed in M89. Please use
// ManagedGuestSessionPrivacyWarningsEnabled to configure the privacy warnings
// of managed-guest sessions instead.
//
// Control the auto launch notification of the managed guest session on Google
// ChromeOS.
//
// If this policy is set to True, the privacy warning notification will be
// closed after some seconds.
//
// If the policy is set to False or not set, the privacy warning notification
// will be pinned until the user dismisses it.
//
// Supported on:
message ManagedGuestSessionAutoLaunchNotificationReducedProto {
  optional PolicyOptions policy_options = 1;
  optional bool ManagedGuestSessionAutoLaunchNotificationReduced = 2;
}

// Continue running background apps when Google Chrome is closed
//
// Setting the policy to Enabled turns background mode on. In background mode, a
// Google Chrome process is started on OS sign-in and keeps running when the
// last browser window is closed, allowing background apps and the browsing
// session to remain active. The background process displays an icon in the
// system tray and can always be closed from there.
//
// Setting the policy to Disabled turns background mode off.
//
// If you set the policy, users can't change it in the browser settings. If
// unset, background mode is off at first, but users can change it.
//
// Supported on: linux, win
message BackgroundModeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BackgroundModeEnabled = 2;
}

// Disable Drive in the Google ChromeOS Files app
//
// Setting the policy to Enabled turns off Google Drive syncing in the Google
// ChromeOS Files app. No data is uploaded to Drive.
//
// Setting the policy to Disabled or leaving it unset lets users transfer files
// to Drive.
//
// Supported on: chrome_os
message DriveDisabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DriveDisabled = 2;
}

// Disable Google Drive over cellular connections in the Google ChromeOS Files
// app
//
// Setting the policy to Enabled turns off Google Drive syncing in the Google
// ChromeOS Files app when on a cellular connection. Data is only synced to
// Drive when connected through Wi-Fi or Ethernet.
//
// Setting the policy to Disabled or leaving it unset lets users transfer files
// to Drive on cellular connections.
//
// Supported on: chrome_os
message DriveDisabledOverCellularProto {
  optional PolicyOptions policy_options = 1;
  optional bool DriveDisabledOverCellular = 2;
}

// List of pinned apps to show in the launcher
//
// Setting the policy fixes which application identifiers Google ChromeOS shows
// as pinned apps in the launcher bar, and users can't change them.
//
// Specify Chrome apps by their ID, such as pjkljhegncpnkpknbcohdijeoejaedia;
// Android apps by their package name, such as com.google.android.gm; and web
// apps by the URL used in WebAppInstallForceList, such as
// https://google.com/maps.
//
// Leaving it unset lets users change the list of pinned apps in the launcher.
//
// Supported on: chrome_os
message PinnedLauncherAppsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PinnedLauncherApps = 2;
}

// Restrict which Google accounts are allowed to be set as browser primary
// accounts in Google Chrome
//
// Contains a regular expression which is used to determine which Google
// accounts can be set as browser primary accounts in Google Chrome (i.e. the
// account that is chosen during the Sync opt-in flow).
//
// An appropriate error is displayed if a user tries to set a browser primary
// account with a username that does not match this pattern.
//
// If this policy is left not set or blank, then the user can set any Google
// account as a browser primary account in Google Chrome.
//
// Supported on: fuchsia, linux, mac, win
message RestrictSigninToPatternProto {
  optional PolicyOptions policy_options = 1;
  optional string RestrictSigninToPattern = 2;
}

// Disable proceeding from the Safe Browsing warning page
//
// Setting the policy to Enabled prevents users from proceeding past the warning
// page the Safe Browsing service shows to the malicious site. This policy only
// prevents users from proceeding on Safe Browsing warnings such as malware and
// phishing, not for SSL certificate-related issues such as invalid or expired
// certificates.
//
// Setting the policy to Disabled or leaving it unset means users can choose to
// proceed to the flagged site after the warning appears.
//
// See more about Safe Browsing ( https://developers.google.com/safe-browsing ).
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message DisableSafeBrowsingProceedAnywayProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisableSafeBrowsingProceedAnyway = 2;
}

// Allow users to opt in to Safe Browsing extended reporting
//
// This policy is deprecated in M82 and removed in M85, use
// SafeBrowsingExtendedReportingEnabled instead. Disabling
// SafeBrowsingExtendedReportingOptInAllowed is equivalent to disabling
// SafeBrowsingExtendedReportingEnabled. Enabling
// SafeBrowsingExtendedReportingOptInAllowed or leaving this setting unset is
// equivalent to leaving SafeBrowsingExtendedReportingEnabled unset.
//
// Setting this policy to false stops users from choosing to send some system
// information and page content to Google servers. If this setting is true or
// not configured, then users will be allowed to send some system information
// and page content to Safe Browsing to help detect dangerous apps and sites.
//
// See https://developers.google.com/safe-browsing for more info on Safe
// Browsing.
//
// Supported on:
message SafeBrowsingExtendedReportingOptInAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SafeBrowsingExtendedReportingOptInAllowed = 2;
}

// Enable or disable spell checking web service
//
// Setting the policy to Enabled puts a Google web service in use to help
// resolve spelling errors. This policy only controls the use of the online
// service. Setting the policy to Disabled means this service is never used.
//
// Leaving the policy unset lets users choose whether to use the spellcheck
// service.
//
// The spell check can always use a downloaded dictionary locally unless the
// feature is disabled by SpellcheckEnabled in which case this policy will have
// no effect.
//
// Valid values:
//   True: Use a Google web service to help resolve spelling errors
//   False: Do not use any Google web services to help resolve spelling errors
//   None: Allow the user to choose if Google web services are used to resolve
// spelling errors
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SpellCheckServiceEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SpellCheckServiceEnabled = 2;
}

// Disable mounting of external storage
//
// Setting the policy to True makes all types of external storage media (USB
// flash drives, external hard drives, SD and other memory cards, optical
// storage) unavailable in the file browser. Setting the policy to False or
// leaving it unset means users can use external storage on their device.
//
// Note: The policy doesn't affect Google Drive and internal storage. Users can
// still access files saved in the Downloads folder.
//
// Supported on: chrome_os
message ExternalStorageDisabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ExternalStorageDisabled = 2;
}

// Treat external storage devices as read-only
//
// Setting the policy to True prevents users from writing to external storage
// devices.
//
// Unless external storage is blocked, if you set ExternalStorageReadOnly to
// False or leave it unset, users can create and modify files of physically
// writable, external storage devices. (You can block external storage by
// setting ExternalStorageDisable to True.)
//
// Supported on: chrome_os
message ExternalStorageReadOnlyProto {
  optional PolicyOptions policy_options = 1;
  optional bool ExternalStorageReadOnly = 2;
}

// Allow playing audio
//
// Setting the policy to Enabled or leaving it unset allows all supported audio
// outputs on the users' devices.
//
// Setting the policy to Disabled allows no audio output while users are signed
// in.
//
// Note: The policy affects all audio output, including audio accessibility
// features. Do not turn the policy off if a user requires a screen reader.
//
// Supported on: chrome_os
message AudioOutputAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool AudioOutputAllowed = 2;
}

// Allow or deny audio capture
//
// Setting the policy to Enabled or leaving it unset means that, with the
// exception of URLs set in the AudioCaptureAllowedUrls list, users get prompted
// for audio capture access.
//
// Setting the policy to Disabled turns off prompts, and audio capture is only
// available to URLs set in the AudioCaptureAllowedUrls list.
//
// Note: The policy affects all audio input (not just the built-in microphone).
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AudioCaptureAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool AudioCaptureAllowed = 2;
}

// URLs that will be granted access to audio capture devices without prompt
//
// Setting the policy means you specify the URL list whose patterns get matched
// to the security origin of the requesting URL. A match grants access to audio
// capture devices without prompt
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AudioCaptureAllowedUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AudioCaptureAllowedUrls = 2;
}

// Allow or deny video capture
//
// Setting the policy to Enabled or leaving it unset means that, with the
// exception of URLs set in the VideoCaptureAllowedUrls list, users get prompted
// for video capture access.
//
// Setting the policy to Disabled turns off prompts, and video capture is only
// available to URLs set in the VideoCaptureAllowedUrls list.
//
// Note: The policy affects all video input (not just the built-in camera).
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message VideoCaptureAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool VideoCaptureAllowed = 2;
}

// URLs that will be granted access to video capture devices without prompt
//
// Setting the policy means you specify the URL list whose patterns get matched
// to the security origin of the requesting URL. A match grants access to video
// capture devices without prompt
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message VideoCaptureAllowedUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList VideoCaptureAllowedUrls = 2;
}

// Disable taking screenshots
//
// Setting the policy to True disallows screenshots taken with keyboard
// shortcuts or extension APIs. Setting the policy to False allows screenshots.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DisableScreenshotsProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisableScreenshots = 2;
}

// Enable virtual keyboard
//
// Controls the on-screen keyboard, acting as a supplementary policy to the
// VirtualKeyboardEnabled policy.
//
// If the VirtualKeyboardEnabled policy is True or if the Enable on-screen
// keyboard ChromeOS setting is on, this policy has no effect.
//
// If the VirtualKeyboardEnabled policy is False or not set and the Enable on-
// screen keyboard ChromeOS setting is off, this policy has the following
// effect:
// If this policy is not set, the on-screen keyboard is displayed when the
// device is in tablet mode.
// If this policy is set to True, the on-screen keyboard is always displayed.
// If this policy is set to False, the on-screen keyboard is never displayed.
//
// The on-screen keyboard may change to a compact layout depending on the input
// method.
//
// If you set the policy, users can't change it.
//
// Supported on: chrome_os
message TouchVirtualKeyboardEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool TouchVirtualKeyboardEnabled = 2;
}

// Add a logout button to the system tray
//
// Setting the policy to True displays a big, red sign-out button in the system
// tray during active sessions while the screen isn't locked.
//
// Setting the policy to False or leaving it unset means no button appears.
//
// Supported on: chrome_os
message ShowLogoutButtonInTrayProto {
  optional PolicyOptions policy_options = 1;
  optional bool ShowLogoutButtonInTray = 2;
}

// Use built-in DNS client
//
// This policy controls which software stack is used to communicate with the DNS
// server: the Operating System DNS client, or Google Chrome's built-in DNS
// client. This policy does not affect which DNS servers are used: if, for
// example, the operating system is configured to use an enterprise DNS server,
// that same server would be used by the built-in DNS client. It also does not
// control if DNS-over-HTTPS is used; Google Chrome will always use the built-in
// resolver for DNS-over-HTTPS requests. Please see the DnsOverHttpsMode policy
// for information on controlling DNS-over-HTTPS.
//
// If this policy is set to Enabled, the built-in DNS client will be used, if
// available.
//
// If this policy is set to Disabled, the built-in DNS client will only be used
// when DNS-over-HTTPS is in use.
//
// If this policy is left unset, the built-in DNS client will be enabled by
// default on macOS, Android (when neither Private DNS nor VPN are enabled) and
// Google ChromeOS.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message BuiltInDnsClientEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BuiltInDnsClientEnabled = 2;
}

// Controls the mode of DNS-over-HTTPS
//
// Controls the mode of the DNS-over-HTTPS resolver. Please note that this
// policy will only set the default mode for each query. The mode may be
// overridden for special types of queries such as requests to resolve a DNS-
// over-HTTPS server hostname.
//
// The "off" mode will disable DNS-over-HTTPS.
//
// The "automatic" mode will send DNS-over-HTTPS queries first if a DNS-over-
// HTTPS server is available and may fallback to sending insecure queries on
// error.
//
// The "secure" mode will only send DNS-over-HTTPS queries and will fail to
// resolve on error.
//
// On Android Pie and above, if DNS-over-TLS is active, Google Chrome will not
// send insecure DNS requests.
//
// If this policy is unset the browser may send DNS-over-HTTPS requests to a
// resolver associated with the user's configured system resolver.
//
// Valid values:
//   off: Disable DNS-over-HTTPS
//   automatic: Enable DNS-over-HTTPS with insecure fallback
//   secure: Enable DNS-over-HTTPS without insecure fallback
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DnsOverHttpsModeProto {
  optional PolicyOptions policy_options = 1;
  optional string DnsOverHttpsMode = 2;
}

// Specify URI template of desired DNS-over-HTTPS resolver
//
// The URI template of the desired DNS-over-HTTPS resolver. To specify multiple
// DNS-over-HTTPS resolvers, separate the corresponding URI templates with
// spaces.
//
// If the DnsOverHttpsMode is set to "secure" then this policy must be set and
// not empty.
//
// If the DnsOverHttpsMode is set to "automatic" and this policy is set then the
// URI templates specified will be used; if this policy is unset then hardcoded
// mappings will be used to attempt to upgrade the user's current DNS resolver
// to a DoH resolver operated by the same provider.
//
// If the URI template contains a dns variable, requests to the resolver will
// use GET; otherwise requests will use POST.
//
// Incorrectly formatted templates will be ignored.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DnsOverHttpsTemplatesProto {
  optional PolicyOptions policy_options = 1;
  optional string DnsOverHttpsTemplates = 2;
}

// Allow DNS queries for additional DNS record types
//
// This policy controls whether Google Chrome may query additional DNS record
// types when making insecure DNS requests. This policy has no effect on DNS
// queries made via Secure DNS, which may always query additional DNS types.
//
// If this policy is unset or set to Enabled, additional types such as HTTPS
// (DNS type 65) may be queried in addition to A (DNS type 1) and AAAA (DNS type
// 28).
//
// If this policy is set to Disabled, DNS will only be queried for A (DNS type
// 1) and/or AAAA (DNS type 28).
//
// This policy is a temporary measure and will be removed in future versions of
// Google Chrome. After removal of the policy, Google Chrome will always be able
// to query additional DNS types.
//
// Valid values:
//   True: Allow additional DNS query types
//   False: Prevent additional DNS query types
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AdditionalDnsQueryTypesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AdditionalDnsQueryTypesEnabled = 2;
}

// Control shelf auto-hiding
//
// Setting the policy to Always will autohide the Google ChromeOS shelf. Setting
// the policy to Never ensures the shelf never autohides.
//
// If you set the policy, users can't change it. If not set, users decide
// whether the shelf autohides.
//
// Valid values:
//   Always: Always auto-hide the shelf
//   Never: Never auto-hide the shelf
//
// Supported on: chrome_os
message ShelfAutoHideBehaviorProto {
  optional PolicyOptions policy_options = 1;
  optional string ShelfAutoHideBehavior = 2;
}

// Control the shelf position
//
// Control the position of the Google ChromeOS shelf.
//
// If this policy is set to 'Bottom', the shelf will be placed at the bottom of
// the screen.
//
// If this policy is set to 'Left', the shelf will be placed on the left side of
// the screen.
//
// If this policy is set to 'Right', the shelf will be placed on the right side
// of the screen.
//
// If you set this policy as mandatory, users cannot change or override it.
//
// If the policy is left not set, the shelf will be be positioned at the bottom
// of the screen by default and the user can change the shelf's position.
//
// Valid values:
//   Left: Position the shelf on the left side of the screen
//   Bottom: Position the shelf at the bottom of the screen
//   Right: Position the shelf on the right side of the screen
//
// Supported on: chrome_os
message ShelfAlignmentProto {
  optional PolicyOptions policy_options = 1;
  optional string ShelfAlignment = 2;
}

// Configure the camera, browser settings, os settings, scanning, web store,
// canvas, explore and crosh features to be disabled
//
// Allows you to set a list of Google ChromeOS features to be disabled.
//
// Disabling any of these features means that the user can't access it from the
// UI and will see it as "disabled by admin". The user experience of disabled
// features is decided by SystemFeaturesDisableMode
//
// If the policy is left not set, all Google ChromeOS features will be enabled
// by default and the user can use any of them.
//
// Note: The scanning feature is currently disabled by default via a feature
// flag. If the user enables the feature via the feature flag, the feature can
// still be disabled by this policy.
//
// Valid values:
//   browser_settings: Browser Settings
//   os_settings: OS Settings
//   camera: Camera
//   scanning: Scanning (supported since version 87)
//   web_store: Web Store (supported since version 89)
//   canvas: Canvas (supported since version 90)
//   google_news: Unsupported
//   explore: Explore (supported since version 91)
//   crosh: Crosh (supported since version 99)
//
// Supported on: chrome_os
message SystemFeaturesDisableListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SystemFeaturesDisableList = 2;
}

// Set the user experience of disabled features
//
// Controls the user experience of disabled features listed in
// SystemFeaturesDisableList.
//
// If this policy is set to "blocked", the disabled features will become
// unusable but still visible to users.
//
// If this policy is set to "hidden", the disabled features will become unusable
// and invisible to users.
//
// If this policy is left unset or has an invalid value, the disable mode of
// system features will be "blocked".
//
// Valid values:
//   blocked: Block the disabled features
//   hidden: Hide and block the disabled features
//
// Supported on: chrome_os
message SystemFeaturesDisableModeProto {
  optional PolicyOptions policy_options = 1;
  optional string SystemFeaturesDisableMode = 2;
}

// Enables the floating accessibility menu
//
// In kiosk mode, controls whether the floating accessibility menu is being
// shown.
//
// If this policy is set to enabled, the floating accessibility menu will be
// always shown.
//
// If this policy is set to disabled or left unset, the floating accessibility
// menu will never be shown.
//
// Supported on: chrome_os
message FloatingAccessibilityMenuEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool FloatingAccessibilityMenuEnabled = 2;
}

// Set the display name for device-local accounts
//
// Controls the account name Google ChromeOS shows on the login screen for the
// corresponding device-local account.
//
// If this policy is set, the login screen will use the specified string in the
// picture-based login chooser for the corresponding device-local account.
//
// If the policy is left not set, Google ChromeOS will use the device-local
// account's email account ID as the display name on the login screen.
//
// This policy is ignored for regular user accounts.
//
// Supported on: chrome_os
message UserDisplayNameProto {
  optional PolicyOptions policy_options = 1;
  optional string UserDisplayName = 2;
}

// Limit the length of a user session
//
// When this policy is set, it specifies the length of time after which a user
// is automatically logged out, terminating the session. The user is informed
// about the remaining time by a countdown timer shown in the system tray.
//
// When this policy is not set, the session length is not limited.
//
// If you set this policy, users cannot change or override it.
//
// The policy value should be specified in milliseconds. Values are clamped to a
// range of 30 seconds to 24 hours.
//
// Supported on: chrome_os
message SessionLengthLimitProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SessionLengthLimit = 2;
}

// Allow fullscreen mode
//
// Setting the policy to True or leaving it unset means that, with appropriate
// permissions, users, apps, and extensions can enter Fullscreen mode (in which
// only web content appears).
//
// Setting the policy to False means users, apps, and extensions can't enter
// Fullscreen mode.
//
// Supported on: chrome_os, fuchsia, linux, win
message FullscreenAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool FullscreenAllowed = 2;
}

// Enable fullscreen alert
//
// Specifies whether the fullscreen alert should be shown when the device
// returns from sleep or dark screen.
//
// When the policy is unset or set to True, an alert will be shown to remind the
// users to exit fullscreen before entering password. When the policy is set to
// False, no alert would be shown.
//
// Valid values:
//   True: Enable fullscreen alert
//   False: Disable show fullscreen alert
//   None: Enable fullscreen alert
//
// Supported on: chrome_os
message FullscreenAlertEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool FullscreenAlertEnabled = 2;
}

// List of URLs which are allowed to remain in full screen mode without showing
// a notification
//
// Configure a list of URLs that are allowed to stay in full screen mode without
// showing a notification when the device returns from the lock screen.
//
// Normally, full screen mode is turned off when returning from the lock screen
// in order to reduce the risk of phishing attacks. This policy allows to
// specify URLs that will be considered trusted sources which are permitted to
// continue full screen mode on unlock. It is set by specifying a list of URL
// patterns formatted according to this format (
// https://www.chromium.org/administrators/url-blocklist-filter-format ). E.g.,
// it is possible to always keep full screen mode on unlock and disable the
// notifications altogether by specifying the wildcard character * matching all
// URLs.
//
// Setting this policy to an empty list or leaving it unset means no URLs are
// allowed to continue full screen mode without a notification.
//
// Supported on: chrome_os
message KeepFullscreenWithoutNotificationUrlAllowListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList KeepFullscreenWithoutNotificationUrlAllowList = 2;
}

// Screen dim delay when running on AC power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which the screen is
// dimmed when running on AC power.
//
// When this policy is set to a value greater than zero, it specifies the length
// of time that the user must remain idle before Google ChromeOS dims the
// screen.
//
// When this policy is set to zero, Google ChromeOS does not dim the screen when
// the user becomes idle.
//
// When this policy is unset, a default length of time is used.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than or equal the screen off delay (if set) and the idle delay.
//
// Supported on: chrome_os
message ScreenDimDelayACProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenDimDelayAC = 2;
}

// Screen off delay when running on AC power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which the screen is
// turned off when running on AC power.
//
// When this policy is set to a value greater than zero, it specifies the length
// of time that the user must remain idle before Google ChromeOS turns off the
// screen.
//
// When this policy is set to zero, Google ChromeOS does not turn off the screen
// when the user becomes idle.
//
// When this policy is unset, a default length of time is used.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than or equal the idle delay.
//
// Supported on: chrome_os
message ScreenOffDelayACProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenOffDelayAC = 2;
}

// Screen lock delay when running on AC power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use ScreenLockDelays instead.
//
// Specifies the length of time without user input after which the screen is
// locked when running on AC power.
//
// When this policy is set to a value greater than zero, it specifies the length
// of time that the user must remain idle before Google ChromeOS locks the
// screen.
//
// When this policy is set to zero, Google ChromeOS does not lock the screen
// when the user becomes idle.
//
// When this policy is unset, a default length of time is used.
//
// The recommended way to lock the screen on idle is to enable screen locking on
// suspend and have Google ChromeOS suspend after the idle delay. This policy
// should only be used when screen locking should occur a significant amount of
// time sooner than suspend or when suspend on idle is not desired at all.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than the idle delay.
//
// Supported on: chrome_os
message ScreenLockDelayACProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenLockDelayAC = 2;
}

// Idle warning delay when running on AC power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which a warning dialog
// is shown when running on AC power.
//
// When this policy is set, it specifies the length of time that the user must
// remain idle before Google ChromeOS shows a warning dialog telling the user
// that the idle action is about to be taken.
//
// When this policy is unset, no warning dialog is shown.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than or equal the idle delay.
//
// The warning message is only shown if the idle action is to logout or shut
// down.
//
// Supported on: chrome_os
message IdleWarningDelayACProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleWarningDelayAC = 2;
}

// Idle delay when running on AC power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which the idle action
// is taken when running on AC power.
//
// When this policy is set, it specifies the length of time that the user must
// remain idle before Google ChromeOS takes the idle action, which can be
// configured separately.
//
// When this policy is unset, a default length of time is used.
//
// The policy value should be specified in milliseconds.
//
// Supported on: chrome_os
message IdleDelayACProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleDelayAC = 2;
}

// Screen dim delay when running on battery power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which the screen is
// dimmed when running on battery power.
//
// When this policy is set to a value greater than zero, it specifies the length
// of time that the user must remain idle before Google ChromeOS dims the
// screen.
//
// When this policy is set to zero, Google ChromeOS does not dim the screen when
// the user becomes idle.
//
// When this policy is unset, a default length of time is used.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than or equal the screen off delay (if set) and the idle delay.
//
// Supported on: chrome_os
message ScreenDimDelayBatteryProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenDimDelayBattery = 2;
}

// Screen off delay when running on battery power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which the screen is
// turned off when running on battery power.
//
// When this policy is set to a value greater than zero, it specifies the length
// of time that the user must remain idle before Google ChromeOS turns off the
// screen.
//
// When this policy is set to zero, Google ChromeOS does not turn off the screen
// when the user becomes idle.
//
// When this policy is unset, a default length of time is used.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than or equal the idle delay.
//
// Supported on: chrome_os
message ScreenOffDelayBatteryProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenOffDelayBattery = 2;
}

// Screen lock delay when running on battery power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use ScreenLockDelays instead.
//
// Specifies the length of time without user input after which the screen is
// locked when running on battery power.
//
// When this policy is set to a value greater than zero, it specifies the length
// of time that the user must remain idle before Google ChromeOS locks the
// screen.
//
// When this policy is set to zero, Google ChromeOS does not lock the screen
// when the user becomes idle.
//
// When this policy is unset, a default length of time is used.
//
// The recommended way to lock the screen on idle is to enable screen locking on
// suspend and have Google ChromeOS suspend after the idle delay. This policy
// should only be used when screen locking should occur a significant amount of
// time sooner than suspend or when suspend on idle is not desired at all.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than the idle delay.
//
// Supported on: chrome_os
message ScreenLockDelayBatteryProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenLockDelayBattery = 2;
}

// Idle warning delay when running on battery power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which a warning dialog
// is shown when running on battery power.
//
// When this policy is set, it specifies the length of time that the user must
// remain idle before Google ChromeOS shows a warning dialog telling the user
// that the idle action is about to be taken.
//
// When this policy is unset, no warning dialog is shown.
//
// The policy value should be specified in milliseconds. Values are clamped to
// be less than or equal the idle delay.
//
// The warning message is only shown if the idle action is to logout or shut
// down.
//
// Supported on: chrome_os
message IdleWarningDelayBatteryProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleWarningDelayBattery = 2;
}

// Idle delay when running on battery power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// Specifies the length of time without user input after which the idle action
// is taken when running on battery power.
//
// When this policy is set, it specifies the length of time that the user must
// remain idle before Google ChromeOS takes the idle action, which can be
// configured separately.
//
// When this policy is unset, a default length of time is used.
//
// The policy value should be specified in milliseconds.
//
// Supported on: chrome_os
message IdleDelayBatteryProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleDelayBattery = 2;
}

// Action to take when the idle delay is reached
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// This policy provides a fallback value for the more-specific IdleActionAC and
// IdleActionBattery policies. If this policy is set, its value gets used if the
// respective more-specific policy is not set.
//
// When this policy is unset, behavior of the more-specific policies remains
// unaffected.
//
// Valid values:
//   0: Suspend
//   1: Log the user out
//   2: Shut down
//   3: Do nothing
//
// Supported on: chrome_os
message IdleActionProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleAction = 2;
}

// Action to take when the idle delay is reached while running on AC power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// When this policy is set, it specifies the action that Google ChromeOS takes
// when the user remains idle for the length of time given by the idle delay,
// which can be configured separately.
//
// When this policy is unset, the default action is taken, which is suspend.
//
// If the action is suspend, Google ChromeOS can separately be configured to
// either lock or not lock the screen before suspending.
//
// Valid values:
//   0: Suspend
//   1: Log the user out
//   2: Shut down
//   3: Do nothing
//
// Supported on: chrome_os
message IdleActionACProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleActionAC = 2;
}

// Action to take when the idle delay is reached while running on battery power
//
// Note that this policy is deprecated and will be removed in Google ChromeOS
// version 85. Please use PowerManagementIdleSettings instead.
//
// When this policy is set, it specifies the action that Google ChromeOS takes
// when the user remains idle for the length of time given by the idle delay,
// which can be configured separately.
//
// When this policy is unset, the default action is taken, which is suspend.
//
// If the action is suspend, Google ChromeOS can separately be configured to
// either lock or not lock the screen before suspending.
//
// Valid values:
//   0: Suspend
//   1: Log the user out
//   2: Shut down
//   3: Do nothing
//
// Supported on: chrome_os
message IdleActionBatteryProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleActionBattery = 2;
}

// Action to take when the user closes the lid
//
// Setting the policy specifies the action that Google ChromeOS takes when the
// user closes the device's lid.
//
// Leaving the policy unset means the Suspend action is taken.
//
// Note: If the action is Suspend, Google ChromeOS can separately be set up to
// lock or not lock the screen before suspending.
//
// Valid values:
//   0: Suspend
//   1: Log the user out
//   2: Shut down
//   3: Do nothing
//
// Supported on: chrome_os
message LidCloseActionProto {
  optional PolicyOptions policy_options = 1;
  optional int64 LidCloseAction = 2;
}

// Specify whether audio activity affects power management
//
// Setting the policy to Enabled or leaving it unset means the user is not
// considered idle while audio plays. This prevents the idle timeout from being
// reached and the idle action from being taken. However, screen dimming, screen
// off, and screen lock will still occur after their configured timeouts despite
// audio activity.
//
// Setting the policy to Disabled means the system can consider users idle
// despite audio activity.
//
// Supported on: chrome_os
message PowerManagementUsesAudioActivityProto {
  optional PolicyOptions policy_options = 1;
  optional bool PowerManagementUsesAudioActivity = 2;
}

// Specify whether video activity affects power management
//
// Setting the policy to Enabled or leaving it unset means the user is not
// considered idle while video plays. This prevents the idle delay, screen dim
// delay, screen off delay, and screen lock delay from being reached and the
// corresponding actions from being taken.
//
// Setting the policy to Disabled means the system can consider users idle
// despite video activity.
//
// Supported on: chrome_os
message PowerManagementUsesVideoActivityProto {
  optional PolicyOptions policy_options = 1;
  optional bool PowerManagementUsesVideoActivity = 2;
}

// Percentage by which to scale the idle delay in presentation mode (deprecated)
//
// This policy has been retired as of Google ChromeOS version 29. Please use the
// PresentationScreenDimDelayScale policy instead.
//
// Supported on:
message PresentationIdleDelayScaleProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PresentationIdleDelayScale = 2;
}

// Percentage by which to scale the screen dim delay in presentation mode
//
// If PowerSmartDimEnabled is Disabled, then setting
// PresentationScreenDimDelayScale specifies the percent that the screen dim
// delay scales when the device is presenting. When the screen dim delay scales,
// the screen off, screen lock, and idle delays adjust to maintain the same
// distances from the screen dim delay as originally set.
//
// Leaving the policy unset puts a default scale factor in use.
//
// Note: The scale factor must be 100% or more.
//
// Supported on: chrome_os
message PresentationScreenDimDelayScaleProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PresentationScreenDimDelayScale = 2;
}

// Allow wake locks
//
// Setting the policy to Enabled or leaving it unset allows wake locks for power
// management. Extensions can request wake locks through the power management
// extension API and ARC apps.
//
// Setting the policy to Disabled means wake lock requests are ignored.
//
// Valid values:
//   True: Allow wake locks for power management
//   False: Ignore requests for wake locks for power management
//
// Supported on: chrome_os
message AllowWakeLocksProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowWakeLocks = 2;
}

// Allow screen wake locks
//
// Unless AllowWakeLocks is set to Disabled, setting AllowScreenWakeLocks to
// Enabled or leaving it unset allows screen wake locks for power management.
// Extensions can request screen wake locks through the power management
// extension API and ARC apps.
//
// Setting the policy to Disabled demotes screen wake lock requests to system
// wake lock requests.
//
// Valid values:
//   True: Allow screen wake locks for power management
//   False: Demote screen wake lock requests to system wake lock requests
//
// Supported on: chrome_os
message AllowScreenWakeLocksProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowScreenWakeLocks = 2;
}

// Percentage by which to scale the screen dim delay if the user becomes active
// after dimming
//
// If PowerSmartDimEnabled is Disabled, then setting
// UserActivityScreenDimDelayScale specifies the percent that the screen dim
// delay scales when there's user activity while the screen dims or soon after
// the screen turns off. When the dim delay scales, the screen off, screen lock
// and idle delays adjust to maintain the same distances from the screen dim
// delay as originally set.
//
// Leaving the policy unset puts a default scale factor in use.
//
// Note: The scale factor must be 100% or more.
//
// Supported on: chrome_os
message UserActivityScreenDimDelayScaleProto {
  optional PolicyOptions policy_options = 1;
  optional int64 UserActivityScreenDimDelayScale = 2;
}

// Wait for initial user activity
//
// Setting the policy to Enabled means that power management delays and session
// length limits don't start until after the first user activity occurs in a
// session.
//
// Setting the policy to Disabled or leaving it unset means power management
// delays and the time limit begin immediately at session start.
//
// Supported on: chrome_os
message WaitForInitialUserActivityProto {
  optional PolicyOptions policy_options = 1;
  optional bool WaitForInitialUserActivity = 2;
}

// Power management settings when the user becomes idle
//
// Setting the policy controls the power management strategy when the user
// idles.
//
// There are 4 actions:
//
// * The screen dims if the user is idle for the time specified by ScreenDim.
//
// * The screen turns off if the user is idle for the time specified by
// ScreenOff.
//
// * A warning dialog appears if the user remains idle for the time specified by
// IdleWarning. It warns the user that the idle action will be taken and only
// appears if the idle action is to sign out or shut down.
//
// * The action specified by IdleAction is taken if the user is idle for the
// time specified by Idle.
//
// For each of the above actions, the delay should be specified in milliseconds
// and must be set to a value greater than zero to trigger the corresponding
// action. If the delay is set to zero, Google ChromeOS won't take the
// corresponding action.
//
// For each of the above delays, when the time is unset, a default value is
// used.
//
// ScreenDim values will be clamped to be less than or equal to ScreenOff.
// ScreenOff and IdleWarning will be clamped to be less than or equal to Idle.
//
// IdleAction can be one of 4 actions:
//
// * Suspend
//
// * Logout
//
// * Shutdown
//
// * DoNothing
//
// If the IdleAction is not set, Suspend is taken.
//
// Note: There are separate settings for AC power and battery.
//
// Value schema:
// {
//     "properties": {
//         "AC": {
//             "description": "Delays and actions to take when the device is
// idle and running on AC power",
//             "id": "PowerManagementDelays",
//             "properties": {
//                 "Delays": {
//                     "properties": {
//                         "Idle": {
//                             "description": "The length of time without user
// input after which the idle action is taken, in milliseconds",
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "IdleWarning": {
//                             "description": "The length of time without user
// input after which a warning dialog is shown, in milliseconds",
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "ScreenDim": {
//                             "description": "The length of time without user
// input after which the screen is dimmed, in milliseconds",
//                             "minimum": 0,
//                             "type": "integer"
//                         },
//                         "ScreenOff": {
//                             "description": "The length of time without user
// input after which the screen is turned off, in milliseconds",
//                             "minimum": 0,
//                             "type": "integer"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "IdleAction": {
//                     "description": "Action to take when the idle delay is
// reached",
//                     "enum": [
//                         "Suspend",
//                         "Logout",
//                         "Shutdown",
//                         "DoNothing"
//                     ],
//                     "type": "string"
//                 }
//             },
//             "type": "object"
//         },
//         "Battery": {
//             "$ref": "PowerManagementDelays",
//             "description": "Delays and actions to take when the device is
// idle and running on battery"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message PowerManagementIdleSettingsProto {
  optional PolicyOptions policy_options = 1;
  optional string PowerManagementIdleSettings = 2;
}

// Screen lock delays
//
// Setting the policy specifies the length of time in milliseconds without user
// input after which the screen locks when running on AC power or battery.
// Values are clamped to be less than the idle delay in
// PowerManagementIdleSettings.
//
// When set to zero, Google ChromeOS doesn't lock the screen when the user
// becomes idle. If unset, a default time is used.
//
// Recommendation: Lock the screen on idle by turning on screen locking on
// suspend and have Google ChromeOS suspend after the idle delay. Only use this
// policy when screen locking should occur a significant amount of time sooner
// than suspend or when you don't want suspend on idle.
//
// Value schema:
// {
//     "properties": {
//         "AC": {
//             "description": "The length of time without user input after which
// the screen is locked when running on AC power, in milliseconds",
//             "minimum": 0,
//             "type": "integer"
//         },
//         "Battery": {
//             "description": "The length of time without user input after which
// the screen is locked when running on battery, in milliseconds",
//             "minimum": 0,
//             "type": "integer"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message ScreenLockDelaysProto {
  optional PolicyOptions policy_options = 1;
  optional string ScreenLockDelays = 2;
}

// Set the Terms of Service for a device-local account
//
// Setting the policy means Google ChromeOS downloads the Terms of Service and
// presents them to users whenever a device-local account session starts. Users
// can only sign in to the session after accepting the Terms of Service.
//
// Leaving the policy unset means no Terms of Service appear.
//
// The policy should be set to a URL from which Google ChromeOS can download the
// Terms of Service. The Terms of Service must be plain text, served as MIME
// type text/plain. No markup is allowed.
//
// Supported on: chrome_os
message TermsOfServiceURLProto {
  optional PolicyOptions policy_options = 1;
  optional string TermsOfServiceURL = 2;
}

// Show accessibility options in system tray menu
//
// Setting the policy to True displays the accessibility options in the system
// tray menu. If you set the policy to False, the options don't appear in the
// menu.
//
// If you set the policy, users can't change it. If not set, accessibility
// options don't appear in the menu, but users can make them appear through the
// Settings page.
//
// If you turn on accessibility features by other means (for example, by key
// combination), accessibility options always appear in the system tray menu.
//
// Supported on: chrome_os
message ShowAccessibilityOptionsInSystemTrayMenuProto {
  optional PolicyOptions policy_options = 1;
  optional bool ShowAccessibilityOptionsInSystemTrayMenu = 2;
}

// Enable large cursor
//
// Setting the policy to True keeps the large cursor on. Setting the policy to
// False keeps the large cursor off.
//
// If you set the policy, users can't change the feature. If not set, the large
// cursor is off at first, but users can turn it on any time.
//
// Supported on: chrome_os
message LargeCursorEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LargeCursorEnabled = 2;
}

// Enable spoken feedback
//
// Setting the policy to True keeps spoken feedback on. Setting the policy to
// False keeps spoken feedback off.
//
// If you set the policy, users can't change it. If not set, spoken feedback is
// off at first, but users can turn it on any time.
//
// Supported on: chrome_os
message SpokenFeedbackEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SpokenFeedbackEnabled = 2;
}

// Enable high contrast mode
//
// Setting the policy to True keeps High-contrast mode on. Setting the policy to
// False keeps High-contrast mode off.
//
// If you set the policy, users can't change it. If not set, High-contrast mode
// is off, but users can turn it on any time.
//
// Supported on: chrome_os
message HighContrastEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool HighContrastEnabled = 2;
}

// Enable accessibility features shortcuts
//
// Enable accessibility features shortcuts.
//
// If this policy is set to true, accessibility features shortcuts will always
// be enabled.
//
// If this policy is set to false, accessibility features shortcuts will always
// be disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, accessibility features shortcuts will be
// enabled by default.
//
// Supported on: chrome_os
message AccessibilityShortcutsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AccessibilityShortcutsEnabled = 2;
}

// Enable on-screen keyboard
//
// Setting the policy to True keeps the on-screen keyboard on. Setting the
// policy to False keeps the on-screen keyboard off unless other factors turn it
// on. See the TouchVirtualKeyboardEnabled policy as an example of these
// factors.
//
// If you set the policy, users can't change it. If not set, the on-screen
// keyboard is off at first, but users can turn it on any time.
//
// Supported on: chrome_os
message VirtualKeyboardEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool VirtualKeyboardEnabled = 2;
}

// Enable or disable various features on the on-screen keyboard
//
// Enable or disable various features on the on-screen keyboard. This policy
// takes effect only when "VirtualKeyboardEnabled" policy is enabled.
//
// If one feature in this policy is set to True, it will be enabled on the on-
// screen keyboard.
//
// If one feature in this policy is set to False or left unset, it will be
// disabled on the on-screen keyboard.
//
// NOTE: this policy is only supported in PWA Kiosk mode.
//
// Value schema:
// {
//     "properties": {
//         "auto_complete_enabled": {
//             "description": "A boolean flag indicating if the on-screen
// keyboard can provide auto-complete.",
//             "type": "boolean"
//         },
//         "auto_correct_enabled": {
//             "description": "A boolean flag indicating if the on-screen
// keyboard can provide auto-correct.",
//             "type": "boolean"
//         },
//         "handwriting_enabled": {
//             "description": "A boolean flag indicating if the on-screen
// keyboard can provide input via handwriting recognition.",
//             "type": "boolean"
//         },
//         "spell_check_enabled": {
//             "description": "A boolean flag indicating if the on-screen
// keyboard can provide spell-check.",
//             "type": "boolean"
//         },
//         "voice_input_enabled": {
//             "description": "A boolean flag indicating if the on-screen
// keyboard can provide voice input.",
//             "type": "boolean"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message VirtualKeyboardFeaturesProto {
  optional PolicyOptions policy_options = 1;
  optional string VirtualKeyboardFeatures = 2;
}

// Enable sticky keys
//
// Setting the policy to True keeps sticky keys on. Setting the policy to False
// keeps sticky keys off.
//
// If you set the policy, users can't change it. If not set, sticky keys is off
// at first, but users can turn it on any time.
//
// Supported on: chrome_os
message StickyKeysEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool StickyKeysEnabled = 2;
}

// Enable select to speak
//
// Enable the select to speak accessibility feature.
//
// If this policy is set to true, the select to speak will always be enabled.
//
// If this policy is set to false, the select to speak will always be disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the select to speak is disabled initially but
// can be enabled by the user anytime.
//
// Supported on: chrome_os
message SelectToSpeakEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SelectToSpeakEnabled = 2;
}

// Enable the dictation accessibility feature
//
// Enable the dictation accessibility feature.
//
// If this policy is set to enabled, the dictation will always be enabled.
//
// If this policy is set to disabled, the dictation will always be disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the dictation is disabled initially but can be
// enabled by the user anytime.
//
// Supported on: chrome_os
message DictationEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DictationEnabled = 2;
}

// Enable the keyboard focus highlighting accessibility feature
//
// Enable the keyboard focus highlighting accessibility feature.
//
// This feature is responsible for highlighting the object that has the focus by
// the keyboard.
//
// If this policy is set to enabled, the keyboard focus highlighting will always
// be enabled.
//
// If this policy is set to disabled, the keyboard focus highlighting will
// always be disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the keyboard focus highlighting is disabled
// initially but can be enabled by the user anytime.
//
// Supported on: chrome_os
message KeyboardFocusHighlightEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool KeyboardFocusHighlightEnabled = 2;
}

// Enable the cursor highlight accessibility feature
//
// Enable the cursor highlight accessibility feature.
//
// This feature is responsible for highlighting the area that surrounds the
// mouse cursor while moving it.
//
// If this policy is set to enabled, the cursor highlight will always be
// enabled.
//
// If this policy is set to disabled, the cursor highlight will always be
// disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the cursor highlight is disabled initially but
// can be enabled by the user anytime.
//
// Supported on: chrome_os
message CursorHighlightEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CursorHighlightEnabled = 2;
}

// Enable the caret highlight accessibility feature
//
// Enable the caret highlight accessibility feature.
//
// This feature is responsible for highlighting the area that surrounds the
// caret while editing.
//
// If this policy is set to enabled, the caret highlight will always be enabled.
//
// If this policy is set to disabled, the caret highlight will always be
// disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the caret highlight is disabled initially but
// can be enabled by the user anytime.
//
// Supported on: chrome_os
message CaretHighlightEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CaretHighlightEnabled = 2;
}

// Enable the mono audio accessibility feature
//
// Enable the mono audio accessibility feature.
//
// This feature is responsible for outputing stereo audio which includes
// different left and right channels, so different ears get different sounds.
//
// If this policy is set to enabled, the mono audio will always be enabled.
//
// If this policy is set to disabled, the mono audio will always be disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the mono audio is disabled initially but can be
// enabled by the user anytime.
//
// Supported on: chrome_os
message MonoAudioEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool MonoAudioEnabled = 2;
}

// Enable the autoclick accessibility feature
//
// Enable the autoclick accessibility feature.
//
// This feature is responsible to click without physically pressing your mouse
// or touchpad, hover over the object you'd like to click.
//
// If this policy is set to enabled, the autoclick will always be enabled.
//
// If this policy is set to disabled, the autoclick will always be disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the autoclick is disabled initially but can be
// enabled by the user anytime.
//
// Supported on: chrome_os
message AutoclickEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AutoclickEnabled = 2;
}

// Media keys default to function keys
//
// Setting the policy to True makes the top row of keys on the keyboard act as
// function key commands. Pressing the Search key changes their behavior back to
// media keys.
//
// If set to False or not set, the keyboard defaults to producing media key
// commands. Pressing the Search key changes them to function keys.
//
// Supported on: chrome_os
message KeyboardDefaultToFunctionKeysProto {
  optional PolicyOptions policy_options = 1;
  optional bool KeyboardDefaultToFunctionKeys = 2;
}

// Set screen magnifier type
//
// Setting the policy to None turns the screen magnifier off.
//
// If you set the policy, users can't change it. If not set, the screen
// magnifier is off at first, but users can turn it on any time.
//
// Valid values:
//   0: Screen magnifier disabled
//   1: Full-screen magnifier enabled
//   2: Docked magnifier enabled
//
// Supported on: chrome_os
message ScreenMagnifierTypeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ScreenMagnifierType = 2;
}

// Switch the primary mouse button to the right button
//
// Switch the primary mouse button to the right button.
//
// If this policy is set to enabled, the right button of the mouse will always
// be the primary key.
//
// If this policy is set to disabled, the left button of the mouse will always
// be the primary key.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the left button of the mouse will be the
// primary key initially, but can be switched by the user anytime.
//
// Supported on: chrome_os
message PrimaryMouseButtonSwitchProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrimaryMouseButtonSwitch = 2;
}

// Enable the Shared Clipboard Feature
//
// Enable the Shared Clipboard feature which allows users to send text between
// Chrome Desktops and an Android device when Sync is enabled and the user is
// Signed-in.
//
// If this policy is set to true, the capability of sending text, cross device,
// for chrome user is enabled.
//
// If this policy is set to false, the capability of sending text, cross device,
// for chrome user is disabled.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the shared clipboard feature is enabled by
// default.
//
// It is up to the admins to set policies in all platforms they care about. It's
// recommended to set this policy to one value in all platforms.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SharedClipboardEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SharedClipboardEnabled = 2;
}

// Hide the web store from the New Tab Page and app launcher
//
// Hide the Chrome Web Store app and footer link from the New Tab Page and
// Google ChromeOS app launcher.
//
// When this policy is set to true, the icons are hidden.
//
// When this policy is set to false or is not configured, the icons are visible.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message HideWebStoreIconProto {
  optional PolicyOptions policy_options = 1;
  optional bool HideWebStoreIcon = 2;
}

// Set the restriction on the fetching of the Variations seed
//
// Add a parameter to the fetching of the Variations seed in Google Chrome.
//
// If specified, will add a query parameter called 'restrict' to the URL used to
// fetch the Variations seed. The value of the parameter will be the value
// specified in this policy.
//
// If not specified, will not modify the Variations seed URL.
//
// Supported on: android, fuchsia, linux, mac, win
message VariationsRestrictParameterProto {
  optional PolicyOptions policy_options = 1;
  optional string VariationsRestrictParameter = 2;
}

// Determine the availability of variations
//
// Configuring this policy allows to specify which variations are allowed to be
// applied in Google Chrome.
//
// Variations provide a means for offering modifications to Google Chrome
// without shipping a new version of the browser by selectively enabling or
// disabling already existing features. See
// https://support.google.com/chrome/a?p=Manage_the_Chrome_variations_framework
// for more information.
//
// Setting the VariationsEnabled (value 0), or leaving the policy not set allows
// all variations to be applied to the browser.
//
// Setting the CriticalFixesOnly (value 1), allows only variations considered
// critical security or stability fixes to be applied to Google Chrome.
//
// Setting the VariationsDisabled (value 2), prevent all variations from being
// applied to the browser. Please note that this mode can potentially prevent
// the Google Chrome developers from providing critical security fixes in a
// timely manner and is thus not recommended.
//
// Valid values:
//   0: Enable all variations
//   1: Enable variations concerning critical fixes only
//   2: Disable all variations
//
// Supported on: fuchsia, ios, linux, mac, win
message ChromeVariationsProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ChromeVariations = 2;
}

// Enable remote attestation for the user
//
// Setting the policy to Enabled lets users use the hardware on Google ChromeOS
// devices to remotely attest its identity to the privacy CA through the
// Enterprise Platform Keys API using
// chrome.enterprise.platformKeys.challengeUserKey().
//
// Setting the policy to Disabled or leaving it unset has calls to the API fail
// with an error code.
//
// Supported on: chrome_os
message AttestationEnabledForUserProto {
  optional PolicyOptions policy_options = 1;
  optional bool AttestationEnabledForUser = 2;
}

// Extensions allowed to to use the remote attestation API
//
// Setting the policy specifies the allowed extensions to use the Enterprise
// Platform Keys API functions for remote attestation. Extensions must be on
// this list to use the API.
//
// If an extension is not in the list, or the list is not set, the call to the
// API fails with an error code.
//
// Supported on: chrome_os
message AttestationExtensionAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AttestationExtensionAllowlist = 2;
}

// Extensions allowed to to use the remote attestation API
//
// This policy is deprecated, please use AttestationExtensionAllowlist instead.
//
// Setting the policy specifies the allowed extensions to use the Enterprise
// Platform Keys API function chrome.enterprise.platformKeys.challengeUserKey()
// for remote attestation. Extensions must be on this list to use the API.
//
// If an extension is not in the list, or the list is not set, the call to the
// API fails with an error code.
//
// Supported on:
message AttestationExtensionWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AttestationExtensionWhitelist = 2;
}

// Suppress the Google Chrome Frame turndown prompt
//
// Suppresses the turndown prompt that appears when a site is rendered by Google
// Chrome Frame.
//
// Supported on:
message SuppressChromeFrameTurndownPromptProto {
  optional PolicyOptions policy_options = 1;
  optional bool SuppressChromeFrameTurndownPrompt = 2;
}

// Enable creation of supervised users
//
// If set to false, supervised-user creation by this user will be disabled. Any
// existing supervised users will still be available.
//
// If set to true or not configured, supervised users can be created and managed
// by this user.
//
// Supported on: fuchsia
message SupervisedUserCreationEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SupervisedUserCreationEnabled = 2;
}

// Enable the supervised user content provider
//
// If true and the user is a supervised user then other Android apps can query
// the user's web restrictions through a content provider.
//
// If false or unset then the content provider returns no information.
//
// Supported on:
message SupervisedUserContentProviderEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SupervisedUserContentProviderEnabled = 2;
}

// Managed Bookmarks
//
// Setting the policy sets up a list of bookmarks where each one is a dictionary
// with the keys "name" and "url". These keys hold the bookmark's name and
// target. Admins can set up a subfolder by defining a bookmark without a "url"
// key, but with an additional "children" key. This key also has a list of
// bookmarks, some of which can also be folders. Chrome amends incomplete URLs
// as if they were submitted through the address bar. For example, "google.com"
// becomes "https://google.com/".
//
// Users can't change the folders the bookmarks are placed in (though they can
// hide it from the bookmark bar). The default folder name for managed bookmarks
// is "Managed bookmarks" but it can be changed by adding a new sub-dictionary
// to the policy with a single key named "toplevel_name" with the desired folder
// name as its value. Managed bookmarks are not synced to the user account and
// extensions can't modify them.
//
// Value schema:
// {
//     "items": {
//         "id": "BookmarkType",
//         "properties": {
//             "children": {
//                 "items": {
//                     "$ref": "BookmarkType"
//                 },
//                 "type": "array"
//             },
//             "name": {
//                 "type": "string"
//             },
//             "toplevel_name": {
//                 "type": "string"
//             },
//             "url": {
//                 "type": "string"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message ManagedBookmarksProto {
  optional PolicyOptions policy_options = 1;
  optional string ManagedBookmarks = 2;
}

// Enable the data compression proxy feature
//
// Setting the policy to Enabled allows the data compression proxy. Setting the
// policy to Disabled disallows the proxy.
//
// If you set the policy, users can't change it. If unset, users can choose to
// use the feature.
//
// Supported on:
message DataCompressionProxyEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DataCompressionProxyEnabled = 2;
}

// User avatar image
//
// This policy allows you to configure the avatar image representing the user on
// the login screen. The policy is set by specifying the URL from which Google
// ChromeOS can download the avatar image and a cryptographic hash used to
// verify the integrity of the download. The image must be in JPEG format, its
// size must not exceed 512kB. The URL must be accessible without any
// authentication.
//
// The avatar image is downloaded and cached. It will be re-downloaded whenever
// the URL or the hash changes.
//
// If this policy is set, Google ChromeOS will download and use the avatar
// image.
//
// If you set this policy, users cannot change or override it.
//
// If the policy is left not set, the user can choose the avatar image
// representing them on the login screen.
//
// Supported on: chrome_os
message UserAvatarImageProto {
  optional PolicyOptions policy_options = 1;
  optional string UserAvatarImage = 2;
}

// Wallpaper image
//
// If you set the policy, Google ChromeOS
//
// downloads and uses the wallpaper image you set for the user's desktop and
// sign-in screen background, and users can't change it. Specify the URL (that's
// accessible without authentication) which Google ChromeOS
//
// can download the wallpaper image from, as well as a cryptographic hash (in
// JPEG format with a file size up to 16 MB) to verify its integrity.
//
// If not set, users choose the image for the desktop and sign-in screen
// background.
//
// Supported on: chrome_os
message WallpaperImageProto {
  optional PolicyOptions policy_options = 1;
  optional string WallpaperImage = 2;
}

// Enable deprecated web platform features for a limited time
//
// Specify a list of deprecated web platform features to re-enable temporarily.
//
// This policy gives administrators the ability to re-enable deprecated web
// platform features for a limited time. Features are identified by a string tag
// and the features corresponding to the tags included in the list specified by
// this policy will get re-enabled.
//
// If this policy is left not set, or the list is empty or does not match one of
// the supported string tags, all deprecated web platform features will remain
// disabled.
//
// While the policy itself is supported on the above platforms, the feature it
// is enabling may be available on fewer platforms. Not all deprecated Web
// Platform features can be re-enabled. Only the ones explicitly listed below
// can be for a limited period of time, which is different per feature. The
// general format of the string tag will be
// [DeprecatedFeatureName]_EffectiveUntil[yyyymmdd]. As reference, you can find
// the intent behind the Web Platform feature changes at
// https://bit.ly/blinkintents.
//
// Valid values:
//   ExampleDeprecatedFeature_EffectiveUntil20080902: Enable
// ExampleDeprecatedFeature API through 2008/09/02
//
// Supported on:
message EnableDeprecatedWebPlatformFeaturesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList EnableDeprecatedWebPlatformFeatures = 2;
}

// Allow Smart Lock to be used
//
// If you enable this setting, users will be allowed to use Smart Lock if the
// requirements for the feature are satisfied.
//
// If you disable this setting, users will not be allowed to use Smart Lock.
//
// If this policy is left not set, the default is not allowed for enterprise-
// managed users and allowed for non-managed users.
//
// Supported on: chrome_os
message EasyUnlockAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool EasyUnlockAllowed = 2;
}

// Set the recommended locales for a managed session
//
// Setting the policy (as recommended only) moves recommended locales for a
// managed session to the top of the list, in the order in which they appear in
// the policy. The first recommended locale is preselected.
//
// If not set, the current UI locale is preselected.
//
// For more than one recommended locale, the assumption is that users want to
// choose among these locales. Locale and keyboard layout selection is prominent
// when starting a managed session. Otherwise, the assumption is that most users
// want the preselected locale. Locale and keyboard layout selection is less
// prominent when starting a managed session.
//
// If you set the policy and turn automatic sign-in on (see the
// DeviceLocalAccountAutoLoginId and DeviceLocalAccountAutoLoginDelay policies),
// the managed session uses the first recommended locale and the most popular
// matching keyboard layout.
//
// The preselected keyboard layout is always the most popular layout matching
// the preselected locale. Users can always choose any locale supported by
// Google ChromeOS for their session.
//
// Supported on: chrome_os
message SessionLocalesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SessionLocales = 2;
}

// Enable guest mode in browser
//
// If this policy is set to true or not configured, Google Chrome and Lacros
// will enable guest logins. Guest logins are Google Chrome profiles where all
// windows are in incognito mode.
//
// If this policy is set to false, Google Chrome and Lacros will not allow guest
// profiles to be started.
//
// Note: If this policy is not configured or set to true, but
// LacrosSecondaryProfilesAllowed is set to false, Lacros will not allow guest
// profiles to be started.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message BrowserGuestModeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserGuestModeEnabled = 2;
}

// Enforce browser guest mode
//
// Setting the policy to Enabled means Google Chrome enforces guest sessions and
// prevents profile sign-ins. Guest sign-ins are Google Chrome profiles where
// windows are in Incognito mode.
//
// Setting the policy to Disabled, leaving it unset, or disabling browser Guest
// mode (through BrowserGuestModeEnabled) allows the use of new and existing
// profiles.
//
// Supported on: fuchsia, linux, mac, win
message BrowserGuestModeEnforcedProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserGuestModeEnforced = 2;
}

// Enable add person in user manager
//
// If this policy is set to true or not configured, Google Chrome and Lacros
// will allow to add a new person from the user manager.
//
// If this policy is set to false, Google Chrome and Lacros will not allow
// adding a new person from the user manager.
//
// Note: If this policy is not configured or set to true, but
// LacrosSecondaryProfilesAllowed is set to false, Lacros will not allow adding
// a new person from the user manager.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message BrowserAddPersonEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserAddPersonEnabled = 2;
}

// Enable force sign in for Google Chrome
//
// This policy is deprecated, consider using BrowserSignin instead.
//
// If this policy is set to true, user has to sign in to Google Chrome with
// their profile before using the browser. And the default value of
// BrowserGuestModeEnabled will be set to false. Note that existing unsigned
// profiles will be locked and inaccessible after enabling this policy. For more
// information, see help center article.
//
// If this policy is set to false or not configured, user can use the browser
// without sign in to Google Chrome.
//
// Supported on: android, mac, win
message ForceBrowserSigninProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceBrowserSignin = 2;
}

// Browser sign in settings
//
// This policy controls the sign-in behavior of the browser. It allows you to
// specify if the user can sign in to Google Chrome with their account and use
// account related services like Google Chrome Sync.
//
// If the policy is set to "Disable browser sign-in" then the user cannot sign
// in to the browser and use account-based services. In this case browser-level
// features like Google Chrome Sync cannot be used and will be unavailable. On
// iOS, if the user was signed in and the policy is set to "Disabled" they will
// be signed out immediately. On other platforms, they will be signed out the
// next time they run Google Chrome. On all platforms, their local profile data
// like bookmarks, passwords etc. will be preserved and still usable. The user
// will still be able to sign into and use Google web services like Gmail.
//
// If the policy is set to "Enable browser sign-in," then the user is allowed to
// sign in to the browser. On all platforms except iOS, the user is
// automatically signed in to the browser when signed in to Google web services
// like Gmail. Being signed in to the browser means the user's account
// information will be kept by the browser. However, it does not mean that
// Google Chrome Sync will be turned on by default; the user must separately
// opt-in to use this feature. Enabling this policy will prevent the user from
// turning off the setting that allows browser sign-in. To control the
// availability of Google Chrome Sync, use the SyncDisabled policy.
//
// If the policy is set to "Force browser sign-in" the user is presented with an
// account selection dialog and has to choose and sign in to an account to use
// the browser. This ensures that for managed accounts the policies associated
// with the account are applied and enforced. The default value of
// BrowserGuestModeEnabled will be set to disabled. Note that existing unsigned
// profiles will be locked and inaccessible after enabling this policy. For more
// information, see help center article:
// https://support.google.com/chrome/a/answer/7572556 . This option is not
// supported on Linux, Android or iOS. It will fall back to "Enable browser
// sign-in" if used.
//
// If this policy is not set then the user can decide if they want to enable
// browser sign-in in the Google Chrome settings and use it as they see fit.
//
// Valid values:
//   0: Disable browser sign-in
//   1: Enable browser sign-in
//   2: Force users to sign-in to use the browser
//
// Supported on: android, fuchsia, ios, linux, mac, win
message BrowserSigninProto {
  optional PolicyOptions policy_options = 1;
  optional int64 BrowserSignin = 2;
}

// Minimum SSL version enabled
//
// Setting the policy to a valid value means Google Chrome won't use SSL/TLS
// versions less than the specified version. Unrecognized values are ignored.
//
// If this policy is not set, then Google Chrome will show an error for TLS 1.0
// and TLS 1.1, but the user will be able to bypass it.
//
// If this policy is set to "tls1.2", the user will not be able to bypass this
// error.
//
// Support for setting this policy to "tls1" or "tls1.1" was removed in version
// 91. Suppressing the TLS 1.0/1.1 warning is no longer supported.
//
// Valid values:
//   tls1: TLS 1.0
//   tls1.1: TLS 1.1
//   tls1.2: TLS 1.2
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SSLVersionMinProto {
  optional PolicyOptions policy_options = 1;
  optional string SSLVersionMin = 2;
}

// Minimum TLS version to fallback to
//
// Warning: The TLS version fallback will be removed from Google Chrome after
// version 52 (around September 2016) and this policy will stop working then.
//
// When a TLS handshake fails, Google Chrome would previously retry the
// connection with a lesser version of TLS in order to work around bugs in HTTPS
// servers. This setting configures the version at which this fallback process
// will stop. If a server performs version negotiation correctly (i.e. without
// breaking the connection) then this setting doesn't apply. Regardless, the
// resulting connection must still comply with SSLVersionMin.
//
// If this policy is not configured or if it is set to "tls1.2" then Google
// Chrome no longer performs this fallback. Note this does not disable support
// for older TLS versions, only whether Google Chrome will work around buggy
// servers which cannot negotiate versions correctly.
//
// Otherwise, if compatibility with a buggy server must be maintained, this
// policy may be set to "tls1.1". This is a stopgap measure and the server
// should be rapidly fixed.
//
// Valid values:
//   tls1.1: TLS 1.1
//   tls1.2: TLS 1.2
//
// Supported on:
message SSLVersionFallbackMinProto {
  optional PolicyOptions policy_options = 1;
  optional string SSLVersionFallbackMin = 2;
}

// Maximum SSL version enabled
//
// Warning: The max TLS version policy will be entirely removed from Google
// Chrome around version 75 (around June 2019).
//
// If this policy is not configured then Google Chrome uses the default maximum
// version.
//
// Otherwise it may be set to one of the following values: "tls1.2" or "tls1.3".
// When set, Google Chrome will not use SSL/TLS versions greater than the
// specified version. An unrecognized value will be ignored.
//
// Valid values:
//   tls1.2: TLS 1.2
//   tls1.3: TLS 1.3
//
// Supported on:
message SSLVersionMaxProto {
  optional PolicyOptions policy_options = 1;
  optional string SSLVersionMax = 2;
}

// CECPQ2 post-quantum key-agreement enabled for TLS
//
// If this policy is not configured, or is set to enabled, then Google Chrome
// will follow the default rollout process for CECPQ2, a post-quantum key-
// agreement algorithm in TLS.
//
// CECPQ2 results in larger TLS messages which, in very rare cases, can trigger
// bugs in some networking hardware. This policy can be set to False to disable
// CECPQ2 while networking issues are resolved.
//
// This policy is a temporary measure and will be removed in future versions of
// Google Chrome.
//
// Valid values:
//   True: Enable default CECPQ2 rollout process
//   False: Disable CECPQ2
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CECPQ2EnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CECPQ2Enabled = 2;
}

// Disable Certificate Transparency enforcement for a list of URLs
//
// Setting the policy turns off Certificate Transparency disclosure requirements
// for the hostnames in the specified URLs. While making it harder to detect
// misissued certificates, hosts can keep using certificates that otherwise
// wouldn't be trusted (because they weren't properly publicly disclosed).
//
// Leaving the policy unset means that if certificates requiring disclosure
// through Certificate Transparency aren't disclosed, then Google Chrome doesn't
// trust those certificates.
//
// A URL pattern follows this format (
// https://www.chromium.org/administrators/url-blocklist-filter-format ).
// However, because the validity of certificates for a given hostname is
// independent of the scheme, port, or path, Google Chrome only considers the
// hostname portion of the URL. Wildcard hosts aren't supported.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CertificateTransparencyEnforcementDisabledForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CertificateTransparencyEnforcementDisabledForUrls = 2;
}

// Disable Certificate Transparency enforcement for a list of
// subjectPublicKeyInfo hashes
//
// Setting the policy turns off enforcement of Certificate Transparency
// disclosure requirements for a list of subjectPublicKeyInfo hashes. Enterprise
// hosts can keep using certificates that otherwise wouldn't be trusted (because
// they weren't properly publicly disclosed). To turn off enforcement, the hash
// must meet one of these conditions:
//
// * It's of the server certificate's subjectPublicKeyInfo.
//
// * It's of a subjectPublicKeyInfo that appears in a Certificate Authority (CA)
// certificate in the certificate chain. That CA certificate is constrained
// through the X.509v3 nameConstraints extension, one or more directoryName
// nameConstraints are present in the permittedSubtrees, and the directoryName
// has an organizationName attribute.
//
// * It's of a subjectPublicKeyInfo that appears in a CA certificate in the
// certificate chain, the CA certificate has one or more organizationName
// attributes in the certificate Subject, and the server's certificate has the
// same number of organizationName attributes, in the same order, and with byte-
// for-byte identical values.
//
// Specify a subjectPublicKeyInfo hash by linking the hash algorithm name, a
// slash, and the Base64 encoding of that hash algorithm applied to the DER-
// encoded subjectPublicKeyInfo of the specified certificate. Base64 encoding
// format matches that of an SPKI Fingerprint. The only recognized hash
// algorithm is sha256; others are ignored.
//
// Leaving the policy unset means that if certificates requiring disclosure
// through Certificate Transparency aren't disclosed, then Google Chrome doesn't
// trust those certificates.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CertificateTransparencyEnforcementDisabledForCasProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CertificateTransparencyEnforcementDisabledForCas = 2;
}

// Disable Certificate Transparency enforcement for a list of Legacy Certificate
// Authorities
//
// Setting the policy turns off enforcement of Certificate Transparency
// disclosure requirements for a list of Legacy Certificate Authorities (CA) for
// certificate chains with a specified subjectPublicKeyInfo hash. Enterprise
// hosts can keep using certificates that otherwise wouldn't be trusted (because
// they weren't properly publicly disclosed). To turn off enforcement, the
// subjectPublicKeyInfo hash must appear in a CA certificate recognized as a
// Legacy CA. A Legacy CA is publicly trusted by one or more operating systems
// supported by Google Chrome, but not Android Open Source Project or Google
// ChromeOS.
//
// Specify a subjectPublicKeyInfo hash by linking the hash algorithm name, a
// slash and the Base64 encoding of that hash algorithm applied to the DER-
// encoded subjectPublicKeyInfo of the specified certificate. Base64 encoding
// format matches that of an SPKI Fingerprint. The only recognized hash
// algorithm is sha256; others are ignored.
//
// Leaving the policy unset means that if certificates requiring disclosure
// through Certificate Transparency aren't disclosed, then Google Chrome doesn't
// trust those certificates.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CertificateTransparencyEnforcementDisabledForLegacyCasProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CertificateTransparencyEnforcementDisabledForLegacyCas = 2;
}

// Enable RC4 cipher suites in TLS
//
// Warning: RC4 will be completely removed from Google Chrome after version 52
// (around September 2016) and this policy will stop working then.
//
// If the policy is not set, or is set to false, then RC4 cipher suites in TLS
// will not be enabled. Otherwise it may be set to true to retain compatibility
// with an outdated server. This is a stopgap measure and the server should be
// reconfigured.
//
// Supported on:
message RC4EnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool RC4Enabled = 2;
}

// Enable DHE cipher suites in TLS
//
// Warning: DHE will be completely removed from Google Chrome after version 57
// (around March 2017) and this policy will stop working then.
//
// If the policy is not set, or is set to false, then DHE cipher suites in TLS
// will not be enabled. Otherwise it may be set to true to enable DHE cipher
// suites and retain compatibility with an outdated server. This is a stopgap
// measure and the server should be reconfigured.
//
// Servers are encouraged to migrated to ECDHE cipher suites. If these are
// unavailable, ensure a cipher suite using RSA key exchange is enabled.
//
// Supported on:
message DHEEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DHEEnabled = 2;
}

// Enable Touch to Search
//
// Setting the policy to True or leaving it unset makes Touch to Search
// available to the user, and they can turn the feature on or off.
//
// Setting the policy to False turns Touch to Search off completely.
//
// Valid values:
//   True: Allow users to use Touch to Search
//   False: Prevent users from using Touch to Search
//
// Supported on: android
message ContextualSearchEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ContextualSearchEnabled = 2;
}

// Maximize the first browser window on first run
//
// Setting the policy to True means Chrome maximizes the first window shown on
// first run.
//
// Setting the policy to False or leaving it unset means that Chrome might
// maximize the first window, depending on the screen size.
//
// Supported on: chrome_os
message ForceMaximizeOnFirstRunProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceMaximizeOnFirstRun = 2;
}

// Allow proceeding from the SSL warning page
//
// Setting the policy to Enabled or leaving it unset lets users click through
// warning pages Google Chrome shows when users navigate to sites that have SSL
// errors.
//
// Setting the policy to Disabled prevent users from clicking through any
// warning pages.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SSLErrorOverrideAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SSLErrorOverrideAllowed = 2;
}

// Allow proceeding from the SSL warning page on specific origins
//
// If SSLErrorOverrideAllowed is Disabled, setting the policy lets you set a
// list of origin patterns that specify the sites where a user can click through
// warning pages Google Chrome shows when users navigate to sites that have SSL
// errors. Users will not be able to click through SSL warning pages on origins
// that are not on this list.
//
// If SSLErrorOverrideAllowed is Enabled or unset, this policy does nothing.
//
// Leaving the policy unset means SSLErrorOverrideAllowed applies for all sites.
//
// For detailed information on valid input patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy. This policy only matches based on
// origin, so any path in the URL pattern is ignored.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SSLErrorOverrideAllowedForOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SSLErrorOverrideAllowedForOrigins = 2;
}

// Allow origins to query for device attributes
//
// Setting the policy to allow some origins of force-installed web applications
// to get device attributes (e.g. serial number, hostname) by using Device
// Attributes API.
//
// Device Attributes API is a list of web APIs, please see
// https://wicg.github.io/WebApiDevice/device_attributes. They are only
// available to origins which correspond to force-installed web applications via
// WebAppInstallForceList or the one configured in the Kiosk session.
//
// Supported on: chrome_os
message DeviceAttributesAllowedForOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList DeviceAttributesAllowedForOrigins = 2;
}

// Allow QUIC protocol
//
// Setting the policy to Enabled or leaving it unset allows the use of QUIC
// protocol in Google Chrome.
//
// Setting the policy to Disabled disallows the use of QUIC protocol.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message QuicAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool QuicAllowed = 2;
}

// Key Permissions
//
// Setting the policy grants access to corporate keys to extensions or Android
// applications. Keys are designated for corporate usage only if they're
// generated using the chrome.enterprise.platformKeys API on a managed account.
// Users can't grant or withdraw access to corporate keys to or from extensions
// or Android applications.
//
// By default, an extension or an Android applications can't use a key
// designated for corporate usage, which is equivalent to setting
// allowCorporateKeyUsage to False for it. Only if allowCorporateKeyUsage is set
// to True for an extension or an Android application can it use any platform
// key marked for corporate usage to sign arbitrary data. Only grant this
// permission if the extension or the Android application is trusted to secure
// access to the key against attackers.
//
// Value schema:
// {
//     "additionalProperties": {
//         "properties": {
//             "allowCorporateKeyUsage": {
//                 "description": "If set to true, this extension can use all
// keys that are designated for corporate usage to sign arbitrary data. If set
// to false, it cannot access any such keys and the user cannot grant such
// permission either. As an exception, an extension can access such a key
// exactly once if the same extension generated that key.",
//                 "type": "boolean"
//             }
//         },
//         "type": "object"
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message KeyPermissionsProto {
  optional PolicyOptions policy_options = 1;
  optional string KeyPermissions = 2;
}

// Enable showing the welcome page on the first browser launch following OS
// upgrade
//
// If this policy is set to true or not configured, the browser will re-show the
// welcome page on the first launch following an OS upgrade.
//
// If this policy is set to false, the browser will not re-show the welcome page
// on the first launch following an OS upgrade.
//
// Supported on:
message WelcomePageOnOSUpgradeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WelcomePageOnOSUpgradeEnabled = 2;
}

// Use hardware acceleration when available
//
// Setting the policy to Enabled or leaving it unset turns on hardware
// acceleration, if available.
//
// Setting the policy to Disabled turns off hardware acceleration.
//
// Supported on: fuchsia, linux, mac, win
message HardwareAccelerationModeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool HardwareAccelerationModeEnabled = 2;
}

// Make Unified Desktop available and turn on by default
//
// Setting the policy to True turns on Unified Desktop, which allows
// applications to span multiple displays. Users can turn off Unified Desktop
// for individual displays.
//
// Setting the policy to False or leaving it unset turns off Unified Desktop,
// and users can't turn it on.
//
// Supported on: chrome_os
message UnifiedDesktopEnabledByDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional bool UnifiedDesktopEnabledByDefault = 2;
}

// Enable ARC
//
// Unless Ephemeral mode or multiple sign-in is on during the user's session,
// setting ArcEnabled to True turns ARC on for the user. Setting the policy to
// False or leaving it unset means enterprise users can't use ARC.
//
// Supported on: chrome_os
message ArcEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ArcEnabled = 2;
}

// Configure ARC
//
// Setting the policy specifies a set of policies to hand over to the ARC
// runtime. Admins can use it to select the Android apps that autoinstall. Enter
// value in valid JSON format.
//
// To pin apps to the launcher, see PinnedLauncherApps.
//
// Supported on: chrome_os
message ArcPolicyProto {
  optional PolicyOptions policy_options = 1;
  optional string ArcPolicy = 2;
}

// Allow Web Kiosk to open more than one browser window on any screen
//
// Setting the policy to Enabled means a Kiosk Web App can open another browser
// window which can be placed on the same screen or on a different screen. To
// open a new window, Web App should call window.open(url, target,
// windowFeatures) JavaScript function.
//
// Setting the policy to Disabled or leaving it unset means a Kiosk Web App can
// use only the main browser window and cannot open a new window. Calling any
// Javascript functions for opening a new window will be ignored.
//
// Valid values:
//   True: Allow a Kiosk Web App to open another browser window
//   False: Prohibit a Kiosk Web App from opening another browser window
//
// Supported on: chrome_os
message NewWindowsInKioskAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool NewWindowsInKioskAllowed = 2;
}

// Suppress the unsupported OS warning
//
// Setting the policy to Enabled suppresses the warning that appears when Google
// Chrome is running on an unsupported computer or operating system.
//
// Setting the policy to Disabled or leaving it unset means the warnings appear
// on unsupported systems.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SuppressUnsupportedOSWarningProto {
  optional PolicyOptions policy_options = 1;
  optional bool SuppressUnsupportedOSWarning = 2;
}

// Enable ending processes in Task Manager
//
// Setting the policy to Disabled prevents users from ending processes in the
// Task Manager.
//
// Setting the policy to Enabled or leaving it unset lets users end processes in
// the Task Manager.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message TaskManagerEndProcessEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool TaskManagerEndProcessEnabled = 2;
}

// Permit locking the screen
//
// Setting the policy to Enabled or leaving it unset lets users who authenticate
// with a password lock the screen.
//
// Setting the policy to Disabled means users can't lock the screen. (They can
// only sign out from the user session.)
//
// Supported on: chrome_os
message AllowScreenLockProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowScreenLock = 2;
}

// Set certificate availability for ARC-apps
//
// Setting the policy to CopyCaCerts makes all ONC-installed CA certificates
// with Web TrustBit available for ARC-apps.
//
// Setting to None or leaving it unset makes ChromeOS certificates unavailable
// for ARC-apps.
//
// Valid values:
//   0: Disable usage of Google ChromeOS certificates to ARC-apps
//   1: Enable Google ChromeOS CA certificates to ARC-apps
//
// Supported on: chrome_os
message ArcCertificatesSyncModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ArcCertificatesSyncMode = 2;
}

// Define domains allowed to access Google Workspace
//
// Setting the policy turns on Chrome's restricted sign-in feature in Google
// Workspace and prevents users from changing this setting. Users can only
// access Google tools using accounts from the specified domains (to allow gmail
// or googlemail accounts, add consumer_accounts to the list of domains). This
// setting prevents users from signing in and adding a Secondary Account on a
// managed device that requires Google authentication, if that account doesn't
// belong to one of the explicitly allowed domains.
//
// Leaving this setting empty or unset means users can access Google Workspace
// with any account.
//
// Users cannot change or override this setting.
//
// Note: This policy causes the X-GoogApps-Allowed-Domains header to be appended
// to all HTTP and HTTPS requests to all google.com domains, as described in
// https://support.google.com/a/answer/1668854.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message AllowedDomainsForAppsProto {
  optional PolicyOptions policy_options = 1;
  optional string AllowedDomainsForApps = 2;
}

// Enable PAC URL stripping (for https://)
//
// Strips privacy and security sensitive parts of https:// URLs before passing
// them on to PAC scripts (Proxy Auto Config) used by Google Chrome during proxy
// resolution.
//
// When True, the security feature is enabled, and https:// URLs are
// stripped before submitting them to a PAC script. In this manner the PAC
// script is not able to view data that is ordinarily protected by an
// encrypted channel (such as the URL's path and query).
//
// When False, the security feature is disabled, and PAC scripts are
// implicitly granted the ability to view all components of an https://
// URL. This applies to all PAC scripts regardless of origin (including
// those fetched over an insecure transport, or discovered insecurely
// through WPAD).
//
// This defaults to True (security feature enabled).
//
// It is recommended that this be set to True. The only reason to set it to
// False is if it causes a compatibility problem with existing PAC scripts.
//
// The policy will be removed in M75.
//
// Supported on:
message PacHttpsUrlStrippingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PacHttpsUrlStrippingEnabled = 2;
}

// Enable Google Cast
//
// Setting the policy to Enabled or leaving it unset turns on Google Cast, which
// users can launch from the app menu, page context menus, media controls on
// Cast-enabled websites, and (if shown) the Cast toolbar icon.
//
// Setting the policy to Disabled turns off Google Cast.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message EnableMediaRouterProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableMediaRouter = 2;
}

// Show the Google Cast toolbar icon
//
// Setting the policy to Enabled displays the Cast toolbar icon on the toolbar
// or the overflow menu, and users can't remove it.
//
// Setting the policy to Disabled or leaving it unset lets users pin or remove
// the icon through its contextual menu.
//
// If the policy EnableMediaRouter is set to Disabled, then this policy's value
// has no effect, and the toolbar icon doesn't appear.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ShowCastIconInToolbarProto {
  optional PolicyOptions policy_options = 1;
  optional bool ShowCastIconInToolbar = 2;
}

// Allow Google Cast to connect to Cast devices on all IP addresses.
//
// Unless EnableMediaRouter is set to Disabled, setting
// MediaRouterCastAllowAllIPs to Enabled connects Google Cast to Cast devices on
// all IP addresses, not just RFC1918/RFC4193 private addresses.
//
// Setting the policy to Disabled connects Google Cast to Cast devices only on
// RFC1918/RFC4193.
//
// Leaving the policy unset connects Google Cast to Cast devices only on
// RFC1918/RFC4193, unless the CastAllowAllIPs feature is turned on.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message MediaRouterCastAllowAllIPsProto {
  optional PolicyOptions policy_options = 1;
  optional bool MediaRouterCastAllowAllIPs = 2;
}

// Enable Android Backup Service
//
// This policy was removed in Google ChromeOS 68 and replaced by
// ArcBackupRestoreServiceEnabled.
//
// Supported on:
message ArcBackupRestoreEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ArcBackupRestoreEnabled = 2;
}

// Enable Android Google Location Service
//
// This policy was removed in Google ChromeOS 68 and replaced by
// ArcGoogleLocationServicesEnabled.
//
// Supported on:
message ArcLocationServiceEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ArcLocationServiceEnabled = 2;
}

// Show content suggestions on the New Tab page
//
// Setting the policy to True or leaving it unset displays autogenerated content
// suggestions on the New Tab page, based on the user's browsing history,
// interests, or location.
//
// Setting the policy to False prevents autogenerated content suggestions from
// appearing on the New Tab page.
//
// Valid values:
//   True: Show content suggestions on the New Tab page
//   False: Do not show content suggestions on the New Tab page
//
// Supported on: android, ios
message NTPContentSuggestionsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NTPContentSuggestionsEnabled = 2;
}

// Allow users to customize the background on the New Tab page
//
// If the policy is set to false, the New Tab page won't allow users to
// customize the background. Any existing custom background will be permanently
// removed even if the policy is set to true later.
//
// If the policy is set to true or unset, users can customize the background on
// the New Tab page.
//
// Valid values:
//   True: Users can customize the New Tab page background
//   False: Users can not customize the New Tab page background
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message NTPCustomBackgroundEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NTPCustomBackgroundEnabled = 2;
}

// Show cards on the New Tab Page
//
// This policy controls the visibility of cards on the New Tab Page. Cards
// surface entry points to launch common user journeys based on the user's
// browsing behavior.
//
// If the policy is set to Enabled, the New Tab Page will show cards if content
// is available.
//
// If the policy is set to Disabled, the New Tab Page won't show cards.
//
// If the policy is not set, the user can control the card visibility. The
// default is visible.
//
// Valid values:
//   True: New Tab Page will show cards if content is available
//   False: New Tab Page will not show cards
//   None: New Tab Page will show cards if content is available, but allow the
// user to change this setting
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message NTPCardsVisibleProto {
  optional PolicyOptions policy_options = 1;
  optional bool NTPCardsVisible = 2;
}

// Show the middle slot announcement on the New Tab Page
//
// This policy controls the visibility of the middle slot announcement on the
// New Tab Page.
//
// If the policy is set to Enabled, the New Tab Page will show the middle slot
// announcement if it is available.
//
// If the policy is set to Disabled, the New Tab Page will not show the middle
// slot announcement even if it is available.
//
// Valid values:
//   True: New Tab Page will show the middle slot announcement if it is
// available
//   False: New Tab Page will not show the middle slot announcement even if it
// is available
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message NTPMiddleSlotAnnouncementVisibleProto {
  optional PolicyOptions policy_options = 1;
  optional bool NTPMiddleSlotAnnouncementVisible = 2;
}

// Restrict the range of local UDP ports used by WebRTC
//
// If the policy is set, the UDP port range used by WebRTC is restricted to the
// specified port interval (endpoints included).
//
// If the policy is not set, or if it is set to the empty string or an invalid
// port range, WebRTC is allowed to use any available local UDP port.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message WebRtcUdpPortRangeProto {
  optional PolicyOptions policy_options = 1;
  optional string WebRtcUdpPortRange = 2;
}

// URLs for which local IPs are exposed in WebRTC ICE candidates
//
// Patterns in this list will be matched against the security origin of the
// requesting URL.
// If a match is found or chrome://flags/#enable-webrtc-hide-local-ips-with-mdns
// is Disabled, the local IP addresses are shown in WebRTC ICE candidates.
// Otherwise, local IP addresses are concealed with mDNS hostnames.
// Please note that this policy weakens the protection of local IPs if needed by
// administrators.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebRtcLocalIpsAllowedUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebRtcLocalIpsAllowedUrls = 2;
}

// Enable component updates in Google Chrome
//
// Enables component updates for all components in Google Chrome when not set or
// set to enabled.
//
// If set to disabled, updates to components are disabled. However, some
// components are exempt from this policy: updates to any component that does
// not contain executable code and is critical for the security of the browser
// will not be disabled.
// Examples of such components include the certificate revocation lists and
// subresource filters.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message ComponentUpdatesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ComponentUpdatesEnabled = 2;
}

// Native Printing
//
// Setting the policy lets administrators set up a list of printers for their
// users. Printer selection occurs the first time users try to print.
//
// Using the policy:
//
// * Customize free-form display_name and description for ease of printer
// selection.
//
// * Help users identify printers using manufacturer and model.
//
// * uri should be an address reachable from a client computer, including the
// scheme, port, and queue.
//
// * Optionally provide uuid to help deduplicate zeroconf printers.
//
// * Either use the model name for effective_model or set autoconf to True.
// Printers with both or no properties get ignored.
//
// PPDs are downloaded after the printer is used, and frequently used PPDs are
// cached. This policy doesn't affect whether users can configure printers on
// individual devices.
//
// Note: For Microsoft® Active Directory® managed devices, this policy supports
// expansion of ${MACHINE_NAME[,pos[,count]]} to the Microsoft® Active
// Directory® machine name or a substring of it. For example, if the machine
// name is CHROMEBOOK, then ${MACHINE_NAME,6,4} gets replaced by the 4
// characters starting after the 6th position, in other words, BOOK. The
// position is zero-based.
//
// This policy is deprecated, please use Printers instead.
//
// Supported on:
message NativePrintersProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativePrinters = 2;
}

// Configures a list of printers
//
// Setting the policy lets administrators set up a list of printers for their
// users. Printer selection occurs the first time users try to print.
//
// Using the policy:
//
// * Customize free-form display_name and description for ease of printer
// selection.
//
// * Help users identify printers using manufacturer and model.
//
// * uri should be an address reachable from a client computer, including the
// scheme, port, and queue.
//
// * Optionally provide uuid to help deduplicate zeroconf printers.
//
// * Either use the model name for effective_model or set autoconf to True.
// Printers with both or no properties get ignored.
//
// PPDs are downloaded after the printer is used, and frequently used PPDs are
// cached. This policy doesn't affect whether users can configure printers on
// individual devices.
//
// Note: For Microsoft® Active Directory® managed devices, this policy supports
// expansion of ${MACHINE_NAME[,pos[,count]]} to the Microsoft® Active
// Directory® machine name or a substring of it. For example, if the machine
// name is CHROMEBOOK, then ${MACHINE_NAME,6,4} gets replaced by the 4
// characters starting after the 6th position, in other words, BOOK. The
// position is zero-based.
//
// Supported on: chrome_os
message PrintersProto {
  optional PolicyOptions policy_options = 1;
  optional StringList Printers = 2;
}

// Enterprise printer configuration file
//
// Setting this policy configure enterprise printers. Its format matches the
// NativePrinters dictionary, with an additional required "id" or "guid" field
// for each printer for allow listing or deny listing. The file size can't
// exceed 5MB and is in JSON format. A file with about 21,000 printers encodes
// as a 5MB file. The cryptographic hash helps verify download integrity. The
// file is downloaded, cached, and redownloaded when the URL or the hash
// changes. Google ChromeOS downloads the file for printer configurations and
// makes printers available along with NativePrintersBulkAccessMode,
// NativePrintersBulkWhitelist, and NativePrintersBulkBlacklist.
//
// This policy has no effect on whether users can configure printers on
// individual devices. It is intended to be supplementary to the configuration
// of printers by individual users.
//
// If you set the policy, users can't change it.
//
// This policy is deprecated, please use PrintersBulkConfiguration instead.
//
// Supported on:
message NativePrintersBulkConfigurationProto {
  optional PolicyOptions policy_options = 1;
  optional string NativePrintersBulkConfiguration = 2;
}

// Enterprise printer configuration file
//
// Setting this policy configure enterprise printers. Its format matches the
// Printers dictionary, with an additional required "id" or "guid" field for
// each printer for allow listing or deny listing. The file size can't exceed
// 5MB and is in JSON format. A file with about 21,000 printers encodes as a 5MB
// file. The cryptographic hash helps verify download integrity. The file is
// downloaded, cached, and redownloaded when the URL or the hash changes. Google
// ChromeOS downloads the file for printer configurations and makes printers
// available along with PrintersBulkAccessMode, PrintersBulkAllowlist, and
// PrintersBulkBlocklist.
//
// This policy has no effect on whether users can configure printers on
// individual devices. It is intended to be supplementary to the configuration
// of printers by individual users.
//
// If you set the policy, users can't change it.
//
// Supported on: chrome_os
message PrintersBulkConfigurationProto {
  optional PolicyOptions policy_options = 1;
  optional string PrintersBulkConfiguration = 2;
}

// Printer configuration access policy.
//
// Setting the policy designates which access policy applies to bulk printer
// configuration, controlling which printers from
// NativePrintersBulkConfiguration are available for users.
//
// * If BlacklistRestriction (value 0) is selected, NativePrintersBulkBlacklist
// restricts access to the specified printers
//
// * If WhitelistPrintersOnly is selected, NativePrintersBulkWhitelist (value 1)
// designates only those printers which are selectable
//
// * AllowAll (Value 2) displays all printers
//
// Leaving the policy unset puts AllowAll in use.
//
// This policy is deprecated, please use PrintersBulkAccessMode instead.
//
// Valid values:
//   0: All printers are shown except those in the blacklist.
//   1: Only printers in the whitelist are shown to users
//   2: Allow all printers from the configuration file.
//
// Supported on:
message NativePrintersBulkAccessModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 NativePrintersBulkAccessMode = 2;
}

// Printer configuration access policy.
//
// Setting the policy designates which access policy applies to bulk printer
// configuration, controlling which printers from PrintersBulkConfiguration are
// available for users.
//
// * BlocklistRestriction (value 0) uses PrintersBulkBlocklist to restrict
// access to the specified printers
//
// * AllowlistPrintersOnly (value 1) uses PrintersBulkAllowlist to designate
// only those printers which are selectable
//
// * AllowAll (value 2) displays all printers
//
// Leaving the policy unset puts AllowAll in use.
//
// Valid values:
//   0: All printers are shown except those in the blocklist.
//   1: Only printers in the allowlist are shown to users
//   2: Allow all printers from the configuration file.
//
// Supported on: chrome_os
message PrintersBulkAccessModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PrintersBulkAccessMode = 2;
}

// Disabled enterprise printers
//
// If BlacklistRestriction is chosen for NativePrintersBulkAccessMode, then
// setting NativePrintersBulkBlacklist specifies which printers users can't use.
// All printers are provided to the user, except for the IDs listed in this
// policy. The IDs must correspond to the "id" or "guid" fields in the file
// specified in NativePrintersBulkConfiguration.
//
// This policy is deprecated, please use PrintersBulkBlocklist instead.
//
// Supported on:
message NativePrintersBulkBlacklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativePrintersBulkBlacklist = 2;
}

// Disabled enterprise printers
//
// If BlocklistRestriction is chosen for PrintersBulkAccessMode, then setting
// PrintersBulkBlocklist specifies which printers users can't use. All printers
// are provided to the user, except for the IDs listed in this policy. The IDs
// must correspond to the "id" or "guid" fields in the file specified in
// PrintersBulkConfiguration.
//
// Supported on: chrome_os
message PrintersBulkBlocklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PrintersBulkBlocklist = 2;
}

// Enabled enterprise printers
//
// If WhitelistPrintersOnly is chosen for NativePrintersBulkAccessMode, then
// setting NativePrintersBulkWhitelist specifies which printers users can use.
// Only the printers with IDs matching the values in this policy are available
// to the user. The IDs must correspond to the "id" or "guid" fields in the file
// specified in NativePrintersBulkConfiguration.
//
// This policy is deprecated, please use PrintersBulkAllowlist instead.
//
// Supported on:
message NativePrintersBulkWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NativePrintersBulkWhitelist = 2;
}

// Enabled enterprise printers
//
// If AllowlistPrintersOnly is chosen for PrintersBulkAccessMode, then setting
// PRINTERS_BULK_ALLOWLIST specifies which printers users can use. Only the
// printers with IDs matching the values in this policy are available to the
// user. The IDs must correspond to the "id" or "guid" fields in the file
// specified in PrintersBulkConfiguration.
//
// Supported on: chrome_os
message PrintersBulkAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PrintersBulkAllowlist = 2;
}

// Configure allowed quick unlock modes
//
// Setting the policy controls which quick unlock modes can unlock the lock
// screen.
//
// To allow:
//
// * Every quick unlock mode, use ["all"] (includes modes added in the future).
//
// * Only PIN unlock, use ["PIN"].
//
// * PIN and fingerprint, use ["PIN", "FINGERPRINT"].
//
// If the policy is unset or set to an empty list, no quick unlock modes are
// available for managed devices.
//
// Valid values:
//   all: All
//   PIN: PIN
//   FINGERPRINT: Fingerprint
//
// Supported on: chrome_os
message QuickUnlockModeAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList QuickUnlockModeAllowlist = 2;
}

// Configure allowed quick unlock modes
//
// Setting the policy controls which quick unlock modes can unlock the lock
// screen.
//
// To allow:
//
// * Every quick unlock mode, use ["all"] (includes modes added in the future).
//
// * Only PIN unlock, use ["PIN"].
//
// * PIN and fingerprint, use ["PIN", "FINGERPRINT"].
//
// If the policy is unset or set to an empty list, no quick unlock modes are
// available for managed devices.
//
// This policy is deprecated, please use QuickUnlockModeAllowlist instead
//
// Valid values:
//   all: All
//   PIN: PIN
//   FINGERPRINT: Fingerprint
//
// Supported on:
message QuickUnlockModeWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList QuickUnlockModeWhitelist = 2;
}

// Set how often user has to enter password to use quick unlock
//
// Setting the policy controls how often the lock screen requests the password
// for quick unlock. Each time the lock screen appears, if the last password
// entry occurred before the time window specified by the value chosen, quick
// unlock won't be available. If users stay on the lock screen past this amount
// of time, a password is requested next time they enter the wrong code or re-
// enter the lock screen, whichever comes first.
//
// Leaving the policy unset means users using quick unlock enter their password
// on the lock screen daily.
//
// Valid values:
//   0: Password entry is required every six hours
//   1: Password entry is required every twelve hours
//   2: Password entry is required every two days (48 hours)
//   3: Password entry is required every week (168 hours)
//
// Supported on: chrome_os
message QuickUnlockTimeoutProto {
  optional PolicyOptions policy_options = 1;
  optional int64 QuickUnlockTimeout = 2;
}

// Configure allowed WebAuthn factors
//
// Setting the policy controls which WebAuthn factors can be used.
//
// To allow:
//
// * Every WebAuthn factor, use ["all"] (includes factors added in the future).
//
// * Only PIN, use ["PIN"].
//
// * PIN and fingerprint, use ["PIN", "FINGERPRINT"].
//
// If the policy is unset or set to an empty list, no WebAuthn factors are
// available for managed devices.
//
// Valid values:
//   all: All
//   PIN: PIN
//   FINGERPRINT: Fingerprint
//
// Supported on: chrome_os
message WebAuthnFactorsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WebAuthnFactors = 2;
}

// Set the minimum length of the lock screen PIN
//
// Setting the policy enforces the minimum PIN length chosen. (Values below 1
// are rounded up to the minimum of 1.)
//
// Leaving the policy unset enforces a minimal PIN length of 6 digits, the
// recommended minimum.
//
// Supported on: chrome_os
message PinUnlockMinimumLengthProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PinUnlockMinimumLength = 2;
}

// Set the maximum length of the lock screen PIN
//
// Setting the policy means the configured maximum PIN length is enforced. A
// value of 0 or less means the user may set a PIN of any length. If the value
// is less than PinUnlockMinimumLength but greater than 0, the maximum length is
// set to the minimum length.
//
// Leaving the policy unset means no maximum length is enforced.
//
// Supported on: chrome_os
message PinUnlockMaximumLengthProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PinUnlockMaximumLength = 2;
}

// Enable users to set weak PINs for the lock screen PIN
//
// Setting the policy to Enabled allows weak PINs. Some characteristics of weak
// PINs: only one digit (1111), digits increase by 1 (1234), digits decrease by
// 1 (4321), and common PINs. Setting the policy to Disabled means users can't
// set weak, easy-to-guess PINs.
//
// By default, users get a warning, not an error, for a weak PIN.
//
// Supported on: chrome_os
message PinUnlockWeakPinsAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool PinUnlockWeakPinsAllowed = 2;
}

// Allow SMS Messages to be synced from phone to Chromebook.
//
// Setting the policy to Enabled lets users set up their devices to sync their
// text messages to Chromebooks. Users must explicitly opt in to this feature by
// completing a setup flow. On completion, users can send and receive texts on
// their Chromebooks.
//
// Setting the policy to Disabled means users can't set up text syncing.
//
// Leaving the policy unset means that by default, the feature isn't allowed for
// managed users but is allowed for other users.
//
// Supported on: chrome_os
message SmsMessagesAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SmsMessagesAllowed = 2;
}

// Allow Wi-Fi network configurations to be synced across Google ChromeOS
// devices and a connected Android phone.
//
// If this setting is enabled, users will be allowed to sync Wi-Fi network
// configurations between their Google ChromeOS device(s) and a connected
// Android phone. Before Wi-Fi network configurations can sync, users must
// explicitly opt in to this feature by completing a setup flow.
//
// If this setting is disabled, users will not be allowed to sync Wi-Fi network
// configurations.
//
// This feature depends on the wifiConfigurations datatype in Chrome Sync being
// enabled. If wifiConfigurations is disabled in the SyncTypesListDisabled
// policy, or Chrome Sync is disabled in the SyncDisabled policy this feature
// will not be enabled.
//
// If this policy is left not set, the default is not allowed for managed users.
//
// Supported on: chrome_os
message WifiSyncAndroidAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool WifiSyncAndroidAllowed = 2;
}

// Allow Smart Lock Signin to be used.
//
// If this setting is enabled, users will be allowed to sign into their account
// with Smart Lock. This is more permissive than usual Smart Lock behavior which
// only allows users to unlock their screen.
//
// If this setting is disabled, users will not be allowed to use Smart Lock
// Signin.
//
// If this policy is left not set, the default is not allowed for enterprise-
// managed users and allowed for non-managed users.
//
// Supported on: chrome_os
message SmartLockSigninAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SmartLockSigninAllowed = 2;
}

// Allow Instant Tethering to be used.
//
// If this setting is enabled, users will be allowed to use Instant Tethering,
// which allows their Google phone to share its mobile data with their device.
//
// If this setting is disabled, users will not be allowed to use Instant
// Tethering.
//
// If this policy is left not set, the default is not allowed for enterprise-
// managed users and allowed for non-managed users.
//
// Supported on: chrome_os
message InstantTetheringAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool InstantTetheringAllowed = 2;
}

// Allow Phone Hub to be enabled.
//
// If this setting is enabled, users will be allowed to opt in to Phone Hub,
// which allows them to interact with their phone on a ChromeOS device.
//
// If this setting is disabled, users will not be allowed to opt in to Phone
// Hub.
//
// If this policy is left not set, the default is not allowed for enterprise-
// managed users and allowed for non-managed users.
//
// Supported on: chrome_os
message PhoneHubAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool PhoneHubAllowed = 2;
}

// Allow recent photos and videos taken on the phone to be accessed via Phone
// Hub.
//
// If this setting is enabled, users who have already opted in to Phone Hub will
// be able to view and download recent photos and videos taken on their phone on
// ChromeOS.
//
// If this setting is disabled, users will not be allowed to use this feature.
// If the PhoneHubAllowed policy is disabled, users also will not be allowed to
// use this feature.
//
// If this policy is left not set, the default is allowed for both enterprise-
// managed users and non-managed users.
//
// Valid values:
//   True: Allows users who have opted in to Phone Hub to access recent photos
// and videos taken on their phone
//   False: Disallows users who have opted in to Phone Hub to access recent
// photos and videos taken on their phone
//
// Supported on: chrome_os
message PhoneHubCameraRollAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool PhoneHubCameraRollAllowed = 2;
}

// Allow Phone Hub notifications to be enabled.
//
// If this setting is enabled, users who have already opted in to Phone Hub,
// will be able to send/receive their phone's notifications on ChromeOS.
//
// If this setting is disabled, users will not be allowed to use this feature.
// If the PhoneHubAllowed policy is disabled, users also will not be allowed to
// use this feature.
//
// If this policy is left not set, the default is allowed for both enterprise-
// managed users and non-managed users.
//
// Supported on: chrome_os
message PhoneHubNotificationsAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool PhoneHubNotificationsAllowed = 2;
}

// Allow Phone Hub task continuation to be enabled.
//
// If this setting is enabled, users who have already opted in to Phone Hub,
// will be able to continue tasks such as viewing their phone's webpages on
// ChromeOS.
//
// If this setting is disabled, users will not be allowed to use this feature.
// If the PhoneHubAllowed policy is disabled, users also will not be allowed to
// use this feature.
//
// If this policy is left not set, the default is allowed for both enterprise-
// managed users and non-managed users.
//
// Supported on: chrome_os
message PhoneHubTaskContinuationAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool PhoneHubTaskContinuationAllowed = 2;
}

// Allow Eche to be enabled.
//
// If this setting is enabled, users will be able to launch the Eche
// application, for example by clicking on a Phone Hub notification.
//
// If this setting is disabled, users will not be able to launch the Eche
// application.
//
// If this policy is left not set, the default is allowed for both enterprise-
// managed users and non-managed users.
//
// Valid values:
//   True: Allows users to click on Phone Hub notification to launch Eche
// application.
//   False: Disallows users to click on Phone Hub notification to launch Eche
// application.
//
// Supported on: chrome_os
message EcheAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool EcheAllowed = 2;
}

// Allow Nearby Share to be enabled.
//
// If this setting is enabled, users will be allowed to opt in to Nearby Share,
// which allows them to send and receive files from people closeby.
//
// If this setting is disabled, users will not be allowed to opt in to Nearby
// Share.
//
// If this policy is left not set, the default is not allowed for enterprise-
// managed users and allowed for non-managed users.
//
// Supported on: chrome_os
message NearbyShareAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool NearbyShareAllowed = 2;
}

// Allow queries to a Google time service
//
// Setting the policy to Enabled or leaving it unset means Google Chrome send
// occasional queries to a Google server to retrieve an accurate timestamp.
//
// Setting the policy to Disabled stops Google Chrome from sending these
// queries.
//
// Valid values:
//   True: Allow queries to a Google server to retrieve an accurate timestamp
//   False: Do not allow queries to Google servers to retrieve timestamps
//
// Supported on: fuchsia, linux, mac, win
message BrowserNetworkTimeQueriesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserNetworkTimeQueriesEnabled = 2;
}

// Use System Default Printer as Default
//
// Setting the policy to Enabled means Google Chrome uses the OS default printer
// as the default destination for print preview.
//
// Setting the policy to Disabled or leaving it unset means Google Chrome uses
// the most recently used printer as the default destination for print preview.
//
// Valid values:
//   True: Use the system default printer as the default choice in Print Preview
//   False: Use the most recently used printer as the default choice in Print
// Preview
//
// Supported on: fuchsia, linux, mac, win
message PrintPreviewUseSystemDefaultPrinterProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrintPreviewUseSystemDefaultPrinter = 2;
}

// Migration strategy for ecryptfs
//
// This policy was removed in M87 and home directories will automatically
// migrate to ext4 at sign-in.
// Setting the policy specifies the action to take when the user's home
// directory was created with ecryptfs encryption. Unless ecryptfs-encrypted
// home directories migrate to ext4-encryption, Android apps might stop running.
//
// Setting the policy to:
//
// * Migrate (or an unsupported option such as AskUser or
// AskForEcryptfsArcUsers) means directories automatically migrate to ext4 at
// sign-in, without asking for user consent.
//
// * Wipe or MinimalMigrate means that, at sign-in, new ext4-encrypted home
// directories replace old ecryptfs-encrypted directories. To help the user
// avoid repeated sign-ins, MinimalMigrate tries to preserve sign-in tokens.
//
// * DisallowArc or leaving it unset prevents migration, and the user's Android
// apps stop running.
//
// This policy doesn't apply to kiosk users.
//
// Warning: Wipe and MinimalMigrate remove local data.
//
// Valid values:
//   0: Disallow data migration and ARC.
//   1: Migrate automatically, don’t ask for user consent.
//   2: Wipe the user’s ecryptfs home directory and start with a fresh
// ext4-encrypted home directory.
//   4: Similar to Wipe (value 2), but tries to preserve login tokens so the
// user does not have to sign in again.
//
// Supported on:
message EcryptfsMigrationStrategyProto {
  optional PolicyOptions policy_options = 1;
  optional int64 EcryptfsMigrationStrategy = 2;
}

// Select task scheduler configuration
//
// Setting the policy instructs Google ChromeOS to use the task scheduler
// configuration identified by the specified name. This policy can be set to
// Conservative or Performance, which tune the task scheduler for stability or
// maximum performance, respectively.
//
// If unset, users make their own choice.
//
// Valid values:
//   conservative: Optimize for stability.
//   performance: Optimize for performance.
//
// Supported on: chrome_os
message SchedulerConfigurationProto {
  optional PolicyOptions policy_options = 1;
  optional string SchedulerConfiguration = 2;
}

// Whitelist note-taking apps allowed on the Google ChromeOS lock screen
//
// This policy is deprecated, please use NoteTakingAppsLockScreenAllowlist
// instead.
//
// Setting the policy specifies the apps that users can turn on as a note-taking
// app on the Google ChromeOS lock screen.
//
// If the preferred app is on the lock screen, a UI element for launching the
// preferred note-taking app appears on the screen. When launched, the app can
// create a window on top of the lock screen and create notes in this context.
// The app can import created notes to the primary user session, when the
// session is unlocked. Only Google Chrome note-taking apps are supported on the
// lock screen.
//
// Setting the policy means users can turn on an app on the lock screen if the
// app's extension ID is in the policy list value. So, setting it to an empty
// list will turn off note-taking on the lock screen. The policy with an app ID
// doesn't necessarily mean that users can turn the app on as a note-taking app
// on the lock screen. For example, on Google Chrome 61, the set of available
// apps is also restricted by the platform.
//
// Leaving the policy unset amounts to no restrictions on the set of apps users
// can enable on the lock screen imposed by the policy.
//
// Supported on:
message NoteTakingAppsLockScreenWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NoteTakingAppsLockScreenWhitelist = 2;
}

// The list of note-taking apps allowed on the Google ChromeOS lock screen
//
// Setting the policy specifies the apps that users can turn on as a note-taking
// app on the Google ChromeOS lock screen.
//
// If the preferred app is on the lock screen, a UI element for launching the
// preferred note-taking app appears on the screen. When launched, the app can
// create a window on top of the lock screen and create notes in this context.
// The app can import created notes to the primary user session, when the
// session is unlocked. Only Google Chrome note-taking apps are supported on the
// lock screen.
//
// Setting the policy means users can turn on an app on the lock screen if the
// app's extension ID is in the policy list value. So, setting it to an empty
// list will turn off note-taking on the lock screen. The policy with an app ID
// doesn't necessarily mean that users can turn the app on as a note-taking app
// on the lock screen. For example, on Google Chrome 61, the set of available
// apps is also restricted by the platform.
//
// Leaving the policy unset amounts to no restrictions on the set of apps users
// can enable on the lock screen imposed by the policy.
//
// Supported on: chrome_os
message NoteTakingAppsLockScreenAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList NoteTakingAppsLockScreenAllowlist = 2;
}

// Enable casting content to the device
//
// Allow content to be cast to the device using Google Cast.
//
// If this policy is set to False, users will not be able to cast content to
// their device. If this policy is set to True, users are allowed to cast
// content. If this policy is not set, users are not allowed to cast content to
// enrolled ChromeOS devices, but can cast to non enrolled devices.
//
// Supported on: chrome_os
message CastReceiverEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CastReceiverEnabled = 2;
}

// Google Chrome cloud policy overrides Platform policy.
//
// Setting the policy to Enabled means cloud policy takes precedence if it
// conflicts with platform policy.
//
// Setting the policy to Disabled or leaving it unset means platform policy
// takes precedence if it conflicts with cloud policy.
//
// This mandatory policy affects machine scope cloud policies.
//
// This policy is only available on Google Chrome; it has no effect on Google
// Update.
//
// Supported on: android, fuchsia, ios, linux, mac, win
message CloudPolicyOverridesPlatformPolicyProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudPolicyOverridesPlatformPolicy = 2;
}

// Allow user cloud policies to override Chrome Browser Cloud Management
// policies.
//
// Setting the policy to Enabled allows policies associated with a Google
// Workspace account to take precedence if they conflict with Chrome Browser
// Cloud Management policies.
//
// Only policies originating from secure users can take precedence. A secure
// user is affiliated with the organization that manages their browser using
// Chrome Browser Cloud Management. All other user-level policies will have
// default precedence.
//
// The policy can be combined with CloudPolicyOverridesPlatformPolicy. If both
// policies are enabled, user cloud policies will also take precedence over
// conflicting platform policies.
//
// Leaving the policy unset or setting it to disabled causes user-level cloud
// policies to have default priority.
//
// Valid values:
//   True: Allow user cloud policies to override machine cloud policies.
//   False: Prevent user cloud policies from overriding machine cloud policies.
//
// Supported on: android, fuchsia, ios, linux, mac, win
message CloudUserPolicyOverridesCloudMachinePolicyProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudUserPolicyOverridesCloudMachinePolicy = 2;
}

// Ask where to save each file before downloading
//
// Setting the policy to Enabled means users are asked where to save each file
// before downloading. Setting the policy to Disabled has downloads start
// immediately, and users aren't asked where to save the file.
//
// Leaving the policy unset lets users change this setting.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message PromptForDownloadLocationProto {
  optional PolicyOptions policy_options = 1;
  optional bool PromptForDownloadLocation = 2;
}

// Enable Site Isolation for specified origins
//
// Setting the policy means each of the named origins in a comma-separated list
// runs in a dedicated process. Each named origin's process will only be allowed
// to contain documents from that origin and its subdomains. For example,
// specifying https://a1.example.com/ allows https://a2.a1.example.com/ in the
// same process, but not https://example.com or https://b.example.com.
//
// Since Google Chrome 77, you can also specify a range of origins to isolate
// using a wildcard. For example, specifying https://[*.]corp.example.com will
// give every origin underneath https://corp.example.com its own dedicated
// process, including https://corp.example.com itself,
// https://a1.corp.example.com, and https://a2.a1.corp.example.com.
//
// Note that all sites (i.e., scheme plus eTLD+1, such as https://example.com)
// are already isolated by default on Desktop platforms, as noted in the
// SitePerProcess policy. This IsolateOrigins policy is useful to isolate
// specific origins at a finer granularity (e.g., https://a.example.com).
//
// Also note that origins isolated by this policy will be unable to script other
// origins in the same site, which is otherwise possible if two same-site
// documents modify their document.domain values to match. Administrators should
// confirm this uncommon behavior is not used on an origin before isolating it.
//
// Setting the policy to off or leaving it unset lets users change this setting.
//
// Note: For Android, use the IsolateOriginsAndroid policy instead.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message IsolateOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional string IsolateOrigins = 2;
}

// Require Site Isolation for every site
//
// Since Google Chrome 67, site isolation has been enabled by default on all
// Desktop platforms, causing every site to run in its own process. A site is a
// scheme plus eTLD+1 (e.g., https://example.com). Setting this policy to
// Enabled does not change that behavior; it only prevents users from opting out
// (for example, using Disable site isolation in chrome://flags). Since Google
// Chrome 76, setting the policy to Disabled or leaving it unset doesn't turn
// off site isolation, but instead allows users to opt out.
//
// IsolateOrigins might also be useful for isolating specific origins at a finer
// granularity than site (e.g., https://a.example.com).
//
// On Google ChromeOS version 76 and earlier, set the
// DeviceLoginScreenSitePerProcess device policy to the same value. (If the
// values don't match, a delay can occur when entering a user session.)
//
// Note: For Android, use the SitePerProcessAndroid policy instead.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SitePerProcessProto {
  optional PolicyOptions policy_options = 1;
  optional bool SitePerProcess = 2;
}

// Enable Site Isolation for specified origins on Android devices
//
// Setting the policy means each of the named origins in a comma-separated list
// runs in a dedicated process on Android. Each named origin's process will only
// be allowed to contain documents from that origin and its subdomains. For
// example, specifying https://a1.example.com/ allows https://a2.a1.example.com/
// in the same process, but not https://example.com or https://b.example.com.
// Note that Android isolates certain sensitive sites by default starting in
// Google Chrome version 77, and this policy extends that mode to isolate
// specific additional origins.
//
// Since Google Chrome 77, you can also specify a range of origins to isolate
// using a wildcard. For example, specifying https://[*.]corp.example.com will
// give every origin underneath https://corp.example.com its own dedicated
// process, including https://corp.example.com itself,
// https://a1.corp.example.com, and https://a2.a1.corp.example.com.
//
// Note that origins isolated by this policy will be unable to script other
// origins in the same site, which is otherwise possible if two same-site
// documents modify their document.domain values to match. Administrators should
// confirm this uncommon behavior is not used on an origin before isolating it.
//
// Setting the policy to Disabled turns off any form of site isolation,
// including isolation of sensitive sites and field trials of
// IsolateOriginsAndroid, SitePerProcessAndroid, and other site isolation modes.
// Users can still turn on IsolateOrigins manually, through the command line
// flag.
//
// Leaving the policy unset lets users change this setting.
//
// Note: Isolating too many sites on Android may cause performance problems,
// especially on low-memory devices. This policy applies only to Chrome on
// Android running on devices with strictly more than 1 GB of RAM. To apply the
// policy on non-Android platforms, use IsolateOrigins.
//
// Supported on: android
message IsolateOriginsAndroidProto {
  optional PolicyOptions policy_options = 1;
  optional string IsolateOriginsAndroid = 2;
}

// Enable Site Isolation for every site
//
// Setting the policy to Enabled isolates all sites on Android, such that each
// site runs in its own process, and it prevents users from opting out. A site
// is a scheme plus eTLD+1 (e.g., https://example.com). Note that Android
// isolates certain sensitive sites by default starting in Google Chrome version
// 77, and this policy extends that default site isolation mode to apply to all
// sites.
//
// Setting the policy to Disabled turns off any form of site isolation,
// including isolation of sensitive sites and field trials of
// IsolateOriginsAndroid, SitePerProcessAndroid, and other site isolation modes.
// Users can still turn the policy on manually.
//
// Leaving the policy unset means users can change this setting.
//
// IsolateOriginsAndroid might also be useful for isolating specific origins at
// a finer granularity than site (e.g., https://a.example.com).
//
// Note: Support for isolating every site on Android will improve, but currently
// it may cause performance problems, especially on low-end devices. This policy
// applies only to Chrome on Android running on devices with strictly more than
// 1 GB of RAM. To isolate specific sites while limiting performance impact for
// users, use IsolateOriginsAndroid with a list of the sites you want to
// isolate.  To apply the policy on non-Android platforms, use SitePerProcess.
//
// Supported on: android
message SitePerProcessAndroidProto {
  optional PolicyOptions policy_options = 1;
  optional bool SitePerProcessAndroid = 2;
}

// Specifies whether SharedArrayBuffers can be used in a non cross-origin-
// isolated context
//
//
// Specifies whether SharedArrayBuffers can be used in a non cross-origin-
// isolated context. Google Chrome will require cross-origin isolation when
// using SharedArrayBuffers from Google Chrome 91 onward (2021-05-25) for Web
// Compatibility reasons. Additional details can be found on:
// https://developer.chrome.com/blog/enabling-shared-array-buffer/.
//
// When set to Enabled, sites can use SharedArrayBuffer with no restrictions.
//
// When set to Disabled or not set, sites can only use SharedArrayBuffers when
// cross-origin isolated.
//
// Valid values:
//   True: Allow sites to use SharedArrayBuffers
//   False: Prevent sites from using SharedArrayBuffers
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SharedArrayBufferUnrestrictedAccessAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SharedArrayBufferUnrestrictedAccessAllowed = 2;
}

// Allow Chrome to block navigations toward external protocols in sandboxed
// iframes
//
// Chrome will block navigations toward external protocols inside
// sandboxed iframe. See https://chromestatus.com/features/5680742077038592.
//
// When True, this lets Chrome blocks those navigations.
//
// When False, this prevents Chrome from blocking those navigations.
//
// This defaults to True: security feature enabled.
//
// This can be used by administrators who need more time to update their
// internal website affected by this new restriction. This Enterprise policy is
// temporary; it's intended to be removed after Google Chrome version 117.
//
// Valid values:
//   True: Allow Chrome to block navigations to external protocols inside
// sandboxed iframe
//   False: Prevent Chrome to block navigations to external protocols inside
// sandboxed iframe
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SandboxExternalProtocolBlockedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SandboxExternalProtocolBlocked = 2;
}

// Specifies whether WebAssembly modules can be sent cross-origin
//
//
// Specifies whether WebAssembly modules can be sent to another window or worker
// cross-origin. Cross-origin WebAssembly module sharing will be deprecated as
// part of the efforts to deprecate document.domain, see
// https://github.com/mikewest/deprecating-document-domain. This policy allows
// to re-enable cross-origin WebAssembly module sharing to offer a longer
// transition period in the deprecation process.
//
// When set to True, sites can send WebAssembly modules also cross-origin
// without restrictions.
//
// When set to False or not set, sites can only send WebAssembly modules to
// windows and workers in the same origin.
//
// Valid values:
//   True: Allow WebAssembly modules to be sent cross-origin
//   False: Prevent WebAssembly modules to be sent cross-origin
//
// Supported on:
message CrossOriginWebAssemblyModuleSharingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CrossOriginWebAssemblyModuleSharingEnabled = 2;
}

// Specifies whether the display-capture permissions-policy is checked or
// skipped.
//
//
// The display-capture permissions-policy gates access to getDisplayMedia(), as
// per this spec: https://www.w3.org/TR/screen-capture/#feature-policy-
// integration. However, if this policy is Disabled, this requirement is not
// enforced, and getDisplayMedia() is allowed from contexts that would otherwise
// be forbidden. This Enterprise policy is temporary; it's intended to be
// removed after Google Chrome version 100. It is intended to unblock Enterprise
// users whose application is non-spec compliant, but needs time to be fixed.
//
// When enabled or not set, sites can only call getDisplayMedia() from contexts
// which are allowlisted by the display-capture permissions-policy.
//
// When disabled, sites can call getDisplayMedia() even from contexts which are
// not allowlisted by the display-capture permissions policy. Note that other
// restrictions may still apply.
//
// Valid values:
//   True:
//           Calls to getDisplayMedia originating from non-allowlisted contexts
//           are denied.
//   False:
//           Calls are not denied on account of originating from non-allowlisted
//           contexts. (Calls may still be denied for other reasons.)
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DisplayCapturePermissionsPolicyEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DisplayCapturePermissionsPolicyEnabled = 2;
}

// Allow WebDriver to Override Incompatible Policies
//
//
// This policy was removed in M80, because it is not necessary anymore as
// WebDriver is now compatible with all existing policies.
//
// This policy allows users of the WebDriver feature to override policies which
// can interfere with its operation.
//
// Currently this policy disables SitePerProcess and IsolateOrigins policies.
//
// If the policy is enabled, WebDriver will be able to override incomaptible
// policies.
//
// If the policy is disabled or not configured, WebDriver will not be allowed to
// override incompatible policies.
//
// Supported on:
message WebDriverOverridesIncompatiblePoliciesProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebDriverOverridesIncompatiblePolicies = 2;
}

// Origins or hostname patterns for which restrictions on
//       insecure origins should not apply
//
// Deprecated in M69. Use
// OverrideSecurityRestrictionsOnInsecureOrigin instead.
//
// The policy specifies a list of origins (URLs) or hostname patterns (such as
// "*.example.com") for which security restrictions on insecure origins will not
// apply.
//
// The intent is to allow organizations to allow origins for legacy applications
// that cannot deploy TLS, or to set up a staging server for internal web
// development so that their developers can test out features requiring secure
// contexts without having to deploy TLS on the staging server. This policy will
// also prevent the origin from being labeled "Not Secure" in the omnibox.
//
// Setting a list of URLs in this policy has the same effect as setting the
// command-line flag '--unsafely-treat-insecure-origin-as-secure' to a comma-
// separated list of the same URLs. If the policy is set, it will override the
// command-line flag.
//
// This policy is deprecated in M69 in favor of
// OverrideSecurityRestrictionsOnInsecureOrigin. If both policies are present,
// OverrideSecurityRestrictionsOnInsecureOrigin will override this policy.
//
// For more information on secure contexts, see https://www.w3.org/TR/secure-
// contexts/
//
// Supported on: fuchsia, linux, mac, win
message UnsafelyTreatInsecureOriginAsSecureProto {
  optional PolicyOptions policy_options = 1;
  optional StringList UnsafelyTreatInsecureOriginAsSecure = 2;
}

// Set default download directory
//
// Setting the policy changes the default directory that Chrome downloads files
// to, but users can change the directory.
//
// Leaving the policy unset means Chrome uses its platform-specific default
// directory.
//
// This policy has no effect if the policy DownloadDirectory is set.
//
// Note: See a list of variables you can use (
// https://www.chromium.org/administrators/policy-list-3/user-data-directory-
// variables ).
//
// Supported on: chrome_os, fuchsia, linux, mac, win
//
// Note: this policy must have a RECOMMENDED PolicyMode set in PolicyOptions.
message DefaultDownloadDirectoryProto {
  optional PolicyOptions policy_options = 1;
  optional string DefaultDownloadDirectory = 2;
}

// Abusive Experience Intervention Enforce
//
// If SafeBrowsingEnabled is not Disabled, then setting
// AbusiveExperienceInterventionEnforce to Enabled or leaving it unset prevents
// sites with abusive experiences from opening new windows or tabs.
//
// Setting SafeBrowsingEnabled to Disabled or
// AbusiveExperienceInterventionEnforce to Disabled lets sites with abusive
// experiences open new windows or tabs.
//
// Valid values:
//   True: Prevent sites with abusive experiences from opening new windows or
// tabs
//   False: Allow sites with abusive experiences to open new windows or tabs
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AbusiveExperienceInterventionEnforceProto {
  optional PolicyOptions policy_options = 1;
  optional bool AbusiveExperienceInterventionEnforce = 2;
}

// Force enable spellcheck languages
//
// Force-enables spellcheck languages. Unrecognized languages in the list will
// be ignored.
//
// If you enable this policy, spellcheck will be enabled for the languages
// specified, in addition to the languages for which the user has enabled
// spellcheck.
//
// If you do not set this policy, or disable it, there will be no change to the
// user's spellcheck preferences.
//
// If the SpellcheckEnabled policy is set to false, this policy will have no
// effect.
//
// If a language is included in both this policy and the
// SpellcheckLanguageBlocklist policy, this policy is prioritized and the
// spellcheck language is enabled.
//
// The currently supported languages are: af, bg, ca, cs, da, de, el, en-AU, en-
// CA, en-GB, en-US, es, es-419, es-AR, es-ES, es-MX, es-US, et, fa, fo, fr, he,
// hi, hr, hu, id, it, ko, lt, lv, nb, nl, pl, pt-BR, pt-PT, ro, ru, sh, sk, sl,
// sq, sr, sv, ta, tg, tr, uk, vi.
//
// Supported on: chrome_os, linux, win
message SpellcheckLanguageProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SpellcheckLanguage = 2;
}

// Force disable spellcheck languages
//
// This policy is deprecated, please use SpellcheckLanguageBlocklist instead.
//
// Force-disables spellcheck languages. Unrecognized languages in that list will
// be ignored.
//
// If you enable this policy, spellcheck will be disabled for the languages
// specified. The user can still enable or disable spellcheck for languages not
// in the list.
//
// If you do not set this policy, or disable it, there will be no change to the
// user's spellcheck preferences.
//
// If the SpellcheckEnabled policy is set to false, this policy will have no
// effect.
//
// If a language is included in both this policy and the SpellcheckLanguage
// policy, the latter is prioritized and the spellcheck language will be
// enabled.
//
// The currently supported languages are: af, bg, ca, cs, da, de, el, en-AU, en-
// CA, en-GB, en-US, es, es-419, es-AR, es-ES, es-MX, es-US, et, fa, fo, fr, he,
// hi, hr, hu, id, it, ko, lt, lv, nb, nl, pl, pt-BR, pt-PT, ro, ru, sh, sk, sl,
// sq, sr, sv, ta, tg, tr, uk, vi.
//
// Supported on:
message SpellcheckLanguageBlacklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SpellcheckLanguageBlacklist = 2;
}

// Force disable spellcheck languages
//
// Force-disables spellcheck languages. Unrecognized languages in that list will
// be ignored.
//
// If you enable this policy, spellcheck will be disabled for the languages
// specified. The user can still enable or disable spellcheck for languages not
// in the list.
//
// If you do not set this policy, or disable it, there will be no change to the
// user's spellcheck preferences.
//
// If the SpellcheckEnabled policy is set to false, this policy will have no
// effect.
//
// If a language is included in both this policy and the SpellcheckLanguage
// policy, the latter is prioritized and the spellcheck language will be
// enabled.
//
// The currently supported languages are: af, bg, ca, cs, da, de, el, en-AU, en-
// CA, en-GB, en-US, es, es-419, es-AR, es-ES, es-MX, es-US, et, fa, fo, fr, he,
// hi, hr, hu, id, it, ko, lt, lv, nb, nl, pl, pt-BR, pt-PT, ro, ru, sh, sk, sl,
// sq, sr, sv, ta, tg, tr, uk, vi.
//
// Supported on: chrome_os, linux, win
message SpellcheckLanguageBlocklistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SpellcheckLanguageBlocklist = 2;
}

// Enable third party software injection blocking
//
// Setting the policy to Enabled or leaving it unset prevents third-party
// software from injecting executable code into Google Chrome's processes.
//
// Setting the policy to Disabled allows this software to inject such code into
// Google Chrome's processes.
//
// Supported on: win
message ThirdPartyBlockingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ThirdPartyBlockingEnabled = 2;
}

// Enable spellcheck
//
// Setting the policy to Enabled turns spellcheck on, and users can't turn it
// off. On Microsoft® Windows®, Google ChromeOS and Linux®, spellcheck languages
// can be switched on or off individually, so users can still turn spellcheck
// off by switching off every spellcheck language. To avoid that, use the
// SpellcheckLanguage to force-enable specific spellcheck languages.
//
// Setting the policy to Disabled turns off spellcheck from all sources, and
// users can't turn it on. The SpellCheckServiceEnabled, SpellcheckLanguage and
// SpellcheckLanguageBlocklist policies have no effect when this policy is set
// to False.
//
// Leaving the policy unset lets users turn spellcheck on or off in the language
// settings.
//
// Valid values:
//   True: Enable spellcheck
//   False: Disable spellcheck
//   None: Allow the user to enable or disable spellcheck
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SpellcheckEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SpellcheckEnabled = 2;
}

// Ads setting for sites with intrusive ads
//
// Unless SafeBrowsingEnabled is set to False, then setting
// AdsSettingForIntrusiveAdsSites to 1 or leaving it unset allows ads on all
// sites.
//
// Setting the policy to 2 blocks ads on sites with intrusive ads.
//
// Valid values:
//   1: Allow ads on all sites
//   2: Do not allow ads on sites with intrusive ads
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AdsSettingForIntrusiveAdsSitesProto {
  optional PolicyOptions policy_options = 1;
  optional int64 AdsSettingForIntrusiveAdsSites = 2;
}

// Restrict accounts that are visible in Google Chrome
//
// Contains a list of patterns which are used to control the visibility of
// accounts in Google Chrome.
//
// Each Google account on the device will be compared to patterns stored in this
// policy to determine the account visibility in Google Chrome. The account will
// be visible if its name matches any pattern on the list. Otherwise, the
// account will be hidden.
//
// Use the wildcard character '*' to match zero or more arbitrary characters.
// The escape character is '\', so to match actual '*' or '\' characters, put a
// '\' in front of them.
//
// If this policy is not set, all Google accounts on the device will be visible
// in Google Chrome.
//
// Supported on: android, ios
message RestrictAccountsToPatternsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RestrictAccountsToPatterns = 2;
}

// Password protection warning trigger
//
// Setting the policy lets you control the triggering of password protection
// warning. Password protection alerts users when they reuse their protected
// password on potentially suspicious sites.
//
// Use PasswordProtectionLoginURLs and PasswordProtectionChangePasswordURL to
// set which password to protect.
//
// If this policy is set to:
//
// * PasswordProtectionWarningOff, no password protection warning will be shown.
//
// * PasswordProtectionWarningOnPasswordReuse, password protection warning will
// be shown when the user reuses their protected password on a non-allowed site.
//
// * PasswordProtectionWarningOnPhishingReuse, password protection warning will
// be shown when the user reuses their protected password on a phishing site.
//
// Leaving the policy unset has the password protection service only protect
// Google passwords, but users can change this setting.
//
// Valid values:
//   0: Password protection warning is off
//   1: Password protection warning is triggered by password reuse
//   2: Password protection warning is triggered by password reuse on phishing
// page
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PasswordProtectionWarningTriggerProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PasswordProtectionWarningTrigger = 2;
}

// Notify a user that a browser relaunch or device restart is recommended or
// required
//
// Notify users that Google Chrome must be relaunched or Google ChromeOS must be
// restarted to apply a pending update.
//
// This policy setting enables notifications to inform the user that a browser
// relaunch or device restart is recommended or required. If not set, Google
// Chrome indicates to the user that a relaunch is needed via subtle changes to
// its menu, while Google ChromeOS indicates such via a notification in the
// system tray. If set to 'Recommended', a recurring warning will be shown to
// the user that a relaunch is recommended. The user can dismiss this warning to
// defer the relaunch. If set to 'Required', a recurring warning will be shown
// to the user indicating that a browser relaunch will be forced once the
// notification period passes. The default period is seven days for Google
// Chrome and four days for Google ChromeOS, and may be configured via the
// RelaunchNotificationPeriod policy setting.
//
// The user's session is restored following the relaunch/restart.
//
// Valid values:
//   1: Show a recurring prompt to the user indicating that a relaunch is
// recommended
//   2: Show a recurring prompt to the user indicating that a relaunch is
// required
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RelaunchNotificationProto {
  optional PolicyOptions policy_options = 1;
  optional int64 RelaunchNotification = 2;
}

// Set the time period for update notifications
//
// Allows you to set the time period, in milliseconds, over which users are
// notified that Google Chrome must be relaunched or that a Google ChromeOS
// device must be restarted to apply a pending update.
//
// Over this time period, the user will be repeatedly informed of the need for
// an update. For Google ChromeOS devices, a restart notification appears in the
// system tray according to the RelaunchHeadsUpPeriod policy. For Google Chrome
// browsers, the app menu changes to indicate that a relaunch is needed once one
// third of the notification period passes. This notification changes color once
// two thirds of the notification period passes, and again once the full
// notification period has passed. The additional notifications enabled by the
// RelaunchNotification policy follow this same schedule.
//
// If not set, the default period of 604800000 milliseconds (one week) is used.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RelaunchNotificationPeriodProto {
  optional PolicyOptions policy_options = 1;
  optional int64 RelaunchNotificationPeriod = 2;
}

// Set the time of the first user relaunch notification
//
// Allows you to set the time period, in milliseconds, between the first
// notification that a Google ChromeOS device must be restarted to apply a
// pending update and the end of the time period specified by the
// RelaunchNotificationPeriod policy.
//
// If not set, the default period of 259200000 milliseconds (three days) is used
// for Google ChromeOS devices.
//
// For rollback and other Google ChromeOS updates that will powerwash the
// device, the user is always notified immediately when the update is available,
// independently of the value of this policy.
//
// Supported on: chrome_os
message RelaunchHeadsUpPeriodProto {
  optional PolicyOptions policy_options = 1;
  optional int64 RelaunchHeadsUpPeriod = 2;
}

// Set the time interval for relaunch
//
// Specify a target time window for the end of the relaunch notification period.
//
// Users are notified of the need for a browser relaunch or device restart based
// on the RelaunchNotification and RelaunchNotificationPeriod policy settings.
// Browsers and devices are forcibly restarted at the end of the notification
// period when the RelaunchNotification policy is set to 'Required'. This
// RelaunchWindow policy can be used to defer the end of the notification period
// so that it falls within a specific time window.
//
// If this policy is not set, the default target time window for Google ChromeOS
// is between 2 AM and 4 AM. The default target time window for Google Chrome is
// the whole day (i.e., the end of the notification period is never deferred).
//
// Note: Though the policy can accept multiple items in entries, all but the
// first item are ignored.
// Warning: Setting this policy may delay application of software updates.
//
// Value schema:
// {
//     "properties": {
//         "entries": {
//             "items": {
//                 "properties": {
//                     "duration_mins": {
//                         "description": "Time period (minutes) that specifies
// the length of the relaunch window.",
//                         "maximum": 1440,
//                         "minimum": 1,
//                         "type": "integer"
//                     },
//                     "start": {
//                         "description": "Time interpreted in local wall-clock
// 24h format.",
//                         "id": "Time",
//                         "properties": {
//                             "hour": {
//                                 "maximum": 23,
//                                 "minimum": 0,
//                                 "type": "integer"
//                             },
//                             "minute": {
//                                 "maximum": 59,
//                                 "minimum": 0,
//                                 "type": "integer"
//                             }
//                         },
//                         "required": [
//                             "hour",
//                             "minute"
//                         ],
//                         "type": "object"
//                     }
//                 },
//                 "required": [
//                     "start",
//                     "duration_mins"
//                 ],
//                 "type": "object"
//             },
//             "type": "array"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message RelaunchWindowProto {
  optional PolicyOptions policy_options = 1;
  optional string RelaunchWindow = 2;
}

// User is enabled to run Crostini
//
// Setting the policy to Enabled or leaving it unset lets users run Crostini, as
// long as VirtualMachinesAllowed and CrostiniAllowed are set to Enabled.
// Setting the policy to Disabled turns Crostini off for the user. Changing it
// to Disabled starts applying the policy to starting new Crostini containers,
// not those already running.
//
// Supported on: chrome_os
message CrostiniAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool CrostiniAllowed = 2;
}

// User is enabled to export / import Crostini containers via the UI
//
// Setting the policy to Enabled or leaving it unset makes the export-import UI
// available to users. Setting the policy to Disabled renders the export-import
// UI unavailable to users.
//
// Supported on: chrome_os
message CrostiniExportImportUIAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool CrostiniExportImportUIAllowed = 2;
}

// User is allowed to have root access to Crostini containers
//
// Allow this user root access to Crostini containers.
//
// If the policy is set to true or left unset root access to Crostini containers
// will be granted to the user.
// If the policy is set to false, root access to both existing and new Crostini
// containers will not be granted to the user.
//
// Supported on: chrome_os
message CrostiniRootAccessAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool CrostiniRootAccessAllowed = 2;
}

// Crostini Ansible playbook
//
// Provides an Ansible playbook that should be executed in the default Crostini
// container.
//
// This policy allows to provide an Ansible playbook to be applied to the
// default Crostini container if it is available on the given device and allowed
// by policies.
//
// The size of the data must not exceed 1MB (1000000 bytes) and must be encoded
// in YAML. The cryptographic hash is used to verify the integrity of the
// download.
//
// The configuration is downloaded and cached. It will be re-downloaded whenever
// the URL or the hash changes.
//
// If you set the policy, users can't change it. If not set, users can continue
// using default Crostini container in its ongoing configuration if Crostini is
// allowed by policies.
//
// Supported on: chrome_os
message CrostiniAnsiblePlaybookProto {
  optional PolicyOptions policy_options = 1;
  optional string CrostiniAnsiblePlaybook = 2;
}

// Control usage of Android apps from untrusted sources for the user
//
// This policy controls the usage of Android apps from untrusted sources (other
// than Google Play Store) on a per-user basis.
//
// If the value for this policy is not set, then the functionality is treated as
// disallowed.
//
// If the user's device is managed, the availability of this functionality is
// additionally dependant on the corresponding device policy.
//
// If the user's device is not managed, the availability of this functionality
// is additionally dependant on whether the user is the device owner.
//
// Valid values:
//   0: Prevent the user from using Android apps from untrusted sources
//   1: Allow the user to use Android apps from untrusted sources
//
// Supported on: chrome_os
message CrostiniArcAdbSideloadingAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional int64 CrostiniArcAdbSideloadingAllowed = 2;
}

// Allow users to [enable/configure] Crostini port forwarding
//
// Specifies whether port forwarding into Crostini containers is allowed.
//
// If this policy is set to True or not set, users will be able to configure
// port forwarding into their Crostini containers.
//
// If this policy is set to False, port forwarding into Crostini containers will
// be disabled.
//
// Supported on: chrome_os
message CrostiniPortForwardingAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool CrostiniPortForwardingAllowed = 2;
}

// Allow SSH outgoing client connections in Terminal System App
//
// If this policy doesn't exist (e.g. for unmanaged users), the SSH (Secure
// SHell) outgoing client connections feature in Terminal System App is enabled
// (default True).
// If the user is managed, and the policy is unset or Disabled, the feature is
// disabled in Terminal.
// Setting the policy to Enabled allows managed users to create outgoing client
// SSH connections in Terminal.
//
// Valid values:
//   True: Enable SSH in Terminal System App
//   False: Disable SSH in Terminal System App
//
// Supported on: chrome_os
message SystemTerminalSshAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool SystemTerminalSshAllowed = 2;
}

// Configure the list of domains on which Safe Browsing will not trigger
// warnings.
//
// This policy is deprecated, please use SafeBrowsingAllowlistDomains instead.
//
// Setting the policy to Enabled means Safe Browsing will trust the domains you
// designate. It won't check them for dangerous resources such as phishing,
// malware, or unwanted software. Safe Browsing's download protection service
// won't check downloads hosted on these domains. Its password protection
// service won't check for password reuse.
//
// Setting the policy to Disabled or leaving it unset means default Safe
// Browsing protection applies to all resources.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on:
message SafeBrowsingWhitelistDomainsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SafeBrowsingWhitelistDomains = 2;
}

// Configure the list of domains on which Safe Browsing will not trigger
// warnings.
//
// Setting the policy to Enabled means Safe Browsing will trust the domains you
// designate. It won't check them for dangerous resources such as phishing,
// malware, or unwanted software. Safe Browsing's download protection service
// won't check downloads hosted on these domains. Its password protection
// service won't check for password reuse.
//
// Leaving the policy unset means default Safe Browsing protection applies to
// all resources.
//
// This policy must be set as a list of fully qualified domain names. It does
// not support regular expressions, and will not allowlist subdomains of domains
// listed in the policy.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SafeBrowsingAllowlistDomainsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SafeBrowsingAllowlistDomains = 2;
}

// Configure the list of enterprise login URLs where password protection service
// should capture salted hashes of passwords.
//
// Setting the policy sets the list of enterprise login URLs (HTTP and HTTPS
// protocols only). Password protection service will capture salted hashes of
// passwords on these URLs and use them for password reuse detection. For Google
// Chrome to correctly capture password salted hashes, ensure your sign-in pages
// follow these guidelines ( https://www.chromium.org/developers/design-
// documents/create-amazing-password-forms ).
//
// Turning this setting off or leaving it unset means the password protection
// service only captures the password salted hashes on
// https://accounts.google.com.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PasswordProtectionLoginURLsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PasswordProtectionLoginURLs = 2;
}

// Configure the change password URL.
//
// Setting the policy sets the URL for users to change their password after
// seeing a warning in the browser. The password protection service sends users
// to the URL (HTTP and HTTPS protocols only) you designate through this policy.
// For Google Chrome to correctly capture the salted hash of the new password on
// this change password page, make sure your change password page follows these
// guidelines ( https://www.chromium.org/developers/design-documents/create-
// amazing-password-forms ).
//
// Turning the policy off or leaving it unset means the service sends users to
// https://myaccount.google.com to change their password.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PasswordProtectionChangePasswordURLProto {
  optional PolicyOptions policy_options = 1;
  optional string PasswordProtectionChangePasswordURL = 2;
}

// Enable Safe Browsing Extended Reporting
//
// Setting the policy to Enabled turns on Google Chrome's Safe Browsing Extended
// Reporting, which sends some system information and page content to Google
// servers to help detect dangerous apps and sites.
//
// Setting the policy to Disabled means reports are never sent.
//
// If you set this policy, users can't change it. If not set, users can decide
// whether to send reports or not.
//
// See more about Safe Browsing ( https://developers.google.com/safe-browsing ).
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SafeBrowsingExtendedReportingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SafeBrowsingExtendedReportingEnabled = 2;
}

// The enrollment token of cloud policy on desktop
//
//
// This policy is deprecated in M72. Please use CloudManagementEnrollmentToken
// instead.
//
// Supported on:
message MachineLevelUserCloudPolicyEnrollmentTokenProto {
  optional PolicyOptions policy_options = 1;
  optional string MachineLevelUserCloudPolicyEnrollmentToken = 2;
}

// The enrollment token of cloud policy
//
// Setting the policy means Google Chrome tries to register itself with Chrome
// Browser Cloud Management. The value of this policy is an enrollment token you
// can retrieve from the Google Admin console.
//
// See https://support.google.com/chrome/a/answer/9301891?ref_topic=9301744 for
// details.
//
// Supported on: android, fuchsia, ios, linux, mac, win
message CloudManagementEnrollmentTokenProto {
  optional PolicyOptions policy_options = 1;
  optional string CloudManagementEnrollmentToken = 2;
}

// Enable mandatory cloud management enrollment
//
// Setting the policy to Enabled mandates Chrome Browser Cloud Management
// enrollment and blocks Google Chrome launch process if failed.
//
// Setting the policy to Disabled or leaving it unset renders Chrome Browser
// Cloud Management optional and doesn't block Google Chrome launch process if
// failed.
//
// Machine scope cloud policy enrollment on desktop uses this policy. See
// https://support.google.com/chrome/a/answer/9301891?ref_topic=9301744 for
// details.
//
// Supported on: fuchsia, linux, mac, win
message CloudManagementEnrollmentMandatoryProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudManagementEnrollmentMandatory = 2;
}

// Allow media autoplay
//
// Setting the policy to True lets Google Chrome autoplay media. Setting the
// policy to False stops Google Chrome from autoplaying media.
//
// By default, Google Chrome doesn't autoplay media. But, for certain URL
// patterns, you can use the AutoplayAllowlist policy to change this setting.
//
// If this policy changes while Google Chrome is running, it only applies to
// newly opened tabs.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AutoplayAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool AutoplayAllowed = 2;
}

// Allow media autoplay on a whitelist of URL patterns
//
// This policy is deprecated, please use the 'AutoplayAllowlist' policy instead.
//
// Setting the policy lets videos play automatically (without user consent) with
// audio content in Google Chrome. If AutoplayAllowed policy is set to True,
// then this policy has no effect. If AutoplayAllowed is set to False, then any
// URL patterns set in this policy can still play. If this policy changes while
// Google Chrome is running, it only applies to newly opened tabs.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Supported on:
message AutoplayWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AutoplayWhitelist = 2;
}

// Allow media autoplay on a allowlist of URL patterns
//
// Setting the policy lets videos play automatically (without user consent) with
// audio content in Google Chrome. If AutoplayAllowed policy is set to True,
// then this policy has no effect. If AutoplayAllowed is set to False, then any
// URL patterns set in this policy can still play. If this policy changes while
// Google Chrome is running, it only applies to newly opened tabs.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AutoplayAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AutoplayAllowlist = 2;
}

// Allow sites to simultaneously navigate and open pop-ups
//
// Deprecated in M68. Use DefaultPopupsSetting instead.
//
// For a full explanation, see
// https://www.chromestatus.com/feature/5675755719622656.
// If this policy is enabled, sites will be allowed to simultaneously navigate
// and open new windows/tabs.
// If this policy is disabled or not set, sites will be disallowed from
// simultaneously navigating and opening a new window/tab.
//
// Supported on:
message TabUnderAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool TabUnderAllowed = 2;
}

// Allow access to native CUPS printers
//
// Allows you to control if users can access non-enterprise printers
//
// If the policy is set to True, or not set at all, users will be able to add,
// configure, and print using their own native printers.
//
// If the policy is set to False, users will not be able to add and configure
// their own native printers. They will also not be able to print using any
// previously configured native printers.
//
// This policy is deprecated, please use UserPrintersAllowed instead.
//
// Supported on:
message UserNativePrintersAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserNativePrintersAllowed = 2;
}

// Allow access to CUPS printers
//
// Allows you to control if users can access non-enterprise printers
//
// If the policy is set to True, or not set at all, users will be able to add,
// configure, and print using their own printers.
//
// If the policy is set to False, users will not be able to add and configure
// their own printers. They will also not be able to print using any previously
// configured printers.
//
// Supported on: chrome_os
message UserPrintersAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserPrintersAllowed = 2;
}

// Enable Chrome Cleanup on Windows
//
// Setting the policy to Enabled or leaving it unset means Chrome Cleanup
// periodically scans the system for unwanted software and should any be found,
// will ask the user if they wish to remove it. Manually triggering Chrome
// Cleanup from chrome://settings is allowed.
//
// Setting the policy to Disabled means Chrome Cleanup won't periodically scan
// and manual triggering is disabled.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management.
//
// Supported on: win
message ChromeCleanupEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ChromeCleanupEnabled = 2;
}

// Control how Chrome Cleanup reports data to Google
//
// Setting the policy to Enabled means if Chrome Cleanup detects unwanted
// software, it may, in line with policy set by
// SafeBrowsingExtendedReportingEnabled, report about the scan to Google. Chrome
// Cleanup asks users if they want the cleanup. It sends results to Google.
//
// Setting the policy to Disabled means if Chrome Cleanup detects unwanted
// software, it won't report about the scan to Google, regardless of the value
// of SafeBrowsingExtendedReportingEnabled. Chrome Cleanup asks users if they
// want the cleanup. The results aren't reported to Google.
//
// Leaving the policy unset means Chrome Cleanup may, in line with policy set by
// SafeBrowsingExtendedReportingEnabled, report about scans for detecting
// unwanted software to Google. Chrome Cleanup asks users if they want the
// cleanup and to share the results with Google to help with future unwanted
// software detection. These results have file metadata, automatically installed
// extensions, and registry keys, as described by the Chrome Privacy Whitepaper.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management.
//
// Supported on: win
message ChromeCleanupReportingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ChromeCleanupReportingEnabled = 2;
}

// Configure the allowed languages in a user session
//
// Setting the policy lets users add only one of the languages listed in this
// policy to the list of preferred languages.
//
// If not set or set to an empty list, users can specify languages as preferred.
//
// If set to a list with invalid values, those values are ignored. If users
// added languages not allowed by this policy to the list of preferred
// languages, they're removed. If they had Google ChromeOS displayed in a
// language not allowed by this policy, the next time they sign in, the display
// language switches to an allowed UI language. Otherwise, if this policy only
// has invalid entries, Google ChromeOS switches to the first valid value
// specified by this policy or a fallback locale such as en-US.
//
// Supported on: chrome_os
message AllowedLanguagesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AllowedLanguages = 2;
}

// Configure the allowed input methods in a user session
//
// Setting the policy lets users choose one of the input methods for Google
// ChromeOS sessions that you specify.
//
// If you leave it unset or set to an empty list, users can select all supported
// input methods.
//
// Starting with version M106 allowed input methods are automatically enabled in
// kiosk session.
//
// Note: If the current input method is unsupported, it switches to the hardware
// keyboard layout (if allowed) or the first valid entry in this list. Invalid
// or unsupported methods are ignored.
//
// Supported on: chrome_os
message AllowedInputMethodsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AllowedInputMethods = 2;
}

// Log events for Android app installs
//
// Setting the policy to True sends reports of key, policy-triggered Android app
// installation events to Google. Setting the policy to False means no events
// are captured.
//
// Supported on: chrome_os
message ArcAppInstallEventLoggingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ArcAppInstallEventLoggingEnabled = 2;
}

// Log events for policy based extension installs
//
// Setting the policy to True sends reports of key, policy-triggered extension
// installation events to Google. Setting the policy to False means no events
// are captured. If the policy is unset, default value is set to True.
//
// Supported on: chrome_os
message ExtensionInstallEventLoggingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ExtensionInstallEventLoggingEnabled = 2;
}

// Time Limit
//
// Allows you to lock the user's session based on the client time or the usage
// quota of the day.
//
// The |time_window_limit| specifies a daily window in which the user's session
// should be locked. We only support one rule for each day of the week,
// therefore the |entries| array may vary from 0-7 in size. |starts_at| and
// |ends_at| are the beginning and the end of the window limit, when |ends_at|
// is smaller than |starts_at| it means that the |time_limit_window| ends on the
// following day. |last_updated_millis| is the UTC timestamp for the last time
// this entry was updated, it is sent as a string because the timestamp wouldn't
// fit in an integer.
//
// The |time_usage_limit| specifies a daily screen quota, so when the user
// reaches it, the user's session is locked. There is a property for each day of
// the week, and it should be set only if there is an active quota for that day.
// |usage_quota_mins| is the amount of time that the managed device can be use
// in a day and |reset_at| is the time when the usage quota is renewed. The
// default value for |reset_at| is midnight ({'hour': 0, 'minute': 0}).
// |last_updated_millis| is the UTC timestamp for the last time this entry was
// updated, it is sent as a string because the timestamp wouldn't fit in an
// integer.
//
// |overrides| is provided to invalidate temporarily one or more of the previous
// rules.
// * If neither time_window_limit nor time_usage_limit is active |LOCK| can be
// used to lock the device.
// * |LOCK| temporarily locks a user session until the next time_window_limit or
// time_usage_limit starts.
// * |UNLOCK| unlocks a user's session locked by time_window_limit or
// time_usage_limit.
// |created_time_millis| is the UTC timestamp for the override creation, it is
// sent as a String because the timestamp wouldn't fit in an integer It is used
// to determine whether this override should still be applied. If the current
// active time limit feature (time usage limit or time window limit) started
// after the override was created, it should not take action. Also if the
// override was created before the last change of the active time_window_limit
// or time_usage_window it should not be applied.
//
// Multiple overrides may be sent, the newest valid entry is the one that is
// going to be applied.
//
// Value schema:
// {
//     "properties": {
//         "overrides": {
//             "items": {
//                 "properties": {
//                     "action": {
//                         "enum": [
//                             "LOCK",
//                             "UNLOCK"
//                         ],
//                         "type": "string"
//                     },
//                     "action_specific_data": {
//                         "properties": {
//                             "duration_mins": {
//                                 "minimum": 0,
//                                 "type": "integer"
//                             }
//                         },
//                         "type": "object"
//                     },
//                     "created_at_millis": {
//                         "type": "string"
//                     }
//                 },
//                 "type": "object"
//             },
//             "type": "array"
//         },
//         "time_usage_limit": {
//             "properties": {
//                 "friday": {
//                     "$ref": "TimeUsageLimitEntry"
//                 },
//                 "monday": {
//                     "id": "TimeUsageLimitEntry",
//                     "properties": {
//                         "last_updated_millis": {
//                             "type": "string"
//                         },
//                         "usage_quota_mins": {
//                             "minimum": 0,
//                             "type": "integer"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "reset_at": {
//                     "$ref": "Time"
//                 },
//                 "saturday": {
//                     "$ref": "TimeUsageLimitEntry"
//                 },
//                 "sunday": {
//                     "$ref": "TimeUsageLimitEntry"
//                 },
//                 "thursday": {
//                     "$ref": "TimeUsageLimitEntry"
//                 },
//                 "tuesday": {
//                     "$ref": "TimeUsageLimitEntry"
//                 },
//                 "wednesday": {
//                     "$ref": "TimeUsageLimitEntry"
//                 }
//             },
//             "type": "object"
//         },
//         "time_window_limit": {
//             "properties": {
//                 "entries": {
//                     "items": {
//                         "properties": {
//                             "effective_day": {
//                                 "$ref": "WeekDay"
//                             },
//                             "ends_at": {
//                                 "$ref": "Time"
//                             },
//                             "last_updated_millis": {
//                                 "type": "string"
//                             },
//                             "starts_at": {
//                                 "$ref": "Time"
//                             }
//                         },
//                         "type": "object"
//                     },
//                     "type": "array"
//                 }
//             },
//             "type": "object"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message UsageTimeLimitProto {
  optional PolicyOptions policy_options = 1;
  optional string UsageTimeLimit = 2;
}

// Control Android backup and restore service
//
// Setting the policy to BackupAndRestoreEnabled means Android backup and
// restore is initially on. Setting the policy to BackupAndRestoreDisabled or
// leaving it unset keeps backup and restore off during setup.
//
// Setting the policy to BackupAndRestoreUnderUserControl means users see
// prompts to use backup and restore. If they turn on backup and restore,
// Android app data is uploaded to Android backup servers and restored during
// reinstallations of compatible apps.
//
// After initial setup, users can turn backup and restore on or off.
//
// Valid values:
//   0: Backup and restore disabled
//   1: User decides whether to enable backup and restore
//   2: Backup and restore enabled
//
// Supported on: chrome_os
message ArcBackupRestoreServiceEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ArcBackupRestoreServiceEnabled = 2;
}

// Control Android Google location services
//
// Unless the DefaultGeolocationSetting policy is set to BlockGeolocation, then
// setting GoogleLocationServicesEnabled turns Google location services on
// during initial setup. Setting the policy to GoogleLocationServicesDisabled or
// leaving it unset keeps location services off during setup.
//
// Setting policy to BackupAndRestoreUnderUserControl prompts users about
// whether or not to use Google location services. If they turn it on, Android
// apps use the services to search the device location and send anonymous
// location data to Google.
//
// After initial setup, users can turn Google location services on or off.
//
// Valid values:
//   0: Google location services disabled
//   1: User decides whether to enable Google location services
//   2: Google location services enabled
//
// Supported on: chrome_os
message ArcGoogleLocationServicesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ArcGoogleLocationServicesEnabled = 2;
}

// Enable displaying Sync Consent during sign-in
//
// This policy controls if Sync Consent can be shown to the user during first
// sign-in. It should be set to false if Sync Consent is never needed for the
// user.
// If set to false, Sync Consent will not be displayed.
// If set to true or unset, Sync Consent can be displayed.
//
// Supported on: chrome_os
message EnableSyncConsentProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableSyncConsent = 2;
}

// Enable contextual suggestions of related web pages
//
// This feature never launched, therefore the policy is deprecated. If this is
// set to true or unset, Google Chrome will suggest pages related to the current
// page.
// These suggestions are fetched remotely from Google servers.
//
// If this setting is set to false, suggestions will not be fetched or
// displayed.
//
// Supported on:
message ContextualSuggestionsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ContextualSuggestionsEnabled = 2;
}

// Enable showing full-tab promotional content
//
// Setting the policy to True or leaving it unset lets Google Chrome show users
// product information as full-tab content.
//
// Setting the policy to False prevents Google Chrome from showing product
// information as full-tab content.
//
// Setting the policy controls the presentation of the welcome pages that help
// users sign in to Google Chrome, set Google Chrome as users' default browser,
// or otherwise inform them of product features.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PromotionalTabsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PromotionalTabsEnabled = 2;
}

// Control SafeSites adult content filtering.
//
// Setting the policy controls the SafeSites URL filter, which uses the Google
// Safe Search API to classify URLs as pornographic or not.
//
// When this policy is set to:
//
// * Do not filter sites for adult content, or not set, sites aren't filtered
//
// * Filter top level sites for adult content, pornographic sites are filtered
//
// Valid values:
//   0: Do not filter sites for adult content
//   1: Filter top level sites (but not embedded iframes) for adult content
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SafeSitesFilterBehaviorProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SafeSitesFilterBehavior = 2;
}

// Origins or hostname patterns for which restrictions on
//       insecure origins should not apply
//
// Setting the policy specifies a list of origins (URLs) or hostname patterns
// (such as *.example.com) for which security restrictions on insecure origins
// won't apply. Organizations can specify origins for legacy applications that
// can't deploy TLS or set up a staging server for internal web development, so
// developers can test out features requiring secure contexts without having to
// deploy TLS on the staging server. This policy also prevents the origin from
// being labeled "Not Secure" in the address bar.
//
// Setting a list of URLs in this policy amounts to setting the command-line
// flag --unsafely-treat-insecure-origin-as-secure to a comma-separated list of
// the same URLs. The policy overrides the command-line flag and
// UnsafelyTreatInsecureOriginAsSecure, if present.
//
// For more information on secure contexts, see Secure Contexts (
// https://www.w3.org/TR/secure-contexts ).
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message OverrideSecurityRestrictionsOnInsecureOriginProto {
  optional PolicyOptions policy_options = 1;
  optional StringList OverrideSecurityRestrictionsOnInsecureOrigin = 2;
}

// Allow background tabs freeze
//
// Controls whether Google Chrome can freeze tabs that have been in the
// background for at least 5 minutes.
//
// If the policy is set to true, tabs that have been in the background for at
// least 5 minutes may be frozen. Tab freezing reduces CPU, battery and memory
// usage. Google Chrome uses heuristics to avoid freezing tabs that do useful
// work in the background (e.g. display notifications, play sound, stream
// video). Web developers can also opt-out their site from freezing (https://chr
// omium.googlesource.com/chromium/src/+/HEAD/chrome/browser/performance_manager
// /docs/freezing_opt_out_opt_in.md).
//
// If the policy is set to false, no tabs will be frozen.
//
// Supported on:
message TabFreezingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool TabFreezingEnabled = 2;
}

// Enable URL-keyed anonymized data collection
//
// Setting the policy to Enabled means URL-keyed anonymized data collection,
// which sends URLs of pages the user visits to Google to make searches and
// browsing better, is always active.
//
// Setting the policy to Disabled results in no URL-keyed anonymized data
// collection.
//
// If you set the policy, users can't change. If not set, then URL-keyed
// anonymized data collection at first, but users can change it.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message UrlKeyedAnonymizedDataCollectionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool UrlKeyedAnonymizedDataCollectionEnabled = 2;
}

// Controls Network File Shares for ChromeOS availability
//
// Setting the policy to Enabled lets users use Network File Shares for Google
// ChromeOS. Setting the policy to Disabled means users can't use this feature.
//
// Supported on: chrome_os
message NetworkFileSharesAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool NetworkFileSharesAllowed = 2;
}

// Allow collection of WebRTC event logs from Google services
//
// Setting the policy to Enabled means Google Chrome can collect WebRTC event
// logs from Google services such as Hangouts Meet and upload them to Google.
// These logs have diagnostic information for debugging issues with audio or
// video meetings in Google Chrome, such as the time and size of RTP packets,
// feedback about congestion on the network, and metadata about time and quality
// of audio and video frames. These logs have no audio or video content from the
// meeting. To make debugging easier, Google might associate these logs, by
// means of a session ID, with other logs collected by the Google service
// itself.
//
// Setting the policy to Disabled results in no collection or uploading of such
// logs.
//
// Leaving the policy unset on versions up to and including M76 means Google
// Chrome defaults to not being able to collect and upload these logs. Starting
// at M77, Google Chrome defaults to being able to collect and upload these logs
// from most profiles affected by cloud-based, user-level enterprise policies.
// From M77 up to and including M80, Google Chrome can also collect and upload
// these logs by default from profiles affected by Google Chrome on-premise
// management.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebRtcEventLogCollectionAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebRtcEventLogCollectionAllowed = 2;
}

// Enable smart dim model to extend the time until the screen is dimmed
//
// Setting the policy to Enabled or leaving it unset turns the smart dim model
// on and can extend the time until the screen dims. If it delays the time, the
// screen off, screen lock, and idle delays adjust to maintain the same
// distances from the screen dim delay as originally set.
//
// Setting the policy to Disabled means the smart dim model won't influence
// screen dimming.
//
// Supported on: chrome_os
message PowerSmartDimEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PowerSmartDimEnabled = 2;
}

// Allow coalescing of HTTP/2 connections for these hosts even when client
// certificates are used
//
// This policy allows HTTP/2 connection coalescing when client certificates are
// in use. In order to coalesce, both the hostname of the potential new
// connection and the hostname of an existing connection must match one or more
// patterns described by this policy. The policy is a list of hosts using the
// URLBlocklist filter format: "example.com" matches "example.com" and all
// subdomains (e.g. "sub.example.com"), while ".example.net" matches exactly
// "example.net".
//
// Coalescing requests to different hosts over connections that use client
// certificates can create security and privacy issues, as the ambient authority
// will be conveyed to all requests, even if the user did not explicitly
// authorize this. This policy is temporary and will be removed in a future
// release. See https://crbug.com/855690.
//
// If this policy is left unset, then the default behavior of not allowing any
// HTTP/2 connection coalescing on connections using client certificates will be
// used.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CoalesceH2ConnectionsWithClientCertificatesForHostsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CoalesceH2ConnectionsWithClientCertificatesForHosts = 2;
}

// Controls Network File Share discovery via NetBIOS
//
// Setting the policy to Enabled means share discovery (the Network File Shares
// feature for Google ChromeOS) uses the NetBIOS Name Query Request protocol to
// discover shares on the network. Setting the policy to Disabled means share
// discovery won't use this protocol to discover shares.
//
// Leaving the policy unset means the behavior defaults to off for managed users
// and on for other users.
//
// Supported on: chrome_os
message NetBiosShareDiscoveryEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NetBiosShareDiscoveryEnabled = 2;
}

// Sets managed configuration values to websites to specific origins
//
// Setting the policy defines the return value of Managed Configuration API for
// given origin.
//
// Managed configuration API is a key-value configuration that can be accessed
// via navigator.managed.getManagedConfiguration() javascript call. This API is
// only available to origins which correspond to force-installed web
// applications via WebAppInstallForceList.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "managed_configuration_hash": {
//                 "type": "string"
//             },
//             "managed_configuration_url": {
//                 "type": "string"
//             },
//             "origin": {
//                 "type": "string"
//             }
//         },
//         "required": [
//             "origin",
//             "managed_configuration_url",
//             "managed_configuration_hash"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ManagedConfigurationPerOriginProto {
  optional PolicyOptions policy_options = 1;
  optional string ManagedConfigurationPerOrigin = 2;
}

// Configure list of force-installed Web Apps
//
// Setting the policy specifies a list of web apps that install silently,
// without user interaction, and which users can't uninstall or turn off.
//
// Each list item of the policy is an object with a mandatory member:
// url (the URL of the web app to install)
//
// and 5 optional members:
// - default_launch_container
// (for how the web app opens—a new tab is the default)
//
// - create_desktop_shortcut
// (True if you want to create Linux and
// Microsoft® Windows® desktop shortcuts).
//
// - fallback_app_name
// (Starting with Google Chrome version 90,
// allows you to override the app name if it is not a
// Progressive Web App (PWA), or the app name that is temporarily
// installed if it is a PWA but authentication is required before the
// installation can be completed. If both
// custom_name and
// fallback_app_name are provided,
// the latter will be ignored.)
//
// - custom_name
// (Starting with Google Chrome
// version 99, allows you to permanently override the app name for all web
// apps and PWAs. Currently only supported on
// Google ChromeOS.)
//
// - custom_icon
// (Starting with Google Chrome
// version 99, allows you to override the app icon of installed apps. The
// icons have to be square, maximal 1 MB in size, and in one of the following
// formats: jpeg, png, gif, webp, ico. The hash value has to be the SHA256
// hash of the icon file. Currently only supported on
// Google ChromeOS.)
//
// See PinnedLauncherApps for pinning apps to the Google ChromeOS shelf.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "create_desktop_shortcut": {
//                 "type": "boolean"
//             },
//             "custom_icon": {
//                 "properties": {
//                     "hash": {
//                         "type": "string"
//                     },
//                     "url": {
//                         "type": "string"
//                     }
//                 },
//                 "required": [
//                     "url",
//                     "hash"
//                 ],
//                 "type": "object"
//             },
//             "custom_name": {
//                 "type": "string"
//             },
//             "default_launch_container": {
//                 "enum": [
//                     "tab",
//                     "window"
//                 ],
//                 "type": "string"
//             },
//             "fallback_app_name": {
//                 "type": "string"
//             },
//             "url": {
//                 "type": "string"
//             }
//         },
//         "required": [
//             "url"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebAppInstallForceListProto {
  optional PolicyOptions policy_options = 1;
  optional string WebAppInstallForceList = 2;
}

// Report OS and Google Chrome Version Information
//
// This policy controls whether to report version information, such as OS
// version, OS platform, OS architecture, Google Chrome version and Google
// Chrome channel.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored.
//
// When this policy is left unset or set to True, version information is
// gathered.
// When this policy is set to False, version information is not gathered.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
// This policy is always effective for Google ChromeOS.
//
// Supported on: linux, mac, win
message ReportVersionDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportVersionData = 2;
}

// Report Google Chrome Policy Information
//
// This policy controls whether to report policy data and time of policy fetch.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored.
//
// When this policy is left unset or set to True, policy data and time of policy
// fetch are gathered.
// When this policy is set to False, policy data and time of policy fetch are
// not gathered.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
// This policy is always effective for Google ChromeOS.
//
// Supported on: linux, mac, win
message ReportPolicyDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportPolicyData = 2;
}

// Report Machine Identification information
//
// This policy controls whether to report information that can be used to
// identify machines, such as machine name and network addresses.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored.
//
// When this policy is left unset or set to True, information that can be used
// to identify machines is gathered.
// When this policy is set to False, information that can be used to identify
// machines is not gathered.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
//
// Supported on: linux, mac, win
message ReportMachineIDDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportMachineIDData = 2;
}

// Report User Identification information
//
// This policy controls whether to report information that can be used to
// identify users, such as OS login, Google Chrome Profile login, Google Chrome
// Profile name, Google Chrome Profile path and Google Chrome executable path.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored.
//
// When this policy is left unset or set to True, information that can be used
// to identify users is gathered.
// When this policy is set to False, information that can be used to identify
// users is not gathered.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
// This policy is always effective for Google ChromeOS.
//
// Supported on: linux, mac, win
message ReportUserIDDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportUserIDData = 2;
}

// Report Extensions and Plugins information
//
// This policy controls whether to report extensions and plugins information.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored.
//
// When this policy is left unset or set to True, extension and plugins data are
// gathered.
// When this policy is set to False, extensions and plugins data are not
// gathered.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
// This policy is always effective for Google ChromeOS.
//
// Supported on: linux, mac, win
message ReportExtensionsAndPluginsDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportExtensionsAndPluginsData = 2;
}

// Report Safe Browsing information
//
// This policy controls whether to report Safe Browsing information including
// the number of Safe Browsing warning and the number of safe browsering warning
// click through.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored.
//
// When this policy is left unset or set to True, Safe Browsing data are
// gathered.
// When this policy is set to False, Safe Browsing data are not gathered.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
// This policy is always effective for Google ChromeOS.
//
// Supported on:
message ReportSafeBrowsingDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool ReportSafeBrowsingData = 2;
}

// Enables Google Chrome extension installation requests
//
// This policy controls Google Chrome extension installation requests which
// allows users to send the requests to the Google Admin console for approval.
//
// When the policy CloudReportingEnabled is left unset or set to disabled, this
// policy will be ignored, extension installation requests are not created or
// uploaded.
// When this policy is left unset or set to disabled, extension installation
// requests are not created or uploaded.
// When this policy is set to enabled, extension installation requests are
// created and uploaded to Google Admin console.
//
// Extension installation requests are created when users try to install an
// extension that is not allowed by ExtensionInstallAllowlist or
// ExtensionSettings.
//
// This policy is only effective when the machine is enrolled with
// CloudManagementEnrollmentToken for Google Chrome.
// This policy is always effective for Google ChromeOS.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message CloudExtensionRequestEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudExtensionRequestEnabled = 2;
}

// Enables Google Chrome cloud reporting
//
// This policy controls Google Chrome cloud reporting which uploads information
// about the browser operation to Google Admin console.
//
// When this policy is left unset or set to Disabled, there is no data collected
// or uploaded.
// When this policy is set to Enabled, the data is collected and uploaded to
// Google Admin console.
//
// For Google Chrome, this policy is only effective when the machine is enrolled
// with CloudManagementEnrollmentToken.
// For Google ChromeOS, this policy is always effective.
//
// Valid values:
//   True: Enable managed browser cloud reporting
//   False: Disable managed browser cloud reporting
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message CloudReportingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudReportingEnabled = 2;
}

// Enable Google Chrome cloud reporting for managed profile
//
//
// This policy controls Google Chrome cloud reporting for a particular managed
// profile.
//
// When this policy is left unset or set to Disabled, there is no data collected
// or uploaded.
// When this policy is set to Enabled, the data is collected and uploaded to
// Google Admin console.
//
// The report contains profile state and usage information, including but not
// limited to OS version, browser version, installed extensions and applied
// policies.
//
// This policy can only be set as cloud user policy.
//
// Valid values:
//   True: Enable managed profile cloud reporting
//   False: Disable managed profile cloud reporting
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CloudProfileReportingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudProfileReportingEnabled = 2;
}

// Frequency of cloud reporting in hours
//
//
// Controls the frequency of Chrome status report uploads.
//
// This includes reports that are enabled by CloudReportingEnabled.
//
// When the policy is not set, reports are uploaded every 24 hours.
// When the policy is set, the number of hours between two successive report
// uploads is defined by this policy.
//
// Supported on: android, chrome_os, fuchsia, ios, linux, mac, win
message CloudReportingUploadFrequencyProto {
  optional PolicyOptions policy_options = 1;
  optional int64 CloudReportingUploadFrequency = 2;
}

// Enables managed extensions to use the Enterprise Hardware Platform API
//
// Setting the policy to True lets extensions installed by enterprise policy use
// the Enterprise Hardware Platform API.
//
// Setting the policy to False or leaving it unset prevents extensions from
// using this API.
//
// Note: This policy also applies to component extensions, such as the Hangout
// Services extension.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message EnterpriseHardwarePlatformAPIEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnterpriseHardwarePlatformAPIEnabled = 2;
}

// Allow the user to manage VPN connections
//
// Setting the policy to Enabled or leaving it unset lets users manage
// (disconnect or modify) VPN connections. If the VPN connection is created
// using a VPN app, the UI inside the app isn't affected. So, users might still
// be able to use the app to modify the VPN connection. Use this policy with the
// Always on VPN feature, which lets the admin decide to establish a VPN
// connection when starting a device.
//
// Setting the policy to Disabled turns off the Google ChromeOS user interfaces
// that would let the user disconnect or modify VPN connections.
//
// Supported on: chrome_os
message VpnConfigAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool VpnConfigAllowed = 2;
}

// Controls enabling NTLM as an authentication protocol for SMB mounts
//
// Setting the policy to Enabled means the Network File Shares feature for
// Google ChromeOS uses NTLM for authentication to SMB shares if necessary.
// Setting the policy to Disabled turns off NTLM authentication to SMB shares.
//
// Leaving the policy unset means the behavior defaults to off for managed users
// and on for other users.
//
// Supported on: chrome_os
message NTLMShareAuthenticationEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NTLMShareAuthenticationEnabled = 2;
}

// List of preconfigured network file shares.
//
// Setting the policy specifies a list of preset network file shares. Each item
// is an object with 2 properties: share_url and mode.
//
// The share URL should be share_url.
//
// For mode, it should be drop_down or pre_mount:
//
// * drop_down indicates that share_url will be added to the share discovery
// list.
//
// * pre_mount indicates that share_url will be mounted.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "mode": {
//                 "enum": [
//                     "drop_down",
//                     "pre_mount"
//                 ],
//                 "type": "string"
//             },
//             "share_url": {
//                 "type": "string"
//             }
//         },
//         "required": [
//             "share_url",
//             "mode"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os
message NetworkFileSharesPreconfiguredSharesProto {
  optional PolicyOptions policy_options = 1;
  optional string NetworkFileSharesPreconfiguredShares = 2;
}

// Screen brightness percent
//
// Setting the policy specifies screen brightness percent, turning
// autobrightness features off. Initial screen brightness adjusts to the policy
// value, but users can change it.
//
// Leaving the policy unset doesn't affect user screen controls or
// autobrightness features.
//
// Note: The policy values should be specified in percents from 0 to 100.
//
// Value schema:
// {
//     "properties": {
//         "BrightnessAC": {
//             "description": "Screen brightness percent when running on AC
// power",
//             "maximum": 100,
//             "minimum": 0,
//             "type": "integer"
//         },
//         "BrightnessBattery": {
//             "description": "Screen brightness percent when running on battery
// power",
//             "maximum": 100,
//             "minimum": 0,
//             "type": "integer"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message ScreenBrightnessPercentProto {
  optional PolicyOptions policy_options = 1;
  optional string ScreenBrightnessPercent = 2;
}

// Alternative browser to launch for configured websites.
//
// Setting the policy controls which command to use to open URLs in an
// alternative browser. The policy can be set to one of ${ie}, ${firefox},
// ${safari}, ${opera}, ${edge} or a file path. When this policy is set to a
// file path, that file is used as an executable file. ${ie} is only available
// on Microsoft® Windows®. ${safari} and ${edge} are only available on
// Microsoft® Windows® and macOS.
//
// Leaving the policy unset puts a platform-specific default in use: Internet
// Explorer® for Microsoft® Windows®, or Safari® for macOS. On Linux®, launching
// an alternative browser will fail.
//
// Supported on: fuchsia, linux, mac, win
message AlternativeBrowserPathProto {
  optional PolicyOptions policy_options = 1;
  optional string AlternativeBrowserPath = 2;
}

// Command-line parameters for the alternative browser.
//
// Setting the policy to a list of strings means each string is passed to the
// alternative browser as separate command-line parameters. On Microsoft®
// Windows®, the parameters are joined with spaces. On macOS and Linux®, a
// parameter can have spaces and still be treated as a single parameter.
//
// If an parameter contains ${url}, ${url} is replaced with the URL of the page
// to open. If no parameter contains ${url}, the URL is appended at the end of
// the command line.
//
// Environment variables are expanded. On Microsoft® Windows®, %ABC% is replaced
// with the value of the ABC environment variable. On macOS and Linux®, ${ABC}
// is replaced with the value of the ABC environment variable.
//
// Leaving the policy unset means only the URL is passed as a command-line
// parameter.
//
// Supported on: fuchsia, linux, mac, win
message AlternativeBrowserParametersProto {
  optional PolicyOptions policy_options = 1;
  optional StringList AlternativeBrowserParameters = 2;
}

// Path to Chrome for switching from the alternative browser.
//
// This policy controls the command to use to open URLs in Google Chrome when
// switching from Internet Explorer®. This policy can be set to an executable
// file path or ${chrome} to autodetect the location of Google Chrome.
//
// Leaving the policy unset means Internet Explorer® autodetects Google Chrome's
// own executable path when launching Google Chrome from Internet Explorer.
//
// Note: If the Legacy Browser Support add-in for Internet Explorer® isn't
// installed, this policy has no effect.
//
// Supported on: win
message BrowserSwitcherChromePathProto {
  optional PolicyOptions policy_options = 1;
  optional string BrowserSwitcherChromePath = 2;
}

// Command-line parameters for switching from the alternative browser.
//
// Setting the policy to a list of strings means the strings are joined with
// spaces and passed from Internet Explorer® to Google Chrome as command-line
// parameters. If an parameter contains ${url}, ${url} is replaced with the URL
// of the page to open. If no parameter contains ${url}, the URL is appended at
// the end of the command line.
//
// Environment variables are expanded. On Microsoft® Windows®, %ABC% is replaced
// with the value of the ABC environment variable.
//
// Leaving the policy unset means Internet Explorer® only passes the URL to
// Google Chrome as a command-line parameter.
//
// Note: If the Legacy Browser Support add-in for Internet Explorer® isn't
// installed, this policy has no effect.
//
// Supported on: win
message BrowserSwitcherChromeParametersProto {
  optional PolicyOptions policy_options = 1;
  optional StringList BrowserSwitcherChromeParameters = 2;
}

// Websites to open in alternative browser
//
// Setting the policy controls the list of websites to open in an alternative
// browser. Each item is treated as a rule for something to open in an
// alternative browser. Google Chrome uses those rules when choosing if a URL
// should open in an alternative browser. When the Internet Explorer® add-in is
// on, Internet Explorer® switches back to Google Chrome when the rules don't
// match. If rules contradict each other, Google Chrome uses the most specific
// rule.
//
// Leaving the policy unset adds no websites to the list.
//
// Note: Elements can also be added to this list through the
// BrowserSwitcherUseIeSitelist and BrowserSwitcherExternalSitelistUrl policies.
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherUrlListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList BrowserSwitcherUrlList = 2;
}

// Websites that should never trigger a browser switch.
//
// Setting the policy controls the list of websites that will never cause a
// browser switch. Each item is treated as a rule. Those rules that match won't
// open an alternative browser. Unlike the BrowserSwitcherUrlList policy, rules
// apply to both directions. When the Internet Explorer® add-in is on, it also
// controls whether Internet Explorer® should open these URLs in Google Chrome.
//
// Leaving the policy unset adds no websites to the list.
//
// Note: Elements can also be added to this list through the
// BrowserSwitcherExternalGreylistUrl policy.
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherUrlGreylistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList BrowserSwitcherUrlGreylist = 2;
}

// Use Internet Explorer's SiteList policy for Legacy Browser Support.
//
// This policy controls whether to load rules from Internet Explorer®'s SiteList
// policy.
//
// When this policy is set to true, Google Chrome reads Internet Explorer®'s
// SiteList to obtain the site list's URL. Google Chrome then downloads the site
// list from that URL, and applies the rules as if they had been configured with
// the BrowserSwitcherUrlList policy.
//
// When this policy is false or unset, Google Chrome does not use Internet
// Explorer®'s SiteList policy as a source of rules for switching browsers.
//
// For more information on Internet Explorer's SiteList policy:
// https://docs.microsoft.com/internet-explorer/ie11-deploy-guide/what-is-
// enterprise-mode
//
// Supported on: win
message BrowserSwitcherUseIeSitelistProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserSwitcherUseIeSitelist = 2;
}

// URL of an XML file that contains URLs to load in an alternative browser.
//
// Setting the policy to a valid URL has Google Chrome download the site list
// from that URL and apply the rules as if they were set up with the
// BrowserSwitcherUrlList policy.
//
// Leaving it unset (or set to a invalid URL) means Google Chrome doesn't use
// the policy as a source of rules for switching browsers.
//
// Note: This policy points to an XML file in the same format as Internet
// Explorer®'s SiteList policy. This loads rules from an XML file, without
// sharing those rules with Internet Explorer®. Read more on Internet
// Explorer®'s SiteList policy ( https://docs.microsoft.com/internet-
// explorer/ie11-deploy-guide/what-is-enterprise-mode)
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherExternalSitelistUrlProto {
  optional PolicyOptions policy_options = 1;
  optional string BrowserSwitcherExternalSitelistUrl = 2;
}

// URL of an XML file that contains URLs that should never trigger a browser
// switch.
//
// Setting the policy to a valid URL has Google Chrome download the site list
// from that URL and apply the rules as if they were set up with the
// BrowserSwitcherUrlGreylist policy. These policies prevent Google Chrome and
// the alternative browser from opening one another.
//
// Leaving it unset (or set to a invalid URL) means Google Chrome doesn't use
// the policy as a source of rules for not switching browsers.
//
// Note: This policy points to an XML file in the same format as Internet
// Explorer®'s SiteList policy. This loads rules from an XML file, without
// sharing those rules with Internet Explorer®. Read more on Internet
// Explorer®'s SiteList policy ( https://docs.microsoft.com/internet-
// explorer/ie11-deploy-guide/what-is-enterprise-mode )
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherExternalGreylistUrlProto {
  optional PolicyOptions policy_options = 1;
  optional string BrowserSwitcherExternalGreylistUrl = 2;
}

// Delay before launching alternative browser (milliseconds)
//
// Setting the policy to a number has Google Chrome show a message for that
// number of milliseconds, then it opens an alternative browser.
//
// Leaving the policy unset or set to 0 means navigating to a designated URL
// immediately opens it in an alternative browser.
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherDelayProto {
  optional PolicyOptions policy_options = 1;
  optional int64 BrowserSwitcherDelay = 2;
}

// Enable the Legacy Browser Support feature.
//
// Setting the policy to Enabled means Google Chrome will try to launch some
// URLs in an alternate browser, such as Internet Explorer®. This feature is set
// using the policies in the Legacy Browser support group.
//
// Setting the policy to Disabled or leaving it unset means Google Chrome won't
// try to launch designated URLs in an alternate browser.
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserSwitcherEnabled = 2;
}

// Sitelist parsing mode
//
// This policy controls how Google Chrome interprets sitelist/greylist policies
// for the Legacy Browser Support feature. It affects the following policies:
// BrowserSwitcherUrlList, BrowserSwitcherUrlGreylist,
// BrowserSwitcherUseIeSitelist, BrowserSwitcherExternalSitelistUrl, and
// BrowserSwitcherExternalGreylistUrl.
//
// If 'Default' (0) or unset, URL matching is less strict. Rules that do not
// contain "/" look for a substring anywhere in the URL's hostname. Matching the
// path component of a URL is case-sensitive.
//
// If 'IESiteListMode' (1), URL matching is more strict. Rules that do not
// contain "/" only match at the end of the hostname. They must also be at a
// domain name boundary. Matching the path component of a URL is case-
// insensitive. This is more compatible with Microsoft® Internet Explorer® and
// Microsoft® Edge®.
//
// For example, with the rules "example.com" and "acme.com/abc":
//
// "http://example.com/", "http://subdomain.example.com/" and
// "http://acme.com/abc" match regardless of parsing mode.
//
// "http://notexample.com/", "http://example.com.invalid.com/",
// "http://example.comabc/" only match in 'Default' mode.
//
// "http://acme.com/ABC" only matches in 'IESiteListMode'.
//
// Valid values:
//   0: Default behavior for LBS.
//   1: More compatible with Microsoft IE/Edge enterprise mode sitelists.
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherParsingModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 BrowserSwitcherParsingMode = 2;
}

// Keep last tab open in Chrome.
//
// Setting the policy to Enabled or leaving it unset has Google Chrome keep at
// least one tab open, after switching to an alternate browser.
//
// Setting the policy to Disabled has Google Chrome close the tab after
// switching to an alternate browser, even if it was the last tab. This causes
// Google Chrome to exit completely.
//
// Supported on: fuchsia, linux, mac, win
message BrowserSwitcherKeepLastChromeTabProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserSwitcherKeepLastChromeTab = 2;
}

// Allow users to use a PluginVm on Google ChromeOS
//
// Allow this user to run PluginVm.
//
// If the policy is set to false or left unset, PluginVm is not enabled for the
// user.
// If set to true, PluginVm is enabled for the user as long as other settings
// also allow it. PluginVmAllowed and UserPluginVmAllowed need to be true, and
// either PluginVmLicenseKey or PluginVmUserId need to be set for PluginVm to be
// allowed to run.
//
// Supported on: chrome_os
message UserPluginVmAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserPluginVmAllowed = 2;
}

// PluginVm user id
//
// This policy specifies the PluginVm licensing user id for this device.
//
// Supported on: chrome_os
message PluginVmUserIdProto {
  optional PolicyOptions policy_options = 1;
  optional string PluginVmUserId = 2;
}

// PluginVm image
//
// Setting the policy specifies the PluginVm image for a user. Specify this
// policy as a JSON format string, with URL stating where to download the image
// and hash as a SHA-256 hash used to verify the integrity of the download.
//
// Value schema:
// {
//     "properties": {
//         "hash": {
//             "description": "The SHA-256 hash of the <ph
// name=\"PLUGIN_VM_NAME\">PluginVm</ph> image.",
//             "type": "string"
//         },
//         "url": {
//             "description": "The URL from which the <ph
// name=\"PLUGIN_VM_NAME\">PluginVm</ph> image can be downloaded.",
//             "type": "string"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message PluginVmImageProto {
  optional PolicyOptions policy_options = 1;
  optional string PluginVmImage = 2;
}

// Allow PluginVm Product Analytics
//
// Allow PluginVm to collect PluginVm usage data.
//
// If the policy is set to false or left unset, PluginVm is not allowed to
// collect data.
// If set to true, PluginVm might collect PluginVm usage data that is then
// combined and thoroughly analyzed to improve PluginVm experience.
//
// Supported on: chrome_os
message PluginVmDataCollectionAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool PluginVmDataCollectionAllowed = 2;
}

// Required free disk space for PluginVm
//
// Free disk space (in GB) required to install PluginVm.
//
// If this policy is left unset, PluginVm installation fails if free disk space
// available on the device is less than 20 GB (default value).
// If this policy is set, PluginVm installation fails if free disk space
// available on the device is less than required by policy.
//
// Supported on: chrome_os
message PluginVmRequiredFreeDiskSpaceProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PluginVmRequiredFreeDiskSpace = 2;
}

// Parent Access Code Configuration
//
// This policy specifies configuration that is used to generate and verify
// Parent Access Code.
//
// |current_config| is always used for generating access code and should be used
// for validating access code only when it cannot be validated with
// |future_config|.
// |future_config| is the primary config used for validating access code.
// |old_configs| should be used for validating access code only when it cannot
// be validated with |future_config| nor |current_config|.
//
// The expected way of using this policy is to gradually rotate access code
// configuration. New configuration is always put into |future_config| and at
// the same
// time the existing value is moved into |current_config|. |current_config|'s
// previous values are moved into |old_configs| and removed after rotation cycle
// is finished.
//
// This policy applies only to child user.
// When this policy is set Parent Access Code can be verified on child user's
// device.
// When this policy is unset it is not possible to verify Parent Access Code on
// child user's device.
//
// Value schema:
// {
//     "properties": {
//         "current_config": {
//             "description": "Configuration used to generate and verify Parent
// Access Code.",
//             "id": "Config",
//             "properties": {
//                 "access_code_ttl": {
//                     "description": "Time that access code is valid for (in
// seconds).",
//                     "maximum": 3600,
//                     "minimum": 60,
//                     "type": "integer"
//                 },
//                 "clock_drift_tolerance": {
//                     "description": "The allowed difference between the clock
// on child and parent devices (in seconds).",
//                     "maximum": 1800,
//                     "minimum": 0,
//                     "type": "integer"
//                 },
//                 "shared_secret": {
//                     "description": "Secret shared between child and parent
// devices.",
//                     "type": "string"
//                 }
//             },
//             "type": "object"
//         },
//         "future_config": {
//             "$ref": "Config"
//         },
//         "old_configs": {
//             "items": {
//                 "$ref": "Config"
//             },
//             "type": "array"
//         }
//     },
//     "sensitiveValue": true,
//     "type": "object"
// }
//
// Supported on: chrome_os
message ParentAccessCodeConfigProto {
  optional PolicyOptions policy_options = 1;
  optional string ParentAccessCodeConfig = 2;
}

// Allow users to manage installed client certificates.
//
// Setting the policy to 'All' (value 0) or leaving it unset lets users manage
// certificates. Setting the policy to 'None' (value 2) means users can only
// view (not manage) certificates.
//
// Setting the policy to 'UserOnly' (value 1) lets users manage user
// certificates, but not device-wide certificates.
//
// Valid values:
//   0: Allow users to manage all certificates
//   1: Allow users to manage user certificates
//   2: Disallow users from managing certificates
//
// Supported on: chrome_os
message ClientCertificateManagementAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ClientCertificateManagementAllowed = 2;
}

// Force networking code to run in the browser process
//
// This policy is deprecated.
//
// Supported on:
message ForceNetworkInProcessProto {
  optional PolicyOptions policy_options = 1;
  optional bool ForceNetworkInProcess = 2;
}

// Mode of the Assistant onboarding experience
//
// This policy controls the mode of the Assistant onboarding experience.
//
// If the policy is unset or is set to "Default", the default mode of the
// Assistant onboarding experience is used.
// If the policy is set to "Education", the EDU mode of the Assistant onboarding
// experience is used.
//
// Valid values:
//   Default: Use the default mode of the Assistant onboarding experience
//   Education: Use the EDU mode of the Assistant onboarding experience
//
// Supported on: chrome_os
message AssistantOnboardingModeProto {
  optional PolicyOptions policy_options = 1;
  optional string AssistantOnboardingMode = 2;
}

// Allow Google Assistant to access screen context
//
// Setting the policy to Enabled lets Google Assistant access screen context and
// send that data to a server. Setting the policy to Disabled keeps Google
// Assistant from screen context.
//
// Leaving the policy unset lets users decide to turn this feature on or off.
//
// Supported on: chrome_os
message VoiceInteractionContextEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool VoiceInteractionContextEnabled = 2;
}

// Allow Google Assistant to listen for the voice activation phrase
//
// Setting the policy to Enabled lets Google Assistant listen for the voice
// activation phrase. Setting the policy to Disabled keeps Google Assistant from
// listening for the phrase.
//
// Leaving the policy unset lets users decide to turn this feature on or off.
//
// Supported on: chrome_os
message VoiceInteractionHotwordEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool VoiceInteractionHotwordEnabled = 2;
}

// Enable Google Assistant voice match flow
//
// Setting the policy to Enabled lets show Google Assistant voice match flow
// during initial setup. Setting the policy to Disabled keeps Google Assistant
// from showing voice match flow during initial setup.
//
// Leaving the policy unset means it is Enabled.
//
// Valid values:
//   True: Show Google Assistant voice match flow during initial setup
//   False: Do not show Google Assistant voice match flow during initial setup
//
// Supported on: chrome_os
message AssistantVoiceMatchEnabledDuringOobeProto {
  optional PolicyOptions policy_options = 1;
  optional bool AssistantVoiceMatchEnabledDuringOobe = 2;
}

// Allow Quick Answers to access selected content
//
// This policy is deprecated and will be removed in Google ChromeOS version 89.
//
// This policy gives Quick Answers permission to access selected content and
// send the info to server.
//
// If the policy is enabled, Quick Answers will be allowed to access selected
// content.
// If the policy is disabled, Quick Answers will not be allowed to access
// selected content.
// If the policy is not set, users can decide whether to allow Quick Answers to
// access selected content.
//
// Supported on:
message VoiceInteractionQuickAnswersEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool VoiceInteractionQuickAnswersEnabled = 2;
}

// Enable Quick Answers
//
// This policy gives Quick Answers permission to access selected content and
// send the info to the server.
//
// If the policy is enabled, Quick Answers will be enabled.
// If the policy is disabled, Quick Answers will be disabled.
// If the policy is not set, users can decide whether to enable or disable Quick
// Answers.
//
// Valid values:
//   True: Enable Quick Answers
//   False: Disable Quick Answers
//
// Supported on: chrome_os
message QuickAnswersEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool QuickAnswersEnabled = 2;
}

// Enable Quick Answers Definition
//
// This policy gives Quick Answers permission to access selected content and
// send the info to the server to get definition results.
//
// If the policy is enabled or not set, Quick Answers Definition will be
// enabled.
// If the policy is disabled, Quick Answers Definition will be disabled.
//
// Valid values:
//   True: Enable Quick Answers Definition
//   False: Disable Quick Answers Definition
//
// Supported on: chrome_os
message QuickAnswersDefinitionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool QuickAnswersDefinitionEnabled = 2;
}

// Enable Quick Answers Translation
//
// This policy gives Quick Answers permission to access selected content and
// send the info to the server to get translation results.
//
// If the policy is enabled or not set, Quick Answers translation will be
// enabled.
// If the policy is disabled, Quick Answers translation will be disabled.
//
// Valid values:
//   True: Enable Quick Answers Translation
//   False: Disable Quick Answers Translation
//
// Supported on: chrome_os
message QuickAnswersTranslationEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool QuickAnswersTranslationEnabled = 2;
}

// Enable Quick Answers Unit Conversion
//
// This policy gives Quick Answers permission to access selected content and
// send the info to the server to get unit conversion results.
//
// If the policy is enabled or not set, Quick Answers unit conversion will be
// enabled.
// If the policy is disabled, Quick Answers unit conversion will be disabled.
//
// Valid values:
//   True: Enable Quick Answers Unit Conversion
//   False: Disable Quick Answers Unit Conversion
//
// Supported on: chrome_os
message QuickAnswersUnitConversionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool QuickAnswersUnitConversionEnabled = 2;
}

// Allows a page to show pop-ups during its unloading
//
// Setting the policy to True allows pages to show pop-ups while the pages
// unload.
//
// Setting the policy to False or leaving it unset prevents pages from showing
// pop-ups while the pages unload.
//
// This policy was removed in Chrome 88 and is ignored if set.
//
// See https://www.chromestatus.com/feature/5989473649164288.
//
// Supported on: fuchsia
message AllowPopupsDuringPageUnloadProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowPopupsDuringPageUnload = 2;
}

// Enable Signed HTTP Exchange (SXG) support
//
// Setting the policy to True or leaving it unset means Google Chrome will
// accept web contents served as Signed HTTP Exchanges.
//
// Setting the policy to False prevents Signed HTTP Exchanges from loading.
//
// Valid values:
//   True: Accept web contents served as Signed HTTP Exchanges
//   False: Prevent Signed HTTP Exchanges from loading
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SignedHTTPExchangeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SignedHTTPExchangeEnabled = 2;
}

// Enable attestation flow for a list of URLs
//
// Enable Chrome Enterprise Platform Identity Connector for a list of URLs.
//
// Setting this policy specifies which URLs should be allowed to be part of the
// attestation flow to get the set of signals from the machine.
//
// Leaving this policy unset or empty means that no endpoint will be able to
// start the attestation flow nor get signals from the machine.
//
// URLs must have HTTPS scheme, e.g. "https://example.com".
//
// Note: Wildcards, *, are allowed.
//
// For ChromeOS, this policy is related to remote attestation where a
// certificate is automatically generated and uploaded to the Device Management
// Server.
//
// For detailed information on valid URL patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ContextAwareAccessSignalsAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ContextAwareAccessSignalsAllowlist = 2;
}

// Password synchronization between third-party SSO providers and Chrome devices
//
// Enables SAML password sync between multiple Chrome devices by monitoring the
// value of password sync token and sending a user through the online re-
// authentication if password was updated and needs to be synchronized.
//
// Enables a page at chrome://password-change that lets SAML users change their
// SAML passwords while in-session, which ensures that the SAML password and the
// device lockscreen password are kept in-sync.
//
// This policy also enables notifications that warn SAML users if their SAML
// passwords are soon to expire so that they can deal with this immediately by
// doing an in-session password change.
// But, these notifications will only be shown if password expiry information is
// sent to the device by the SAML identity provider during the SAML login flow.
//
// Setting this policy to Disabled or not set, SAML password can't be changed at
// chrome://password-change and there won't be any notification when SAML
// passwords are soon to expire.
//
// Valid values:
//   True: Trigger authentication flows to synchronize passwords with SSO
// providers
//   False: Do not trigger authentication flows for password synchronization
//
// Supported on: chrome_os
message SamlInSessionPasswordChangeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SamlInSessionPasswordChangeEnabled = 2;
}

// Enables online re-authentication on lock screen for SAML users
//
// Enables online user signin on a lock screen. If the policy is set to true
// online re-authentication on the lock screen is triggered e.g. by
// SAMLOfflineSigninTimeLimit.
// The re-authentication is enforced immediately when on the lock screen or next
// time a user locks the screen after the condition is met.
// If the policy is set to false or unset users can always unlock the screen
// with their local credentials.
//
// Supported on: chrome_os
message LockScreenReauthenticationEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LockScreenReauthenticationEnabled = 2;
}

// Allow user feedback
//
// Setting the policy to Enabled or leaving it unset lets users send feedback to
// Google through Menu > Help > Report an Issue or key combination.
//
// Setting the policy to Disabled means users can't send feedback to Google.
//
// Valid values:
//   True: Allow users to file feedback
//   False: Prevent users from filing feedback
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message UserFeedbackAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserFeedbackAllowed = 2;
}

// How many days in advance to notify SAML users when their password is due to
// expire
//
// This policy has no effect unless SamlInSessionPasswordChangeEnabled is true.
// If that policy is true, and this policy is set to (for example) 14, that
// means SAML users will be notified 14 days in advance that their password is
// due to expire on a certain date.
// Then they can deal with this immediately by doing an in-session password
// change and updating their password before it expires.
// But, these notifications will only be shown if password expiry information is
// sent to the device by the SAML identity provider during the SAML login flow.
// Setting this policy to zero means the users will not be notified in advance -
// they will only be notified once the password has already expired.
//
// If this policy is set, the user cannot change or override it.
//
// Supported on: chrome_os
message SamlPasswordExpirationAdvanceWarningDaysProto {
  optional PolicyOptions policy_options = 1;
  optional int64 SamlPasswordExpirationAdvanceWarningDays = 2;
}

// Enable Kerberos functionality
//
// Controls whether the Kerberos functionality is enabled. Kerberos is an
// authentication protocol that can be used to authenticate to web apps and file
// shares.
//
// If this policy is enabled, Kerberos functionality is enabled. Kerberos
// accounts can be added either through the 'Configure Kerberos accounts' policy
// or through the Kerberos Accounts settings in the Kerberos settings page.
//
// If this policy is disabled or not set, the Kerberos Accounts settings are
// disabled. No Kerberos accounts can be added and Kerberos authentication
// cannot be used. All existing Kerberos accounts are deleted, all stored
// passwords are deleted.
//
// Supported on: chrome_os
message KerberosEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool KerberosEnabled = 2;
}

// Enable 'Remember password' feature
//
// Controls whether the 'Remember password' feature is enabled in the Kerberos
// authentication dialog. Passwords are stored encrypted on disk, only
// accessible to the Kerberos system daemon and during a user session.
//
// If this policy is enabled or not set, users can decide whether Kerberos
// passwords are remembered, so that they do not have to be entered again.
// Kerberos tickets are automatically fetched unless additional authentication
// is required (two-factor authentication).
//
// If this policy is disabled, passwords are never remembered and all previously
// stored passwords are removed. Users have to enter their password every time
// they need to authenticate with the Kerberos system. Depending on server
// settings, this usually happens between every 8 hours to several months.
//
// Supported on: chrome_os
message KerberosRememberPasswordEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool KerberosRememberPasswordEnabled = 2;
}

// Users can add Kerberos accounts
//
// Controls whether users may add Kerberos accounts.
//
// If this policy is enabled or not set, users may add Kerberos accounts via the
// Kerberos Accounts settings in the Kerberos settings page. Users have full
// control over accounts they added and may modify or remove them.
//
// If this policy is disabled, users may not add Kerberos accounts. Accounts can
// only be added via the 'Configure Kerberos accounts' policy. This is an
// effective way to lock down accounts.
//
// Supported on: chrome_os
message KerberosAddAccountsAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool KerberosAddAccountsAllowed = 2;
}

// Configure Kerberos accounts
//
// Adds prefilled Kerberos accounts. If the Kerberos credentials match the login
// credentials, an account can be configured to reuse the login credentials by
// specifying '${{LOGIN_EMAIL}}' and ${{PASSWORD}}' for principal and password,
// respectively, so that the Kerberos ticket can be retrieved automatically
// unless two-factor authentication is configured. Users cannot modify accounts
// added via this policy.
//
// If this policy is enabled, the list of accounts defined by the policy is
// added to the Kerberos Accounts settings.
//
// If this policy is disabled or not set, no accounts are added to the Kerberos
// Accounts settings and all accounts previously added with this policy are
// removed. Users may still add accounts manually if the 'Users can add Kerberos
// accounts' policy is enabled.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "krb5conf": {
//                 "description": "Kerberos configuration (one line per array
// item), see
// https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html.",
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "password": {
//                 "description": "Kerberos password. The placeholder <ph
// name=\"PASSWORD_PLACEHOLDER\">${{PASSWORD}}</ph> is replaced by the login
// password.",
//                 "sensitiveValue": true,
//                 "type": "string"
//             },
//             "principal": {
//                 "description": "User principal 'user@realm'. The placeholder
// <ph name=\"LOGIN_ID_PLACEHOLDER\">${{LOGIN_ID}}</ph> is replaced by the
// username 'user'. The placeholder <ph
// name=\"LOGIN_EMAIL_PLACEHOLDER\">${{LOGIN_EMAIL}}</ph> is replaced by the
// full principal 'user@realm'.",
//                 "pattern":
// "^(?:[^@]+@[^@]+)|(?:\\${LOGIN_ID})|(?:\\${LOGIN_EMAIL})$",
//                 "type": "string"
//             },
//             "remember_password": {
//                 "description": "Whether to remember the Kerberos password. If
// not set or set to false, the password is not remembered. Ignored if the
// password is not specified.",
//                 "type": "boolean"
//             }
//         },
//         "required": [
//             "principal"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os
message KerberosAccountsProto {
  optional PolicyOptions policy_options = 1;
  optional string KerberosAccounts = 2;
}

// Autocomplete domain for new Kerberos tickets
//
// Adds a prefilled domain to the Kerberos authentication dialog.
//
// If this policy is set, the "Kerberos username" field shows the prefilled
// domain on the right. If the user enters their username it is going to be
// concatenated with the prefilled domain. If the user's input contains "@", the
// prefilled domain is not shown and does not affect the input.
//
// If this policy is unset, no additional information is shown and creating the
// ticket works as usual.
//
// Supported on: chrome_os
message KerberosDomainAutocompleteProto {
  optional PolicyOptions policy_options = 1;
  optional string KerberosDomainAutocomplete = 2;
}

// Changes default configuration for Kerberos tickets
//
// Changes the krb5 suggested configuration for the new manually created
// tickets.
//
// If the policy is set, its value is applied as the suggested configuration and
// shown in the "Advanced" section of the authentication dialog.
//
// If this policy is unset, the recommended Google ChromeOS configuration is
// applied instead. Note that it is also shown in the "Advanced" section of the
// authentication dialog.
//
// Supported on: chrome_os
message KerberosDefaultConfigurationProto {
  optional PolicyOptions policy_options = 1;
  optional string KerberosDefaultConfiguration = 2;
}

// Enable security warnings for command-line flags
//
// Setting the policy to Enabled or leaving it unset means security warnings
// appear when potentially dangerous command-line flags are used to launch
// Chrome.
//
// Setting the policy to Disabled prevents security warnings from appearing when
// Chrome is launched with potentially dangerous command-line flags.
//
// On Microsoft® Windows®, this functionality is only available on instances
// that are joined to a Microsoft® Active Directory® domain, running on Windows
// 10 Pro, or enrolled in Chrome Browser Cloud Management. On macOS, this
// functionality is only available on instances that are managed via MDM, or
// joined to a domain via MCX.
//
// Valid values:
//   True: Show security warnings when potentially dangerous command-line flags
// are used
//   False: Hide security warnings when potentially dangerous command-line flags
// are used
//
// Supported on: fuchsia, linux, mac, win
message CommandLineFlagSecurityWarningsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CommandLineFlagSecurityWarningsEnabled = 2;
}

// Suppress launching of browser window
//
// Setting the policy to True prevents the browser window from launching at the
// start of the session.
//
// Setting the policy to False or leaving it unset allows the window to launch.
//
// Note: The browser window might not launch due to other policies or command-
// line flags.
//
// Supported on: chrome_os
message StartupBrowserWindowLaunchSuppressedProto {
  optional PolicyOptions policy_options = 1;
  optional bool StartupBrowserWindowLaunchSuppressed = 2;
}

// External print servers
//
// Provides configurations of available print servers.
//
// This policy allows you to provide configuration of external print servers to
// Google ChromeOS devices as JSON file.
//
// The size of the file must not exceed 1MB and must contain an array of records
// (JSON objects). Each record must contain fields "id", "url" and
// "display_name" with strings as values. Values of "id" fields must be unique.
//
// The file is downloaded and cached. The cryptographic hash is used to verify
// the integrity of the download. The file will be re-downloaded whenever the
// URL or the hash changes.
//
// When this policy is set to correct value, devices will try to query specified
// print servers for available printers using IPP protocol.
//
// If this policy is unset or set to incorrect value, none of the provided
// server printers are visible to users.
//
// Currently, the number of print servers is limited to 16. Only the first 16
// print servers from the list will be queried.
//
// Supported on: chrome_os
message ExternalPrintServersProto {
  optional PolicyOptions policy_options = 1;
  optional string ExternalPrintServers = 2;
}

// Specify VM CLI permission
//
// Instructs Google ChromeOS to enable or disable virtual machine management
// console tools.
//
// If the policy is set to true or left unset, the user will be able to use VM
// management CLI.
// Otherwise, all of VM management CLI is disabled and hidden.
//
// Supported on: chrome_os
message VmManagementCliAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool VmManagementCliAllowed = 2;
}

// Allow users to manage installed CA certificates.
//
// Setting the policy to All (0) or leaving it unset lets users edit trust
// settings for all CA certificates, remove user-imported certificates, and
// import certificates using Certificate Manager. Setting the policy to UserOnly
// (1) lets users manage only user-imported certificates, but not change trust
// settings of built-in certificates. Setting it to None (2) lets users view
// (not manage) CA certificates.
//
// Valid values:
//   0: Allow users to manage all certificates
//   1: Allow users to manage user certificates
//   2: Disallow users from managing certificates
//
// Supported on: chrome_os
message CACertificateManagementAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional int64 CACertificateManagementAllowed = 2;
}

// Allows users to play media when the device is locked
//
// Setting the policy to Enabled or leaving it unset displays media controls on
// the lock screen if users lock the device when media is playing.
//
// Setting the policy to Disabled turns media controls on the lock screen off.
//
// Supported on: chrome_os
message LockScreenMediaPlaybackEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LockScreenMediaPlaybackEnabled = 2;
}

// Configuration policy for the OnFileDownloaded Chrome Enterprise Connector
//
// List of Chrome Enterprise Connectors services settings to be applied to the
// OnFileDownloaded Enterprise Connector, which triggers when a file is
// downloaded in Chrome.
//
// The url_list, tags, enable and disable fields are used to determine if the
// connector should send a file for analysis when it is downloaded from a
// specific page and what tags to include in the analysis request for that file.
// A tag corresponding to an 'enable' pattern will be included in the analysis
// request if the page URL matches a pattern associated to that tag as long as
// no 'disable' pattern with that same tag matches the page URL. The analysis
// occurs if at least 1 tag is to be included in the request.
//
// The service_provider field identifies which analysis service provider the
// settings correspond to.
//
// The block_until_verdict field being set to 1 means Chrome will wait to get a
// response from the analysis service before giving the user access to the
// downloaded file. Any other integer value means Chrome gives the user access
// to the file immediately.
//
// The block_password_protected field controls whether Chrome blocks or allows
// files that are password protected.
//
// The block_large_files fields controls whether Chrome blocks or allows files
// that are too large to be analyzed.
//
// The require_justification_tags field is used to determine for which tags the
// connector should require the user to enter a justification to bypass a scan
// that results in a bypassable warning. If the field is not set, it's assumed
// that a justification is not required.
//
// The custom_messages, message, learn_more_url, language and tag fields are
// used to configure a message to show the user when a warning is shown after a
// scan had a non-clean verdict. The message field contains the text to show the
// user and should have at most 200 characters. The learn_more_url field
// contains an admin-provided URL that will be clickable by the user to get more
// customer-provided information about why the action was blocked. The language
// field is optional and contains the language of the message. An empty language
// field or a value of 'default' indicates a message to be used when the user's
// language doesn't have a message. The tag field specifies for which type of
// scans the message is displayed. The custom_messages list can have zero or
// more entries, where each entry is required to have non-empty message and tag
// fields.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "block_large_files": {
//                 "type": "boolean"
//             },
//             "block_password_protected": {
//                 "type": "boolean"
//             },
//             "block_until_verdict": {
//                 "type": "integer"
//             },
//             "custom_messages": {
//                 "items": {
//                     "properties": {
//                         "language": {
//                             "type": "string"
//                         },
//                         "learn_more_url": {
//                             "type": "string"
//                         },
//                         "message": {
//                             "type": "string"
//                         },
//                         "tag": {
//                             "type": "string"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "disable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "enable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "require_justification_tags": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "service_provider": {
//                 "enum": [
//                     "google",
//                     "local_user_agent",
//                     "local_system_agent"
//                 ],
//                 "type": "string"
//             },
//             "verification": {
//                 "properties": {
//                     "linux": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "mac": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "windows": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     }
//                 },
//                 "type": "object"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message OnFileDownloadedEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string OnFileDownloadedEnterpriseConnector = 2;
}

// Configuration policy for the OnFileAttached Chrome Enterprise Connector
//
// List of Chrome Enterprise Connectors services settings to be applied to the
// OnFileAttached Enterprise Connector, which triggers when a file is attached
// to Chrome.
//
// The url_list, tags, enable and disable fields are used to determine if the
// connector should send a file for analysis when it is attached to a specific
// page and what tags to include in the analysis request for that file. A tag
// corresponding to an 'enable' pattern will be included in the analysis request
// if the page URL matches a pattern associated to that tag as long as no
// 'disable' pattern with that same tag matches the page URL. The analysis
// occurs if at least 1 tag is to be included in the request.
//
// The service_provider field identifies which analysis service provider the
// settings correspond to.
//
// The block_until_verdict field being set to 1 means Chrome will wait to get a
// response from the analysis service before giving the page access to the file.
// Any other integer value means Chrome gives the page access to the file
// immediately.
//
// The block_password_protected field controls whether Chrome blocks or allows
// files that are password protected.
//
// The block_large_files fields controls whether Chrome blocks or allows files
// that are too large to be analyzed.
//
// The require_justification_tags field is used to determine for which tags the
// connector should require the user to enter a justification to bypass a scan
// that results in a bypassable warning. If the field is not set, it's assumed
// that a justification is not required.
//
// The custom_messages, message, learn_more_url, language and tag fields are
// used to configure a message to show the user when a warning is shown after a
// scan had a non-clean verdict. The message field contains the text to show the
// user and should have at most 200 characters. The learn_more_url field
// contains an admin-provided URL that will be clickable by the user to get more
// customer-provided information about why the action was blocked. The language
// field is optional and contains the language of the message. An empty language
// field or a value of 'default' indicates a message to be used when the user's
// language doesn't have a message. The tag field specifies for which type of
// scans the message is displayed. The custom_messages list can have zero or
// more entries, where each entry is required to have non-empty message and tag
// fields.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "block_large_files": {
//                 "type": "boolean"
//             },
//             "block_password_protected": {
//                 "type": "boolean"
//             },
//             "block_until_verdict": {
//                 "type": "integer"
//             },
//             "custom_messages": {
//                 "items": {
//                     "properties": {
//                         "language": {
//                             "type": "string"
//                         },
//                         "learn_more_url": {
//                             "type": "string"
//                         },
//                         "message": {
//                             "type": "string"
//                         },
//                         "tag": {
//                             "type": "string"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "disable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "enable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "require_justification_tags": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "service_provider": {
//                 "enum": [
//                     "google",
//                     "local_user_agent",
//                     "local_system_agent"
//                 ],
//                 "type": "string"
//             },
//             "verification": {
//                 "properties": {
//                     "linux": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "mac": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "windows": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     }
//                 },
//                 "type": "object"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message OnFileAttachedEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string OnFileAttachedEnterpriseConnector = 2;
}

// Configuration policy for the OnBulkDataEntry Chrome Enterprise Connector
//
// List of Chrome Enterprise Connectors services settings to be applied to the
// OnBulkDataEntry Enterprise Connector, which triggers when data is entered in
// Chrome from the clipboard or by drag and dropping web content.
//
// The url_list, tags, enable and disable fields are used to determine if the
// connector should send data for analysis when it is entered in a specific page
// and what tags to include in the analysis request for that data. A tag
// corresponding to an 'enable' pattern will be included in the analysis request
// if the page URL matches a pattern associated to that tag as long as no
// 'disable' pattern with that same tag matches the page URL. The analysis
// occurs if at least 1 tag is to be included in the request.
//
// The service_provider field identifies which analysis service provider the
// settings correspond to.
//
// The block_until_verdict field being set to 1 means Chrome will wait to get a
// response from the analysis service before giving the page access to the data.
// Any other integer value means Chrome gives the page access to the data
// immediately.
//
// The minimum_data_size field indicates the minimum size (in bytes) data
// entered in Chrome must equal or surpass to be scanned. The default value is
// 100 bytes if the field is unset.
//
// The require_justification_tags field is used to determine for which tags the
// connector should require the user to enter a justification to bypass a scan
// that results in a bypassable warning. If the field is not set, it's assumed
// that a justification is not required.
//
// The custom_messages, message, learn_more_url, language and tag fields are
// used to configure a message to show the user when a warning is shown after a
// scan had a non-clean verdict. The message field contains the text to show the
// user and should have at most 200 characters. The learn_more_url field
// contains an admin-provided URL that will be clickable by the user to get more
// customer-provided information about why the action was blocked. The language
// field is optional and contains the language of the message. An empty language
// field or a value of 'default' indicates a message to be used when the user's
// language doesn't have a message. The tag field specifies for which type of
// scans the message is displayed. The custom_messages list can have zero or
// more entries, where each entry is required to have non-empty message and tag
// fields.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "block_until_verdict": {
//                 "type": "integer"
//             },
//             "custom_messages": {
//                 "items": {
//                     "properties": {
//                         "language": {
//                             "type": "string"
//                         },
//                         "learn_more_url": {
//                             "type": "string"
//                         },
//                         "message": {
//                             "type": "string"
//                         },
//                         "tag": {
//                             "type": "string"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "disable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "enable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "minimum_data_size": {
//                 "minimum": 0,
//                 "type": "integer"
//             },
//             "require_justification_tags": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "service_provider": {
//                 "enum": [
//                     "google",
//                     "local_user_agent",
//                     "local_system_agent"
//                 ],
//                 "type": "string"
//             },
//             "verification": {
//                 "properties": {
//                     "linux": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "mac": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "windows": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     }
//                 },
//                 "type": "object"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message OnBulkDataEntryEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string OnBulkDataEntryEnterpriseConnector = 2;
}

// Configuration policy for the OnPrint Google Chrome Enterprise Connector
//
// List of Google Chrome Enterprise Connectors services settings to be applied
// to the OnPrint Enterprise Connector, which triggers when a page or file is
// printed from Google Chrome.
//
// The url_list, tags, enable and disable fields are used to determine if the
// connector should send data for analysis when printing is triggered on a
// specific page and what tags to include in the analysis request. The analysis
// occurs if at least 1 tag is to be included in the request.
//
// The service_provider field identifies which analysis service provider the
// settings correspond to.
//
// The block_until_verdict field being set to 1 means Google Chrome will wait to
// get a response from the analysis service before allowing the print preview
// dialog to be shown for the printed page. Any other integer value means Google
// Chrome shows the print preview dialog immediately.
//
// The block_large_files fields controls whether Google Chrome blocks or allows
// files/pages that are too large to be analyzed.
//
// The require_justification_tags field is used to determine for which tags the
// connector should require the user to enter a justification to bypass a scan
// that results in a bypassable warning. If the field is not set, it's assumed
// that a justification is not required.
//
// The custom_messages, message, learn_more_url, language and tag fields are
// used to configure a message to show the user when a warning is shown after a
// scan had a non-clean verdict. The administrator is able to configure messages
// of up to 200 characters.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "block_large_files": {
//                 "type": "boolean"
//             },
//             "block_until_verdict": {
//                 "enum": [
//                     0,
//                     1
//                 ],
//                 "type": "integer"
//             },
//             "custom_messages": {
//                 "items": {
//                     "properties": {
//                         "language": {
//                             "type": "string"
//                         },
//                         "learn_more_url": {
//                             "type": "string"
//                         },
//                         "message": {
//                             "type": "string"
//                         },
//                         "tag": {
//                             "type": "string"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "disable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "enable": {
//                 "items": {
//                     "properties": {
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "require_justification_tags": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "service_provider": {
//                 "enum": [
//                     "google",
//                     "local_user_agent",
//                     "local_system_agent"
//                 ],
//                 "type": "string"
//             },
//             "verification": {
//                 "properties": {
//                     "linux": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "mac": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "windows": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     }
//                 },
//                 "type": "object"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message OnPrintEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string OnPrintEnterpriseConnector = 2;
}

// Configuration policy for the OnFileTransfer Chrome Enterprise Connector
//
// List of Chrome Enterprise Connectors services settings to be applied to the
// OnFileTransfer Enterprise Connector, which triggers when a file is
// transferred within Google ChromeOS.
//
// The source_destination_list, tags, enable and disable fields are used to
// determine if the connector should send a file for analysis when it is
// transferred between a source and a destination and what tags to include in
// the analysis request for that file. A tag corresponding to an 'enable' rule
// will be included in the analysis request if the source and destination match
// the rule associated to that tag as long as no 'disable' rule with that same
// tag matches the transfer. The analysis occurs if at least 1 tag is to be
// included in the request. A source_destination_list rule is defined by a list
// of pairs, where each pair contains a list of sources and a list of
// destinations. The file_system_type defines for which file system a rule
// should apply.
//
// The service_provider field identifies which analysis service provider the
// settings correspond to.
//
// The block_until_verdict field being set to 1 means Google ChromeOS will wait
// to get a response from the analysis service before allowing the transfer. Any
// other integer value means Google ChromeOS allows the transfer immediately.
//
// The block_password_protected field controls whether Google ChromeOS blocks or
// allows files that are password protected.
//
// The block_large_files fields controls whether Google ChromeOS blocks or
// allows files that are too large to be analyzed.
//
// The require_justification_tags field is used to determine for which tags the
// connector should require the user to enter a justification to bypass a scan
// that results in a bypassable warning. If the field is not set, it's assumed
// that a justification is not required.
//
// The custom_messages, message, learn_more_url, language and tag fields are
// used to configure a message to show the user when a warning is shown after a
// scan had a non-clean verdict. The message field contains the text to show the
// user and should have at most 200 characters. The learn_more_url field
// contains an admin-provided URL that will be clickable by the user to get more
// customer-provided information about why the action was blocked. The language
// field is optional and contains the language of the message. An empty language
// field or a value of 'default' indicates a message to be used when the user's
// language doesn't have a message. The tag field specifies for which type of
// scans the message is displayed. The custom_messages list can have zero or
// more entries, where each entry is required to have non-empty message and tag
// fields.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "block_large_files": {
//                 "type": "boolean"
//             },
//             "block_password_protected": {
//                 "type": "boolean"
//             },
//             "block_until_verdict": {
//                 "type": "integer"
//             },
//             "custom_messages": {
//                 "items": {
//                     "properties": {
//                         "language": {
//                             "type": "string"
//                         },
//                         "learn_more_url": {
//                             "type": "string"
//                         },
//                         "message": {
//                             "type": "string"
//                         },
//                         "tag": {
//                             "type": "string"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "disable": {
//                 "$ref": "file_transfer_enable_disable_schema"
//             },
//             "enable": {
//                 "id": "file_transfer_enable_disable_schema",
//                 "items": {
//                     "properties": {
//                         "source_destination_list": {
//                             "items": {
//                                 "properties": {
//                                     "destinations": {
//                                         "$ref":
// "file_transfer_source_destination_schema"
//                                     },
//                                     "sources": {
//                                         "id":
// "file_transfer_source_destination_schema",
//                                         "items": {
//                                             "properties": {
//                                                 "file_system_type": {
//                                                     "enum": [
//                                                         "UNKNOWN",
//                                                         "ANY",
//                                                         "*",
//                                                         "MY_FILES",
//                                                         "REMOVABLE",
// "DEVICE_MEDIA_STORAGE",
//                                                         "PROVIDED",
//                                                         "ARC",
//                                                         "GOOGLE_DRIVE",
//                                                         "SMB",
//                                                         "CROSTINI",
//                                                         "PLUGIN_VM",
//                                                         "BOREALIS",
//                                                         "BRUSCHETTA",
//                                                         "UNKNOWN_VM"
//                                                     ],
//                                                     "type": "string"
//                                                 }
//                                             },
//                                             "type": "object"
//                                         },
//                                         "type": "array"
//                                     }
//                                 },
//                                 "type": "object"
//                             },
//                             "type": "array"
//                         },
//                         "tags": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "require_justification_tags": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "service_provider": {
//                 "type": "string"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os
message OnFileTransferEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string OnFileTransferEnterpriseConnector = 2;
}

// Configuration policy for the OnSecurityEvent Chrome Enterprise Connector
//
// List of Chrome Enterprise Connectors services settings to be applied to the
// OnSecurityEvent Enterprise Connector, which triggers when a security event
// occurs in Chrome. This includes negative verdicts from analysis Enterprise
// Connectors, password reuse, navigations to unsafe pages and other security
// sensitive user actions.
//
// The service_provider field identifies which reporting service provider the
// settings correspond to and the enabled_event_names field identifies which
// events are enabled for this provider.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "enabled_event_names": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "enabled_opt_in_events": {
//                 "items": {
//                     "properties": {
//                         "name": {
//                             "type": "string"
//                         },
//                         "url_patterns": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "service_provider": {
//                 "enum": [
//                     "google"
//                 ],
//                 "type": "string"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message OnSecurityEventEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string OnSecurityEventEnterpriseConnector = 2;
}

// Check Safe Browsing status of URLs in real time
//
// This policy controls checking URLs in real time to identify unsafe URLs.
//
// If this policy is left not set or set to ‘Disabled’, the consumer Safe
// Browsing checks will be applied. Consumer Safe Browsing checks can still
// include real time lookups, depending on the value of the “Make searches and
// browsing better” setting and the value of the
// UrlKeyedAnonymizedDataCollectionEnabled policy.
//
// If this policy is set to ‘Enabled’, URLs will be sent to be scanned in real
// time under enterprise ToS. It will result in Chrome sending URLs to Google
// Cloud or third parties of your choosing to check them in real time. The
// consumer version of Safe Browsing real time lookup will be switched off.
//
// This policy requires additional setup to take effect, please visit https://su
// pport.google.com/chrome/a?p=chrome_enterprise_connector_policies_setting for
// more information.
//
// Valid values:
//   0: Real time URL check is disabled.
//   1: Real time check for main frame URLs is enabled.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message EnterpriseRealTimeUrlCheckModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 EnterpriseRealTimeUrlCheckMode = 2;
}

// Enable Renderer Code Integrity
//
// Setting the policy to Enabled or leaving it unset turns Renderer Code
// Integrity on.
//
// Setting the policy to Disabled has a detrimental effect on Google Chrome's
// security and stability as unknown and potentially hostile code can load
// inside Google Chrome's renderer processes. Only turn off the policy if there
// are compatibility issues with third-party software that must run inside
// Google Chrome's renderer processes.
//
// Note: Read more about Process mitigation policies ( https://chromium.googleso
// urce.com/chromium/src/+/HEAD/docs/design/sandbox.md#Process-mitigation-
// policies ).
//
// Supported on: win
message RendererCodeIntegrityEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool RendererCodeIntegrityEnabled = 2;
}

// Enable Renderer App Container
//
// Setting the policy to Enabled or leaving it unset means Renderer App
// Container configuration will be enabled on supported platforms.
//
// Setting the policy to Disabled has a detrimental effect on the security and
// stability of Google Chrome as it will weaken the sandbox that renderer
// processes use. Only turn off the policy if there are compatibility issues
// with third-party software that must run inside renderer processes.
//
// Note: Read more about Process mitigation policies ( https://chromium.googleso
// urce.com/chromium/src/+/HEAD/docs/design/sandbox.md#Process-mitigation-
// policies ).
//
// Valid values:
//   True: Enable the Renderer App Container sandbox
//   False: Disable the Renderer App Container sandbox
//
// Supported on: win
message RendererAppContainerEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool RendererAppContainerEnabled = 2;
}

// Block Browser Legacy Extension Points
//
// Setting the policy to Enabled or leaving it unset will permit Google Chrome
// to apply the additional extension point security mitigation to block legacy
// extension points in the Browser process.
//
// Setting the policy to Disabled has a detrimental effect on Google Chrome's
// security and stability as unknown and potentially hostile code can load
// inside Google Chrome's browser process. Only turn off the policy if there are
// compatibility issues with third-party software that must run inside Google
// Chrome's browser process.
//
// Note: Read more about Process mitigation policies ( https://chromium.googleso
// urce.com/chromium/src/+/HEAD/docs/design/sandbox.md#Process-mitigation-
// policies ).
//
// Valid values:
//   True: Block legacy extension points in the Browser process
//   False: Do not block legacy extension points in the Browser process
//
// Supported on: win
message BrowserLegacyExtensionPointsBlockedProto {
  optional PolicyOptions policy_options = 1;
  optional bool BrowserLegacyExtensionPointsBlocked = 2;
}

// List of names that will bypass the HSTS policy check
//
// Setting the policy specifies a list of hostnames that bypass preloaded HSTS
// upgrades from http to https.
//
// Only single-label hostnames are allowed in this policy, and this policy only
// applies to "static" HSTS-preloaded entries (for instance, "app", "new",
// "search", "play"). This policy does not prevent HSTS upgrades for servers
// that have "dynamically" requested HSTS upgrades using a Strict-Transport-
// Security response header.
//
// Supplied hostnames must be canonicalized: Any IDNs must be converted to their
// A-label format, and all ASCII letters must be lowercase. This policy only
// applies to the specific single-label hostnames specified, not to subdomains
// of those names.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message HSTSPolicyBypassListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList HSTSPolicyBypassList = 2;
}

// Allows a page to perform synchronous XHR requests during page dismissal.
//
// This policy allows an admin to specify that a page may send synchronous XHR
// requests during page dismissal.
//
// When the policy is set to enabled, pages are allowed to send synchronous XHR
// requests during page dismissal.
//
// When the policy is set to disabled or not set, pages are not allowed to send
// synchronous XHR requests during page dismissal.
//
// This policy was removed in Chrome 99.
//
// See https://www.chromestatus.com/feature/4664843055398912 .
//
// Supported on: fuchsia
message AllowSyncXHRInPageDismissalProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowSyncXHRInPageDismissal = 2;
}

// Set limit on megabytes of memory a single Chrome instance can use.
//
// Configures the amount of memory that a single Google Chrome instance can use
// before tabs start being discarded (I.E. the memory used by the tab will be
// freed and the tab will have to be reloaded when switched to) to save memory.
//
// If the policy is set, browser will begin to discard tabs to save memory once
// the limitation is exceeded. However, there is no guarantee that the browser
// is always running under the limit. Any value under 1024 will be rounded up to
// 1024.
//
// If this policy is not set, the browser will only begin attempts to save
// memory once it has detected that the amount of physical memory on its machine
// is low.
//
// Supported on: mac, win
message TotalMemoryLimitMbProto {
  optional PolicyOptions policy_options = 1;
  optional int64 TotalMemoryLimitMb = 2;
}

// Enable a TLS 1.3 security feature for local trust anchors.
//
// This policy controls a security feature in TLS 1.3 which protects connections
// against downgrade attacks. It is backwards-compatible and will not affect
// connections to compliant TLS 1.2 servers or proxies. However, older versions
// of some TLS-intercepting proxies have an implementation flaw which causes
// them to be incompatible.
//
// If this policy is set to True or not set, Google Chrome will enable these
// security protections for all connections.
//
// If this policy is set to False, Google Chrome will disable these security
// protections for connections authenticated with locally-installed CA
// certificates. These protections are always enabled for connections
// authenticated with publicly-trusted CA certificates.
//
// The default value for this policy was changed in Google Chrome 81 from false
// to true. Affected proxies are expected to fail connections with an error code
// of ERR_TLS13_DOWNGRADE_DETECTED. Administrators who need more time to upgrade
// affected proxies may use this policy to temporarily disable this security
// feature. This policy was removed in version 86.
//
// Supported on:
message TLS13HardeningForLocalAnchorsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool TLS13HardeningForLocalAnchorsEnabled = 2;
}

// Allow the audio sandbox to run
//
// This policy controls the audio process sandbox.
// If this policy is enabled, the audio process will run sandboxed.
// If this policy is disabled, the audio process will run unsandboxed and the
// WebRTC audio-processing module will run in the renderer process.
// This leaves users open to security risks related to running the audio
// subsystem unsandboxed.
// If this policy is not set, the default configuration for the audio sandbox
// will be used, which may differ per platform.
// This policy is intended to give enterprises flexibility to disable the audio
// sandbox if they use security software setups that interfere with the sandbox.
//
// Supported on: linux, mac, win
message AudioSandboxEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AudioSandboxEnabled = 2;
}

// Enable CORS check mitigations in the new CORS implementation
//
// Enable CORS check mitigations in the new CORS implementation, allowing
// Extensions to keep compatible behavior, and allowing Google Chrome to send
// specified headers without CORS checks.
//
// If this list is set to empty, Google Chrome tries to run Extensions in
// compatible manners, and does not introduce API changes for Google Chrome 79
// as explained at https://developer.chrome.com/extensions/webRequest.
//
// If this list is set to have HTTP request header names, CORS inspection will
// ignore the listed headers in addition to enable the mitigation for
// Extensions.
//
// If this list is not set, both mitigations explained above are not applied.
//
// For details on CORS, visit:
// https://www.chromestatus.com/feature/5768642492891136.
//
// Note that this policy was announced to be removed in Google Chrome version
// 82, but removed in version 84.
//
// Supported on:
message CorsMitigationListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList CorsMitigationList = 2;
}

// Use the legacy CORS implementation rather than new CORS
//
// Use the legacy CORS implementation rather than new CORS.
//
// If this setting is set to True, the legacy implementation is used that should
// be compatible with previous versions.
//
// If this setting is set to False, or is not set, the new implementation is
// used that might cause enterprise specific compatibility issues potentially.
//
// This policy will be removed after a couple of milestones.
//
// For details on CORS, visit:
// https://www.chromestatus.com/feature/5768642492891136.
//
// Note that this policy was announced to be removed in Google Chrome version
// 82, but removed in version 84.
//
// Supported on:
message CorsLegacyModeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CorsLegacyModeEnabled = 2;
}

// Enabled external print servers
//
// Specifies the subset of print servers that will be queried for server
// printers.
//
// If this policy is used, only the server printers with ids matching the values
// in this policy are available to the user.
//
// The ids must correspond to the "id" field in the file specified in
// ExternalPrintServers.
//
// If this policy is not set, filtering is omitted and all print servers are
// taken into account.
//
// This policy is deprecated, please use ExternalPrintServersAllowlist instead.
//
// Supported on:
message ExternalPrintServersWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExternalPrintServersWhitelist = 2;
}

// Enabled external print servers
//
// Specifies the subset of print servers that will be queried for server
// printers.
//
// If this policy is used, only the server printers with ids matching the values
// in this policy are available to the user.
//
// The ids must correspond to the "id" field in the file specified in
// ExternalPrintServers.
//
// If this policy is not set, filtering is omitted and all print servers are
// taken into account.
//
// Supported on: chrome_os
message ExternalPrintServersAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExternalPrintServersAllowlist = 2;
}

// Show an "Always open" checkbox in external protocol dialog.
//
// This policy controls whether or not the "Always open" checkbox is shown on
// external protocol launch confirmation prompts.
//
// If this policy is set to True or not set, when an external protocol
// confirmation is shown, the user can select "Always allow" to skip all future
// confirmation prompts for the protocol on this site.
//
// If this policy is set to False, the "Always allow" checkbox is not displayed
// and the user will be prompted each time an external protocol is invoked.
//
// Valid values:
//   True: Allow users to select "Always allow" when an external protocol dialog
// is shown to skip future confirmation prompts
//   False: Always require users to confrim external protocol prompts
//
// Supported on: fuchsia, linux, mac, win
message ExternalProtocolDialogShowAlwaysOpenCheckboxProto {
  optional PolicyOptions policy_options = 1;
  optional bool ExternalProtocolDialogShowAlwaysOpenCheckbox = 2;
}

// Control use of insecure content exceptions
//
// Allows you to set whether users can add exceptions to allow mixed content for
// specific sites.
//
// This policy can be overridden for specific URL patterns using the
// 'InsecureContentAllowedForUrls' and 'InsecureContentBlockedForUrls' policies.
//
// If this policy is left not set, users will be allowed to add exceptions to
// allow blockable mixed content and disable autoupgrades for optionally
// blockable mixed content.
//
// Valid values:
//   2: Do not allow any site to load mixed content
//   3: Allow users to add exceptions to allow mixed content
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultInsecureContentSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultInsecureContentSetting = 2;
}

// Allow insecure content on these sites
//
// Allows you to set a list of url patterns that specify sites which are allowed
// to display blockable (i.e. active) mixed content (i.e. HTTP content on HTTPS
// sites) and for which optionally blockable mixed content upgrades will be
// disabled.
//
// If this policy is left not set blockable mixed content will be blocked and
// optionally blockable mixed content will be upgraded, and users will be
// allowed to set exceptions to allow it for specific sites.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message InsecureContentAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList InsecureContentAllowedForUrls = 2;
}

// Block insecure content on these sites
//
// Allows you to set a list of url patterns that specify sites which are not
// allowed to display blockable (i.e. active) mixed content (i.e. HTTP content
// on HTTPS sites), and for which optionally blockable (i.e. passive) mixed
// content will be upgraded.
//
// If this policy is left not set blockable mixed content will be blocked and
// optionally blockable mixed content will be upgraded, but users will be
// allowed to set exceptions to allow it for specific sites.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message InsecureContentBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList InsecureContentBlockedForUrls = 2;
}

// Per-App Time Limits
//
// Allows to set per-app usage restrictions.
// Usage restrictions can be applied to the apps installed on Google ChromeOS
// for the given user.
// Restrictions should be passed in |app_limits| list. Only one entry per-app is
// allowed. Apps not included in the list have no restrictions.
// It is not possible to block apps that are essential for the operating system,
// the restrictions for such apps will be ignored.
// App is uniquely identified by |app_id|. Since different types of apps can use
// different id format |app_type| needs to be specified next to |app_id|.
// Per-App Time Limits only support |ARC| apps currently. Android package name
// is used as |app_id|.
// Support for other types of applications will be added in the future, for now
// they can be specified in the policy, but the restrictions will take no
// effect.
// There are two types of available restrictions: |BLOCK| and |TIME_LIMIT|.
// |BLOCK| makes app unavailable for the user. If |daily_limit_mins| is
// specified with |BLOCK| restriction |daily_limit_mins| will be ignored.
// |TIME_LIMITS| applies daily usage limit and makes app unavailable after the
// limit is reached on the given day. Usage limit is specified in
// |daily_limit_mins|. Usage limit is reset daily at the UTC time passed in
// |reset_at|.
// This policy is only used for child users.
// This policy is complementary to 'UsageTimeLimit'. Restrictions specified in
// 'UsageTimeLimit' like screen time and bedtime will be enforced regardless of
// 'PerAppTimeLimits'.
//
// Value schema:
// {
//     "properties": {
//         "activity_reporting_enabled": {
//             "description": "The value of app activity collection toggle. If
// set to true user app activity will be reported to the server with purpose of
// being displayed in child and parent <ph name=\"PRODUCT_NAME\">$1<ex>Family
// Link</ex></ph> app. If set to false Per-app time limits feature will still
// work, but no data will be reported to the server and therefore displayed in
// <ph name=\"PRODUCT_NAME\">$1<ex>Family Link</ex></ph>.",
//             "type": "boolean"
//         },
//         "app_limits": {
//             "items": {
//                 "properties": {
//                     "app_info": {
//                         "properties": {
//                             "app_id": {
//                                 "type": "string"
//                             },
//                             "app_type": {
//                                 "enum": [
//                                     "ARC",
//                                     "BUILT-IN",
//                                     "EXTENSION",
//                                     "WEB",
//                                     "CROSTINI"
//                                 ],
//                                 "type": "string"
//                             }
//                         },
//                         "type": "object"
//                     },
//                     "daily_limit_mins": {
//                         "maximum": 1440,
//                         "minimum": 0,
//                         "type": "integer"
//                     },
//                     "last_updated_millis": {
//                         "description": "UTC timestamp for the last time this
// entry was updated. Sent as a string because the timestamp would not fit in an
// integer",
//                         "type": "string"
//                     },
//                     "restriction": {
//                         "enum": [
//                             "BLOCK",
//                             "TIME_LIMIT"
//                         ],
//                         "type": "string"
//                     }
//                 },
//                 "type": "object"
//             },
//             "type": "array"
//         },
//         "reset_at": {
//             "description": "The time of the day in local time when usage
// quota is renewed.",
//             "properties": {
//                 "hour": {
//                     "maximum": 23,
//                     "minimum": 0,
//                     "type": "integer"
//                 },
//                 "minute": {
//                     "maximum": 59,
//                     "minimum": 0,
//                     "type": "integer"
//                 }
//             },
//             "type": "object"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message PerAppTimeLimitsProto {
  optional PolicyOptions policy_options = 1;
  optional string PerAppTimeLimits = 2;
}

// Re-enable Web Components v0 API until M84.
//
// The Web Components v0 APIs (Shadow DOM v0, Custom Elements v0, and HTML
// Imports) were deprecated in 2018, and have been disabled by default starting
// in M80. This policy allows these features to be selectively re-enabled until
// M84.
//
// If this policy is set to True, the Web Components v0 features will be enabled
// for all sites.
//
// If this policy is set to False or not set, the Web Components v0 features
// will be disabled by default, starting in M80.
//
// This policy will be removed after Chrome 84.
//
// Supported on:
message WebComponentsV0EnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebComponentsV0Enabled = 2;
}

// Use Legacy Form Controls until M84.
//
// Starting in M81, the standard form control elements (e.g. &lt;select&gt;,
// &lt;button&gt;, &lt;input type=date&gt;) were given a refreshed look and
// feel, with improved accessibility and better platform uniformity. This policy
// restores the old "legacy" form control elements until M84.
//
// If this policy is set to True, the "legacy" form control elements will be
// used for all sites.
//
// If this policy is set to False or not set, the form control elements will be
// enabled as they are launched in M81, M82, and M83.
//
// This policy will be removed after Chrome 84.
//
// Supported on:
message UseLegacyFormControlsProto {
  optional PolicyOptions policy_options = 1;
  optional bool UseLegacyFormControls = 2;
}

// Re-enable the Event.path API until M115.
//
// Starting in M109, the non-standard API Event.path will be removed to improve
// web compatibility. This policy re-enables the API until M115.
//
// If this policy is set to enabled, the Event.path API will be available.
//
// If this policy is set to disabled, the Event.path API will be unavailable.
//
// If this policy is not set, the Event.path API will be in the default status:
// available before M109, and unavailable in M109 to 114.
//
// This policy will be removed after Chrome 115.
//
// Valid values:
//   True: Event.path API will be available.
//   False: Event.path API will be unavailable.
//   None: Event.path API will be in the default status: available before M109,
// and unavailable in M109 to 114.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message EventPathEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool EventPathEnabled = 2;
}

// Enable the Click to Call Feature
//
// Enable the Click to Call feature which allows users to send phone numbers
// from Chrome Desktops to an Android device when the user is Signed-in. For
// more information, see help center article:
// https://support.google.com/chrome/answer/9430554?hl=en.
//
// If this policy is set to enabled, the capability of sending phone numbers to
// Android devices will be enabled for the Chrome user.
//
// If this policy is set to disabled, the capability of sending phone numbers to
// Android devices will be disabled for the Chrome user.
//
// If you set this policy, users cannot change or override it.
//
// If this policy is left unset, the Click to Call feature is enabled by
// default.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ClickToCallEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ClickToCallEnabled = 2;
}

// Limits the number of user data snapshots retained for use in case of
// emergency rollback.
//
// Following each major version update, Chrome will create a snapshot of certain
// portions of the user's browsing data for use in case of a later emergency
// version rollback. If an emergency rollback is performed to a version for
// which a user has a corresponding snapshot, the data in the snapshot is
// restored. This allows users to retain such settings as bookmarks and autofill
// data.
//
// If this policy is not set, the default value of 3 is used
//
// If the policy is set, old snapshots are deleted as needed to respect the
// limit. If the policy is set to 0, no snapshots will be taken
//
// Supported on: fuchsia, linux, mac, win
message UserDataSnapshotRetentionLimitProto {
  optional PolicyOptions policy_options = 1;
  optional int64 UserDataSnapshotRetentionLimit = 2;
}

// Disable printer types on the deny list
//
// The printers of types placed on the deny list will be disabled from being
// discovered or having their capabilities fetched.
//
// Placing all printer types on the deny list effectively disables printing, as
// there would be no available destinations to send a document for printing.
//
// In versions before 102, including cloud on the deny list has the same effect
// as setting the CloudPrintSubmitEnabled policy to false. In order to keep
// Google Cloud Print destinations discoverable, the CloudPrintSubmitEnabled
// policy must be set to true and cloud must not be on the deny list. Beginning
// in version 102, Google Cloud Print destinations are not supported and will
// not appear regardless of policy values.
//
// If the policy is not set, or is set to an empty list, all printer types will
// be available for discovery.
//
// Extension printers are also known as print provider destinations, and include
// any destination that belongs to a Google Chrome extension.
//
// Local printers are also known as native printing destinations, and include
// destinations available to the local machine and shared network printers.
//
// Valid values:
//   privet: Zeroconf-based (mDNS + DNS-SD) protocol destinations (Deprecated)
//   extension: Extension-based destinations
//   pdf: The 'Save as PDF' destination
//   local: Local printer destinations
//   cloud: Google Cloud Print and 'Save to Google Drive' destinations
// (Deprecated)
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PrinterTypeDenyListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList PrinterTypeDenyList = 2;
}

// Print PostScript Mode
//
// Controls how Google Chrome prints on Microsoft® Windows®.
//
// When printing to a PostScript printer on Microsoft® Windows® different
// PostScript generation methods can affect printing performance.
//
// When this policy is set to Default, Google Chrome will use a set of default
// options when generating PostScript. For text in particular, text will always
// be rendered using Type 3 fonts.
//
// When this policy is set to Type42, Google Chrome will render text using Type
// 42 fonts if possible. This should increase printing speed for some PostScript
// printers.
//
// When this policy is not set, Google Chrome will be in Default mode.
//
// Valid values:
//   0: Default
//   1: Type42
//
// Supported on: win
message PrintPostScriptModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PrintPostScriptMode = 2;
}

// Print Rasterization Mode
//
// Controls how Google Chrome prints on Microsoft® Windows®.
//
// When printing to a non-PostScript printer on Microsoft® Windows®, sometimes
// print jobs need to be rasterized to print correctly.
//
// When this policy is set to Full, Google Chrome will do full page
// rasterization if necessary.
//
// When this policy is set to Fast, Google Chrome will avoid rasterization if
// possible, reducing the amount of rasterization can help reduce print job
// sizes and increase printing speed.
//
// When this policy is not set, Google Chrome will be in Full mode.
//
// Valid values:
//   0: Full
//   1: Fast
//
// Supported on: win
message PrintRasterizationModeProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PrintRasterizationMode = 2;
}

// Print PDF as Image Available
//
// Controls how Google Chrome makes the Print as image option available on
// Microsoft® Windows® and macOS when printing PDFs.
//
// When printing a PDF on Microsoft® Windows® or macOS, sometimes print jobs
// need to be rasterized to an image for certain printers to get correct looking
// output.
//
// When this policy is set to Enabled, Google Chrome will make the Print as
// image option available in the Print Preview when printing a PDF.
//
// When this policy is set to Disabled or not set Google Chrome the Print as
// image option will not be available to users in Print Preview and PDFs will be
// printed as usual without being rasterized to an image before being sent to
// the destination.
//
// Valid values:
//   True: Print as image option available to user to allow PDF rasterization
// prior to sending print job to destination.
//   False: Print as image option not available for user selection.
//
// Supported on: mac, win
message PrintPdfAsImageAvailabilityProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrintPdfAsImageAvailability = 2;
}

// Print Rasterize PDF DPI
//
// Controls print image resolution when Google Chrome prints PDFs with
// rasterization.
//
// When printing a PDF using the Print to image option, it can be beneficial to
// specify a print resolution other than a device's printer setting or the PDF
// default.  A high resolution will significantly increase the processing and
// printing time while a low resolution can lead to poor imaging quality.
//
// This policy allows a particular resolution to be specified for use when
// rasterizing PDFs for printing.
//
// If this policy is set to zero or not set at all then the system default
// resolution will be used during rasterization of page images.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PrintRasterizePdfDpiProto {
  optional PolicyOptions policy_options = 1;
  optional int64 PrintRasterizePdfDpi = 2;
}

// Print PDF as Image Default
//
// Controls if Google Chrome makes the Print as image option default to set when
// printing PDFs.
//
// When this policy is set to Enabled, Google Chrome will default to setting the
// Print as image option in the Print Preview when printing a PDF.
//
// When this policy is set to Disabled or not set Google Chrome then the user
// selection for Print as image option will be initially unset.  The user will
// be allowed to select it for each individual PDFs print job, if the option is
// available.
//
// For Microsoft® Windows® or macOS this policy only has an effect if
// PrintPdfAsImageAvailability is also enabled.
//
// Valid values:
//   True: Print as image option defaults to set for print previews of PDF
// documents when it is available.
//   False: Print as image option defaults to unset for print previews of PDF
// documents when it is available.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
//
// Note: this policy must have a RECOMMENDED PolicyMode set in PolicyOptions.
message PrintPdfAsImageDefaultProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrintPdfAsImageDefault = 2;
}

// Allow print job history to be deleted
//
// Controls whether print job history can be deleted.
//
// Locally stored print jobs can be deleted through the print management app or
// through deleting the users's browser history.
//
// When this policy is enabled or unset, the user will be able to delete their
// print job history through the print mangement app or through deleting their
// browser history.
//
// When this policy is disabled, the user will not be able to delete their print
// job history through the print management app or through deleting their
// browser history.
//
// Supported on: chrome_os
message DeletePrintJobHistoryAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool DeletePrintJobHistoryAllowed = 2;
}

// Enable Ambient Authentication for profile types.
//
// Configuring this policy will allow/disallow ambient authentication for
// Incognito and Guest profiles in Google Chrome.
//
// Ambient Authentication is http authentication with default credentials if
// explicit credentials are not provided via NTLM/Kerberos/Negotiate
// challenge/response schemes.
//
// Setting the RegularOnly (value 0), allows ambient authentication for Regular
// sessions only. Incognito and Guest sessions wouldn't be allowed to ambiently
// authenticate.
//
// Setting the IncognitoAndRegular (value 1), allows ambient authentication for
// Incognito and Regular sessions. Guest sessions wouldn't be allowed to
// ambiently authenticate.
//
// Setting the GuestAndRegular (value 2), allows ambient authentication for
// Guest and Regular sessions. Incognito sessions wouldn't be allowed to
// ambiently authenticate.
//
// Setting the  All (value 3), allows ambient authentication for all sessions.
//
// Note that, ambient authentication is always allowed on regular profiles.
//
// In Google Chrome version 81 and later, if the policy is left not set, ambient
// authentication will be enabled in regular sessions only.
//
// Valid values:
//   0: Enable ambient authentication in regular sessions only.
//   1: Enable ambient authentication in incognito and regular sessions.
//   2: Enable ambient authentication in guest and regular sessions.
//   3: Enable ambient authentication in regular, incognito and guest sessions.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AmbientAuthenticationInPrivateModesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional int64 AmbientAuthenticationInPrivateModesEnabled = 2;
}

// Allow websites to query for available payment methods.
//
// Allows you to set whether websites are allowed to check if the user has
// payment methods saved.
//
// If this policy is set to disabled, websites that use
// PaymentRequest.canMakePayment or PaymentRequest.hasEnrolledInstrument API
// will be informed that no payment methods are available.
//
// If the setting is enabled or not set then websites are allowed to check if
// the user has payment methods saved.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message PaymentMethodQueryEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PaymentMethodQueryEnabled = 2;
}

// Enable stricter treatment for mixed content
//
// This policy has been removed as of M85, please use
// InsecureContentAllowedForUrls to allow insecure content on a per-site basis
// instead.
// This policy controls the treatment for mixed content (HTTP content in HTTPS
// sites) in the browser.
// If the policy is set to true or unset, audio and video mixed content will be
// autoupgraded to HTTPS (i.e. the URL will be rewritten as HTTPS, without a
// fallback if the resource is not available over HTTPS) and a 'Not Secure'
// warning will be shown in the URL bar for image mixed content.
// If the policy is set to false, autoupgrades will be disabled for audio and
// video, and no warning will be shown for images.
// This policy does not affect other types of mixed content other than audio,
// video, and images.
// This policy will no longer take effect starting in Google Chrome 84.
//
// Supported on: chrome_os, linux, mac, win
message StricterMixedContentTreatmentEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool StricterMixedContentTreatmentEnabled = 2;
}

// Per-App Time Limits Whitelist
//
// This policy specifies which applications and URLs should be whitelisted for
// per-app usage restrictions.
// The configured whitelist are applied to the apps installed on Google ChromeOS
// for the given user with per-app time limits.
// The configured whitelist can only be applied to child user accounts and take
// effect when PerAppTimeLimits policy is set.
// The configured whitelist are applied to applications and URLs so that they
// will not be blocked by per-app time limits.
// Accessing whitelisted URLs will not count towards the chrome time limit.
// Add url regular expressions to |url_list| to whitelist urls that match any of
// the regular expressions in the list.
// Add an application with its |app_id| and |app_type| to |app_list| to
// whitelist the application.
//
// This policy is deprecated, please use PerAppTimeLimitsAllowlist instead.
//
// Value schema:
// {
//     "properties": {
//         "app_list": {
//             "items": {
//                 "properties": {
//                     "app_id": {
//                         "type": "string"
//                     },
//                     "app_type": {
//                         "enum": [
//                             "ARC",
//                             "BUILT-IN",
//                             "EXTENSION",
//                             "WEB",
//                             "CROSTINI"
//                         ],
//                         "type": "string"
//                     }
//                 },
//                 "type": "object"
//             },
//             "type": "array"
//         },
//         "url_list": {
//             "items": {
//                 "type": "string"
//             },
//             "type": "array"
//         }
//     },
//     "type": "object"
// }
//
// Supported on:
message PerAppTimeLimitsWhitelistProto {
  optional PolicyOptions policy_options = 1;
  optional string PerAppTimeLimitsWhitelist = 2;
}

// Per-App Time Limits Allowlist
//
// This policy specifies which applications and URLs should be allowed for per-
// app usage restrictions.
// The configured allowlist is applied to the apps installed on Google ChromeOS
// for the given user with per-app time limits.
// The configured allowlist can only be applied to child user accounts and take
// effect when PerAppTimeLimits policy is set.
// The configured allowlist is applied to applications and URLs so that they
// will not be blocked by per-app time limits.
// Accessing allowed URLs will not count towards the chrome time limit.
// Add url regular expressions to |url_list| to allow urls that match any of the
// regular expressions in the list.
// Add an application with its |app_id| and |app_type| to |app_list| to allow
// the application.
//
// Value schema:
// {
//     "properties": {
//         "app_list": {
//             "items": {
//                 "properties": {
//                     "app_id": {
//                         "type": "string"
//                     },
//                     "app_type": {
//                         "enum": [
//                             "ARC",
//                             "BUILT-IN",
//                             "EXTENSION",
//                             "WEB",
//                             "CROSTINI"
//                         ],
//                         "type": "string"
//                     }
//                 },
//                 "type": "object"
//             },
//             "type": "array"
//         },
//         "url_list": {
//             "items": {
//                 "type": "string"
//             },
//             "type": "array"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os
message PerAppTimeLimitsAllowlistProto {
  optional PolicyOptions policy_options = 1;
  optional string PerAppTimeLimitsAllowlist = 2;
}

// Enable chrome://devices
//
// This policy controls access to controllable features in the local discovery
// UI (chrome://devices) which shows discoverable devices near the user as well
// as cloud devices registered to them. On all operating systems except for
// Google ChromeOS, the local discovery UI also allows users to add classic
// printers connected to their computers to Google Cloud Print.
//
// Setting the policy to Enabled or not set allow local device discovery.
//
// Setting the policy to Disabled prevents local device discovery.
//
// Valid values:
//   True: Allow local device discovery
//   False: Prevent local device discovery
//
// Supported on:
message LocalDiscoveryEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LocalDiscoveryEnabled = 2;
}

// Allow or deny screen capture
//
// If enabled or not configured (default), a Web page can use
// screen-share APIs (e.g., getDisplayMedia() or the Desktop Capture extension
// API)
// to prompt the user to select a tab, window or desktop to capture.
//
// When this policy is disabled, any calls to screen-share APIs will fail
// with an error; however this policy is not considered (and a site will be
// allowed to use screen-share APIs) if the site matches an origin pattern in
// any of the following policies:
// ScreenCaptureAllowedByOrigins,
// WindowCaptureAllowedByOrigins,
// TabCaptureAllowedByOrigins,
// SameOriginTabCaptureAllowedByOrigins.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ScreenCaptureAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool ScreenCaptureAllowed = 2;
}

// Allow Desktop, Window, and Tab capture by these origins
//
// Setting the policy lets you set a list of URL patterns that can use Desktop,
// Window, and Tab Capture.
//
// Leaving the policy unset means that sites will not be considered for an
// override at this level of Capture.
//
// This policy is not considered if a site matches a URL pattern in any of the
// following policies: WindowCaptureAllowedByOrigins,
// TabCaptureAllowedByOrigins, SameOriginTabCaptureAllowedByOrigins.
//
// If a site matches a URL pattern in this policy, the ScreenCaptureAllowed will
// not be considered.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.  This
// policy only matches based on origin, so any path in the URL pattern is
// ignored.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ScreenCaptureAllowedByOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ScreenCaptureAllowedByOrigins = 2;
}

// Allow Window and Tab capture by these origins
//
// Setting the policy lets you set a list of URL patterns that can use Window
// and Tab Capture.
//
// Leaving the policy unset means that sites will not be considered for an
// override at this level of Capture.
//
// This policy is not considered if a site matches a URL pattern in any of the
// following policies: TabCaptureAllowedByOrigins,
// SameOriginTabCaptureAllowedByOrigins.
//
// If a site matches a URL pattern in this policy, the following policies will
// not be considered: ScreenCaptureAllowedByOrigins, ScreenCaptureAllowed.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.  This
// policy only matches based on origin, so any path in the URL pattern is
// ignored.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WindowCaptureAllowedByOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WindowCaptureAllowedByOrigins = 2;
}

// Allow Tab capture by these origins
//
// Setting the policy lets you set a list of URL patterns that can use Tab
// Capture.
//
// Leaving the policy unset means that sites will not be considered for an
// override at this level of capture.
//
// Note that windowed Chrome Apps will still be allowed to be captured.
//
// This policy is not considered if a site matches a URL pattern in the
// SameOriginTabCaptureAllowedByOrigins policy.
//
// If a site matches a URL pattern in this policy, the following policies will
// not be considered: WindowCaptureAllowedByOrigins,
// ScreenCaptureAllowedByOrigins, ScreenCaptureAllowed.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.  This
// policy only matches based on origin, so any path in the URL pattern is
// ignored.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message TabCaptureAllowedByOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList TabCaptureAllowedByOrigins = 2;
}

// Allow Same Origin Tab capture by these origins
//
// Setting the policy lets you set a list of URL patterns that can capture tabs
// with their same Origin.
//
// Leaving the policy unset means that sites will not be considered for an
// override at this level of capture.
//
// Note that windowed Chrome Apps with the same origin as this site will still
// be allowed to be captured.
//
// If a site matches a URL pattern in this policy, the following policies will
// not be considered: TabCaptureAllowedByOrigins, WindowCaptureAllowedByOrigins,
// ScreenCaptureAllowedByOrigins, ScreenCaptureAllowed.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.  This
// policy only matches based on origin, so any path in the URL pattern is
// ignored.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SameOriginTabCaptureAllowedByOriginsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList SameOriginTabCaptureAllowedByOrigins = 2;
}

// Enable sending downloads to Google for deep scanning for users enrolled in
// the Advanced Protection program
//
// This policy is deprecated, and has been replaced with
// AdvancedProtectionAllowed.
//
// This policy controls whether users enrolled in the Advanced Protection
// program are allowed to send their downloads to Google for malware scanning.
// If set to True or not set, enrolled users will be be prompted to send their
// files to Google for deep scanning. If the user selects 'Scan', their download
// will be sent to Google. If set to False, users will not be prompted and their
// downloads will not be sent to Google.
//
// Supported on:
message AdvancedProtectionDeepScanningEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AdvancedProtectionDeepScanningEnabled = 2;
}

// Enable privacy screen
//
// Enable/disable the privacy screen feature.
//
// If this policy is set to True, privacy screen will always be enabled.
//
// If this policy is set to False, privacy screen will always be disabled.
//
// When this policy is set, the user cannot override the value.
//
// If this policy is left unset, privacy screen is disabled initially but can be
// controlled by the user.
//
// Supported on: chrome_os
message PrivacyScreenEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PrivacyScreenEnabled = 2;
}

// Allows native notifications
//
// This policy is deprecated, please use the 'AllowSystemNotifications' policy
// instead.
//
// Configures whether Google Chrome on Linux will use native notifications.
//
// If set to True or not set, Google Chrome is allowed to use native
// notifications.
//
// If set to False, Google Chrome will not use native notifications. Google
// Chrome's Message Center will be used as a fallback.
//
// Supported on:
message AllowNativeNotificationsProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowNativeNotifications = 2;
}

// Allows system notifications
//
// Configures whether Google Chrome on Linux will use system notifications.
//
// If set to True or not set, Google Chrome is allowed to use system
// notifications.
//
// If set to False, Google Chrome will not use system notifications. Google
// Chrome's Message Center will be used as a fallback.
//
// Valid values:
//   True: Allow system notifications to be used
//   False: Do not allow system notifications to be used
//
// Supported on: linux
message AllowSystemNotificationsProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowSystemNotifications = 2;
}

// Required Client Certificates
//
// Specifies client certificates that should be enrolled using the device
// management protocol.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "cert_profile_id": {
//                 "description": "The identifier for this client certificate.",
//                 "type": "string"
//             },
//             "enable_remote_attestation_check": {
//                 "description": "Enable an additional security check based on
// remote attestation (optional, default: True).",
//                 "type": "boolean"
//             },
//             "key_algorithm": {
//                 "description": "The algorithm for key pair generation.",
//                 "enum": [
//                     "rsa"
//                 ],
//                 "type": "string"
//             },
//             "name": {
//                 "description": "The name of the certificate profile.",
//                 "type": "string"
//             },
//             "policy_version": {
//                 "description": "The client should not interpret this data and
// should forward it verbatim. The DMServer uses policy_version to verify that
// the policy view of DMServer matches the view of ChromeOS device.",
//                 "type": "string"
//             },
//             "renewal_period_seconds": {
//                 "description": "Number of seconds before expiration of a
// certificate when renewal should be triggered",
//                 "type": "integer"
//             }
//         },
//         "required": [
//             "cert_profile_id",
//             "key_algorithm"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os
message RequiredClientCertificateForUserProto {
  optional PolicyOptions policy_options = 1;
  optional string RequiredClientCertificateForUser = 2;
}

// Enable additional protections for users enrolled in the Advanced Protection
// program
//
// This policy controls whether users enrolled in the Advanced Protection
// program receive extra protections. Some of these features may involve the
// sharing of data with Google (for example, Advanced Protection users will be
// able to send their downloads to Google for malware scanning). If set to True
// or not set, enrolled users will receive extra protections. If set to False,
// Advanced Protection users will receive only the standard consumer features.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AdvancedProtectionAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool AdvancedProtectionAllowed = 2;
}

// Enable scrolling to text specified in URL fragments
//
// This feature allows for hyperlinks and address bar URL navigations to target
// specific text within a web page, which will be scrolled to once the loading
// of the web page is complete.
//
// If you enable or don't configure this policy, web page scrolling to specific
// text fragments via URL will be enabled.
//
// If you disable this policy, web page scrolling to specific text fragments via
// URL will be disabled.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ScrollToTextFragmentEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ScrollToTextFragmentEnabled = 2;
}

// Show the display password button on the login and lock screen
//
// When enabled, this feature shows a button on the login and lock screen that
// allows the password to be displayed.
// It is represented as an eye icon on the password textfield. The button is
// absent when the feature is disabled.
//
// Supported on: chrome_os
message LoginDisplayPasswordButtonEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LoginDisplayPasswordButtonEnabled = 2;
}

// Enable Get Image Descriptions from Google.
//
// The Get Image Descriptions from Google
// accessibility feature enables visually-impaired screen reader users to
// get descriptions of unlabeled images on the web. Users who choose to enable
// it
// will have the option of using an anonymous Google service to provide
// automatic descriptions for unlabeled images they encounter on the web.
//
// If this feature is enabled, the content of images will be sent to Google
// servers in order to generate a description. No cookies or other user
// data is sent, and Google does not save or log any image content.
//
// If this policy is set to Enabled, the
// Get Image Descriptions from Google
// feature will be enabled, though it will only affect users who are using a
// screen reader or other similar assistive technology.
//
// If this policy is set to Disabled, users will not have the option of enabling
// the feature.
//
// If this policy is not set, user can choose to use this feature or not.
//
// Valid values:
//   True: Use an anonymous Google service to provide automatic descriptions for
// unlabeled images
//   False: Do not use Google services to provide automatic image descriptions
//   None: Let users choose to use an anonymous Google service to provide
// automatic descriptions for unlabeled images
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AccessibilityImageLabelsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AccessibilityImageLabelsEnabled = 2;
}

// Control the IntensiveWakeUpThrottling feature.
//
// When enabled the IntensiveWakeUpThrottling feature causes Javascript timers
// in background tabs to be aggressively throttled and coalesced, running no
// more than once per minute after a page has been backgrounded for 5 minutes or
// more.
//
// This is a web standards compliant feature, but it may break functionality
// on some websites by causing certain actions to be delayed by up to a
// minute. However, it results in significant CPU and battery savings when
// enabled. See https://bit.ly/30b1XR4 for more details.
//
// If this policy is set to enabled then the feature will be force enabled, and
// users will not be able to override this.
//
// If this policy is set to disabled then the feature will be force disabled,
// and
// users will not be able to override this.
//
// If this policy is left unset then the feature will be controlled by its
// own internal logic, which can be manually configured by users.
//
// Note that the policy is applied per renderer process, with the most recent
// value of the policy setting in force when a renderer process starts. A full
// restart is required to ensure that all loaded tabs receive a consistent
// policy setting. It is harmless for processes to be running with different
// values of this policy.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message IntensiveWakeUpThrottlingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool IntensiveWakeUpThrottlingEnabled = 2;
}

// Control the BackForwardCache feature.
//
// When enabled the BackForwardCache feature allows the use of the back-forward
// cache. When navigating away from a page, its current state (document tree,
// script, etc.) may be preserved in the back-forward cache. If the browser
// navigates back to the page, the page may be restored from the back-forward
// cache and displayed in the state it was in before being cached.
//
// This feature might cause issues for some websites that do not expect this
// caching. In particular, some websites depend on the "unload" event being
// dispatched when the browser navigates away from the page. The "unload" event
// will not be dispatched if the page enters the back-forward cache.
//
// If this policy is set to enabled or not set,
// the BackForwardCache feature will be enabled.
//
// If this policy is set to disabled then the feature will be force disabled.
//
// Valid values:
//   True: Allow the back-forward cache to be used
//   False: Do not allow the back-forward cache to be used
//
// Supported on: android
message BackForwardCacheEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool BackForwardCacheEnabled = 2;
}

// Enable PIN auto-submit feature on the lock and login screen.
//
// The PIN auto-submit feature changes how PINs are entered in ChromeOS.
// Instead of showing the same textfield that is used for password input, this
// feature shows a special UI that clearly shows to the user how many
// digits are necessary for their PIN. As a consequence, the user's PIN length
// will be stored outside the user encrypted data. Only supports PINs that are
// between 6 and 12 digits long.
//
// If this policy is set to false, users will not have the option of enabling
// the feature on the Settings page.
//
// Supported on: chrome_os
message PinUnlockAutosubmitEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PinUnlockAutosubmitEnabled = 2;
}

// Enable Emoji Suggestion
//
// This policy enables Google ChromeOS to suggest emojis when users type text
// with their virtual or physical keyboards.
// If this policy is set to true, the feature will be enabled, and users will be
// able to change it.
// This policy is defaulted to false, no emoji will be suggested and users
// cannot override it.
//
// Supported on: chrome_os
message EmojiSuggestionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool EmojiSuggestionEnabled = 2;
}

// Control the User-Agent Client Hints feature.
//
// Note that this policy was removed in M94.  This policy was intended for
// short-term adaptation purposes only.
//
// When enabled the User-Agent Client Hints feature sends granular request
// headers providing information about the user browser and environment.
// This is an additive feature, but the new headers may break some websites that
// restrict the characters that requests may contain.
// If this policy is enabled or not set the User-Agent Client Hints feature is
// enabled. If the policy is disabled the feature is unavailable.
//
// Supported on:
message UserAgentClientHintsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserAgentClientHintsEnabled = 2;
}

// Control the User-Agent Client Hints GREASE Update feature.
//
// When enabled the User-Agent Client Hints GREASE Update feature aligns the
// User-Agent GREASE algorithm with the latest spec.
// The updated spec may break some websites that restrict the characters that
// requests may contain. See the spec for more information:
// https://wicg.github.io/ua-client-hints/#grease
// If this policy is enabled or not set, the browser will decide which User-
// Agent GREASE algorithm to use. If the policy is disabled the prior User-Agent
// GREASE algorithm is used.
// This policy is a temporary measure and will be removed in a future release.
//
// Valid values:
//   True: Allow the updated User-Agent GREASE algorithm to be run.
//   False: Force the prior User-Agent GREASE algorithm to be used.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message UserAgentClientHintsGREASEUpdateEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserAgentClientHintsGREASEUpdateEnabled = 2;
}

// Control the URL parameter filter feature
//
// When enabled or not set, the URL parameter filter may remove some parameters
// when a user selects "Open Link in Incognito Window" from the context menu.
// When disabled, no filtering is performed.
// This policy is temporary and may be removed in a future release.
//
// Valid values:
//   True: Allow the browser to filter URL parameters.
//   False: Disallow any filtering of URL parameters.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message UrlParamFilterEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool UrlParamFilterEnabled = 2;
}

// Enable Suggested Content
//
// This feature enables suggestions for new content to explore. Includes apps,
// webpages, and more.
// If this policy is set to True, then suggestions for new content to explore
// will be enabled.
// If this policy is set to False, then suggestions for new content to explore
// will be disabled.
// If this policy is left unset, then suggestions for new content to explore
// will be disabled for managed users and enabled for other users.
//
// Supported on: chrome_os
message SuggestedContentEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SuggestedContentEnabled = 2;
}

// Show Full URLs
//
// This feature enables display of the full URL in the address bar.
// If this policy is set to True, then the full URL will be shown in the address
// bar, including schemes and subdomains.
// If this policy is set to False, then the default URL display will apply.
// If this policy is left unset, then the default URL display will apply and the
// user will be able to toggle between default and full URL display with a
// context menu option.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ShowFullUrlsInAddressBarProto {
  optional PolicyOptions policy_options = 1;
  optional bool ShowFullUrlsInAddressBar = 2;
}

// Enable warnings for insecure forms
//
// This policy controls the treatment for insecure forms (forms that submit over
// HTTP) embedded in secure (HTTPS) sites in the browser.
// If the policy is enabled or unset, a full page warning will be shown when an
// insecure form is submitted. Additionally, a warning bubble will be shown next
// to the form fields when they are focused, and autofill will be disabled for
// those forms.
// If the policy is disabled, warnings will not be shown for insecure forms, and
// autofill will work normally.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message InsecureFormsWarningsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool InsecureFormsWarningsEnabled = 2;
}

// Suppress lookalike domain warnings on domains
//
// This policy prevents the display of lookalike URL warnings on the sites
// listed. These warnings are typically shown on sites that Google Chrome
// believes might be trying to spoof another site the user is familiar with.
//
// If the policy is enabled and set to one or more domains, no lookalike
// warnings pages will be shown when the user visits pages on that domain.
//
// If the policy is not set, or set to an empty list, warnings may appear on any
// site the user visits.
//
// A hostname can be allowed with a complete host match, or any domain match.
// For example, a URL like "https://foo.example.com/bar" may have warnings
// suppressed if this list includes either "foo.example.com" or "example.com".
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message LookalikeWarningAllowlistDomainsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList LookalikeWarningAllowlistDomains = 2;
}

// Enable ToS during first-run for CCT
//
// This policy is deprecated, please use the ToSDialogBehavior policy instead.
//
// By default the Terms of Service are shown when CCT is first-run. Setting this
// policy to Disabled will cause the Terms of Service dialog to not appear
// during the first-run-experience or subsequent runs. Setting this policy to
// Enabled or leaving it unset will cause the Terms of Service dialog to appear
// during the first-run-experience. The other caveats are:
//
// - This policy only works on fully managed Android devices that can be
// configured by Unified Endpoint Management vendors.
//
// - If this policy is Disabled the BrowserSignin policy will have no effect.
//
// - If this policy is Disabled metrics​ will not be sent to the server.
//
// - If this policy is Disabled the browser will have limited functionality.
//
// - If this policy is Disabled admins must communicate this to end users of the
// device.
//
// Supported on:
message CCTToSDialogEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool CCTToSDialogEnabled = 2;
}

// Configuring the ToS behavior during first-run for CCT
//
// By default the Terms of Service are shown when CCT is first-run. Setting this
// policy to SkipTosDialog will cause the Terms of Service dialog to not appear
// during the first-run-experience or subsequent runs. Setting this policy to
// StandardTosDialog or leaving it unset will cause the Terms of Service dialog
// to appear during the first-run-experience. The other caveats are:
//
// - This policy only works on fully managed Android devices that can be
// configured by Unified Endpoint Management vendors.
//
// - If this policy is SkipTosDialog the BrowserSignin policy will have no
// effect.
//
// - If this policy is SkipTosDialog metrics​ will not be sent to the server.
//
// - If this policy is SkipTosDialog the browser will have limited
// functionality.
//
// - If this policy is SkipTosDialog admins must communicate this to end users
// of the device.
//
// Valid values:
//   1: Use default browser behavior, shows the ToS and waits for the user to
// accept.
//   2: Automatically skips ToS and loads the browser.
//
// Supported on: android
message TosDialogBehaviorProto {
  optional PolicyOptions policy_options = 1;
  optional int64 TosDialogBehavior = 2;
}

// Suppress Google Cloud Print deprecation messages
//
// This policy controls whether Google Cloud Print deprecation warnings are
// shown to users in the print preview dialog or settings pages.
// Setting this policy to True will hide the deprecation warnings.
// Setting this policy to False or leaving it unset will show the deprecation
// warnings.
//
// Valid values:
//   True: Hide Google Cloud Print deprecation warnings
//   False: Show Google Cloud Print deprecation warnings
//
// Supported on:
message CloudPrintWarningsSuppressedProto {
  optional PolicyOptions policy_options = 1;
  optional bool CloudPrintWarningsSuppressed = 2;
}

// Enable deprecated privet printing
//
// This policy controls whether any available privet printers are shown to users
// in the print preview dialog.
// Setting this policy to Enabled will show available privet printers.
// Setting this policy to Disabled or leaving it unset will result in privet
// printers not appearing in print preview, as this printing method is
// deprecated.
//
// Valid values:
//   True: Enable deprecated privet printing
//   False: Disable deprecated privet printing
//
// Supported on:
message EnableDeprecatedPrivetPrintingProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnableDeprecatedPrivetPrinting = 2;
}

// Set minimal size limit for data leak prevention clipboard restriction
//
// This policy sets the minimal data size (in bytes) of the data in the
// clipboard that will be checked against clipboard restriction rules defined in
// DataLeakPreventionRulesList policy.
// If not set, it defaults to 0 that means that all pastes from the clipboard
// will be checked according to the configured rules.
//
// Supported on: chrome_os
message DataLeakPreventionClipboardCheckSizeLimitProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DataLeakPreventionClipboardCheckSizeLimit = 2;
}

// Enable data leak prevention reporting
//
// This policy is a general switch for all rules defined in the
// DataLeakPreventionRulesList policy.
// Setting this policy to True will switch on real-time reporting of data leak
// prevention events.
// Setting this policy to False or leaving it unset will switch off the
// reporting.
// Rules defined with ALLOW level restrictions in DataLeakPreventionRulesList
// will not report events in both cases.
//
// Valid values:
//   True: Enable reporting of data leak prevention events
//   False: Disable reporting of data leak prevention events
//
// Supported on: chrome_os
message DataLeakPreventionReportingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DataLeakPreventionReportingEnabled = 2;
}

// Sets a list of data leak prevention rules.
//
// Configures a list of rules to prevent data leak on Google ChromeOS.
// Data leak can happen by copying and pasting data, transferring files,
// printing, screensharing, or taking screenshots ...etc.
//
// Each rule consists of the following:
// - A list of sources defined as URLs. Any data in the sources will be
// considered confidential data, to which the restrictions will be applied.
// - A list of destinations defined as URLs or components, to which the
// confidential data is either allowed or disallowed to be shared.
// - A list of restrictions to be applied on the data of the sources.
//
// Rules can be added to:
// - Control the clipboard data shared between the sources and the destinations.
// - Control taking screenshots of any of the sources.
// - Control printing of any of the sources.
// - Control the privacy screen when any of the sources is visible.
// - Control screen sharing of any of the sources.
//
// The restriction level can be set to BLOCK, ALLOW, REPORT, WARN.
// - If the restriction level is set to BLOCK, the action won't be allowed. If
// DataLeakPreventionReportingEnabled is set to True, the blocked action will be
// reported to the admin.
// - If the restriction level is set to ALLOW, the action will be allowed.
// - If the restriction level is set to REPORT and
// DataLeakPreventionReportingEnabled is set to True, the action will be
// reported to the admin.
// - If the restriction level is set to WARN, a user will be warned and may
// choose to proceed with or cancel the action. If
// DataLeakPreventionReportingEnabled is set to True, showing the warning will
// be reported to the admin; proceeding with the action will also be reported.
//
// Notes:
// - PRIVACY_SCREEN restriction doesn't block the ability to turn on privacy
// screen, but enforces it when the restriction class is set to BLOCK.
// - Destinations cannot be empty in case one of the restrictions is CLIPBOARD,
// but they don't make any difference for the remaining restrictions.
// - Format the URL patterns according to this format (
// https://www.chromium.org/administrators/url-blocklist-filter-format ).
//
// If the policy is left not set, no restrictions will be applied.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "description": {
//                 "type": "string"
//             },
//             "destinations": {
//                 "properties": {
//                     "components": {
//                         "items": {
//                             "enum": [
//                                 "ARC",
//                                 "CROSTINI",
//                                 "PLUGIN_VM"
//                             ],
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "urls": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     }
//                 },
//                 "type": "object"
//             },
//             "name": {
//                 "type": "string"
//             },
//             "restrictions": {
//                 "items": {
//                     "properties": {
//                         "class": {
//                             "enum": [
//                                 "CLIPBOARD",
//                                 "SCREENSHOT",
//                                 "PRINTING",
//                                 "PRIVACY_SCREEN",
//                                 "SCREEN_SHARE"
//                             ],
//                             "type": "string"
//                         },
//                         "level": {
//                             "enum": [
//                                 "BLOCK",
//                                 "ALLOW",
//                                 "REPORT",
//                                 "WARN"
//                             ],
//                             "type": "string"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "sources": {
//                 "properties": {
//                     "urls": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     }
//                 },
//                 "type": "object"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os
message DataLeakPreventionRulesListProto {
  optional PolicyOptions policy_options = 1;
  optional string DataLeakPreventionRulesList = 2;
}

// Allow legacy TLS/DTLS downgrade in WebRTC
//
// If enabled, WebRTC peer connections can downgrade to obsolete
// versions of the TLS/DTLS (DTLS 1.0, TLS 1.0 and TLS 1.1) protocols.
// When this policy is disabled or not set, these TLS/DTLS versions are
// disabled.
//
// This policy is temporary and will be removed in a future version
// of Google Chrome.
//
// Valid values:
//   True: Allow WebRTC to use obsolete versions of the TLD/DTLS protocol
//   False: Prevent WebRTC from using obsolete versions of TLS/DTLS
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebRtcAllowLegacyTLSProtocolsProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebRtcAllowLegacyTLSProtocols = 2;
}

// Enable Media Recommendations
//
// By default the browser will show media recommendations that are personalized
// to the user. Setting this policy to Disabled will result in these
// recommendations being hidden from the user. Setting this policy to Enabled or
// leaving it unset will result in the media recommendations being shown to the
// user.
//
// Valid values:
//   True: Show media recommendations to the user
//   False: Hide media recommendations from the user
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message MediaRecommendationsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool MediaRecommendationsEnabled = 2;
}

// The valid version of Edu Coexistence Terms of Service
//
// This policy indicates current valid version of Edu Coexistence Terms of
// Service.
// It is compared with the version last accepted by the parent and used to
// prompt parent permission renewal when needed.
//
// When this policy is set Terms of Service version can be validated.
// When this policy is unset it is not possible to verify validity of Edu
// Coexistence Terms of Service.
//
// This policy is only used for Family Link users.
//
// Supported on: chrome_os
message EduCoexistenceToSVersionProto {
  optional PolicyOptions policy_options = 1;
  optional string EduCoexistenceToSVersion = 2;
}

// Browsing Data Lifetime Settings
//
// Configures browsing data lifetime settings for Google Chrome. This policy
// allows admins to configure (per data-type) when data is deleted by the
// browser. This is useful for customers that work with sensitive customer data.
// The policy will only take effect if SyncDisabled is set to true.
//
// The available data types are 'browsing_history', 'download_history',
// 'cookies_and_other_site_data', 'cached_images_and_files', 'password_signin',
// 'autofill', 'site_settings' and 'hosted_app_data'.
//
// The browser will automatically remove data of selected types that is older
// than 'time_to_live_in_hours'. The minimum value that can be set is 1 hour.
//
// The deletion of expired data will happen 15 seconds after the browser starts
// then every hour while the browser is running.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "data_types": {
//                 "items": {
//                     "enum": [
//                         "browsing_history",
//                         "download_history",
//                         "cookies_and_other_site_data",
//                         "cached_images_and_files",
//                         "password_signin",
//                         "autofill",
//                         "site_settings",
//                         "hosted_app_data"
//                     ],
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "time_to_live_in_hours": {
//                 "minimum": 1,
//                 "type": "integer"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message BrowsingDataLifetimeProto {
  optional PolicyOptions policy_options = 1;
  optional string BrowsingDataLifetime = 2;
}

// Allow usage of Lacros
//
// This setting is deprecated. Use LacrosAvailability instead.
//
// If this policy is set to Disabled or unset, the user cannot use Lacros.
//
// If this policy is set to Enabled, the user can use the Lacros browser.
//
// Valid values:
//   True: Allow users to use the Lacros browser
//   False: Prevent users from using the Lacros browser
//
// Supported on:
message LacrosAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool LacrosAllowed = 2;
}

// Allow users to create and use secondary profiles, and use guest mode in the
// Lacros browser
//
// This setting allows users to create and use secondary profiles, and use guest
// mode in the Lacros browser.
//
// Similar to both BrowserAddPersonEnabled and BrowserGuestModeEnabled, if this
// policy is set to false or unset, the user cannot create or use secondary
// profiles, and use guest mode. Previously created secondary profiles, if any,
// will be unavailable.
//
// If this policy is set to true, the user can create and use secondary
// profiles, and use guest mode.
//
// Note: If this policy is set to true but BrowserAddPersonEnabled is set to
// false, the user cannot create secondary profiles. The same for
// BrowserGuestModeEnabled and guest mode.
//
// Valid values:
//   True: Allow users to create and use secondary profiles, and use guest mode
// in the Lacros browser
//   False: Prevent users from creating and using secondary profiles, and from
// using guest mode in the Lacros browser
//
// Supported on: chrome_os
message LacrosSecondaryProfilesAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool LacrosSecondaryProfilesAllowed = 2;
}

// Make the Lacros browser available
//
// This setting provides several availability options for the Lacros browser.
//
// If the policy is set to user_choice, the user can enable Lacros and make it
// primary.
//
// If the policy is set to lacros_disallowed, the user cannot use Lacros.
//
// If the policy is set to side_by_side, Lacros is enabled but is not the
// primary browser.
//
// If the policy is set to lacros_primary, Lacros is enabled and is the primary
// browser.
//
// If the policy is unset, the default is lacros_disallowed for enterprise-
// managed users and user_choice for non-managed users.
//
// In the future it will be possible to make Lacros the only available browser
// in Google ChromeOS with lacros_only value.
//
// Valid values:
//   user_choice: Allow users to enable Lacros and make it the primary browser
//   lacros_disallowed: Prevent users from using Lacros
//   side_by_side: Enable Lacros
//   lacros_primary: Enable Lacros and make it the primary browser
//   lacros_only: Make Lacros the only available browser (not implemented yet)
//
// Supported on: chrome_os
message LacrosAvailabilityProto {
  optional PolicyOptions policy_options = 1;
  optional string LacrosAvailability = 2;
}

// Allow reusing the Google ChromeOS login credentials for network
// authentication
//
// This policy is deprecated, please configure Kerberos policies to reuse the
// login password instead.
//
// Valid values:
//   True: The Google ChromeOS login credentials will be used for network
// authentication to a managed proxy.
//   False: The Google ChromeOS login credentials will not be used for network
// authentication.
//
// Supported on:
message IntegratedWebAuthenticationAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool IntegratedWebAuthenticationAllowed = 2;
}

// Clear Browsing Data on Exit
//
// Configures a list of browsing data types that should be deleted when the user
// closes all browser windows. The available data types are browsing history
// (browsing_history), download history (download_history), cookies
// (cookies_and_other_site_data), cache (cached_images_and_files), autofill
// (autofill), passwords (password_signin), site settings (site_settings) and
// hosted apps data (hosted_app_data). This policy does not take precedence over
// AllowDeletingBrowserHistory.
//
// This policy requires the SyncDisabled policy to be set to true, otherwise it
// will be ignored. If this policy is set at platform level, Sync should be
// disabled at platform level. If this policy is set at user level, Sync should
// be disabled for that user in order for this policy to take effect.
//
// If Google Chrome does not exit cleanly (for example, if the browser or the OS
// crashes), the browsing data will be cleared the next time the profile is
// loaded.
//
// Valid values:
//   browsing_history: Browsing history
//   download_history: Download history
//   cookies_and_other_site_data: Cookies and other site data
//   cached_images_and_files: Cached images and files
//   password_signin: Password signin
//   autofill: Autofill
//   site_settings: Site settings
//   hosted_app_data: Hosted apps data
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ClearBrowsingDataOnExitListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ClearBrowsingDataOnExitList = 2;
}

// Profile picker availability on startup
//
// Specifies whether the profile picker is enabled, disabled or forced at the
// browser startup.
//
// By default the profile picker is not shown if the browser starts in guest or
// incognito mode, a profile directory and/or urls are specified by command
// line, an app is explicitly requested to open, the browser was launched by a
// native notification, there is only one profile available or the policy
// ForceBrowserSignin is set to true.
//
// If 'Enabled' (0) is selected or the policy is left unset, the profile picker
// will be shown at startup by default, but users will be able to enable/disable
// it.
//
// If 'Disabled' (1) is selected, the profile picker will never be shown, and
// users will not be able to change the setting.
//
// If 'Forced' (2) is selected, the profile picker cannot be suppressed by the
// user. The profile picker will be shown even if there is only one profile
// available.
//
// Valid values:
//   0: Profile picker available at startup
//   1: Profile picker disabled at startup
//   2: Profile picker forced at startup
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ProfilePickerOnStartupAvailabilityProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ProfilePickerOnStartupAvailability = 2;
}

// Enable signin interception
//
// This settings enables or disables signin interception.
//
// When this policy not set or is enabled, the signin interception dialog
// triggers when a Google account is added on the web, and the user may benefit
// from moving this account to another (new or existing) profile.
//
// When this is disabled, the signin interception dialog does not trigger.
// When this is disabled, a dialog will still be shown if managed account
// profile separation is enforced by ManagedAccountsSigninRestriction.
//
// Valid values:
//   True: Enable signin interception
//   False: Disable signin interception
//   None: Enable signin interception
//
// Supported on: fuchsia, linux, mac, win
message SigninInterceptionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SigninInterceptionEnabled = 2;
}

// Allow creating WebXR's "immersive-ar" sessions
//
// Configures whether the sites that the user navigates to are allowed to create
// immersive Augmented Reality sessions using WebXR Device API.
//
// When this policy is unset or enabled, the WebXR Device API will accept
// "immersive-ar" during session creation, thus allowing the users to enter
// Augmented Reality experiences.
//
// When this policy is disabled, the WebXR Device API will reject requests to
// create sessions with mode set to "immersive-ar". The existing "immersive-ar"
// sessions (if any) will not be terminated.
//
// For more details about "immersive-ar" sessions, please see WebXR Augmented
// Reality Module specfication.
//
// Valid values:
//   True: Allow creating WebXR's "immersive-ar" sessions
//   False: Prevent creating WebXR's "immersive-ar" sessions
//
// Supported on: android
message WebXRImmersiveArEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebXRImmersiveArEnabled = 2;
}

// Configuration policy for the File System Enterprise Connector handling of
// downloaded files
//
// List of settings to be applied to the File System Enterprise Connector, which
// triggers when a file is downloaded.
//
// The url_list, mime_types, enable and disable fields are used to determine if
// the connector should send a file to the service provider when downloading
// from a web page. The web page URL must match a pattern associated to an
// 'enable' pattern and not associated to a 'disable' pattern.  The file's MIME
// type must also match a pattern associated to an 'enable' pattern and not
// associated to a 'disable' pattern.
//
// The service_provider field identifies which analysis service provider the
// settings correspond to.
//
// The enterprise_id field is a unique ID for a partner service provider that
// identifies the customer's account with the service provider. When the user is
// asked to sign in as part of setting up the File System Enterprise Connector,
// only user accounts associated with this customer's service provider account
// are permitted.
//
// This policy can only be set from the Google Admin console.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "disable": {
//                 "items": {
//                     "properties": {
//                         "mime_types": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "domain": {
//                 "type": "string"
//             },
//             "enable": {
//                 "items": {
//                     "properties": {
//                         "mime_types": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         },
//                         "url_list": {
//                             "items": {
//                                 "type": "string"
//                             },
//                             "type": "array"
//                         }
//                     },
//                     "type": "object"
//                 },
//                 "type": "array"
//             },
//             "enterprise_id": {
//                 "type": "string"
//             },
//             "service_provider": {
//                 "enum": [
//                     "box"
//                 ],
//                 "type": "string"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message SendDownloadToCloudEnterpriseConnectorProto {
  optional PolicyOptions policy_options = 1;
  optional string SendDownloadToCloudEnterpriseConnector = 2;
}

// Web App management settings
//
// This policy allows an admin to specify settings for installed web apps.
//
// This policy maps a Web App ID to its specific setting. A default
// configuration can be set using the special ID "*", which applies to all web
// apps without a custom configuration in this policy.
//
// The "manifest_id" field is the Manifest ID for the Web App. See
// https://developer.chrome.com/blog/pwa-manifest-id/ for instructions on how to
// determine the Manifest ID for an installed web app.
// The "run_on_os_login" field specifies if a web app can be run during OS
// login. If this field is set to "blocked", the web app will not run during OS
// login and the user will not be able to enable this later. If this field is
// set to "run_windowed", the web app will run during OS login and the user will
// not be able to disable this later. If this field is set to "allowed", the
// user will be able to configure the web app to run at OS login. The default
// configuration only allows the "allowed" and "blocked" values.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "manifest_id": {
//                 "type": "string"
//             },
//             "run_on_os_login": {
//                 "enum": [
//                     "allowed",
//                     "blocked",
//                     "run_windowed"
//                 ],
//                 "type": "string"
//             }
//         },
//         "required": [
//             "manifest_id"
//         ],
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: fuchsia, linux, mac, win
message WebAppSettingsProto {
  optional PolicyOptions policy_options = 1;
  optional string WebAppSettings = 2;
}

// Fetch keepalive duration on Shutdown
//
// Controls the duration (in seconds) allowed for keepalive requests on browser
// shutdown.
//
// When specified, browser shutdown can be blocked up to the specified seconds,
// to process keepalive (https://fetch.spec.whatwg.org/#request-keepalive-flag)
// requests.
//
// The default value (0) means this feature is disabled.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message FetchKeepaliveDurationSecondsOnShutdownProto {
  optional PolicyOptions policy_options = 1;
  optional int64 FetchKeepaliveDurationSecondsOnShutdown = 2;
}

// Suppress JavaScript Dialogs triggered from different origin subframes
//
// As described in https://www.chromestatus.com/feature/5148698084376576 ,
// JavaScript modal dialogs, triggered by window.alert, window.confirm, and
// window.prompt, will be blocked in Google Chrome if triggered from a subframe
// whose origin is different from the main frame origin.
// This policy allows overriding that change.
// If the policy is set to enabled or unset, JavaScript dialogs triggered from a
// different origin subframe will be blocked.
// If the policy is set to disabled, JavaScript dialogs triggered from a
// different origin subframe will not be blocked.
//
// This policy will be removed in Google Chrome version 95.
//
// Valid values:
//   True: Block JavaScript dialogs triggered from a different origin subframe.
//   False: Allow JavaScript dialogs triggered from a different origin subframe.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message SuppressDifferentOriginSubframeDialogsProto {
  optional PolicyOptions policy_options = 1;
  optional bool SuppressDifferentOriginSubframeDialogs = 2;
}

// Allow users to use Borealis on Google ChromeOS
//
// Controls the availability of Borealis for this user.
//
// If the policy is set to false, Borealis will be unavailable. Otherwise (when
// the policy is unset, or true) Borealis will be available if and only if no
// other policy or setting disables it.
//
// Valid values:
//   True: Do not prevent Borealis from running for a user
//   False: Prevent Borealis from running for a user
//
// Supported on: chrome_os
message UserBorealisAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool UserBorealisAllowed = 2;
}

// Allow the audio process to run with priority above normal on Windows
//
// This policy controls the priority of the audio process on Windows.
// If this policy is enabled, the audio process will run with above normal
// priority.
// If this policy is disabled, the audio process will run with normal priority.
// If this policy is not set, the default configuration for the audio process
// will be used.
// This policy is intended as a temporary measure to give enterprises the
// ability to
// run audio with higher priority to address certain performance issues with
// audio capture.
// This policy will be removed in the future.
//
// Valid values:
//   True: Use high priority for audio process
//   False: Use normal Priority for audio process
//   None: Use default priority for audio process
//
// Supported on: win
message AudioProcessHighPriorityEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AudioProcessHighPriorityEnabled = 2;
}

// Configure the content and order of preferred languages
//
// This policy allows admins to configure the order of the preferred languages
// in Google Chrome's settings.
//
// The order of the list will appear in the same order under the "Order
// languages based on your preference" section in chrome://settings/languages.
// Users won't be able to remove or reorder languages set by the policy, but
// will be able to add languages underneath those set by the policy. Users will
// also have full control over the browser's UI language and translation/spell
// check settings, unless enforced by other policies.
//
// Leaving the policy unset lets users manipulate the entire list of preferred
// languages.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ForcedLanguagesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ForcedLanguages = 2;
}

// Configure the color of the browser's theme
//
// This policy allows admins to configure the color of Google Chrome's theme.
// The input string should be a valid hex color string matching the format
// "#RRGGBB".
//
// Setting the policy to a valid hex color causes a theme based on that color to
// be automatically generated and applied to the browser. Users won't be able to
// change the theme set by the policy.
//
// Leaving the policy unset lets users change their browser's theme as
// preferred.
//
// Supported on: fuchsia, linux, mac, win
message BrowserThemeColorProto {
  optional PolicyOptions policy_options = 1;
  optional string BrowserThemeColor = 2;
}

// The IP handling policy of WebRTC
//
// This policy allows restricting which IP addresses and interfaces WebRTC uses
// when attempting to find the best available connection. See RFC 8828 section
// 5.2 (https://tools.ietf.org/html/rfc8828.html#section-5.2). When unset,
// defaults to using all available interfaces.
//
// Valid values:
//   default: WebRTC will use all available interfaces when searching for the
// best path.
//   default_public_and_private_interfaces: WebRTC will only use the interface
// connecting to the public Internet, but may connect using private IP
// addresses.
//   default_public_interface_only: WebRTC will only use the interface
// connecting to the public Internet, and will not connect using private IP
// addresses.
//   disable_non_proxied_udp: WebRTC will use TCP on the public-facing
// interface, and will only use UDP if supported by a configured proxy.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WebRtcIPHandlingProto {
  optional PolicyOptions policy_options = 1;
  optional string WebRtcIPHandling = 2;
}

// Enable PDF Annotations
//
// Controls if the PDF viewer in Google Chrome can annotate PDFs.
//
// When this policy is not set, or is set to true, then the PDF viewer will be
// able to annotate PDFs.
//
// When this policy is set to false, then the PDF viewer will not be able to
// annotate PDFs.
//
// Valid values:
//   True: The PDF viewer can annotate PDFs
//   False: The PDF viewer cannot annotate PDFs
//
// Supported on: chrome_os
message PdfAnnotationsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PdfAnnotationsEnabled = 2;
}

// Explicitly allowed network ports
//
// There is a list of restricted ports built into Google Chrome. Connections to
// these ports will fail. This setting permits bypassing that list. The value is
// a comma-separated list of zero or more ports that outgoing connections will
// be permitted on.
//
// Ports are restricted to prevent Google Chrome being used as a vector to
// exploit various network vulnerabilities. Setting this policy may expose your
// network to attacks. This policy is intended as a temporary workaround for
// errors with code "ERR_UNSAFE_PORT" while migrating a service running on a
// blocked port to a standard port (ie. port 80 or 443).
//
// Malicious websites can easily detect that this policy is set, and for what
// ports, and use that information to target attacks.
//
// Each port here is labelled with a date that it can be unblocked until. After
// that date the port will be restricted regardless of this setting.
//
// Leaving the value empty or unset means that all restricted ports will be
// blocked. If there is a mixture of valid and invalid values, the valid ones
// will be applied.
//
// This policy overrides the "--explicitly-allowed-ports" command-line option.
//
// Valid values:
//   554: port 554 (can be unblocked until 2021/10/15)
//   10080: port 10080 (can be unblocked until 2022/04/01)
//   6566: port 6566 (can be unblocked until 2021/10/15)
//   989: port 989 (can be unblocked until 2022/02/01)
//   990: port 990 (can be unblocked until 2022/02/01)
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ExplicitlyAllowedNetworkPortsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList ExplicitlyAllowedNetworkPorts = 2;
}

// Display the logout confirmation dialog
//
// The policy only applies to managed guest sessions.
// Setting the policy to True or leaving it unset will show a dialog asking the
// user to confirm or deny logout when the last window is closed.
// Setting the policy to False will prevent the dialog from being displayed and
// therefore also disables auto-logout after closing the last window.
//
// Valid values:
//   True: Show logout dialog on last window closed.
//   False: Suppress showing logout dialog on last window closed.
//
// Supported on: chrome_os
message SuggestLogoutAfterClosingLastWindowProto {
  optional PolicyOptions policy_options = 1;
  optional bool SuggestLogoutAfterClosingLastWindow = 2;
}

// Enable 3DES cipher suites in TLS
//
// Warning: 3DES will be completely removed from Google Chrome in version 95
// (around October 2021) and this policy will stop working then.
//
// If the policy is set to true, then 3DES cipher suites in TLS will be enabled.
// If it is set to false, they will be disabled. If the policy is unset, 3DES
// cipher suites are disabled by default. This policy may be used to temporarily
// retain compatibility with an outdated server. This is a stopgap measure and
// the server should be reconfigured.
//
// Valid values:
//   True: 3DES cipher suites will be enabled in TLS
//   False: 3DES cipher suites will be disabled in TLS
//   None: Use the default setting for 3DES cipher suites in TLS
//
// Supported on:
message TripleDESEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool TripleDESEnabled = 2;
}

// Add restrictions on managed accounts
//
//
// Default behavior (Policy unset)
// When an account is added in the content area a small dialog may appear asking
// the user to create a new profile.  This dialog is dismissable.
//
// ManagedAccountsSigninRestriction = 'primary_account'
// If a user signs into a Google service for the first time in a Google Chrome
// browser, a dialog will appear asking the user to create a new profile for
// their enterprise account. The user may click Cancel and get signed out, or
// Continue to create a new profile. Any existing browsing data will not be
// added to the new profile.   The newly created profile is allowed to have
// secondary accounts, for example the user can sign into another account in the
// content area.
//
// ManagedAccountsSigninRestriction = 'primary_account_strict'
// This is the same behavior as 'primary_account' except the newly created
// profile is not allowed to have secondary accounts.
//
// ManagedAccountsSigninRestriction = 'primary_account_keep_existing_data'
// This is the same behavior as 'primary_account' except a checkbox will be
// added to the dialog to allow the user to keep local browsing data.
// If the user checks the box, then the existing profile data becomes associated
// with the Managed account.
// -  All existing browsing data will be present in the new profile.
// -  This data includes bookmarks, history, password, autofill data, open tabs,
// cookies, cache, web storage, extensions, etc.
// If the user does not check the box:
// -  The old profile will continue to exist, no data will be lost.
// -  A new profile will be created.
//
// ManagedAccountsSigninRestriction =
// 'primary_account_strict_keep_existing_data'
// This is the same behavior as 'primary_account_keep_existing_data' except the
// newly created profile is not allowed to have secondary accounts.
//
// Valid values:
//   primary_account: A Managed account must be a primary account and importing
// existing browsing data is allowed at the time of profile creation
//   primary_account_strict: A Managed account must be a primary account and
// have no secondary accounts and importing existing browsing data is allowed at
// the time of profile creation
//   none: No restrictions on managed accounts
//   primary_account_keep_existing_data: A Managed account must be a primary
// account and the user can import existing data at the time of its creation
//   primary_account_strict_keep_existing_data: A Managed account must be a
// primary account and have no secondary accounts and the user can import
// existing data at the time of its creation
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ManagedAccountsSigninRestrictionProto {
  optional PolicyOptions policy_options = 1;
  optional string ManagedAccountsSigninRestriction = 2;
}

// Ask for consent from managed users to share device signals on unmanaged
// devices to gain access
//
//
// Setting the policy to Enabled (True) lets Google Chrome asks for managed
// users' consent prior to sharing device signals on unmanaged devices in order
// to gain access.
//
// Setting the policy to Disabled (False) or leaving it unset disallows Google
// Chrome from collecting device signals
// Examples of device signals include (but are not limited to) OS information,
// registry, file presesnce.
//
// Valid values:
//   True: Enable device signal consenting for managed users on unmanaged
// devices
//   False: Disable device signal consenting for managed users on unmanaged
// devices
//
// Supported on: linux, mac, win
message UnmanagedDeviceSignalsConsentFlowEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool UnmanagedDeviceSignalsConsentFlowEnabled = 2;
}

// Enable lock icon in the omnibox for secure connections
//
// This policy controls the treatment for lock icon in the omnibox.
// From Chrome M93, there is a new omnibox icon for secure connections.
// If the policy is Enabled, Chrome will use the existing lock icon for secure
// connections.
// If the policy is Disabled or not set, Chrome will use the default icon for
// secure connections.
//
// Valid values:
//   True: Use lock icon for secure connections
//   False: Use default icons for secure connections
//
// Supported on:
message LockIconInAddressBarEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool LockIconInAddressBarEnabled = 2;
}

// Control use of JavaScript JIT
//
// Allows you to set whether Google Chrome will run the v8 JavaScript engine
// with JIT (Just In Time) compiler enabled or not.
//
// Disabling the JavaScript JIT will mean that Google Chrome may render web
// content more slowly, and may also disable parts of JavaScript including
// WebAssembly. Disabling the JavaScript JIT may allow Google Chrome to render
// web content in a more secure configuration.
//
// This policy can be overridden for specific URL patterns using the
// JavaScriptJitAllowedForSites and JavaScriptJitBlockedForSites policies.
//
// If this policy is left not set, JavaScript JIT is enabled.
//
// Valid values:
//   1: Allow any site to run JavaScript JIT
//   2: Do not allow any site to run JavaScript JIT
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message DefaultJavaScriptJitSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultJavaScriptJitSetting = 2;
}

// Allow JavaScript to use JIT on these sites
//
// Allows you to set a list of site url patterns that specify sites which are
// allowed to run JavaScript with JIT (Just In Time) compiler enabled.
//
// For detailed information on valid site url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// JavaScript JIT policy exceptions will only be enforced at a site granularity
// (eTLD+1). A policy set for only subdomain.site.com will not correctly apply
// to site.com or subdomain.site.com since they both resolve to the same eTLD+1
// (site.com) for which there is no policy. In this case, policy must be set on
// site.com to apply correctly for both site.com and subdomain.site.com.
//
// This policy applies on a frame-by-frame basis and not based on top level
// origin url alone, so e.g. if site-one.com is listed in the
// JavaScriptJitAllowedForSites policy but site-one.com loads a frame containing
// site-two.com then site-one.com will have JavaScript JIT enabled, but site-
// two.com will use the policy from DefaultJavaScriptJitSetting, if set, or
// default to JavaScript JIT enabled.
//
// If this policy is not set for a site then the policy from
// DefaultJavaScriptJitSetting applies to the site, if set, otherwise Javascript
// JIT is enabled for the site.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message JavaScriptJitAllowedForSitesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList JavaScriptJitAllowedForSites = 2;
}

// Block JavaScript from using JIT on these sites
//
// Allows you to set a list of site url patterns that specify sites which are
// not allowed to run JavaScript JIT (Just In Time) compiler enabled.
//
// Disabling the JavaScript JIT will mean that Google Chrome may render web
// content more slowly, and may also disable parts of JavaScript including
// WebAssembly. Disabling the JavaScript JIT may allow Google Chrome to render
// web content in a more secure configuration.
//
// For detailed information on valid url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns. * is
// not an accepted value for this policy.
//
// JavaScript JIT policy exceptions will only be enforced at a site granularity
// (eTLD+1). A policy set for only subdomain.site.com will not correctly apply
// to site.com or subdomain.site.com since they both resolve to the same eTLD+1
// (site.com) for which there is no policy. In this case, policy must be set on
// site.com to apply correctly for both site.com and subdomain.site.com.
//
// This policy applies on a frame-by-frame basis and not based on top level
// origin url alone, so e.g. if site-one.com is listed in the
// JavaScriptJitBlockedForSites policy but site-one.com loads a frame containing
// site-two.com then site-one.com will have JavaScript JIT disabled, but site-
// two.com will use the policy from DefaultJavaScriptJitSetting, if set, or
// default to JavaScript JIT enabled.
//
// If this policy is not set for a site then the policy from
// DefaultJavaScriptJitSetting applies to the site, if set, otherwise JavaScript
// JIT is enabled for the site.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message JavaScriptJitBlockedForSitesProto {
  optional PolicyOptions policy_options = 1;
  optional StringList JavaScriptJitBlockedForSites = 2;
}

// Allow HTTPS-Only Mode to be enabled
//
// This policy controls whether users can enable HTTPS-Only Mode in Settings.
// HTTPS-Only Mode upgrades all navigations to HTTPS.
// If this setting is not set or set to allowed, users will be allowed to enable
// HTTPS-Only Mode.
// If this setting is set to disallowed, users will not be allowed to enable
// HTTPS-Only Mode.
// Force enabling HTTPS-Only Mode is not currently supported.
//
// Valid values:
//   allowed: Allow users to enable HTTPS-Only Mode
//   disallowed: Do not allow users to enable HTTPS-Only Mode
//   force_enabled: Force enable HTTPS-Only Mode (not supported yet)
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message HttpsOnlyModeProto {
  optional PolicyOptions policy_options = 1;
  optional string HttpsOnlyMode = 2;
}

// Enable desktop sharing in the omnibox and 3-dot menu
//
// Setting the policy to True or leaving it unset lets users share or save the
// current webpage using actions provided by the desktop sharing hub. The
// sharing hub is accessed through either an omnibox icon or the 3-dot menu.
//
// Setting the policy to False removes the sharing icon from the omnibox and the
// entry from the 3-dot menu.
//
// Valid values:
//   True: Enable desktop sharing hub
//   False: Disable desktop sharing hub
//
// Supported on: fuchsia, linux, mac, win
message DesktopSharingHubEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DesktopSharingHubEnabled = 2;
}

// Configure the list of extension IDs exempt from the restricted managed guest
// session clean-up procedure
//
// The policy only applies to managed guest sessions.
// Setting the policy specifies a list of extension IDs that are exempt from the
// restricted managed guest session clean-up procedure (see
// DeviceRestrictedManagedGuestSessionEnabled).
// Leaving the policy unset means no extensions are exempt from the reset
// procedure.
//
// Supported on: chrome_os
message RestrictedManagedGuestSessionExtensionCleanupExemptListProto {
  optional PolicyOptions policy_options = 1;
  optional StringList RestrictedManagedGuestSessionExtensionCleanupExemptList = 2;
}

// Enable sharing from Android apps to Web apps
//
// Setting the policy to True enables sharing text/files from Android apps to
// supported Web Apps, using the built-in Android sharing system.
// When enabled, this will send metadata for installed Web Apps to Google to
// generate and install a shim Android app.
// Setting the policy to False disables this functionality.
//
// Valid values:
//   True: Enable Android to Web App sharing.
//   False: Disable Android to Web App sharing.
//
// Supported on: chrome_os
message ArcAppToWebAppSharingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ArcAppToWebAppSharingEnabled = 2;
}

// Allow the enhanced network text-to-speech voices in Select-to-speak
//
// Allow the enhanced network text-to-speech voices in Select-to-speak
// accessibility feature. These voices send text to Google's servers to
// synthesize natural-sounding speech.
//
// If this policy is set to false, the enhanced network text-to-speech voices
// feature in Select-to-speak will always be disabled.
//
// If this policy is set to true or unset, the enhanced network text-to-speech
// voices feature in Select-to-speak can be enabled or disabled by the user.
//
// Valid values:
//   True: Allow enhanced network text-to-speech voices when using Select-to-
// Speak
//   False: Disallow enhanced network text-to-speech voices when using Select-
// to-Speak
//
// Supported on: chrome_os
message EnhancedNetworkVoicesInSelectToSpeakAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnhancedNetworkVoicesInSelectToSpeakAllowed = 2;
}

// Extend support for Chrome Apps on Microsoft® Windows®, macOS, and Linux.
//
// Chrome Apps are deprecated on Microsoft® Windows®, macOS, and Linux.
// If this policy is enabled, Google Chrome will continue to allow Chrome Apps
// to be run on these platforms until the final date when Chrome Apps support is
// removed on all platforms, June 2022.
// If this policy is disabled or unset, Chrome Apps may not be allowed to run,
// depending on the status of the deprecation rollout.
// In either case, Chrome Apps that are force installed by policy will continue
// to be allowed.
//
// Valid values:
//   True: Chrome Apps will be allowed to run on these platforms.
//   False: Chrome Apps may not be allowed to run, depending on the status of
// the deprecation rollout.
//
// Supported on: fuchsia, linux, mac, win
message ChromeAppsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ChromeAppsEnabled = 2;
}

// Enable the full restore feature
//
// Setting the policy to enable the full restore feature.
// If this policy is true, apps and app windows will be restored or not restored
// after a crash or reboot based on the restore app setting.
// If this policy is false, only browser windows are automatcially launched.
//
// Valid values:
//   True: Enable the full restore feature.
//   False: Disable the full restore feature.
//
// Supported on: chrome_os
message FullRestoreEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool FullRestoreEnabled = 2;
}

// Enable the ghost window feature
//
// Setting the policy to enable the ghost window feature.
// If this policy is true, ARC ghost windows will be created before ARC boots
// after a crash or reboot based on the restore app setting.
// If this policy is false, there is no ghost window created before ARC boots.
// Arc apps are restored after ARC boots
//
// Valid values:
//   True: Enable the ghost window feature.
//   False: Disable the ghost window feature.
//
// Supported on: chrome_os
message GhostWindowEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool GhostWindowEnabled = 2;
}

// Force WebSQL in third-party contexts to be re-enabled.
//
// WebSQL in third-party contexts (e.g., cross-site iframes) is off by default
// as of M97 and will be fully removed in M101.
// If this policy is set to false or unset, WebSQL in third party contexts will
// remain off.
// If this policy is set to true, WebSQL in third-party contexts will be re-
// enabled.
//
// Valid values:
//   True: Force WebSQL in third-party contexts to be re-enabled.
//   False: Allow WebSQL in third-party contexts to be disabled by default.
//
// Supported on:
message WebSQLInThirdPartyContextEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebSQLInThirdPartyContextEnabled = 2;
}

// Prompt when multiple certificates match
//
// This policy controls whether the user is prompted to select a client
// certificate when more than one certificate matches
// AutoSelectCertificateForUrls.
// If this policy is set to Enabled, the user is prompted to select a client
// certificate whenever the auto-selection policy matches multiple certificates.
// If this policy is set to Disabled or not set, the user may only be prompted
// when no certificate matches the auto-selection.
//
// Valid values:
//   True: Prompt the user to select the client certificate whenever the auto-
// selection policy matches multiple certificates.
//   False: Only prompt the user when no certificate matches the auto-selection.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message PromptOnMultipleMatchingCertificatesProto {
  optional PolicyOptions policy_options = 1;
  optional bool PromptOnMultipleMatchingCertificates = 2;
}

// Allow users to select cast devices with an access code or QR code from within
// the Google Cast menu.
//
// This policy controls whether a user will be presented with an option, within
// the Google Cast menu which allows them to cast to cast devices that do not
// appear in the Google Cast menu, using either the access code or QR code
// displayed on the cast devices's screen.
// By default, a user must reenter the access code or rescan the QR code in
// order to initiate a subsequent casting session, but if the
// AccessCodeCastDeviceDuration policy has been set to a non-zero value (the
// default is zero), then the cast device will remain in the list of available
// cast devices until the specified period of time has expired.
// When this policy is set to Enabled, users will be presented with the option
// to select cast devices by using an access code or by scanning a QR code.
// When this policy is set to Disabled or not set, users will not be given the
// option to select cast devices by using an access code or by scanning a QR
// code.
//
// Valid values:
//   True: User will be given the option in the Google Cast menu to select cast
// devices by using an access code or by scanning a QR code.
//   False: User will not be given the option in the Google Cast menu to select
// cast devices by using an access code or by scanning a QR code.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AccessCodeCastEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool AccessCodeCastEnabled = 2;
}

// Specifies how long (in seconds) a cast device selected with an access code or
// QR code stays in the Google Cast menu's list of cast devices.
//
// This policy specifies how long (in seconds) a cast device that was previously
// selected via an access code or QR code can be seen within the Google Cast
// menu of cast devices.
// The lifetime of an entry starts at the time the access code was first entered
// or the QR code was first scanned.
// During this period the cast device will appear in the Google Cast menu's list
// of cast devices.
// After this period, in order to use the cast device again the access code must
// be reentered or the QR code must be rescanned.
// By default, the period is zero seconds, so cast devices will not stay in the
// Google Cast menu, and so the access code must be reentered, or the QR code
// rescanned, in order to initiate a new casting session.
// Note that this policy only affects how long a cast devices appears in the
// Google Cast menu, and has no effect on any ongoing cast session which will
// continue even if the period expires.
// This policy has no effect unless the AccessCodeCastEnabled policy is Enabled.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message AccessCodeCastDeviceDurationProto {
  optional PolicyOptions policy_options = 1;
  optional int64 AccessCodeCastDeviceDuration = 2;
}

// Enable the network service sandbox
//
// This policy controls whether or not the network service process runs
// sandboxed.
// If this policy is enabled, the network service process will run sandboxed.
// If this policy is disabled, the network service process will run unsandboxed.
// This leaves users open to additional security risks related to running the
// network service unsandboxed.
// If this policy is not set, the default configuration for the network sandbox
// will be used. This may vary depending on Google Chrome release, currently
// running field trials, and platform.
// This policy is intended to give enterprises flexibility to disable the
// network sandbox if they use third party software that interferes with the
// network service sandbox.
//
// Valid values:
//   True: Enable the network service sandbox
//   False: Disable the network service sandbox
//
// Supported on: win
message NetworkServiceSandboxEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool NetworkServiceSandboxEnabled = 2;
}

// Allow users to select a desk template layout to load
//
// Setting the policy to Enabled allows users to use desktop layout templates.
// Setting the policy to Disabled or unset means these templates will be
// unavailable.
//
// Valid values:
//   True: Allow users to use desk templates
//   False: Do not allow users to use desk templates
//
// Supported on: chrome_os
message DeskTemplatesEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DeskTemplatesEnabled = 2;
}

// Allow users to select a preconfigured desktop layout to load
//
// If set, this policy contains information to download a desk template file.
// The file contains a desk template to be provisioned for the current user.
// If not set, no preconfigured desk template will be included in the list of
// desk templates.  If the DeskTemplatesEnabled
// policy is not set to true, this policy has no effect.
//
// Supported on: chrome_os
message PreconfiguredDeskTemplatesProto {
  optional PolicyOptions policy_options = 1;
  optional string PreconfiguredDeskTemplates = 2;
}

// Enable Fast Pair (fast Bluetooth pairing)
//
// Setting this policy will force Fast Pair to be enabled or disabled.
// Fast Pair is a new Bluetooth pairing flow that links paired peripherals with
// a GAIA account.
// This allows other ChromeOS (and Android) devices signed in with the same GAIA
// account to pair automatically.
// If unset, the default value is disabled for enterprise users and enabled for
// non
// managed accounts.
//
// Valid values:
//   True: Force Fast Pair (fast Bluetooth pairing) to be enabled.
//   False: Force Fast Pair (fast Bluetooth pairing) to be disabled.
//
// Supported on: chrome_os
message FastPairEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool FastPairEnabled = 2;
}

// CORS non-wildcard request headers support
//
// Configures support of CORS non-wildcard request headers.
//
// Google Chrome version 97 introduces support for CORS non-wildcard request
// headers. When scripts make a cross-origin network request via fetch() and
// XMLHttpRequest with a script-added Authorization header, the header must be
// explicitly allowed by the Access-Control-Allow-Headers header in the CORS
// preflight response. "Explicitly" here means that the wild card symbol "*"
// doesn't cover the Authorization header. See
// https://chromestatus.com/feature/5742041264816128 for more detail.
//
// If this policy is not set, or set to True, Google Chrome will support the
// CORS non-wildcard request headers and behave as described above.
//
// When this policy is set to False, chrome will allow the wildcard symbol ("*")
// in the Access-Control-Allow-Headers header in the CORS preflight response to
// cover the Authorization header.
//
// This Enterprise policy is temporary; it's intended to be removed in the
// future.
//
// Valid values:
//   True: Support CORS non-wildcard request headers.
//   False: Do not support CORS non-wildcard request headers.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message CORSNonWildcardRequestHeadersSupportProto {
  optional PolicyOptions policy_options = 1;
  optional bool CORSNonWildcardRequestHeadersSupport = 2;
}

// Allows blocking copying to the clipboard on specified URLs
//
// This policy blocks copying data to the clipboard on specific URLs.
//
// The enable and disable URL lists control which sites are allowed to write to
// the clipboard. A clipboard write is blocked if the URL matches a pattern in
// 'enable' and doesn't match a pattern in 'disable'. A copy is not blocked if
// the URL does not match any pattern.
//
// The origin matching patterns use a similar format to those for the
// 'URLBlocklist' policy, which are documented at
// http://www.chromium.org/administrators/url-blocklist-filter-format.
//
// The minimum_data_size indicates the minimum amount of data in bytes that
// triggers the pattern check. This means that a clipboard write from a blocked
// URL would be allowed if the size of the copied data is smaller than the value
// specified in this field. The default value is 100 bytes if the field is
// unset.
//
// Value schema:
// {
//     "properties": {
//         "disable": {
//             "items": {
//                 "type": "string"
//             },
//             "type": "array"
//         },
//         "enable": {
//             "items": {
//                 "type": "string"
//             },
//             "type": "array"
//         },
//         "minimum_data_size": {
//             "minimum": 0,
//             "type": "integer"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message CopyPreventionSettingsProto {
  optional PolicyOptions policy_options = 1;
  optional string CopyPreventionSettings = 2;
}

// Enable or disable the User-Agent Reduction.
//
// The User-Agent HTTP request header is scheduled to be reduced. In order to
// facilitate testing and compatibility, this policy can enable the reduction
// feature for all websites, or disable the ability for origin trials or field
// trials to enable the feature.
//
// To learn more about the User-Agent Reduction and its timeline, read here:
//
// https://blog.chromium.org/2021/09/user-agent-reduction-origin-trial-and-
// dates.html
//
// Valid values:
//   0: User Agent reduction will be controllable via Field-Trials and Origin-
// Trials.
//   1: User Agent reduction disabled, and not enabled by Field-Trials or
// Origin-Trials.
//   2: User Agent reduction will be enabled for all origins.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message UserAgentReductionProto {
  optional PolicyOptions policy_options = 1;
  optional int64 UserAgentReduction = 2;
}

// Freeze User-Agent string major version at 99
//
// This policy controls whether the User-Agent string major
// version should be frozen at 99.
//
// The User-Agent request header lets websites identify the application,
// operating system, vendor, and/or version of the requesting user agent.
// Some websites make assumptions about how this header is formatted and may
// encounter issues with version strings that include three digits in the
// major position (e.g. 100.0.0.0).
//
// Setting the policy to 'Default' or leaving it unset will default to
// browser settings for the User-Agent string major version.
// If set to 'ForceDisabled', the User-Agent string will not freeze the
// major version.
// If set to 'ForceEnabled', the User-Agent string will always report the
// major version as 99 and include the browser's major version in the minor
// position. For example, browser version 101.0.0.0 would send a User-Agent
// request header that reports version 99.101.0.0.
//
// This policy is temporary and will be deprecated in the future. Note that
// if this policy and
// User-Agent Reduction are
// both enabled, the User-Agent version string will always be 99.0.0.0.
//
// Valid values:
//   0: Default to browser settings for User-Agent string version.
//   1: The User-Agent string will not freeze the major version.
//   2: The User-Agent string will freeze the major version as 99 and include
// the browser's major version in the minor position.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message ForceMajorVersionToMinorPositionInUserAgentProto {
  optional PolicyOptions policy_options = 1;
  optional int64 ForceMajorVersionToMinorPositionInUserAgent = 2;
}

// Allows origin-keyed agent clustering by default.
//
// This policy allows origin-keyed agent clustering by default.
//
// The Origin-Agent-Cluster: HTTP header controls whether a document is
// isolated in an origin-keyed agent cluster, or in a site-keyed agent
// cluster. This has security implications since an origin-keyed agent
// cluster allows isolating documents by origin. The developer-visible
// consequence of this is that the document.domain accessor can no longer
// be set.
//
// The default behaviour - when no Origin-Agent-Cluster: header has been set
// - changes in M106 from site-keyed to origin-keyed. If this policy
// is enabled or not set, the browser will follow this new default from that
// version on. If this policy is disabled this change is reversed and
// documents without Origin-Agent-Cluster: headers will be assigned to
// site-keyed agent clusters. As a consequence, the document.domain accessor
// remains settable by default. This matches the legacy behaviour.
//
// See https://developer.chrome.com/blog/immutable-document-domain/
// for additional details.
//
// Valid values:
//   True: By default, documents may be put in origin-keyed agent clusters.
// document.domain is not settable for such documents.
//   False: By default, documents are put in site-keyed agent clusters.
// document.domain remains settable.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message OriginAgentClusterDefaultEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool OriginAgentClusterDefaultEnabled = 2;
}

// Enable Screencast
//
// This policy gives Screencast permission to create and transcribe screen
// recording and upload to Drive for enterprise users.
// This policy does not affect Family Link users.
// This policy does not affect ProjectorDogfoodForFamilyLinkEnabled policy for
// Family Link users.
//
// If the policy is unset or enabled, Screencast will be enabled.
// If the policy is disabled, Screencast will be disabled.
//
// Valid values:
//   True: Enable Screencast
//   False: Disable Screencast
//
// Supported on: chrome_os
message ProjectorEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ProjectorEnabled = 2;
}

// Default Window Placement permission setting
//
// Setting the policy to BlockWindowPlacement (value 2) automatically denies the
// window placement permission to sites by default. This will limit the ability
// of sites to see information about the device's screens and use that
// information to open and place windows or request fullscreen on specific
// screens.
//
// Setting the policy to AskWindowPlacement (value 3) will prompt the user when
// the window placement permission is requested by default. If users allow the
// permission, it will extend the ability of sites to see information about the
// device's screens and use that information to open and place windows or
// request fullscreen on specific screens.
//
// Leaving the policy unset means the AskWindowPlacement policy applies, but
// users can change this setting.
//
// Valid values:
//   2: Denies the Window Placement permission on all sites by default
//   3: Ask every time a site wants obtain the Window Placement permission
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultWindowPlacementSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultWindowPlacementSetting = 2;
}

// Allow Window Placement permission on these sites
//
// Allows you to set a list of site url patterns that specify sites which will
// automatically grant the window placement permission. This will extend the
// ability of sites to see information about the device's screens and use that
// information to open and place windows or request fullscreen on specific
// screens.
//
// For detailed information on valid site url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// Wildcards, *, are allowed. This policy only matches based on origin, so any
// path in the URL pattern is ignored.
//
// If this policy is not set for a site then the policy from
// DefaultWindowPlacementSetting applies to the site, if set, otherwise the
// permission will follow the browser's defaults and allow users to choose this
// permission per site.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WindowPlacementAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WindowPlacementAllowedForUrls = 2;
}

// Block Window Placement permission on these sites
//
// Allows you to set a list of site url patterns that specify sites which will
// automatically deny the window placement permission. This will limit the
// ability of sites to see information about the device's screens and use that
// information to open and place windows or request fullscreen on specific
// screens.
//
// For detailed information on valid site url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// Wildcards, *, are allowed. This policy only matches based on origin, so any
// path in the URL pattern is ignored.
//
// If this policy is not set for a site then the policy from
// DefaultWindowPlacementSetting applies to the site, if set, otherwise the
// permission will follow the browser's defaults and allow users to choose this
// permission per site.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message WindowPlacementBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList WindowPlacementBlockedForUrls = 2;
}

// Default Local Fonts permission setting
//
// Setting the policy to BlockLocalFonts (value 2) automatically denies the
// local fonts permission to sites by default. This will limit the ability of
// sites to see information about local fonts.
//
// Setting the policy to AskLocalFonts (value 3) will prompt the user when the
// local fonts permission is requested by default. If users allow the
// permission, it will extend the ability of sites to see information about
// local fonts.
//
// Leaving the policy unset means the default behavior applies which is to
// prompt the user, but users can change this setting
//
// Valid values:
//   2: Denies the Local Fonts permission on all sites by default
//   3: Ask every time a site wants obtain the Local Fonts permission
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message DefaultLocalFontsSettingProto {
  optional PolicyOptions policy_options = 1;
  optional int64 DefaultLocalFontsSetting = 2;
}

// Allow Local Fonts permission on these sites
//
// Sets a list of site url patterns that specify sites which will automatically
// grant the local fonts permission. This will extend the ability of sites to
// see information about local fonts.
//
// For detailed information on valid site url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// Wildcards, *, are allowed. This policy only matches based on origin, so any
// path in the URL pattern is ignored.
//
// If this policy is not set for a site then the policy from
// DefaultLocalFontsSetting applies to the site, if set, otherwise the
// permission will follow the browser's defaults and allow users to choose this
// permission per site.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message LocalFontsAllowedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList LocalFontsAllowedForUrls = 2;
}

// Block Local Fonts permission on these sites
//
// Sets a list of site url patterns that specify sites which will automatically
// deny the local fonts permission. This will limit the ability of sites to see
// information about local fonts.
//
// For detailed information on valid site url patterns, please see
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// Wildcards, *, are allowed. This policy only matches based on origin, so any
// path in the URL pattern is ignored.
//
// If this policy is not set for a site then the policy from
// DefaultLocalFontsSetting applies to the site, if set, otherwise the
// permission will follow the browser's defaults and allow users to choose this
// permission per site.
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message LocalFontsBlockedForUrlsProto {
  optional PolicyOptions policy_options = 1;
  optional StringList LocalFontsBlockedForUrls = 2;
}

// Disable download file type extension-based warnings for specified file types
// on domains
//
// You can enable this policy to create a dictionary of file type extensions
// with a corresponding list of domains that will be exempted from file type
// extension-based download warnings. This lets enterprise administrators block
// file type extension-based download warnings for files that are associated
// with a listed domain. For example, if  the "jnlp" extension is associated
// with "website1.com", users would not see a warning when downloading "jnlp"
// files from "website1.com", but see a download warning when downloading "jnlp"
// files from "website2.com".
//
// Files with file type extensions specified for domains identified by this
// policy will still be subject to non-file type extension-based security
// warnings such as mixed-content download warnings and Safe Browsing warnings.
//
// If you disable this policy or don't configure it, file types that trigger
// extension-based download warnings will show warnings to the user.
//
// If you enable this policy:
//
// * The URL pattern should be formatted according to
// https://cloud.google.com/docs/chrome-enterprise/policies/url-patterns.
// * The file type extension entered must be in lower-cased ASCII. The leading
// separator should not be included when listing the file type extension, so
// list "jnlp" should be used instead of ".jnlp".
//
// Example:
//
// The following example value would prevent file type extension-based download
// warnings on swf, exe, and jnlp extensions for *.example.com domains. It will
// show the user a file type extension-based download warning on any other
// domain for exe and jnlp files, but not for swf files.
//
// [
// { "file_extension": "jnlp", "domains": ["example.com"] },
// { "file_extension": "exe", "domains": ["example.com"] },
// { "file_extension": "swf", "domains": ["*"] }
// ]
//
// Note that while the preceding example shows the suppression of file type
// extension-based download warnings for "swf" files for all domains, applying
// suppression of such warnings for all domains for any dangerous file type
// extension is not recommended due to security concerns. It is shown in the
// example merely to demonstrate the ability to do so.
//
// If this policy is enabled alongside DownloadRestrictions and
// DownloadRestrictions is set to block dangerous file types, download blocks
// determined by DownloadRestrictions take precedence. For example, if this
// policy is set to enable "exe" extension downloads from "website1.com", and
// DownloadRestrictions is set to block malicious downloads and dangerous file
// types, then "exe" extension downloads will still be blocked in all domains.
// If DownloadRestrictions is not set to block dangerous file types, then file
// types specified in this policy will be exempted from file-type extension-
// based download warnings in the specified domains. Read more about
// DownloadRestrictions
// (https://chromeenterprise.google/policies/?policy=DownloadRestrictions).
//
// Value schema:
// {
//     "items": {
//         "id": "DomainFiletypePair",
//         "properties": {
//             "domains": {
//                 "items": {
//                     "type": "string"
//                 },
//                 "type": "array"
//             },
//             "file_extension": {
//                 "type": "string"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message ExemptDomainFileTypePairsFromFileTypeDownloadWarningsProto {
  optional PolicyOptions policy_options = 1;
  optional string ExemptDomainFileTypePairsFromFileTypeDownloadWarnings = 2;
}

// Enable First-Party Sets.
//
// This policy is provided as a way to opt-out of the First-Party Sets feature.
//
// When this policy is unset or set to Enabled, the First-Party Sets feature is
// enabled.
//
// When this policy is set to Disabled, the First-Party Sets feature is
// disabled.
//
// It controls whether Chrome supports First-Party Sets related features (e.g.
// the SameParty cookie attribute).
//
// Valid values:
//   True: Enable First-Party Sets for all affected users
//   False: Disable First-Party Sets for all affected users
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message FirstPartySetsEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool FirstPartySetsEnabled = 2;
}

// Override First-Party Sets.
//
// This policy provides a way to override the list of sets the browser uses for
// First-Party Sets features.
//
// Each set in the browser's list of First-Party Sets must meet the requirements
// of a First-Party Set.
// A First-Party Set consists of an owner and one or more member sites. All
// sites in a First-Party Set must
// be a registrable domain served over HTTPS, regardless of whether it is an
// owner or member site.
// Each site in a First-Party Set must also be unique, meaning a site cannot be
// both owner and member, nor
// listed more than once as a member of a First-Party Set.
// See https://github.com/privacycg/first-party-sets for more information on
// First-Party Sets.
//
// When this policy is given an empty dictionary, the browser uses the public
// list of First-Party Sets.
//
// For all sites in a First-Party Set from the replacements list, if a site is
// also present
// on a First-Party Set in the browser's list, then that site will be removed
// from the browser's First-Party Set.
// After this, the policy's First-Party Set will be added to the browser's list
// of First-Party Sets.
//
// For all sites in a First-Party Set from the additions list, if a site is also
// present
// on a First-Party Set in the browser's list, then the browser's First-Party
// Set will be updated so that the
// new First-Party Set can be added to the browser's list. After the browser's
// list has been updated,
// the policy's First-Party Set will be added to the browser's list of First-
// Party Sets.
//
// The browser's list of First-Party Sets requires that for all sites in its
// list, no site is in
// more than one set. This is also required for both the replacements list
// and the additions list. Similarly, a site cannot be in both the
// replacements list and the additions list.
//
// Wildcards (*) are not supported as a policy value, nor within any First-Party
// Set in these lists.
//
// All sets provided by to policy must be valid First-Party Sets, if they aren't
// then an
// appropriate error will be outputted.
//
// This policy is available only on Windows instances that are joined to a
// Microsoft® Active Directory® domain or Windows 10 Pro or Enterprise instances
// that are enrolled for device management, and macOS instances that are managed
// via MDM or joined to a domain via MCX.
//
// Value schema:
// {
//     "properties": {
//         "additions": {
//             "items": {
//                 "properties": {
//                     "members": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "owner": {
//                         "type": "string"
//                     }
//                 },
//                 "required": [
//                     "owner",
//                     "members"
//                 ],
//                 "type": "object"
//             },
//             "type": "array"
//         },
//         "replacements": {
//             "items": {
//                 "properties": {
//                     "members": {
//                         "items": {
//                             "type": "string"
//                         },
//                         "type": "array"
//                     },
//                     "owner": {
//                         "type": "string"
//                     }
//                 },
//                 "required": [
//                     "owner",
//                     "members"
//                 ],
//                 "type": "object"
//             },
//             "type": "array"
//         }
//     },
//     "type": "object"
// }
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message FirstPartySetsOverridesProto {
  optional PolicyOptions policy_options = 1;
  optional string FirstPartySetsOverrides = 2;
}

// Allow Developer Mode for Isolated Apps.
//
// Setting the policy to Enabled lets users access Developer Mode for Isolated
// Apps.
// Setting the policy to Disabled means users will not be able to access these
// capabilities.
// If this policy is left not set, the default is not allowed for enterprise-
// managed users on ChromeOS and allowed for all other users and OSes.
//
// Valid values:
//   True: Enable Isolated Apps Developer Mode
//   False: Disable Isolated Apps Developer Mode
//
// Supported on: chrome_os, fuchsia, linux, mac, win
message IsolatedAppsDeveloperModeAllowedProto {
  optional PolicyOptions policy_options = 1;
  optional bool IsolatedAppsDeveloperModeAllowed = 2;
}

// Enable Floating Workspace Service
//
// Setting the policy to Enabled will launch browser windows from current user's
// last used device automatically upon login.
// Setting the policy to Disabled or leaving it unset will let full restore
// settings determine what to be launched upon login.
//
// Valid values:
//   True: Enable floating workspace and launch remote browser windows upon
// login
//   False: Disable floating workspace and do not launch remote browser windows
// upon login
//
// Supported on: chrome_os
message FloatingWorkspaceEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool FloatingWorkspaceEnabled = 2;
}

// Enable Optimization Guide Fetching
//
// Setting the policy to Enabled or leaving it unset will enable the fetching of
// page load metadata and machine learning models that enhance the browsing
// experience.
// Setting the policy to Disabled may cause some features to not work
// appropriately.
//
// Valid values:
//   True: Enable fetching of page load metadata and machine learning models to
// enhance the browsing experience
//   False: Disable fetching of page load metadata and machine learning models
// that enhance the browsing experience
//
// Supported on:
message OptimizationGuideFetchingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool OptimizationGuideFetchingEnabled = 2;
}

// Force WebSQL to be enabled.
//
// WebSQL is on by default as of M101, but can be disabled via Chrome flag.
// If this policy is set to false or unset, WebSQL can be disabled.
// If this policy is set to true, WebSQL cannot be disabled.
//
// Valid values:
//   True: Force WebSQL to be enabled.
//   False: Allow WebSQL to be disabled by Chrome flag.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message WebSQLAccessProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebSQLAccess = 2;
}

// Force WebSQL in non-secure contexts to be enabled.
//
// WebSQL in non-secure contexts is off by default as of M107 and will be fully
// removed in M110.
// If this policy is set to false or unset, WebSQL in non-secure contexts will
// remain on until the end of M106, then off from M107.
// If this policy is set to true, WebSQL in non-secure contexts will be enabled.
//
// Valid values:
//   True: Force WebSQL in non-secure contexts to be enabled.
//   False: Disable WebSQL in non-secure contexts unless enabled by Chrome flag.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message WebSQLNonSecureContextEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WebSQLNonSecureContextEnabled = 2;
}

// Control Javascript setTimeout() function minimum timeout.
//
// When the policy is set to Enabled, the Javascript setTimeout() with a timeout
// of 0ms will not clamp to 1ms.
// When the policy is set to Disabled,  the Javascript setTimeout() with a
// timeout of 0ms will clamp to 1ms.
// When the policy is unset, use the browser's default behavior for setTimeout()
// function clamp.
//
// This is a web standards compliant feature, but it may change task ordering
// on a web page, leading to unexpected behavior on sites that are dependent on
// a certain ordering in some way. It also may affect sites with a lot of
// setTimeout()
// with a timeout of 0ms usage, e.g. increasing CPU load.
//
// For users where this policy is unset, Chrome will roll out the change
// gradually on the stable channel.
//
// This is a temporary policy that is planned be removed in Chrome 105. This
// deadline may be extended if there is a need for it among enterprises.
//
// Valid values:
//   True: Javascript setTimeout() with a timeout of 0ms will not clamp to 1ms.
//   False: Javascript setTimeout() with a timeout of 0ms will clamp to 1ms.
//   None: 'Default behavior for setTimeout() function clamp.
//
// Supported on: android, chrome_os, linux, mac, win
message SetTimeoutWithout1MsClampEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool SetTimeoutWithout1MsClampEnabled = 2;
}

// Allow backup of Google Chrome data
//
// If this policy is set to False, Google Chrome data, including cookies and
// website local storage, will be excluded from iCloud and local backups on iOS.
// If this policy is set to True or unset, Google Chrome may be included in
// backups.
//
// Valid values:
//   True: Allow Google Chrome data to be included in backups
//   False: Prevent Google Chrome data from being included in backups
//
// Supported on: ios
message AllowChromeDataInBackupsProto {
  optional PolicyOptions policy_options = 1;
  optional bool AllowChromeDataInBackups = 2;
}

// Enable adaptive charging model to hold charging process to extend battery
// life
//
// Specifies whether an adaptive charging model is allowed to hold charging
// process to extend battery life.
//
// When the device is on AC, the adaptive charging model evaluates if charging
// process should be hold to extend battery life. If the adaptive charging model
// holds the charging process, it'll keep the battery at a certain level (i.e.
// 80%) and then charge the device to 100% when the user needs it.
// If this policy is set to True, the adaptive charging model will be enabled
// and allowed to hold the charging process to extend battery life. If this
// policy is set to False or unset, the adaptive charging model will not
// influence the charging process.
//
// Valid values:
//   True: Enable adaptive charging model on Google ChromeOS
//   False: Disable adaptive charging model on Google ChromeOS
//
// Supported on: chrome_os
message DevicePowerAdaptiveChargingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool DevicePowerAdaptiveChargingEnabled = 2;
}

// Show a warning dialog when the user is attempting to quit
//
// Controls "Warn Before Quitting (⌘Q)" dialog when the user is attempting to
// quit browser.
//
// If this policy is set to Enabled or not set, a warning dialog is shown when
// the user is attempting to quit.
//
// If this policy is set to Disabled, a warning dialog is not shown when the
// user is attempting to quit.
//
// Valid values:
//   True: Show a warning dialog when the user is attempting to quit
//   False: Do not show a warning dialog when the user is attempting to quit
//
// Supported on: mac
message WarnBeforeQuittingEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool WarnBeforeQuittingEnabled = 2;
}

// ChromeOS color mode
//
// Controls the theme used to render UI during OOBE and in session
// (dark/light/auto).
// The auto mode automatically switches between dark and light themes on sunrise
// and sunset.
// This policy should be recommended, giving users the possibility to change the
// theme in system settings.
//
// Valid values:
//   light: Use the Light theme
//   dark: Use the Dark theme
//   auto: Use the Auto mode
//
// Supported on: chrome_os
message OsColorModeProto {
  optional PolicyOptions policy_options = 1;
  optional string OsColorMode = 2;
}

// Enable insights extension for reporting usage metrics
//
// The insights extension reports user internet download and upload speed, user
// idle time, and application insights.
//
// If the policy is set to enabled, the insights extension will be installed and
// report metrics.
//
// If the policy is not set or set to disabled, then the insights extension will
// not be installed and will not report metrics.
//
// Valid values:
//   True: Enable insights extension
//   False: Disable insights extension
//
// Supported on: chrome_os
message InsightsExtensionEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool InsightsExtensionEnabled = 2;
}

// External authentication app launch URLs
//
// Allows you to specify configs for authentication urls in Android WebView.
//
// These Authentication urls would be treated special by Android WebView, such
// that during authentication when webpage in Android WebView
// is navigated to authentication urls, corresponding Identity providers
// authenticator app that can handle this authentication URL would be launched.
//
// This flow of launching the Idenity providers authenticator app would be used
// by the Identity providers to enable
// use cases like providing SSO across apps or provide better security by
// collecting zero trust device signals to understand device posture during
// authentication.
//
// If there is no valid app installed to handle authentication url on the
// device, navigation will continue in Android WebView.
//
// Authentication URL pattern has to be formatted according to
// https://www.chromium.org/administrators/url-blocklist-filter-format.
//
// Value schema:
// {
//     "items": {
//         "properties": {
//             "url": {
//                 "type": "string"
//             }
//         },
//         "type": "object"
//     },
//     "type": "array"
// }
//
// Supported on: android
message EnterpriseAuthenticationAppLinkPolicyProto {
  optional PolicyOptions policy_options = 1;
  optional string EnterpriseAuthenticationAppLinkPolicy = 2;
}

// Enable Screencast dogfood for Family Link users
//
// This policy enables Screencast feature for Family Link users and gives it
// permission to create and transcribe screen recording and upload to Drive.
// This policy does not affect other types of users.
// This policy does not affect ProjectorEnabled policy for enterprise users.
//
// If the policy is enabled, Screencast dogfood will be enabled for Family Link
// users.
// If the policy is disabled, Screencast dogfood will be disabled for Family
// Link users.
// If the policy is not set, Screencast dogfood will be by default disabled for
// Family Link users.
//
// Valid values:
//   True: Enable Screencast dogfood for Family Link users
//   False: Disable Screencast dogfood for Family Link users
//
// Supported on: chrome_os
message ProjectorDogfoodForFamilyLinkEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ProjectorDogfoodForFamilyLinkEnabled = 2;
}

// Enable Screen Time for websites
//
// This policy enables Google Chrome to participate in the macOS Screen Time
// feature.
//
// If the policy is Enabled or not set, visited origins will be reported to the
// OS, and origins that have been blocked in Screen Time settings will display a
// blocking screen.
// If the policy is Disabled, visited origins will not be reported to the OS,
// and origins that have been blocked in Screen Time settings will be
// accessible.
//
// Valid values:
//   True: Enable Screen Time for websites
//   False: Disable Screen Time for websites
//
// Supported on: mac
message ScreenTimeEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool ScreenTimeEnabled = 2;
}

// Control the nesting threshold before which Javascript setTimeout() function
// start being clamped
//
// setTimeout(…, 0) is commonly used to break down long Javascript tasks.
// When the policy is set to Enabled, setTimeouts and setIntervals with an
// interval smaller than 4ms are not clamped as aggressively.
// This improves short horizon performance, but websites abusing the API will
// still eventually have their setTimeouts clamped.
//
// When the policy is set to Disabled, setTimeouts and setIntervals with an
// interval smaller than 4ms will be clamped.
//
// This may change task ordering on a web page, leading to unexpected behavior
// on sites that are dependent on a certain ordering in some way.
// It also may affect sites with a lot of setTimeout() with a timeout of 0ms
// usage, e.g. increasing CPU load.
//
// For users where this policy is unset, Google Chrome will roll out the change
// gradually on the stable channel.
//
// This is a temporary policy that is planned be removed in Google Chrome 107.
// This deadline may be extended if there is a need for it among enterprises.
//
// Valid values:
//   True: Javascript setTimeout() will not be clamped until a higher nesting
// threshold.
//   False: Javascript setTimeout() will be clamped after a normal nesting
// threshold.
//   None: Default behavior for setTimeout() function nested clamp.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message UnthrottledNestedTimeoutEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool UnthrottledNestedTimeoutEnabled = 2;
}

// Timeout until idle profile is closed
//
// Triggers an action when the computer is idle.
//
// If this policy is set to a positive number: it is a number of minutes. After
// that many minutes without user input, Google Chrome closes all browser
// windows, and shows the Profile Picker.
//
// If this policy is less than 5, or left unset: nothing happens when the
// computer is idle.
//
// "User input" is defined by Operating System APIs, and includes things like
// moving the mouse or typing on the keyboard.
//
// Supported on: fuchsia, linux, mac, win
message IdleProfileCloseTimeoutProto {
  optional PolicyOptions policy_options = 1;
  optional int64 IdleProfileCloseTimeout = 2;
}

// Enable TLS Encrypted ClientHello
//
// Encrypted ClientHello (ECH) is an extension to TLS to encrypt sensitive
// fields of the ClientHello and improve privacy.
//
// If this policy is not configured, or is set to enabled, Google Chrome will
// follow the default rollout process for ECH. If it is disabled, Google Chrome
// will not enable ECH.
//
// When the feature is enabled, Google Chrome may or may not use ECH depending
// on server support, availability of the HTTPS DNS record, or rollout status.
//
// ECH is an evolving protocol, so Google Chrome's implementation is subject to
// change. As such, this policy is a temporary measure to control the initial
// experimental implementation. It will be replaced with final controls as the
// protocol finalizes.
//
// Valid values:
//   True: Enable the TLS Encrypted ClientHello experiment
//   False: Disable the TLS Encrypted ClientHello experiment
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message EncryptedClientHelloEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool EncryptedClientHelloEnabled = 2;
}

// Keep browsing data when creating enterprise profile by default
//
// If this policy is Enabled, the option to keep any existing browsing data when
// creating an enterprise profile will be checked by default.
//
// If this policy is unset or Disabled, the option to keep any existing browsing
// data when creating an enterprise profile will not be checked by default.
//
// Regardless of the value, the user will be able to decide whether or not to
// keep any existing browsing data when creating an enterprise profile.
//
// This policy has no effect if the option to keep existing browsing data is not
// available; this happens if enterprise profile separation is strictly
// enforced, or if the data would be from an already managed profile.
//
// Valid values:
//   True: Check the option to keep existing browsing data by default
//   False: Do not check the option to keep existing browsing data by default
//
// Supported on: fuchsia, linux, mac, win
//
// Note: this policy must have a RECOMMENDED PolicyMode set in PolicyOptions.
message EnterpriseProfileCreationKeepBrowsingDataProto {
  optional PolicyOptions policy_options = 1;
  optional bool EnterpriseProfileCreationKeepBrowsingData = 2;
}

// Force persistent quota to be enabled
//
// Starting M106 persistent quota will no longer be supported. This policy will
// re-enable persistent quota functionality until M107.
// If this policy is set to enabled, webkitRequestFileSystem with persistent
// type will operate with persistent quota.
// If this policy is unset or disabled, webkitRequestFileSystem with persistent
// type will operate with temporary quota.
//
// Valid values:
//   True: Enable persistent quota.
//   False: Disable persistent quota.
//
// Supported on: android, chrome_os, fuchsia, linux, mac, win
message PersistentQuotaEnabledProto {
  optional PolicyOptions policy_options = 1;
  optional bool PersistentQuotaEnabled = 2;
}

// --------------------------------------------------
// Big wrapper PB containing the above groups.

message ChromeSettingsProto {
  optional HomepageLocationProto HomepageLocation = 3;
  optional HomepageIsNewTabPageProto HomepageIsNewTabPage = 4;
  optional NewTabPageLocationProto NewTabPageLocation = 362;
  optional DefaultBrowserSettingEnabledProto DefaultBrowserSettingEnabled = 5;
  optional ApplicationLocaleValueProto ApplicationLocaleValue = 6;
  optional AlternateErrorPagesEnabledProto AlternateErrorPagesEnabled = 7;
  optional SearchSuggestEnabledProto SearchSuggestEnabled = 8;
  optional NativeWindowOcclusionEnabledProto NativeWindowOcclusionEnabled = 677;
  optional WindowOcclusionEnabledProto WindowOcclusionEnabled = 819;
  optional DnsPrefetchingEnabledProto DnsPrefetchingEnabled = 9;
  optional NetworkPredictionOptionsProto NetworkPredictionOptions = 275;
  optional WPADQuickCheckEnabledProto WPADQuickCheckEnabled = 263;
  optional DisableSpdyProto DisableSpdy = 10;
  optional DisabledSchemesProto DisabledSchemes = 87;
  optional GetDisplayMediaSetSelectAllScreensAllowedForUrlsProto GetDisplayMediaSetSelectAllScreensAllowedForUrls = 974;
  optional GloballyScopeHTTPAuthCacheEnabledProto GloballyScopeHTTPAuthCacheEnabled = 645;
  optional DNSInterceptionChecksEnabledProto DNSInterceptionChecksEnabled = 656;
  optional IntranetRedirectBehaviorProto IntranetRedirectBehavior = 794;
  optional Http09OnNonDefaultPortsEnabledProto Http09OnNonDefaultPortsEnabled = 347;
  optional JavascriptEnabledProto JavascriptEnabled = 11;
  optional IncognitoEnabledProto IncognitoEnabled = 12;
  optional IncognitoModeAvailabilityProto IncognitoModeAvailability = 95;
  optional SavingBrowserHistoryDisabledProto SavingBrowserHistoryDisabled = 13;
  optional AllowDeletingBrowserHistoryProto AllowDeletingBrowserHistory = 189;
  optional HistoryClustersVisibleProto HistoryClustersVisible = 928;
  optional AllowDinosaurEasterEggProto AllowDinosaurEasterEgg = 311;
  optional ForceLegacyDefaultReferrerPolicyProto ForceLegacyDefaultReferrerPolicy = 650;
  optional RemoteAccessClientFirewallTraversalProto RemoteAccessClientFirewallTraversal = 96;
  optional RemoteAccessHostClientDomainProto RemoteAccessHostClientDomain = 318;
  optional RemoteAccessHostClientDomainListProto RemoteAccessHostClientDomainList = 371;
  optional RemoteAccessHostFirewallTraversalProto RemoteAccessHostFirewallTraversal = 97;
  optional RemoteAccessHostDomainProto RemoteAccessHostDomain = 156;
  optional RemoteAccessHostDomainListProto RemoteAccessHostDomainList = 370;
  optional RemoteAccessHostRequireTwoFactorProto RemoteAccessHostRequireTwoFactor = 157;
  optional RemoteAccessHostTalkGadgetPrefixProto RemoteAccessHostTalkGadgetPrefix = 158;
  optional RemoteAccessHostRequireCurtainProto RemoteAccessHostRequireCurtain = 159;
  optional RemoteAccessHostAllowClientPairingProto RemoteAccessHostAllowClientPairing = 236;
  optional RemoteAccessHostAllowGnubbyAuthProto RemoteAccessHostAllowGnubbyAuth = 259;
  optional RemoteAccessHostAllowRelayedConnectionProto RemoteAccessHostAllowRelayedConnection = 265;
  optional RemoteAccessHostUdpPortRangeProto RemoteAccessHostUdpPortRange = 266;
  optional RemoteAccessHostMatchUsernameProto RemoteAccessHostMatchUsername = 287;
  optional RemoteAccessHostTokenUrlProto RemoteAccessHostTokenUrl = 288;
  optional RemoteAccessHostTokenValidationUrlProto RemoteAccessHostTokenValidationUrl = 289;
  optional RemoteAccessHostTokenValidationCertificateIssuerProto RemoteAccessHostTokenValidationCertificateIssuer = 290;
  optional RemoteAccessHostDebugOverridePoliciesProto RemoteAccessHostDebugOverridePolicies = 291;
  optional RemoteAccessHostAllowUiAccessForRemoteAssistanceProto RemoteAccessHostAllowUiAccessForRemoteAssistance = 346;
  optional RemoteAccessHostAllowFileTransferProto RemoteAccessHostAllowFileTransfer = 536;
  optional RemoteAccessHostEnableUserInterfaceProto RemoteAccessHostEnableUserInterface = 805;
  optional RemoteAccessHostAllowRemoteAccessConnectionsProto RemoteAccessHostAllowRemoteAccessConnections = 814;
  optional RemoteAccessHostMaximumSessionDurationMinutesProto RemoteAccessHostMaximumSessionDurationMinutes = 816;
  optional RemoteAccessHostClipboardSizeBytesProto RemoteAccessHostClipboardSizeBytes = 924;
  optional RemoteAccessHostAllowRemoteSupportConnectionsProto RemoteAccessHostAllowRemoteSupportConnections = 925;
  optional PrintingEnabledProto PrintingEnabled = 14;
  optional CloudPrintProxyEnabledProto CloudPrintProxyEnabled = 15;
  optional PrintingAllowedColorModesProto PrintingAllowedColorModes = 476;
  optional PrintingAllowedDuplexModesProto PrintingAllowedDuplexModes = 477;
  optional PrintingAllowedPinModesProto PrintingAllowedPinModes = 527;
  optional PrintingAllowedBackgroundGraphicsModesProto PrintingAllowedBackgroundGraphicsModes = 623;
  optional PrintingColorDefaultProto PrintingColorDefault = 479;
  optional PrintingDuplexDefaultProto PrintingDuplexDefault = 480;
  optional PrintingPinDefaultProto PrintingPinDefault = 528;
  optional PrintingBackgroundGraphicsDefaultProto PrintingBackgroundGraphicsDefault = 624;
  optional PrintingPaperSizeDefaultProto PrintingPaperSizeDefault = 481;
  optional PrintingSendUsernameAndFilenameEnabledProto PrintingSendUsernameAndFilenameEnabled = 508;
  optional PrintingMaxSheetsAllowedProto PrintingMaxSheetsAllowed = 694;
  optional AppCacheForceEnabledProto AppCacheForceEnabled = 706;
  optional PrintJobHistoryExpirationPeriodProto PrintJobHistoryExpirationPeriod = 627;
  optional PrintingAPIExtensionsWhitelistProto PrintingAPIExtensionsWhitelist = 666;
  optional PrintingAPIExtensionsAllowlistProto PrintingAPIExtensionsAllowlist = 785;
  optional ForceSafeSearchProto ForceSafeSearch = 164;
  optional ForceGoogleSafeSearchProto ForceGoogleSafeSearch = 284;
  optional ForceYouTubeSafetyModeProto ForceYouTubeSafetyMode = 285;
  optional ForceYouTubeRestrictProto ForceYouTubeRestrict = 350;
  optional SafeBrowsingEnabledProto SafeBrowsingEnabled = 16;
  optional SafeBrowsingProtectionLevelProto SafeBrowsingProtectionLevel = 686;
  optional MetricsReportingEnabledProto MetricsReportingEnabled = 17;
  optional PasswordManagerEnabledProto PasswordManagerEnabled = 18;
  optional PasswordManagerAllowShowPasswordsProto PasswordManagerAllowShowPasswords = 19;
  optional PasswordLeakDetectionEnabledProto PasswordLeakDetectionEnabled = 582;
  optional PasswordDismissCompromisedAlertEnabledProto PasswordDismissCompromisedAlertEnabled = 948;
  optional AutoFillEnabledProto AutoFillEnabled = 20;
  optional AutofillAddressEnabledProto AutofillAddressEnabled = 461;
  optional AutofillCreditCardEnabledProto AutofillCreditCardEnabled = 394;
  optional DisabledPluginsProto DisabledPlugins = 21;
  optional EnabledPluginsProto EnabledPlugins = 80;
  optional DisabledPluginsExceptionsProto DisabledPluginsExceptions = 81;
  optional AlwaysOpenPdfExternallyProto AlwaysOpenPdfExternally = 349;
  optional DisablePluginFinderProto DisablePluginFinder = 68;
  optional SyncDisabledProto SyncDisabled = 22;
  optional SyncTypesListDisabledProto SyncTypesListDisabled = 651;
  optional RoamingProfileSupportEnabledProto RoamingProfileSupportEnabled = 360;
  optional RoamingProfileLocationProto RoamingProfileLocation = 361;
  optional SigninAllowedProto SigninAllowed = 192;
  optional EnableDeprecatedWebBasedSigninProto EnableDeprecatedWebBasedSignin = 267;
  optional UserDataDirProto UserDataDir = 65;
  optional DiskCacheDirProto DiskCacheDir = 90;
  optional DiskCacheSizeProto DiskCacheSize = 112;
  optional MediaCacheSizeProto MediaCacheSize = 113;
  optional DownloadBubbleEnabledProto DownloadBubbleEnabled = 972;
  optional DownloadRestrictionsProto DownloadRestrictions = 373;
  optional DownloadDirectoryProto DownloadDirectory = 66;
  optional AutoOpenFileTypesProto AutoOpenFileTypes = 702;
  optional AutoOpenAllowedForURLsProto AutoOpenAllowedForURLs = 709;
  optional AutoLaunchProtocolsFromOriginsProto AutoLaunchProtocolsFromOrigins = 724;
  optional SafeBrowsingForTrustedSourcesEnabledProto SafeBrowsingForTrustedSourcesEnabled = 377;
  optional ClearSiteDataOnExitProto ClearSiteDataOnExit = 67;
  optional CaptivePortalAuthenticationIgnoresProxyProto CaptivePortalAuthenticationIgnoresProxy = 297;
  optional ProxyModeProto ProxyMode = 23;
  optional ProxyServerModeProto ProxyServerMode = 24;
  optional ProxyServerProto ProxyServer = 25;
  optional ProxyPacUrlProto ProxyPacUrl = 26;
  optional ProxyBypassListProto ProxyBypassList = 27;
  optional ProxySettingsProto ProxySettings = 118;
  optional AuthSchemesProto AuthSchemes = 28;
  optional AllHttpAuthSchemesAllowedForOriginsProto AllHttpAuthSchemesAllowedForOrigins = 952;
  optional DisableAuthNegotiateCnameLookupProto DisableAuthNegotiateCnameLookup = 29;
  optional EnableAuthNegotiatePortProto EnableAuthNegotiatePort = 30;
  optional BasicAuthOverHttpEnabledProto BasicAuthOverHttpEnabled = 808;
  optional AuthServerWhitelistProto AuthServerWhitelist = 31;
  optional AuthServerAllowlistProto AuthServerAllowlist = 749;
  optional AuthNegotiateDelegateWhitelistProto AuthNegotiateDelegateWhitelist = 32;
  optional AuthNegotiateDelegateAllowlistProto AuthNegotiateDelegateAllowlist = 748;
  optional AuthNegotiateDelegateByKdcPolicyProto AuthNegotiateDelegateByKdcPolicy = 530;
  optional BrowserLabsEnabledProto BrowserLabsEnabled = 818;
  optional GSSAPILibraryNameProto GSSAPILibraryName = 33;
  optional AuthAndroidNegotiateAccountTypeProto AuthAndroidNegotiateAccountType = 307;
  optional AllowCrossOriginAuthPromptProto AllowCrossOriginAuthPrompt = 91;
  optional NtlmV2EnabledProto NtlmV2Enabled = 395;
  optional ExtensionInstallBlacklistProto ExtensionInstallBlacklist = 34;
  optional ExtensionInstallBlocklistProto ExtensionInstallBlocklist = 742;
  optional ExtensionInstallAllowlistProto ExtensionInstallAllowlist = 740;
  optional ExtensionInstallWhitelistProto ExtensionInstallWhitelist = 35;
  optional ExtensionInstallForcelistProto ExtensionInstallForcelist = 36;
  optional ExtensionInstallSourcesProto ExtensionInstallSources = 150;
  optional ExtensionAllowInsecureUpdatesProto ExtensionAllowInsecureUpdates = 518;
  optional ExtensionAllowedTypesProto ExtensionAllowedTypes = 170;
  optional ExtensionSettingsProto ExtensionSettings = 280;
  optional BlockExternalExtensionsProto BlockExternalExtensions = 639;
  optional ShowHomeButtonProto ShowHomeButton = 37;
  optional DeveloperToolsDisabledProto DeveloperToolsDisabled = 38;
  optional DeveloperToolsAvailabilityProto DeveloperToolsAvailability = 445;
  optional RemoteDebuggingAllowedProto RemoteDebuggingAllowed = 866;
  optional HeadlessModeProto HeadlessMode = 844;
  optional RestoreOnStartupProto RestoreOnStartup = 39;
  optional RestoreOnStartupURLsProto RestoreOnStartupURLs = 40;
  optional BlockThirdPartyCookiesProto BlockThirdPartyCookies = 41;
  optional DefaultSearchProviderEnabledProto DefaultSearchProviderEnabled = 42;
  optional DefaultSearchProviderContextMenuAccessAllowedProto DefaultSearchProviderContextMenuAccessAllowed = 717;
  optional DefaultSearchProviderNameProto DefaultSearchProviderName = 43;
  optional DefaultSearchProviderKeywordProto DefaultSearchProviderKeyword = 44;
  optional DefaultSearchProviderSearchURLProto DefaultSearchProviderSearchURL = 45;
  optional DefaultSearchProviderSuggestURLProto DefaultSearchProviderSuggestURL = 46;
  optional DefaultSearchProviderInstantURLProto DefaultSearchProviderInstantURL = 47;
  optional DefaultSearchProviderIconURLProto DefaultSearchProviderIconURL = 48;
  optional DefaultSearchProviderEncodingsProto DefaultSearchProviderEncodings = 49;
  optional DefaultSearchProviderAlternateURLsProto DefaultSearchProviderAlternateURLs = 163;
  optional DefaultSearchProviderSearchTermsReplacementKeyProto DefaultSearchProviderSearchTermsReplacementKey = 173;
  optional DefaultSearchProviderImageURLProto DefaultSearchProviderImageURL = 231;
  optional DefaultSearchProviderNewTabURLProto DefaultSearchProviderNewTabURL = 239;
  optional DefaultSearchProviderSearchURLPostParamsProto DefaultSearchProviderSearchURLPostParams = 232;
  optional DefaultSearchProviderSuggestURLPostParamsProto DefaultSearchProviderSuggestURLPostParams = 233;
  optional DefaultSearchProviderInstantURLPostParamsProto DefaultSearchProviderInstantURLPostParams = 234;
  optional DefaultSearchProviderImageURLPostParamsProto DefaultSearchProviderImageURLPostParams = 235;
  optional DefaultCookiesSettingProto DefaultCookiesSetting = 50;
  optional DefaultImagesSettingProto DefaultImagesSetting = 51;
  optional DefaultJavaScriptSettingProto DefaultJavaScriptSetting = 52;
  optional DefaultPluginsSettingProto DefaultPluginsSetting = 53;
  optional DefaultPopupsSettingProto DefaultPopupsSetting = 54;
  optional DefaultNotificationsSettingProto DefaultNotificationsSetting = 55;
  optional DefaultGeolocationSettingProto DefaultGeolocationSetting = 56;
  optional DefaultMediaStreamSettingProto DefaultMediaStreamSetting = 151;
  optional DefaultWebBluetoothGuardSettingProto DefaultWebBluetoothGuardSetting = 322;
  optional DefaultKeygenSettingProto DefaultKeygenSetting = 315;
  optional DefaultSensorsSettingProto DefaultSensorsSetting = 756;
  optional DefaultWebUsbGuardSettingProto DefaultWebUsbGuardSetting = 436;
  optional WebUsbAllowDevicesForUrlsProto WebUsbAllowDevicesForUrls = 488;
  optional WebUsbAskForUrlsProto WebUsbAskForUrls = 441;
  optional WebUsbBlockedForUrlsProto WebUsbBlockedForUrls = 442;
  optional DefaultSerialGuardSettingProto DefaultSerialGuardSetting = 753;
  optional SerialAskForUrlsProto SerialAskForUrls = 754;
  optional SerialBlockedForUrlsProto SerialBlockedForUrls = 755;
  optional SerialAllowAllPortsForUrlsProto SerialAllowAllPortsForUrls = 839;
  optional SerialAllowUsbDevicesForUrlsProto SerialAllowUsbDevicesForUrls = 840;
  optional DefaultWebHidGuardSettingProto DefaultWebHidGuardSetting = 945;
  optional WebHidAskForUrlsProto WebHidAskForUrls = 946;
  optional WebHidBlockedForUrlsProto WebHidBlockedForUrls = 947;
  optional WebHidAllowAllDevicesForUrlsProto WebHidAllowAllDevicesForUrls = 955;
  optional WebHidAllowDevicesForUrlsProto WebHidAllowDevicesForUrls = 956;
  optional WebHidAllowDevicesWithHidUsagesForUrlsProto WebHidAllowDevicesWithHidUsagesForUrls = 957;
  optional DefaultFileHandlingGuardSettingProto DefaultFileHandlingGuardSetting = 847;
  optional FileHandlingAllowedForUrlsProto FileHandlingAllowedForUrls = 848;
  optional FileHandlingBlockedForUrlsProto FileHandlingBlockedForUrls = 849;
  optional DefaultFileSystemReadGuardSettingProto DefaultFileSystemReadGuardSetting = 775;
  optional DefaultFileSystemWriteGuardSettingProto DefaultFileSystemWriteGuardSetting = 776;
  optional FileSystemReadAskForUrlsProto FileSystemReadAskForUrls = 777;
  optional FileSystemReadBlockedForUrlsProto FileSystemReadBlockedForUrls = 778;
  optional FileSystemWriteAskForUrlsProto FileSystemWriteAskForUrls = 779;
  optional FileSystemWriteBlockedForUrlsProto FileSystemWriteBlockedForUrls = 780;
  optional AutoSelectCertificateForUrlsProto AutoSelectCertificateForUrls = 104;
  optional CookiesAllowedForUrlsProto CookiesAllowedForUrls = 79;
  optional CookiesBlockedForUrlsProto CookiesBlockedForUrls = 69;
  optional CookiesSessionOnlyForUrlsProto CookiesSessionOnlyForUrls = 70;
  optional ImagesAllowedForUrlsProto ImagesAllowedForUrls = 71;
  optional ImagesBlockedForUrlsProto ImagesBlockedForUrls = 72;
  optional JavaScriptAllowedForUrlsProto JavaScriptAllowedForUrls = 73;
  optional JavaScriptBlockedForUrlsProto JavaScriptBlockedForUrls = 74;
  optional DefaultClipboardSettingProto DefaultClipboardSetting = 985;
  optional ClipboardAllowedForUrlsProto ClipboardAllowedForUrls = 986;
  optional ClipboardBlockedForUrlsProto ClipboardBlockedForUrls = 987;
  optional KeygenAllowedForUrlsProto KeygenAllowedForUrls = 316;
  optional KeygenBlockedForUrlsProto KeygenBlockedForUrls = 317;
  optional LegacySameSiteCookieBehaviorEnabledProto LegacySameSiteCookieBehaviorEnabled = 625;
  optional LegacySameSiteCookieBehaviorEnabledForDomainListProto LegacySameSiteCookieBehaviorEnabledForDomainList = 626;
  optional LensCameraAssistedSearchEnabledProto LensCameraAssistedSearchEnabled = 855;
  optional LensRegionSearchEnabledProto LensRegionSearchEnabled = 888;
  optional SideSearchEnabledProto SideSearchEnabled = 908;
  optional InsecurePrivateNetworkRequestsAllowedProto InsecurePrivateNetworkRequestsAllowed = 768;
  optional InsecurePrivateNetworkRequestsAllowedForUrlsProto InsecurePrivateNetworkRequestsAllowedForUrls = 769;
  optional PluginsAllowedForUrlsProto PluginsAllowedForUrls = 75;
  optional PluginsBlockedForUrlsProto PluginsBlockedForUrls = 76;
  optional PopupsAllowedForUrlsProto PopupsAllowedForUrls = 77;
  optional RegisteredProtocolHandlersProto RegisteredProtocolHandlers = 270;
  optional PopupsBlockedForUrlsProto PopupsBlockedForUrls = 78;
  optional NotificationsAllowedForUrlsProto NotificationsAllowedForUrls = 107;
  optional NotificationsBlockedForUrlsProto NotificationsBlockedForUrls = 108;
  optional SensorsAllowedForUrlsProto SensorsAllowedForUrls = 757;
  optional SensorsBlockedForUrlsProto SensorsBlockedForUrls = 758;
  optional NativeMessagingBlacklistProto NativeMessagingBlacklist = 253;
  optional NativeMessagingBlocklistProto NativeMessagingBlocklist = 746;
  optional NativeMessagingWhitelistProto NativeMessagingWhitelist = 254;
  optional NativeMessagingAllowlistProto NativeMessagingAllowlist = 747;
  optional NativeMessagingUserLevelHostsProto NativeMessagingUserLevelHosts = 255;
  optional Disable3DAPIsProto Disable3DAPIs = 57;
  optional PolicyRefreshRateProto PolicyRefreshRate = 58;
  optional MaxInvalidationFetchDelayProto MaxInvalidationFetchDelay = 230;
  optional ChromeFrameRendererSettingsProto ChromeFrameRendererSettings = 59;
  optional RenderInChromeFrameListProto RenderInChromeFrameList = 60;
  optional RenderInHostListProto RenderInHostList = 61;
  optional AdditionalLaunchParametersProto AdditionalLaunchParameters = 143;
  optional SkipMetadataCheckProto SkipMetadataCheck = 240;
  optional ChromeFrameContentTypesProto ChromeFrameContentTypes = 62;
  optional ChromeOsLockOnIdleSuspendProto ChromeOsLockOnIdleSuspend = 63;
  optional ChromeOsMultiProfileUserBehaviorProto ChromeOsMultiProfileUserBehavior = 246;
  optional SecondaryGoogleAccountSigninAllowedProto SecondaryGoogleAccountSigninAllowed = 408;
  optional SecondaryGoogleAccountUsageProto SecondaryGoogleAccountUsage = 958;
  optional ForceLogoutUnauthenticatedUserEnabledProto ForceLogoutUnauthenticatedUserEnabled = 681;
  optional SecurityTokenSessionBehaviorProto SecurityTokenSessionBehavior = 801;
  optional SecurityTokenSessionNotificationSecondsProto SecurityTokenSessionNotificationSeconds = 802;
  optional TargetBlankImpliesNoOpenerProto TargetBlankImpliesNoOpener = 804;
  optional InstantEnabledProto InstantEnabled = 64;
  optional AppRecommendationZeroStateEnabledProto AppRecommendationZeroStateEnabled = 565;
  optional TranslateEnabledProto TranslateEnabled = 82;
  optional AllowOutdatedPluginsProto AllowOutdatedPlugins = 83;
  optional AlwaysAuthorizePluginsProto AlwaysAuthorizePlugins = 88;
  optional RunAllFlashInAllowModeProto RunAllFlashInAllowMode = 393;
  optional BookmarkBarEnabledProto BookmarkBarEnabled = 84;
  optional EditBookmarksEnabledProto EditBookmarksEnabled = 85;
  optional ShowAppsShortcutInBookmarkBarProto ShowAppsShortcutInBookmarkBar = 269;
  optional AllowFileSelectionDialogsProto AllowFileSelectionDialogs = 86;
  optional SecurityKeyPermitAttestationProto SecurityKeyPermitAttestation = 404;
  optional U2fSecurityKeyApiEnabledProto U2fSecurityKeyApiEnabled = 905;
  optional WebAuthenticationRemoteProxiedRequestsAllowedProto WebAuthenticationRemoteProxiedRequestsAllowed = 967;
  optional GCFUserDataDirProto GCFUserDataDir = 89;
  optional ImportBookmarksProto ImportBookmarks = 99;
  optional ImportHistoryProto ImportHistory = 100;
  optional ImportHomepageProto ImportHomepage = 101;
  optional ImportSearchEngineProto ImportSearchEngine = 102;
  optional ImportSavedPasswordsProto ImportSavedPasswords = 103;
  optional ImportAutofillFormDataProto ImportAutofillFormData = 279;
  optional MaxConnectionsPerProxyProto MaxConnectionsPerProxy = 94;
  optional HideWebStorePromoProto HideWebStorePromo = 98;
  optional URLBlacklistProto URLBlacklist = 105;
  optional URLWhitelistProto URLWhitelist = 106;
  optional URLBlocklistProto URLBlocklist = 738;
  optional URLAllowlistProto URLAllowlist = 739;
  optional PolicyAtomicGroupsEnabledProto PolicyAtomicGroupsEnabled = 586;
  optional PolicyListMultipleSourceMergeListProto PolicyListMultipleSourceMergeList = 556;
  optional PolicyDictionaryMultipleSourceMergeListProto PolicyDictionaryMultipleSourceMergeList = 567;
  optional CloudUserPolicyMergeProto CloudUserPolicyMerge = 861;
  optional EnableExperimentalPoliciesProto EnableExperimentalPolicies = 713;
  optional PolicyScopeDetectionProto PolicyScopeDetection = 991;
  optional OpenNetworkConfigurationProto OpenNetworkConfiguration = 109;
  optional CloudPrintSubmitEnabledProto CloudPrintSubmitEnabled = 111;
  optional EnterpriseWebStoreURLProto EnterpriseWebStoreURL = 114;
  optional EnterpriseWebStoreNameProto EnterpriseWebStoreName = 115;
  optional DisablePrintPreviewProto DisablePrintPreview = 119;
  optional PrintHeaderFooterProto PrintHeaderFooter = 482;
  optional DefaultPrinterSelectionProto DefaultPrinterSelection = 310;
  optional DisableSSLRecordSplittingProto DisableSSLRecordSplitting = 120;
  optional EnableOnlineRevocationChecksProto EnableOnlineRevocationChecks = 131;
  optional RequireOnlineRevocationChecksForLocalAnchorsProto RequireOnlineRevocationChecksForLocalAnchors = 237;
  optional EnableSha1ForLocalAnchorsProto EnableSha1ForLocalAnchors = 342;
  optional EnableCommonNameFallbackForLocalAnchorsProto EnableCommonNameFallbackForLocalAnchors = 368;
  optional EnableSymantecLegacyInfrastructureProto EnableSymantecLegacyInfrastructure = 415;
  optional BuiltinCertificateVerifierEnabledProto BuiltinCertificateVerifierEnabled = 577;
  optional ChromeRootStoreEnabledProto ChromeRootStoreEnabled = 994;
  optional ForceEphemeralProfilesProto ForceEphemeralProfiles = 247;
  optional GaiaOfflineSigninTimeLimitDaysProto GaiaOfflineSigninTimeLimitDays = 823;
  optional SAMLOfflineSigninTimeLimitProto SAMLOfflineSigninTimeLimit = 256;
  optional GaiaLockScreenOfflineSigninTimeLimitDaysProto GaiaLockScreenOfflineSigninTimeLimitDays = 835;
  optional SamlLockScreenOfflineSigninTimeLimitDaysProto SamlLockScreenOfflineSigninTimeLimitDays = 836;
  optional ReportArcStatusEnabledProto ReportArcStatusEnabled = 351;
  optional ReportCrostiniUsageEnabledProto ReportCrostiniUsageEnabled = 486;
  optional DeviceLocalAccountManagedSessionEnabledProto DeviceLocalAccountManagedSessionEnabled = 465;
  optional ManagedGuestSessionAutoLaunchNotificationReducedProto ManagedGuestSessionAutoLaunchNotificationReduced = 690;
  optional BackgroundModeEnabledProto BackgroundModeEnabled = 140;
  optional DriveDisabledProto DriveDisabled = 141;
  optional DriveDisabledOverCellularProto DriveDisabledOverCellular = 142;
  optional PinnedLauncherAppsProto PinnedLauncherApps = 146;
  optional RestrictSigninToPatternProto RestrictSigninToPattern = 149;
  optional DisableSafeBrowsingProceedAnywayProto DisableSafeBrowsingProceedAnyway = 152;
  optional SafeBrowsingExtendedReportingOptInAllowedProto SafeBrowsingExtendedReportingOptInAllowed = 301;
  optional SpellCheckServiceEnabledProto SpellCheckServiceEnabled = 153;
  optional ExternalStorageDisabledProto ExternalStorageDisabled = 154;
  optional ExternalStorageReadOnlyProto ExternalStorageReadOnly = 345;
  optional AudioOutputAllowedProto AudioOutputAllowed = 161;
  optional AudioCaptureAllowedProto AudioCaptureAllowed = 162;
  optional AudioCaptureAllowedUrlsProto AudioCaptureAllowedUrls = 210;
  optional VideoCaptureAllowedProto VideoCaptureAllowed = 169;
  optional VideoCaptureAllowedUrlsProto VideoCaptureAllowedUrls = 211;
  optional DisableScreenshotsProto DisableScreenshots = 155;
  optional TouchVirtualKeyboardEnabledProto TouchVirtualKeyboardEnabled = 271;
  optional ShowLogoutButtonInTrayProto ShowLogoutButtonInTray = 166;
  optional BuiltInDnsClientEnabledProto BuiltInDnsClientEnabled = 167;
  optional DnsOverHttpsModeProto DnsOverHttpsMode = 584;
  optional DnsOverHttpsTemplatesProto DnsOverHttpsTemplates = 644;
  optional AdditionalDnsQueryTypesEnabledProto AdditionalDnsQueryTypesEnabled = 859;
  optional ShelfAutoHideBehaviorProto ShelfAutoHideBehavior = 168;
  optional ShelfAlignmentProto ShelfAlignment = 622;
  optional SystemFeaturesDisableListProto SystemFeaturesDisableList = 691;
  optional SystemFeaturesDisableModeProto SystemFeaturesDisableMode = 809;
  optional FloatingAccessibilityMenuEnabledProto FloatingAccessibilityMenuEnabled = 693;
  optional UserDisplayNameProto UserDisplayName = 171;
  optional SessionLengthLimitProto SessionLengthLimit = 172;
  optional FullscreenAllowedProto FullscreenAllowed = 242;
  optional FullscreenAlertEnabledProto FullscreenAlertEnabled = 806;
  optional KeepFullscreenWithoutNotificationUrlAllowListProto KeepFullscreenWithoutNotificationUrlAllowList = 932;
  optional ScreenDimDelayACProto ScreenDimDelayAC = 174;
  optional ScreenOffDelayACProto ScreenOffDelayAC = 175;
  optional ScreenLockDelayACProto ScreenLockDelayAC = 176;
  optional IdleWarningDelayACProto IdleWarningDelayAC = 199;
  optional IdleDelayACProto IdleDelayAC = 177;
  optional ScreenDimDelayBatteryProto ScreenDimDelayBattery = 178;
  optional ScreenOffDelayBatteryProto ScreenOffDelayBattery = 179;
  optional ScreenLockDelayBatteryProto ScreenLockDelayBattery = 180;
  optional IdleWarningDelayBatteryProto IdleWarningDelayBattery = 200;
  optional IdleDelayBatteryProto IdleDelayBattery = 181;
  optional IdleActionProto IdleAction = 182;
  optional IdleActionACProto IdleActionAC = 228;
  optional IdleActionBatteryProto IdleActionBattery = 224;
  optional LidCloseActionProto LidCloseAction = 183;
  optional PowerManagementUsesAudioActivityProto PowerManagementUsesAudioActivity = 184;
  optional PowerManagementUsesVideoActivityProto PowerManagementUsesVideoActivity = 185;
  optional PresentationIdleDelayScaleProto PresentationIdleDelayScale = 186;
  optional PresentationScreenDimDelayScaleProto PresentationScreenDimDelayScale = 222;
  optional AllowWakeLocksProto AllowWakeLocks = 493;
  optional AllowScreenWakeLocksProto AllowScreenWakeLocks = 205;
  optional UserActivityScreenDimDelayScaleProto UserActivityScreenDimDelayScale = 212;
  optional WaitForInitialUserActivityProto WaitForInitialUserActivity = 249;
  optional PowerManagementIdleSettingsProto PowerManagementIdleSettings = 260;
  optional ScreenLockDelaysProto ScreenLockDelays = 261;
  optional TermsOfServiceURLProto TermsOfServiceURL = 188;
  optional ShowAccessibilityOptionsInSystemTrayMenuProto ShowAccessibilityOptionsInSystemTrayMenu = 190;
  optional LargeCursorEnabledProto LargeCursorEnabled = 213;
  optional SpokenFeedbackEnabledProto SpokenFeedbackEnabled = 214;
  optional HighContrastEnabledProto HighContrastEnabled = 215;
  optional AccessibilityShortcutsEnabledProto AccessibilityShortcutsEnabled = 661;
  optional VirtualKeyboardEnabledProto VirtualKeyboardEnabled = 257;
  optional VirtualKeyboardFeaturesProto VirtualKeyboardFeatures = 719;
  optional StickyKeysEnabledProto StickyKeysEnabled = 563;
  optional SelectToSpeakEnabledProto SelectToSpeakEnabled = 575;
  optional DictationEnabledProto DictationEnabled = 594;
  optional KeyboardFocusHighlightEnabledProto KeyboardFocusHighlightEnabled = 595;
  optional CursorHighlightEnabledProto CursorHighlightEnabled = 596;
  optional CaretHighlightEnabledProto CaretHighlightEnabled = 597;
  optional MonoAudioEnabledProto MonoAudioEnabled = 598;
  optional AutoclickEnabledProto AutoclickEnabled = 599;
  optional KeyboardDefaultToFunctionKeysProto KeyboardDefaultToFunctionKeys = 262;
  optional ScreenMagnifierTypeProto ScreenMagnifierType = 216;
  optional PrimaryMouseButtonSwitchProto PrimaryMouseButtonSwitch = 657;
  optional SharedClipboardEnabledProto SharedClipboardEnabled = 612;
  optional HideWebStoreIconProto HideWebStoreIcon = 191;
  optional VariationsRestrictParameterProto VariationsRestrictParameter = 198;
  optional ChromeVariationsProto ChromeVariations = 665;
  optional AttestationEnabledForUserProto AttestationEnabledForUser = 202;
  optional AttestationExtensionAllowlistProto AttestationExtensionAllowlist = 787;
  optional AttestationExtensionWhitelistProto AttestationExtensionWhitelist = 203;
  optional SuppressChromeFrameTurndownPromptProto SuppressChromeFrameTurndownPrompt = 223;
  optional SupervisedUserCreationEnabledProto SupervisedUserCreationEnabled = 225;
  optional SupervisedUserContentProviderEnabledProto SupervisedUserContentProviderEnabled = 314;
  optional ManagedBookmarksProto ManagedBookmarks = 229;
  optional DataCompressionProxyEnabledProto DataCompressionProxyEnabled = 243;
  optional UserAvatarImageProto UserAvatarImage = 251;
  optional WallpaperImageProto WallpaperImage = 264;
  optional EnableDeprecatedWebPlatformFeaturesProto EnableDeprecatedWebPlatformFeatures = 272;
  optional EasyUnlockAllowedProto EasyUnlockAllowed = 274;
  optional SessionLocalesProto SessionLocales = 276;
  optional BrowserGuestModeEnabledProto BrowserGuestModeEnabled = 277;
  optional BrowserGuestModeEnforcedProto BrowserGuestModeEnforced = 576;
  optional BrowserAddPersonEnabledProto BrowserAddPersonEnabled = 278;
  optional ForceBrowserSigninProto ForceBrowserSignin = 348;
  optional BrowserSigninProto BrowserSignin = 489;
  optional SSLVersionMinProto SSLVersionMin = 281;
  optional SSLVersionFallbackMinProto SSLVersionFallbackMin = 282;
  optional SSLVersionMaxProto SSLVersionMax = 363;
  optional CECPQ2EnabledProto CECPQ2Enabled = 843;
  optional CertificateTransparencyEnforcementDisabledForUrlsProto CertificateTransparencyEnforcementDisabledForUrls = 337;
  optional CertificateTransparencyEnforcementDisabledForCasProto CertificateTransparencyEnforcementDisabledForCas = 437;
  optional CertificateTransparencyEnforcementDisabledForLegacyCasProto CertificateTransparencyEnforcementDisabledForLegacyCas = 438;
  optional RC4EnabledProto RC4Enabled = 312;
  optional DHEEnabledProto DHEEnabled = 336;
  optional ContextualSearchEnabledProto ContextualSearchEnabled = 283;
  optional ForceMaximizeOnFirstRunProto ForceMaximizeOnFirstRun = 300;
  optional SSLErrorOverrideAllowedProto SSLErrorOverrideAllowed = 302;
  optional SSLErrorOverrideAllowedForOriginsProto SSLErrorOverrideAllowedForOrigins = 821;
  optional DeviceAttributesAllowedForOriginsProto DeviceAttributesAllowedForOrigins = 867;
  optional QuicAllowedProto QuicAllowed = 303;
  optional KeyPermissionsProto KeyPermissions = 304;
  optional WelcomePageOnOSUpgradeEnabledProto WelcomePageOnOSUpgradeEnabled = 305;
  optional HardwareAccelerationModeEnabledProto HardwareAccelerationModeEnabled = 306;
  optional UnifiedDesktopEnabledByDefaultProto UnifiedDesktopEnabledByDefault = 309;
  optional ArcEnabledProto ArcEnabled = 319;
  optional ArcPolicyProto ArcPolicy = 320;
  optional NewWindowsInKioskAllowedProto NewWindowsInKioskAllowed = 997;
  optional SuppressUnsupportedOSWarningProto SuppressUnsupportedOSWarning = 326;
  optional TaskManagerEndProcessEnabledProto TaskManagerEndProcessEnabled = 329;
  optional AllowScreenLockProto AllowScreenLock = 331;
  optional ArcCertificatesSyncModeProto ArcCertificatesSyncMode = 332;
  optional AllowedDomainsForAppsProto AllowedDomainsForApps = 333;
  optional PacHttpsUrlStrippingEnabledProto PacHttpsUrlStrippingEnabled = 334;
  optional EnableMediaRouterProto EnableMediaRouter = 335;
  optional ShowCastIconInToolbarProto ShowCastIconInToolbar = 364;
  optional MediaRouterCastAllowAllIPsProto MediaRouterCastAllowAllIPs = 439;
  optional ArcBackupRestoreEnabledProto ArcBackupRestoreEnabled = 339;
  optional ArcLocationServiceEnabledProto ArcLocationServiceEnabled = 365;
  optional NTPContentSuggestionsEnabledProto NTPContentSuggestionsEnabled = 340;
  optional NTPCustomBackgroundEnabledProto NTPCustomBackgroundEnabled = 655;
  optional NTPCardsVisibleProto NTPCardsVisible = 807;
  optional NTPMiddleSlotAnnouncementVisibleProto NTPMiddleSlotAnnouncementVisible = 943;
  optional WebRtcUdpPortRangeProto WebRtcUdpPortRange = 341;
  optional WebRtcLocalIpsAllowedUrlsProto WebRtcLocalIpsAllowedUrls = 642;
  optional ComponentUpdatesEnabledProto ComponentUpdatesEnabled = 344;
  optional NativePrintersProto NativePrinters = 352;
  optional PrintersProto Printers = 771;
  optional NativePrintersBulkConfigurationProto NativePrintersBulkConfiguration = 384;
  optional PrintersBulkConfigurationProto PrintersBulkConfiguration = 772;
  optional NativePrintersBulkAccessModeProto NativePrintersBulkAccessMode = 385;
  optional PrintersBulkAccessModeProto PrintersBulkAccessMode = 774;
  optional NativePrintersBulkBlacklistProto NativePrintersBulkBlacklist = 386;
  optional PrintersBulkBlocklistProto PrintersBulkBlocklist = 781;
  optional NativePrintersBulkWhitelistProto NativePrintersBulkWhitelist = 387;
  optional PrintersBulkAllowlistProto PrintersBulkAllowlist = 782;
  optional QuickUnlockModeAllowlistProto QuickUnlockModeAllowlist = 786;
  optional QuickUnlockModeWhitelistProto QuickUnlockModeWhitelist = 354;
  optional QuickUnlockTimeoutProto QuickUnlockTimeout = 355;
  optional WebAuthnFactorsProto WebAuthnFactors = 966;
  optional PinUnlockMinimumLengthProto PinUnlockMinimumLength = 356;
  optional PinUnlockMaximumLengthProto PinUnlockMaximumLength = 357;
  optional PinUnlockWeakPinsAllowedProto PinUnlockWeakPinsAllowed = 358;
  optional SmsMessagesAllowedProto SmsMessagesAllowed = 471;
  optional WifiSyncAndroidAllowedProto WifiSyncAndroidAllowed = 800;
  optional SmartLockSigninAllowedProto SmartLockSigninAllowed = 490;
  optional InstantTetheringAllowedProto InstantTetheringAllowed = 369;
  optional PhoneHubAllowedProto PhoneHubAllowed = 797;
  optional PhoneHubCameraRollAllowedProto PhoneHubCameraRollAllowed = 938;
  optional PhoneHubNotificationsAllowedProto PhoneHubNotificationsAllowed = 798;
  optional PhoneHubTaskContinuationAllowedProto PhoneHubTaskContinuationAllowed = 799;
  optional EcheAllowedProto EcheAllowed = 939;
  optional NearbyShareAllowedProto NearbyShareAllowed = 763;
  optional BrowserNetworkTimeQueriesEnabledProto BrowserNetworkTimeQueriesEnabled = 372;
  optional PrintPreviewUseSystemDefaultPrinterProto PrintPreviewUseSystemDefaultPrinter = 375;
  optional EcryptfsMigrationStrategyProto EcryptfsMigrationStrategy = 378;
  optional SchedulerConfigurationProto SchedulerConfiguration = 524;
  optional NoteTakingAppsLockScreenWhitelistProto NoteTakingAppsLockScreenWhitelist = 379;
  optional NoteTakingAppsLockScreenAllowlistProto NoteTakingAppsLockScreenAllowlist = 761;
  optional CastReceiverEnabledProto CastReceiverEnabled = 380;
  optional CloudPolicyOverridesPlatformPolicyProto CloudPolicyOverridesPlatformPolicy = 383;
  optional CloudUserPolicyOverridesCloudMachinePolicyProto CloudUserPolicyOverridesCloudMachinePolicy = 901;
  optional PromptForDownloadLocationProto PromptForDownloadLocation = 397;
  optional IsolateOriginsProto IsolateOrigins = 400;
  optional SitePerProcessProto SitePerProcess = 401;
  optional IsolateOriginsAndroidProto IsolateOriginsAndroid = 447;
  optional SitePerProcessAndroidProto SitePerProcessAndroid = 448;
  optional SharedArrayBufferUnrestrictedAccessAllowedProto SharedArrayBufferUnrestrictedAccessAllowed = 854;
  optional SandboxExternalProtocolBlockedProto SandboxExternalProtocolBlocked = 915;
  optional CrossOriginWebAssemblyModuleSharingEnabledProto CrossOriginWebAssemblyModuleSharingEnabled = 880;
  optional DisplayCapturePermissionsPolicyEnabledProto DisplayCapturePermissionsPolicyEnabled = 882;
  optional WebDriverOverridesIncompatiblePoliciesProto WebDriverOverridesIncompatiblePolicies = 416;
  optional UnsafelyTreatInsecureOriginAsSecureProto UnsafelyTreatInsecureOriginAsSecure = 402;
  optional DefaultDownloadDirectoryProto DefaultDownloadDirectory = 403;
  optional AbusiveExperienceInterventionEnforceProto AbusiveExperienceInterventionEnforce = 406;
  optional SpellcheckLanguageProto SpellcheckLanguage = 407;
  optional SpellcheckLanguageBlacklistProto SpellcheckLanguageBlacklist = 538;
  optional SpellcheckLanguageBlocklistProto SpellcheckLanguageBlocklist = 751;
  optional ThirdPartyBlockingEnabledProto ThirdPartyBlockingEnabled = 409;
  optional SpellcheckEnabledProto SpellcheckEnabled = 410;
  optional AdsSettingForIntrusiveAdsSitesProto AdsSettingForIntrusiveAdsSites = 411;
  optional RestrictAccountsToPatternsProto RestrictAccountsToPatterns = 412;
  optional PasswordProtectionWarningTriggerProto PasswordProtectionWarningTrigger = 413;
  optional RelaunchNotificationProto RelaunchNotification = 421;
  optional RelaunchNotificationPeriodProto RelaunchNotificationPeriod = 422;
  optional RelaunchHeadsUpPeriodProto RelaunchHeadsUpPeriod = 569;
  optional RelaunchWindowProto RelaunchWindow = 856;
  optional CrostiniAllowedProto CrostiniAllowed = 483;
  optional CrostiniExportImportUIAllowedProto CrostiniExportImportUIAllowed = 525;
  optional CrostiniRootAccessAllowedProto CrostiniRootAccessAllowed = 578;
  optional CrostiniAnsiblePlaybookProto CrostiniAnsiblePlaybook = 641;
  optional CrostiniArcAdbSideloadingAllowedProto CrostiniArcAdbSideloadingAllowed = 692;
  optional CrostiniPortForwardingAllowedProto CrostiniPortForwardingAllowed = 718;
  optional SystemTerminalSshAllowedProto SystemTerminalSshAllowed = 976;
  optional SafeBrowsingWhitelistDomainsProto SafeBrowsingWhitelistDomains = 424;
  optional SafeBrowsingAllowlistDomainsProto SafeBrowsingAllowlistDomains = 734;
  optional PasswordProtectionLoginURLsProto PasswordProtectionLoginURLs = 425;
  optional PasswordProtectionChangePasswordURLProto PasswordProtectionChangePasswordURL = 426;
  optional SafeBrowsingExtendedReportingEnabledProto SafeBrowsingExtendedReportingEnabled = 431;
  optional MachineLevelUserCloudPolicyEnrollmentTokenProto MachineLevelUserCloudPolicyEnrollmentToken = 430;
  optional CloudManagementEnrollmentTokenProto CloudManagementEnrollmentToken = 512;
  optional CloudManagementEnrollmentMandatoryProto CloudManagementEnrollmentMandatory = 507;
  optional AutoplayAllowedProto AutoplayAllowed = 432;
  optional AutoplayWhitelistProto AutoplayWhitelist = 433;
  optional AutoplayAllowlistProto AutoplayAllowlist = 744;
  optional TabUnderAllowedProto TabUnderAllowed = 434;
  optional UserNativePrintersAllowedProto UserNativePrintersAllowed = 435;
  optional UserPrintersAllowedProto UserPrintersAllowed = 770;
  optional ChromeCleanupEnabledProto ChromeCleanupEnabled = 443;
  optional ChromeCleanupReportingEnabledProto ChromeCleanupReportingEnabled = 444;
  optional AllowedLanguagesProto AllowedLanguages = 446;
  optional AllowedInputMethodsProto AllowedInputMethods = 458;
  optional ArcAppInstallEventLoggingEnabledProto ArcAppInstallEventLoggingEnabled = 449;
  optional ExtensionInstallEventLoggingEnabledProto ExtensionInstallEventLoggingEnabled = 729;
  optional UsageTimeLimitProto UsageTimeLimit = 450;
  optional ArcBackupRestoreServiceEnabledProto ArcBackupRestoreServiceEnabled = 451;
  optional ArcGoogleLocationServicesEnabledProto ArcGoogleLocationServicesEnabled = 452;
  optional EnableSyncConsentProto EnableSyncConsent = 453;
  optional ContextualSuggestionsEnabledProto ContextualSuggestionsEnabled = 454;
  optional PromotionalTabsEnabledProto PromotionalTabsEnabled = 456;
  optional SafeSitesFilterBehaviorProto SafeSitesFilterBehavior = 457;
  optional OverrideSecurityRestrictionsOnInsecureOriginProto OverrideSecurityRestrictionsOnInsecureOrigin = 459;
  optional TabFreezingEnabledProto TabFreezingEnabled = 462;
  optional UrlKeyedAnonymizedDataCollectionEnabledProto UrlKeyedAnonymizedDataCollectionEnabled = 463;
  optional NetworkFileSharesAllowedProto NetworkFileSharesAllowed = 464;
  optional WebRtcEventLogCollectionAllowedProto WebRtcEventLogCollectionAllowed = 466;
  optional PowerSmartDimEnabledProto PowerSmartDimEnabled = 467;
  optional CoalesceH2ConnectionsWithClientCertificatesForHostsProto CoalesceH2ConnectionsWithClientCertificatesForHosts = 468;
  optional NetBiosShareDiscoveryEnabledProto NetBiosShareDiscoveryEnabled = 469;
  optional ManagedConfigurationPerOriginProto ManagedConfigurationPerOrigin = 815;
  optional WebAppInstallForceListProto WebAppInstallForceList = 470;
  optional ReportVersionDataProto ReportVersionData = 472;
  optional ReportPolicyDataProto ReportPolicyData = 473;
  optional ReportMachineIDDataProto ReportMachineIDData = 474;
  optional ReportUserIDDataProto ReportUserIDData = 475;
  optional ReportExtensionsAndPluginsDataProto ReportExtensionsAndPluginsData = 501;
  optional ReportSafeBrowsingDataProto ReportSafeBrowsingData = 502;
  optional CloudExtensionRequestEnabledProto CloudExtensionRequestEnabled = 610;
  optional CloudReportingEnabledProto CloudReportingEnabled = 495;
  optional CloudProfileReportingEnabledProto CloudProfileReportingEnabled = 944;
  optional CloudReportingUploadFrequencyProto CloudReportingUploadFrequency = 964;
  optional EnterpriseHardwarePlatformAPIEnabledProto EnterpriseHardwarePlatformAPIEnabled = 485;
  optional VpnConfigAllowedProto VpnConfigAllowed = 487;
  optional NTLMShareAuthenticationEnabledProto NTLMShareAuthenticationEnabled = 491;
  optional NetworkFileSharesPreconfiguredSharesProto NetworkFileSharesPreconfiguredShares = 492;
  optional ScreenBrightnessPercentProto ScreenBrightnessPercent = 494;
  optional AlternativeBrowserPathProto AlternativeBrowserPath = 496;
  optional AlternativeBrowserParametersProto AlternativeBrowserParameters = 497;
  optional BrowserSwitcherChromePathProto BrowserSwitcherChromePath = 532;
  optional BrowserSwitcherChromeParametersProto BrowserSwitcherChromeParameters = 533;
  optional BrowserSwitcherUrlListProto BrowserSwitcherUrlList = 498;
  optional BrowserSwitcherUrlGreylistProto BrowserSwitcherUrlGreylist = 499;
  optional BrowserSwitcherUseIeSitelistProto BrowserSwitcherUseIeSitelist = 500;
  optional BrowserSwitcherExternalSitelistUrlProto BrowserSwitcherExternalSitelistUrl = 513;
  optional BrowserSwitcherExternalGreylistUrlProto BrowserSwitcherExternalGreylistUrl = 566;
  optional BrowserSwitcherDelayProto BrowserSwitcherDelay = 526;
  optional BrowserSwitcherEnabledProto BrowserSwitcherEnabled = 519;
  optional BrowserSwitcherParsingModeProto BrowserSwitcherParsingMode = 868;
  optional BrowserSwitcherKeepLastChromeTabProto BrowserSwitcherKeepLastChromeTab = 521;
  optional UserPluginVmAllowedProto UserPluginVmAllowed = 707;
  optional PluginVmUserIdProto PluginVmUserId = 700;
  optional PluginVmImageProto PluginVmImage = 506;
  optional PluginVmDataCollectionAllowedProto PluginVmDataCollectionAllowed = 714;
  optional PluginVmRequiredFreeDiskSpaceProto PluginVmRequiredFreeDiskSpace = 726;
  optional ParentAccessCodeConfigProto ParentAccessCodeConfig = 509;
  optional ClientCertificateManagementAllowedProto ClientCertificateManagementAllowed = 520;
  optional ForceNetworkInProcessProto ForceNetworkInProcess = 523;
  optional AssistantOnboardingModeProto AssistantOnboardingMode = 731;
  optional VoiceInteractionContextEnabledProto VoiceInteractionContextEnabled = 529;
  optional VoiceInteractionHotwordEnabledProto VoiceInteractionHotwordEnabled = 531;
  optional AssistantVoiceMatchEnabledDuringOobeProto AssistantVoiceMatchEnabledDuringOobe = 887;
  optional VoiceInteractionQuickAnswersEnabledProto VoiceInteractionQuickAnswersEnabled = 696;
  optional QuickAnswersEnabledProto QuickAnswersEnabled = 919;
  optional QuickAnswersDefinitionEnabledProto QuickAnswersDefinitionEnabled = 920;
  optional QuickAnswersTranslationEnabledProto QuickAnswersTranslationEnabled = 921;
  optional QuickAnswersUnitConversionEnabledProto QuickAnswersUnitConversionEnabled = 922;
  optional AllowPopupsDuringPageUnloadProto AllowPopupsDuringPageUnload = 535;
  optional SignedHTTPExchangeEnabledProto SignedHTTPExchangeEnabled = 544;
  optional ContextAwareAccessSignalsAllowlistProto ContextAwareAccessSignalsAllowlist = 828;
  optional SamlInSessionPasswordChangeEnabledProto SamlInSessionPasswordChangeEnabled = 547;
  optional LockScreenReauthenticationEnabledProto LockScreenReauthenticationEnabled = 721;
  optional UserFeedbackAllowedProto UserFeedbackAllowed = 572;
  optional SamlPasswordExpirationAdvanceWarningDaysProto SamlPasswordExpirationAdvanceWarningDays = 557;
  optional KerberosEnabledProto KerberosEnabled = 559;
  optional KerberosRememberPasswordEnabledProto KerberosRememberPasswordEnabled = 560;
  optional KerberosAddAccountsAllowedProto KerberosAddAccountsAllowed = 561;
  optional KerberosAccountsProto KerberosAccounts = 562;
  optional KerberosDomainAutocompleteProto KerberosDomainAutocomplete = 1001;
  optional KerberosDefaultConfigurationProto KerberosDefaultConfiguration = 1002;
  optional CommandLineFlagSecurityWarningsEnabledProto CommandLineFlagSecurityWarningsEnabled = 568;
  optional StartupBrowserWindowLaunchSuppressedProto StartupBrowserWindowLaunchSuppressed = 570;
  optional ExternalPrintServersProto ExternalPrintServers = 574;
  optional VmManagementCliAllowedProto VmManagementCliAllowed = 579;
  optional CACertificateManagementAllowedProto CACertificateManagementAllowed = 581;
  optional LockScreenMediaPlaybackEnabledProto LockScreenMediaPlaybackEnabled = 583;
  optional OnFileDownloadedEnterpriseConnectorProto OnFileDownloadedEnterpriseConnector = 698;
  optional OnFileAttachedEnterpriseConnectorProto OnFileAttachedEnterpriseConnector = 695;
  optional OnBulkDataEntryEnterpriseConnectorProto OnBulkDataEntryEnterpriseConnector = 699;
  optional OnPrintEnterpriseConnectorProto OnPrintEnterpriseConnector = 933;
  optional OnFileTransferEnterpriseConnectorProto OnFileTransferEnterpriseConnector = 993;
  optional OnSecurityEventEnterpriseConnectorProto OnSecurityEventEnterpriseConnector = 701;
  optional EnterpriseRealTimeUrlCheckModeProto EnterpriseRealTimeUrlCheckMode = 730;
  optional RendererCodeIntegrityEnabledProto RendererCodeIntegrityEnabled = 600;
  optional RendererAppContainerEnabledProto RendererAppContainerEnabled = 989;
  optional BrowserLegacyExtensionPointsBlockedProto BrowserLegacyExtensionPointsBlocked = 895;
  optional HSTSPolicyBypassListProto HSTSPolicyBypassList = 603;
  optional AllowSyncXHRInPageDismissalProto AllowSyncXHRInPageDismissal = 606;
  optional TotalMemoryLimitMbProto TotalMemoryLimitMb = 618;
  optional TLS13HardeningForLocalAnchorsEnabledProto TLS13HardeningForLocalAnchorsEnabled = 628;
  optional AudioSandboxEnabledProto AudioSandboxEnabled = 629;
  optional CorsMitigationListProto CorsMitigationList = 631;
  optional CorsLegacyModeEnabledProto CorsLegacyModeEnabled = 632;
  optional ExternalPrintServersWhitelistProto ExternalPrintServersWhitelist = 633;
  optional ExternalPrintServersAllowlistProto ExternalPrintServersAllowlist = 752;
  optional ExternalProtocolDialogShowAlwaysOpenCheckboxProto ExternalProtocolDialogShowAlwaysOpenCheckbox = 634;
  optional DefaultInsecureContentSettingProto DefaultInsecureContentSetting = 635;
  optional InsecureContentAllowedForUrlsProto InsecureContentAllowedForUrls = 636;
  optional InsecureContentBlockedForUrlsProto InsecureContentBlockedForUrls = 637;
  optional PerAppTimeLimitsProto PerAppTimeLimits = 643;
  optional WebComponentsV0EnabledProto WebComponentsV0Enabled = 646;
  optional UseLegacyFormControlsProto UseLegacyFormControls = 685;
  optional EventPathEnabledProto EventPathEnabled = 992;
  optional ClickToCallEnabledProto ClickToCallEnabled = 647;
  optional UserDataSnapshotRetentionLimitProto UserDataSnapshotRetentionLimit = 675;
  optional PrinterTypeDenyListProto PrinterTypeDenyList = 649;
  optional PrintPostScriptModeProto PrintPostScriptMode = 897;
  optional PrintRasterizationModeProto PrintRasterizationMode = 708;
  optional PrintPdfAsImageAvailabilityProto PrintPdfAsImageAvailability = 891;
  optional PrintRasterizePdfDpiProto PrintRasterizePdfDpi = 892;
  optional PrintPdfAsImageDefaultProto PrintPdfAsImageDefault = 898;
  optional DeletePrintJobHistoryAllowedProto DeletePrintJobHistoryAllowed = 722;
  optional AmbientAuthenticationInPrivateModesEnabledProto AmbientAuthenticationInPrivateModesEnabled = 652;
  optional PaymentMethodQueryEnabledProto PaymentMethodQueryEnabled = 653;
  optional StricterMixedContentTreatmentEnabledProto StricterMixedContentTreatmentEnabled = 654;
  optional PerAppTimeLimitsWhitelistProto PerAppTimeLimitsWhitelist = 660;
  optional PerAppTimeLimitsAllowlistProto PerAppTimeLimitsAllowlist = 764;
  optional LocalDiscoveryEnabledProto LocalDiscoveryEnabled = 664;
  optional ScreenCaptureAllowedProto ScreenCaptureAllowed = 668;
  optional ScreenCaptureAllowedByOriginsProto ScreenCaptureAllowedByOrigins = 883;
  optional WindowCaptureAllowedByOriginsProto WindowCaptureAllowedByOrigins = 884;
  optional TabCaptureAllowedByOriginsProto TabCaptureAllowedByOrigins = 885;
  optional SameOriginTabCaptureAllowedByOriginsProto SameOriginTabCaptureAllowedByOrigins = 886;
  optional AdvancedProtectionDeepScanningEnabledProto AdvancedProtectionDeepScanningEnabled = 669;
  optional PrivacyScreenEnabledProto PrivacyScreenEnabled = 679;
  optional AllowNativeNotificationsProto AllowNativeNotifications = 680;
  optional AllowSystemNotificationsProto AllowSystemNotifications = 830;
  optional RequiredClientCertificateForUserProto RequiredClientCertificateForUser = 682;
  optional AdvancedProtectionAllowedProto AdvancedProtectionAllowed = 687;
  optional ScrollToTextFragmentEnabledProto ScrollToTextFragmentEnabled = 689;
  optional LoginDisplayPasswordButtonEnabledProto LoginDisplayPasswordButtonEnabled = 703;
  optional AccessibilityImageLabelsEnabledProto AccessibilityImageLabelsEnabled = 705;
  optional IntensiveWakeUpThrottlingEnabledProto IntensiveWakeUpThrottlingEnabled = 715;
  optional BackForwardCacheEnabledProto BackForwardCacheEnabled = 760;
  optional PinUnlockAutosubmitEnabledProto PinUnlockAutosubmitEnabled = 720;
  optional EmojiSuggestionEnabledProto EmojiSuggestionEnabled = 723;
  optional UserAgentClientHintsEnabledProto UserAgentClientHintsEnabled = 727;
  optional UserAgentClientHintsGREASEUpdateEnabledProto UserAgentClientHintsGREASEUpdateEnabled = 926;
  optional UrlParamFilterEnabledProto UrlParamFilterEnabled = 983;
  optional SuggestedContentEnabledProto SuggestedContentEnabled = 728;
  optional ShowFullUrlsInAddressBarProto ShowFullUrlsInAddressBar = 741;
  optional InsecureFormsWarningsEnabledProto InsecureFormsWarningsEnabled = 750;
  optional LookalikeWarningAllowlistDomainsProto LookalikeWarningAllowlistDomains = 784;
  optional CCTToSDialogEnabledProto CCTToSDialogEnabled = 762;
  optional TosDialogBehaviorProto TosDialogBehavior = 803;
  optional CloudPrintWarningsSuppressedProto CloudPrintWarningsSuppressed = 783;
  optional EnableDeprecatedPrivetPrintingProto EnableDeprecatedPrivetPrinting = 817;
  optional DataLeakPreventionClipboardCheckSizeLimitProto DataLeakPreventionClipboardCheckSizeLimit = 879;
  optional DataLeakPreventionReportingEnabledProto DataLeakPreventionReportingEnabled = 858;
  optional DataLeakPreventionRulesListProto DataLeakPreventionRulesList = 788;
  optional WebRtcAllowLegacyTLSProtocolsProto WebRtcAllowLegacyTLSProtocols = 789;
  optional MediaRecommendationsEnabledProto MediaRecommendationsEnabled = 790;
  optional EduCoexistenceToSVersionProto EduCoexistenceToSVersion = 792;
  optional BrowsingDataLifetimeProto BrowsingDataLifetime = 793;
  optional LacrosAllowedProto LacrosAllowed = 795;
  optional LacrosSecondaryProfilesAllowedProto LacrosSecondaryProfilesAllowed = 834;
  optional LacrosAvailabilityProto LacrosAvailability = 857;
  optional IntegratedWebAuthenticationAllowedProto IntegratedWebAuthenticationAllowed = 810;
  optional ClearBrowsingDataOnExitListProto ClearBrowsingDataOnExitList = 811;
  optional ProfilePickerOnStartupAvailabilityProto ProfilePickerOnStartupAvailability = 812;
  optional SigninInterceptionEnabledProto SigninInterceptionEnabled = 813;
  optional WebXRImmersiveArEnabledProto WebXRImmersiveArEnabled = 822;
  optional SendDownloadToCloudEnterpriseConnectorProto SendDownloadToCloudEnterpriseConnector = 824;
  optional WebAppSettingsProto WebAppSettings = 826;
  optional FetchKeepaliveDurationSecondsOnShutdownProto FetchKeepaliveDurationSecondsOnShutdown = 829;
  optional SuppressDifferentOriginSubframeDialogsProto SuppressDifferentOriginSubframeDialogs = 831;
  optional UserBorealisAllowedProto UserBorealisAllowed = 833;
  optional AudioProcessHighPriorityEnabledProto AudioProcessHighPriorityEnabled = 838;
  optional ForcedLanguagesProto ForcedLanguages = 841;
  optional BrowserThemeColorProto BrowserThemeColor = 842;
  optional WebRtcIPHandlingProto WebRtcIPHandling = 845;
  optional PdfAnnotationsEnabledProto PdfAnnotationsEnabled = 846;
  optional ExplicitlyAllowedNetworkPortsProto ExplicitlyAllowedNetworkPorts = 851;
  optional SuggestLogoutAfterClosingLastWindowProto SuggestLogoutAfterClosingLastWindow = 853;
  optional TripleDESEnabledProto TripleDESEnabled = 860;
  optional ManagedAccountsSigninRestrictionProto ManagedAccountsSigninRestriction = 862;
  optional UnmanagedDeviceSignalsConsentFlowEnabledProto UnmanagedDeviceSignalsConsentFlowEnabled = 1003;
  optional LockIconInAddressBarEnabledProto LockIconInAddressBarEnabled = 863;
  optional DefaultJavaScriptJitSettingProto DefaultJavaScriptJitSetting = 869;
  optional JavaScriptJitAllowedForSitesProto JavaScriptJitAllowedForSites = 870;
  optional JavaScriptJitBlockedForSitesProto JavaScriptJitBlockedForSites = 871;
  optional HttpsOnlyModeProto HttpsOnlyMode = 872;
  optional DesktopSharingHubEnabledProto DesktopSharingHubEnabled = 873;
  optional RestrictedManagedGuestSessionExtensionCleanupExemptListProto RestrictedManagedGuestSessionExtensionCleanupExemptList = 881;
  optional ArcAppToWebAppSharingEnabledProto ArcAppToWebAppSharingEnabled = 889;
  optional EnhancedNetworkVoicesInSelectToSpeakAllowedProto EnhancedNetworkVoicesInSelectToSpeakAllowed = 890;
  optional ChromeAppsEnabledProto ChromeAppsEnabled = 894;
  optional FullRestoreEnabledProto FullRestoreEnabled = 899;
  optional GhostWindowEnabledProto GhostWindowEnabled = 900;
  optional WebSQLInThirdPartyContextEnabledProto WebSQLInThirdPartyContextEnabled = 904;
  optional PromptOnMultipleMatchingCertificatesProto PromptOnMultipleMatchingCertificates = 907;
  optional AccessCodeCastEnabledProto AccessCodeCastEnabled = 909;
  optional AccessCodeCastDeviceDurationProto AccessCodeCastDeviceDuration = 910;
  optional NetworkServiceSandboxEnabledProto NetworkServiceSandboxEnabled = 911;
  optional DeskTemplatesEnabledProto DeskTemplatesEnabled = 912;
  optional PreconfiguredDeskTemplatesProto PreconfiguredDeskTemplates = 913;
  optional FastPairEnabledProto FastPairEnabled = 914;
  optional CORSNonWildcardRequestHeadersSupportProto CORSNonWildcardRequestHeadersSupport = 923;
  optional CopyPreventionSettingsProto CopyPreventionSettings = 930;
  optional UserAgentReductionProto UserAgentReduction = 934;
  optional ForceMajorVersionToMinorPositionInUserAgentProto ForceMajorVersionToMinorPositionInUserAgent = 951;
  optional OriginAgentClusterDefaultEnabledProto OriginAgentClusterDefaultEnabled = 935;
  optional ProjectorEnabledProto ProjectorEnabled = 937;
  optional DefaultWindowPlacementSettingProto DefaultWindowPlacementSetting = 953;
  optional WindowPlacementAllowedForUrlsProto WindowPlacementAllowedForUrls = 962;
  optional WindowPlacementBlockedForUrlsProto WindowPlacementBlockedForUrls = 963;
  optional DefaultLocalFontsSettingProto DefaultLocalFontsSetting = 979;
  optional LocalFontsAllowedForUrlsProto LocalFontsAllowedForUrls = 980;
  optional LocalFontsBlockedForUrlsProto LocalFontsBlockedForUrls = 981;
  optional ExemptDomainFileTypePairsFromFileTypeDownloadWarningsProto ExemptDomainFileTypePairsFromFileTypeDownloadWarnings = 949;
  optional FirstPartySetsEnabledProto FirstPartySetsEnabled = 950;
  optional FirstPartySetsOverridesProto FirstPartySetsOverrides = 971;
  optional IsolatedAppsDeveloperModeAllowedProto IsolatedAppsDeveloperModeAllowed = 960;
  optional FloatingWorkspaceEnabledProto FloatingWorkspaceEnabled = 961;
  optional OptimizationGuideFetchingEnabledProto OptimizationGuideFetchingEnabled = 965;
  optional WebSQLAccessProto WebSQLAccess = 968;
  optional WebSQLNonSecureContextEnabledProto WebSQLNonSecureContextEnabled = 995;
  optional SetTimeoutWithout1MsClampEnabledProto SetTimeoutWithout1MsClampEnabled = 969;
  optional AllowChromeDataInBackupsProto AllowChromeDataInBackups = 970;
  optional DevicePowerAdaptiveChargingEnabledProto DevicePowerAdaptiveChargingEnabled = 973;
  optional WarnBeforeQuittingEnabledProto WarnBeforeQuittingEnabled = 975;
  optional OsColorModeProto OsColorMode = 988;
  optional InsightsExtensionEnabledProto InsightsExtensionEnabled = 977;
  optional EnterpriseAuthenticationAppLinkPolicyProto EnterpriseAuthenticationAppLinkPolicy = 978;
  optional ProjectorDogfoodForFamilyLinkEnabledProto ProjectorDogfoodForFamilyLinkEnabled = 982;
  optional ScreenTimeEnabledProto ScreenTimeEnabled = 984;
  optional UnthrottledNestedTimeoutEnabledProto UnthrottledNestedTimeoutEnabled = 990;
  optional IdleProfileCloseTimeoutProto IdleProfileCloseTimeout = 996;
  optional EncryptedClientHelloEnabledProto EncryptedClientHelloEnabled = 998;
  optional EnterpriseProfileCreationKeepBrowsingDataProto EnterpriseProfileCreationKeepBrowsingData = 1000;
  optional PersistentQuotaEnabledProto PersistentQuotaEnabled = 1004;
}
