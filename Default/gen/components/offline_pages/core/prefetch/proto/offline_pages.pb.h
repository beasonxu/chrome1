// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: offline_pages.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_offline_5fpages_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_offline_5fpages_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "status.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_offline_5fpages_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_offline_5fpages_2eproto {
  static const uint32_t offsets[];
};
namespace offline_pages {
namespace proto {
class Archive;
struct ArchiveDefaultTypeInternal;
extern ArchiveDefaultTypeInternal _Archive_default_instance_;
class GeneratePageBundleRequest;
struct GeneratePageBundleRequestDefaultTypeInternal;
extern GeneratePageBundleRequestDefaultTypeInternal _GeneratePageBundleRequest_default_instance_;
class PageBundle;
struct PageBundleDefaultTypeInternal;
extern PageBundleDefaultTypeInternal _PageBundle_default_instance_;
class PageInfo;
struct PageInfoDefaultTypeInternal;
extern PageInfoDefaultTypeInternal _PageInfo_default_instance_;
class PageParameters;
struct PageParametersDefaultTypeInternal;
extern PageParametersDefaultTypeInternal _PageParameters_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace proto
}  // namespace offline_pages
PROTOBUF_NAMESPACE_OPEN
template<> ::offline_pages::proto::Archive* Arena::CreateMaybeMessage<::offline_pages::proto::Archive>(Arena*);
template<> ::offline_pages::proto::GeneratePageBundleRequest* Arena::CreateMaybeMessage<::offline_pages::proto::GeneratePageBundleRequest>(Arena*);
template<> ::offline_pages::proto::PageBundle* Arena::CreateMaybeMessage<::offline_pages::proto::PageBundle>(Arena*);
template<> ::offline_pages::proto::PageInfo* Arena::CreateMaybeMessage<::offline_pages::proto::PageInfo>(Arena*);
template<> ::offline_pages::proto::PageParameters* Arena::CreateMaybeMessage<::offline_pages::proto::PageParameters>(Arena*);
template<> ::offline_pages::proto::Timestamp* Arena::CreateMaybeMessage<::offline_pages::proto::Timestamp>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace offline_pages {
namespace proto {

enum Transformation : int {
  TRANSFORMATION_UNSPECIFIED = 0,
  NO_TRANSFORMATION = 1
};
bool Transformation_IsValid(int value);
constexpr Transformation Transformation_MIN = TRANSFORMATION_UNSPECIFIED;
constexpr Transformation Transformation_MAX = NO_TRANSFORMATION;
constexpr int Transformation_ARRAYSIZE = Transformation_MAX + 1;

const std::string& Transformation_Name(Transformation value);
template<typename T>
inline const std::string& Transformation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Transformation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Transformation_Name.");
  return Transformation_Name(static_cast<Transformation>(enum_t_value));
}
bool Transformation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Transformation* value);
enum OutputFormat : int {
  FORMAT_UNSPECIFIED = 0,
  FORMAT_MHTML = 1
};
bool OutputFormat_IsValid(int value);
constexpr OutputFormat OutputFormat_MIN = FORMAT_UNSPECIFIED;
constexpr OutputFormat OutputFormat_MAX = FORMAT_MHTML;
constexpr int OutputFormat_ARRAYSIZE = OutputFormat_MAX + 1;

const std::string& OutputFormat_Name(OutputFormat value);
template<typename T>
inline const std::string& OutputFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OutputFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OutputFormat_Name.");
  return OutputFormat_Name(static_cast<OutputFormat>(enum_t_value));
}
bool OutputFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OutputFormat* value);
// ===================================================================

class Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:offline_pages.proto.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  explicit PROTOBUF_CONSTEXPR Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Timestamp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Timestamp& from);
  void MergeFrom(const Timestamp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Timestamp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "offline_pages.proto.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // optional int64 seconds = 1;
  bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  void clear_seconds();
  int64_t seconds() const;
  void set_seconds(int64_t value);
  private:
  int64_t _internal_seconds() const;
  void _internal_set_seconds(int64_t value);
  public:

  // optional int32 nanos = 2;
  bool has_nanos() const;
  private:
  bool _internal_has_nanos() const;
  public:
  void clear_nanos();
  int32_t nanos() const;
  void set_nanos(int32_t value);
  private:
  int32_t _internal_nanos() const;
  void _internal_set_nanos(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:offline_pages.proto.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t seconds_;
  int32_t nanos_;
  friend struct ::TableStruct_offline_5fpages_2eproto;
};
// -------------------------------------------------------------------

class PageBundle final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:offline_pages.proto.PageBundle) */ {
 public:
  inline PageBundle() : PageBundle(nullptr) {}
  ~PageBundle() override;
  explicit PROTOBUF_CONSTEXPR PageBundle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PageBundle(const PageBundle& from);
  PageBundle(PageBundle&& from) noexcept
    : PageBundle() {
    *this = ::std::move(from);
  }

  inline PageBundle& operator=(const PageBundle& from) {
    CopyFrom(from);
    return *this;
  }
  inline PageBundle& operator=(PageBundle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PageBundle& default_instance() {
    return *internal_default_instance();
  }
  static inline const PageBundle* internal_default_instance() {
    return reinterpret_cast<const PageBundle*>(
               &_PageBundle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PageBundle& a, PageBundle& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PageBundle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PageBundle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PageBundle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PageBundle>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PageBundle& from);
  void MergeFrom(const PageBundle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PageBundle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "offline_pages.proto.PageBundle";
  }
  protected:
  explicit PageBundle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArchivesFieldNumber = 1,
  };
  // repeated .offline_pages.proto.Archive archives = 1;
  int archives_size() const;
  private:
  int _internal_archives_size() const;
  public:
  void clear_archives();
  ::offline_pages::proto::Archive* mutable_archives(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::Archive >*
      mutable_archives();
  private:
  const ::offline_pages::proto::Archive& _internal_archives(int index) const;
  ::offline_pages::proto::Archive* _internal_add_archives();
  public:
  const ::offline_pages::proto::Archive& archives(int index) const;
  ::offline_pages::proto::Archive* add_archives();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::Archive >&
      archives() const;

  // @@protoc_insertion_point(class_scope:offline_pages.proto.PageBundle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::Archive > archives_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_offline_5fpages_2eproto;
};
// -------------------------------------------------------------------

class Archive final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:offline_pages.proto.Archive) */ {
 public:
  inline Archive() : Archive(nullptr) {}
  ~Archive() override;
  explicit PROTOBUF_CONSTEXPR Archive(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Archive(const Archive& from);
  Archive(Archive&& from) noexcept
    : Archive() {
    *this = ::std::move(from);
  }

  inline Archive& operator=(const Archive& from) {
    CopyFrom(from);
    return *this;
  }
  inline Archive& operator=(Archive&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Archive& default_instance() {
    return *internal_default_instance();
  }
  static inline const Archive* internal_default_instance() {
    return reinterpret_cast<const Archive*>(
               &_Archive_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Archive& a, Archive& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Archive* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Archive* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Archive* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Archive>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Archive& from);
  void MergeFrom(const Archive& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Archive* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "offline_pages.proto.Archive";
  }
  protected:
  explicit Archive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPageInfosFieldNumber = 1,
    kBodyNameFieldNumber = 3,
    kBodyLengthFieldNumber = 4,
    kOutputFormatFieldNumber = 2,
  };
  // repeated .offline_pages.proto.PageInfo page_infos = 1;
  int page_infos_size() const;
  private:
  int _internal_page_infos_size() const;
  public:
  void clear_page_infos();
  ::offline_pages::proto::PageInfo* mutable_page_infos(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageInfo >*
      mutable_page_infos();
  private:
  const ::offline_pages::proto::PageInfo& _internal_page_infos(int index) const;
  ::offline_pages::proto::PageInfo* _internal_add_page_infos();
  public:
  const ::offline_pages::proto::PageInfo& page_infos(int index) const;
  ::offline_pages::proto::PageInfo* add_page_infos();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageInfo >&
      page_infos() const;

  // optional string body_name = 3;
  bool has_body_name() const;
  private:
  bool _internal_has_body_name() const;
  public:
  void clear_body_name();
  const std::string& body_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body_name();
  PROTOBUF_NODISCARD std::string* release_body_name();
  void set_allocated_body_name(std::string* body_name);
  private:
  const std::string& _internal_body_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body_name(const std::string& value);
  std::string* _internal_mutable_body_name();
  public:

  // optional int64 body_length = 4;
  bool has_body_length() const;
  private:
  bool _internal_has_body_length() const;
  public:
  void clear_body_length();
  int64_t body_length() const;
  void set_body_length(int64_t value);
  private:
  int64_t _internal_body_length() const;
  void _internal_set_body_length(int64_t value);
  public:

  // optional .offline_pages.proto.OutputFormat output_format = 2;
  bool has_output_format() const;
  private:
  bool _internal_has_output_format() const;
  public:
  void clear_output_format();
  ::offline_pages::proto::OutputFormat output_format() const;
  void set_output_format(::offline_pages::proto::OutputFormat value);
  private:
  ::offline_pages::proto::OutputFormat _internal_output_format() const;
  void _internal_set_output_format(::offline_pages::proto::OutputFormat value);
  public:

  // @@protoc_insertion_point(class_scope:offline_pages.proto.Archive)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageInfo > page_infos_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_name_;
  int64_t body_length_;
  int output_format_;
  friend struct ::TableStruct_offline_5fpages_2eproto;
};
// -------------------------------------------------------------------

class PageInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:offline_pages.proto.PageInfo) */ {
 public:
  inline PageInfo() : PageInfo(nullptr) {}
  ~PageInfo() override;
  explicit PROTOBUF_CONSTEXPR PageInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PageInfo(const PageInfo& from);
  PageInfo(PageInfo&& from) noexcept
    : PageInfo() {
    *this = ::std::move(from);
  }

  inline PageInfo& operator=(const PageInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PageInfo& operator=(PageInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PageInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PageInfo* internal_default_instance() {
    return reinterpret_cast<const PageInfo*>(
               &_PageInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PageInfo& a, PageInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PageInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PageInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PageInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PageInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PageInfo& from);
  void MergeFrom(const PageInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PageInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "offline_pages.proto.PageInfo";
  }
  protected:
  explicit PageInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kRedirectUrlFieldNumber = 2,
    kStatusFieldNumber = 3,
    kRenderTimeFieldNumber = 5,
    kTransformationFieldNumber = 4,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string redirect_url = 2;
  bool has_redirect_url() const;
  private:
  bool _internal_has_redirect_url() const;
  public:
  void clear_redirect_url();
  const std::string& redirect_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_redirect_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_redirect_url();
  PROTOBUF_NODISCARD std::string* release_redirect_url();
  void set_allocated_redirect_url(std::string* redirect_url);
  private:
  const std::string& _internal_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_redirect_url(const std::string& value);
  std::string* _internal_mutable_redirect_url();
  public:

  // optional .offline_pages.proto.Status status = 3;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::offline_pages::proto::Status& status() const;
  PROTOBUF_NODISCARD ::offline_pages::proto::Status* release_status();
  ::offline_pages::proto::Status* mutable_status();
  void set_allocated_status(::offline_pages::proto::Status* status);
  private:
  const ::offline_pages::proto::Status& _internal_status() const;
  ::offline_pages::proto::Status* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::offline_pages::proto::Status* status);
  ::offline_pages::proto::Status* unsafe_arena_release_status();

  // optional .offline_pages.proto.Timestamp render_time = 5;
  bool has_render_time() const;
  private:
  bool _internal_has_render_time() const;
  public:
  void clear_render_time();
  const ::offline_pages::proto::Timestamp& render_time() const;
  PROTOBUF_NODISCARD ::offline_pages::proto::Timestamp* release_render_time();
  ::offline_pages::proto::Timestamp* mutable_render_time();
  void set_allocated_render_time(::offline_pages::proto::Timestamp* render_time);
  private:
  const ::offline_pages::proto::Timestamp& _internal_render_time() const;
  ::offline_pages::proto::Timestamp* _internal_mutable_render_time();
  public:
  void unsafe_arena_set_allocated_render_time(
      ::offline_pages::proto::Timestamp* render_time);
  ::offline_pages::proto::Timestamp* unsafe_arena_release_render_time();

  // optional .offline_pages.proto.Transformation transformation = 4;
  bool has_transformation() const;
  private:
  bool _internal_has_transformation() const;
  public:
  void clear_transformation();
  ::offline_pages::proto::Transformation transformation() const;
  void set_transformation(::offline_pages::proto::Transformation value);
  private:
  ::offline_pages::proto::Transformation _internal_transformation() const;
  void _internal_set_transformation(::offline_pages::proto::Transformation value);
  public:

  // @@protoc_insertion_point(class_scope:offline_pages.proto.PageInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr redirect_url_;
  ::offline_pages::proto::Status* status_;
  ::offline_pages::proto::Timestamp* render_time_;
  int transformation_;
  friend struct ::TableStruct_offline_5fpages_2eproto;
};
// -------------------------------------------------------------------

class GeneratePageBundleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:offline_pages.proto.GeneratePageBundleRequest) */ {
 public:
  inline GeneratePageBundleRequest() : GeneratePageBundleRequest(nullptr) {}
  ~GeneratePageBundleRequest() override;
  explicit PROTOBUF_CONSTEXPR GeneratePageBundleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GeneratePageBundleRequest(const GeneratePageBundleRequest& from);
  GeneratePageBundleRequest(GeneratePageBundleRequest&& from) noexcept
    : GeneratePageBundleRequest() {
    *this = ::std::move(from);
  }

  inline GeneratePageBundleRequest& operator=(const GeneratePageBundleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GeneratePageBundleRequest& operator=(GeneratePageBundleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GeneratePageBundleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GeneratePageBundleRequest* internal_default_instance() {
    return reinterpret_cast<const GeneratePageBundleRequest*>(
               &_GeneratePageBundleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GeneratePageBundleRequest& a, GeneratePageBundleRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GeneratePageBundleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GeneratePageBundleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GeneratePageBundleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GeneratePageBundleRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GeneratePageBundleRequest& from);
  void MergeFrom(const GeneratePageBundleRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GeneratePageBundleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "offline_pages.proto.GeneratePageBundleRequest";
  }
  protected:
  explicit GeneratePageBundleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBrowserLanguagesFieldNumber = 2,
    kPagesFieldNumber = 6,
    kUserAgentFieldNumber = 1,
    kGcmRegistrationIdFieldNumber = 5,
    kMaxBundleSizeBytesFieldNumber = 4,
    kOutputFormatFieldNumber = 3,
  };
  // repeated string browser_languages = 2;
  int browser_languages_size() const;
  private:
  int _internal_browser_languages_size() const;
  public:
  void clear_browser_languages();
  const std::string& browser_languages(int index) const;
  std::string* mutable_browser_languages(int index);
  void set_browser_languages(int index, const std::string& value);
  void set_browser_languages(int index, std::string&& value);
  void set_browser_languages(int index, const char* value);
  void set_browser_languages(int index, const char* value, size_t size);
  std::string* add_browser_languages();
  void add_browser_languages(const std::string& value);
  void add_browser_languages(std::string&& value);
  void add_browser_languages(const char* value);
  void add_browser_languages(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& browser_languages() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_browser_languages();
  private:
  const std::string& _internal_browser_languages(int index) const;
  std::string* _internal_add_browser_languages();
  public:

  // repeated .offline_pages.proto.PageParameters pages = 6;
  int pages_size() const;
  private:
  int _internal_pages_size() const;
  public:
  void clear_pages();
  ::offline_pages::proto::PageParameters* mutable_pages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageParameters >*
      mutable_pages();
  private:
  const ::offline_pages::proto::PageParameters& _internal_pages(int index) const;
  ::offline_pages::proto::PageParameters* _internal_add_pages();
  public:
  const ::offline_pages::proto::PageParameters& pages(int index) const;
  ::offline_pages::proto::PageParameters* add_pages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageParameters >&
      pages() const;

  // optional string user_agent = 1;
  bool has_user_agent() const;
  private:
  bool _internal_has_user_agent() const;
  public:
  void clear_user_agent();
  const std::string& user_agent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_agent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_agent();
  PROTOBUF_NODISCARD std::string* release_user_agent();
  void set_allocated_user_agent(std::string* user_agent);
  private:
  const std::string& _internal_user_agent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_agent(const std::string& value);
  std::string* _internal_mutable_user_agent();
  public:

  // optional string gcm_registration_id = 5;
  bool has_gcm_registration_id() const;
  private:
  bool _internal_has_gcm_registration_id() const;
  public:
  void clear_gcm_registration_id();
  const std::string& gcm_registration_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gcm_registration_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gcm_registration_id();
  PROTOBUF_NODISCARD std::string* release_gcm_registration_id();
  void set_allocated_gcm_registration_id(std::string* gcm_registration_id);
  private:
  const std::string& _internal_gcm_registration_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gcm_registration_id(const std::string& value);
  std::string* _internal_mutable_gcm_registration_id();
  public:

  // optional int64 max_bundle_size_bytes = 4;
  bool has_max_bundle_size_bytes() const;
  private:
  bool _internal_has_max_bundle_size_bytes() const;
  public:
  void clear_max_bundle_size_bytes();
  int64_t max_bundle_size_bytes() const;
  void set_max_bundle_size_bytes(int64_t value);
  private:
  int64_t _internal_max_bundle_size_bytes() const;
  void _internal_set_max_bundle_size_bytes(int64_t value);
  public:

  // optional .offline_pages.proto.OutputFormat output_format = 3;
  bool has_output_format() const;
  private:
  bool _internal_has_output_format() const;
  public:
  void clear_output_format();
  ::offline_pages::proto::OutputFormat output_format() const;
  void set_output_format(::offline_pages::proto::OutputFormat value);
  private:
  ::offline_pages::proto::OutputFormat _internal_output_format() const;
  void _internal_set_output_format(::offline_pages::proto::OutputFormat value);
  public:

  // @@protoc_insertion_point(class_scope:offline_pages.proto.GeneratePageBundleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> browser_languages_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageParameters > pages_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_agent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gcm_registration_id_;
  int64_t max_bundle_size_bytes_;
  int output_format_;
  friend struct ::TableStruct_offline_5fpages_2eproto;
};
// -------------------------------------------------------------------

class PageParameters final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:offline_pages.proto.PageParameters) */ {
 public:
  inline PageParameters() : PageParameters(nullptr) {}
  ~PageParameters() override;
  explicit PROTOBUF_CONSTEXPR PageParameters(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PageParameters(const PageParameters& from);
  PageParameters(PageParameters&& from) noexcept
    : PageParameters() {
    *this = ::std::move(from);
  }

  inline PageParameters& operator=(const PageParameters& from) {
    CopyFrom(from);
    return *this;
  }
  inline PageParameters& operator=(PageParameters&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PageParameters& default_instance() {
    return *internal_default_instance();
  }
  static inline const PageParameters* internal_default_instance() {
    return reinterpret_cast<const PageParameters*>(
               &_PageParameters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PageParameters& a, PageParameters& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PageParameters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PageParameters* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PageParameters* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PageParameters>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PageParameters& from);
  void MergeFrom(const PageParameters& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PageParameters* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "offline_pages.proto.PageParameters";
  }
  protected:
  explicit PageParameters(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kTransformationFieldNumber = 2,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional .offline_pages.proto.Transformation transformation = 2;
  bool has_transformation() const;
  private:
  bool _internal_has_transformation() const;
  public:
  void clear_transformation();
  ::offline_pages::proto::Transformation transformation() const;
  void set_transformation(::offline_pages::proto::Transformation value);
  private:
  ::offline_pages::proto::Transformation _internal_transformation() const;
  void _internal_set_transformation(::offline_pages::proto::Transformation value);
  public:

  // @@protoc_insertion_point(class_scope:offline_pages.proto.PageParameters)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  int transformation_;
  friend struct ::TableStruct_offline_5fpages_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Timestamp

// optional int64 seconds = 1;
inline bool Timestamp::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Timestamp::has_seconds() const {
  return _internal_has_seconds();
}
inline void Timestamp::clear_seconds() {
  seconds_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t Timestamp::_internal_seconds() const {
  return seconds_;
}
inline int64_t Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  seconds_ = value;
}
inline void Timestamp::set_seconds(int64_t value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.Timestamp.seconds)
}

// optional int32 nanos = 2;
inline bool Timestamp::_internal_has_nanos() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Timestamp::has_nanos() const {
  return _internal_has_nanos();
}
inline void Timestamp::clear_nanos() {
  nanos_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t Timestamp::_internal_nanos() const {
  return nanos_;
}
inline int32_t Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.Timestamp.nanos)
  return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  nanos_ = value;
}
inline void Timestamp::set_nanos(int32_t value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.Timestamp.nanos)
}

// -------------------------------------------------------------------

// PageBundle

// repeated .offline_pages.proto.Archive archives = 1;
inline int PageBundle::_internal_archives_size() const {
  return archives_.size();
}
inline int PageBundle::archives_size() const {
  return _internal_archives_size();
}
inline void PageBundle::clear_archives() {
  archives_.Clear();
}
inline ::offline_pages::proto::Archive* PageBundle::mutable_archives(int index) {
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.PageBundle.archives)
  return archives_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::Archive >*
PageBundle::mutable_archives() {
  // @@protoc_insertion_point(field_mutable_list:offline_pages.proto.PageBundle.archives)
  return &archives_;
}
inline const ::offline_pages::proto::Archive& PageBundle::_internal_archives(int index) const {
  return archives_.Get(index);
}
inline const ::offline_pages::proto::Archive& PageBundle::archives(int index) const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageBundle.archives)
  return _internal_archives(index);
}
inline ::offline_pages::proto::Archive* PageBundle::_internal_add_archives() {
  return archives_.Add();
}
inline ::offline_pages::proto::Archive* PageBundle::add_archives() {
  ::offline_pages::proto::Archive* _add = _internal_add_archives();
  // @@protoc_insertion_point(field_add:offline_pages.proto.PageBundle.archives)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::Archive >&
PageBundle::archives() const {
  // @@protoc_insertion_point(field_list:offline_pages.proto.PageBundle.archives)
  return archives_;
}

// -------------------------------------------------------------------

// Archive

// repeated .offline_pages.proto.PageInfo page_infos = 1;
inline int Archive::_internal_page_infos_size() const {
  return page_infos_.size();
}
inline int Archive::page_infos_size() const {
  return _internal_page_infos_size();
}
inline void Archive::clear_page_infos() {
  page_infos_.Clear();
}
inline ::offline_pages::proto::PageInfo* Archive::mutable_page_infos(int index) {
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.Archive.page_infos)
  return page_infos_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageInfo >*
Archive::mutable_page_infos() {
  // @@protoc_insertion_point(field_mutable_list:offline_pages.proto.Archive.page_infos)
  return &page_infos_;
}
inline const ::offline_pages::proto::PageInfo& Archive::_internal_page_infos(int index) const {
  return page_infos_.Get(index);
}
inline const ::offline_pages::proto::PageInfo& Archive::page_infos(int index) const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.Archive.page_infos)
  return _internal_page_infos(index);
}
inline ::offline_pages::proto::PageInfo* Archive::_internal_add_page_infos() {
  return page_infos_.Add();
}
inline ::offline_pages::proto::PageInfo* Archive::add_page_infos() {
  ::offline_pages::proto::PageInfo* _add = _internal_add_page_infos();
  // @@protoc_insertion_point(field_add:offline_pages.proto.Archive.page_infos)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageInfo >&
Archive::page_infos() const {
  // @@protoc_insertion_point(field_list:offline_pages.proto.Archive.page_infos)
  return page_infos_;
}

// optional .offline_pages.proto.OutputFormat output_format = 2;
inline bool Archive::_internal_has_output_format() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Archive::has_output_format() const {
  return _internal_has_output_format();
}
inline void Archive::clear_output_format() {
  output_format_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::offline_pages::proto::OutputFormat Archive::_internal_output_format() const {
  return static_cast< ::offline_pages::proto::OutputFormat >(output_format_);
}
inline ::offline_pages::proto::OutputFormat Archive::output_format() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.Archive.output_format)
  return _internal_output_format();
}
inline void Archive::_internal_set_output_format(::offline_pages::proto::OutputFormat value) {
  assert(::offline_pages::proto::OutputFormat_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  output_format_ = value;
}
inline void Archive::set_output_format(::offline_pages::proto::OutputFormat value) {
  _internal_set_output_format(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.Archive.output_format)
}

// optional string body_name = 3;
inline bool Archive::_internal_has_body_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Archive::has_body_name() const {
  return _internal_has_body_name();
}
inline void Archive::clear_body_name() {
  body_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Archive::body_name() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.Archive.body_name)
  return _internal_body_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Archive::set_body_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 body_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:offline_pages.proto.Archive.body_name)
}
inline std::string* Archive::mutable_body_name() {
  std::string* _s = _internal_mutable_body_name();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.Archive.body_name)
  return _s;
}
inline const std::string& Archive::_internal_body_name() const {
  return body_name_.Get();
}
inline void Archive::_internal_set_body_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  body_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Archive::_internal_mutable_body_name() {
  _has_bits_[0] |= 0x00000001u;
  return body_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Archive::release_body_name() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.Archive.body_name)
  if (!_internal_has_body_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = body_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_name_.IsDefault()) {
    body_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Archive::set_allocated_body_name(std::string* body_name) {
  if (body_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  body_name_.SetAllocated(body_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_name_.IsDefault()) {
    body_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.Archive.body_name)
}

// optional int64 body_length = 4;
inline bool Archive::_internal_has_body_length() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Archive::has_body_length() const {
  return _internal_has_body_length();
}
inline void Archive::clear_body_length() {
  body_length_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t Archive::_internal_body_length() const {
  return body_length_;
}
inline int64_t Archive::body_length() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.Archive.body_length)
  return _internal_body_length();
}
inline void Archive::_internal_set_body_length(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  body_length_ = value;
}
inline void Archive::set_body_length(int64_t value) {
  _internal_set_body_length(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.Archive.body_length)
}

// -------------------------------------------------------------------

// PageInfo

// optional string url = 1;
inline bool PageInfo::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PageInfo::has_url() const {
  return _internal_has_url();
}
inline void PageInfo::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PageInfo::url() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageInfo.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PageInfo::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:offline_pages.proto.PageInfo.url)
}
inline std::string* PageInfo::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.PageInfo.url)
  return _s;
}
inline const std::string& PageInfo::_internal_url() const {
  return url_.Get();
}
inline void PageInfo::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* PageInfo::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* PageInfo::release_url() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.PageInfo.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PageInfo::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.PageInfo.url)
}

// optional string redirect_url = 2;
inline bool PageInfo::_internal_has_redirect_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PageInfo::has_redirect_url() const {
  return _internal_has_redirect_url();
}
inline void PageInfo::clear_redirect_url() {
  redirect_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PageInfo::redirect_url() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageInfo.redirect_url)
  return _internal_redirect_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PageInfo::set_redirect_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 redirect_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:offline_pages.proto.PageInfo.redirect_url)
}
inline std::string* PageInfo::mutable_redirect_url() {
  std::string* _s = _internal_mutable_redirect_url();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.PageInfo.redirect_url)
  return _s;
}
inline const std::string& PageInfo::_internal_redirect_url() const {
  return redirect_url_.Get();
}
inline void PageInfo::_internal_set_redirect_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* PageInfo::_internal_mutable_redirect_url() {
  _has_bits_[0] |= 0x00000002u;
  return redirect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* PageInfo::release_redirect_url() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.PageInfo.redirect_url)
  if (!_internal_has_redirect_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = redirect_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redirect_url_.IsDefault()) {
    redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PageInfo::set_allocated_redirect_url(std::string* redirect_url) {
  if (redirect_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  redirect_url_.SetAllocated(redirect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (redirect_url_.IsDefault()) {
    redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.PageInfo.redirect_url)
}

// optional .offline_pages.proto.Status status = 3;
inline bool PageInfo::_internal_has_status() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || status_ != nullptr);
  return value;
}
inline bool PageInfo::has_status() const {
  return _internal_has_status();
}
inline const ::offline_pages::proto::Status& PageInfo::_internal_status() const {
  const ::offline_pages::proto::Status* p = status_;
  return p != nullptr ? *p : reinterpret_cast<const ::offline_pages::proto::Status&>(
      ::offline_pages::proto::_Status_default_instance_);
}
inline const ::offline_pages::proto::Status& PageInfo::status() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageInfo.status)
  return _internal_status();
}
inline void PageInfo::unsafe_arena_set_allocated_status(
    ::offline_pages::proto::Status* status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:offline_pages.proto.PageInfo.status)
}
inline ::offline_pages::proto::Status* PageInfo::release_status() {
  _has_bits_[0] &= ~0x00000004u;
  ::offline_pages::proto::Status* temp = status_;
  status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::offline_pages::proto::Status* PageInfo::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.PageInfo.status)
  _has_bits_[0] &= ~0x00000004u;
  ::offline_pages::proto::Status* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::offline_pages::proto::Status* PageInfo::_internal_mutable_status() {
  _has_bits_[0] |= 0x00000004u;
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::offline_pages::proto::Status>(GetArenaForAllocation());
    status_ = p;
  }
  return status_;
}
inline ::offline_pages::proto::Status* PageInfo::mutable_status() {
  ::offline_pages::proto::Status* _msg = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.PageInfo.status)
  return _msg;
}
inline void PageInfo::set_allocated_status(::offline_pages::proto::Status* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status));
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.PageInfo.status)
}

// optional .offline_pages.proto.Transformation transformation = 4;
inline bool PageInfo::_internal_has_transformation() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PageInfo::has_transformation() const {
  return _internal_has_transformation();
}
inline void PageInfo::clear_transformation() {
  transformation_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::offline_pages::proto::Transformation PageInfo::_internal_transformation() const {
  return static_cast< ::offline_pages::proto::Transformation >(transformation_);
}
inline ::offline_pages::proto::Transformation PageInfo::transformation() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageInfo.transformation)
  return _internal_transformation();
}
inline void PageInfo::_internal_set_transformation(::offline_pages::proto::Transformation value) {
  assert(::offline_pages::proto::Transformation_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  transformation_ = value;
}
inline void PageInfo::set_transformation(::offline_pages::proto::Transformation value) {
  _internal_set_transformation(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.PageInfo.transformation)
}

// optional .offline_pages.proto.Timestamp render_time = 5;
inline bool PageInfo::_internal_has_render_time() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || render_time_ != nullptr);
  return value;
}
inline bool PageInfo::has_render_time() const {
  return _internal_has_render_time();
}
inline void PageInfo::clear_render_time() {
  if (render_time_ != nullptr) render_time_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::offline_pages::proto::Timestamp& PageInfo::_internal_render_time() const {
  const ::offline_pages::proto::Timestamp* p = render_time_;
  return p != nullptr ? *p : reinterpret_cast<const ::offline_pages::proto::Timestamp&>(
      ::offline_pages::proto::_Timestamp_default_instance_);
}
inline const ::offline_pages::proto::Timestamp& PageInfo::render_time() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageInfo.render_time)
  return _internal_render_time();
}
inline void PageInfo::unsafe_arena_set_allocated_render_time(
    ::offline_pages::proto::Timestamp* render_time) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(render_time_);
  }
  render_time_ = render_time;
  if (render_time) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:offline_pages.proto.PageInfo.render_time)
}
inline ::offline_pages::proto::Timestamp* PageInfo::release_render_time() {
  _has_bits_[0] &= ~0x00000008u;
  ::offline_pages::proto::Timestamp* temp = render_time_;
  render_time_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::offline_pages::proto::Timestamp* PageInfo::unsafe_arena_release_render_time() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.PageInfo.render_time)
  _has_bits_[0] &= ~0x00000008u;
  ::offline_pages::proto::Timestamp* temp = render_time_;
  render_time_ = nullptr;
  return temp;
}
inline ::offline_pages::proto::Timestamp* PageInfo::_internal_mutable_render_time() {
  _has_bits_[0] |= 0x00000008u;
  if (render_time_ == nullptr) {
    auto* p = CreateMaybeMessage<::offline_pages::proto::Timestamp>(GetArenaForAllocation());
    render_time_ = p;
  }
  return render_time_;
}
inline ::offline_pages::proto::Timestamp* PageInfo::mutable_render_time() {
  ::offline_pages::proto::Timestamp* _msg = _internal_mutable_render_time();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.PageInfo.render_time)
  return _msg;
}
inline void PageInfo::set_allocated_render_time(::offline_pages::proto::Timestamp* render_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete render_time_;
  }
  if (render_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(render_time);
    if (message_arena != submessage_arena) {
      render_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, render_time, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  render_time_ = render_time;
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.PageInfo.render_time)
}

// -------------------------------------------------------------------

// GeneratePageBundleRequest

// optional string user_agent = 1;
inline bool GeneratePageBundleRequest::_internal_has_user_agent() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GeneratePageBundleRequest::has_user_agent() const {
  return _internal_has_user_agent();
}
inline void GeneratePageBundleRequest::clear_user_agent() {
  user_agent_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GeneratePageBundleRequest::user_agent() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.GeneratePageBundleRequest.user_agent)
  return _internal_user_agent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GeneratePageBundleRequest::set_user_agent(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 user_agent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:offline_pages.proto.GeneratePageBundleRequest.user_agent)
}
inline std::string* GeneratePageBundleRequest::mutable_user_agent() {
  std::string* _s = _internal_mutable_user_agent();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.GeneratePageBundleRequest.user_agent)
  return _s;
}
inline const std::string& GeneratePageBundleRequest::_internal_user_agent() const {
  return user_agent_.Get();
}
inline void GeneratePageBundleRequest::_internal_set_user_agent(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  user_agent_.Set(value, GetArenaForAllocation());
}
inline std::string* GeneratePageBundleRequest::_internal_mutable_user_agent() {
  _has_bits_[0] |= 0x00000001u;
  return user_agent_.Mutable(GetArenaForAllocation());
}
inline std::string* GeneratePageBundleRequest::release_user_agent() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.GeneratePageBundleRequest.user_agent)
  if (!_internal_has_user_agent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = user_agent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_agent_.IsDefault()) {
    user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GeneratePageBundleRequest::set_allocated_user_agent(std::string* user_agent) {
  if (user_agent != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  user_agent_.SetAllocated(user_agent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (user_agent_.IsDefault()) {
    user_agent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.GeneratePageBundleRequest.user_agent)
}

// repeated string browser_languages = 2;
inline int GeneratePageBundleRequest::_internal_browser_languages_size() const {
  return browser_languages_.size();
}
inline int GeneratePageBundleRequest::browser_languages_size() const {
  return _internal_browser_languages_size();
}
inline void GeneratePageBundleRequest::clear_browser_languages() {
  browser_languages_.Clear();
}
inline std::string* GeneratePageBundleRequest::add_browser_languages() {
  std::string* _s = _internal_add_browser_languages();
  // @@protoc_insertion_point(field_add_mutable:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
  return _s;
}
inline const std::string& GeneratePageBundleRequest::_internal_browser_languages(int index) const {
  return browser_languages_.Get(index);
}
inline const std::string& GeneratePageBundleRequest::browser_languages(int index) const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
  return _internal_browser_languages(index);
}
inline std::string* GeneratePageBundleRequest::mutable_browser_languages(int index) {
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
  return browser_languages_.Mutable(index);
}
inline void GeneratePageBundleRequest::set_browser_languages(int index, const std::string& value) {
  browser_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline void GeneratePageBundleRequest::set_browser_languages(int index, std::string&& value) {
  browser_languages_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline void GeneratePageBundleRequest::set_browser_languages(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  browser_languages_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline void GeneratePageBundleRequest::set_browser_languages(int index, const char* value, size_t size) {
  browser_languages_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline std::string* GeneratePageBundleRequest::_internal_add_browser_languages() {
  return browser_languages_.Add();
}
inline void GeneratePageBundleRequest::add_browser_languages(const std::string& value) {
  browser_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline void GeneratePageBundleRequest::add_browser_languages(std::string&& value) {
  browser_languages_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline void GeneratePageBundleRequest::add_browser_languages(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  browser_languages_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline void GeneratePageBundleRequest::add_browser_languages(const char* value, size_t size) {
  browser_languages_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GeneratePageBundleRequest::browser_languages() const {
  // @@protoc_insertion_point(field_list:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
  return browser_languages_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GeneratePageBundleRequest::mutable_browser_languages() {
  // @@protoc_insertion_point(field_mutable_list:offline_pages.proto.GeneratePageBundleRequest.browser_languages)
  return &browser_languages_;
}

// optional .offline_pages.proto.OutputFormat output_format = 3;
inline bool GeneratePageBundleRequest::_internal_has_output_format() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GeneratePageBundleRequest::has_output_format() const {
  return _internal_has_output_format();
}
inline void GeneratePageBundleRequest::clear_output_format() {
  output_format_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::offline_pages::proto::OutputFormat GeneratePageBundleRequest::_internal_output_format() const {
  return static_cast< ::offline_pages::proto::OutputFormat >(output_format_);
}
inline ::offline_pages::proto::OutputFormat GeneratePageBundleRequest::output_format() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.GeneratePageBundleRequest.output_format)
  return _internal_output_format();
}
inline void GeneratePageBundleRequest::_internal_set_output_format(::offline_pages::proto::OutputFormat value) {
  assert(::offline_pages::proto::OutputFormat_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  output_format_ = value;
}
inline void GeneratePageBundleRequest::set_output_format(::offline_pages::proto::OutputFormat value) {
  _internal_set_output_format(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.GeneratePageBundleRequest.output_format)
}

// optional int64 max_bundle_size_bytes = 4;
inline bool GeneratePageBundleRequest::_internal_has_max_bundle_size_bytes() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GeneratePageBundleRequest::has_max_bundle_size_bytes() const {
  return _internal_has_max_bundle_size_bytes();
}
inline void GeneratePageBundleRequest::clear_max_bundle_size_bytes() {
  max_bundle_size_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t GeneratePageBundleRequest::_internal_max_bundle_size_bytes() const {
  return max_bundle_size_bytes_;
}
inline int64_t GeneratePageBundleRequest::max_bundle_size_bytes() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.GeneratePageBundleRequest.max_bundle_size_bytes)
  return _internal_max_bundle_size_bytes();
}
inline void GeneratePageBundleRequest::_internal_set_max_bundle_size_bytes(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  max_bundle_size_bytes_ = value;
}
inline void GeneratePageBundleRequest::set_max_bundle_size_bytes(int64_t value) {
  _internal_set_max_bundle_size_bytes(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.GeneratePageBundleRequest.max_bundle_size_bytes)
}

// optional string gcm_registration_id = 5;
inline bool GeneratePageBundleRequest::_internal_has_gcm_registration_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GeneratePageBundleRequest::has_gcm_registration_id() const {
  return _internal_has_gcm_registration_id();
}
inline void GeneratePageBundleRequest::clear_gcm_registration_id() {
  gcm_registration_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GeneratePageBundleRequest::gcm_registration_id() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.GeneratePageBundleRequest.gcm_registration_id)
  return _internal_gcm_registration_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GeneratePageBundleRequest::set_gcm_registration_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 gcm_registration_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:offline_pages.proto.GeneratePageBundleRequest.gcm_registration_id)
}
inline std::string* GeneratePageBundleRequest::mutable_gcm_registration_id() {
  std::string* _s = _internal_mutable_gcm_registration_id();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.GeneratePageBundleRequest.gcm_registration_id)
  return _s;
}
inline const std::string& GeneratePageBundleRequest::_internal_gcm_registration_id() const {
  return gcm_registration_id_.Get();
}
inline void GeneratePageBundleRequest::_internal_set_gcm_registration_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  gcm_registration_id_.Set(value, GetArenaForAllocation());
}
inline std::string* GeneratePageBundleRequest::_internal_mutable_gcm_registration_id() {
  _has_bits_[0] |= 0x00000002u;
  return gcm_registration_id_.Mutable(GetArenaForAllocation());
}
inline std::string* GeneratePageBundleRequest::release_gcm_registration_id() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.GeneratePageBundleRequest.gcm_registration_id)
  if (!_internal_has_gcm_registration_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = gcm_registration_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gcm_registration_id_.IsDefault()) {
    gcm_registration_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GeneratePageBundleRequest::set_allocated_gcm_registration_id(std::string* gcm_registration_id) {
  if (gcm_registration_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  gcm_registration_id_.SetAllocated(gcm_registration_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gcm_registration_id_.IsDefault()) {
    gcm_registration_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.GeneratePageBundleRequest.gcm_registration_id)
}

// repeated .offline_pages.proto.PageParameters pages = 6;
inline int GeneratePageBundleRequest::_internal_pages_size() const {
  return pages_.size();
}
inline int GeneratePageBundleRequest::pages_size() const {
  return _internal_pages_size();
}
inline void GeneratePageBundleRequest::clear_pages() {
  pages_.Clear();
}
inline ::offline_pages::proto::PageParameters* GeneratePageBundleRequest::mutable_pages(int index) {
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.GeneratePageBundleRequest.pages)
  return pages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageParameters >*
GeneratePageBundleRequest::mutable_pages() {
  // @@protoc_insertion_point(field_mutable_list:offline_pages.proto.GeneratePageBundleRequest.pages)
  return &pages_;
}
inline const ::offline_pages::proto::PageParameters& GeneratePageBundleRequest::_internal_pages(int index) const {
  return pages_.Get(index);
}
inline const ::offline_pages::proto::PageParameters& GeneratePageBundleRequest::pages(int index) const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.GeneratePageBundleRequest.pages)
  return _internal_pages(index);
}
inline ::offline_pages::proto::PageParameters* GeneratePageBundleRequest::_internal_add_pages() {
  return pages_.Add();
}
inline ::offline_pages::proto::PageParameters* GeneratePageBundleRequest::add_pages() {
  ::offline_pages::proto::PageParameters* _add = _internal_add_pages();
  // @@protoc_insertion_point(field_add:offline_pages.proto.GeneratePageBundleRequest.pages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::offline_pages::proto::PageParameters >&
GeneratePageBundleRequest::pages() const {
  // @@protoc_insertion_point(field_list:offline_pages.proto.GeneratePageBundleRequest.pages)
  return pages_;
}

// -------------------------------------------------------------------

// PageParameters

// optional string url = 1;
inline bool PageParameters::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PageParameters::has_url() const {
  return _internal_has_url();
}
inline void PageParameters::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PageParameters::url() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageParameters.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PageParameters::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:offline_pages.proto.PageParameters.url)
}
inline std::string* PageParameters::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:offline_pages.proto.PageParameters.url)
  return _s;
}
inline const std::string& PageParameters::_internal_url() const {
  return url_.Get();
}
inline void PageParameters::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* PageParameters::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* PageParameters::release_url() {
  // @@protoc_insertion_point(field_release:offline_pages.proto.PageParameters.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PageParameters::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:offline_pages.proto.PageParameters.url)
}

// optional .offline_pages.proto.Transformation transformation = 2;
inline bool PageParameters::_internal_has_transformation() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PageParameters::has_transformation() const {
  return _internal_has_transformation();
}
inline void PageParameters::clear_transformation() {
  transformation_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::offline_pages::proto::Transformation PageParameters::_internal_transformation() const {
  return static_cast< ::offline_pages::proto::Transformation >(transformation_);
}
inline ::offline_pages::proto::Transformation PageParameters::transformation() const {
  // @@protoc_insertion_point(field_get:offline_pages.proto.PageParameters.transformation)
  return _internal_transformation();
}
inline void PageParameters::_internal_set_transformation(::offline_pages::proto::Transformation value) {
  assert(::offline_pages::proto::Transformation_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  transformation_ = value;
}
inline void PageParameters::set_transformation(::offline_pages::proto::Transformation value) {
  _internal_set_transformation(value);
  // @@protoc_insertion_point(field_set:offline_pages.proto.PageParameters.transformation)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace offline_pages

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::offline_pages::proto::Transformation> : ::std::true_type {};
template <> struct is_proto_enum< ::offline_pages::proto::OutputFormat> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_offline_5fpages_2eproto
