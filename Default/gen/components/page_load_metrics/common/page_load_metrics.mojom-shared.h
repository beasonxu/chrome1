// components/page_load_metrics/common/page_load_metrics.mojom-shared.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2016 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_
#define COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_

#include <stdint.h>

#include <functional>
#include <iosfwd>
#include <type_traits>
#include <utility>
#include "mojo/public/cpp/bindings/array_data_view.h"
#include "mojo/public/cpp/bindings/enum_traits.h"
#include "mojo/public/cpp/bindings/interface_data_view.h"
#include "mojo/public/cpp/bindings/lib/bindings_internal.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/map_data_view.h"
#include "mojo/public/cpp/bindings/string_data_view.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/page_load_metrics/common/page_load_metrics.mojom-shared-internal.h"
#include "ui/gfx/geometry/mojom/geometry.mojom-shared.h"
#include "mojo/public/mojom/base/shared_memory.mojom-shared.h"
#include "mojo/public/mojom/base/time.mojom-shared.h"
#include "third_party/blink/public/mojom/use_counter/metrics/web_feature.mojom-shared.h"
#include "third_party/blink/public/mojom/mobile_metrics/mobile_friendliness.mojom-shared.h"
#include "third_party/blink/public/mojom/use_counter/use_counter_feature.mojom-shared.h"
#include "mojo/public/cpp/bindings/lib/interface_serialization.h"






namespace page_load_metrics {
namespace mojom {
class DocumentTimingDataView;

class LargestContentfulPaintTimingDataView;

class PaintTimingDataView;

class ParseTimingDataView;

class InteractiveTimingDataView;

class PageLoadTimingDataView;

class FrameMetadataDataView;

class ResourceDataUpdateDataView;

class LayoutShiftDataView;

class FrameRenderDataUpdateDataView;

class CpuTimingDataView;

class InputTimingDataView;

class UserInteractionLatencyDataView;

class BackForwardCacheTimingDataView;

class UserInteractionLatenciesDataView;


}  // namespace mojom
}  // namespace page_load_metrics

namespace mojo {
namespace internal {

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::DocumentTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::DocumentTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::PaintTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::PaintTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::ParseTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::ParseTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::InteractiveTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::InteractiveTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::PageLoadTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::PageLoadTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::FrameMetadataDataView> {
  using Data = ::page_load_metrics::mojom::internal::FrameMetadata_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::ResourceDataUpdateDataView> {
  using Data = ::page_load_metrics::mojom::internal::ResourceDataUpdate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::LayoutShiftDataView> {
  using Data = ::page_load_metrics::mojom::internal::LayoutShift_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::FrameRenderDataUpdateDataView> {
  using Data = ::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::CpuTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::CpuTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::InputTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::InputTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::UserInteractionLatencyDataView> {
  using Data = ::page_load_metrics::mojom::internal::UserInteractionLatency_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::BackForwardCacheTimingDataView> {
  using Data = ::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data;
  using DataAsArrayElement = Pointer<Data>;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kStruct;
};

template <>
struct MojomTypeTraits<::page_load_metrics::mojom::UserInteractionLatenciesDataView> {
  using Data = ::page_load_metrics::mojom::internal::UserInteractionLatencies_Data;
  using DataAsArrayElement = Data;
  static constexpr MojomTypeCategory category = MojomTypeCategory::kUnion;
};

}  // namespace internal
}  // namespace mojo


namespace page_load_metrics {
namespace mojom {


enum class CacheType : int32_t {
  
  kNotCached = 0,
  
  kHttp = 1,
  
  kMemory = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, CacheType value);
inline bool IsKnownEnumValue(CacheType value) {
  return internal::CacheType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}


enum class UserInteractionType : int32_t {
  
  kKeyboard = 0,
  
  kTapOrClick = 1,
  
  kDrag = 2,
  kMinValue = 0,
  kMaxValue = 2,
};

 std::ostream& operator<<(std::ostream& os, UserInteractionType value);
inline bool IsKnownEnumValue(UserInteractionType value) {
  return internal::UserInteractionType_Data::IsKnownValue(
      static_cast<int32_t>(value));
}
// Interface base classes. They are used for type safety check.
class PageLoadMetricsInterfaceBase {};

using PageLoadMetricsPtrDataView =
    mojo::InterfacePtrDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsRequestDataView =
    mojo::InterfaceRequestDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsAssociatedPtrInfoDataView =
    mojo::AssociatedInterfacePtrInfoDataView<PageLoadMetricsInterfaceBase>;
using PageLoadMetricsAssociatedRequestDataView =
    mojo::AssociatedInterfaceRequestDataView<PageLoadMetricsInterfaceBase>;


class DocumentTimingDataView {
 public:
  DocumentTimingDataView() = default;

  DocumentTimingDataView(
      internal::DocumentTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetDomContentLoadedEventStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDomContentLoadedEventStart(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `dom_content_loaded_event_start` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadDomContentLoadedEventStart` instead "
    "of `ReadDomContentLoadedEventStart if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->dom_content_loaded_event_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetLoadEventStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLoadEventStart(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `load_event_start` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLoadEventStart` instead "
    "of `ReadLoadEventStart if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->load_event_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::DocumentTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class LargestContentfulPaintTimingDataView {
 public:
  LargestContentfulPaintTimingDataView() = default;

  LargestContentfulPaintTimingDataView(
      internal::LargestContentfulPaintTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetLargestImagePaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLargestImagePaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `largest_image_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLargestImagePaint` instead "
    "of `ReadLargestImagePaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->largest_image_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  uint64_t largest_image_paint_size() const {
    return data_->largest_image_paint_size;
  }
  inline void GetLargestTextPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLargestTextPaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `largest_text_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLargestTextPaint` instead "
    "of `ReadLargestTextPaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->largest_text_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  uint64_t largest_text_paint_size() const {
    return data_->largest_text_paint_size;
  }
  uint64_t type() const {
    return data_->type;
  }
  double image_bpp() const {
    return data_->image_bpp;
  }
 private:
  internal::LargestContentfulPaintTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PaintTimingDataView {
 public:
  PaintTimingDataView() = default;

  PaintTimingDataView(
      internal::PaintTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFirstPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstPaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstPaint` instead "
    "of `ReadFirstPaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstImagePaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstImagePaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_image_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstImagePaint` instead "
    "of `ReadFirstImagePaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_image_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstContentfulPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstContentfulPaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_contentful_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstContentfulPaint` instead "
    "of `ReadFirstContentfulPaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_contentful_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstMeaningfulPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstMeaningfulPaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_meaningful_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstMeaningfulPaint` instead "
    "of `ReadFirstMeaningfulPaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_meaningful_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetLargestContentfulPaintDataView(
      LargestContentfulPaintTimingDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLargestContentfulPaint(UserType* output) {
    
    auto* pointer = data_->largest_contentful_paint.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        pointer, output, message_);
  }
  inline void GetExperimentalLargestContentfulPaintDataView(
      LargestContentfulPaintTimingDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadExperimentalLargestContentfulPaint(UserType* output) {
    
    auto* pointer = data_->experimental_largest_contentful_paint.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        pointer, output, message_);
  }
  inline void GetFirstEligibleToPaintDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstEligibleToPaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_eligible_to_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstEligibleToPaint` instead "
    "of `ReadFirstEligibleToPaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_eligible_to_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstInputOrScrollNotifiedTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstInputOrScrollNotifiedTimestamp(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_input_or_scroll_notified_timestamp` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstInputOrScrollNotifiedTimestamp` instead "
    "of `ReadFirstInputOrScrollNotifiedTimestamp if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_input_or_scroll_notified_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetPortalActivatedPaintDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPortalActivatedPaint(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeTicksDataView, UserType>(),
    "Attempting to read the optional `portal_activated_paint` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadPortalActivatedPaint` instead "
    "of `ReadPortalActivatedPaint if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->portal_activated_paint.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
 private:
  internal::PaintTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ParseTimingDataView {
 public:
  ParseTimingDataView() = default;

  ParseTimingDataView(
      internal::ParseTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetParseStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseStart(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `parse_start` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParseStart` instead "
    "of `ReadParseStart if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parse_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetParseStopDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseStop(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `parse_stop` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParseStop` instead "
    "of `ReadParseStop if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parse_stop.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetParseBlockedOnScriptLoadDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseBlockedOnScriptLoadDuration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `parse_blocked_on_script_load_duration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParseBlockedOnScriptLoadDuration` instead "
    "of `ReadParseBlockedOnScriptLoadDuration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parse_blocked_on_script_load_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetParseBlockedOnScriptLoadFromDocumentWriteDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseBlockedOnScriptLoadFromDocumentWriteDuration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `parse_blocked_on_script_load_from_document_write_duration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParseBlockedOnScriptLoadFromDocumentWriteDuration` instead "
    "of `ReadParseBlockedOnScriptLoadFromDocumentWriteDuration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parse_blocked_on_script_load_from_document_write_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetParseBlockedOnScriptExecutionDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseBlockedOnScriptExecutionDuration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `parse_blocked_on_script_execution_duration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParseBlockedOnScriptExecutionDuration` instead "
    "of `ReadParseBlockedOnScriptExecutionDuration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parse_blocked_on_script_execution_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetParseBlockedOnScriptExecutionFromDocumentWriteDurationDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseBlockedOnScriptExecutionFromDocumentWriteDuration(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `parse_blocked_on_script_execution_from_document_write_duration` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadParseBlockedOnScriptExecutionFromDocumentWriteDuration` instead "
    "of `ReadParseBlockedOnScriptExecutionFromDocumentWriteDuration if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->parse_blocked_on_script_execution_from_document_write_duration.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::ParseTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class InteractiveTimingDataView {
 public:
  InteractiveTimingDataView() = default;

  InteractiveTimingDataView(
      internal::InteractiveTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFirstInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstInputDelay(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_input_delay` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstInputDelay` instead "
    "of `ReadFirstInputDelay if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstInputTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstInputTimestamp(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_input_timestamp` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstInputTimestamp` instead "
    "of `ReadFirstInputTimestamp if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_input_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetLongestInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLongestInputDelay(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `longest_input_delay` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLongestInputDelay` instead "
    "of `ReadLongestInputDelay if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->longest_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetLongestInputTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLongestInputTimestamp(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `longest_input_timestamp` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadLongestInputTimestamp` instead "
    "of `ReadLongestInputTimestamp if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->longest_input_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstScrollDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstScrollDelay(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_scroll_delay` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstScrollDelay` instead "
    "of `ReadFirstScrollDelay if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_scroll_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstScrollTimestampDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstScrollTimestamp(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_scroll_timestamp` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstScrollTimestamp` instead "
    "of `ReadFirstScrollTimestamp if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_scroll_timestamp.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetFirstInputProcessingTimeDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstInputProcessingTime(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_input_processing_time` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstInputProcessingTime` instead "
    "of `ReadFirstInputProcessingTime if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_input_processing_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::InteractiveTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class PageLoadTimingDataView {
 public:
  PageLoadTimingDataView() = default;

  PageLoadTimingDataView(
      internal::PageLoadTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetNavigationStartDataView(
      ::mojo_base::mojom::TimeDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNavigationStart(UserType* output) {
    
    auto* pointer = data_->navigation_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDataView>(
        pointer, output, message_);
  }
  inline void GetResponseStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadResponseStart(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `response_start` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadResponseStart` instead "
    "of `ReadResponseStart if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->response_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetDocumentTimingDataView(
      DocumentTimingDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadDocumentTiming(UserType* output) {
    
    auto* pointer = data_->document_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::DocumentTimingDataView>(
        pointer, output, message_);
  }
  inline void GetInteractiveTimingDataView(
      InteractiveTimingDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInteractiveTiming(UserType* output) {
    
    auto* pointer = data_->interactive_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::InteractiveTimingDataView>(
        pointer, output, message_);
  }
  inline void GetPaintTimingDataView(
      PaintTimingDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadPaintTiming(UserType* output) {
    
    auto* pointer = data_->paint_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::PaintTimingDataView>(
        pointer, output, message_);
  }
  inline void GetParseTimingDataView(
      ParseTimingDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadParseTiming(UserType* output) {
    
    auto* pointer = data_->parse_timing.Get();
    return mojo::internal::Deserialize<::page_load_metrics::mojom::ParseTimingDataView>(
        pointer, output, message_);
  }
  inline void GetBackForwardCacheTimingsDataView(
      mojo::ArrayDataView<BackForwardCacheTimingDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadBackForwardCacheTimings(UserType* output) {
    
    auto* pointer = data_->back_forward_cache_timings.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::BackForwardCacheTimingDataView>>(
        pointer, output, message_);
  }
  inline void GetActivationStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadActivationStart(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `activation_start` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadActivationStart` instead "
    "of `ReadActivationStart if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->activation_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetInputToNavigationStartDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInputToNavigationStart(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `input_to_navigation_start` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadInputToNavigationStart` instead "
    "of `ReadInputToNavigationStart if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->input_to_navigation_start.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetUserTimingMarkFullyLoadedDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUserTimingMarkFullyLoaded(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `user_timing_mark_fully_loaded` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUserTimingMarkFullyLoaded` instead "
    "of `ReadUserTimingMarkFullyLoaded if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->user_timing_mark_fully_loaded.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetUserTimingMarkFullyVisibleDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUserTimingMarkFullyVisible(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `user_timing_mark_fully_visible` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUserTimingMarkFullyVisible` instead "
    "of `ReadUserTimingMarkFullyVisible if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->user_timing_mark_fully_visible.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetUserTimingMarkInteractiveDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadUserTimingMarkInteractive(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `user_timing_mark_interactive` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadUserTimingMarkInteractive` instead "
    "of `ReadUserTimingMarkInteractive if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->user_timing_mark_interactive.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::PageLoadTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FrameMetadataDataView {
 public:
  FrameMetadataDataView() = default;

  FrameMetadataDataView(
      internal::FrameMetadata_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t behavior_flags() const {
    return data_->behavior_flags;
  }
  inline void GetMainFrameIntersectionRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMainFrameIntersectionRect(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::RectDataView, UserType>(),
    "Attempting to read the optional `main_frame_intersection_rect` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMainFrameIntersectionRect` instead "
    "of `ReadMainFrameIntersectionRect if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->main_frame_intersection_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
  inline void GetMainFrameViewportRectDataView(
      ::gfx::mojom::RectDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMainFrameViewportRect(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::gfx::mojom::RectDataView, UserType>(),
    "Attempting to read the optional `main_frame_viewport_rect` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadMainFrameViewportRect` instead "
    "of `ReadMainFrameViewportRect if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->main_frame_viewport_rect.Get();
    return mojo::internal::Deserialize<::gfx::mojom::RectDataView>(
        pointer, output, message_);
  }
 private:
  internal::FrameMetadata_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class ResourceDataUpdateDataView {
 public:
  ResourceDataUpdateDataView() = default;

  ResourceDataUpdateDataView(
      internal::ResourceDataUpdate_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  int32_t request_id() const {
    return data_->request_id;
  }
  int64_t delta_bytes() const {
    return data_->delta_bytes;
  }
  int64_t received_data_length() const {
    return data_->received_data_length;
  }
  int64_t encoded_body_length() const {
    return data_->encoded_body_length;
  }
  int64_t decoded_body_length() const {
    return data_->decoded_body_length;
  }
  bool is_complete() const {
    return data_->is_complete;
  }
  bool reported_as_ad_resource() const {
    return data_->reported_as_ad_resource;
  }
  bool is_main_frame_resource() const {
    return data_->is_main_frame_resource;
  }
  template <typename UserType>
  [[nodiscard]] bool ReadCacheType(UserType* output) const {
    auto data_value = data_->cache_type;
    return mojo::internal::Deserialize<::page_load_metrics::mojom::CacheType>(
        data_value, output);
  }
  CacheType cache_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::page_load_metrics::mojom::CacheType>(data_->cache_type));
  }
  bool is_primary_frame_resource() const {
    return data_->is_primary_frame_resource;
  }
  inline void GetMimeTypeDataView(
      mojo::StringDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMimeType(UserType* output) {
    
    auto* pointer = data_->mime_type.Get();
    return mojo::internal::Deserialize<mojo::StringDataView>(
        pointer, output, message_);
  }
  bool is_secure_scheme() const {
    return data_->is_secure_scheme;
  }
  bool proxy_used() const {
    return data_->proxy_used;
  }
  bool completed_before_fcp() const {
    return data_->completed_before_fcp;
  }
 private:
  internal::ResourceDataUpdate_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class LayoutShiftDataView {
 public:
  LayoutShiftDataView() = default;

  LayoutShiftDataView(
      internal::LayoutShift_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetLayoutShiftTimeDataView(
      ::mojo_base::mojom::TimeTicksDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadLayoutShiftTime(UserType* output) {
    
    auto* pointer = data_->layout_shift_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeTicksDataView>(
        pointer, output, message_);
  }
  double layout_shift_score() const {
    return data_->layout_shift_score;
  }
 private:
  internal::LayoutShift_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class FrameRenderDataUpdateDataView {
 public:
  FrameRenderDataUpdateDataView() = default;

  FrameRenderDataUpdateDataView(
      internal::FrameRenderDataUpdate_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  float layout_shift_delta() const {
    return data_->layout_shift_delta;
  }
  float layout_shift_delta_before_input_or_scroll() const {
    return data_->layout_shift_delta_before_input_or_scroll;
  }
  uint32_t all_layout_block_count_delta() const {
    return data_->all_layout_block_count_delta;
  }
  uint32_t ng_layout_block_count_delta() const {
    return data_->ng_layout_block_count_delta;
  }
  uint32_t all_layout_call_count_delta() const {
    return data_->all_layout_call_count_delta;
  }
  uint32_t ng_layout_call_count_delta() const {
    return data_->ng_layout_call_count_delta;
  }
  inline void GetNewLayoutShiftsDataView(
      mojo::ArrayDataView<LayoutShiftDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadNewLayoutShifts(UserType* output) {
    
    auto* pointer = data_->new_layout_shifts.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::LayoutShiftDataView>>(
        pointer, output, message_);
  }
 private:
  internal::FrameRenderDataUpdate_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class CpuTimingDataView {
 public:
  CpuTimingDataView() = default;

  CpuTimingDataView(
      internal::CpuTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetTaskTimeDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTaskTime(UserType* output) {
    
    auto* pointer = data_->task_time.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::CpuTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class InputTimingDataView {
 public:
  InputTimingDataView() = default;

  InputTimingDataView(
      internal::InputTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetTotalInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTotalInputDelay(UserType* output) {
    
    auto* pointer = data_->total_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetTotalAdjustedInputDelayDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadTotalAdjustedInputDelay(UserType* output) {
    
    auto* pointer = data_->total_adjusted_input_delay.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  uint64_t num_input_events() const {
    return data_->num_input_events;
  }
  uint64_t num_interactions() const {
    return data_->num_interactions;
  }
  inline void GetMaxEventDurationsDataView(
      UserInteractionLatenciesDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadMaxEventDurations(UserType* output) {
    
    auto* pointer = !data_->max_event_durations.is_null() ? &data_->max_event_durations : nullptr;
    return mojo::internal::Deserialize<::page_load_metrics::mojom::UserInteractionLatenciesDataView>(
        pointer, output, message_);
  }
 private:
  internal::InputTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class UserInteractionLatencyDataView {
 public:
  UserInteractionLatencyDataView() = default;

  UserInteractionLatencyDataView(
      internal::UserInteractionLatency_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetInteractionLatencyDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadInteractionLatency(UserType* output) {
    
    auto* pointer = data_->interaction_latency.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  template <typename UserType>
  [[nodiscard]] bool ReadInteractionType(UserType* output) const {
    auto data_value = data_->interaction_type;
    return mojo::internal::Deserialize<::page_load_metrics::mojom::UserInteractionType>(
        data_value, output);
  }
  UserInteractionType interaction_type() const {
    return ::mojo::internal::ToKnownEnumValueHelper(
          static_cast<::page_load_metrics::mojom::UserInteractionType>(data_->interaction_type));
  }
 private:
  internal::UserInteractionLatency_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class BackForwardCacheTimingDataView {
 public:
  BackForwardCacheTimingDataView() = default;

  BackForwardCacheTimingDataView(
      internal::BackForwardCacheTiming_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const { return !data_; }
  inline void GetFirstPaintAfterBackForwardCacheRestoreDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstPaintAfterBackForwardCacheRestore(UserType* output) {
    
    auto* pointer = data_->first_paint_after_back_forward_cache_restore.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
  inline void GetRequestAnimationFramesAfterBackForwardCacheRestoreDataView(
      mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>* output);

  template <typename UserType>
  [[nodiscard]] bool ReadRequestAnimationFramesAfterBackForwardCacheRestore(UserType* output) {
    
    auto* pointer = data_->request_animation_frames_after_back_forward_cache_restore.Get();
    return mojo::internal::Deserialize<mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>>(
        pointer, output, message_);
  }
  inline void GetFirstInputDelayAfterBackForwardCacheRestoreDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output);

  template <typename UserType>
  [[nodiscard]] bool ReadFirstInputDelayAfterBackForwardCacheRestore(UserType* output) {
    
static_assert(
    mojo::internal::IsValidUserTypeForOptionalValue<
        ::mojo_base::mojom::TimeDeltaDataView, UserType>(),
    "Attempting to read the optional `first_input_delay_after_back_forward_cache_restore` field into a type which "
    "cannot represent a null value. Either wrap the destination object "
    "with absl::optional, ensure that any corresponding "
    "{Struct/Union/Array/String}Traits define the necessary IsNull and "
    "SetToNull methods, or use `MaybeReadFirstInputDelayAfterBackForwardCacheRestore` instead "
    "of `ReadFirstInputDelayAfterBackForwardCacheRestore if you're fine with null values being "
    "silently ignored in this case.");
    auto* pointer = data_->first_input_delay_after_back_forward_cache_restore.Get();
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        pointer, output, message_);
  }
 private:
  internal::BackForwardCacheTiming_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



class UserInteractionLatenciesDataView {
 public:
  using Tag = internal::UserInteractionLatencies_Data::UserInteractionLatencies_Tag;

  UserInteractionLatenciesDataView() = default;

  UserInteractionLatenciesDataView(
      internal::UserInteractionLatencies_Data* data,
      mojo::Message* message)
      : data_(data), message_(message) {}

  bool is_null() const {
    // For inlined unions, |data_| is always non-null. In that case we need to
    // check |data_->is_null()|.
    return !data_ || data_->is_null();
  }

  Tag tag() const { return data_->tag; }
  bool is_user_interaction_latencies() const { return data_->tag == Tag::kUserInteractionLatencies; }
  inline void GetUserInteractionLatenciesDataView(
      mojo::ArrayDataView<UserInteractionLatencyDataView>* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadUserInteractionLatencies(UserType* output) const {
    
    CHECK(is_user_interaction_latencies());
    return mojo::internal::Deserialize<mojo::ArrayDataView<::page_load_metrics::mojom::UserInteractionLatencyDataView>>(
        data_->data.f_user_interaction_latencies.Get(), output, message_);
  }
  bool is_worst_interaction_latency() const { return data_->tag == Tag::kWorstInteractionLatency; }
  inline void GetWorstInteractionLatencyDataView(
      ::mojo_base::mojom::TimeDeltaDataView* output) const;

  template <typename UserType>
  [[nodiscard]] bool ReadWorstInteractionLatency(UserType* output) const {
    
    CHECK(is_worst_interaction_latency());
    return mojo::internal::Deserialize<::mojo_base::mojom::TimeDeltaDataView>(
        data_->data.f_worst_interaction_latency.Get(), output, message_);
  }

 private:
  internal::UserInteractionLatencies_Data* data_ = nullptr;
  mojo::Message* message_ = nullptr;
};



}  // namespace mojom
}  // namespace page_load_metrics

namespace std {

template <>
struct hash<::page_load_metrics::mojom::CacheType>
    : public mojo::internal::EnumHashImpl<::page_load_metrics::mojom::CacheType> {};

template <>
struct hash<::page_load_metrics::mojom::UserInteractionType>
    : public mojo::internal::EnumHashImpl<::page_load_metrics::mojom::UserInteractionType> {};

}  // namespace std

namespace mojo {


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::CacheType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::page_load_metrics::mojom::CacheType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::page_load_metrics::mojom::CacheType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::UserInteractionType, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = EnumTraits<::page_load_metrics::mojom::UserInteractionType, UserType>;

  static void Serialize(UserType input, int32_t* output) {
    *output = static_cast<int32_t>(Traits::ToMojom(input));
  }

  static bool Deserialize(int32_t input, UserType* output) {
    return Traits::FromMojom(::mojo::internal::ToKnownEnumValueHelper(
        static_cast<::page_load_metrics::mojom::UserInteractionType>(input)), output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::DocumentTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::DocumentTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::DocumentTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::dom_content_loaded_event_start(input)) in_dom_content_loaded_event_start = Traits::dom_content_loaded_event_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->dom_content_loaded_event_start)::BaseType> dom_content_loaded_event_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_dom_content_loaded_event_start, dom_content_loaded_event_start_fragment);
    fragment->dom_content_loaded_event_start.Set(
        dom_content_loaded_event_start_fragment.is_null() ? nullptr : dom_content_loaded_event_start_fragment.data());
    decltype(Traits::load_event_start(input)) in_load_event_start = Traits::load_event_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->load_event_start)::BaseType> load_event_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_load_event_start, load_event_start_fragment);
    fragment->load_event_start.Set(
        load_event_start_fragment.is_null() ? nullptr : load_event_start_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::DocumentTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::DocumentTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::largest_image_paint(input)) in_largest_image_paint = Traits::largest_image_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->largest_image_paint)::BaseType> largest_image_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_largest_image_paint, largest_image_paint_fragment);
    fragment->largest_image_paint.Set(
        largest_image_paint_fragment.is_null() ? nullptr : largest_image_paint_fragment.data());
    fragment->largest_image_paint_size = Traits::largest_image_paint_size(input);
    decltype(Traits::largest_text_paint(input)) in_largest_text_paint = Traits::largest_text_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->largest_text_paint)::BaseType> largest_text_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_largest_text_paint, largest_text_paint_fragment);
    fragment->largest_text_paint.Set(
        largest_text_paint_fragment.is_null() ? nullptr : largest_text_paint_fragment.data());
    fragment->largest_text_paint_size = Traits::largest_text_paint_size(input);
    fragment->type = Traits::type(input);
    fragment->image_bpp = Traits::image_bpp(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::LargestContentfulPaintTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::LargestContentfulPaintTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::PaintTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::PaintTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::PaintTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::first_paint(input)) in_first_paint = Traits::first_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_paint)::BaseType> first_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_paint, first_paint_fragment);
    fragment->first_paint.Set(
        first_paint_fragment.is_null() ? nullptr : first_paint_fragment.data());
    decltype(Traits::first_image_paint(input)) in_first_image_paint = Traits::first_image_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_image_paint)::BaseType> first_image_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_image_paint, first_image_paint_fragment);
    fragment->first_image_paint.Set(
        first_image_paint_fragment.is_null() ? nullptr : first_image_paint_fragment.data());
    decltype(Traits::first_contentful_paint(input)) in_first_contentful_paint = Traits::first_contentful_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_contentful_paint)::BaseType> first_contentful_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_contentful_paint, first_contentful_paint_fragment);
    fragment->first_contentful_paint.Set(
        first_contentful_paint_fragment.is_null() ? nullptr : first_contentful_paint_fragment.data());
    decltype(Traits::first_meaningful_paint(input)) in_first_meaningful_paint = Traits::first_meaningful_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_meaningful_paint)::BaseType> first_meaningful_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_meaningful_paint, first_meaningful_paint_fragment);
    fragment->first_meaningful_paint.Set(
        first_meaningful_paint_fragment.is_null() ? nullptr : first_meaningful_paint_fragment.data());
    decltype(Traits::largest_contentful_paint(input)) in_largest_contentful_paint = Traits::largest_contentful_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->largest_contentful_paint)::BaseType> largest_contentful_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        in_largest_contentful_paint, largest_contentful_paint_fragment);
    fragment->largest_contentful_paint.Set(
        largest_contentful_paint_fragment.is_null() ? nullptr : largest_contentful_paint_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->largest_contentful_paint.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null largest_contentful_paint in PaintTiming struct");
    decltype(Traits::experimental_largest_contentful_paint(input)) in_experimental_largest_contentful_paint = Traits::experimental_largest_contentful_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->experimental_largest_contentful_paint)::BaseType> experimental_largest_contentful_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::page_load_metrics::mojom::LargestContentfulPaintTimingDataView>(
        in_experimental_largest_contentful_paint, experimental_largest_contentful_paint_fragment);
    fragment->experimental_largest_contentful_paint.Set(
        experimental_largest_contentful_paint_fragment.is_null() ? nullptr : experimental_largest_contentful_paint_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->experimental_largest_contentful_paint.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null experimental_largest_contentful_paint in PaintTiming struct");
    decltype(Traits::first_eligible_to_paint(input)) in_first_eligible_to_paint = Traits::first_eligible_to_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_eligible_to_paint)::BaseType> first_eligible_to_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_eligible_to_paint, first_eligible_to_paint_fragment);
    fragment->first_eligible_to_paint.Set(
        first_eligible_to_paint_fragment.is_null() ? nullptr : first_eligible_to_paint_fragment.data());
    decltype(Traits::first_input_or_scroll_notified_timestamp(input)) in_first_input_or_scroll_notified_timestamp = Traits::first_input_or_scroll_notified_timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_input_or_scroll_notified_timestamp)::BaseType> first_input_or_scroll_notified_timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_or_scroll_notified_timestamp, first_input_or_scroll_notified_timestamp_fragment);
    fragment->first_input_or_scroll_notified_timestamp.Set(
        first_input_or_scroll_notified_timestamp_fragment.is_null() ? nullptr : first_input_or_scroll_notified_timestamp_fragment.data());
    decltype(Traits::portal_activated_paint(input)) in_portal_activated_paint = Traits::portal_activated_paint(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->portal_activated_paint)::BaseType> portal_activated_paint_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_portal_activated_paint, portal_activated_paint_fragment);
    fragment->portal_activated_paint.Set(
        portal_activated_paint_fragment.is_null() ? nullptr : portal_activated_paint_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::PaintTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::PaintTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::ParseTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::ParseTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::ParseTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::parse_start(input)) in_parse_start = Traits::parse_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_start)::BaseType> parse_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_start, parse_start_fragment);
    fragment->parse_start.Set(
        parse_start_fragment.is_null() ? nullptr : parse_start_fragment.data());
    decltype(Traits::parse_stop(input)) in_parse_stop = Traits::parse_stop(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_stop)::BaseType> parse_stop_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_stop, parse_stop_fragment);
    fragment->parse_stop.Set(
        parse_stop_fragment.is_null() ? nullptr : parse_stop_fragment.data());
    decltype(Traits::parse_blocked_on_script_load_duration(input)) in_parse_blocked_on_script_load_duration = Traits::parse_blocked_on_script_load_duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_blocked_on_script_load_duration)::BaseType> parse_blocked_on_script_load_duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_load_duration, parse_blocked_on_script_load_duration_fragment);
    fragment->parse_blocked_on_script_load_duration.Set(
        parse_blocked_on_script_load_duration_fragment.is_null() ? nullptr : parse_blocked_on_script_load_duration_fragment.data());
    decltype(Traits::parse_blocked_on_script_load_from_document_write_duration(input)) in_parse_blocked_on_script_load_from_document_write_duration = Traits::parse_blocked_on_script_load_from_document_write_duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_blocked_on_script_load_from_document_write_duration)::BaseType> parse_blocked_on_script_load_from_document_write_duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_load_from_document_write_duration, parse_blocked_on_script_load_from_document_write_duration_fragment);
    fragment->parse_blocked_on_script_load_from_document_write_duration.Set(
        parse_blocked_on_script_load_from_document_write_duration_fragment.is_null() ? nullptr : parse_blocked_on_script_load_from_document_write_duration_fragment.data());
    decltype(Traits::parse_blocked_on_script_execution_duration(input)) in_parse_blocked_on_script_execution_duration = Traits::parse_blocked_on_script_execution_duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_blocked_on_script_execution_duration)::BaseType> parse_blocked_on_script_execution_duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_execution_duration, parse_blocked_on_script_execution_duration_fragment);
    fragment->parse_blocked_on_script_execution_duration.Set(
        parse_blocked_on_script_execution_duration_fragment.is_null() ? nullptr : parse_blocked_on_script_execution_duration_fragment.data());
    decltype(Traits::parse_blocked_on_script_execution_from_document_write_duration(input)) in_parse_blocked_on_script_execution_from_document_write_duration = Traits::parse_blocked_on_script_execution_from_document_write_duration(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_blocked_on_script_execution_from_document_write_duration)::BaseType> parse_blocked_on_script_execution_from_document_write_duration_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_parse_blocked_on_script_execution_from_document_write_duration, parse_blocked_on_script_execution_from_document_write_duration_fragment);
    fragment->parse_blocked_on_script_execution_from_document_write_duration.Set(
        parse_blocked_on_script_execution_from_document_write_duration_fragment.is_null() ? nullptr : parse_blocked_on_script_execution_from_document_write_duration_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::ParseTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::ParseTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::InteractiveTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::InteractiveTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::InteractiveTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::first_input_delay(input)) in_first_input_delay = Traits::first_input_delay(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_input_delay)::BaseType> first_input_delay_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_delay, first_input_delay_fragment);
    fragment->first_input_delay.Set(
        first_input_delay_fragment.is_null() ? nullptr : first_input_delay_fragment.data());
    decltype(Traits::first_input_timestamp(input)) in_first_input_timestamp = Traits::first_input_timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_input_timestamp)::BaseType> first_input_timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_timestamp, first_input_timestamp_fragment);
    fragment->first_input_timestamp.Set(
        first_input_timestamp_fragment.is_null() ? nullptr : first_input_timestamp_fragment.data());
    decltype(Traits::longest_input_delay(input)) in_longest_input_delay = Traits::longest_input_delay(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->longest_input_delay)::BaseType> longest_input_delay_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_longest_input_delay, longest_input_delay_fragment);
    fragment->longest_input_delay.Set(
        longest_input_delay_fragment.is_null() ? nullptr : longest_input_delay_fragment.data());
    decltype(Traits::longest_input_timestamp(input)) in_longest_input_timestamp = Traits::longest_input_timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->longest_input_timestamp)::BaseType> longest_input_timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_longest_input_timestamp, longest_input_timestamp_fragment);
    fragment->longest_input_timestamp.Set(
        longest_input_timestamp_fragment.is_null() ? nullptr : longest_input_timestamp_fragment.data());
    decltype(Traits::first_scroll_delay(input)) in_first_scroll_delay = Traits::first_scroll_delay(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_scroll_delay)::BaseType> first_scroll_delay_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_scroll_delay, first_scroll_delay_fragment);
    fragment->first_scroll_delay.Set(
        first_scroll_delay_fragment.is_null() ? nullptr : first_scroll_delay_fragment.data());
    decltype(Traits::first_scroll_timestamp(input)) in_first_scroll_timestamp = Traits::first_scroll_timestamp(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_scroll_timestamp)::BaseType> first_scroll_timestamp_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_scroll_timestamp, first_scroll_timestamp_fragment);
    fragment->first_scroll_timestamp.Set(
        first_scroll_timestamp_fragment.is_null() ? nullptr : first_scroll_timestamp_fragment.data());
    decltype(Traits::first_input_processing_time(input)) in_first_input_processing_time = Traits::first_input_processing_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_input_processing_time)::BaseType> first_input_processing_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_processing_time, first_input_processing_time_fragment);
    fragment->first_input_processing_time.Set(
        first_input_processing_time_fragment.is_null() ? nullptr : first_input_processing_time_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::InteractiveTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::InteractiveTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::PageLoadTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::PageLoadTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::PageLoadTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::navigation_start(input)) in_navigation_start = Traits::navigation_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->navigation_start)::BaseType> navigation_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDataView>(
        in_navigation_start, navigation_start_fragment);
    fragment->navigation_start.Set(
        navigation_start_fragment.is_null() ? nullptr : navigation_start_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->navigation_start.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null navigation_start in PageLoadTiming struct");
    decltype(Traits::response_start(input)) in_response_start = Traits::response_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->response_start)::BaseType> response_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_response_start, response_start_fragment);
    fragment->response_start.Set(
        response_start_fragment.is_null() ? nullptr : response_start_fragment.data());
    decltype(Traits::document_timing(input)) in_document_timing = Traits::document_timing(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->document_timing)::BaseType> document_timing_fragment(
            fragment.message());
    mojo::internal::Serialize<::page_load_metrics::mojom::DocumentTimingDataView>(
        in_document_timing, document_timing_fragment);
    fragment->document_timing.Set(
        document_timing_fragment.is_null() ? nullptr : document_timing_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->document_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null document_timing in PageLoadTiming struct");
    decltype(Traits::interactive_timing(input)) in_interactive_timing = Traits::interactive_timing(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->interactive_timing)::BaseType> interactive_timing_fragment(
            fragment.message());
    mojo::internal::Serialize<::page_load_metrics::mojom::InteractiveTimingDataView>(
        in_interactive_timing, interactive_timing_fragment);
    fragment->interactive_timing.Set(
        interactive_timing_fragment.is_null() ? nullptr : interactive_timing_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->interactive_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null interactive_timing in PageLoadTiming struct");
    decltype(Traits::paint_timing(input)) in_paint_timing = Traits::paint_timing(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->paint_timing)::BaseType> paint_timing_fragment(
            fragment.message());
    mojo::internal::Serialize<::page_load_metrics::mojom::PaintTimingDataView>(
        in_paint_timing, paint_timing_fragment);
    fragment->paint_timing.Set(
        paint_timing_fragment.is_null() ? nullptr : paint_timing_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->paint_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null paint_timing in PageLoadTiming struct");
    decltype(Traits::parse_timing(input)) in_parse_timing = Traits::parse_timing(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->parse_timing)::BaseType> parse_timing_fragment(
            fragment.message());
    mojo::internal::Serialize<::page_load_metrics::mojom::ParseTimingDataView>(
        in_parse_timing, parse_timing_fragment);
    fragment->parse_timing.Set(
        parse_timing_fragment.is_null() ? nullptr : parse_timing_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->parse_timing.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null parse_timing in PageLoadTiming struct");
    decltype(Traits::back_forward_cache_timings(input)) in_back_forward_cache_timings = Traits::back_forward_cache_timings(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->back_forward_cache_timings)::BaseType>
        back_forward_cache_timings_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams back_forward_cache_timings_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::BackForwardCacheTimingDataView>>(
        in_back_forward_cache_timings, back_forward_cache_timings_fragment, &back_forward_cache_timings_validate_params);
    fragment->back_forward_cache_timings.Set(
        back_forward_cache_timings_fragment.is_null() ? nullptr : back_forward_cache_timings_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->back_forward_cache_timings.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null back_forward_cache_timings in PageLoadTiming struct");
    decltype(Traits::activation_start(input)) in_activation_start = Traits::activation_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->activation_start)::BaseType> activation_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_activation_start, activation_start_fragment);
    fragment->activation_start.Set(
        activation_start_fragment.is_null() ? nullptr : activation_start_fragment.data());
    decltype(Traits::input_to_navigation_start(input)) in_input_to_navigation_start = Traits::input_to_navigation_start(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->input_to_navigation_start)::BaseType> input_to_navigation_start_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_input_to_navigation_start, input_to_navigation_start_fragment);
    fragment->input_to_navigation_start.Set(
        input_to_navigation_start_fragment.is_null() ? nullptr : input_to_navigation_start_fragment.data());
    decltype(Traits::user_timing_mark_fully_loaded(input)) in_user_timing_mark_fully_loaded = Traits::user_timing_mark_fully_loaded(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user_timing_mark_fully_loaded)::BaseType> user_timing_mark_fully_loaded_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_user_timing_mark_fully_loaded, user_timing_mark_fully_loaded_fragment);
    fragment->user_timing_mark_fully_loaded.Set(
        user_timing_mark_fully_loaded_fragment.is_null() ? nullptr : user_timing_mark_fully_loaded_fragment.data());
    decltype(Traits::user_timing_mark_fully_visible(input)) in_user_timing_mark_fully_visible = Traits::user_timing_mark_fully_visible(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user_timing_mark_fully_visible)::BaseType> user_timing_mark_fully_visible_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_user_timing_mark_fully_visible, user_timing_mark_fully_visible_fragment);
    fragment->user_timing_mark_fully_visible.Set(
        user_timing_mark_fully_visible_fragment.is_null() ? nullptr : user_timing_mark_fully_visible_fragment.data());
    decltype(Traits::user_timing_mark_interactive(input)) in_user_timing_mark_interactive = Traits::user_timing_mark_interactive(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->user_timing_mark_interactive)::BaseType> user_timing_mark_interactive_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_user_timing_mark_interactive, user_timing_mark_interactive_fragment);
    fragment->user_timing_mark_interactive.Set(
        user_timing_mark_interactive_fragment.is_null() ? nullptr : user_timing_mark_interactive_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::PageLoadTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::PageLoadTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::FrameMetadataDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::FrameMetadataDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::FrameMetadata_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->behavior_flags = Traits::behavior_flags(input);
    decltype(Traits::main_frame_intersection_rect(input)) in_main_frame_intersection_rect = Traits::main_frame_intersection_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->main_frame_intersection_rect)::BaseType> main_frame_intersection_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_main_frame_intersection_rect, main_frame_intersection_rect_fragment);
    fragment->main_frame_intersection_rect.Set(
        main_frame_intersection_rect_fragment.is_null() ? nullptr : main_frame_intersection_rect_fragment.data());
    decltype(Traits::main_frame_viewport_rect(input)) in_main_frame_viewport_rect = Traits::main_frame_viewport_rect(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->main_frame_viewport_rect)::BaseType> main_frame_viewport_rect_fragment(
            fragment.message());
    mojo::internal::Serialize<::gfx::mojom::RectDataView>(
        in_main_frame_viewport_rect, main_frame_viewport_rect_fragment);
    fragment->main_frame_viewport_rect.Set(
        main_frame_viewport_rect_fragment.is_null() ? nullptr : main_frame_viewport_rect_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::FrameMetadata_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::FrameMetadataDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::ResourceDataUpdateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::ResourceDataUpdateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::ResourceDataUpdate_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->request_id = Traits::request_id(input);
    fragment->delta_bytes = Traits::delta_bytes(input);
    fragment->received_data_length = Traits::received_data_length(input);
    fragment->encoded_body_length = Traits::encoded_body_length(input);
    fragment->decoded_body_length = Traits::decoded_body_length(input);
    fragment->is_complete = Traits::is_complete(input);
    fragment->reported_as_ad_resource = Traits::reported_as_ad_resource(input);
    fragment->is_main_frame_resource = Traits::is_main_frame_resource(input);
    mojo::internal::Serialize<::page_load_metrics::mojom::CacheType>(
        Traits::cache_type(input), &fragment->cache_type);
    fragment->is_primary_frame_resource = Traits::is_primary_frame_resource(input);
    decltype(Traits::mime_type(input)) in_mime_type = Traits::mime_type(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->mime_type)::BaseType> mime_type_fragment(
            fragment.message());
    mojo::internal::Serialize<mojo::StringDataView>(
        in_mime_type, mime_type_fragment);
    fragment->mime_type.Set(
        mime_type_fragment.is_null() ? nullptr : mime_type_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->mime_type.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null mime_type in ResourceDataUpdate struct");
    fragment->is_secure_scheme = Traits::is_secure_scheme(input);
    fragment->proxy_used = Traits::proxy_used(input);
    fragment->completed_before_fcp = Traits::completed_before_fcp(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::ResourceDataUpdate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::ResourceDataUpdateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::LayoutShiftDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::LayoutShiftDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::LayoutShift_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::layout_shift_time(input)) in_layout_shift_time = Traits::layout_shift_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->layout_shift_time)::BaseType> layout_shift_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeTicksDataView>(
        in_layout_shift_time, layout_shift_time_fragment);
    fragment->layout_shift_time.Set(
        layout_shift_time_fragment.is_null() ? nullptr : layout_shift_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->layout_shift_time.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null layout_shift_time in LayoutShift struct");
    fragment->layout_shift_score = Traits::layout_shift_score(input);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::LayoutShift_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::LayoutShiftDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::FrameRenderDataUpdateDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::FrameRenderDataUpdateDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    fragment->layout_shift_delta = Traits::layout_shift_delta(input);
    fragment->layout_shift_delta_before_input_or_scroll = Traits::layout_shift_delta_before_input_or_scroll(input);
    fragment->all_layout_block_count_delta = Traits::all_layout_block_count_delta(input);
    fragment->ng_layout_block_count_delta = Traits::ng_layout_block_count_delta(input);
    fragment->all_layout_call_count_delta = Traits::all_layout_call_count_delta(input);
    fragment->ng_layout_call_count_delta = Traits::ng_layout_call_count_delta(input);
    decltype(Traits::new_layout_shifts(input)) in_new_layout_shifts = Traits::new_layout_shifts(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->new_layout_shifts)::BaseType>
        new_layout_shifts_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams new_layout_shifts_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::LayoutShiftDataView>>(
        in_new_layout_shifts, new_layout_shifts_fragment, &new_layout_shifts_validate_params);
    fragment->new_layout_shifts.Set(
        new_layout_shifts_fragment.is_null() ? nullptr : new_layout_shifts_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->new_layout_shifts.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null new_layout_shifts in FrameRenderDataUpdate struct");
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::FrameRenderDataUpdate_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::FrameRenderDataUpdateDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::CpuTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::CpuTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::CpuTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::task_time(input)) in_task_time = Traits::task_time(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->task_time)::BaseType> task_time_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_task_time, task_time_fragment);
    fragment->task_time.Set(
        task_time_fragment.is_null() ? nullptr : task_time_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->task_time.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null task_time in CpuTiming struct");
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::CpuTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::CpuTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::InputTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::InputTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::InputTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::total_input_delay(input)) in_total_input_delay = Traits::total_input_delay(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->total_input_delay)::BaseType> total_input_delay_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_total_input_delay, total_input_delay_fragment);
    fragment->total_input_delay.Set(
        total_input_delay_fragment.is_null() ? nullptr : total_input_delay_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->total_input_delay.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null total_input_delay in InputTiming struct");
    decltype(Traits::total_adjusted_input_delay(input)) in_total_adjusted_input_delay = Traits::total_adjusted_input_delay(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->total_adjusted_input_delay)::BaseType> total_adjusted_input_delay_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_total_adjusted_input_delay, total_adjusted_input_delay_fragment);
    fragment->total_adjusted_input_delay.Set(
        total_adjusted_input_delay_fragment.is_null() ? nullptr : total_adjusted_input_delay_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->total_adjusted_input_delay.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null total_adjusted_input_delay in InputTiming struct");
    fragment->num_input_events = Traits::num_input_events(input);
    fragment->num_interactions = Traits::num_interactions(input);
    decltype(Traits::max_event_durations(input)) in_max_event_durations = Traits::max_event_durations(input);
    mojo::internal::MessageFragment<decltype(fragment->max_event_durations)>
        max_event_durations_fragment(fragment.message());
    max_event_durations_fragment.Claim(&fragment->max_event_durations);
    mojo::internal::Serialize<::page_load_metrics::mojom::UserInteractionLatenciesDataView>(
        in_max_event_durations, max_event_durations_fragment, true);
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->max_event_durations.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null max_event_durations in InputTiming struct");
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::InputTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::InputTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::UserInteractionLatencyDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::UserInteractionLatencyDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::UserInteractionLatency_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::interaction_latency(input)) in_interaction_latency = Traits::interaction_latency(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->interaction_latency)::BaseType> interaction_latency_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_interaction_latency, interaction_latency_fragment);
    fragment->interaction_latency.Set(
        interaction_latency_fragment.is_null() ? nullptr : interaction_latency_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->interaction_latency.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null interaction_latency in UserInteractionLatency struct");
    mojo::internal::Serialize<::page_load_metrics::mojom::UserInteractionType>(
        Traits::interaction_type(input), &fragment->interaction_type);
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::UserInteractionLatency_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::UserInteractionLatencyDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::BackForwardCacheTimingDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = StructTraits<::page_load_metrics::mojom::BackForwardCacheTimingDataView, UserType>;

  static void Serialize(
      MaybeConstUserType& input,
      mojo::internal::MessageFragment<::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data>& fragment) {
    if (CallIsNullIfExists<Traits>(input))
      return;
    fragment.Allocate();
    decltype(Traits::first_paint_after_back_forward_cache_restore(input)) in_first_paint_after_back_forward_cache_restore = Traits::first_paint_after_back_forward_cache_restore(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_paint_after_back_forward_cache_restore)::BaseType> first_paint_after_back_forward_cache_restore_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_paint_after_back_forward_cache_restore, first_paint_after_back_forward_cache_restore_fragment);
    fragment->first_paint_after_back_forward_cache_restore.Set(
        first_paint_after_back_forward_cache_restore_fragment.is_null() ? nullptr : first_paint_after_back_forward_cache_restore_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->first_paint_after_back_forward_cache_restore.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null first_paint_after_back_forward_cache_restore in BackForwardCacheTiming struct");
    decltype(Traits::request_animation_frames_after_back_forward_cache_restore(input)) in_request_animation_frames_after_back_forward_cache_restore = Traits::request_animation_frames_after_back_forward_cache_restore(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->request_animation_frames_after_back_forward_cache_restore)::BaseType>
        request_animation_frames_after_back_forward_cache_restore_fragment(fragment.message());
    const mojo::internal::ContainerValidateParams request_animation_frames_after_back_forward_cache_restore_validate_params(
        0, false, nullptr);
    mojo::internal::Serialize<mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>>(
        in_request_animation_frames_after_back_forward_cache_restore, request_animation_frames_after_back_forward_cache_restore_fragment, &request_animation_frames_after_back_forward_cache_restore_validate_params);
    fragment->request_animation_frames_after_back_forward_cache_restore.Set(
        request_animation_frames_after_back_forward_cache_restore_fragment.is_null() ? nullptr : request_animation_frames_after_back_forward_cache_restore_fragment.data());
    MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
        fragment->request_animation_frames_after_back_forward_cache_restore.is_null(),
        mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
        "null request_animation_frames_after_back_forward_cache_restore in BackForwardCacheTiming struct");
    decltype(Traits::first_input_delay_after_back_forward_cache_restore(input)) in_first_input_delay_after_back_forward_cache_restore = Traits::first_input_delay_after_back_forward_cache_restore(input);
    mojo::internal::MessageFragment<
        typename decltype(fragment->first_input_delay_after_back_forward_cache_restore)::BaseType> first_input_delay_after_back_forward_cache_restore_fragment(
            fragment.message());
    mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
        in_first_input_delay_after_back_forward_cache_restore, first_input_delay_after_back_forward_cache_restore_fragment);
    fragment->first_input_delay_after_back_forward_cache_restore.Set(
        first_input_delay_after_back_forward_cache_restore_fragment.is_null() ? nullptr : first_input_delay_after_back_forward_cache_restore_fragment.data());
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::BackForwardCacheTiming_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input)
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::BackForwardCacheTimingDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal


namespace internal {

template <typename MaybeConstUserType>
struct Serializer<::page_load_metrics::mojom::UserInteractionLatenciesDataView, MaybeConstUserType> {
  using UserType = typename std::remove_const<MaybeConstUserType>::type;
  using Traits = UnionTraits<::page_load_metrics::mojom::UserInteractionLatenciesDataView, UserType>;

  static void Serialize(MaybeConstUserType& input,
                        MessageFragment<::page_load_metrics::mojom::internal::UserInteractionLatencies_Data>& fragment,
                        bool inlined) {
    if (CallIsNullIfExists<Traits>(input)) {
       if (inlined)
        fragment->set_null();
      return;
    }

    if (!inlined)
      fragment.Allocate();

    // TODO(azani): Handle unknown and objects.
    // Set the not-null flag.
    fragment->size = kUnionDataSize;
    fragment->tag = Traits::GetTag(input);
    switch (fragment->tag) {
      case ::page_load_metrics::mojom::UserInteractionLatenciesDataView::Tag::kUserInteractionLatencies: {
        decltype(Traits::user_interaction_latencies(input))
            in_user_interaction_latencies = Traits::user_interaction_latencies(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_user_interaction_latencies)::BaseType>
            value_fragment(fragment.message());
        const ContainerValidateParams user_interaction_latencies_validate_params(
            0, false, nullptr);
        mojo::internal::Serialize<mojo::ArrayDataView<::page_load_metrics::mojom::UserInteractionLatencyDataView>>(
            in_user_interaction_latencies, value_fragment, &user_interaction_latencies_validate_params);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null user_interaction_latencies in UserInteractionLatencies union");
        fragment->data.f_user_interaction_latencies.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
      case ::page_load_metrics::mojom::UserInteractionLatenciesDataView::Tag::kWorstInteractionLatency: {
        decltype(Traits::worst_interaction_latency(input))
            in_worst_interaction_latency = Traits::worst_interaction_latency(input);
        mojo::internal::MessageFragment<
            typename decltype(fragment->data.f_worst_interaction_latency)::BaseType>
            value_fragment(fragment.message());
        mojo::internal::Serialize<::mojo_base::mojom::TimeDeltaDataView>(
            in_worst_interaction_latency, value_fragment);
        MOJO_INTERNAL_DLOG_SERIALIZATION_WARNING(
            value_fragment.is_null(),
            mojo::internal::VALIDATION_ERROR_UNEXPECTED_NULL_POINTER,
            "null worst_interaction_latency in UserInteractionLatencies union");
        fragment->data.f_worst_interaction_latency.Set(
            value_fragment.is_null() ? nullptr : value_fragment.data());
        break;
      }
    }
  }

  static bool Deserialize(::page_load_metrics::mojom::internal::UserInteractionLatencies_Data* input,
                          UserType* output,
                          Message* message) {
    if (!input || input->is_null())
      return CallSetToNullIfExists<Traits>(output);

    ::page_load_metrics::mojom::UserInteractionLatenciesDataView data_view(input, message);
    return Traits::Read(data_view, output);
  }
};

}  // namespace internal

}  // namespace mojo


namespace page_load_metrics {
namespace mojom {

inline void DocumentTimingDataView::GetDomContentLoadedEventStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->dom_content_loaded_event_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void DocumentTimingDataView::GetLoadEventStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->load_event_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void LargestContentfulPaintTimingDataView::GetLargestImagePaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->largest_image_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void LargestContentfulPaintTimingDataView::GetLargestTextPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->largest_text_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void PaintTimingDataView::GetFirstPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstImagePaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_image_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstContentfulPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_contentful_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstMeaningfulPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_meaningful_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetLargestContentfulPaintDataView(
    LargestContentfulPaintTimingDataView* output) {
  auto pointer = data_->largest_contentful_paint.Get();
  *output = LargestContentfulPaintTimingDataView(pointer, message_);
}
inline void PaintTimingDataView::GetExperimentalLargestContentfulPaintDataView(
    LargestContentfulPaintTimingDataView* output) {
  auto pointer = data_->experimental_largest_contentful_paint.Get();
  *output = LargestContentfulPaintTimingDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstEligibleToPaintDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_eligible_to_paint.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetFirstInputOrScrollNotifiedTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_or_scroll_notified_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PaintTimingDataView::GetPortalActivatedPaintDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->portal_activated_paint.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}


inline void ParseTimingDataView::GetParseStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseStopDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_stop.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptLoadDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_load_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptLoadFromDocumentWriteDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_load_from_document_write_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptExecutionDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_execution_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void ParseTimingDataView::GetParseBlockedOnScriptExecutionFromDocumentWriteDurationDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->parse_blocked_on_script_execution_from_document_write_duration.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void InteractiveTimingDataView::GetFirstInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstInputTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetLongestInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->longest_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetLongestInputTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->longest_input_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstScrollDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_scroll_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstScrollTimestampDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_scroll_timestamp.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InteractiveTimingDataView::GetFirstInputProcessingTimeDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_processing_time.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void PageLoadTimingDataView::GetNavigationStartDataView(
    ::mojo_base::mojom::TimeDataView* output) {
  auto pointer = data_->navigation_start.Get();
  *output = ::mojo_base::mojom::TimeDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetResponseStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->response_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetDocumentTimingDataView(
    DocumentTimingDataView* output) {
  auto pointer = data_->document_timing.Get();
  *output = DocumentTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetInteractiveTimingDataView(
    InteractiveTimingDataView* output) {
  auto pointer = data_->interactive_timing.Get();
  *output = InteractiveTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetPaintTimingDataView(
    PaintTimingDataView* output) {
  auto pointer = data_->paint_timing.Get();
  *output = PaintTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetParseTimingDataView(
    ParseTimingDataView* output) {
  auto pointer = data_->parse_timing.Get();
  *output = ParseTimingDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetBackForwardCacheTimingsDataView(
    mojo::ArrayDataView<BackForwardCacheTimingDataView>* output) {
  auto pointer = data_->back_forward_cache_timings.Get();
  *output = mojo::ArrayDataView<BackForwardCacheTimingDataView>(pointer, message_);
}
inline void PageLoadTimingDataView::GetActivationStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->activation_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetInputToNavigationStartDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->input_to_navigation_start.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetUserTimingMarkFullyLoadedDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->user_timing_mark_fully_loaded.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetUserTimingMarkFullyVisibleDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->user_timing_mark_fully_visible.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void PageLoadTimingDataView::GetUserTimingMarkInteractiveDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->user_timing_mark_interactive.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void FrameMetadataDataView::GetMainFrameIntersectionRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->main_frame_intersection_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}
inline void FrameMetadataDataView::GetMainFrameViewportRectDataView(
    ::gfx::mojom::RectDataView* output) {
  auto pointer = data_->main_frame_viewport_rect.Get();
  *output = ::gfx::mojom::RectDataView(pointer, message_);
}


inline void ResourceDataUpdateDataView::GetMimeTypeDataView(
    mojo::StringDataView* output) {
  auto pointer = data_->mime_type.Get();
  *output = mojo::StringDataView(pointer, message_);
}


inline void LayoutShiftDataView::GetLayoutShiftTimeDataView(
    ::mojo_base::mojom::TimeTicksDataView* output) {
  auto pointer = data_->layout_shift_time.Get();
  *output = ::mojo_base::mojom::TimeTicksDataView(pointer, message_);
}


inline void FrameRenderDataUpdateDataView::GetNewLayoutShiftsDataView(
    mojo::ArrayDataView<LayoutShiftDataView>* output) {
  auto pointer = data_->new_layout_shifts.Get();
  *output = mojo::ArrayDataView<LayoutShiftDataView>(pointer, message_);
}


inline void CpuTimingDataView::GetTaskTimeDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->task_time.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void InputTimingDataView::GetTotalInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->total_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InputTimingDataView::GetTotalAdjustedInputDelayDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->total_adjusted_input_delay.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void InputTimingDataView::GetMaxEventDurationsDataView(
    UserInteractionLatenciesDataView* output) {
  auto pointer = &data_->max_event_durations;
  *output = UserInteractionLatenciesDataView(pointer, message_);
}


inline void UserInteractionLatencyDataView::GetInteractionLatencyDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->interaction_latency.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void BackForwardCacheTimingDataView::GetFirstPaintAfterBackForwardCacheRestoreDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_paint_after_back_forward_cache_restore.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}
inline void BackForwardCacheTimingDataView::GetRequestAnimationFramesAfterBackForwardCacheRestoreDataView(
    mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>* output) {
  auto pointer = data_->request_animation_frames_after_back_forward_cache_restore.Get();
  *output = mojo::ArrayDataView<::mojo_base::mojom::TimeDeltaDataView>(pointer, message_);
}
inline void BackForwardCacheTimingDataView::GetFirstInputDelayAfterBackForwardCacheRestoreDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) {
  auto pointer = data_->first_input_delay_after_back_forward_cache_restore.Get();
  *output = ::mojo_base::mojom::TimeDeltaDataView(pointer, message_);
}


inline void UserInteractionLatenciesDataView::GetUserInteractionLatenciesDataView(
    mojo::ArrayDataView<UserInteractionLatencyDataView>* output) const {
  CHECK(is_user_interaction_latencies());
  *output = mojo::ArrayDataView<UserInteractionLatencyDataView>(data_->data.f_user_interaction_latencies.Get(), message_);
}
inline void UserInteractionLatenciesDataView::GetWorstInteractionLatencyDataView(
    ::mojo_base::mojom::TimeDeltaDataView* output) const {
  CHECK(is_worst_interaction_latency());
  *output = ::mojo_base::mojom::TimeDeltaDataView(data_->data.f_worst_interaction_latency.Get(), message_);
}


}  // namespace mojom
}  // namespace page_load_metrics

// Declare TraceFormatTraits for enums, which should be defined in ::perfetto
// namespace.

namespace perfetto {

template <>
struct  TraceFormatTraits<::page_load_metrics::mojom::CacheType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::page_load_metrics::mojom::CacheType value);
};

} // namespace perfetto

namespace perfetto {

template <>
struct  TraceFormatTraits<::page_load_metrics::mojom::UserInteractionType> {
 static void WriteIntoTrace(perfetto::TracedValue context, ::page_load_metrics::mojom::UserInteractionType value);
};

} // namespace perfetto

#endif  // COMPONENTS_PAGE_LOAD_METRICS_COMMON_PAGE_LOAD_METRICS_MOJOM_SHARED_H_