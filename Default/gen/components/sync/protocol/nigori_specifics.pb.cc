// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/nigori_specifics.proto

#include "components/sync/protocol/nigori_specifics.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR NigoriKey::NigoriKey(
    ::_pbi::ConstantInitialized)
  : deprecated_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , deprecated_user_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , encryption_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , mac_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct NigoriKeyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NigoriKeyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NigoriKeyDefaultTypeInternal() {}
  union {
    NigoriKey _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NigoriKeyDefaultTypeInternal _NigoriKey_default_instance_;
PROTOBUF_CONSTEXPR NigoriKeyBag::NigoriKeyBag(
    ::_pbi::ConstantInitialized)
  : key_(){}
struct NigoriKeyBagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NigoriKeyBagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NigoriKeyBagDefaultTypeInternal() {}
  union {
    NigoriKeyBag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NigoriKeyBagDefaultTypeInternal _NigoriKeyBag_default_instance_;
PROTOBUF_CONSTEXPR NigoriSpecifics_TrustedVaultDebugInfo::NigoriSpecifics_TrustedVaultDebugInfo(
    ::_pbi::ConstantInitialized)
  : migration_time_(int64_t{0})
  , key_version_(0){}
struct NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal() {}
  union {
    NigoriSpecifics_TrustedVaultDebugInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NigoriSpecifics_TrustedVaultDebugInfoDefaultTypeInternal _NigoriSpecifics_TrustedVaultDebugInfo_default_instance_;
PROTOBUF_CONSTEXPR NigoriSpecifics::NigoriSpecifics(
    ::_pbi::ConstantInitialized)
  : custom_passphrase_key_derivation_salt_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , encryption_keybag_(nullptr)
  , keystore_decryptor_token_(nullptr)
  , trusted_vault_debug_info_(nullptr)
  , keybag_is_frozen_(false)
  , encrypt_bookmarks_(false)
  , encrypt_preferences_(false)
  , encrypt_autofill_profile_(false)
  , encrypt_autofill_(false)
  , encrypt_themes_(false)
  , encrypt_typed_urls_(false)
  , encrypt_extensions_(false)
  , encrypt_sessions_(false)
  , encrypt_apps_(false)
  , encrypt_search_engines_(false)
  , encrypt_everything_(false)
  , encrypt_extension_settings_(false)
  , encrypt_app_notifications_(false)
  , encrypt_app_settings_(false)
  , sync_tab_favicons_(false)
  , keystore_migration_time_(int64_t{0})
  , custom_passphrase_time_(int64_t{0})
  , encrypt_dictionary_(false)
  , encrypt_app_list_(false)
  , encrypt_autofill_wallet_metadata_(false)
  , server_only_was_missing_keystore_migration_time_(false)
  , encrypt_arc_package_(false)
  , encrypt_printers_(false)
  , encrypt_reading_list_(false)
  , encrypt_send_tab_to_self_(false)
  , custom_passphrase_key_derivation_method_(0)
  , encrypt_web_apps_(false)
  , encrypt_os_preferences_(false)
  , encrypt_workspace_desk_(false)
  , encrypt_printers_authorization_servers_(false)
  , passphrase_type_(1){}
struct NigoriSpecificsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NigoriSpecificsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NigoriSpecificsDefaultTypeInternal() {}
  union {
    NigoriSpecifics _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NigoriSpecificsDefaultTypeInternal _NigoriSpecifics_default_instance_;
}  // namespace sync_pb
namespace sync_pb {
bool NigoriSpecifics_PassphraseType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NigoriSpecifics_PassphraseType_strings[6] = {};

static const char NigoriSpecifics_PassphraseType_names[] =
  "CUSTOM_PASSPHRASE"
  "FROZEN_IMPLICIT_PASSPHRASE"
  "IMPLICIT_PASSPHRASE"
  "KEYSTORE_PASSPHRASE"
  "TRUSTED_VAULT_PASSPHRASE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NigoriSpecifics_PassphraseType_entries[] = {
  { {NigoriSpecifics_PassphraseType_names + 0, 17}, 4 },
  { {NigoriSpecifics_PassphraseType_names + 17, 26}, 3 },
  { {NigoriSpecifics_PassphraseType_names + 43, 19}, 1 },
  { {NigoriSpecifics_PassphraseType_names + 62, 19}, 2 },
  { {NigoriSpecifics_PassphraseType_names + 81, 24}, 5 },
  { {NigoriSpecifics_PassphraseType_names + 105, 7}, 0 },
};

static const int NigoriSpecifics_PassphraseType_entries_by_number[] = {
  5, // 0 -> UNKNOWN
  2, // 1 -> IMPLICIT_PASSPHRASE
  3, // 2 -> KEYSTORE_PASSPHRASE
  1, // 3 -> FROZEN_IMPLICIT_PASSPHRASE
  0, // 4 -> CUSTOM_PASSPHRASE
  4, // 5 -> TRUSTED_VAULT_PASSPHRASE
};

const std::string& NigoriSpecifics_PassphraseType_Name(
    NigoriSpecifics_PassphraseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NigoriSpecifics_PassphraseType_entries,
          NigoriSpecifics_PassphraseType_entries_by_number,
          6, NigoriSpecifics_PassphraseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NigoriSpecifics_PassphraseType_entries,
      NigoriSpecifics_PassphraseType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NigoriSpecifics_PassphraseType_strings[idx].get();
}
bool NigoriSpecifics_PassphraseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NigoriSpecifics_PassphraseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NigoriSpecifics_PassphraseType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<NigoriSpecifics_PassphraseType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::UNKNOWN;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::IMPLICIT_PASSPHRASE;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::KEYSTORE_PASSPHRASE;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::FROZEN_IMPLICIT_PASSPHRASE;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::CUSTOM_PASSPHRASE;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::TRUSTED_VAULT_PASSPHRASE;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::PassphraseType_MIN;
constexpr NigoriSpecifics_PassphraseType NigoriSpecifics::PassphraseType_MAX;
constexpr int NigoriSpecifics::PassphraseType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool NigoriSpecifics_KeyDerivationMethod_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NigoriSpecifics_KeyDerivationMethod_strings[3] = {};

static const char NigoriSpecifics_KeyDerivationMethod_names[] =
  "PBKDF2_HMAC_SHA1_1003"
  "SCRYPT_8192_8_11"
  "UNSPECIFIED";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NigoriSpecifics_KeyDerivationMethod_entries[] = {
  { {NigoriSpecifics_KeyDerivationMethod_names + 0, 21}, 1 },
  { {NigoriSpecifics_KeyDerivationMethod_names + 21, 16}, 2 },
  { {NigoriSpecifics_KeyDerivationMethod_names + 37, 11}, 0 },
};

static const int NigoriSpecifics_KeyDerivationMethod_entries_by_number[] = {
  2, // 0 -> UNSPECIFIED
  0, // 1 -> PBKDF2_HMAC_SHA1_1003
  1, // 2 -> SCRYPT_8192_8_11
};

const std::string& NigoriSpecifics_KeyDerivationMethod_Name(
    NigoriSpecifics_KeyDerivationMethod value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NigoriSpecifics_KeyDerivationMethod_entries,
          NigoriSpecifics_KeyDerivationMethod_entries_by_number,
          3, NigoriSpecifics_KeyDerivationMethod_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NigoriSpecifics_KeyDerivationMethod_entries,
      NigoriSpecifics_KeyDerivationMethod_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NigoriSpecifics_KeyDerivationMethod_strings[idx].get();
}
bool NigoriSpecifics_KeyDerivationMethod_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NigoriSpecifics_KeyDerivationMethod* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NigoriSpecifics_KeyDerivationMethod_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NigoriSpecifics_KeyDerivationMethod>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics::UNSPECIFIED;
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics::PBKDF2_HMAC_SHA1_1003;
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics::SCRYPT_8192_8_11;
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics::KeyDerivationMethod_MIN;
constexpr NigoriSpecifics_KeyDerivationMethod NigoriSpecifics::KeyDerivationMethod_MAX;
constexpr int NigoriSpecifics::KeyDerivationMethod_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class NigoriKey::_Internal {
 public:
  using HasBits = decltype(std::declval<NigoriKey>()._has_bits_);
  static void set_has_deprecated_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_deprecated_user_key(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encryption_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mac_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

NigoriKey::NigoriKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.NigoriKey)
}
NigoriKey::NigoriKey(const NigoriKey& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  deprecated_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    deprecated_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_deprecated_name()) {
    deprecated_name_.Set(from._internal_deprecated_name(), 
      GetArenaForAllocation());
  }
  deprecated_user_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    deprecated_user_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_deprecated_user_key()) {
    deprecated_user_key_.Set(from._internal_deprecated_user_key(), 
      GetArenaForAllocation());
  }
  encryption_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encryption_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encryption_key()) {
    encryption_key_.Set(from._internal_encryption_key(), 
      GetArenaForAllocation());
  }
  mac_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac_key()) {
    mac_key_.Set(from._internal_mac_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.NigoriKey)
}

inline void NigoriKey::SharedCtor() {
deprecated_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  deprecated_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
deprecated_user_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  deprecated_user_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
encryption_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encryption_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
mac_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

NigoriKey::~NigoriKey() {
  // @@protoc_insertion_point(destructor:sync_pb.NigoriKey)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NigoriKey::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  deprecated_name_.Destroy();
  deprecated_user_key_.Destroy();
  encryption_key_.Destroy();
  mac_key_.Destroy();
}

void NigoriKey::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NigoriKey::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.NigoriKey)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      deprecated_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      deprecated_user_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      encryption_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      mac_key_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NigoriKey::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string deprecated_name = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_deprecated_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes deprecated_user_key = 2 [deprecated = true];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_deprecated_user_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encryption_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_encryption_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes mac_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mac_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NigoriKey::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NigoriKey)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string deprecated_name = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_deprecated_name(), target);
  }

  // optional bytes deprecated_user_key = 2 [deprecated = true];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_deprecated_user_key(), target);
  }

  // optional bytes encryption_key = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_encryption_key(), target);
  }

  // optional bytes mac_key = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_mac_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NigoriKey)
  return target;
}

size_t NigoriKey::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.NigoriKey)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string deprecated_name = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_deprecated_name());
    }

    // optional bytes deprecated_user_key = 2 [deprecated = true];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_deprecated_user_key());
    }

    // optional bytes encryption_key = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encryption_key());
    }

    // optional bytes mac_key = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_mac_key());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NigoriKey::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NigoriKey*>(
      &from));
}

void NigoriKey::MergeFrom(const NigoriKey& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NigoriKey)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_deprecated_name(from._internal_deprecated_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_deprecated_user_key(from._internal_deprecated_user_key());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_encryption_key(from._internal_encryption_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_mac_key(from._internal_mac_key());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NigoriKey::CopyFrom(const NigoriKey& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NigoriKey)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NigoriKey::IsInitialized() const {
  return true;
}

void NigoriKey::InternalSwap(NigoriKey* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &deprecated_name_, lhs_arena,
      &other->deprecated_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &deprecated_user_key_, lhs_arena,
      &other->deprecated_user_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &encryption_key_, lhs_arena,
      &other->encryption_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &mac_key_, lhs_arena,
      &other->mac_key_, rhs_arena
  );
}

std::string NigoriKey::GetTypeName() const {
  return "sync_pb.NigoriKey";
}


// ===================================================================

class NigoriKeyBag::_Internal {
 public:
};

NigoriKeyBag::NigoriKeyBag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  key_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.NigoriKeyBag)
}
NigoriKeyBag::NigoriKeyBag(const NigoriKeyBag& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      key_(from.key_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.NigoriKeyBag)
}

inline void NigoriKeyBag::SharedCtor() {
}

NigoriKeyBag::~NigoriKeyBag() {
  // @@protoc_insertion_point(destructor:sync_pb.NigoriKeyBag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NigoriKeyBag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NigoriKeyBag::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NigoriKeyBag::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.NigoriKeyBag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  key_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NigoriKeyBag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sync_pb.NigoriKey key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_key(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NigoriKeyBag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NigoriKeyBag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sync_pb.NigoriKey key = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_key_size()); i < n; i++) {
    const auto& repfield = this->_internal_key(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NigoriKeyBag)
  return target;
}

size_t NigoriKeyBag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.NigoriKeyBag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sync_pb.NigoriKey key = 2;
  total_size += 1UL * this->_internal_key_size();
  for (const auto& msg : this->key_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NigoriKeyBag::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NigoriKeyBag*>(
      &from));
}

void NigoriKeyBag::MergeFrom(const NigoriKeyBag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NigoriKeyBag)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  key_.MergeFrom(from.key_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NigoriKeyBag::CopyFrom(const NigoriKeyBag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NigoriKeyBag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NigoriKeyBag::IsInitialized() const {
  return true;
}

void NigoriKeyBag::InternalSwap(NigoriKeyBag* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  key_.InternalSwap(&other->key_);
}

std::string NigoriKeyBag::GetTypeName() const {
  return "sync_pb.NigoriKeyBag";
}


// ===================================================================

class NigoriSpecifics_TrustedVaultDebugInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<NigoriSpecifics_TrustedVaultDebugInfo>()._has_bits_);
  static void set_has_migration_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_key_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

NigoriSpecifics_TrustedVaultDebugInfo::NigoriSpecifics_TrustedVaultDebugInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
}
NigoriSpecifics_TrustedVaultDebugInfo::NigoriSpecifics_TrustedVaultDebugInfo(const NigoriSpecifics_TrustedVaultDebugInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&migration_time_, &from.migration_time_,
    static_cast<size_t>(reinterpret_cast<char*>(&key_version_) -
    reinterpret_cast<char*>(&migration_time_)) + sizeof(key_version_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
}

inline void NigoriSpecifics_TrustedVaultDebugInfo::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&migration_time_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&key_version_) -
    reinterpret_cast<char*>(&migration_time_)) + sizeof(key_version_));
}

NigoriSpecifics_TrustedVaultDebugInfo::~NigoriSpecifics_TrustedVaultDebugInfo() {
  // @@protoc_insertion_point(destructor:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NigoriSpecifics_TrustedVaultDebugInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void NigoriSpecifics_TrustedVaultDebugInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NigoriSpecifics_TrustedVaultDebugInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&migration_time_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&key_version_) -
        reinterpret_cast<char*>(&migration_time_)) + sizeof(key_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NigoriSpecifics_TrustedVaultDebugInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 migration_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_migration_time(&has_bits);
          migration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 key_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_key_version(&has_bits);
          key_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NigoriSpecifics_TrustedVaultDebugInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 migration_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_migration_time(), target);
  }

  // optional int32 key_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_key_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  return target;
}

size_t NigoriSpecifics_TrustedVaultDebugInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 migration_time = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_migration_time());
    }

    // optional int32 key_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_key_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NigoriSpecifics_TrustedVaultDebugInfo::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NigoriSpecifics_TrustedVaultDebugInfo*>(
      &from));
}

void NigoriSpecifics_TrustedVaultDebugInfo::MergeFrom(const NigoriSpecifics_TrustedVaultDebugInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      migration_time_ = from.migration_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      key_version_ = from.key_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NigoriSpecifics_TrustedVaultDebugInfo::CopyFrom(const NigoriSpecifics_TrustedVaultDebugInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NigoriSpecifics.TrustedVaultDebugInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NigoriSpecifics_TrustedVaultDebugInfo::IsInitialized() const {
  return true;
}

void NigoriSpecifics_TrustedVaultDebugInfo::InternalSwap(NigoriSpecifics_TrustedVaultDebugInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NigoriSpecifics_TrustedVaultDebugInfo, key_version_)
      + sizeof(NigoriSpecifics_TrustedVaultDebugInfo::key_version_)
      - PROTOBUF_FIELD_OFFSET(NigoriSpecifics_TrustedVaultDebugInfo, migration_time_)>(
          reinterpret_cast<char*>(&migration_time_),
          reinterpret_cast<char*>(&other->migration_time_));
}

std::string NigoriSpecifics_TrustedVaultDebugInfo::GetTypeName() const {
  return "sync_pb.NigoriSpecifics.TrustedVaultDebugInfo";
}


// ===================================================================

class NigoriSpecifics::_Internal {
 public:
  using HasBits = decltype(std::declval<NigoriSpecifics>()._has_bits_);
  static const ::sync_pb::EncryptedData& encryption_keybag(const NigoriSpecifics* msg);
  static void set_has_encryption_keybag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_keybag_is_frozen(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_encrypt_bookmarks(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_encrypt_preferences(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_encrypt_autofill_profile(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_encrypt_autofill(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_encrypt_themes(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_encrypt_typed_urls(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_encrypt_extensions(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_encrypt_sessions(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_encrypt_apps(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_encrypt_search_engines(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_encrypt_everything(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_encrypt_extension_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_encrypt_app_notifications(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_encrypt_app_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_sync_tab_favicons(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_passphrase_type(HasBits* has_bits) {
    (*has_bits)[1] |= 8u;
  }
  static const ::sync_pb::EncryptedData& keystore_decryptor_token(const NigoriSpecifics* msg);
  static void set_has_keystore_decryptor_token(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_keystore_migration_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_custom_passphrase_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_encrypt_dictionary(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_encrypt_app_list(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_encrypt_autofill_wallet_metadata(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_server_only_was_missing_keystore_migration_time(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_encrypt_arc_package(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_encrypt_printers(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_encrypt_reading_list(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
  static void set_has_custom_passphrase_key_derivation_method(HasBits* has_bits) {
    (*has_bits)[0] |= 1073741824u;
  }
  static void set_has_custom_passphrase_key_derivation_salt(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_encrypt_send_tab_to_self(HasBits* has_bits) {
    (*has_bits)[0] |= 536870912u;
  }
  static void set_has_encrypt_web_apps(HasBits* has_bits) {
    (*has_bits)[0] |= 2147483648u;
  }
  static void set_has_encrypt_os_preferences(HasBits* has_bits) {
    (*has_bits)[1] |= 1u;
  }
  static const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo& trusted_vault_debug_info(const NigoriSpecifics* msg);
  static void set_has_trusted_vault_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_encrypt_workspace_desk(HasBits* has_bits) {
    (*has_bits)[1] |= 2u;
  }
  static void set_has_encrypt_printers_authorization_servers(HasBits* has_bits) {
    (*has_bits)[1] |= 4u;
  }
};

const ::sync_pb::EncryptedData&
NigoriSpecifics::_Internal::encryption_keybag(const NigoriSpecifics* msg) {
  return *msg->encryption_keybag_;
}
const ::sync_pb::EncryptedData&
NigoriSpecifics::_Internal::keystore_decryptor_token(const NigoriSpecifics* msg) {
  return *msg->keystore_decryptor_token_;
}
const ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo&
NigoriSpecifics::_Internal::trusted_vault_debug_info(const NigoriSpecifics* msg) {
  return *msg->trusted_vault_debug_info_;
}
void NigoriSpecifics::clear_encryption_keybag() {
  if (encryption_keybag_ != nullptr) encryption_keybag_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
void NigoriSpecifics::clear_keystore_decryptor_token() {
  if (keystore_decryptor_token_ != nullptr) keystore_decryptor_token_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
NigoriSpecifics::NigoriSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.NigoriSpecifics)
}
NigoriSpecifics::NigoriSpecifics(const NigoriSpecifics& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  custom_passphrase_key_derivation_salt_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_custom_passphrase_key_derivation_salt()) {
    custom_passphrase_key_derivation_salt_.Set(from._internal_custom_passphrase_key_derivation_salt(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_encryption_keybag()) {
    encryption_keybag_ = new ::sync_pb::EncryptedData(*from.encryption_keybag_);
  } else {
    encryption_keybag_ = nullptr;
  }
  if (from._internal_has_keystore_decryptor_token()) {
    keystore_decryptor_token_ = new ::sync_pb::EncryptedData(*from.keystore_decryptor_token_);
  } else {
    keystore_decryptor_token_ = nullptr;
  }
  if (from._internal_has_trusted_vault_debug_info()) {
    trusted_vault_debug_info_ = new ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo(*from.trusted_vault_debug_info_);
  } else {
    trusted_vault_debug_info_ = nullptr;
  }
  ::memcpy(&keybag_is_frozen_, &from.keybag_is_frozen_,
    static_cast<size_t>(reinterpret_cast<char*>(&passphrase_type_) -
    reinterpret_cast<char*>(&keybag_is_frozen_)) + sizeof(passphrase_type_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.NigoriSpecifics)
}

inline void NigoriSpecifics::SharedCtor() {
custom_passphrase_key_derivation_salt_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  custom_passphrase_key_derivation_salt_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&encryption_keybag_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&encrypt_printers_authorization_servers_) -
    reinterpret_cast<char*>(&encryption_keybag_)) + sizeof(encrypt_printers_authorization_servers_));
passphrase_type_ = 1;
}

NigoriSpecifics::~NigoriSpecifics() {
  // @@protoc_insertion_point(destructor:sync_pb.NigoriSpecifics)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NigoriSpecifics::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  custom_passphrase_key_derivation_salt_.Destroy();
  if (this != internal_default_instance()) delete encryption_keybag_;
  if (this != internal_default_instance()) delete keystore_decryptor_token_;
  if (this != internal_default_instance()) delete trusted_vault_debug_info_;
}

void NigoriSpecifics::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NigoriSpecifics::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.NigoriSpecifics)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      custom_passphrase_key_derivation_salt_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(encryption_keybag_ != nullptr);
      encryption_keybag_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(keystore_decryptor_token_ != nullptr);
      keystore_decryptor_token_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(trusted_vault_debug_info_ != nullptr);
      trusted_vault_debug_info_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&keybag_is_frozen_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&encrypt_autofill_profile_) -
        reinterpret_cast<char*>(&keybag_is_frozen_)) + sizeof(encrypt_autofill_profile_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&encrypt_autofill_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&encrypt_everything_) -
        reinterpret_cast<char*>(&encrypt_autofill_)) + sizeof(encrypt_everything_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&encrypt_extension_settings_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&encrypt_app_list_) -
        reinterpret_cast<char*>(&encrypt_extension_settings_)) + sizeof(encrypt_app_list_));
  }
  if (cached_has_bits & 0xff000000u) {
    ::memset(&encrypt_autofill_wallet_metadata_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&encrypt_web_apps_) -
        reinterpret_cast<char*>(&encrypt_autofill_wallet_metadata_)) + sizeof(encrypt_web_apps_));
  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&encrypt_os_preferences_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&encrypt_printers_authorization_servers_) -
        reinterpret_cast<char*>(&encrypt_os_preferences_)) + sizeof(encrypt_printers_authorization_servers_));
    passphrase_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* NigoriSpecifics::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.EncryptedData encryption_keybag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_encryption_keybag(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool keybag_is_frozen = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_keybag_is_frozen(&_has_bits_);
          keybag_is_frozen_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_bookmarks = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_encrypt_bookmarks(&_has_bits_);
          encrypt_bookmarks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_preferences = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_encrypt_preferences(&_has_bits_);
          encrypt_preferences_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_autofill_profile = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_encrypt_autofill_profile(&_has_bits_);
          encrypt_autofill_profile_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_autofill = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_encrypt_autofill(&_has_bits_);
          encrypt_autofill_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_themes = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_encrypt_themes(&_has_bits_);
          encrypt_themes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_typed_urls = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_encrypt_typed_urls(&_has_bits_);
          encrypt_typed_urls_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_extensions = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_encrypt_extensions(&_has_bits_);
          encrypt_extensions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_sessions = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_encrypt_sessions(&_has_bits_);
          encrypt_sessions_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_apps = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_encrypt_apps(&_has_bits_);
          encrypt_apps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_search_engines = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_encrypt_search_engines(&_has_bits_);
          encrypt_search_engines_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_everything = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_encrypt_everything(&_has_bits_);
          encrypt_everything_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_extension_settings = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_encrypt_extension_settings(&_has_bits_);
          encrypt_extension_settings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_app_notifications = 26 [deprecated = true];
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_encrypt_app_notifications(&_has_bits_);
          encrypt_app_notifications_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_app_settings = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_encrypt_app_settings(&_has_bits_);
          encrypt_app_settings_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sync_tab_favicons = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_sync_tab_favicons(&_has_bits_);
          sync_tab_favicons_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passphrase_type = 30 [default = 1];
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          _Internal::set_has_passphrase_type(&_has_bits_);
          passphrase_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_keystore_decryptor_token(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 keystore_migration_time = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 0)) {
          _Internal::set_has_keystore_migration_time(&_has_bits_);
          keystore_migration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 custom_passphrase_time = 33;
      case 33:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_custom_passphrase_time(&_has_bits_);
          custom_passphrase_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_dictionary = 34;
      case 34:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_encrypt_dictionary(&_has_bits_);
          encrypt_dictionary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_app_list = 38;
      case 38:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_encrypt_app_list(&_has_bits_);
          encrypt_app_list_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_autofill_wallet_metadata = 39;
      case 39:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_encrypt_autofill_wallet_metadata(&_has_bits_);
          encrypt_autofill_wallet_metadata_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool server_only_was_missing_keystore_migration_time = 40;
      case 40:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_server_only_was_missing_keystore_migration_time(&_has_bits_);
          server_only_was_missing_keystore_migration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_arc_package = 41;
      case 41:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_encrypt_arc_package(&_has_bits_);
          encrypt_arc_package_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_printers = 42;
      case 42:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_encrypt_printers(&_has_bits_);
          encrypt_printers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_reading_list = 43;
      case 43:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_encrypt_reading_list(&_has_bits_);
          encrypt_reading_list_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
      case 45:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_custom_passphrase_key_derivation_method(&_has_bits_);
          custom_passphrase_key_derivation_method_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string custom_passphrase_key_derivation_salt = 46;
      case 46:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_custom_passphrase_key_derivation_salt();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_send_tab_to_self = 47;
      case 47:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_encrypt_send_tab_to_self(&_has_bits_);
          encrypt_send_tab_to_self_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_web_apps = 48;
      case 48:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_encrypt_web_apps(&_has_bits_);
          encrypt_web_apps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_os_preferences = 49;
      case 49:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_encrypt_os_preferences(&_has_bits_);
          encrypt_os_preferences_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
      case 50:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_trusted_vault_debug_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_workspace_desk = 51;
      case 51:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_encrypt_workspace_desk(&_has_bits_);
          encrypt_workspace_desk_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool encrypt_printers_authorization_servers = 52;
      case 52:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_encrypt_printers_authorization_servers(&_has_bits_);
          encrypt_printers_authorization_servers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NigoriSpecifics::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.NigoriSpecifics)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.EncryptedData encryption_keybag = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::encryption_keybag(this),
        _Internal::encryption_keybag(this).GetCachedSize(), target, stream);
  }

  // optional bool keybag_is_frozen = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_keybag_is_frozen(), target);
  }

  // optional bool encrypt_bookmarks = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(13, this->_internal_encrypt_bookmarks(), target);
  }

  // optional bool encrypt_preferences = 14;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(14, this->_internal_encrypt_preferences(), target);
  }

  // optional bool encrypt_autofill_profile = 15;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_encrypt_autofill_profile(), target);
  }

  // optional bool encrypt_autofill = 16;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_encrypt_autofill(), target);
  }

  // optional bool encrypt_themes = 17;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_encrypt_themes(), target);
  }

  // optional bool encrypt_typed_urls = 18;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_encrypt_typed_urls(), target);
  }

  // optional bool encrypt_extensions = 19;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(19, this->_internal_encrypt_extensions(), target);
  }

  // optional bool encrypt_sessions = 20;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(20, this->_internal_encrypt_sessions(), target);
  }

  // optional bool encrypt_apps = 21;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(21, this->_internal_encrypt_apps(), target);
  }

  // optional bool encrypt_search_engines = 22;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(22, this->_internal_encrypt_search_engines(), target);
  }

  // optional bool encrypt_everything = 24;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(24, this->_internal_encrypt_everything(), target);
  }

  // optional bool encrypt_extension_settings = 25;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(25, this->_internal_encrypt_extension_settings(), target);
  }

  // optional bool encrypt_app_notifications = 26 [deprecated = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(26, this->_internal_encrypt_app_notifications(), target);
  }

  // optional bool encrypt_app_settings = 27;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(27, this->_internal_encrypt_app_settings(), target);
  }

  // optional bool sync_tab_favicons = 29;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(29, this->_internal_sync_tab_favicons(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional int32 passphrase_type = 30 [default = 1];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(30, this->_internal_passphrase_type(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::keystore_decryptor_token(this),
        _Internal::keystore_decryptor_token(this).GetCachedSize(), target, stream);
  }

  // optional int64 keystore_migration_time = 32;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(32, this->_internal_keystore_migration_time(), target);
  }

  // optional int64 custom_passphrase_time = 33;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(33, this->_internal_custom_passphrase_time(), target);
  }

  // optional bool encrypt_dictionary = 34;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(34, this->_internal_encrypt_dictionary(), target);
  }

  // optional bool encrypt_app_list = 38;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(38, this->_internal_encrypt_app_list(), target);
  }

  // optional bool encrypt_autofill_wallet_metadata = 39;
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(39, this->_internal_encrypt_autofill_wallet_metadata(), target);
  }

  // optional bool server_only_was_missing_keystore_migration_time = 40;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(40, this->_internal_server_only_was_missing_keystore_migration_time(), target);
  }

  // optional bool encrypt_arc_package = 41;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(41, this->_internal_encrypt_arc_package(), target);
  }

  // optional bool encrypt_printers = 42;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(42, this->_internal_encrypt_printers(), target);
  }

  // optional bool encrypt_reading_list = 43;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(43, this->_internal_encrypt_reading_list(), target);
  }

  // optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
  if (cached_has_bits & 0x40000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(45, this->_internal_custom_passphrase_key_derivation_method(), target);
  }

  // optional string custom_passphrase_key_derivation_salt = 46;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        46, this->_internal_custom_passphrase_key_derivation_salt(), target);
  }

  // optional bool encrypt_send_tab_to_self = 47;
  if (cached_has_bits & 0x20000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(47, this->_internal_encrypt_send_tab_to_self(), target);
  }

  // optional bool encrypt_web_apps = 48;
  if (cached_has_bits & 0x80000000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(48, this->_internal_encrypt_web_apps(), target);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool encrypt_os_preferences = 49;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(49, this->_internal_encrypt_os_preferences(), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(50, _Internal::trusted_vault_debug_info(this),
        _Internal::trusted_vault_debug_info(this).GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[1];
  // optional bool encrypt_workspace_desk = 51;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(51, this->_internal_encrypt_workspace_desk(), target);
  }

  // optional bool encrypt_printers_authorization_servers = 52;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(52, this->_internal_encrypt_printers_authorization_servers(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.NigoriSpecifics)
  return target;
}

size_t NigoriSpecifics::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.NigoriSpecifics)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string custom_passphrase_key_derivation_salt = 46;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_custom_passphrase_key_derivation_salt());
    }

    // optional .sync_pb.EncryptedData encryption_keybag = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *encryption_keybag_);
    }

    // optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *keystore_decryptor_token_);
    }

    // optional .sync_pb.NigoriSpecifics.TrustedVaultDebugInfo trusted_vault_debug_info = 50;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *trusted_vault_debug_info_);
    }

    // optional bool keybag_is_frozen = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool encrypt_bookmarks = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool encrypt_preferences = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool encrypt_autofill_profile = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool encrypt_autofill = 16;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_themes = 17;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_typed_urls = 18;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_extensions = 19;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_sessions = 20;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_apps = 21;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_search_engines = 22;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_everything = 24;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool encrypt_extension_settings = 25;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_app_notifications = 26 [deprecated = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_app_settings = 27;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool sync_tab_favicons = 29;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional int64 keystore_migration_time = 32;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_keystore_migration_time());
    }

    // optional int64 custom_passphrase_time = 33;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int64Size(
          this->_internal_custom_passphrase_time());
    }

    // optional bool encrypt_dictionary = 34;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_app_list = 38;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0xff000000u) {
    // optional bool encrypt_autofill_wallet_metadata = 39;
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 + 1;
    }

    // optional bool server_only_was_missing_keystore_migration_time = 40;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_arc_package = 41;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_printers = 42;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_reading_list = 43;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_send_tab_to_self = 47;
    if (cached_has_bits & 0x20000000u) {
      total_size += 2 + 1;
    }

    // optional int32 custom_passphrase_key_derivation_method = 45 [default = 0];
    if (cached_has_bits & 0x40000000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_custom_passphrase_key_derivation_method());
    }

    // optional bool encrypt_web_apps = 48;
    if (cached_has_bits & 0x80000000u) {
      total_size += 2 + 1;
    }

  }
  cached_has_bits = _has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool encrypt_os_preferences = 49;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_workspace_desk = 51;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 + 1;
    }

    // optional bool encrypt_printers_authorization_servers = 52;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 + 1;
    }

    // optional int32 passphrase_type = 30 [default = 1];
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_passphrase_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NigoriSpecifics::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NigoriSpecifics*>(
      &from));
}

void NigoriSpecifics::MergeFrom(const NigoriSpecifics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.NigoriSpecifics)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_custom_passphrase_key_derivation_salt(from._internal_custom_passphrase_key_derivation_salt());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_encryption_keybag()->::sync_pb::EncryptedData::MergeFrom(from._internal_encryption_keybag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_keystore_decryptor_token()->::sync_pb::EncryptedData::MergeFrom(from._internal_keystore_decryptor_token());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_trusted_vault_debug_info()->::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo::MergeFrom(from._internal_trusted_vault_debug_info());
    }
    if (cached_has_bits & 0x00000010u) {
      keybag_is_frozen_ = from.keybag_is_frozen_;
    }
    if (cached_has_bits & 0x00000020u) {
      encrypt_bookmarks_ = from.encrypt_bookmarks_;
    }
    if (cached_has_bits & 0x00000040u) {
      encrypt_preferences_ = from.encrypt_preferences_;
    }
    if (cached_has_bits & 0x00000080u) {
      encrypt_autofill_profile_ = from.encrypt_autofill_profile_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      encrypt_autofill_ = from.encrypt_autofill_;
    }
    if (cached_has_bits & 0x00000200u) {
      encrypt_themes_ = from.encrypt_themes_;
    }
    if (cached_has_bits & 0x00000400u) {
      encrypt_typed_urls_ = from.encrypt_typed_urls_;
    }
    if (cached_has_bits & 0x00000800u) {
      encrypt_extensions_ = from.encrypt_extensions_;
    }
    if (cached_has_bits & 0x00001000u) {
      encrypt_sessions_ = from.encrypt_sessions_;
    }
    if (cached_has_bits & 0x00002000u) {
      encrypt_apps_ = from.encrypt_apps_;
    }
    if (cached_has_bits & 0x00004000u) {
      encrypt_search_engines_ = from.encrypt_search_engines_;
    }
    if (cached_has_bits & 0x00008000u) {
      encrypt_everything_ = from.encrypt_everything_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      encrypt_extension_settings_ = from.encrypt_extension_settings_;
    }
    if (cached_has_bits & 0x00020000u) {
      encrypt_app_notifications_ = from.encrypt_app_notifications_;
    }
    if (cached_has_bits & 0x00040000u) {
      encrypt_app_settings_ = from.encrypt_app_settings_;
    }
    if (cached_has_bits & 0x00080000u) {
      sync_tab_favicons_ = from.sync_tab_favicons_;
    }
    if (cached_has_bits & 0x00100000u) {
      keystore_migration_time_ = from.keystore_migration_time_;
    }
    if (cached_has_bits & 0x00200000u) {
      custom_passphrase_time_ = from.custom_passphrase_time_;
    }
    if (cached_has_bits & 0x00400000u) {
      encrypt_dictionary_ = from.encrypt_dictionary_;
    }
    if (cached_has_bits & 0x00800000u) {
      encrypt_app_list_ = from.encrypt_app_list_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0xff000000u) {
    if (cached_has_bits & 0x01000000u) {
      encrypt_autofill_wallet_metadata_ = from.encrypt_autofill_wallet_metadata_;
    }
    if (cached_has_bits & 0x02000000u) {
      server_only_was_missing_keystore_migration_time_ = from.server_only_was_missing_keystore_migration_time_;
    }
    if (cached_has_bits & 0x04000000u) {
      encrypt_arc_package_ = from.encrypt_arc_package_;
    }
    if (cached_has_bits & 0x08000000u) {
      encrypt_printers_ = from.encrypt_printers_;
    }
    if (cached_has_bits & 0x10000000u) {
      encrypt_reading_list_ = from.encrypt_reading_list_;
    }
    if (cached_has_bits & 0x20000000u) {
      encrypt_send_tab_to_self_ = from.encrypt_send_tab_to_self_;
    }
    if (cached_has_bits & 0x40000000u) {
      custom_passphrase_key_derivation_method_ = from.custom_passphrase_key_derivation_method_;
    }
    if (cached_has_bits & 0x80000000u) {
      encrypt_web_apps_ = from.encrypt_web_apps_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  cached_has_bits = from._has_bits_[1];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      encrypt_os_preferences_ = from.encrypt_os_preferences_;
    }
    if (cached_has_bits & 0x00000002u) {
      encrypt_workspace_desk_ = from.encrypt_workspace_desk_;
    }
    if (cached_has_bits & 0x00000004u) {
      encrypt_printers_authorization_servers_ = from.encrypt_printers_authorization_servers_;
    }
    if (cached_has_bits & 0x00000008u) {
      passphrase_type_ = from.passphrase_type_;
    }
    _has_bits_[1] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NigoriSpecifics::CopyFrom(const NigoriSpecifics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.NigoriSpecifics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NigoriSpecifics::IsInitialized() const {
  return true;
}

void NigoriSpecifics::InternalSwap(NigoriSpecifics* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(_has_bits_[1], other->_has_bits_[1]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &custom_passphrase_key_derivation_salt_, lhs_arena,
      &other->custom_passphrase_key_derivation_salt_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NigoriSpecifics, encrypt_printers_authorization_servers_)
      + sizeof(NigoriSpecifics::encrypt_printers_authorization_servers_)
      - PROTOBUF_FIELD_OFFSET(NigoriSpecifics, encryption_keybag_)>(
          reinterpret_cast<char*>(&encryption_keybag_),
          reinterpret_cast<char*>(&other->encryption_keybag_));
  swap(passphrase_type_, other->passphrase_type_);
}

std::string NigoriSpecifics::GetTypeName() const {
  return "sync_pb.NigoriSpecifics";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sync_pb::NigoriKey*
Arena::CreateMaybeMessage< ::sync_pb::NigoriKey >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::NigoriKey >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::NigoriKeyBag*
Arena::CreateMaybeMessage< ::sync_pb::NigoriKeyBag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::NigoriKeyBag >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo*
Arena::CreateMaybeMessage< ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::NigoriSpecifics_TrustedVaultDebugInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::NigoriSpecifics*
Arena::CreateMaybeMessage< ::sync_pb::NigoriSpecifics >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::NigoriSpecifics >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
