// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/session_specifics.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/sync_enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto {
  static const uint32_t offsets[];
};
namespace sync_pb {
class NavigationRedirect;
struct NavigationRedirectDefaultTypeInternal;
extern NavigationRedirectDefaultTypeInternal _NavigationRedirect_default_instance_;
class ReplacedNavigation;
struct ReplacedNavigationDefaultTypeInternal;
extern ReplacedNavigationDefaultTypeInternal _ReplacedNavigation_default_instance_;
class SessionHeader;
struct SessionHeaderDefaultTypeInternal;
extern SessionHeaderDefaultTypeInternal _SessionHeader_default_instance_;
class SessionSpecifics;
struct SessionSpecificsDefaultTypeInternal;
extern SessionSpecificsDefaultTypeInternal _SessionSpecifics_default_instance_;
class SessionTab;
struct SessionTabDefaultTypeInternal;
extern SessionTabDefaultTypeInternal _SessionTab_default_instance_;
class SessionWindow;
struct SessionWindowDefaultTypeInternal;
extern SessionWindowDefaultTypeInternal _SessionWindow_default_instance_;
class TabNavigation;
struct TabNavigationDefaultTypeInternal;
extern TabNavigationDefaultTypeInternal _TabNavigation_default_instance_;
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::sync_pb::NavigationRedirect* Arena::CreateMaybeMessage<::sync_pb::NavigationRedirect>(Arena*);
template<> ::sync_pb::ReplacedNavigation* Arena::CreateMaybeMessage<::sync_pb::ReplacedNavigation>(Arena*);
template<> ::sync_pb::SessionHeader* Arena::CreateMaybeMessage<::sync_pb::SessionHeader>(Arena*);
template<> ::sync_pb::SessionSpecifics* Arena::CreateMaybeMessage<::sync_pb::SessionSpecifics>(Arena*);
template<> ::sync_pb::SessionTab* Arena::CreateMaybeMessage<::sync_pb::SessionTab>(Arena*);
template<> ::sync_pb::SessionWindow* Arena::CreateMaybeMessage<::sync_pb::SessionWindow>(Arena*);
template<> ::sync_pb::TabNavigation* Arena::CreateMaybeMessage<::sync_pb::TabNavigation>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum SessionTab_FaviconType : int {
  SessionTab_FaviconType_TYPE_WEB_FAVICON = 1
};
bool SessionTab_FaviconType_IsValid(int value);
constexpr SessionTab_FaviconType SessionTab_FaviconType_FaviconType_MIN = SessionTab_FaviconType_TYPE_WEB_FAVICON;
constexpr SessionTab_FaviconType SessionTab_FaviconType_FaviconType_MAX = SessionTab_FaviconType_TYPE_WEB_FAVICON;
constexpr int SessionTab_FaviconType_FaviconType_ARRAYSIZE = SessionTab_FaviconType_FaviconType_MAX + 1;

const std::string& SessionTab_FaviconType_Name(SessionTab_FaviconType value);
template<typename T>
inline const std::string& SessionTab_FaviconType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SessionTab_FaviconType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SessionTab_FaviconType_Name.");
  return SessionTab_FaviconType_Name(static_cast<SessionTab_FaviconType>(enum_t_value));
}
bool SessionTab_FaviconType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SessionTab_FaviconType* value);
enum TabNavigation_BlockedState : int {
  TabNavigation_BlockedState_STATE_ALLOWED = 1,
  TabNavigation_BlockedState_STATE_BLOCKED = 2
};
bool TabNavigation_BlockedState_IsValid(int value);
constexpr TabNavigation_BlockedState TabNavigation_BlockedState_BlockedState_MIN = TabNavigation_BlockedState_STATE_ALLOWED;
constexpr TabNavigation_BlockedState TabNavigation_BlockedState_BlockedState_MAX = TabNavigation_BlockedState_STATE_BLOCKED;
constexpr int TabNavigation_BlockedState_BlockedState_ARRAYSIZE = TabNavigation_BlockedState_BlockedState_MAX + 1;

const std::string& TabNavigation_BlockedState_Name(TabNavigation_BlockedState value);
template<typename T>
inline const std::string& TabNavigation_BlockedState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TabNavigation_BlockedState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TabNavigation_BlockedState_Name.");
  return TabNavigation_BlockedState_Name(static_cast<TabNavigation_BlockedState>(enum_t_value));
}
bool TabNavigation_BlockedState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TabNavigation_BlockedState* value);
enum TabNavigation_PasswordState : int {
  TabNavigation_PasswordState_PASSWORD_STATE_UNKNOWN = 0,
  TabNavigation_PasswordState_NO_PASSWORD_FIELD = 1,
  TabNavigation_PasswordState_HAS_PASSWORD_FIELD = 2
};
bool TabNavigation_PasswordState_IsValid(int value);
constexpr TabNavigation_PasswordState TabNavigation_PasswordState_PasswordState_MIN = TabNavigation_PasswordState_PASSWORD_STATE_UNKNOWN;
constexpr TabNavigation_PasswordState TabNavigation_PasswordState_PasswordState_MAX = TabNavigation_PasswordState_HAS_PASSWORD_FIELD;
constexpr int TabNavigation_PasswordState_PasswordState_ARRAYSIZE = TabNavigation_PasswordState_PasswordState_MAX + 1;

const std::string& TabNavigation_PasswordState_Name(TabNavigation_PasswordState value);
template<typename T>
inline const std::string& TabNavigation_PasswordState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TabNavigation_PasswordState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TabNavigation_PasswordState_Name.");
  return TabNavigation_PasswordState_Name(static_cast<TabNavigation_PasswordState>(enum_t_value));
}
bool TabNavigation_PasswordState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TabNavigation_PasswordState* value);
// ===================================================================

class SessionSpecifics final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionSpecifics) */ {
 public:
  inline SessionSpecifics() : SessionSpecifics(nullptr) {}
  ~SessionSpecifics() override;
  explicit PROTOBUF_CONSTEXPR SessionSpecifics(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionSpecifics(const SessionSpecifics& from);
  SessionSpecifics(SessionSpecifics&& from) noexcept
    : SessionSpecifics() {
    *this = ::std::move(from);
  }

  inline SessionSpecifics& operator=(const SessionSpecifics& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionSpecifics& operator=(SessionSpecifics&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionSpecifics& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionSpecifics* internal_default_instance() {
    return reinterpret_cast<const SessionSpecifics*>(
               &_SessionSpecifics_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SessionSpecifics& a, SessionSpecifics& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SessionSpecifics* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionSpecifics* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionSpecifics* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionSpecifics>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionSpecifics& from);
  void MergeFrom(const SessionSpecifics& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionSpecifics* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.SessionSpecifics";
  }
  protected:
  explicit SessionSpecifics(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSessionTagFieldNumber = 1,
    kHeaderFieldNumber = 2,
    kTabFieldNumber = 3,
    kTabNodeIdFieldNumber = 4,
  };
  // optional string session_tag = 1;
  bool has_session_tag() const;
  private:
  bool _internal_has_session_tag() const;
  public:
  void clear_session_tag();
  const std::string& session_tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_session_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_session_tag();
  PROTOBUF_NODISCARD std::string* release_session_tag();
  void set_allocated_session_tag(std::string* session_tag);
  private:
  const std::string& _internal_session_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_session_tag(const std::string& value);
  std::string* _internal_mutable_session_tag();
  public:

  // optional .sync_pb.SessionHeader header = 2;
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const ::sync_pb::SessionHeader& header() const;
  PROTOBUF_NODISCARD ::sync_pb::SessionHeader* release_header();
  ::sync_pb::SessionHeader* mutable_header();
  void set_allocated_header(::sync_pb::SessionHeader* header);
  private:
  const ::sync_pb::SessionHeader& _internal_header() const;
  ::sync_pb::SessionHeader* _internal_mutable_header();
  public:
  void unsafe_arena_set_allocated_header(
      ::sync_pb::SessionHeader* header);
  ::sync_pb::SessionHeader* unsafe_arena_release_header();

  // optional .sync_pb.SessionTab tab = 3;
  bool has_tab() const;
  private:
  bool _internal_has_tab() const;
  public:
  void clear_tab();
  const ::sync_pb::SessionTab& tab() const;
  PROTOBUF_NODISCARD ::sync_pb::SessionTab* release_tab();
  ::sync_pb::SessionTab* mutable_tab();
  void set_allocated_tab(::sync_pb::SessionTab* tab);
  private:
  const ::sync_pb::SessionTab& _internal_tab() const;
  ::sync_pb::SessionTab* _internal_mutable_tab();
  public:
  void unsafe_arena_set_allocated_tab(
      ::sync_pb::SessionTab* tab);
  ::sync_pb::SessionTab* unsafe_arena_release_tab();

  // optional int32 tab_node_id = 4 [default = -1];
  bool has_tab_node_id() const;
  private:
  bool _internal_has_tab_node_id() const;
  public:
  void clear_tab_node_id();
  int32_t tab_node_id() const;
  void set_tab_node_id(int32_t value);
  private:
  int32_t _internal_tab_node_id() const;
  void _internal_set_tab_node_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.SessionSpecifics)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr session_tag_;
  ::sync_pb::SessionHeader* header_;
  ::sync_pb::SessionTab* tab_;
  int32_t tab_node_id_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SessionHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionHeader) */ {
 public:
  inline SessionHeader() : SessionHeader(nullptr) {}
  ~SessionHeader() override;
  explicit PROTOBUF_CONSTEXPR SessionHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionHeader(const SessionHeader& from);
  SessionHeader(SessionHeader&& from) noexcept
    : SessionHeader() {
    *this = ::std::move(from);
  }

  inline SessionHeader& operator=(const SessionHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionHeader& operator=(SessionHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionHeader* internal_default_instance() {
    return reinterpret_cast<const SessionHeader*>(
               &_SessionHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SessionHeader& a, SessionHeader& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SessionHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionHeader& from);
  void MergeFrom(const SessionHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.SessionHeader";
  }
  protected:
  explicit SessionHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWindowFieldNumber = 2,
    kClientNameFieldNumber = 3,
    kDeviceTypeFieldNumber = 4,
  };
  // repeated .sync_pb.SessionWindow window = 2;
  int window_size() const;
  private:
  int _internal_window_size() const;
  public:
  void clear_window();
  ::sync_pb::SessionWindow* mutable_window(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SessionWindow >*
      mutable_window();
  private:
  const ::sync_pb::SessionWindow& _internal_window(int index) const;
  ::sync_pb::SessionWindow* _internal_add_window();
  public:
  const ::sync_pb::SessionWindow& window(int index) const;
  ::sync_pb::SessionWindow* add_window();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SessionWindow >&
      window() const;

  // optional string client_name = 3;
  bool has_client_name() const;
  private:
  bool _internal_has_client_name() const;
  public:
  void clear_client_name();
  const std::string& client_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_client_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_client_name();
  PROTOBUF_NODISCARD std::string* release_client_name();
  void set_allocated_client_name(std::string* client_name);
  private:
  const std::string& _internal_client_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_client_name(const std::string& value);
  std::string* _internal_mutable_client_name();
  public:

  // optional .sync_pb.SyncEnums.DeviceType device_type = 4;
  bool has_device_type() const;
  private:
  bool _internal_has_device_type() const;
  public:
  void clear_device_type();
  ::sync_pb::SyncEnums_DeviceType device_type() const;
  void set_device_type(::sync_pb::SyncEnums_DeviceType value);
  private:
  ::sync_pb::SyncEnums_DeviceType _internal_device_type() const;
  void _internal_set_device_type(::sync_pb::SyncEnums_DeviceType value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.SessionHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SessionWindow > window_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr client_name_;
  int device_type_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SessionWindow final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionWindow) */ {
 public:
  inline SessionWindow() : SessionWindow(nullptr) {}
  ~SessionWindow() override;
  explicit PROTOBUF_CONSTEXPR SessionWindow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionWindow(const SessionWindow& from);
  SessionWindow(SessionWindow&& from) noexcept
    : SessionWindow() {
    *this = ::std::move(from);
  }

  inline SessionWindow& operator=(const SessionWindow& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionWindow& operator=(SessionWindow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionWindow& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionWindow* internal_default_instance() {
    return reinterpret_cast<const SessionWindow*>(
               &_SessionWindow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SessionWindow& a, SessionWindow& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SessionWindow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionWindow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionWindow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionWindow>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionWindow& from);
  void MergeFrom(const SessionWindow& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionWindow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.SessionWindow";
  }
  protected:
  explicit SessionWindow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTabFieldNumber = 4,
    kWindowIdFieldNumber = 1,
    kSelectedTabIndexFieldNumber = 2,
    kBrowserTypeFieldNumber = 3,
  };
  // repeated int32 tab = 4;
  int tab_size() const;
  private:
  int _internal_tab_size() const;
  public:
  void clear_tab();
  private:
  int32_t _internal_tab(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_tab() const;
  void _internal_add_tab(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_tab();
  public:
  int32_t tab(int index) const;
  void set_tab(int index, int32_t value);
  void add_tab(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      tab() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_tab();

  // optional int32 window_id = 1;
  bool has_window_id() const;
  private:
  bool _internal_has_window_id() const;
  public:
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // optional int32 selected_tab_index = 2 [default = -1];
  bool has_selected_tab_index() const;
  private:
  bool _internal_has_selected_tab_index() const;
  public:
  void clear_selected_tab_index();
  int32_t selected_tab_index() const;
  void set_selected_tab_index(int32_t value);
  private:
  int32_t _internal_selected_tab_index() const;
  void _internal_set_selected_tab_index(int32_t value);
  public:

  // optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
  bool has_browser_type() const;
  private:
  bool _internal_has_browser_type() const;
  public:
  void clear_browser_type();
  ::sync_pb::SyncEnums_BrowserType browser_type() const;
  void set_browser_type(::sync_pb::SyncEnums_BrowserType value);
  private:
  ::sync_pb::SyncEnums_BrowserType _internal_browser_type() const;
  void _internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.SessionWindow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > tab_;
  int32_t window_id_;
  int32_t selected_tab_index_;
  int browser_type_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class SessionTab final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SessionTab) */ {
 public:
  inline SessionTab() : SessionTab(nullptr) {}
  ~SessionTab() override;
  explicit PROTOBUF_CONSTEXPR SessionTab(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SessionTab(const SessionTab& from);
  SessionTab(SessionTab&& from) noexcept
    : SessionTab() {
    *this = ::std::move(from);
  }

  inline SessionTab& operator=(const SessionTab& from) {
    CopyFrom(from);
    return *this;
  }
  inline SessionTab& operator=(SessionTab&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SessionTab& default_instance() {
    return *internal_default_instance();
  }
  static inline const SessionTab* internal_default_instance() {
    return reinterpret_cast<const SessionTab*>(
               &_SessionTab_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SessionTab& a, SessionTab& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SessionTab* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SessionTab* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SessionTab* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SessionTab>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SessionTab& from);
  void MergeFrom(const SessionTab& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SessionTab* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.SessionTab";
  }
  protected:
  explicit SessionTab(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef SessionTab_FaviconType FaviconType;
  static constexpr FaviconType TYPE_WEB_FAVICON =
    SessionTab_FaviconType_TYPE_WEB_FAVICON;
  static inline bool FaviconType_IsValid(int value) {
    return SessionTab_FaviconType_IsValid(value);
  }
  static constexpr FaviconType FaviconType_MIN =
    SessionTab_FaviconType_FaviconType_MIN;
  static constexpr FaviconType FaviconType_MAX =
    SessionTab_FaviconType_FaviconType_MAX;
  static constexpr int FaviconType_ARRAYSIZE =
    SessionTab_FaviconType_FaviconType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& FaviconType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FaviconType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FaviconType_Name.");
    return SessionTab_FaviconType_Name(enum_t_value);
  }
  static inline bool FaviconType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FaviconType* value) {
    return SessionTab_FaviconType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNavigationFieldNumber = 7,
    kVariationIdFieldNumber = 12,
    kExtensionAppIdFieldNumber = 6,
    kFaviconFieldNumber = 8,
    kFaviconSourceFieldNumber = 11,
    kWindowIdFieldNumber = 2,
    kPinnedFieldNumber = 5,
    kBrowserTypeFieldNumber = 13,
    kTabIdFieldNumber = 1,
    kTabVisualIndexFieldNumber = 3,
    kCurrentNavigationIndexFieldNumber = 4,
    kFaviconTypeFieldNumber = 9,
  };
  // repeated .sync_pb.TabNavigation navigation = 7;
  int navigation_size() const;
  private:
  int _internal_navigation_size() const;
  public:
  void clear_navigation();
  ::sync_pb::TabNavigation* mutable_navigation(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::TabNavigation >*
      mutable_navigation();
  private:
  const ::sync_pb::TabNavigation& _internal_navigation(int index) const;
  ::sync_pb::TabNavigation* _internal_add_navigation();
  public:
  const ::sync_pb::TabNavigation& navigation(int index) const;
  ::sync_pb::TabNavigation* add_navigation();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::TabNavigation >&
      navigation() const;

  // repeated uint64 variation_id = 12 [deprecated = true];
  PROTOBUF_DEPRECATED int variation_id_size() const;
  private:
  int _internal_variation_id_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_variation_id();
  private:
  uint64_t _internal_variation_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_variation_id() const;
  void _internal_add_variation_id(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_variation_id();
  public:
  PROTOBUF_DEPRECATED uint64_t variation_id(int index) const;
  PROTOBUF_DEPRECATED void set_variation_id(int index, uint64_t value);
  PROTOBUF_DEPRECATED void add_variation_id(uint64_t value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      variation_id() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_variation_id();

  // optional string extension_app_id = 6;
  bool has_extension_app_id() const;
  private:
  bool _internal_has_extension_app_id() const;
  public:
  void clear_extension_app_id();
  const std::string& extension_app_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_app_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_app_id();
  PROTOBUF_NODISCARD std::string* release_extension_app_id();
  void set_allocated_extension_app_id(std::string* extension_app_id);
  private:
  const std::string& _internal_extension_app_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_app_id(const std::string& value);
  std::string* _internal_mutable_extension_app_id();
  public:

  // optional bytes favicon = 8 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_favicon() const;
  private:
  bool _internal_has_favicon() const;
  public:
  PROTOBUF_DEPRECATED void clear_favicon();
  PROTOBUF_DEPRECATED const std::string& favicon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_favicon(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_favicon();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_favicon();
  PROTOBUF_DEPRECATED void set_allocated_favicon(std::string* favicon);
  private:
  const std::string& _internal_favicon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon(const std::string& value);
  std::string* _internal_mutable_favicon();
  public:

  // optional string favicon_source = 11 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_favicon_source() const;
  private:
  bool _internal_has_favicon_source() const;
  public:
  PROTOBUF_DEPRECATED void clear_favicon_source();
  PROTOBUF_DEPRECATED const std::string& favicon_source() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_favicon_source(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_favicon_source();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_favicon_source();
  PROTOBUF_DEPRECATED void set_allocated_favicon_source(std::string* favicon_source);
  private:
  const std::string& _internal_favicon_source() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon_source(const std::string& value);
  std::string* _internal_mutable_favicon_source();
  public:

  // optional int32 window_id = 2;
  bool has_window_id() const;
  private:
  bool _internal_has_window_id() const;
  public:
  void clear_window_id();
  int32_t window_id() const;
  void set_window_id(int32_t value);
  private:
  int32_t _internal_window_id() const;
  void _internal_set_window_id(int32_t value);
  public:

  // optional bool pinned = 5 [default = false];
  bool has_pinned() const;
  private:
  bool _internal_has_pinned() const;
  public:
  void clear_pinned();
  bool pinned() const;
  void set_pinned(bool value);
  private:
  bool _internal_pinned() const;
  void _internal_set_pinned(bool value);
  public:

  // optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
  bool has_browser_type() const;
  private:
  bool _internal_has_browser_type() const;
  public:
  void clear_browser_type();
  ::sync_pb::SyncEnums_BrowserType browser_type() const;
  void set_browser_type(::sync_pb::SyncEnums_BrowserType value);
  private:
  ::sync_pb::SyncEnums_BrowserType _internal_browser_type() const;
  void _internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value);
  public:

  // optional int32 tab_id = 1 [default = -1];
  bool has_tab_id() const;
  private:
  bool _internal_has_tab_id() const;
  public:
  void clear_tab_id();
  int32_t tab_id() const;
  void set_tab_id(int32_t value);
  private:
  int32_t _internal_tab_id() const;
  void _internal_set_tab_id(int32_t value);
  public:

  // optional int32 tab_visual_index = 3 [default = -1];
  bool has_tab_visual_index() const;
  private:
  bool _internal_has_tab_visual_index() const;
  public:
  void clear_tab_visual_index();
  int32_t tab_visual_index() const;
  void set_tab_visual_index(int32_t value);
  private:
  int32_t _internal_tab_visual_index() const;
  void _internal_set_tab_visual_index(int32_t value);
  public:

  // optional int32 current_navigation_index = 4 [default = -1];
  bool has_current_navigation_index() const;
  private:
  bool _internal_has_current_navigation_index() const;
  public:
  void clear_current_navigation_index();
  int32_t current_navigation_index() const;
  void set_current_navigation_index(int32_t value);
  private:
  int32_t _internal_current_navigation_index() const;
  void _internal_set_current_navigation_index(int32_t value);
  public:

  // optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_favicon_type() const;
  private:
  bool _internal_has_favicon_type() const;
  public:
  PROTOBUF_DEPRECATED void clear_favicon_type();
  PROTOBUF_DEPRECATED ::sync_pb::SessionTab_FaviconType favicon_type() const;
  PROTOBUF_DEPRECATED void set_favicon_type(::sync_pb::SessionTab_FaviconType value);
  private:
  ::sync_pb::SessionTab_FaviconType _internal_favicon_type() const;
  void _internal_set_favicon_type(::sync_pb::SessionTab_FaviconType value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.SessionTab)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::TabNavigation > navigation_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > variation_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_app_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_source_;
  int32_t window_id_;
  bool pinned_;
  int browser_type_;
  int32_t tab_id_;
  int32_t tab_visual_index_;
  int32_t current_navigation_index_;
  int favicon_type_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class TabNavigation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.TabNavigation) */ {
 public:
  inline TabNavigation() : TabNavigation(nullptr) {}
  ~TabNavigation() override;
  explicit PROTOBUF_CONSTEXPR TabNavigation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TabNavigation(const TabNavigation& from);
  TabNavigation(TabNavigation&& from) noexcept
    : TabNavigation() {
    *this = ::std::move(from);
  }

  inline TabNavigation& operator=(const TabNavigation& from) {
    CopyFrom(from);
    return *this;
  }
  inline TabNavigation& operator=(TabNavigation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TabNavigation& default_instance() {
    return *internal_default_instance();
  }
  static inline const TabNavigation* internal_default_instance() {
    return reinterpret_cast<const TabNavigation*>(
               &_TabNavigation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TabNavigation& a, TabNavigation& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TabNavigation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TabNavigation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TabNavigation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TabNavigation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TabNavigation& from);
  void MergeFrom(const TabNavigation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TabNavigation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.TabNavigation";
  }
  protected:
  explicit TabNavigation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef TabNavigation_BlockedState BlockedState;
  static constexpr BlockedState STATE_ALLOWED =
    TabNavigation_BlockedState_STATE_ALLOWED;
  static constexpr BlockedState STATE_BLOCKED =
    TabNavigation_BlockedState_STATE_BLOCKED;
  static inline bool BlockedState_IsValid(int value) {
    return TabNavigation_BlockedState_IsValid(value);
  }
  static constexpr BlockedState BlockedState_MIN =
    TabNavigation_BlockedState_BlockedState_MIN;
  static constexpr BlockedState BlockedState_MAX =
    TabNavigation_BlockedState_BlockedState_MAX;
  static constexpr int BlockedState_ARRAYSIZE =
    TabNavigation_BlockedState_BlockedState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& BlockedState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, BlockedState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function BlockedState_Name.");
    return TabNavigation_BlockedState_Name(enum_t_value);
  }
  static inline bool BlockedState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      BlockedState* value) {
    return TabNavigation_BlockedState_Parse(name, value);
  }

  typedef TabNavigation_PasswordState PasswordState;
  static constexpr PasswordState PASSWORD_STATE_UNKNOWN =
    TabNavigation_PasswordState_PASSWORD_STATE_UNKNOWN;
  static constexpr PasswordState NO_PASSWORD_FIELD =
    TabNavigation_PasswordState_NO_PASSWORD_FIELD;
  static constexpr PasswordState HAS_PASSWORD_FIELD =
    TabNavigation_PasswordState_HAS_PASSWORD_FIELD;
  static inline bool PasswordState_IsValid(int value) {
    return TabNavigation_PasswordState_IsValid(value);
  }
  static constexpr PasswordState PasswordState_MIN =
    TabNavigation_PasswordState_PasswordState_MIN;
  static constexpr PasswordState PasswordState_MAX =
    TabNavigation_PasswordState_PasswordState_MAX;
  static constexpr int PasswordState_ARRAYSIZE =
    TabNavigation_PasswordState_PasswordState_ARRAYSIZE;
  template<typename T>
  static inline const std::string& PasswordState_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PasswordState>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PasswordState_Name.");
    return TabNavigation_PasswordState_Name(enum_t_value);
  }
  static inline bool PasswordState_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PasswordState* value) {
    return TabNavigation_PasswordState_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNavigationRedirectFieldNumber = 23,
    kAncestorTaskIdFieldNumber = 28,
    kVirtualUrlFieldNumber = 2,
    kReferrerFieldNumber = 3,
    kTitleFieldNumber = 4,
    kSearchTermsFieldNumber = 16,
    kFaviconUrlFieldNumber = 17,
    kLastNavigationRedirectUrlFieldNumber = 24,
    kPageLanguageFieldNumber = 30,
    kReplacedNavigationFieldNumber = 29,
    kPageTransitionFieldNumber = 6,
    kUniqueIdFieldNumber = 8,
    kTimestampMsecFieldNumber = 9,
    kNavigationForwardBackFieldNumber = 10,
    kNavigationFromAddressBarFieldNumber = 11,
    kNavigationHomePageFieldNumber = 12,
    kNavigationChainStartFieldNumber = 13,
    kNavigationChainEndFieldNumber = 14,
    kIsRestoredFieldNumber = 22,
    kGlobalIdFieldNumber = 15,
    kHttpStatusCodeFieldNumber = 20,
    kObsoleteReferrerPolicyFieldNumber = 21,
    kTaskIdFieldNumber = 27,
    kPasswordStateFieldNumber = 26,
    kCorrectReferrerPolicyFieldNumber = 25,
    kRedirectTypeFieldNumber = 7,
    kBlockedStateFieldNumber = 18,
  };
  // repeated .sync_pb.NavigationRedirect navigation_redirect = 23;
  int navigation_redirect_size() const;
  private:
  int _internal_navigation_redirect_size() const;
  public:
  void clear_navigation_redirect();
  ::sync_pb::NavigationRedirect* mutable_navigation_redirect(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NavigationRedirect >*
      mutable_navigation_redirect();
  private:
  const ::sync_pb::NavigationRedirect& _internal_navigation_redirect(int index) const;
  ::sync_pb::NavigationRedirect* _internal_add_navigation_redirect();
  public:
  const ::sync_pb::NavigationRedirect& navigation_redirect(int index) const;
  ::sync_pb::NavigationRedirect* add_navigation_redirect();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NavigationRedirect >&
      navigation_redirect() const;

  // repeated int64 ancestor_task_id = 28;
  int ancestor_task_id_size() const;
  private:
  int _internal_ancestor_task_id_size() const;
  public:
  void clear_ancestor_task_id();
  private:
  int64_t _internal_ancestor_task_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_ancestor_task_id() const;
  void _internal_add_ancestor_task_id(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_ancestor_task_id();
  public:
  int64_t ancestor_task_id(int index) const;
  void set_ancestor_task_id(int index, int64_t value);
  void add_ancestor_task_id(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      ancestor_task_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_ancestor_task_id();

  // optional string virtual_url = 2;
  bool has_virtual_url() const;
  private:
  bool _internal_has_virtual_url() const;
  public:
  void clear_virtual_url();
  const std::string& virtual_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_virtual_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_virtual_url();
  PROTOBUF_NODISCARD std::string* release_virtual_url();
  void set_allocated_virtual_url(std::string* virtual_url);
  private:
  const std::string& _internal_virtual_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_virtual_url(const std::string& value);
  std::string* _internal_mutable_virtual_url();
  public:

  // optional string referrer = 3;
  bool has_referrer() const;
  private:
  bool _internal_has_referrer() const;
  public:
  void clear_referrer();
  const std::string& referrer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referrer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referrer();
  PROTOBUF_NODISCARD std::string* release_referrer();
  void set_allocated_referrer(std::string* referrer);
  private:
  const std::string& _internal_referrer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referrer(const std::string& value);
  std::string* _internal_mutable_referrer();
  public:

  // optional string title = 4;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string search_terms = 16 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_search_terms() const;
  private:
  bool _internal_has_search_terms() const;
  public:
  PROTOBUF_DEPRECATED void clear_search_terms();
  PROTOBUF_DEPRECATED const std::string& search_terms() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  PROTOBUF_DEPRECATED void set_search_terms(ArgT0&& arg0, ArgT... args);
  PROTOBUF_DEPRECATED std::string* mutable_search_terms();
  PROTOBUF_NODISCARD PROTOBUF_DEPRECATED std::string* release_search_terms();
  PROTOBUF_DEPRECATED void set_allocated_search_terms(std::string* search_terms);
  private:
  const std::string& _internal_search_terms() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_search_terms(const std::string& value);
  std::string* _internal_mutable_search_terms();
  public:

  // optional string favicon_url = 17;
  bool has_favicon_url() const;
  private:
  bool _internal_has_favicon_url() const;
  public:
  void clear_favicon_url();
  const std::string& favicon_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_favicon_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_favicon_url();
  PROTOBUF_NODISCARD std::string* release_favicon_url();
  void set_allocated_favicon_url(std::string* favicon_url);
  private:
  const std::string& _internal_favicon_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_favicon_url(const std::string& value);
  std::string* _internal_mutable_favicon_url();
  public:

  // optional string last_navigation_redirect_url = 24;
  bool has_last_navigation_redirect_url() const;
  private:
  bool _internal_has_last_navigation_redirect_url() const;
  public:
  void clear_last_navigation_redirect_url();
  const std::string& last_navigation_redirect_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_navigation_redirect_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_navigation_redirect_url();
  PROTOBUF_NODISCARD std::string* release_last_navigation_redirect_url();
  void set_allocated_last_navigation_redirect_url(std::string* last_navigation_redirect_url);
  private:
  const std::string& _internal_last_navigation_redirect_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_navigation_redirect_url(const std::string& value);
  std::string* _internal_mutable_last_navigation_redirect_url();
  public:

  // optional string page_language = 30;
  bool has_page_language() const;
  private:
  bool _internal_has_page_language() const;
  public:
  void clear_page_language();
  const std::string& page_language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_language();
  PROTOBUF_NODISCARD std::string* release_page_language();
  void set_allocated_page_language(std::string* page_language);
  private:
  const std::string& _internal_page_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_language(const std::string& value);
  std::string* _internal_mutable_page_language();
  public:

  // optional .sync_pb.ReplacedNavigation replaced_navigation = 29;
  bool has_replaced_navigation() const;
  private:
  bool _internal_has_replaced_navigation() const;
  public:
  void clear_replaced_navigation();
  const ::sync_pb::ReplacedNavigation& replaced_navigation() const;
  PROTOBUF_NODISCARD ::sync_pb::ReplacedNavigation* release_replaced_navigation();
  ::sync_pb::ReplacedNavigation* mutable_replaced_navigation();
  void set_allocated_replaced_navigation(::sync_pb::ReplacedNavigation* replaced_navigation);
  private:
  const ::sync_pb::ReplacedNavigation& _internal_replaced_navigation() const;
  ::sync_pb::ReplacedNavigation* _internal_mutable_replaced_navigation();
  public:
  void unsafe_arena_set_allocated_replaced_navigation(
      ::sync_pb::ReplacedNavigation* replaced_navigation);
  ::sync_pb::ReplacedNavigation* unsafe_arena_release_replaced_navigation();

  // optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
  bool has_page_transition() const;
  private:
  bool _internal_has_page_transition() const;
  public:
  void clear_page_transition();
  ::sync_pb::SyncEnums_PageTransition page_transition() const;
  void set_page_transition(::sync_pb::SyncEnums_PageTransition value);
  private:
  ::sync_pb::SyncEnums_PageTransition _internal_page_transition() const;
  void _internal_set_page_transition(::sync_pb::SyncEnums_PageTransition value);
  public:

  // optional int32 unique_id = 8;
  bool has_unique_id() const;
  private:
  bool _internal_has_unique_id() const;
  public:
  void clear_unique_id();
  int32_t unique_id() const;
  void set_unique_id(int32_t value);
  private:
  int32_t _internal_unique_id() const;
  void _internal_set_unique_id(int32_t value);
  public:

  // optional int64 timestamp_msec = 9;
  bool has_timestamp_msec() const;
  private:
  bool _internal_has_timestamp_msec() const;
  public:
  void clear_timestamp_msec();
  int64_t timestamp_msec() const;
  void set_timestamp_msec(int64_t value);
  private:
  int64_t _internal_timestamp_msec() const;
  void _internal_set_timestamp_msec(int64_t value);
  public:

  // optional bool navigation_forward_back = 10;
  bool has_navigation_forward_back() const;
  private:
  bool _internal_has_navigation_forward_back() const;
  public:
  void clear_navigation_forward_back();
  bool navigation_forward_back() const;
  void set_navigation_forward_back(bool value);
  private:
  bool _internal_navigation_forward_back() const;
  void _internal_set_navigation_forward_back(bool value);
  public:

  // optional bool navigation_from_address_bar = 11;
  bool has_navigation_from_address_bar() const;
  private:
  bool _internal_has_navigation_from_address_bar() const;
  public:
  void clear_navigation_from_address_bar();
  bool navigation_from_address_bar() const;
  void set_navigation_from_address_bar(bool value);
  private:
  bool _internal_navigation_from_address_bar() const;
  void _internal_set_navigation_from_address_bar(bool value);
  public:

  // optional bool navigation_home_page = 12;
  bool has_navigation_home_page() const;
  private:
  bool _internal_has_navigation_home_page() const;
  public:
  void clear_navigation_home_page();
  bool navigation_home_page() const;
  void set_navigation_home_page(bool value);
  private:
  bool _internal_navigation_home_page() const;
  void _internal_set_navigation_home_page(bool value);
  public:

  // optional bool navigation_chain_start = 13;
  bool has_navigation_chain_start() const;
  private:
  bool _internal_has_navigation_chain_start() const;
  public:
  void clear_navigation_chain_start();
  bool navigation_chain_start() const;
  void set_navigation_chain_start(bool value);
  private:
  bool _internal_navigation_chain_start() const;
  void _internal_set_navigation_chain_start(bool value);
  public:

  // optional bool navigation_chain_end = 14;
  bool has_navigation_chain_end() const;
  private:
  bool _internal_has_navigation_chain_end() const;
  public:
  void clear_navigation_chain_end();
  bool navigation_chain_end() const;
  void set_navigation_chain_end(bool value);
  private:
  bool _internal_navigation_chain_end() const;
  void _internal_set_navigation_chain_end(bool value);
  public:

  // optional bool is_restored = 22;
  bool has_is_restored() const;
  private:
  bool _internal_has_is_restored() const;
  public:
  void clear_is_restored();
  bool is_restored() const;
  void set_is_restored(bool value);
  private:
  bool _internal_is_restored() const;
  void _internal_set_is_restored(bool value);
  public:

  // optional int64 global_id = 15;
  bool has_global_id() const;
  private:
  bool _internal_has_global_id() const;
  public:
  void clear_global_id();
  int64_t global_id() const;
  void set_global_id(int64_t value);
  private:
  int64_t _internal_global_id() const;
  void _internal_set_global_id(int64_t value);
  public:

  // optional int32 http_status_code = 20;
  bool has_http_status_code() const;
  private:
  bool _internal_has_http_status_code() const;
  public:
  void clear_http_status_code();
  int32_t http_status_code() const;
  void set_http_status_code(int32_t value);
  private:
  int32_t _internal_http_status_code() const;
  void _internal_set_http_status_code(int32_t value);
  public:

  // optional int32 obsolete_referrer_policy = 21 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_obsolete_referrer_policy() const;
  private:
  bool _internal_has_obsolete_referrer_policy() const;
  public:
  PROTOBUF_DEPRECATED void clear_obsolete_referrer_policy();
  PROTOBUF_DEPRECATED int32_t obsolete_referrer_policy() const;
  PROTOBUF_DEPRECATED void set_obsolete_referrer_policy(int32_t value);
  private:
  int32_t _internal_obsolete_referrer_policy() const;
  void _internal_set_obsolete_referrer_policy(int32_t value);
  public:

  // optional int64 task_id = 27;
  bool has_task_id() const;
  private:
  bool _internal_has_task_id() const;
  public:
  void clear_task_id();
  int64_t task_id() const;
  void set_task_id(int64_t value);
  private:
  int64_t _internal_task_id() const;
  void _internal_set_task_id(int64_t value);
  public:

  // optional .sync_pb.TabNavigation.PasswordState password_state = 26;
  bool has_password_state() const;
  private:
  bool _internal_has_password_state() const;
  public:
  void clear_password_state();
  ::sync_pb::TabNavigation_PasswordState password_state() const;
  void set_password_state(::sync_pb::TabNavigation_PasswordState value);
  private:
  ::sync_pb::TabNavigation_PasswordState _internal_password_state() const;
  void _internal_set_password_state(::sync_pb::TabNavigation_PasswordState value);
  public:

  // optional int32 correct_referrer_policy = 25 [default = 1];
  bool has_correct_referrer_policy() const;
  private:
  bool _internal_has_correct_referrer_policy() const;
  public:
  void clear_correct_referrer_policy();
  int32_t correct_referrer_policy() const;
  void set_correct_referrer_policy(int32_t value);
  private:
  int32_t _internal_correct_referrer_policy() const;
  void _internal_set_correct_referrer_policy(int32_t value);
  public:

  // optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
  bool has_redirect_type() const;
  private:
  bool _internal_has_redirect_type() const;
  public:
  void clear_redirect_type();
  ::sync_pb::SyncEnums_PageTransitionRedirectType redirect_type() const;
  void set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value);
  private:
  ::sync_pb::SyncEnums_PageTransitionRedirectType _internal_redirect_type() const;
  void _internal_set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value);
  public:

  // optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];
  bool has_blocked_state() const;
  private:
  bool _internal_has_blocked_state() const;
  public:
  void clear_blocked_state();
  ::sync_pb::TabNavigation_BlockedState blocked_state() const;
  void set_blocked_state(::sync_pb::TabNavigation_BlockedState value);
  private:
  ::sync_pb::TabNavigation_BlockedState _internal_blocked_state() const;
  void _internal_set_blocked_state(::sync_pb::TabNavigation_BlockedState value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.TabNavigation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NavigationRedirect > navigation_redirect_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > ancestor_task_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr virtual_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referrer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr search_terms_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr favicon_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_navigation_redirect_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_language_;
  ::sync_pb::ReplacedNavigation* replaced_navigation_;
  int page_transition_;
  int32_t unique_id_;
  int64_t timestamp_msec_;
  bool navigation_forward_back_;
  bool navigation_from_address_bar_;
  bool navigation_home_page_;
  bool navigation_chain_start_;
  bool navigation_chain_end_;
  bool is_restored_;
  int64_t global_id_;
  int32_t http_status_code_;
  int32_t obsolete_referrer_policy_;
  int64_t task_id_;
  int password_state_;
  int32_t correct_referrer_policy_;
  int redirect_type_;
  int blocked_state_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class NavigationRedirect final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.NavigationRedirect) */ {
 public:
  inline NavigationRedirect() : NavigationRedirect(nullptr) {}
  ~NavigationRedirect() override;
  explicit PROTOBUF_CONSTEXPR NavigationRedirect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NavigationRedirect(const NavigationRedirect& from);
  NavigationRedirect(NavigationRedirect&& from) noexcept
    : NavigationRedirect() {
    *this = ::std::move(from);
  }

  inline NavigationRedirect& operator=(const NavigationRedirect& from) {
    CopyFrom(from);
    return *this;
  }
  inline NavigationRedirect& operator=(NavigationRedirect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const NavigationRedirect& default_instance() {
    return *internal_default_instance();
  }
  static inline const NavigationRedirect* internal_default_instance() {
    return reinterpret_cast<const NavigationRedirect*>(
               &_NavigationRedirect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(NavigationRedirect& a, NavigationRedirect& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(NavigationRedirect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NavigationRedirect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NavigationRedirect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NavigationRedirect>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NavigationRedirect& from);
  void MergeFrom(const NavigationRedirect& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NavigationRedirect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.NavigationRedirect";
  }
  protected:
  explicit NavigationRedirect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // optional string url = 1;
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.NavigationRedirect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// -------------------------------------------------------------------

class ReplacedNavigation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ReplacedNavigation) */ {
 public:
  inline ReplacedNavigation() : ReplacedNavigation(nullptr) {}
  ~ReplacedNavigation() override;
  explicit PROTOBUF_CONSTEXPR ReplacedNavigation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplacedNavigation(const ReplacedNavigation& from);
  ReplacedNavigation(ReplacedNavigation&& from) noexcept
    : ReplacedNavigation() {
    *this = ::std::move(from);
  }

  inline ReplacedNavigation& operator=(const ReplacedNavigation& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplacedNavigation& operator=(ReplacedNavigation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReplacedNavigation& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplacedNavigation* internal_default_instance() {
    return reinterpret_cast<const ReplacedNavigation*>(
               &_ReplacedNavigation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ReplacedNavigation& a, ReplacedNavigation& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ReplacedNavigation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplacedNavigation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplacedNavigation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplacedNavigation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReplacedNavigation& from);
  void MergeFrom(const ReplacedNavigation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReplacedNavigation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ReplacedNavigation";
  }
  protected:
  explicit ReplacedNavigation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFirstCommittedUrlFieldNumber = 1,
    kFirstTimestampMsecFieldNumber = 2,
    kFirstPageTransitionFieldNumber = 3,
  };
  // optional string first_committed_url = 1;
  bool has_first_committed_url() const;
  private:
  bool _internal_has_first_committed_url() const;
  public:
  void clear_first_committed_url();
  const std::string& first_committed_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_first_committed_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_first_committed_url();
  PROTOBUF_NODISCARD std::string* release_first_committed_url();
  void set_allocated_first_committed_url(std::string* first_committed_url);
  private:
  const std::string& _internal_first_committed_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_first_committed_url(const std::string& value);
  std::string* _internal_mutable_first_committed_url();
  public:

  // optional int64 first_timestamp_msec = 2;
  bool has_first_timestamp_msec() const;
  private:
  bool _internal_has_first_timestamp_msec() const;
  public:
  void clear_first_timestamp_msec();
  int64_t first_timestamp_msec() const;
  void set_first_timestamp_msec(int64_t value);
  private:
  int64_t _internal_first_timestamp_msec() const;
  void _internal_set_first_timestamp_msec(int64_t value);
  public:

  // optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
  bool has_first_page_transition() const;
  private:
  bool _internal_has_first_page_transition() const;
  public:
  void clear_first_page_transition();
  ::sync_pb::SyncEnums_PageTransition first_page_transition() const;
  void set_first_page_transition(::sync_pb::SyncEnums_PageTransition value);
  private:
  ::sync_pb::SyncEnums_PageTransition _internal_first_page_transition() const;
  void _internal_set_first_page_transition(::sync_pb::SyncEnums_PageTransition value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ReplacedNavigation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr first_committed_url_;
  int64_t first_timestamp_msec_;
  int first_page_transition_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SessionSpecifics

// optional string session_tag = 1;
inline bool SessionSpecifics::_internal_has_session_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionSpecifics::has_session_tag() const {
  return _internal_has_session_tag();
}
inline void SessionSpecifics::clear_session_tag() {
  session_tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionSpecifics::session_tag() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.session_tag)
  return _internal_session_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionSpecifics::set_session_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 session_tag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SessionSpecifics.session_tag)
}
inline std::string* SessionSpecifics::mutable_session_tag() {
  std::string* _s = _internal_mutable_session_tag();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionSpecifics.session_tag)
  return _s;
}
inline const std::string& SessionSpecifics::_internal_session_tag() const {
  return session_tag_.Get();
}
inline void SessionSpecifics::_internal_set_session_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  session_tag_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionSpecifics::_internal_mutable_session_tag() {
  _has_bits_[0] |= 0x00000001u;
  return session_tag_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionSpecifics::release_session_tag() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionSpecifics.session_tag)
  if (!_internal_has_session_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = session_tag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_tag_.IsDefault()) {
    session_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionSpecifics::set_allocated_session_tag(std::string* session_tag) {
  if (session_tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  session_tag_.SetAllocated(session_tag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (session_tag_.IsDefault()) {
    session_tag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionSpecifics.session_tag)
}

// optional .sync_pb.SessionHeader header = 2;
inline bool SessionSpecifics::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || header_ != nullptr);
  return value;
}
inline bool SessionSpecifics::has_header() const {
  return _internal_has_header();
}
inline void SessionSpecifics::clear_header() {
  if (header_ != nullptr) header_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::sync_pb::SessionHeader& SessionSpecifics::_internal_header() const {
  const ::sync_pb::SessionHeader* p = header_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SessionHeader&>(
      ::sync_pb::_SessionHeader_default_instance_);
}
inline const ::sync_pb::SessionHeader& SessionSpecifics::header() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.header)
  return _internal_header();
}
inline void SessionSpecifics::unsafe_arena_set_allocated_header(
    ::sync_pb::SessionHeader* header) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(header_);
  }
  header_ = header;
  if (header) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.SessionSpecifics.header)
}
inline ::sync_pb::SessionHeader* SessionSpecifics::release_header() {
  _has_bits_[0] &= ~0x00000002u;
  ::sync_pb::SessionHeader* temp = header_;
  header_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::unsafe_arena_release_header() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionSpecifics.header)
  _has_bits_[0] &= ~0x00000002u;
  ::sync_pb::SessionHeader* temp = header_;
  header_ = nullptr;
  return temp;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000002u;
  if (header_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::SessionHeader>(GetArenaForAllocation());
    header_ = p;
  }
  return header_;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::mutable_header() {
  ::sync_pb::SessionHeader* _msg = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionSpecifics.header)
  return _msg;
}
inline void SessionSpecifics::set_allocated_header(::sync_pb::SessionHeader* header) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete header_;
  }
  if (header) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(header);
    if (message_arena != submessage_arena) {
      header = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, header, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  header_ = header;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionSpecifics.header)
}

// optional .sync_pb.SessionTab tab = 3;
inline bool SessionSpecifics::_internal_has_tab() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || tab_ != nullptr);
  return value;
}
inline bool SessionSpecifics::has_tab() const {
  return _internal_has_tab();
}
inline void SessionSpecifics::clear_tab() {
  if (tab_ != nullptr) tab_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::SessionTab& SessionSpecifics::_internal_tab() const {
  const ::sync_pb::SessionTab* p = tab_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SessionTab&>(
      ::sync_pb::_SessionTab_default_instance_);
}
inline const ::sync_pb::SessionTab& SessionSpecifics::tab() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.tab)
  return _internal_tab();
}
inline void SessionSpecifics::unsafe_arena_set_allocated_tab(
    ::sync_pb::SessionTab* tab) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tab_);
  }
  tab_ = tab;
  if (tab) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.SessionSpecifics.tab)
}
inline ::sync_pb::SessionTab* SessionSpecifics::release_tab() {
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::SessionTab* temp = tab_;
  tab_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::SessionTab* SessionSpecifics::unsafe_arena_release_tab() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionSpecifics.tab)
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::SessionTab* temp = tab_;
  tab_ = nullptr;
  return temp;
}
inline ::sync_pb::SessionTab* SessionSpecifics::_internal_mutable_tab() {
  _has_bits_[0] |= 0x00000004u;
  if (tab_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::SessionTab>(GetArenaForAllocation());
    tab_ = p;
  }
  return tab_;
}
inline ::sync_pb::SessionTab* SessionSpecifics::mutable_tab() {
  ::sync_pb::SessionTab* _msg = _internal_mutable_tab();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionSpecifics.tab)
  return _msg;
}
inline void SessionSpecifics::set_allocated_tab(::sync_pb::SessionTab* tab) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete tab_;
  }
  if (tab) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tab);
    if (message_arena != submessage_arena) {
      tab = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tab, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tab_ = tab;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionSpecifics.tab)
}

// optional int32 tab_node_id = 4 [default = -1];
inline bool SessionSpecifics::_internal_has_tab_node_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SessionSpecifics::has_tab_node_id() const {
  return _internal_has_tab_node_id();
}
inline void SessionSpecifics::clear_tab_node_id() {
  tab_node_id_ = -1;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t SessionSpecifics::_internal_tab_node_id() const {
  return tab_node_id_;
}
inline int32_t SessionSpecifics::tab_node_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionSpecifics.tab_node_id)
  return _internal_tab_node_id();
}
inline void SessionSpecifics::_internal_set_tab_node_id(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  tab_node_id_ = value;
}
inline void SessionSpecifics::set_tab_node_id(int32_t value) {
  _internal_set_tab_node_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionSpecifics.tab_node_id)
}

// -------------------------------------------------------------------

// SessionHeader

// repeated .sync_pb.SessionWindow window = 2;
inline int SessionHeader::_internal_window_size() const {
  return window_.size();
}
inline int SessionHeader::window_size() const {
  return _internal_window_size();
}
inline void SessionHeader::clear_window() {
  window_.Clear();
}
inline ::sync_pb::SessionWindow* SessionHeader::mutable_window(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionHeader.window)
  return window_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SessionWindow >*
SessionHeader::mutable_window() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionHeader.window)
  return &window_;
}
inline const ::sync_pb::SessionWindow& SessionHeader::_internal_window(int index) const {
  return window_.Get(index);
}
inline const ::sync_pb::SessionWindow& SessionHeader::window(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.window)
  return _internal_window(index);
}
inline ::sync_pb::SessionWindow* SessionHeader::_internal_add_window() {
  return window_.Add();
}
inline ::sync_pb::SessionWindow* SessionHeader::add_window() {
  ::sync_pb::SessionWindow* _add = _internal_add_window();
  // @@protoc_insertion_point(field_add:sync_pb.SessionHeader.window)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SessionWindow >&
SessionHeader::window() const {
  // @@protoc_insertion_point(field_list:sync_pb.SessionHeader.window)
  return window_;
}

// optional string client_name = 3;
inline bool SessionHeader::_internal_has_client_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionHeader::has_client_name() const {
  return _internal_has_client_name();
}
inline void SessionHeader::clear_client_name() {
  client_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionHeader::client_name() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.client_name)
  return _internal_client_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionHeader::set_client_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 client_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SessionHeader.client_name)
}
inline std::string* SessionHeader::mutable_client_name() {
  std::string* _s = _internal_mutable_client_name();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionHeader.client_name)
  return _s;
}
inline const std::string& SessionHeader::_internal_client_name() const {
  return client_name_.Get();
}
inline void SessionHeader::_internal_set_client_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  client_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionHeader::_internal_mutable_client_name() {
  _has_bits_[0] |= 0x00000001u;
  return client_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionHeader::release_client_name() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionHeader.client_name)
  if (!_internal_has_client_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = client_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionHeader::set_allocated_client_name(std::string* client_name) {
  if (client_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  client_name_.SetAllocated(client_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (client_name_.IsDefault()) {
    client_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionHeader.client_name)
}

// optional .sync_pb.SyncEnums.DeviceType device_type = 4;
inline bool SessionHeader::_internal_has_device_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SessionHeader::has_device_type() const {
  return _internal_has_device_type();
}
inline void SessionHeader::clear_device_type() {
  device_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::SyncEnums_DeviceType SessionHeader::_internal_device_type() const {
  return static_cast< ::sync_pb::SyncEnums_DeviceType >(device_type_);
}
inline ::sync_pb::SyncEnums_DeviceType SessionHeader::device_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionHeader.device_type)
  return _internal_device_type();
}
inline void SessionHeader::_internal_set_device_type(::sync_pb::SyncEnums_DeviceType value) {
  assert(::sync_pb::SyncEnums_DeviceType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  device_type_ = value;
}
inline void SessionHeader::set_device_type(::sync_pb::SyncEnums_DeviceType value) {
  _internal_set_device_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionHeader.device_type)
}

// -------------------------------------------------------------------

// SessionWindow

// optional int32 window_id = 1;
inline bool SessionWindow::_internal_has_window_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionWindow::has_window_id() const {
  return _internal_has_window_id();
}
inline void SessionWindow::clear_window_id() {
  window_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t SessionWindow::_internal_window_id() const {
  return window_id_;
}
inline int32_t SessionWindow::window_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.window_id)
  return _internal_window_id();
}
inline void SessionWindow::_internal_set_window_id(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  window_id_ = value;
}
inline void SessionWindow::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.window_id)
}

// optional int32 selected_tab_index = 2 [default = -1];
inline bool SessionWindow::_internal_has_selected_tab_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SessionWindow::has_selected_tab_index() const {
  return _internal_has_selected_tab_index();
}
inline void SessionWindow::clear_selected_tab_index() {
  selected_tab_index_ = -1;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t SessionWindow::_internal_selected_tab_index() const {
  return selected_tab_index_;
}
inline int32_t SessionWindow::selected_tab_index() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.selected_tab_index)
  return _internal_selected_tab_index();
}
inline void SessionWindow::_internal_set_selected_tab_index(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  selected_tab_index_ = value;
}
inline void SessionWindow::set_selected_tab_index(int32_t value) {
  _internal_set_selected_tab_index(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.selected_tab_index)
}

// optional .sync_pb.SyncEnums.BrowserType browser_type = 3 [default = TYPE_TABBED];
inline bool SessionWindow::_internal_has_browser_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SessionWindow::has_browser_type() const {
  return _internal_has_browser_type();
}
inline void SessionWindow::clear_browser_type() {
  browser_type_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_BrowserType SessionWindow::_internal_browser_type() const {
  return static_cast< ::sync_pb::SyncEnums_BrowserType >(browser_type_);
}
inline ::sync_pb::SyncEnums_BrowserType SessionWindow::browser_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.browser_type)
  return _internal_browser_type();
}
inline void SessionWindow::_internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value) {
  assert(::sync_pb::SyncEnums_BrowserType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  browser_type_ = value;
}
inline void SessionWindow::set_browser_type(::sync_pb::SyncEnums_BrowserType value) {
  _internal_set_browser_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.browser_type)
}

// repeated int32 tab = 4;
inline int SessionWindow::_internal_tab_size() const {
  return tab_.size();
}
inline int SessionWindow::tab_size() const {
  return _internal_tab_size();
}
inline void SessionWindow::clear_tab() {
  tab_.Clear();
}
inline int32_t SessionWindow::_internal_tab(int index) const {
  return tab_.Get(index);
}
inline int32_t SessionWindow::tab(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionWindow.tab)
  return _internal_tab(index);
}
inline void SessionWindow::set_tab(int index, int32_t value) {
  tab_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionWindow.tab)
}
inline void SessionWindow::_internal_add_tab(int32_t value) {
  tab_.Add(value);
}
inline void SessionWindow::add_tab(int32_t value) {
  _internal_add_tab(value);
  // @@protoc_insertion_point(field_add:sync_pb.SessionWindow.tab)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SessionWindow::_internal_tab() const {
  return tab_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SessionWindow::tab() const {
  // @@protoc_insertion_point(field_list:sync_pb.SessionWindow.tab)
  return _internal_tab();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SessionWindow::_internal_mutable_tab() {
  return &tab_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SessionWindow::mutable_tab() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionWindow.tab)
  return _internal_mutable_tab();
}

// -------------------------------------------------------------------

// SessionTab

// optional int32 tab_id = 1 [default = -1];
inline bool SessionTab::_internal_has_tab_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool SessionTab::has_tab_id() const {
  return _internal_has_tab_id();
}
inline void SessionTab::clear_tab_id() {
  tab_id_ = -1;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t SessionTab::_internal_tab_id() const {
  return tab_id_;
}
inline int32_t SessionTab::tab_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.tab_id)
  return _internal_tab_id();
}
inline void SessionTab::_internal_set_tab_id(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  tab_id_ = value;
}
inline void SessionTab::set_tab_id(int32_t value) {
  _internal_set_tab_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.tab_id)
}

// optional int32 window_id = 2;
inline bool SessionTab::_internal_has_window_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SessionTab::has_window_id() const {
  return _internal_has_window_id();
}
inline void SessionTab::clear_window_id() {
  window_id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t SessionTab::_internal_window_id() const {
  return window_id_;
}
inline int32_t SessionTab::window_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.window_id)
  return _internal_window_id();
}
inline void SessionTab::_internal_set_window_id(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  window_id_ = value;
}
inline void SessionTab::set_window_id(int32_t value) {
  _internal_set_window_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.window_id)
}

// optional int32 tab_visual_index = 3 [default = -1];
inline bool SessionTab::_internal_has_tab_visual_index() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool SessionTab::has_tab_visual_index() const {
  return _internal_has_tab_visual_index();
}
inline void SessionTab::clear_tab_visual_index() {
  tab_visual_index_ = -1;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t SessionTab::_internal_tab_visual_index() const {
  return tab_visual_index_;
}
inline int32_t SessionTab::tab_visual_index() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.tab_visual_index)
  return _internal_tab_visual_index();
}
inline void SessionTab::_internal_set_tab_visual_index(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  tab_visual_index_ = value;
}
inline void SessionTab::set_tab_visual_index(int32_t value) {
  _internal_set_tab_visual_index(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.tab_visual_index)
}

// optional int32 current_navigation_index = 4 [default = -1];
inline bool SessionTab::_internal_has_current_navigation_index() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool SessionTab::has_current_navigation_index() const {
  return _internal_has_current_navigation_index();
}
inline void SessionTab::clear_current_navigation_index() {
  current_navigation_index_ = -1;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t SessionTab::_internal_current_navigation_index() const {
  return current_navigation_index_;
}
inline int32_t SessionTab::current_navigation_index() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.current_navigation_index)
  return _internal_current_navigation_index();
}
inline void SessionTab::_internal_set_current_navigation_index(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  current_navigation_index_ = value;
}
inline void SessionTab::set_current_navigation_index(int32_t value) {
  _internal_set_current_navigation_index(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.current_navigation_index)
}

// optional bool pinned = 5 [default = false];
inline bool SessionTab::_internal_has_pinned() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SessionTab::has_pinned() const {
  return _internal_has_pinned();
}
inline void SessionTab::clear_pinned() {
  pinned_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool SessionTab::_internal_pinned() const {
  return pinned_;
}
inline bool SessionTab::pinned() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.pinned)
  return _internal_pinned();
}
inline void SessionTab::_internal_set_pinned(bool value) {
  _has_bits_[0] |= 0x00000010u;
  pinned_ = value;
}
inline void SessionTab::set_pinned(bool value) {
  _internal_set_pinned(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.pinned)
}

// optional string extension_app_id = 6;
inline bool SessionTab::_internal_has_extension_app_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SessionTab::has_extension_app_id() const {
  return _internal_has_extension_app_id();
}
inline void SessionTab::clear_extension_app_id() {
  extension_app_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SessionTab::extension_app_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.extension_app_id)
  return _internal_extension_app_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionTab::set_extension_app_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 extension_app_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.extension_app_id)
}
inline std::string* SessionTab::mutable_extension_app_id() {
  std::string* _s = _internal_mutable_extension_app_id();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.extension_app_id)
  return _s;
}
inline const std::string& SessionTab::_internal_extension_app_id() const {
  return extension_app_id_.Get();
}
inline void SessionTab::_internal_set_extension_app_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extension_app_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionTab::_internal_mutable_extension_app_id() {
  _has_bits_[0] |= 0x00000001u;
  return extension_app_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionTab::release_extension_app_id() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionTab.extension_app_id)
  if (!_internal_has_extension_app_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = extension_app_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extension_app_id_.IsDefault()) {
    extension_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionTab::set_allocated_extension_app_id(std::string* extension_app_id) {
  if (extension_app_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extension_app_id_.SetAllocated(extension_app_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extension_app_id_.IsDefault()) {
    extension_app_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionTab.extension_app_id)
}

// repeated .sync_pb.TabNavigation navigation = 7;
inline int SessionTab::_internal_navigation_size() const {
  return navigation_.size();
}
inline int SessionTab::navigation_size() const {
  return _internal_navigation_size();
}
inline void SessionTab::clear_navigation() {
  navigation_.Clear();
}
inline ::sync_pb::TabNavigation* SessionTab::mutable_navigation(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.navigation)
  return navigation_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::TabNavigation >*
SessionTab::mutable_navigation() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionTab.navigation)
  return &navigation_;
}
inline const ::sync_pb::TabNavigation& SessionTab::_internal_navigation(int index) const {
  return navigation_.Get(index);
}
inline const ::sync_pb::TabNavigation& SessionTab::navigation(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.navigation)
  return _internal_navigation(index);
}
inline ::sync_pb::TabNavigation* SessionTab::_internal_add_navigation() {
  return navigation_.Add();
}
inline ::sync_pb::TabNavigation* SessionTab::add_navigation() {
  ::sync_pb::TabNavigation* _add = _internal_add_navigation();
  // @@protoc_insertion_point(field_add:sync_pb.SessionTab.navigation)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::TabNavigation >&
SessionTab::navigation() const {
  // @@protoc_insertion_point(field_list:sync_pb.SessionTab.navigation)
  return navigation_;
}

// optional bytes favicon = 8 [deprecated = true];
inline bool SessionTab::_internal_has_favicon() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SessionTab::has_favicon() const {
  return _internal_has_favicon();
}
inline void SessionTab::clear_favicon() {
  favicon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SessionTab::favicon() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.favicon)
  return _internal_favicon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionTab::set_favicon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 favicon_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.favicon)
}
inline std::string* SessionTab::mutable_favicon() {
  std::string* _s = _internal_mutable_favicon();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.favicon)
  return _s;
}
inline const std::string& SessionTab::_internal_favicon() const {
  return favicon_.Get();
}
inline void SessionTab::_internal_set_favicon(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  favicon_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionTab::_internal_mutable_favicon() {
  _has_bits_[0] |= 0x00000002u;
  return favicon_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionTab::release_favicon() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionTab.favicon)
  if (!_internal_has_favicon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = favicon_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_.IsDefault()) {
    favicon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionTab::set_allocated_favicon(std::string* favicon) {
  if (favicon != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  favicon_.SetAllocated(favicon, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_.IsDefault()) {
    favicon_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionTab.favicon)
}

// optional .sync_pb.SessionTab.FaviconType favicon_type = 9 [deprecated = true];
inline bool SessionTab::_internal_has_favicon_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool SessionTab::has_favicon_type() const {
  return _internal_has_favicon_type();
}
inline void SessionTab::clear_favicon_type() {
  favicon_type_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::sync_pb::SessionTab_FaviconType SessionTab::_internal_favicon_type() const {
  return static_cast< ::sync_pb::SessionTab_FaviconType >(favicon_type_);
}
inline ::sync_pb::SessionTab_FaviconType SessionTab::favicon_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.favicon_type)
  return _internal_favicon_type();
}
inline void SessionTab::_internal_set_favicon_type(::sync_pb::SessionTab_FaviconType value) {
  assert(::sync_pb::SessionTab_FaviconType_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  favicon_type_ = value;
}
inline void SessionTab::set_favicon_type(::sync_pb::SessionTab_FaviconType value) {
  _internal_set_favicon_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.favicon_type)
}

// optional string favicon_source = 11 [deprecated = true];
inline bool SessionTab::_internal_has_favicon_source() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SessionTab::has_favicon_source() const {
  return _internal_has_favicon_source();
}
inline void SessionTab::clear_favicon_source() {
  favicon_source_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& SessionTab::favicon_source() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.favicon_source)
  return _internal_favicon_source();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SessionTab::set_favicon_source(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 favicon_source_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.favicon_source)
}
inline std::string* SessionTab::mutable_favicon_source() {
  std::string* _s = _internal_mutable_favicon_source();
  // @@protoc_insertion_point(field_mutable:sync_pb.SessionTab.favicon_source)
  return _s;
}
inline const std::string& SessionTab::_internal_favicon_source() const {
  return favicon_source_.Get();
}
inline void SessionTab::_internal_set_favicon_source(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  favicon_source_.Set(value, GetArenaForAllocation());
}
inline std::string* SessionTab::_internal_mutable_favicon_source() {
  _has_bits_[0] |= 0x00000004u;
  return favicon_source_.Mutable(GetArenaForAllocation());
}
inline std::string* SessionTab::release_favicon_source() {
  // @@protoc_insertion_point(field_release:sync_pb.SessionTab.favicon_source)
  if (!_internal_has_favicon_source()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = favicon_source_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_source_.IsDefault()) {
    favicon_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SessionTab::set_allocated_favicon_source(std::string* favicon_source) {
  if (favicon_source != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  favicon_source_.SetAllocated(favicon_source, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_source_.IsDefault()) {
    favicon_source_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SessionTab.favicon_source)
}

// repeated uint64 variation_id = 12 [deprecated = true];
inline int SessionTab::_internal_variation_id_size() const {
  return variation_id_.size();
}
inline int SessionTab::variation_id_size() const {
  return _internal_variation_id_size();
}
inline void SessionTab::clear_variation_id() {
  variation_id_.Clear();
}
inline uint64_t SessionTab::_internal_variation_id(int index) const {
  return variation_id_.Get(index);
}
inline uint64_t SessionTab::variation_id(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.variation_id)
  return _internal_variation_id(index);
}
inline void SessionTab::set_variation_id(int index, uint64_t value) {
  variation_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.variation_id)
}
inline void SessionTab::_internal_add_variation_id(uint64_t value) {
  variation_id_.Add(value);
}
inline void SessionTab::add_variation_id(uint64_t value) {
  _internal_add_variation_id(value);
  // @@protoc_insertion_point(field_add:sync_pb.SessionTab.variation_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SessionTab::_internal_variation_id() const {
  return variation_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
SessionTab::variation_id() const {
  // @@protoc_insertion_point(field_list:sync_pb.SessionTab.variation_id)
  return _internal_variation_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SessionTab::_internal_mutable_variation_id() {
  return &variation_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
SessionTab::mutable_variation_id() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.SessionTab.variation_id)
  return _internal_mutable_variation_id();
}

// optional .sync_pb.SyncEnums.BrowserType browser_type = 13;
inline bool SessionTab::_internal_has_browser_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool SessionTab::has_browser_type() const {
  return _internal_has_browser_type();
}
inline void SessionTab::clear_browser_type() {
  browser_type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::sync_pb::SyncEnums_BrowserType SessionTab::_internal_browser_type() const {
  return static_cast< ::sync_pb::SyncEnums_BrowserType >(browser_type_);
}
inline ::sync_pb::SyncEnums_BrowserType SessionTab::browser_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.SessionTab.browser_type)
  return _internal_browser_type();
}
inline void SessionTab::_internal_set_browser_type(::sync_pb::SyncEnums_BrowserType value) {
  assert(::sync_pb::SyncEnums_BrowserType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  browser_type_ = value;
}
inline void SessionTab::set_browser_type(::sync_pb::SyncEnums_BrowserType value) {
  _internal_set_browser_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.SessionTab.browser_type)
}

// -------------------------------------------------------------------

// TabNavigation

// optional string virtual_url = 2;
inline bool TabNavigation::_internal_has_virtual_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool TabNavigation::has_virtual_url() const {
  return _internal_has_virtual_url();
}
inline void TabNavigation::clear_virtual_url() {
  virtual_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& TabNavigation::virtual_url() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.virtual_url)
  return _internal_virtual_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_virtual_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 virtual_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.virtual_url)
}
inline std::string* TabNavigation::mutable_virtual_url() {
  std::string* _s = _internal_mutable_virtual_url();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.virtual_url)
  return _s;
}
inline const std::string& TabNavigation::_internal_virtual_url() const {
  return virtual_url_.Get();
}
inline void TabNavigation::_internal_set_virtual_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  virtual_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_virtual_url() {
  _has_bits_[0] |= 0x00000001u;
  return virtual_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_virtual_url() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.virtual_url)
  if (!_internal_has_virtual_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = virtual_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (virtual_url_.IsDefault()) {
    virtual_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_virtual_url(std::string* virtual_url) {
  if (virtual_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  virtual_url_.SetAllocated(virtual_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (virtual_url_.IsDefault()) {
    virtual_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.virtual_url)
}

// optional string referrer = 3;
inline bool TabNavigation::_internal_has_referrer() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool TabNavigation::has_referrer() const {
  return _internal_has_referrer();
}
inline void TabNavigation::clear_referrer() {
  referrer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& TabNavigation::referrer() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.referrer)
  return _internal_referrer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_referrer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 referrer_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.referrer)
}
inline std::string* TabNavigation::mutable_referrer() {
  std::string* _s = _internal_mutable_referrer();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.referrer)
  return _s;
}
inline const std::string& TabNavigation::_internal_referrer() const {
  return referrer_.Get();
}
inline void TabNavigation::_internal_set_referrer(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  referrer_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_referrer() {
  _has_bits_[0] |= 0x00000002u;
  return referrer_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_referrer() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.referrer)
  if (!_internal_has_referrer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = referrer_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (referrer_.IsDefault()) {
    referrer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_referrer(std::string* referrer) {
  if (referrer != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  referrer_.SetAllocated(referrer, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (referrer_.IsDefault()) {
    referrer_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.referrer)
}

// optional string title = 4;
inline bool TabNavigation::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool TabNavigation::has_title() const {
  return _internal_has_title();
}
inline void TabNavigation::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& TabNavigation::title() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.title)
}
inline std::string* TabNavigation::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.title)
  return _s;
}
inline const std::string& TabNavigation::_internal_title() const {
  return title_.Get();
}
inline void TabNavigation::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000004u;
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_title() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = title_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.title)
}

// optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = LINK];
inline bool TabNavigation::_internal_has_page_transition() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool TabNavigation::has_page_transition() const {
  return _internal_has_page_transition();
}
inline void TabNavigation::clear_page_transition() {
  page_transition_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::sync_pb::SyncEnums_PageTransition TabNavigation::_internal_page_transition() const {
  return static_cast< ::sync_pb::SyncEnums_PageTransition >(page_transition_);
}
inline ::sync_pb::SyncEnums_PageTransition TabNavigation::page_transition() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.page_transition)
  return _internal_page_transition();
}
inline void TabNavigation::_internal_set_page_transition(::sync_pb::SyncEnums_PageTransition value) {
  assert(::sync_pb::SyncEnums_PageTransition_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  page_transition_ = value;
}
inline void TabNavigation::set_page_transition(::sync_pb::SyncEnums_PageTransition value) {
  _internal_set_page_transition(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.page_transition)
}

// optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
inline bool TabNavigation::_internal_has_redirect_type() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool TabNavigation::has_redirect_type() const {
  return _internal_has_redirect_type();
}
inline void TabNavigation::clear_redirect_type() {
  redirect_type_ = 1;
  _has_bits_[0] &= ~0x00800000u;
}
inline ::sync_pb::SyncEnums_PageTransitionRedirectType TabNavigation::_internal_redirect_type() const {
  return static_cast< ::sync_pb::SyncEnums_PageTransitionRedirectType >(redirect_type_);
}
inline ::sync_pb::SyncEnums_PageTransitionRedirectType TabNavigation::redirect_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.redirect_type)
  return _internal_redirect_type();
}
inline void TabNavigation::_internal_set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value) {
  assert(::sync_pb::SyncEnums_PageTransitionRedirectType_IsValid(value));
  _has_bits_[0] |= 0x00800000u;
  redirect_type_ = value;
}
inline void TabNavigation::set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value) {
  _internal_set_redirect_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.redirect_type)
}

// optional int32 unique_id = 8;
inline bool TabNavigation::_internal_has_unique_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool TabNavigation::has_unique_id() const {
  return _internal_has_unique_id();
}
inline void TabNavigation::clear_unique_id() {
  unique_id_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t TabNavigation::_internal_unique_id() const {
  return unique_id_;
}
inline int32_t TabNavigation::unique_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.unique_id)
  return _internal_unique_id();
}
inline void TabNavigation::_internal_set_unique_id(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  unique_id_ = value;
}
inline void TabNavigation::set_unique_id(int32_t value) {
  _internal_set_unique_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.unique_id)
}

// optional int64 timestamp_msec = 9;
inline bool TabNavigation::_internal_has_timestamp_msec() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool TabNavigation::has_timestamp_msec() const {
  return _internal_has_timestamp_msec();
}
inline void TabNavigation::clear_timestamp_msec() {
  timestamp_msec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000400u;
}
inline int64_t TabNavigation::_internal_timestamp_msec() const {
  return timestamp_msec_;
}
inline int64_t TabNavigation::timestamp_msec() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.timestamp_msec)
  return _internal_timestamp_msec();
}
inline void TabNavigation::_internal_set_timestamp_msec(int64_t value) {
  _has_bits_[0] |= 0x00000400u;
  timestamp_msec_ = value;
}
inline void TabNavigation::set_timestamp_msec(int64_t value) {
  _internal_set_timestamp_msec(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.timestamp_msec)
}

// optional bool navigation_forward_back = 10;
inline bool TabNavigation::_internal_has_navigation_forward_back() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool TabNavigation::has_navigation_forward_back() const {
  return _internal_has_navigation_forward_back();
}
inline void TabNavigation::clear_navigation_forward_back() {
  navigation_forward_back_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool TabNavigation::_internal_navigation_forward_back() const {
  return navigation_forward_back_;
}
inline bool TabNavigation::navigation_forward_back() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_forward_back)
  return _internal_navigation_forward_back();
}
inline void TabNavigation::_internal_set_navigation_forward_back(bool value) {
  _has_bits_[0] |= 0x00000800u;
  navigation_forward_back_ = value;
}
inline void TabNavigation::set_navigation_forward_back(bool value) {
  _internal_set_navigation_forward_back(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_forward_back)
}

// optional bool navigation_from_address_bar = 11;
inline bool TabNavigation::_internal_has_navigation_from_address_bar() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool TabNavigation::has_navigation_from_address_bar() const {
  return _internal_has_navigation_from_address_bar();
}
inline void TabNavigation::clear_navigation_from_address_bar() {
  navigation_from_address_bar_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool TabNavigation::_internal_navigation_from_address_bar() const {
  return navigation_from_address_bar_;
}
inline bool TabNavigation::navigation_from_address_bar() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_from_address_bar)
  return _internal_navigation_from_address_bar();
}
inline void TabNavigation::_internal_set_navigation_from_address_bar(bool value) {
  _has_bits_[0] |= 0x00001000u;
  navigation_from_address_bar_ = value;
}
inline void TabNavigation::set_navigation_from_address_bar(bool value) {
  _internal_set_navigation_from_address_bar(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_from_address_bar)
}

// optional bool navigation_home_page = 12;
inline bool TabNavigation::_internal_has_navigation_home_page() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool TabNavigation::has_navigation_home_page() const {
  return _internal_has_navigation_home_page();
}
inline void TabNavigation::clear_navigation_home_page() {
  navigation_home_page_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool TabNavigation::_internal_navigation_home_page() const {
  return navigation_home_page_;
}
inline bool TabNavigation::navigation_home_page() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_home_page)
  return _internal_navigation_home_page();
}
inline void TabNavigation::_internal_set_navigation_home_page(bool value) {
  _has_bits_[0] |= 0x00002000u;
  navigation_home_page_ = value;
}
inline void TabNavigation::set_navigation_home_page(bool value) {
  _internal_set_navigation_home_page(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_home_page)
}

// optional bool navigation_chain_start = 13;
inline bool TabNavigation::_internal_has_navigation_chain_start() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool TabNavigation::has_navigation_chain_start() const {
  return _internal_has_navigation_chain_start();
}
inline void TabNavigation::clear_navigation_chain_start() {
  navigation_chain_start_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool TabNavigation::_internal_navigation_chain_start() const {
  return navigation_chain_start_;
}
inline bool TabNavigation::navigation_chain_start() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_chain_start)
  return _internal_navigation_chain_start();
}
inline void TabNavigation::_internal_set_navigation_chain_start(bool value) {
  _has_bits_[0] |= 0x00004000u;
  navigation_chain_start_ = value;
}
inline void TabNavigation::set_navigation_chain_start(bool value) {
  _internal_set_navigation_chain_start(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_chain_start)
}

// optional bool navigation_chain_end = 14;
inline bool TabNavigation::_internal_has_navigation_chain_end() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool TabNavigation::has_navigation_chain_end() const {
  return _internal_has_navigation_chain_end();
}
inline void TabNavigation::clear_navigation_chain_end() {
  navigation_chain_end_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool TabNavigation::_internal_navigation_chain_end() const {
  return navigation_chain_end_;
}
inline bool TabNavigation::navigation_chain_end() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_chain_end)
  return _internal_navigation_chain_end();
}
inline void TabNavigation::_internal_set_navigation_chain_end(bool value) {
  _has_bits_[0] |= 0x00008000u;
  navigation_chain_end_ = value;
}
inline void TabNavigation::set_navigation_chain_end(bool value) {
  _internal_set_navigation_chain_end(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.navigation_chain_end)
}

// optional int64 global_id = 15;
inline bool TabNavigation::_internal_has_global_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool TabNavigation::has_global_id() const {
  return _internal_has_global_id();
}
inline void TabNavigation::clear_global_id() {
  global_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline int64_t TabNavigation::_internal_global_id() const {
  return global_id_;
}
inline int64_t TabNavigation::global_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.global_id)
  return _internal_global_id();
}
inline void TabNavigation::_internal_set_global_id(int64_t value) {
  _has_bits_[0] |= 0x00020000u;
  global_id_ = value;
}
inline void TabNavigation::set_global_id(int64_t value) {
  _internal_set_global_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.global_id)
}

// optional string search_terms = 16 [deprecated = true];
inline bool TabNavigation::_internal_has_search_terms() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool TabNavigation::has_search_terms() const {
  return _internal_has_search_terms();
}
inline void TabNavigation::clear_search_terms() {
  search_terms_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& TabNavigation::search_terms() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.search_terms)
  return _internal_search_terms();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_search_terms(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 search_terms_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.search_terms)
}
inline std::string* TabNavigation::mutable_search_terms() {
  std::string* _s = _internal_mutable_search_terms();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.search_terms)
  return _s;
}
inline const std::string& TabNavigation::_internal_search_terms() const {
  return search_terms_.Get();
}
inline void TabNavigation::_internal_set_search_terms(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  search_terms_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_search_terms() {
  _has_bits_[0] |= 0x00000008u;
  return search_terms_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_search_terms() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.search_terms)
  if (!_internal_has_search_terms()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = search_terms_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_terms_.IsDefault()) {
    search_terms_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_search_terms(std::string* search_terms) {
  if (search_terms != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  search_terms_.SetAllocated(search_terms, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (search_terms_.IsDefault()) {
    search_terms_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.search_terms)
}

// optional string favicon_url = 17;
inline bool TabNavigation::_internal_has_favicon_url() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool TabNavigation::has_favicon_url() const {
  return _internal_has_favicon_url();
}
inline void TabNavigation::clear_favicon_url() {
  favicon_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& TabNavigation::favicon_url() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.favicon_url)
  return _internal_favicon_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_favicon_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 favicon_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.favicon_url)
}
inline std::string* TabNavigation::mutable_favicon_url() {
  std::string* _s = _internal_mutable_favicon_url();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.favicon_url)
  return _s;
}
inline const std::string& TabNavigation::_internal_favicon_url() const {
  return favicon_url_.Get();
}
inline void TabNavigation::_internal_set_favicon_url(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  favicon_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_favicon_url() {
  _has_bits_[0] |= 0x00000010u;
  return favicon_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_favicon_url() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.favicon_url)
  if (!_internal_has_favicon_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = favicon_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_url_.IsDefault()) {
    favicon_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_favicon_url(std::string* favicon_url) {
  if (favicon_url != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  favicon_url_.SetAllocated(favicon_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (favicon_url_.IsDefault()) {
    favicon_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.favicon_url)
}

// optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];
inline bool TabNavigation::_internal_has_blocked_state() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool TabNavigation::has_blocked_state() const {
  return _internal_has_blocked_state();
}
inline void TabNavigation::clear_blocked_state() {
  blocked_state_ = 1;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::sync_pb::TabNavigation_BlockedState TabNavigation::_internal_blocked_state() const {
  return static_cast< ::sync_pb::TabNavigation_BlockedState >(blocked_state_);
}
inline ::sync_pb::TabNavigation_BlockedState TabNavigation::blocked_state() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.blocked_state)
  return _internal_blocked_state();
}
inline void TabNavigation::_internal_set_blocked_state(::sync_pb::TabNavigation_BlockedState value) {
  assert(::sync_pb::TabNavigation_BlockedState_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  blocked_state_ = value;
}
inline void TabNavigation::set_blocked_state(::sync_pb::TabNavigation_BlockedState value) {
  _internal_set_blocked_state(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.blocked_state)
}

// optional int32 http_status_code = 20;
inline bool TabNavigation::_internal_has_http_status_code() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool TabNavigation::has_http_status_code() const {
  return _internal_has_http_status_code();
}
inline void TabNavigation::clear_http_status_code() {
  http_status_code_ = 0;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t TabNavigation::_internal_http_status_code() const {
  return http_status_code_;
}
inline int32_t TabNavigation::http_status_code() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.http_status_code)
  return _internal_http_status_code();
}
inline void TabNavigation::_internal_set_http_status_code(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  http_status_code_ = value;
}
inline void TabNavigation::set_http_status_code(int32_t value) {
  _internal_set_http_status_code(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.http_status_code)
}

// optional int32 obsolete_referrer_policy = 21 [deprecated = true];
inline bool TabNavigation::_internal_has_obsolete_referrer_policy() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool TabNavigation::has_obsolete_referrer_policy() const {
  return _internal_has_obsolete_referrer_policy();
}
inline void TabNavigation::clear_obsolete_referrer_policy() {
  obsolete_referrer_policy_ = 0;
  _has_bits_[0] &= ~0x00080000u;
}
inline int32_t TabNavigation::_internal_obsolete_referrer_policy() const {
  return obsolete_referrer_policy_;
}
inline int32_t TabNavigation::obsolete_referrer_policy() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.obsolete_referrer_policy)
  return _internal_obsolete_referrer_policy();
}
inline void TabNavigation::_internal_set_obsolete_referrer_policy(int32_t value) {
  _has_bits_[0] |= 0x00080000u;
  obsolete_referrer_policy_ = value;
}
inline void TabNavigation::set_obsolete_referrer_policy(int32_t value) {
  _internal_set_obsolete_referrer_policy(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.obsolete_referrer_policy)
}

// optional bool is_restored = 22;
inline bool TabNavigation::_internal_has_is_restored() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool TabNavigation::has_is_restored() const {
  return _internal_has_is_restored();
}
inline void TabNavigation::clear_is_restored() {
  is_restored_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool TabNavigation::_internal_is_restored() const {
  return is_restored_;
}
inline bool TabNavigation::is_restored() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.is_restored)
  return _internal_is_restored();
}
inline void TabNavigation::_internal_set_is_restored(bool value) {
  _has_bits_[0] |= 0x00010000u;
  is_restored_ = value;
}
inline void TabNavigation::set_is_restored(bool value) {
  _internal_set_is_restored(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.is_restored)
}

// repeated .sync_pb.NavigationRedirect navigation_redirect = 23;
inline int TabNavigation::_internal_navigation_redirect_size() const {
  return navigation_redirect_.size();
}
inline int TabNavigation::navigation_redirect_size() const {
  return _internal_navigation_redirect_size();
}
inline void TabNavigation::clear_navigation_redirect() {
  navigation_redirect_.Clear();
}
inline ::sync_pb::NavigationRedirect* TabNavigation::mutable_navigation_redirect(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.navigation_redirect)
  return navigation_redirect_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NavigationRedirect >*
TabNavigation::mutable_navigation_redirect() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.TabNavigation.navigation_redirect)
  return &navigation_redirect_;
}
inline const ::sync_pb::NavigationRedirect& TabNavigation::_internal_navigation_redirect(int index) const {
  return navigation_redirect_.Get(index);
}
inline const ::sync_pb::NavigationRedirect& TabNavigation::navigation_redirect(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.navigation_redirect)
  return _internal_navigation_redirect(index);
}
inline ::sync_pb::NavigationRedirect* TabNavigation::_internal_add_navigation_redirect() {
  return navigation_redirect_.Add();
}
inline ::sync_pb::NavigationRedirect* TabNavigation::add_navigation_redirect() {
  ::sync_pb::NavigationRedirect* _add = _internal_add_navigation_redirect();
  // @@protoc_insertion_point(field_add:sync_pb.TabNavigation.navigation_redirect)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::NavigationRedirect >&
TabNavigation::navigation_redirect() const {
  // @@protoc_insertion_point(field_list:sync_pb.TabNavigation.navigation_redirect)
  return navigation_redirect_;
}

// optional string last_navigation_redirect_url = 24;
inline bool TabNavigation::_internal_has_last_navigation_redirect_url() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool TabNavigation::has_last_navigation_redirect_url() const {
  return _internal_has_last_navigation_redirect_url();
}
inline void TabNavigation::clear_last_navigation_redirect_url() {
  last_navigation_redirect_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& TabNavigation::last_navigation_redirect_url() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.last_navigation_redirect_url)
  return _internal_last_navigation_redirect_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_last_navigation_redirect_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 last_navigation_redirect_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.last_navigation_redirect_url)
}
inline std::string* TabNavigation::mutable_last_navigation_redirect_url() {
  std::string* _s = _internal_mutable_last_navigation_redirect_url();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.last_navigation_redirect_url)
  return _s;
}
inline const std::string& TabNavigation::_internal_last_navigation_redirect_url() const {
  return last_navigation_redirect_url_.Get();
}
inline void TabNavigation::_internal_set_last_navigation_redirect_url(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  last_navigation_redirect_url_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_last_navigation_redirect_url() {
  _has_bits_[0] |= 0x00000020u;
  return last_navigation_redirect_url_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_last_navigation_redirect_url() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.last_navigation_redirect_url)
  if (!_internal_has_last_navigation_redirect_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = last_navigation_redirect_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_navigation_redirect_url_.IsDefault()) {
    last_navigation_redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_last_navigation_redirect_url(std::string* last_navigation_redirect_url) {
  if (last_navigation_redirect_url != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  last_navigation_redirect_url_.SetAllocated(last_navigation_redirect_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_navigation_redirect_url_.IsDefault()) {
    last_navigation_redirect_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.last_navigation_redirect_url)
}

// optional int32 correct_referrer_policy = 25 [default = 1];
inline bool TabNavigation::_internal_has_correct_referrer_policy() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool TabNavigation::has_correct_referrer_policy() const {
  return _internal_has_correct_referrer_policy();
}
inline void TabNavigation::clear_correct_referrer_policy() {
  correct_referrer_policy_ = 1;
  _has_bits_[0] &= ~0x00400000u;
}
inline int32_t TabNavigation::_internal_correct_referrer_policy() const {
  return correct_referrer_policy_;
}
inline int32_t TabNavigation::correct_referrer_policy() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.correct_referrer_policy)
  return _internal_correct_referrer_policy();
}
inline void TabNavigation::_internal_set_correct_referrer_policy(int32_t value) {
  _has_bits_[0] |= 0x00400000u;
  correct_referrer_policy_ = value;
}
inline void TabNavigation::set_correct_referrer_policy(int32_t value) {
  _internal_set_correct_referrer_policy(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.correct_referrer_policy)
}

// optional .sync_pb.TabNavigation.PasswordState password_state = 26;
inline bool TabNavigation::_internal_has_password_state() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool TabNavigation::has_password_state() const {
  return _internal_has_password_state();
}
inline void TabNavigation::clear_password_state() {
  password_state_ = 0;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::sync_pb::TabNavigation_PasswordState TabNavigation::_internal_password_state() const {
  return static_cast< ::sync_pb::TabNavigation_PasswordState >(password_state_);
}
inline ::sync_pb::TabNavigation_PasswordState TabNavigation::password_state() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.password_state)
  return _internal_password_state();
}
inline void TabNavigation::_internal_set_password_state(::sync_pb::TabNavigation_PasswordState value) {
  assert(::sync_pb::TabNavigation_PasswordState_IsValid(value));
  _has_bits_[0] |= 0x00200000u;
  password_state_ = value;
}
inline void TabNavigation::set_password_state(::sync_pb::TabNavigation_PasswordState value) {
  _internal_set_password_state(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.password_state)
}

// optional int64 task_id = 27;
inline bool TabNavigation::_internal_has_task_id() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool TabNavigation::has_task_id() const {
  return _internal_has_task_id();
}
inline void TabNavigation::clear_task_id() {
  task_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00100000u;
}
inline int64_t TabNavigation::_internal_task_id() const {
  return task_id_;
}
inline int64_t TabNavigation::task_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.task_id)
  return _internal_task_id();
}
inline void TabNavigation::_internal_set_task_id(int64_t value) {
  _has_bits_[0] |= 0x00100000u;
  task_id_ = value;
}
inline void TabNavigation::set_task_id(int64_t value) {
  _internal_set_task_id(value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.task_id)
}

// repeated int64 ancestor_task_id = 28;
inline int TabNavigation::_internal_ancestor_task_id_size() const {
  return ancestor_task_id_.size();
}
inline int TabNavigation::ancestor_task_id_size() const {
  return _internal_ancestor_task_id_size();
}
inline void TabNavigation::clear_ancestor_task_id() {
  ancestor_task_id_.Clear();
}
inline int64_t TabNavigation::_internal_ancestor_task_id(int index) const {
  return ancestor_task_id_.Get(index);
}
inline int64_t TabNavigation::ancestor_task_id(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.ancestor_task_id)
  return _internal_ancestor_task_id(index);
}
inline void TabNavigation::set_ancestor_task_id(int index, int64_t value) {
  ancestor_task_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.ancestor_task_id)
}
inline void TabNavigation::_internal_add_ancestor_task_id(int64_t value) {
  ancestor_task_id_.Add(value);
}
inline void TabNavigation::add_ancestor_task_id(int64_t value) {
  _internal_add_ancestor_task_id(value);
  // @@protoc_insertion_point(field_add:sync_pb.TabNavigation.ancestor_task_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TabNavigation::_internal_ancestor_task_id() const {
  return ancestor_task_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
TabNavigation::ancestor_task_id() const {
  // @@protoc_insertion_point(field_list:sync_pb.TabNavigation.ancestor_task_id)
  return _internal_ancestor_task_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TabNavigation::_internal_mutable_ancestor_task_id() {
  return &ancestor_task_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
TabNavigation::mutable_ancestor_task_id() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.TabNavigation.ancestor_task_id)
  return _internal_mutable_ancestor_task_id();
}

// optional .sync_pb.ReplacedNavigation replaced_navigation = 29;
inline bool TabNavigation::_internal_has_replaced_navigation() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || replaced_navigation_ != nullptr);
  return value;
}
inline bool TabNavigation::has_replaced_navigation() const {
  return _internal_has_replaced_navigation();
}
inline void TabNavigation::clear_replaced_navigation() {
  if (replaced_navigation_ != nullptr) replaced_navigation_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::ReplacedNavigation& TabNavigation::_internal_replaced_navigation() const {
  const ::sync_pb::ReplacedNavigation* p = replaced_navigation_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ReplacedNavigation&>(
      ::sync_pb::_ReplacedNavigation_default_instance_);
}
inline const ::sync_pb::ReplacedNavigation& TabNavigation::replaced_navigation() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.replaced_navigation)
  return _internal_replaced_navigation();
}
inline void TabNavigation::unsafe_arena_set_allocated_replaced_navigation(
    ::sync_pb::ReplacedNavigation* replaced_navigation) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(replaced_navigation_);
  }
  replaced_navigation_ = replaced_navigation;
  if (replaced_navigation) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.TabNavigation.replaced_navigation)
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::release_replaced_navigation() {
  _has_bits_[0] &= ~0x00000080u;
  ::sync_pb::ReplacedNavigation* temp = replaced_navigation_;
  replaced_navigation_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::unsafe_arena_release_replaced_navigation() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.replaced_navigation)
  _has_bits_[0] &= ~0x00000080u;
  ::sync_pb::ReplacedNavigation* temp = replaced_navigation_;
  replaced_navigation_ = nullptr;
  return temp;
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::_internal_mutable_replaced_navigation() {
  _has_bits_[0] |= 0x00000080u;
  if (replaced_navigation_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ReplacedNavigation>(GetArenaForAllocation());
    replaced_navigation_ = p;
  }
  return replaced_navigation_;
}
inline ::sync_pb::ReplacedNavigation* TabNavigation::mutable_replaced_navigation() {
  ::sync_pb::ReplacedNavigation* _msg = _internal_mutable_replaced_navigation();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.replaced_navigation)
  return _msg;
}
inline void TabNavigation::set_allocated_replaced_navigation(::sync_pb::ReplacedNavigation* replaced_navigation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete replaced_navigation_;
  }
  if (replaced_navigation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(replaced_navigation);
    if (message_arena != submessage_arena) {
      replaced_navigation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, replaced_navigation, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  replaced_navigation_ = replaced_navigation;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.replaced_navigation)
}

// optional string page_language = 30;
inline bool TabNavigation::_internal_has_page_language() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool TabNavigation::has_page_language() const {
  return _internal_has_page_language();
}
inline void TabNavigation::clear_page_language() {
  page_language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& TabNavigation::page_language() const {
  // @@protoc_insertion_point(field_get:sync_pb.TabNavigation.page_language)
  return _internal_page_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TabNavigation::set_page_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 page_language_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.TabNavigation.page_language)
}
inline std::string* TabNavigation::mutable_page_language() {
  std::string* _s = _internal_mutable_page_language();
  // @@protoc_insertion_point(field_mutable:sync_pb.TabNavigation.page_language)
  return _s;
}
inline const std::string& TabNavigation::_internal_page_language() const {
  return page_language_.Get();
}
inline void TabNavigation::_internal_set_page_language(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  page_language_.Set(value, GetArenaForAllocation());
}
inline std::string* TabNavigation::_internal_mutable_page_language() {
  _has_bits_[0] |= 0x00000040u;
  return page_language_.Mutable(GetArenaForAllocation());
}
inline std::string* TabNavigation::release_page_language() {
  // @@protoc_insertion_point(field_release:sync_pb.TabNavigation.page_language)
  if (!_internal_has_page_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = page_language_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_language_.IsDefault()) {
    page_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void TabNavigation::set_allocated_page_language(std::string* page_language) {
  if (page_language != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  page_language_.SetAllocated(page_language, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_language_.IsDefault()) {
    page_language_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.TabNavigation.page_language)
}

// -------------------------------------------------------------------

// NavigationRedirect

// optional string url = 1;
inline bool NavigationRedirect::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool NavigationRedirect::has_url() const {
  return _internal_has_url();
}
inline void NavigationRedirect::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& NavigationRedirect::url() const {
  // @@protoc_insertion_point(field_get:sync_pb.NavigationRedirect.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NavigationRedirect::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.NavigationRedirect.url)
}
inline std::string* NavigationRedirect::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:sync_pb.NavigationRedirect.url)
  return _s;
}
inline const std::string& NavigationRedirect::_internal_url() const {
  return url_.Get();
}
inline void NavigationRedirect::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* NavigationRedirect::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* NavigationRedirect::release_url() {
  // @@protoc_insertion_point(field_release:sync_pb.NavigationRedirect.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void NavigationRedirect::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.NavigationRedirect.url)
}

// -------------------------------------------------------------------

// ReplacedNavigation

// optional string first_committed_url = 1;
inline bool ReplacedNavigation::_internal_has_first_committed_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReplacedNavigation::has_first_committed_url() const {
  return _internal_has_first_committed_url();
}
inline void ReplacedNavigation::clear_first_committed_url() {
  first_committed_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ReplacedNavigation::first_committed_url() const {
  // @@protoc_insertion_point(field_get:sync_pb.ReplacedNavigation.first_committed_url)
  return _internal_first_committed_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReplacedNavigation::set_first_committed_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 first_committed_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ReplacedNavigation.first_committed_url)
}
inline std::string* ReplacedNavigation::mutable_first_committed_url() {
  std::string* _s = _internal_mutable_first_committed_url();
  // @@protoc_insertion_point(field_mutable:sync_pb.ReplacedNavigation.first_committed_url)
  return _s;
}
inline const std::string& ReplacedNavigation::_internal_first_committed_url() const {
  return first_committed_url_.Get();
}
inline void ReplacedNavigation::_internal_set_first_committed_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  first_committed_url_.Set(value, GetArenaForAllocation());
}
inline std::string* ReplacedNavigation::_internal_mutable_first_committed_url() {
  _has_bits_[0] |= 0x00000001u;
  return first_committed_url_.Mutable(GetArenaForAllocation());
}
inline std::string* ReplacedNavigation::release_first_committed_url() {
  // @@protoc_insertion_point(field_release:sync_pb.ReplacedNavigation.first_committed_url)
  if (!_internal_has_first_committed_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = first_committed_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_committed_url_.IsDefault()) {
    first_committed_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ReplacedNavigation::set_allocated_first_committed_url(std::string* first_committed_url) {
  if (first_committed_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  first_committed_url_.SetAllocated(first_committed_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (first_committed_url_.IsDefault()) {
    first_committed_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ReplacedNavigation.first_committed_url)
}

// optional int64 first_timestamp_msec = 2;
inline bool ReplacedNavigation::_internal_has_first_timestamp_msec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReplacedNavigation::has_first_timestamp_msec() const {
  return _internal_has_first_timestamp_msec();
}
inline void ReplacedNavigation::clear_first_timestamp_msec() {
  first_timestamp_msec_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ReplacedNavigation::_internal_first_timestamp_msec() const {
  return first_timestamp_msec_;
}
inline int64_t ReplacedNavigation::first_timestamp_msec() const {
  // @@protoc_insertion_point(field_get:sync_pb.ReplacedNavigation.first_timestamp_msec)
  return _internal_first_timestamp_msec();
}
inline void ReplacedNavigation::_internal_set_first_timestamp_msec(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  first_timestamp_msec_ = value;
}
inline void ReplacedNavigation::set_first_timestamp_msec(int64_t value) {
  _internal_set_first_timestamp_msec(value);
  // @@protoc_insertion_point(field_set:sync_pb.ReplacedNavigation.first_timestamp_msec)
}

// optional .sync_pb.SyncEnums.PageTransition first_page_transition = 3;
inline bool ReplacedNavigation::_internal_has_first_page_transition() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReplacedNavigation::has_first_page_transition() const {
  return _internal_has_first_page_transition();
}
inline void ReplacedNavigation::clear_first_page_transition() {
  first_page_transition_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_PageTransition ReplacedNavigation::_internal_first_page_transition() const {
  return static_cast< ::sync_pb::SyncEnums_PageTransition >(first_page_transition_);
}
inline ::sync_pb::SyncEnums_PageTransition ReplacedNavigation::first_page_transition() const {
  // @@protoc_insertion_point(field_get:sync_pb.ReplacedNavigation.first_page_transition)
  return _internal_first_page_transition();
}
inline void ReplacedNavigation::_internal_set_first_page_transition(::sync_pb::SyncEnums_PageTransition value) {
  assert(::sync_pb::SyncEnums_PageTransition_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  first_page_transition_ = value;
}
inline void ReplacedNavigation::set_first_page_transition(::sync_pb::SyncEnums_PageTransition value) {
  _internal_set_first_page_transition(value);
  // @@protoc_insertion_point(field_set:sync_pb.ReplacedNavigation.first_page_transition)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sync_pb::SessionTab_FaviconType> : ::std::true_type {};
template <> struct is_proto_enum< ::sync_pb::TabNavigation_BlockedState> : ::std::true_type {};
template <> struct is_proto_enum< ::sync_pb::TabNavigation_PasswordState> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsession_5fspecifics_2eproto
