// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/password_specifics.proto

package org.chromium.components.sync.protocol;

public interface PasswordSpecificsDataOrBuilder extends
    // @@protoc_insertion_point(interface_extends:sync_pb.PasswordSpecificsData)
    com.google.protobuf.MessageLiteOrBuilder {

  /**
   * <pre>
   * See the enum above.
   * </pre>
   *
   * <code>optional int32 scheme = 1;</code>
   * @return Whether the scheme field is set.
   */
  boolean hasScheme();
  /**
   * <pre>
   * See the enum above.
   * </pre>
   *
   * <code>optional int32 scheme = 1;</code>
   * @return The scheme.
   */
  int getScheme();

  /**
   * <pre>
   * Signon realm stores information on where the saved password was stored, and
   * where it's supposed to be filled again.
   * It can take various formats depending on the exact circumstances where it
   * was recorded. Note that the format is *not* guaranteed to be a valid URL or
   * URI:
   *  * For parsed web forms and normal passwords saved through Credential
   *  Manager
   *    API: &lt;http-scheme&gt;://&lt;url-host&gt;[:&lt;url-port&gt;]/
   *    where
   *      &lt;http-scheme&gt; is one of "http" or "https"
   *      &lt;url-host&gt; is the host for which the password was stored
   *      &lt;url-port&gt; is the option port on the host
   *    The signon realm is a valid URL in this case with an empty path.
   *    Examples:
   *      http://www.example.com/
   *      https://127.0.0.1/
   *      http://www.google.com:8080/
   *      http://192.168.1.254/
   *      https://accounts.google.com/
   *  * For Android apps saved through Autofill with Google:
   *      android://&lt;hash-of-cert&gt;&#64;&lt;package-name&gt;/
   *    where
   *      &lt;hash-of-cert&gt; is the base64 encoded SHA512 of the app's public
   *      certificate &lt;package-name&gt; is the app's package name
   *    Examples:
   *      android://kCyQDzpaoAX2gs-1zdGPKNAeICb8LzRFOxa4NCq0jO8c8d_NFS_q-Y35bU3Nq3GmFV2lLurmNvIZa6YPYZwmWg==&#64;com.pinterest/
   *      android://mNUCvTnoWBkzIhSSkVj-uzAdK42YagmCmyUtPoC6JPmYAN3wKpmTdIRsdJtz6pzNBye8XL7nBbEcx-y9CJeo9A==&#64;com.twitter.android.lite/
   *  * For federated credentials:
   *      federation://&lt;origin_host&gt;/&lt;federation_host&gt;
   *    where
   *      &lt;origin_host&gt; is the host for which the login information was stored
   *      &lt;federation_host&gt; is the host of the federation provider that was
   *        used to sign in
   *    Examples:
   *      federation://www.example.com/accounts.google.com
   *      federation://uk.trustpilot.com/www.facebook.com
   *  * For proxy auth:
   *      &lt;proxy-host&gt;[:&lt;proxy_port&gt;]/&lt;auth-realm&gt;
   *    where
   *      &lt;proxy-host&gt; is the host of the proxy for which the password was
   *      stored
   *      &lt;proxy-port&gt; is the port of the proxy
   *      &lt;auth-realm&gt; is a string provided by the proxy during authentication.
   *      It can contain spaces.
   *    Examples:
   *      proxy2.eq.edu.au:80/MISldap
   *      proxy.det.nsw.edu.au:8080/NSW Department of Education
   *      10.47.2.250:3128/Squid Proxy Server CPUT
   *      default.go2https.com:443/(******Get password from vpnso.com/account/
   *      *****)
   *  * For HTTP basic auth:
   *      &lt;http-scheme&gt;://&lt;url-host&gt;[:&lt;url-port&gt;]/&lt;auth-realm&gt;
   *    where
   *      &lt;http-scheme&gt; is one of "http" or "https"
   *      &lt;url-host&gt; is the host for which the password was stored
   *      &lt;url-port&gt; is the option port on the host
   *      &lt;auth-realm&gt; is a string provided by the host during authentication.
   *      It can contain spaces.
   *    Examples:
   *      http://192.168.1.1/Broadband Router
   *      http://192.168.0.1/TP-LINK Wireless N Router WR841N
   *      http://192.168.1.1/index.htm
   *      https://www.edge.asic.gov.au/ASIC eBusiness
   * </pre>
   *
   * <code>optional string signon_realm = 2;</code>
   * @return Whether the signonRealm field is set.
   */
  boolean hasSignonRealm();
  /**
   * <pre>
   * Signon realm stores information on where the saved password was stored, and
   * where it's supposed to be filled again.
   * It can take various formats depending on the exact circumstances where it
   * was recorded. Note that the format is *not* guaranteed to be a valid URL or
   * URI:
   *  * For parsed web forms and normal passwords saved through Credential
   *  Manager
   *    API: &lt;http-scheme&gt;://&lt;url-host&gt;[:&lt;url-port&gt;]/
   *    where
   *      &lt;http-scheme&gt; is one of "http" or "https"
   *      &lt;url-host&gt; is the host for which the password was stored
   *      &lt;url-port&gt; is the option port on the host
   *    The signon realm is a valid URL in this case with an empty path.
   *    Examples:
   *      http://www.example.com/
   *      https://127.0.0.1/
   *      http://www.google.com:8080/
   *      http://192.168.1.254/
   *      https://accounts.google.com/
   *  * For Android apps saved through Autofill with Google:
   *      android://&lt;hash-of-cert&gt;&#64;&lt;package-name&gt;/
   *    where
   *      &lt;hash-of-cert&gt; is the base64 encoded SHA512 of the app's public
   *      certificate &lt;package-name&gt; is the app's package name
   *    Examples:
   *      android://kCyQDzpaoAX2gs-1zdGPKNAeICb8LzRFOxa4NCq0jO8c8d_NFS_q-Y35bU3Nq3GmFV2lLurmNvIZa6YPYZwmWg==&#64;com.pinterest/
   *      android://mNUCvTnoWBkzIhSSkVj-uzAdK42YagmCmyUtPoC6JPmYAN3wKpmTdIRsdJtz6pzNBye8XL7nBbEcx-y9CJeo9A==&#64;com.twitter.android.lite/
   *  * For federated credentials:
   *      federation://&lt;origin_host&gt;/&lt;federation_host&gt;
   *    where
   *      &lt;origin_host&gt; is the host for which the login information was stored
   *      &lt;federation_host&gt; is the host of the federation provider that was
   *        used to sign in
   *    Examples:
   *      federation://www.example.com/accounts.google.com
   *      federation://uk.trustpilot.com/www.facebook.com
   *  * For proxy auth:
   *      &lt;proxy-host&gt;[:&lt;proxy_port&gt;]/&lt;auth-realm&gt;
   *    where
   *      &lt;proxy-host&gt; is the host of the proxy for which the password was
   *      stored
   *      &lt;proxy-port&gt; is the port of the proxy
   *      &lt;auth-realm&gt; is a string provided by the proxy during authentication.
   *      It can contain spaces.
   *    Examples:
   *      proxy2.eq.edu.au:80/MISldap
   *      proxy.det.nsw.edu.au:8080/NSW Department of Education
   *      10.47.2.250:3128/Squid Proxy Server CPUT
   *      default.go2https.com:443/(******Get password from vpnso.com/account/
   *      *****)
   *  * For HTTP basic auth:
   *      &lt;http-scheme&gt;://&lt;url-host&gt;[:&lt;url-port&gt;]/&lt;auth-realm&gt;
   *    where
   *      &lt;http-scheme&gt; is one of "http" or "https"
   *      &lt;url-host&gt; is the host for which the password was stored
   *      &lt;url-port&gt; is the option port on the host
   *      &lt;auth-realm&gt; is a string provided by the host during authentication.
   *      It can contain spaces.
   *    Examples:
   *      http://192.168.1.1/Broadband Router
   *      http://192.168.0.1/TP-LINK Wireless N Router WR841N
   *      http://192.168.1.1/index.htm
   *      https://www.edge.asic.gov.au/ASIC eBusiness
   * </pre>
   *
   * <code>optional string signon_realm = 2;</code>
   * @return The signonRealm.
   */
  java.lang.String getSignonRealm();
  /**
   * <pre>
   * Signon realm stores information on where the saved password was stored, and
   * where it's supposed to be filled again.
   * It can take various formats depending on the exact circumstances where it
   * was recorded. Note that the format is *not* guaranteed to be a valid URL or
   * URI:
   *  * For parsed web forms and normal passwords saved through Credential
   *  Manager
   *    API: &lt;http-scheme&gt;://&lt;url-host&gt;[:&lt;url-port&gt;]/
   *    where
   *      &lt;http-scheme&gt; is one of "http" or "https"
   *      &lt;url-host&gt; is the host for which the password was stored
   *      &lt;url-port&gt; is the option port on the host
   *    The signon realm is a valid URL in this case with an empty path.
   *    Examples:
   *      http://www.example.com/
   *      https://127.0.0.1/
   *      http://www.google.com:8080/
   *      http://192.168.1.254/
   *      https://accounts.google.com/
   *  * For Android apps saved through Autofill with Google:
   *      android://&lt;hash-of-cert&gt;&#64;&lt;package-name&gt;/
   *    where
   *      &lt;hash-of-cert&gt; is the base64 encoded SHA512 of the app's public
   *      certificate &lt;package-name&gt; is the app's package name
   *    Examples:
   *      android://kCyQDzpaoAX2gs-1zdGPKNAeICb8LzRFOxa4NCq0jO8c8d_NFS_q-Y35bU3Nq3GmFV2lLurmNvIZa6YPYZwmWg==&#64;com.pinterest/
   *      android://mNUCvTnoWBkzIhSSkVj-uzAdK42YagmCmyUtPoC6JPmYAN3wKpmTdIRsdJtz6pzNBye8XL7nBbEcx-y9CJeo9A==&#64;com.twitter.android.lite/
   *  * For federated credentials:
   *      federation://&lt;origin_host&gt;/&lt;federation_host&gt;
   *    where
   *      &lt;origin_host&gt; is the host for which the login information was stored
   *      &lt;federation_host&gt; is the host of the federation provider that was
   *        used to sign in
   *    Examples:
   *      federation://www.example.com/accounts.google.com
   *      federation://uk.trustpilot.com/www.facebook.com
   *  * For proxy auth:
   *      &lt;proxy-host&gt;[:&lt;proxy_port&gt;]/&lt;auth-realm&gt;
   *    where
   *      &lt;proxy-host&gt; is the host of the proxy for which the password was
   *      stored
   *      &lt;proxy-port&gt; is the port of the proxy
   *      &lt;auth-realm&gt; is a string provided by the proxy during authentication.
   *      It can contain spaces.
   *    Examples:
   *      proxy2.eq.edu.au:80/MISldap
   *      proxy.det.nsw.edu.au:8080/NSW Department of Education
   *      10.47.2.250:3128/Squid Proxy Server CPUT
   *      default.go2https.com:443/(******Get password from vpnso.com/account/
   *      *****)
   *  * For HTTP basic auth:
   *      &lt;http-scheme&gt;://&lt;url-host&gt;[:&lt;url-port&gt;]/&lt;auth-realm&gt;
   *    where
   *      &lt;http-scheme&gt; is one of "http" or "https"
   *      &lt;url-host&gt; is the host for which the password was stored
   *      &lt;url-port&gt; is the option port on the host
   *      &lt;auth-realm&gt; is a string provided by the host during authentication.
   *      It can contain spaces.
   *    Examples:
   *      http://192.168.1.1/Broadband Router
   *      http://192.168.0.1/TP-LINK Wireless N Router WR841N
   *      http://192.168.1.1/index.htm
   *      https://www.edge.asic.gov.au/ASIC eBusiness
   * </pre>
   *
   * <code>optional string signon_realm = 2;</code>
   * @return The bytes for signonRealm.
   */
  com.google.protobuf.ByteString
      getSignonRealmBytes();

  /**
   * <pre>
   * For parsed web forms and Credential Management API:
   *     url-scheme://url-host[:url-port]/path
   * For Android: "android://&lt;hash of cert&gt;&#64;&lt;package name&gt;/"
   * For proxy/HTTP auth: url-scheme://url-host[:url-port]/path
   * </pre>
   *
   * <code>optional string origin = 3;</code>
   * @return Whether the origin field is set.
   */
  boolean hasOrigin();
  /**
   * <pre>
   * For parsed web forms and Credential Management API:
   *     url-scheme://url-host[:url-port]/path
   * For Android: "android://&lt;hash of cert&gt;&#64;&lt;package name&gt;/"
   * For proxy/HTTP auth: url-scheme://url-host[:url-port]/path
   * </pre>
   *
   * <code>optional string origin = 3;</code>
   * @return The origin.
   */
  java.lang.String getOrigin();
  /**
   * <pre>
   * For parsed web forms and Credential Management API:
   *     url-scheme://url-host[:url-port]/path
   * For Android: "android://&lt;hash of cert&gt;&#64;&lt;package name&gt;/"
   * For proxy/HTTP auth: url-scheme://url-host[:url-port]/path
   * </pre>
   *
   * <code>optional string origin = 3;</code>
   * @return The bytes for origin.
   */
  com.google.protobuf.ByteString
      getOriginBytes();

  /**
   * <pre>
   * Only for web-parsed forms - the action target of the form:
   *     url-scheme://url-host[:url-port]/path
   * </pre>
   *
   * <code>optional string action = 4;</code>
   * @return Whether the action field is set.
   */
  boolean hasAction();
  /**
   * <pre>
   * Only for web-parsed forms - the action target of the form:
   *     url-scheme://url-host[:url-port]/path
   * </pre>
   *
   * <code>optional string action = 4;</code>
   * @return The action.
   */
  java.lang.String getAction();
  /**
   * <pre>
   * Only for web-parsed forms - the action target of the form:
   *     url-scheme://url-host[:url-port]/path
   * </pre>
   *
   * <code>optional string action = 4;</code>
   * @return The bytes for action.
   */
  com.google.protobuf.ByteString
      getActionBytes();

  /**
   * <pre>
   * Only for web-parsed forms - the name of the element containing username.
   * </pre>
   *
   * <code>optional string username_element = 5;</code>
   * @return Whether the usernameElement field is set.
   */
  boolean hasUsernameElement();
  /**
   * <pre>
   * Only for web-parsed forms - the name of the element containing username.
   * </pre>
   *
   * <code>optional string username_element = 5;</code>
   * @return The usernameElement.
   */
  java.lang.String getUsernameElement();
  /**
   * <pre>
   * Only for web-parsed forms - the name of the element containing username.
   * </pre>
   *
   * <code>optional string username_element = 5;</code>
   * @return The bytes for usernameElement.
   */
  com.google.protobuf.ByteString
      getUsernameElementBytes();

  /**
   * <pre>
   * For all: the username.
   * For blacklisted forms: &lt;empty&gt;.
   * </pre>
   *
   * <code>optional string username_value = 6;</code>
   * @return Whether the usernameValue field is set.
   */
  boolean hasUsernameValue();
  /**
   * <pre>
   * For all: the username.
   * For blacklisted forms: &lt;empty&gt;.
   * </pre>
   *
   * <code>optional string username_value = 6;</code>
   * @return The usernameValue.
   */
  java.lang.String getUsernameValue();
  /**
   * <pre>
   * For all: the username.
   * For blacklisted forms: &lt;empty&gt;.
   * </pre>
   *
   * <code>optional string username_value = 6;</code>
   * @return The bytes for usernameValue.
   */
  com.google.protobuf.ByteString
      getUsernameValueBytes();

  /**
   * <pre>
   * Only for web-parsed forms - the name of the element containing password.
   * </pre>
   *
   * <code>optional string password_element = 7;</code>
   * @return Whether the passwordElement field is set.
   */
  boolean hasPasswordElement();
  /**
   * <pre>
   * Only for web-parsed forms - the name of the element containing password.
   * </pre>
   *
   * <code>optional string password_element = 7;</code>
   * @return The passwordElement.
   */
  java.lang.String getPasswordElement();
  /**
   * <pre>
   * Only for web-parsed forms - the name of the element containing password.
   * </pre>
   *
   * <code>optional string password_element = 7;</code>
   * @return The bytes for passwordElement.
   */
  com.google.protobuf.ByteString
      getPasswordElementBytes();

  /**
   * <pre>
   * For all: the password.
   * For federated logins and blacklisted forms: &lt;empty&gt;
   * </pre>
   *
   * <code>optional string password_value = 8;</code>
   * @return Whether the passwordValue field is set.
   */
  boolean hasPasswordValue();
  /**
   * <pre>
   * For all: the password.
   * For federated logins and blacklisted forms: &lt;empty&gt;
   * </pre>
   *
   * <code>optional string password_value = 8;</code>
   * @return The passwordValue.
   */
  java.lang.String getPasswordValue();
  /**
   * <pre>
   * For all: the password.
   * For federated logins and blacklisted forms: &lt;empty&gt;
   * </pre>
   *
   * <code>optional string password_value = 8;</code>
   * @return The bytes for passwordValue.
   */
  com.google.protobuf.ByteString
      getPasswordValueBytes();

  /**
   * <pre>
   * Deprecated: http://crbug.com/413020
   * True if the credential was saved for a HTTPS session with a valid SSL cert.
   * Ignored for Android apps.
   * </pre>
   *
   * <code>optional bool ssl_valid = 9 [deprecated = true];</code>
   * @return Whether the sslValid field is set.
   */
  @java.lang.Deprecated boolean hasSslValid();
  /**
   * <pre>
   * Deprecated: http://crbug.com/413020
   * True if the credential was saved for a HTTPS session with a valid SSL cert.
   * Ignored for Android apps.
   * </pre>
   *
   * <code>optional bool ssl_valid = 9 [deprecated = true];</code>
   * @return The sslValid.
   */
  @java.lang.Deprecated boolean getSslValid();

  /**
   * <pre>
   * True for the last credential used for logging in on a given site.
   * Deprecated in M81.
   * </pre>
   *
   * <code>optional bool preferred = 10 [deprecated = true];</code>
   * @return Whether the preferred field is set.
   */
  @java.lang.Deprecated boolean hasPreferred();
  /**
   * <pre>
   * True for the last credential used for logging in on a given site.
   * Deprecated in M81.
   * </pre>
   *
   * <code>optional bool preferred = 10 [deprecated = true];</code>
   * @return The preferred.
   */
  @java.lang.Deprecated boolean getPreferred();

  /**
   * <pre>
   * Time when the credential was created. Amount of microseconds since 1601.
   * </pre>
   *
   * <code>optional int64 date_created = 11;</code>
   * @return Whether the dateCreated field is set.
   */
  boolean hasDateCreated();
  /**
   * <pre>
   * Time when the credential was created. Amount of microseconds since 1601.
   * </pre>
   *
   * <code>optional int64 date_created = 11;</code>
   * @return The dateCreated.
   */
  long getDateCreated();

  /**
   * <pre>
   * True, if user chose permanently not to save the credentials for the form.
   * </pre>
   *
   * <code>optional bool blacklisted = 12;</code>
   * @return Whether the blacklisted field is set.
   */
  boolean hasBlacklisted();
  /**
   * <pre>
   * True, if user chose permanently not to save the credentials for the form.
   * </pre>
   *
   * <code>optional bool blacklisted = 12;</code>
   * @return The blacklisted.
   */
  boolean getBlacklisted();

  /**
   * <pre>
   * kFormSubmission(0), user manually filled the username and the password
   * in the form.
   * kGenerated(1), the credential was auto generated.
   * kApi(2), the credential was generated from Credential Management API.
   * kManuallyAdded(3), user manually created the password credential
   * via Settings.
   * kImported(4), the credential was imported using the import flow.
   * </pre>
   *
   * <code>optional int32 type = 13;</code>
   * @return Whether the type field is set.
   */
  boolean hasType();
  /**
   * <pre>
   * kFormSubmission(0), user manually filled the username and the password
   * in the form.
   * kGenerated(1), the credential was auto generated.
   * kApi(2), the credential was generated from Credential Management API.
   * kManuallyAdded(3), user manually created the password credential
   * via Settings.
   * kImported(4), the credential was imported using the import flow.
   * </pre>
   *
   * <code>optional int32 type = 13;</code>
   * @return The type.
   */
  int getType();

  /**
   * <pre>
   * Number of times this login was used for logging in. Chrome uses this field
   * to distinguish log-in and sign-up forms.
   * </pre>
   *
   * <code>optional int32 times_used = 14;</code>
   * @return Whether the timesUsed field is set.
   */
  boolean hasTimesUsed();
  /**
   * <pre>
   * Number of times this login was used for logging in. Chrome uses this field
   * to distinguish log-in and sign-up forms.
   * </pre>
   *
   * <code>optional int32 times_used = 14;</code>
   * @return The timesUsed.
   */
  int getTimesUsed();

  /**
   * <pre>
   * A human readable name of the account holder. Set by CredentialManager API
   * and Android.
   * </pre>
   *
   * <code>optional string display_name = 15;</code>
   * @return Whether the displayName field is set.
   */
  boolean hasDisplayName();
  /**
   * <pre>
   * A human readable name of the account holder. Set by CredentialManager API
   * and Android.
   * </pre>
   *
   * <code>optional string display_name = 15;</code>
   * @return The displayName.
   */
  java.lang.String getDisplayName();
  /**
   * <pre>
   * A human readable name of the account holder. Set by CredentialManager API
   * and Android.
   * </pre>
   *
   * <code>optional string display_name = 15;</code>
   * @return The bytes for displayName.
   */
  com.google.protobuf.ByteString
      getDisplayNameBytes();

  /**
   * <pre>
   * A URL of the avatar for the credential. Set by CredentialManager API and
   * Android.
   * </pre>
   *
   * <code>optional string avatar_url = 16;</code>
   * @return Whether the avatarUrl field is set.
   */
  boolean hasAvatarUrl();
  /**
   * <pre>
   * A URL of the avatar for the credential. Set by CredentialManager API and
   * Android.
   * </pre>
   *
   * <code>optional string avatar_url = 16;</code>
   * @return The avatarUrl.
   */
  java.lang.String getAvatarUrl();
  /**
   * <pre>
   * A URL of the avatar for the credential. Set by CredentialManager API and
   * Android.
   * </pre>
   *
   * <code>optional string avatar_url = 16;</code>
   * @return The bytes for avatarUrl.
   */
  com.google.protobuf.ByteString
      getAvatarUrlBytes();

  /**
   * <pre>
   * A URL of the IdP used to verify the credential. Set by Credential Manager
   * API and Android.
   * </pre>
   *
   * <code>optional string federation_url = 17;</code>
   * @return Whether the federationUrl field is set.
   */
  boolean hasFederationUrl();
  /**
   * <pre>
   * A URL of the IdP used to verify the credential. Set by Credential Manager
   * API and Android.
   * </pre>
   *
   * <code>optional string federation_url = 17;</code>
   * @return The federationUrl.
   */
  java.lang.String getFederationUrl();
  /**
   * <pre>
   * A URL of the IdP used to verify the credential. Set by Credential Manager
   * API and Android.
   * </pre>
   *
   * <code>optional string federation_url = 17;</code>
   * @return The bytes for federationUrl.
   */
  com.google.protobuf.ByteString
      getFederationUrlBytes();

  /**
   * <pre>
   * Time when the credential was last used. This covers *successful* logins to
   * the website, and explicit updates to the password. It does *not* cover if
   * the password just gets filled but not actually submitted, or if the login
   * failed.
   * Note that password consumers other than Chrome (e.g. Google Play Services)
   * might not update this at all.
   * Amount of microseconds since 1601, aka Windows epoch.
   * </pre>
   *
   * <code>optional int64 date_last_used = 18;</code>
   * @return Whether the dateLastUsed field is set.
   */
  boolean hasDateLastUsed();
  /**
   * <pre>
   * Time when the credential was last used. This covers *successful* logins to
   * the website, and explicit updates to the password. It does *not* cover if
   * the password just gets filled but not actually submitted, or if the login
   * failed.
   * Note that password consumers other than Chrome (e.g. Google Play Services)
   * might not update this at all.
   * Amount of microseconds since 1601, aka Windows epoch.
   * </pre>
   *
   * <code>optional int64 date_last_used = 18;</code>
   * @return The dateLastUsed.
   */
  long getDateLastUsed();

  /**
   * <pre>
   * Set if an issue was detected that puts this password at risk. All the
   * clients are expected to clear the field when the password value is updated.
   * 'reused' part can be additionally reset when the analysis on the entire
   * password store is completed.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsData.PasswordIssues password_issues = 19;</code>
   * @return Whether the passwordIssues field is set.
   */
  boolean hasPasswordIssues();
  /**
   * <pre>
   * Set if an issue was detected that puts this password at risk. All the
   * clients are expected to clear the field when the password value is updated.
   * 'reused' part can be additionally reset when the analysis on the entire
   * password store is completed.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsData.PasswordIssues password_issues = 19;</code>
   * @return The passwordIssues.
   */
  org.chromium.components.sync.protocol.PasswordSpecificsData.PasswordIssues getPasswordIssues();

  /**
   * <pre>
   * Time when the |password_value| was last modified. For new credentials it
   * should be set to |date_created|. For subsequent updates the timestamp is
   * changed if and only if the new password value was saved.
   * Number of microseconds since Windows epoch (1601).
   * </pre>
   *
   * <code>optional int64 date_password_modified_windows_epoch_micros = 20;</code>
   * @return Whether the datePasswordModifiedWindowsEpochMicros field is set.
   */
  boolean hasDatePasswordModifiedWindowsEpochMicros();
  /**
   * <pre>
   * Time when the |password_value| was last modified. For new credentials it
   * should be set to |date_created|. For subsequent updates the timestamp is
   * changed if and only if the new password value was saved.
   * Number of microseconds since Windows epoch (1601).
   * </pre>
   *
   * <code>optional int64 date_password_modified_windows_epoch_micros = 20;</code>
   * @return The datePasswordModifiedWindowsEpochMicros.
   */
  long getDatePasswordModifiedWindowsEpochMicros();

  /**
   * <pre>
   * Set of extra notes that the user attached to the password. The presence of
   * this field, even with an empty Notes message, becomes the authoritative
   * value for notes and would disregard whatever `encrypted_notes_backup`
   * contains.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsData.Notes notes = 21;</code>
   * @return Whether the notes field is set.
   */
  boolean hasNotes();
  /**
   * <pre>
   * Set of extra notes that the user attached to the password. The presence of
   * this field, even with an empty Notes message, becomes the authoritative
   * value for notes and would disregard whatever `encrypted_notes_backup`
   * contains.
   * </pre>
   *
   * <code>optional .sync_pb.PasswordSpecificsData.Notes notes = 21;</code>
   * @return The notes.
   */
  org.chromium.components.sync.protocol.PasswordSpecificsData.Notes getNotes();
}
