// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync.proto

#include "components/sync/protocol/sync.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sync_pb {
PROTOBUF_CONSTEXPR ChromiumExtensionsActivity::ChromiumExtensionsActivity(
    ::_pbi::ConstantInitialized)
  : extension_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , bookmark_writes_since_last_commit_(0u){}
struct ChromiumExtensionsActivityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChromiumExtensionsActivityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChromiumExtensionsActivityDefaultTypeInternal() {}
  union {
    ChromiumExtensionsActivity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChromiumExtensionsActivityDefaultTypeInternal _ChromiumExtensionsActivity_default_instance_;
PROTOBUF_CONSTEXPR ClientConfigParams::ClientConfigParams(
    ::_pbi::ConstantInitialized)
  : enabled_type_ids_()
  , devices_fcm_registration_tokens_()
  , fcm_registration_tokens_for_interested_clients_()
  , tabs_datatype_enabled_(false)
  , cookie_jar_mismatch_(false)
  , single_client_(false)
  , single_client_with_standalone_invalidations_(false){}
struct ClientConfigParamsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientConfigParamsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientConfigParamsDefaultTypeInternal() {}
  union {
    ClientConfigParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientConfigParamsDefaultTypeInternal _ClientConfigParams_default_instance_;
PROTOBUF_CONSTEXPR CommitMessage::CommitMessage(
    ::_pbi::ConstantInitialized)
  : entries_()
  , extensions_activity_()
  , client_contexts_()
  , cache_guid_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , padding_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , config_params_(nullptr){}
struct CommitMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitMessageDefaultTypeInternal() {}
  union {
    CommitMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitMessageDefaultTypeInternal _CommitMessage_default_instance_;
PROTOBUF_CONSTEXPR GetUpdatesMessage::GetUpdatesMessage(
    ::_pbi::ConstantInitialized)
  : from_progress_marker_()
  , client_contexts_()
  , caller_info_(nullptr)
  , get_updates_origin_(0)

  , streaming_(false)
  , need_encryption_key_(false)
  , create_mobile_bookmarks_folder_(false)
  , is_retry_(false)
  , fetch_folders_(true){}
struct GetUpdatesMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUpdatesMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUpdatesMessageDefaultTypeInternal() {}
  union {
    GetUpdatesMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUpdatesMessageDefaultTypeInternal _GetUpdatesMessage_default_instance_;
PROTOBUF_CONSTEXPR ClearServerDataMessage::ClearServerDataMessage(
    ::_pbi::ConstantInitialized){}
struct ClearServerDataMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearServerDataMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearServerDataMessageDefaultTypeInternal() {}
  union {
    ClearServerDataMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearServerDataMessageDefaultTypeInternal _ClearServerDataMessage_default_instance_;
PROTOBUF_CONSTEXPR ClearServerDataResponse::ClearServerDataResponse(
    ::_pbi::ConstantInitialized){}
struct ClearServerDataResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClearServerDataResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClearServerDataResponseDefaultTypeInternal() {}
  union {
    ClearServerDataResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClearServerDataResponseDefaultTypeInternal _ClearServerDataResponse_default_instance_;
PROTOBUF_CONSTEXPR ChipBag::ChipBag(
    ::_pbi::ConstantInitialized)
  : server_chips_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ChipBagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ChipBagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ChipBagDefaultTypeInternal() {}
  union {
    ChipBag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ChipBagDefaultTypeInternal _ChipBag_default_instance_;
PROTOBUF_CONSTEXPR ClientStatus::ClientStatus(
    ::_pbi::ConstantInitialized)
  : hierarchy_conflict_detected_(false)
  , is_sync_feature_enabled_(false){}
struct ClientStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientStatusDefaultTypeInternal() {}
  union {
    ClientStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientStatusDefaultTypeInternal _ClientStatus_default_instance_;
PROTOBUF_CONSTEXPR ClientToServerMessage::ClientToServerMessage(
    ::_pbi::ConstantInitialized)
  : share_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , store_birthday_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , api_key_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , invalidator_client_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , commit_(nullptr)
  , get_updates_(nullptr)
  , debug_info_(nullptr)
  , bag_of_chips_(nullptr)
  , client_status_(nullptr)
  , clear_server_data_(nullptr)
  , sync_problem_detected_(false)
  , protocol_version_(99)
  , message_contents_(1)
{}
struct ClientToServerMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientToServerMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientToServerMessageDefaultTypeInternal() {}
  union {
    ClientToServerMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToServerMessageDefaultTypeInternal _ClientToServerMessage_default_instance_;
PROTOBUF_CONSTEXPR CommitResponse_EntryResponse_DatatypeSpecificError::CommitResponse_EntryResponse_DatatypeSpecificError(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal() {}
  union {
    CommitResponse_EntryResponse_DatatypeSpecificError _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal _CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_;
PROTOBUF_CONSTEXPR CommitResponse_EntryResponse::CommitResponse_EntryResponse(
    ::_pbi::ConstantInitialized)
  : id_string_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , error_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , datatype_specific_error_(nullptr)
  , version_(int64_t{0})
  , mtime_(int64_t{0})
  , response_type_(1)
{}
struct CommitResponse_EntryResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitResponse_EntryResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitResponse_EntryResponseDefaultTypeInternal() {}
  union {
    CommitResponse_EntryResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitResponse_EntryResponseDefaultTypeInternal _CommitResponse_EntryResponse_default_instance_;
PROTOBUF_CONSTEXPR CommitResponse::CommitResponse(
    ::_pbi::ConstantInitialized)
  : entryresponse_(){}
struct CommitResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommitResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommitResponseDefaultTypeInternal() {}
  union {
    CommitResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
PROTOBUF_CONSTEXPR GetUpdatesResponse::GetUpdatesResponse(
    ::_pbi::ConstantInitialized)
  : entries_()
  , new_progress_marker_()
  , encryption_keys_()
  , context_mutations_()
  , changes_remaining_(int64_t{0}){}
struct GetUpdatesResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetUpdatesResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetUpdatesResponseDefaultTypeInternal() {}
  union {
    GetUpdatesResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetUpdatesResponseDefaultTypeInternal _GetUpdatesResponse_default_instance_;
PROTOBUF_CONSTEXPR ClientToServerResponse_Error::ClientToServerResponse_Error(
    ::_pbi::ConstantInitialized)
  : error_data_type_ids_()
  , error_description_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , error_type_(100)

  , action_(5)
{}
struct ClientToServerResponse_ErrorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientToServerResponse_ErrorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientToServerResponse_ErrorDefaultTypeInternal() {}
  union {
    ClientToServerResponse_Error _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToServerResponse_ErrorDefaultTypeInternal _ClientToServerResponse_Error_default_instance_;
PROTOBUF_CONSTEXPR ClientToServerResponse::ClientToServerResponse(
    ::_pbi::ConstantInitialized)
  : migrated_data_type_id_()
  , error_message_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , store_birthday_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , commit_(nullptr)
  , get_updates_(nullptr)
  , client_command_(nullptr)
  , error_(nullptr)
  , new_bag_of_chips_(nullptr)
  , clear_server_data_(nullptr)
  , error_code_(100)
{}
struct ClientToServerResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientToServerResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientToServerResponseDefaultTypeInternal() {}
  union {
    ClientToServerResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientToServerResponseDefaultTypeInternal _ClientToServerResponse_default_instance_;
PROTOBUF_CONSTEXPR EventRequest::EventRequest(
    ::_pbi::ConstantInitialized)
  : sync_disabled_(nullptr){}
struct EventRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventRequestDefaultTypeInternal() {}
  union {
    EventRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventRequestDefaultTypeInternal _EventRequest_default_instance_;
PROTOBUF_CONSTEXPR EventResponse::EventResponse(
    ::_pbi::ConstantInitialized){}
struct EventResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EventResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EventResponseDefaultTypeInternal() {}
  union {
    EventResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EventResponseDefaultTypeInternal _EventResponse_default_instance_;
PROTOBUF_CONSTEXPR SyncDisabledEvent::SyncDisabledEvent(
    ::_pbi::ConstantInitialized)
  : cache_guid_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , store_birthday_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct SyncDisabledEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SyncDisabledEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SyncDisabledEventDefaultTypeInternal() {}
  union {
    SyncDisabledEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SyncDisabledEventDefaultTypeInternal _SyncDisabledEvent_default_instance_;
}  // namespace sync_pb
namespace sync_pb {
bool ClientToServerMessage_Contents_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> ClientToServerMessage_Contents_strings[5] = {};

static const char ClientToServerMessage_Contents_names[] =
  "CLEAR_SERVER_DATA"
  "COMMIT"
  "DEPRECATED_3"
  "DEPRECATED_4"
  "GET_UPDATES";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry ClientToServerMessage_Contents_entries[] = {
  { {ClientToServerMessage_Contents_names + 0, 17}, 5 },
  { {ClientToServerMessage_Contents_names + 17, 6}, 1 },
  { {ClientToServerMessage_Contents_names + 23, 12}, 3 },
  { {ClientToServerMessage_Contents_names + 35, 12}, 4 },
  { {ClientToServerMessage_Contents_names + 47, 11}, 2 },
};

static const int ClientToServerMessage_Contents_entries_by_number[] = {
  1, // 1 -> COMMIT
  4, // 2 -> GET_UPDATES
  2, // 3 -> DEPRECATED_3
  3, // 4 -> DEPRECATED_4
  0, // 5 -> CLEAR_SERVER_DATA
};

const std::string& ClientToServerMessage_Contents_Name(
    ClientToServerMessage_Contents value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          ClientToServerMessage_Contents_entries,
          ClientToServerMessage_Contents_entries_by_number,
          5, ClientToServerMessage_Contents_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      ClientToServerMessage_Contents_entries,
      ClientToServerMessage_Contents_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     ClientToServerMessage_Contents_strings[idx].get();
}
bool ClientToServerMessage_Contents_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientToServerMessage_Contents* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      ClientToServerMessage_Contents_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<ClientToServerMessage_Contents>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr ClientToServerMessage_Contents ClientToServerMessage::COMMIT;
constexpr ClientToServerMessage_Contents ClientToServerMessage::GET_UPDATES;
constexpr ClientToServerMessage_Contents ClientToServerMessage::DEPRECATED_3;
constexpr ClientToServerMessage_Contents ClientToServerMessage::DEPRECATED_4;
constexpr ClientToServerMessage_Contents ClientToServerMessage::CLEAR_SERVER_DATA;
constexpr ClientToServerMessage_Contents ClientToServerMessage::Contents_MIN;
constexpr ClientToServerMessage_Contents ClientToServerMessage::Contents_MAX;
constexpr int ClientToServerMessage::Contents_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CommitResponse_ResponseType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CommitResponse_ResponseType_strings[6] = {};

static const char CommitResponse_ResponseType_names[] =
  "CONFLICT"
  "INVALID_MESSAGE"
  "OVER_QUOTA"
  "RETRY"
  "SUCCESS"
  "TRANSIENT_ERROR";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CommitResponse_ResponseType_entries[] = {
  { {CommitResponse_ResponseType_names + 0, 8}, 2 },
  { {CommitResponse_ResponseType_names + 8, 15}, 4 },
  { {CommitResponse_ResponseType_names + 23, 10}, 5 },
  { {CommitResponse_ResponseType_names + 33, 5}, 3 },
  { {CommitResponse_ResponseType_names + 38, 7}, 1 },
  { {CommitResponse_ResponseType_names + 45, 15}, 6 },
};

static const int CommitResponse_ResponseType_entries_by_number[] = {
  4, // 1 -> SUCCESS
  0, // 2 -> CONFLICT
  3, // 3 -> RETRY
  1, // 4 -> INVALID_MESSAGE
  2, // 5 -> OVER_QUOTA
  5, // 6 -> TRANSIENT_ERROR
};

const std::string& CommitResponse_ResponseType_Name(
    CommitResponse_ResponseType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CommitResponse_ResponseType_entries,
          CommitResponse_ResponseType_entries_by_number,
          6, CommitResponse_ResponseType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CommitResponse_ResponseType_entries,
      CommitResponse_ResponseType_entries_by_number,
      6, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CommitResponse_ResponseType_strings[idx].get();
}
bool CommitResponse_ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommitResponse_ResponseType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CommitResponse_ResponseType_entries, 6, name, &int_value);
  if (success) {
    *value = static_cast<CommitResponse_ResponseType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CommitResponse_ResponseType CommitResponse::SUCCESS;
constexpr CommitResponse_ResponseType CommitResponse::CONFLICT;
constexpr CommitResponse_ResponseType CommitResponse::RETRY;
constexpr CommitResponse_ResponseType CommitResponse::INVALID_MESSAGE;
constexpr CommitResponse_ResponseType CommitResponse::OVER_QUOTA;
constexpr CommitResponse_ResponseType CommitResponse::TRANSIENT_ERROR;
constexpr CommitResponse_ResponseType CommitResponse::ResponseType_MIN;
constexpr CommitResponse_ResponseType CommitResponse::ResponseType_MAX;
constexpr int CommitResponse::ResponseType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class ChromiumExtensionsActivity::_Internal {
 public:
  using HasBits = decltype(std::declval<ChromiumExtensionsActivity>()._has_bits_);
  static void set_has_extension_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_bookmark_writes_since_last_commit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ChromiumExtensionsActivity::ChromiumExtensionsActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ChromiumExtensionsActivity)
}
ChromiumExtensionsActivity::ChromiumExtensionsActivity(const ChromiumExtensionsActivity& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  extension_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extension_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extension_id()) {
    extension_id_.Set(from._internal_extension_id(), 
      GetArenaForAllocation());
  }
  bookmark_writes_since_last_commit_ = from.bookmark_writes_since_last_commit_;
  // @@protoc_insertion_point(copy_constructor:sync_pb.ChromiumExtensionsActivity)
}

inline void ChromiumExtensionsActivity::SharedCtor() {
extension_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extension_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
bookmark_writes_since_last_commit_ = 0u;
}

ChromiumExtensionsActivity::~ChromiumExtensionsActivity() {
  // @@protoc_insertion_point(destructor:sync_pb.ChromiumExtensionsActivity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChromiumExtensionsActivity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  extension_id_.Destroy();
}

void ChromiumExtensionsActivity::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChromiumExtensionsActivity::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ChromiumExtensionsActivity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    extension_id_.ClearNonDefaultToEmpty();
  }
  bookmark_writes_since_last_commit_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChromiumExtensionsActivity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string extension_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_extension_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bookmark_writes_since_last_commit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_bookmark_writes_since_last_commit(&has_bits);
          bookmark_writes_since_last_commit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChromiumExtensionsActivity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ChromiumExtensionsActivity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string extension_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_extension_id(), target);
  }

  // optional uint32 bookmark_writes_since_last_commit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_bookmark_writes_since_last_commit(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ChromiumExtensionsActivity)
  return target;
}

size_t ChromiumExtensionsActivity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ChromiumExtensionsActivity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string extension_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extension_id());
    }

    // optional uint32 bookmark_writes_since_last_commit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_bookmark_writes_since_last_commit());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChromiumExtensionsActivity::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChromiumExtensionsActivity*>(
      &from));
}

void ChromiumExtensionsActivity::MergeFrom(const ChromiumExtensionsActivity& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ChromiumExtensionsActivity)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_extension_id(from._internal_extension_id());
    }
    if (cached_has_bits & 0x00000002u) {
      bookmark_writes_since_last_commit_ = from.bookmark_writes_since_last_commit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChromiumExtensionsActivity::CopyFrom(const ChromiumExtensionsActivity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ChromiumExtensionsActivity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChromiumExtensionsActivity::IsInitialized() const {
  return true;
}

void ChromiumExtensionsActivity::InternalSwap(ChromiumExtensionsActivity* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &extension_id_, lhs_arena,
      &other->extension_id_, rhs_arena
  );
  swap(bookmark_writes_since_last_commit_, other->bookmark_writes_since_last_commit_);
}

std::string ChromiumExtensionsActivity::GetTypeName() const {
  return "sync_pb.ChromiumExtensionsActivity";
}


// ===================================================================

class ClientConfigParams::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientConfigParams>()._has_bits_);
  static void set_has_tabs_datatype_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cookie_jar_mismatch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_single_client(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_single_client_with_standalone_invalidations(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

ClientConfigParams::ClientConfigParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  enabled_type_ids_(arena),
  devices_fcm_registration_tokens_(arena),
  fcm_registration_tokens_for_interested_clients_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClientConfigParams)
}
ClientConfigParams::ClientConfigParams(const ClientConfigParams& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      enabled_type_ids_(from.enabled_type_ids_),
      devices_fcm_registration_tokens_(from.devices_fcm_registration_tokens_),
      fcm_registration_tokens_for_interested_clients_(from.fcm_registration_tokens_for_interested_clients_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&tabs_datatype_enabled_, &from.tabs_datatype_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&single_client_with_standalone_invalidations_) -
    reinterpret_cast<char*>(&tabs_datatype_enabled_)) + sizeof(single_client_with_standalone_invalidations_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClientConfigParams)
}

inline void ClientConfigParams::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&tabs_datatype_enabled_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&single_client_with_standalone_invalidations_) -
    reinterpret_cast<char*>(&tabs_datatype_enabled_)) + sizeof(single_client_with_standalone_invalidations_));
}

ClientConfigParams::~ClientConfigParams() {
  // @@protoc_insertion_point(destructor:sync_pb.ClientConfigParams)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientConfigParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientConfigParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientConfigParams::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClientConfigParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enabled_type_ids_.Clear();
  devices_fcm_registration_tokens_.Clear();
  fcm_registration_tokens_for_interested_clients_.Clear();
  ::memset(&tabs_datatype_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&single_client_with_standalone_invalidations_) -
      reinterpret_cast<char*>(&tabs_datatype_enabled_)) + sizeof(single_client_with_standalone_invalidations_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientConfigParams::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated int32 enabled_type_ids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_enabled_type_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_enabled_type_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool tabs_datatype_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_tabs_datatype_enabled(&has_bits);
          tabs_datatype_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cookie_jar_mismatch = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cookie_jar_mismatch(&has_bits);
          cookie_jar_mismatch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool single_client = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_single_client(&has_bits);
          single_client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string devices_fcm_registration_tokens = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_devices_fcm_registration_tokens();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool single_client_with_standalone_invalidations = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_single_client_with_standalone_invalidations(&has_bits);
          single_client_with_standalone_invalidations_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string fcm_registration_tokens_for_interested_clients = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_fcm_registration_tokens_for_interested_clients();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientConfigParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientConfigParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated int32 enabled_type_ids = 1;
  for (int i = 0, n = this->_internal_enabled_type_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_enabled_type_ids(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool tabs_datatype_enabled = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_tabs_datatype_enabled(), target);
  }

  // optional bool cookie_jar_mismatch = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_cookie_jar_mismatch(), target);
  }

  // optional bool single_client = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_single_client(), target);
  }

  // repeated string devices_fcm_registration_tokens = 5;
  for (int i = 0, n = this->_internal_devices_fcm_registration_tokens_size(); i < n; i++) {
    const auto& s = this->_internal_devices_fcm_registration_tokens(i);
    target = stream->WriteString(5, s, target);
  }

  // optional bool single_client_with_standalone_invalidations = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_single_client_with_standalone_invalidations(), target);
  }

  // repeated string fcm_registration_tokens_for_interested_clients = 7;
  for (int i = 0, n = this->_internal_fcm_registration_tokens_for_interested_clients_size(); i < n; i++) {
    const auto& s = this->_internal_fcm_registration_tokens_for_interested_clients(i);
    target = stream->WriteString(7, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientConfigParams)
  return target;
}

size_t ClientConfigParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientConfigParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 enabled_type_ids = 1;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->enabled_type_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_enabled_type_ids_size());
    total_size += data_size;
  }

  // repeated string devices_fcm_registration_tokens = 5;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(devices_fcm_registration_tokens_.size());
  for (int i = 0, n = devices_fcm_registration_tokens_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      devices_fcm_registration_tokens_.Get(i));
  }

  // repeated string fcm_registration_tokens_for_interested_clients = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(fcm_registration_tokens_for_interested_clients_.size());
  for (int i = 0, n = fcm_registration_tokens_for_interested_clients_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      fcm_registration_tokens_for_interested_clients_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool tabs_datatype_enabled = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool cookie_jar_mismatch = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool single_client = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool single_client_with_standalone_invalidations = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientConfigParams::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientConfigParams*>(
      &from));
}

void ClientConfigParams::MergeFrom(const ClientConfigParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientConfigParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  enabled_type_ids_.MergeFrom(from.enabled_type_ids_);
  devices_fcm_registration_tokens_.MergeFrom(from.devices_fcm_registration_tokens_);
  fcm_registration_tokens_for_interested_clients_.MergeFrom(from.fcm_registration_tokens_for_interested_clients_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      tabs_datatype_enabled_ = from.tabs_datatype_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      cookie_jar_mismatch_ = from.cookie_jar_mismatch_;
    }
    if (cached_has_bits & 0x00000004u) {
      single_client_ = from.single_client_;
    }
    if (cached_has_bits & 0x00000008u) {
      single_client_with_standalone_invalidations_ = from.single_client_with_standalone_invalidations_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientConfigParams::CopyFrom(const ClientConfigParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientConfigParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientConfigParams::IsInitialized() const {
  return true;
}

void ClientConfigParams::InternalSwap(ClientConfigParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  enabled_type_ids_.InternalSwap(&other->enabled_type_ids_);
  devices_fcm_registration_tokens_.InternalSwap(&other->devices_fcm_registration_tokens_);
  fcm_registration_tokens_for_interested_clients_.InternalSwap(&other->fcm_registration_tokens_for_interested_clients_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientConfigParams, single_client_with_standalone_invalidations_)
      + sizeof(ClientConfigParams::single_client_with_standalone_invalidations_)
      - PROTOBUF_FIELD_OFFSET(ClientConfigParams, tabs_datatype_enabled_)>(
          reinterpret_cast<char*>(&tabs_datatype_enabled_),
          reinterpret_cast<char*>(&other->tabs_datatype_enabled_));
}

std::string ClientConfigParams::GetTypeName() const {
  return "sync_pb.ClientConfigParams";
}


// ===================================================================

class CommitMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CommitMessage>()._has_bits_);
  static void set_has_cache_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sync_pb::ClientConfigParams& config_params(const CommitMessage* msg);
  static void set_has_config_params(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_padding(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::sync_pb::ClientConfigParams&
CommitMessage::_Internal::config_params(const CommitMessage* msg) {
  return *msg->config_params_;
}
void CommitMessage::clear_entries() {
  entries_.Clear();
}
void CommitMessage::clear_client_contexts() {
  client_contexts_.Clear();
}
CommitMessage::CommitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  entries_(arena),
  extensions_activity_(arena),
  client_contexts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.CommitMessage)
}
CommitMessage::CommitMessage(const CommitMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      entries_(from.entries_),
      extensions_activity_(from.extensions_activity_),
      client_contexts_(from.client_contexts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  cache_guid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cache_guid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cache_guid()) {
    cache_guid_.Set(from._internal_cache_guid(), 
      GetArenaForAllocation());
  }
  padding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    padding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_padding()) {
    padding_.Set(from._internal_padding(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_config_params()) {
    config_params_ = new ::sync_pb::ClientConfigParams(*from.config_params_);
  } else {
    config_params_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.CommitMessage)
}

inline void CommitMessage::SharedCtor() {
cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
padding_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  padding_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
config_params_ = nullptr;
}

CommitMessage::~CommitMessage() {
  // @@protoc_insertion_point(destructor:sync_pb.CommitMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommitMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  cache_guid_.Destroy();
  padding_.Destroy();
  if (this != internal_default_instance()) delete config_params_;
}

void CommitMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommitMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.CommitMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  extensions_activity_.Clear();
  client_contexts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      cache_guid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      padding_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(config_params_ != nullptr);
      config_params_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommitMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sync_pb.SyncEntity entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string cache_guid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cache_guid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_extensions_activity(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ClientConfigParams config_params = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_config_params(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sync_pb.DataTypeContext client_contexts = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_client_contexts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string padding = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_padding();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommitMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sync_pb.SyncEntity entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional string cache_guid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cache_guid(), target);
  }

  // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_extensions_activity_size()); i < n; i++) {
    const auto& repfield = this->_internal_extensions_activity(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .sync_pb.ClientConfigParams config_params = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::config_params(this),
        _Internal::config_params(this).GetCachedSize(), target, stream);
  }

  // repeated .sync_pb.DataTypeContext client_contexts = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_client_contexts_size()); i < n; i++) {
    const auto& repfield = this->_internal_client_contexts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional string padding = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_padding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitMessage)
  return target;
}

size_t CommitMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sync_pb.SyncEntity entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
  total_size += 1UL * this->_internal_extensions_activity_size();
  for (const auto& msg : this->extensions_activity_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .sync_pb.DataTypeContext client_contexts = 5;
  total_size += 1UL * this->_internal_client_contexts_size();
  for (const auto& msg : this->client_contexts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string cache_guid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cache_guid());
    }

    // optional string padding = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_padding());
    }

    // optional .sync_pb.ClientConfigParams config_params = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *config_params_);
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommitMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommitMessage*>(
      &from));
}

void CommitMessage::MergeFrom(const CommitMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  extensions_activity_.MergeFrom(from.extensions_activity_);
  client_contexts_.MergeFrom(from.client_contexts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_cache_guid(from._internal_cache_guid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_padding(from._internal_padding());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_config_params()->::sync_pb::ClientConfigParams::MergeFrom(from._internal_config_params());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitMessage::CopyFrom(const CommitMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitMessage::IsInitialized() const {
  return true;
}

void CommitMessage::InternalSwap(CommitMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entries_.InternalSwap(&other->entries_);
  extensions_activity_.InternalSwap(&other->extensions_activity_);
  client_contexts_.InternalSwap(&other->client_contexts_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cache_guid_, lhs_arena,
      &other->cache_guid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &padding_, lhs_arena,
      &other->padding_, rhs_arena
  );
  swap(config_params_, other->config_params_);
}

std::string CommitMessage::GetTypeName() const {
  return "sync_pb.CommitMessage";
}


// ===================================================================

class GetUpdatesMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUpdatesMessage>()._has_bits_);
  static const ::sync_pb::GetUpdatesCallerInfo& caller_info(const GetUpdatesMessage* msg);
  static void set_has_caller_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fetch_folders(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_need_encryption_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_create_mobile_bookmarks_folder(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_get_updates_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_retry(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::sync_pb::GetUpdatesCallerInfo&
GetUpdatesMessage::_Internal::caller_info(const GetUpdatesMessage* msg) {
  return *msg->caller_info_;
}
void GetUpdatesMessage::clear_caller_info() {
  if (caller_info_ != nullptr) caller_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
void GetUpdatesMessage::clear_from_progress_marker() {
  from_progress_marker_.Clear();
}
void GetUpdatesMessage::clear_client_contexts() {
  client_contexts_.Clear();
}
GetUpdatesMessage::GetUpdatesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  from_progress_marker_(arena),
  client_contexts_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.GetUpdatesMessage)
}
GetUpdatesMessage::GetUpdatesMessage(const GetUpdatesMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      from_progress_marker_(from.from_progress_marker_),
      client_contexts_(from.client_contexts_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_caller_info()) {
    caller_info_ = new ::sync_pb::GetUpdatesCallerInfo(*from.caller_info_);
  } else {
    caller_info_ = nullptr;
  }
  ::memcpy(&get_updates_origin_, &from.get_updates_origin_,
    static_cast<size_t>(reinterpret_cast<char*>(&fetch_folders_) -
    reinterpret_cast<char*>(&get_updates_origin_)) + sizeof(fetch_folders_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.GetUpdatesMessage)
}

inline void GetUpdatesMessage::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&caller_info_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_retry_) -
    reinterpret_cast<char*>(&caller_info_)) + sizeof(is_retry_));
fetch_folders_ = true;
}

GetUpdatesMessage::~GetUpdatesMessage() {
  // @@protoc_insertion_point(destructor:sync_pb.GetUpdatesMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUpdatesMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete caller_info_;
}

void GetUpdatesMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetUpdatesMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.GetUpdatesMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  from_progress_marker_.Clear();
  client_contexts_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(caller_info_ != nullptr);
    caller_info_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&get_updates_origin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_retry_) -
        reinterpret_cast<char*>(&get_updates_origin_)) + sizeof(is_retry_));
    fetch_folders_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetUpdatesMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_caller_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool fetch_folders = 3 [default = true];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fetch_folders(&has_bits);
          fetch_folders_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_from_progress_marker(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool streaming = 7 [default = false];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_streaming(&has_bits);
          streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool need_encryption_key = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_need_encryption_key(&has_bits);
          need_encryption_key_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_GetUpdatesOrigin_IsValid(val))) {
            _internal_set_get_updates_origin(static_cast<::sync_pb::SyncEnums_GetUpdatesOrigin>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_retry = 10 [default = false];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_retry(&has_bits);
          is_retry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sync_pb.DataTypeContext client_contexts = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_client_contexts(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool create_mobile_bookmarks_folder = 1000 [default = false, deprecated = true];
      case 1000:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_create_mobile_bookmarks_folder(&has_bits);
          create_mobile_bookmarks_folder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUpdatesMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.GetUpdatesMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::caller_info(this),
        _Internal::caller_info(this).GetCachedSize(), target, stream);
  }

  // optional bool fetch_folders = 3 [default = true];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_fetch_folders(), target);
  }

  // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_from_progress_marker_size()); i < n; i++) {
    const auto& repfield = this->_internal_from_progress_marker(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool streaming = 7 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_streaming(), target);
  }

  // optional bool need_encryption_key = 8 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_need_encryption_key(), target);
  }

  // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      9, this->_internal_get_updates_origin(), target);
  }

  // optional bool is_retry = 10 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_is_retry(), target);
  }

  // repeated .sync_pb.DataTypeContext client_contexts = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_client_contexts_size()); i < n; i++) {
    const auto& repfield = this->_internal_client_contexts(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool create_mobile_bookmarks_folder = 1000 [default = false, deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1000, this->_internal_create_mobile_bookmarks_folder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.GetUpdatesMessage)
  return target;
}

size_t GetUpdatesMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.GetUpdatesMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
  total_size += 1UL * this->_internal_from_progress_marker_size();
  for (const auto& msg : this->from_progress_marker_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .sync_pb.DataTypeContext client_contexts = 11;
  total_size += 1UL * this->_internal_client_contexts_size();
  for (const auto& msg : this->client_contexts_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *caller_info_);
    }

    // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_get_updates_origin());
    }

    // optional bool streaming = 7 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool need_encryption_key = 8 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool create_mobile_bookmarks_folder = 1000 [default = false, deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 + 1;
    }

    // optional bool is_retry = 10 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool fetch_folders = 3 [default = true];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUpdatesMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetUpdatesMessage*>(
      &from));
}

void GetUpdatesMessage::MergeFrom(const GetUpdatesMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.GetUpdatesMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  from_progress_marker_.MergeFrom(from.from_progress_marker_);
  client_contexts_.MergeFrom(from.client_contexts_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_caller_info()->::sync_pb::GetUpdatesCallerInfo::MergeFrom(from._internal_caller_info());
    }
    if (cached_has_bits & 0x00000002u) {
      get_updates_origin_ = from.get_updates_origin_;
    }
    if (cached_has_bits & 0x00000004u) {
      streaming_ = from.streaming_;
    }
    if (cached_has_bits & 0x00000008u) {
      need_encryption_key_ = from.need_encryption_key_;
    }
    if (cached_has_bits & 0x00000010u) {
      create_mobile_bookmarks_folder_ = from.create_mobile_bookmarks_folder_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_retry_ = from.is_retry_;
    }
    if (cached_has_bits & 0x00000040u) {
      fetch_folders_ = from.fetch_folders_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUpdatesMessage::CopyFrom(const GetUpdatesMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.GetUpdatesMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUpdatesMessage::IsInitialized() const {
  if (_internal_has_caller_info()) {
    if (!caller_info_->IsInitialized()) return false;
  }
  return true;
}

void GetUpdatesMessage::InternalSwap(GetUpdatesMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  from_progress_marker_.InternalSwap(&other->from_progress_marker_);
  client_contexts_.InternalSwap(&other->client_contexts_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GetUpdatesMessage, is_retry_)
      + sizeof(GetUpdatesMessage::is_retry_)
      - PROTOBUF_FIELD_OFFSET(GetUpdatesMessage, caller_info_)>(
          reinterpret_cast<char*>(&caller_info_),
          reinterpret_cast<char*>(&other->caller_info_));
  swap(fetch_folders_, other->fetch_folders_);
}

std::string GetUpdatesMessage::GetTypeName() const {
  return "sync_pb.GetUpdatesMessage";
}


// ===================================================================

class ClearServerDataMessage::_Internal {
 public:
};

ClearServerDataMessage::ClearServerDataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClearServerDataMessage)
}
ClearServerDataMessage::ClearServerDataMessage(const ClearServerDataMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClearServerDataMessage)
}

inline void ClearServerDataMessage::SharedCtor() {
}

ClearServerDataMessage::~ClearServerDataMessage() {
  // @@protoc_insertion_point(destructor:sync_pb.ClearServerDataMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearServerDataMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearServerDataMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClearServerDataMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClearServerDataMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ClearServerDataMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClearServerDataMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClearServerDataMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClearServerDataMessage)
  return target;
}

size_t ClearServerDataMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClearServerDataMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClearServerDataMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClearServerDataMessage*>(
      &from));
}

void ClearServerDataMessage::MergeFrom(const ClearServerDataMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClearServerDataMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClearServerDataMessage::CopyFrom(const ClearServerDataMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClearServerDataMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearServerDataMessage::IsInitialized() const {
  return true;
}

void ClearServerDataMessage::InternalSwap(ClearServerDataMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClearServerDataMessage::GetTypeName() const {
  return "sync_pb.ClearServerDataMessage";
}


// ===================================================================

class ClearServerDataResponse::_Internal {
 public:
};

ClearServerDataResponse::ClearServerDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClearServerDataResponse)
}
ClearServerDataResponse::ClearServerDataResponse(const ClearServerDataResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClearServerDataResponse)
}

inline void ClearServerDataResponse::SharedCtor() {
}

ClearServerDataResponse::~ClearServerDataResponse() {
  // @@protoc_insertion_point(destructor:sync_pb.ClearServerDataResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClearServerDataResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClearServerDataResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClearServerDataResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClearServerDataResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* ClearServerDataResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClearServerDataResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClearServerDataResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClearServerDataResponse)
  return target;
}

size_t ClearServerDataResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClearServerDataResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClearServerDataResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClearServerDataResponse*>(
      &from));
}

void ClearServerDataResponse::MergeFrom(const ClearServerDataResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClearServerDataResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClearServerDataResponse::CopyFrom(const ClearServerDataResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClearServerDataResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClearServerDataResponse::IsInitialized() const {
  return true;
}

void ClearServerDataResponse::InternalSwap(ClearServerDataResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string ClearServerDataResponse::GetTypeName() const {
  return "sync_pb.ClearServerDataResponse";
}


// ===================================================================

class ChipBag::_Internal {
 public:
  using HasBits = decltype(std::declval<ChipBag>()._has_bits_);
  static void set_has_server_chips(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

ChipBag::ChipBag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ChipBag)
}
ChipBag::ChipBag(const ChipBag& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  server_chips_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    server_chips_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_server_chips()) {
    server_chips_.Set(from._internal_server_chips(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.ChipBag)
}

inline void ChipBag::SharedCtor() {
server_chips_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  server_chips_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ChipBag::~ChipBag() {
  // @@protoc_insertion_point(destructor:sync_pb.ChipBag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ChipBag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  server_chips_.Destroy();
}

void ChipBag::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ChipBag::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ChipBag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    server_chips_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ChipBag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes server_chips = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_server_chips();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ChipBag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ChipBag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes server_chips = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_server_chips(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ChipBag)
  return target;
}

size_t ChipBag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ChipBag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes server_chips = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_server_chips());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ChipBag::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ChipBag*>(
      &from));
}

void ChipBag::MergeFrom(const ChipBag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ChipBag)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_server_chips()) {
    _internal_set_server_chips(from._internal_server_chips());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ChipBag::CopyFrom(const ChipBag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ChipBag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ChipBag::IsInitialized() const {
  return true;
}

void ChipBag::InternalSwap(ChipBag* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &server_chips_, lhs_arena,
      &other->server_chips_, rhs_arena
  );
}

std::string ChipBag::GetTypeName() const {
  return "sync_pb.ChipBag";
}


// ===================================================================

class ClientStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientStatus>()._has_bits_);
  static void set_has_hierarchy_conflict_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_sync_feature_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ClientStatus::ClientStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClientStatus)
}
ClientStatus::ClientStatus(const ClientStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  ::memcpy(&hierarchy_conflict_detected_, &from.hierarchy_conflict_detected_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_sync_feature_enabled_) -
    reinterpret_cast<char*>(&hierarchy_conflict_detected_)) + sizeof(is_sync_feature_enabled_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClientStatus)
}

inline void ClientStatus::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hierarchy_conflict_detected_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_sync_feature_enabled_) -
    reinterpret_cast<char*>(&hierarchy_conflict_detected_)) + sizeof(is_sync_feature_enabled_));
}

ClientStatus::~ClientStatus() {
  // @@protoc_insertion_point(destructor:sync_pb.ClientStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ClientStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClientStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&hierarchy_conflict_detected_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_sync_feature_enabled_) -
      reinterpret_cast<char*>(&hierarchy_conflict_detected_)) + sizeof(is_sync_feature_enabled_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_hierarchy_conflict_detected(&has_bits);
          hierarchy_conflict_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_sync_feature_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_sync_feature_enabled(&has_bits);
          is_sync_feature_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_hierarchy_conflict_detected(), target);
  }

  // optional bool is_sync_feature_enabled = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_sync_feature_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientStatus)
  return target;
}

size_t ClientStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool is_sync_feature_enabled = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientStatus::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientStatus*>(
      &from));
}

void ClientStatus::MergeFrom(const ClientStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hierarchy_conflict_detected_ = from.hierarchy_conflict_detected_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_sync_feature_enabled_ = from.is_sync_feature_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientStatus::CopyFrom(const ClientStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientStatus::IsInitialized() const {
  return true;
}

void ClientStatus::InternalSwap(ClientStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientStatus, is_sync_feature_enabled_)
      + sizeof(ClientStatus::is_sync_feature_enabled_)
      - PROTOBUF_FIELD_OFFSET(ClientStatus, hierarchy_conflict_detected_)>(
          reinterpret_cast<char*>(&hierarchy_conflict_detected_),
          reinterpret_cast<char*>(&other->hierarchy_conflict_detected_));
}

std::string ClientStatus::GetTypeName() const {
  return "sync_pb.ClientStatus";
}


// ===================================================================

class ClientToServerMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientToServerMessage>()._has_bits_);
  static void set_has_share(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_protocol_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_message_contents(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::sync_pb::CommitMessage& commit(const ClientToServerMessage* msg);
  static void set_has_commit(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::sync_pb::GetUpdatesMessage& get_updates(const ClientToServerMessage* msg);
  static void set_has_get_updates(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_store_birthday(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sync_problem_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static const ::sync_pb::DebugInfo& debug_info(const ClientToServerMessage* msg);
  static void set_has_debug_info(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::sync_pb::ChipBag& bag_of_chips(const ClientToServerMessage* msg);
  static void set_has_bag_of_chips(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_api_key(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sync_pb::ClientStatus& client_status(const ClientToServerMessage* msg);
  static void set_has_client_status(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_invalidator_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::sync_pb::ClearServerDataMessage& clear_server_data(const ClientToServerMessage* msg);
  static void set_has_clear_server_data(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00001001) ^ 0x00001001) != 0;
  }
};

const ::sync_pb::CommitMessage&
ClientToServerMessage::_Internal::commit(const ClientToServerMessage* msg) {
  return *msg->commit_;
}
const ::sync_pb::GetUpdatesMessage&
ClientToServerMessage::_Internal::get_updates(const ClientToServerMessage* msg) {
  return *msg->get_updates_;
}
const ::sync_pb::DebugInfo&
ClientToServerMessage::_Internal::debug_info(const ClientToServerMessage* msg) {
  return *msg->debug_info_;
}
const ::sync_pb::ChipBag&
ClientToServerMessage::_Internal::bag_of_chips(const ClientToServerMessage* msg) {
  return *msg->bag_of_chips_;
}
const ::sync_pb::ClientStatus&
ClientToServerMessage::_Internal::client_status(const ClientToServerMessage* msg) {
  return *msg->client_status_;
}
const ::sync_pb::ClearServerDataMessage&
ClientToServerMessage::_Internal::clear_server_data(const ClientToServerMessage* msg) {
  return *msg->clear_server_data_;
}
void ClientToServerMessage::clear_debug_info() {
  if (debug_info_ != nullptr) debug_info_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
ClientToServerMessage::ClientToServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClientToServerMessage)
}
ClientToServerMessage::ClientToServerMessage(const ClientToServerMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  share_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    share_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_share()) {
    share_.Set(from._internal_share(), 
      GetArenaForAllocation());
  }
  store_birthday_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_birthday_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_birthday()) {
    store_birthday_.Set(from._internal_store_birthday(), 
      GetArenaForAllocation());
  }
  api_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    api_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_api_key()) {
    api_key_.Set(from._internal_api_key(), 
      GetArenaForAllocation());
  }
  invalidator_client_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    invalidator_client_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_invalidator_client_id()) {
    invalidator_client_id_.Set(from._internal_invalidator_client_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_commit()) {
    commit_ = new ::sync_pb::CommitMessage(*from.commit_);
  } else {
    commit_ = nullptr;
  }
  if (from._internal_has_get_updates()) {
    get_updates_ = new ::sync_pb::GetUpdatesMessage(*from.get_updates_);
  } else {
    get_updates_ = nullptr;
  }
  if (from._internal_has_debug_info()) {
    debug_info_ = new ::sync_pb::DebugInfo(*from.debug_info_);
  } else {
    debug_info_ = nullptr;
  }
  if (from._internal_has_bag_of_chips()) {
    bag_of_chips_ = new ::sync_pb::ChipBag(*from.bag_of_chips_);
  } else {
    bag_of_chips_ = nullptr;
  }
  if (from._internal_has_client_status()) {
    client_status_ = new ::sync_pb::ClientStatus(*from.client_status_);
  } else {
    client_status_ = nullptr;
  }
  if (from._internal_has_clear_server_data()) {
    clear_server_data_ = new ::sync_pb::ClearServerDataMessage(*from.clear_server_data_);
  } else {
    clear_server_data_ = nullptr;
  }
  ::memcpy(&sync_problem_detected_, &from.sync_problem_detected_,
    static_cast<size_t>(reinterpret_cast<char*>(&message_contents_) -
    reinterpret_cast<char*>(&sync_problem_detected_)) + sizeof(message_contents_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClientToServerMessage)
}

inline void ClientToServerMessage::SharedCtor() {
share_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  share_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
api_key_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  api_key_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
invalidator_client_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  invalidator_client_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&commit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&sync_problem_detected_) -
    reinterpret_cast<char*>(&commit_)) + sizeof(sync_problem_detected_));
protocol_version_ = 99;
message_contents_ = 1;
}

ClientToServerMessage::~ClientToServerMessage() {
  // @@protoc_insertion_point(destructor:sync_pb.ClientToServerMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientToServerMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  share_.Destroy();
  store_birthday_.Destroy();
  api_key_.Destroy();
  invalidator_client_id_.Destroy();
  if (this != internal_default_instance()) delete commit_;
  if (this != internal_default_instance()) delete get_updates_;
  if (this != internal_default_instance()) delete debug_info_;
  if (this != internal_default_instance()) delete bag_of_chips_;
  if (this != internal_default_instance()) delete client_status_;
  if (this != internal_default_instance()) delete clear_server_data_;
}

void ClientToServerMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientToServerMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClientToServerMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      share_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      store_birthday_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      api_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      invalidator_client_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(commit_ != nullptr);
      commit_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(get_updates_ != nullptr);
      get_updates_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(debug_info_ != nullptr);
      debug_info_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(bag_of_chips_ != nullptr);
      bag_of_chips_->Clear();
    }
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(client_status_ != nullptr);
      client_status_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(clear_server_data_ != nullptr);
      clear_server_data_->Clear();
    }
  }
  if (cached_has_bits & 0x00001c00u) {
    sync_problem_detected_ = false;
    protocol_version_ = 99;
    message_contents_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientToServerMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string share = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_share();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 protocol_version = 2 [default = 99];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_protocol_version(&has_bits);
          protocol_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sync_pb::ClientToServerMessage_Contents_IsValid(val))) {
            _internal_set_message_contents(static_cast<::sync_pb::ClientToServerMessage_Contents>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.CommitMessage commit = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_commit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.GetUpdatesMessage get_updates = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_updates(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string store_birthday = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_store_birthday();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool sync_problem_detected = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_sync_problem_detected(&has_bits);
          sync_problem_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.DebugInfo debug_info = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_debug_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ChipBag bag_of_chips = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_bag_of_chips(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string api_key = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_api_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ClientStatus client_status = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string invalidator_client_id = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_invalidator_client_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_clear_server_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientToServerMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientToServerMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string share = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_share(), target);
  }

  // optional int32 protocol_version = 2 [default = 99];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_protocol_version(), target);
  }

  // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      3, this->_internal_message_contents(), target);
  }

  // optional .sync_pb.CommitMessage commit = 4;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::commit(this),
        _Internal::commit(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.GetUpdatesMessage get_updates = 5;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::get_updates(this),
        _Internal::get_updates(this).GetCachedSize(), target, stream);
  }

  // optional string store_birthday = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_store_birthday(), target);
  }

  // optional bool sync_problem_detected = 8 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_sync_problem_detected(), target);
  }

  // optional .sync_pb.DebugInfo debug_info = 10;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::debug_info(this),
        _Internal::debug_info(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.ChipBag bag_of_chips = 11;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::bag_of_chips(this),
        _Internal::bag_of_chips(this).GetCachedSize(), target, stream);
  }

  // optional string api_key = 12;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_api_key(), target);
  }

  // optional .sync_pb.ClientStatus client_status = 13;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::client_status(this),
        _Internal::client_status(this).GetCachedSize(), target, stream);
  }

  // optional string invalidator_client_id = 14;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_invalidator_client_id(), target);
  }

  // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::clear_server_data(this),
        _Internal::clear_server_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientToServerMessage)
  return target;
}

size_t ClientToServerMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:sync_pb.ClientToServerMessage)
  size_t total_size = 0;

  if (_internal_has_share()) {
    // required string share = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_share());
  }

  if (_internal_has_message_contents()) {
    // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_message_contents());
  }

  return total_size;
}
size_t ClientToServerMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientToServerMessage)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00001001) ^ 0x00001001) == 0) {  // All required fields are present.
    // required string share = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_share());

    // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_message_contents());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string store_birthday = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_birthday());
    }

    // optional string api_key = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_api_key());
    }

    // optional string invalidator_client_id = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_invalidator_client_id());
    }

    // optional .sync_pb.CommitMessage commit = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *commit_);
    }

    // optional .sync_pb.GetUpdatesMessage get_updates = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *get_updates_);
    }

    // optional .sync_pb.DebugInfo debug_info = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *debug_info_);
    }

    // optional .sync_pb.ChipBag bag_of_chips = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bag_of_chips_);
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .sync_pb.ClientStatus client_status = 13;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_status_);
    }

    // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *clear_server_data_);
    }

    // optional bool sync_problem_detected = 8 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 protocol_version = 2 [default = 99];
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_protocol_version());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToServerMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientToServerMessage*>(
      &from));
}

void ClientToServerMessage::MergeFrom(const ClientToServerMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientToServerMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_share(from._internal_share());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_store_birthday(from._internal_store_birthday());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_api_key(from._internal_api_key());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_invalidator_client_id(from._internal_invalidator_client_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_commit()->::sync_pb::CommitMessage::MergeFrom(from._internal_commit());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_get_updates()->::sync_pb::GetUpdatesMessage::MergeFrom(from._internal_get_updates());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_debug_info()->::sync_pb::DebugInfo::MergeFrom(from._internal_debug_info());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_bag_of_chips()->::sync_pb::ChipBag::MergeFrom(from._internal_bag_of_chips());
    }
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _internal_mutable_client_status()->::sync_pb::ClientStatus::MergeFrom(from._internal_client_status());
    }
    if (cached_has_bits & 0x00000200u) {
      _internal_mutable_clear_server_data()->::sync_pb::ClearServerDataMessage::MergeFrom(from._internal_clear_server_data());
    }
    if (cached_has_bits & 0x00000400u) {
      sync_problem_detected_ = from.sync_problem_detected_;
    }
    if (cached_has_bits & 0x00000800u) {
      protocol_version_ = from.protocol_version_;
    }
    if (cached_has_bits & 0x00001000u) {
      message_contents_ = from.message_contents_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToServerMessage::CopyFrom(const ClientToServerMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientToServerMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToServerMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_get_updates()) {
    if (!get_updates_->IsInitialized()) return false;
  }
  if (_internal_has_debug_info()) {
    if (!debug_info_->IsInitialized()) return false;
  }
  return true;
}

void ClientToServerMessage::InternalSwap(ClientToServerMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &share_, lhs_arena,
      &other->share_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &store_birthday_, lhs_arena,
      &other->store_birthday_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &api_key_, lhs_arena,
      &other->api_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &invalidator_client_id_, lhs_arena,
      &other->invalidator_client_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientToServerMessage, sync_problem_detected_)
      + sizeof(ClientToServerMessage::sync_problem_detected_)
      - PROTOBUF_FIELD_OFFSET(ClientToServerMessage, commit_)>(
          reinterpret_cast<char*>(&commit_),
          reinterpret_cast<char*>(&other->commit_));
  swap(protocol_version_, other->protocol_version_);
  swap(message_contents_, other->message_contents_);
}

std::string ClientToServerMessage::GetTypeName() const {
  return "sync_pb.ClientToServerMessage";
}


// ===================================================================

class CommitResponse_EntryResponse_DatatypeSpecificError::_Internal {
 public:
  static const ::sync_pb::SharingMessageCommitError& sharing_message_error(const CommitResponse_EntryResponse_DatatypeSpecificError* msg);
};

const ::sync_pb::SharingMessageCommitError&
CommitResponse_EntryResponse_DatatypeSpecificError::_Internal::sharing_message_error(const CommitResponse_EntryResponse_DatatypeSpecificError* msg) {
  return *msg->datatype_error_.sharing_message_error_;
}
void CommitResponse_EntryResponse_DatatypeSpecificError::set_allocated_sharing_message_error(::sync_pb::SharingMessageCommitError* sharing_message_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_datatype_error();
  if (sharing_message_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sharing_message_error));
    if (message_arena != submessage_arena) {
      sharing_message_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sharing_message_error, submessage_arena);
    }
    set_has_sharing_message_error();
    datatype_error_.sharing_message_error_ = sharing_message_error;
  }
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
}
void CommitResponse_EntryResponse_DatatypeSpecificError::clear_sharing_message_error() {
  if (_internal_has_sharing_message_error()) {
    if (GetArenaForAllocation() == nullptr) {
      delete datatype_error_.sharing_message_error_;
    }
    clear_has_datatype_error();
  }
}
CommitResponse_EntryResponse_DatatypeSpecificError::CommitResponse_EntryResponse_DatatypeSpecificError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
}
CommitResponse_EntryResponse_DatatypeSpecificError::CommitResponse_EntryResponse_DatatypeSpecificError(const CommitResponse_EntryResponse_DatatypeSpecificError& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_datatype_error();
  switch (from.datatype_error_case()) {
    case kSharingMessageError: {
      _internal_mutable_sharing_message_error()->::sync_pb::SharingMessageCommitError::MergeFrom(from._internal_sharing_message_error());
      break;
    }
    case DATATYPE_ERROR_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
}

inline void CommitResponse_EntryResponse_DatatypeSpecificError::SharedCtor() {
clear_has_datatype_error();
}

CommitResponse_EntryResponse_DatatypeSpecificError::~CommitResponse_EntryResponse_DatatypeSpecificError() {
  // @@protoc_insertion_point(destructor:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommitResponse_EntryResponse_DatatypeSpecificError::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_datatype_error()) {
    clear_datatype_error();
  }
}

void CommitResponse_EntryResponse_DatatypeSpecificError::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommitResponse_EntryResponse_DatatypeSpecificError::clear_datatype_error() {
// @@protoc_insertion_point(one_of_clear_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  switch (datatype_error_case()) {
    case kSharingMessageError: {
      if (GetArenaForAllocation() == nullptr) {
        delete datatype_error_.sharing_message_error_;
      }
      break;
    }
    case DATATYPE_ERROR_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DATATYPE_ERROR_NOT_SET;
}


void CommitResponse_EntryResponse_DatatypeSpecificError::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_datatype_error();
  _internal_metadata_.Clear<std::string>();
}

const char* CommitResponse_EntryResponse_DatatypeSpecificError::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sharing_message_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommitResponse_EntryResponse_DatatypeSpecificError::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
  if (_internal_has_sharing_message_error()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sharing_message_error(this),
        _Internal::sharing_message_error(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  return target;
}

size_t CommitResponse_EntryResponse_DatatypeSpecificError::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (datatype_error_case()) {
    // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
    case kSharingMessageError: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *datatype_error_.sharing_message_error_);
      break;
    }
    case DATATYPE_ERROR_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommitResponse_EntryResponse_DatatypeSpecificError::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommitResponse_EntryResponse_DatatypeSpecificError*>(
      &from));
}

void CommitResponse_EntryResponse_DatatypeSpecificError::MergeFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.datatype_error_case()) {
    case kSharingMessageError: {
      _internal_mutable_sharing_message_error()->::sync_pb::SharingMessageCommitError::MergeFrom(from._internal_sharing_message_error());
      break;
    }
    case DATATYPE_ERROR_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitResponse_EntryResponse_DatatypeSpecificError::CopyFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitResponse_EntryResponse_DatatypeSpecificError::IsInitialized() const {
  return true;
}

void CommitResponse_EntryResponse_DatatypeSpecificError::InternalSwap(CommitResponse_EntryResponse_DatatypeSpecificError* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(datatype_error_, other->datatype_error_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string CommitResponse_EntryResponse_DatatypeSpecificError::GetTypeName() const {
  return "sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError";
}


// ===================================================================

class CommitResponse_EntryResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CommitResponse_EntryResponse>()._has_bits_);
  static void set_has_response_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_id_string(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_mtime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& datatype_specific_error(const CommitResponse_EntryResponse* msg);
  static void set_has_datatype_specific_error(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000020) ^ 0x00000020) != 0;
  }
};

const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError&
CommitResponse_EntryResponse::_Internal::datatype_specific_error(const CommitResponse_EntryResponse* msg) {
  return *msg->datatype_specific_error_;
}
CommitResponse_EntryResponse::CommitResponse_EntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.CommitResponse.EntryResponse)
}
CommitResponse_EntryResponse::CommitResponse_EntryResponse(const CommitResponse_EntryResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  id_string_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    id_string_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_id_string()) {
    id_string_.Set(from._internal_id_string(), 
      GetArenaForAllocation());
  }
  error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    error_message_.Set(from._internal_error_message(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_datatype_specific_error()) {
    datatype_specific_error_ = new ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError(*from.datatype_specific_error_);
  } else {
    datatype_specific_error_ = nullptr;
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&response_type_) -
    reinterpret_cast<char*>(&version_)) + sizeof(response_type_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.CommitResponse.EntryResponse)
}

inline void CommitResponse_EntryResponse::SharedCtor() {
id_string_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  id_string_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&datatype_specific_error_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mtime_) -
    reinterpret_cast<char*>(&datatype_specific_error_)) + sizeof(mtime_));
response_type_ = 1;
}

CommitResponse_EntryResponse::~CommitResponse_EntryResponse() {
  // @@protoc_insertion_point(destructor:sync_pb.CommitResponse.EntryResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommitResponse_EntryResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  id_string_.Destroy();
  error_message_.Destroy();
  if (this != internal_default_instance()) delete datatype_specific_error_;
}

void CommitResponse_EntryResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommitResponse_EntryResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.CommitResponse.EntryResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      id_string_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(datatype_specific_error_ != nullptr);
      datatype_specific_error_->Clear();
    }
  }
  if (cached_has_bits & 0x00000038u) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mtime_) -
        reinterpret_cast<char*>(&version_)) + sizeof(mtime_));
    response_type_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommitResponse_EntryResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .sync_pb.CommitResponse.ResponseType response_type = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sync_pb::CommitResponse_ResponseType_IsValid(val))) {
            _internal_set_response_type(static_cast<::sync_pb::CommitResponse_ResponseType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string id_string = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_id_string();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 version = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 mtime = 10 [deprecated = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_mtime(&has_bits);
          mtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_datatype_specific_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommitResponse_EntryResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitResponse.EntryResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .sync_pb.CommitResponse.ResponseType response_type = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_response_type(), target);
  }

  // optional string id_string = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_id_string(), target);
  }

  // optional int64 version = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(6, this->_internal_version(), target);
  }

  // optional string error_message = 9;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_error_message(), target);
  }

  // optional int64 mtime = 10 [deprecated = true];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(10, this->_internal_mtime(), target);
  }

  // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::datatype_specific_error(this),
        _Internal::datatype_specific_error(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitResponse.EntryResponse)
  return target;
}

size_t CommitResponse_EntryResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitResponse.EntryResponse)
  size_t total_size = 0;

  // required .sync_pb.CommitResponse.ResponseType response_type = 2;
  if (_internal_has_response_type()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_response_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string id_string = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_id_string());
    }

    // optional string error_message = 9;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *datatype_specific_error_);
    }

    // optional int64 version = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_version());
    }

    // optional int64 mtime = 10 [deprecated = true];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_mtime());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommitResponse_EntryResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommitResponse_EntryResponse*>(
      &from));
}

void CommitResponse_EntryResponse::MergeFrom(const CommitResponse_EntryResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitResponse.EntryResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_id_string(from._internal_id_string());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_datatype_specific_error()->::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError::MergeFrom(from._internal_datatype_specific_error());
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000010u) {
      mtime_ = from.mtime_;
    }
    if (cached_has_bits & 0x00000020u) {
      response_type_ = from.response_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitResponse_EntryResponse::CopyFrom(const CommitResponse_EntryResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitResponse.EntryResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitResponse_EntryResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CommitResponse_EntryResponse::InternalSwap(CommitResponse_EntryResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &id_string_, lhs_arena,
      &other->id_string_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &error_message_, lhs_arena,
      &other->error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CommitResponse_EntryResponse, mtime_)
      + sizeof(CommitResponse_EntryResponse::mtime_)
      - PROTOBUF_FIELD_OFFSET(CommitResponse_EntryResponse, datatype_specific_error_)>(
          reinterpret_cast<char*>(&datatype_specific_error_),
          reinterpret_cast<char*>(&other->datatype_specific_error_));
  swap(response_type_, other->response_type_);
}

std::string CommitResponse_EntryResponse::GetTypeName() const {
  return "sync_pb.CommitResponse.EntryResponse";
}


// ===================================================================

class CommitResponse::_Internal {
 public:
};

CommitResponse::CommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  entryresponse_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.CommitResponse)
}
CommitResponse::CommitResponse(const CommitResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      entryresponse_(from.entryresponse_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.CommitResponse)
}

inline void CommitResponse::SharedCtor() {
}

CommitResponse::~CommitResponse() {
  // @@protoc_insertion_point(destructor:sync_pb.CommitResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommitResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommitResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CommitResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.CommitResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entryresponse_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* CommitResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated group EntryResponse = 1 { ... };
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 11)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseGroup(_internal_add_entryresponse(), ptr, 11);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<11>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CommitResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.CommitResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated group EntryResponse = 1 { ... };
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entryresponse_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteGroup(1, this->_internal_entryresponse(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.CommitResponse)
  return target;
}

size_t CommitResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.CommitResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated group EntryResponse = 1 { ... };
  total_size += 2UL * this->_internal_entryresponse_size();
  for (const auto& msg : this->entryresponse_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GroupSize(msg);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CommitResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CommitResponse*>(
      &from));
}

void CommitResponse::MergeFrom(const CommitResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.CommitResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entryresponse_.MergeFrom(from.entryresponse_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CommitResponse::CopyFrom(const CommitResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.CommitResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommitResponse::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entryresponse_))
    return false;
  return true;
}

void CommitResponse::InternalSwap(CommitResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entryresponse_.InternalSwap(&other->entryresponse_);
}

std::string CommitResponse::GetTypeName() const {
  return "sync_pb.CommitResponse";
}


// ===================================================================

class GetUpdatesResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<GetUpdatesResponse>()._has_bits_);
  static void set_has_changes_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

void GetUpdatesResponse::clear_entries() {
  entries_.Clear();
}
void GetUpdatesResponse::clear_new_progress_marker() {
  new_progress_marker_.Clear();
}
void GetUpdatesResponse::clear_context_mutations() {
  context_mutations_.Clear();
}
GetUpdatesResponse::GetUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  entries_(arena),
  new_progress_marker_(arena),
  encryption_keys_(arena),
  context_mutations_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.GetUpdatesResponse)
}
GetUpdatesResponse::GetUpdatesResponse(const GetUpdatesResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      entries_(from.entries_),
      new_progress_marker_(from.new_progress_marker_),
      encryption_keys_(from.encryption_keys_),
      context_mutations_(from.context_mutations_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  changes_remaining_ = from.changes_remaining_;
  // @@protoc_insertion_point(copy_constructor:sync_pb.GetUpdatesResponse)
}

inline void GetUpdatesResponse::SharedCtor() {
changes_remaining_ = int64_t{0};
}

GetUpdatesResponse::~GetUpdatesResponse() {
  // @@protoc_insertion_point(destructor:sync_pb.GetUpdatesResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetUpdatesResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GetUpdatesResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GetUpdatesResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.GetUpdatesResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  new_progress_marker_.Clear();
  encryption_keys_.Clear();
  context_mutations_.Clear();
  changes_remaining_ = int64_t{0};
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* GetUpdatesResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sync_pb.SyncEntity entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 changes_remaining = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_changes_remaining(&has_bits);
          changes_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_new_progress_marker(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated bytes encryption_keys = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_encryption_keys();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .sync_pb.DataTypeContext context_mutations = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_context_mutations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetUpdatesResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.GetUpdatesResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sync_pb.SyncEntity entries = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_entries_size()); i < n; i++) {
    const auto& repfield = this->_internal_entries(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int64 changes_remaining = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_changes_remaining(), target);
  }

  // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_new_progress_marker_size()); i < n; i++) {
    const auto& repfield = this->_internal_new_progress_marker(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(5, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated bytes encryption_keys = 6;
  for (int i = 0, n = this->_internal_encryption_keys_size(); i < n; i++) {
    const auto& s = this->_internal_encryption_keys(i);
    target = stream->WriteBytes(6, s, target);
  }

  // repeated .sync_pb.DataTypeContext context_mutations = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_context_mutations_size()); i < n; i++) {
    const auto& repfield = this->_internal_context_mutations(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.GetUpdatesResponse)
  return target;
}

size_t GetUpdatesResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.GetUpdatesResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sync_pb.SyncEntity entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
  total_size += 1UL * this->_internal_new_progress_marker_size();
  for (const auto& msg : this->new_progress_marker_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated bytes encryption_keys = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(encryption_keys_.size());
  for (int i = 0, n = encryption_keys_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      encryption_keys_.Get(i));
  }

  // repeated .sync_pb.DataTypeContext context_mutations = 7;
  total_size += 1UL * this->_internal_context_mutations_size();
  for (const auto& msg : this->context_mutations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int64 changes_remaining = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_changes_remaining());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void GetUpdatesResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const GetUpdatesResponse*>(
      &from));
}

void GetUpdatesResponse::MergeFrom(const GetUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.GetUpdatesResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  new_progress_marker_.MergeFrom(from.new_progress_marker_);
  encryption_keys_.MergeFrom(from.encryption_keys_);
  context_mutations_.MergeFrom(from.context_mutations_);
  if (from._internal_has_changes_remaining()) {
    _internal_set_changes_remaining(from._internal_changes_remaining());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void GetUpdatesResponse::CopyFrom(const GetUpdatesResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.GetUpdatesResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetUpdatesResponse::IsInitialized() const {
  return true;
}

void GetUpdatesResponse::InternalSwap(GetUpdatesResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entries_.InternalSwap(&other->entries_);
  new_progress_marker_.InternalSwap(&other->new_progress_marker_);
  encryption_keys_.InternalSwap(&other->encryption_keys_);
  context_mutations_.InternalSwap(&other->context_mutations_);
  swap(changes_remaining_, other->changes_remaining_);
}

std::string GetUpdatesResponse::GetTypeName() const {
  return "sync_pb.GetUpdatesResponse";
}


// ===================================================================

class ClientToServerResponse_Error::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientToServerResponse_Error>()._has_bits_);
  static void set_has_error_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_error_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

ClientToServerResponse_Error::ClientToServerResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  error_data_type_ids_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClientToServerResponse.Error)
}
ClientToServerResponse_Error::ClientToServerResponse_Error(const ClientToServerResponse_Error& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      error_data_type_ids_(from.error_data_type_ids_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_description_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_description_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_description()) {
    error_description_.Set(from._internal_error_description(), 
      GetArenaForAllocation());
  }
  ::memcpy(&error_type_, &from.error_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&action_) -
    reinterpret_cast<char*>(&error_type_)) + sizeof(action_));
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClientToServerResponse.Error)
}

inline void ClientToServerResponse_Error::SharedCtor() {
error_description_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_description_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
error_type_ = 100;
action_ = 5;
}

ClientToServerResponse_Error::~ClientToServerResponse_Error() {
  // @@protoc_insertion_point(destructor:sync_pb.ClientToServerResponse.Error)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientToServerResponse_Error::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_description_.Destroy();
}

void ClientToServerResponse_Error::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientToServerResponse_Error::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClientToServerResponse.Error)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  error_data_type_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      error_description_.ClearNonDefaultToEmpty();
    }
    error_type_ = 100;
    action_ = 5;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientToServerResponse_Error::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_ErrorType_IsValid(val))) {
            _internal_set_error_type(static_cast<::sync_pb::SyncEnums_ErrorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string error_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_error_description();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_Action_IsValid(val))) {
            _internal_set_action(static_cast<::sync_pb::SyncEnums_Action>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int32 error_data_type_ids = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_error_data_type_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_error_data_type_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientToServerResponse_Error::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientToServerResponse.Error)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_error_type(), target);
  }

  // optional string error_description = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_error_description(), target);
  }

  // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_action(), target);
  }

  // repeated int32 error_data_type_ids = 5;
  for (int i = 0, n = this->_internal_error_data_type_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_error_data_type_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientToServerResponse.Error)
  return target;
}

size_t ClientToServerResponse_Error::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientToServerResponse.Error)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 error_data_type_ids = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->error_data_type_ids_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_error_data_type_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string error_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_description());
    }

    // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_error_type());
    }

    // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_action());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToServerResponse_Error::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientToServerResponse_Error*>(
      &from));
}

void ClientToServerResponse_Error::MergeFrom(const ClientToServerResponse_Error& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientToServerResponse.Error)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  error_data_type_ids_.MergeFrom(from.error_data_type_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_description(from._internal_error_description());
    }
    if (cached_has_bits & 0x00000002u) {
      error_type_ = from.error_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      action_ = from.action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToServerResponse_Error::CopyFrom(const ClientToServerResponse_Error& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientToServerResponse.Error)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToServerResponse_Error::IsInitialized() const {
  return true;
}

void ClientToServerResponse_Error::InternalSwap(ClientToServerResponse_Error* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  error_data_type_ids_.InternalSwap(&other->error_data_type_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &error_description_, lhs_arena,
      &other->error_description_, rhs_arena
  );
  swap(error_type_, other->error_type_);
  swap(action_, other->action_);
}

std::string ClientToServerResponse_Error::GetTypeName() const {
  return "sync_pb.ClientToServerResponse.Error";
}


// ===================================================================

class ClientToServerResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<ClientToServerResponse>()._has_bits_);
  static const ::sync_pb::CommitResponse& commit(const ClientToServerResponse* msg);
  static void set_has_commit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sync_pb::GetUpdatesResponse& get_updates(const ClientToServerResponse* msg);
  static void set_has_get_updates(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_error_code(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_store_birthday(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sync_pb::ClientCommand& client_command(const ClientToServerResponse* msg);
  static void set_has_client_command(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::sync_pb::ClientToServerResponse_Error& error(const ClientToServerResponse* msg);
  static void set_has_error(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::sync_pb::ChipBag& new_bag_of_chips(const ClientToServerResponse* msg);
  static void set_has_new_bag_of_chips(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::sync_pb::ClearServerDataResponse& clear_server_data(const ClientToServerResponse* msg);
  static void set_has_clear_server_data(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

const ::sync_pb::CommitResponse&
ClientToServerResponse::_Internal::commit(const ClientToServerResponse* msg) {
  return *msg->commit_;
}
const ::sync_pb::GetUpdatesResponse&
ClientToServerResponse::_Internal::get_updates(const ClientToServerResponse* msg) {
  return *msg->get_updates_;
}
const ::sync_pb::ClientCommand&
ClientToServerResponse::_Internal::client_command(const ClientToServerResponse* msg) {
  return *msg->client_command_;
}
const ::sync_pb::ClientToServerResponse_Error&
ClientToServerResponse::_Internal::error(const ClientToServerResponse* msg) {
  return *msg->error_;
}
const ::sync_pb::ChipBag&
ClientToServerResponse::_Internal::new_bag_of_chips(const ClientToServerResponse* msg) {
  return *msg->new_bag_of_chips_;
}
const ::sync_pb::ClearServerDataResponse&
ClientToServerResponse::_Internal::clear_server_data(const ClientToServerResponse* msg) {
  return *msg->clear_server_data_;
}
void ClientToServerResponse::clear_client_command() {
  if (client_command_ != nullptr) client_command_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
ClientToServerResponse::ClientToServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  migrated_data_type_id_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.ClientToServerResponse)
}
ClientToServerResponse::ClientToServerResponse(const ClientToServerResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      migrated_data_type_id_(from.migrated_data_type_id_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  error_message_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_message_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_message()) {
    error_message_.Set(from._internal_error_message(), 
      GetArenaForAllocation());
  }
  store_birthday_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_birthday_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_birthday()) {
    store_birthday_.Set(from._internal_store_birthday(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_commit()) {
    commit_ = new ::sync_pb::CommitResponse(*from.commit_);
  } else {
    commit_ = nullptr;
  }
  if (from._internal_has_get_updates()) {
    get_updates_ = new ::sync_pb::GetUpdatesResponse(*from.get_updates_);
  } else {
    get_updates_ = nullptr;
  }
  if (from._internal_has_client_command()) {
    client_command_ = new ::sync_pb::ClientCommand(*from.client_command_);
  } else {
    client_command_ = nullptr;
  }
  if (from._internal_has_error()) {
    error_ = new ::sync_pb::ClientToServerResponse_Error(*from.error_);
  } else {
    error_ = nullptr;
  }
  if (from._internal_has_new_bag_of_chips()) {
    new_bag_of_chips_ = new ::sync_pb::ChipBag(*from.new_bag_of_chips_);
  } else {
    new_bag_of_chips_ = nullptr;
  }
  if (from._internal_has_clear_server_data()) {
    clear_server_data_ = new ::sync_pb::ClearServerDataResponse(*from.clear_server_data_);
  } else {
    clear_server_data_ = nullptr;
  }
  error_code_ = from.error_code_;
  // @@protoc_insertion_point(copy_constructor:sync_pb.ClientToServerResponse)
}

inline void ClientToServerResponse::SharedCtor() {
error_message_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_message_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&commit_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&clear_server_data_) -
    reinterpret_cast<char*>(&commit_)) + sizeof(clear_server_data_));
error_code_ = 100;
}

ClientToServerResponse::~ClientToServerResponse() {
  // @@protoc_insertion_point(destructor:sync_pb.ClientToServerResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientToServerResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_message_.Destroy();
  store_birthday_.Destroy();
  if (this != internal_default_instance()) delete commit_;
  if (this != internal_default_instance()) delete get_updates_;
  if (this != internal_default_instance()) delete client_command_;
  if (this != internal_default_instance()) delete error_;
  if (this != internal_default_instance()) delete new_bag_of_chips_;
  if (this != internal_default_instance()) delete clear_server_data_;
}

void ClientToServerResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientToServerResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.ClientToServerResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  migrated_data_type_id_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      error_message_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      store_birthday_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(commit_ != nullptr);
      commit_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(get_updates_ != nullptr);
      get_updates_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(client_command_ != nullptr);
      client_command_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(error_ != nullptr);
      error_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(new_bag_of_chips_ != nullptr);
      new_bag_of_chips_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(clear_server_data_ != nullptr);
      clear_server_data_->Clear();
    }
  }
  error_code_ = 100;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientToServerResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.CommitResponse commit = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_commit(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.GetUpdatesResponse get_updates = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_updates(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sync_pb::SyncEnums_ErrorType_IsValid(val))) {
            _internal_set_error_code(static_cast<::sync_pb::SyncEnums_ErrorType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string error_message = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_error_message();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string store_birthday = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_store_birthday();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ClientCommand client_command = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_command(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 migrated_data_type_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_migrated_data_type_id(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<96>(ptr));
        } else if (static_cast<uint8_t>(tag) == 98) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_migrated_data_type_id(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ClientToServerResponse.Error error = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_error(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ChipBag new_bag_of_chips = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_new_bag_of_chips(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_clear_server_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientToServerResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.ClientToServerResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.CommitResponse commit = 1;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::commit(this),
        _Internal::commit(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.GetUpdatesResponse get_updates = 2;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::get_updates(this),
        _Internal::get_updates(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      4, this->_internal_error_code(), target);
  }

  // optional string error_message = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_error_message(), target);
  }

  // optional string store_birthday = 6;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_store_birthday(), target);
  }

  // optional .sync_pb.ClientCommand client_command = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::client_command(this),
        _Internal::client_command(this).GetCachedSize(), target, stream);
  }

  // repeated int32 migrated_data_type_id = 12;
  for (int i = 0, n = this->_internal_migrated_data_type_id_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_migrated_data_type_id(i), target);
  }

  // optional .sync_pb.ClientToServerResponse.Error error = 13;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::error(this),
        _Internal::error(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.ChipBag new_bag_of_chips = 14;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::new_bag_of_chips(this),
        _Internal::new_bag_of_chips(this).GetCachedSize(), target, stream);
  }

  // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::clear_server_data(this),
        _Internal::clear_server_data(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.ClientToServerResponse)
  return target;
}

size_t ClientToServerResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.ClientToServerResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 migrated_data_type_id = 12;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->migrated_data_type_id_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_migrated_data_type_id_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string error_message = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_message());
    }

    // optional string store_birthday = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_birthday());
    }

    // optional .sync_pb.CommitResponse commit = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *commit_);
    }

    // optional .sync_pb.GetUpdatesResponse get_updates = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *get_updates_);
    }

    // optional .sync_pb.ClientCommand client_command = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *client_command_);
    }

    // optional .sync_pb.ClientToServerResponse.Error error = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *error_);
    }

    // optional .sync_pb.ChipBag new_bag_of_chips = 14;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *new_bag_of_chips_);
    }

    // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *clear_server_data_);
    }

  }
  // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_error_code());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientToServerResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientToServerResponse*>(
      &from));
}

void ClientToServerResponse::MergeFrom(const ClientToServerResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.ClientToServerResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  migrated_data_type_id_.MergeFrom(from.migrated_data_type_id_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_message(from._internal_error_message());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_store_birthday(from._internal_store_birthday());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_commit()->::sync_pb::CommitResponse::MergeFrom(from._internal_commit());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_get_updates()->::sync_pb::GetUpdatesResponse::MergeFrom(from._internal_get_updates());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_client_command()->::sync_pb::ClientCommand::MergeFrom(from._internal_client_command());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_error()->::sync_pb::ClientToServerResponse_Error::MergeFrom(from._internal_error());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_new_bag_of_chips()->::sync_pb::ChipBag::MergeFrom(from._internal_new_bag_of_chips());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_mutable_clear_server_data()->::sync_pb::ClearServerDataResponse::MergeFrom(from._internal_clear_server_data());
    }
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_error_code(from._internal_error_code());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientToServerResponse::CopyFrom(const ClientToServerResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.ClientToServerResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientToServerResponse::IsInitialized() const {
  if (_internal_has_commit()) {
    if (!commit_->IsInitialized()) return false;
  }
  return true;
}

void ClientToServerResponse::InternalSwap(ClientToServerResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  migrated_data_type_id_.InternalSwap(&other->migrated_data_type_id_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &error_message_, lhs_arena,
      &other->error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &store_birthday_, lhs_arena,
      &other->store_birthday_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ClientToServerResponse, clear_server_data_)
      + sizeof(ClientToServerResponse::clear_server_data_)
      - PROTOBUF_FIELD_OFFSET(ClientToServerResponse, commit_)>(
          reinterpret_cast<char*>(&commit_),
          reinterpret_cast<char*>(&other->commit_));
  swap(error_code_, other->error_code_);
}

std::string ClientToServerResponse::GetTypeName() const {
  return "sync_pb.ClientToServerResponse";
}


// ===================================================================

class EventRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<EventRequest>()._has_bits_);
  static const ::sync_pb::SyncDisabledEvent& sync_disabled(const EventRequest* msg);
  static void set_has_sync_disabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::sync_pb::SyncDisabledEvent&
EventRequest::_Internal::sync_disabled(const EventRequest* msg) {
  return *msg->sync_disabled_;
}
EventRequest::EventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.EventRequest)
}
EventRequest::EventRequest(const EventRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_sync_disabled()) {
    sync_disabled_ = new ::sync_pb::SyncDisabledEvent(*from.sync_disabled_);
  } else {
    sync_disabled_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.EventRequest)
}

inline void EventRequest::SharedCtor() {
sync_disabled_ = nullptr;
}

EventRequest::~EventRequest() {
  // @@protoc_insertion_point(destructor:sync_pb.EventRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete sync_disabled_;
}

void EventRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EventRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.EventRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(sync_disabled_ != nullptr);
    sync_disabled_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* EventRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_sync_disabled(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.EventRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::sync_disabled(this),
        _Internal::sync_disabled(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.EventRequest)
  return target;
}

size_t EventRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.EventRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *sync_disabled_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventRequest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventRequest*>(
      &from));
}

void EventRequest::MergeFrom(const EventRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.EventRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sync_disabled()) {
    _internal_mutable_sync_disabled()->::sync_pb::SyncDisabledEvent::MergeFrom(from._internal_sync_disabled());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventRequest::CopyFrom(const EventRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.EventRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventRequest::IsInitialized() const {
  return true;
}

void EventRequest::InternalSwap(EventRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sync_disabled_, other->sync_disabled_);
}

std::string EventRequest::GetTypeName() const {
  return "sync_pb.EventRequest";
}


// ===================================================================

class EventResponse::_Internal {
 public:
};

EventResponse::EventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.EventResponse)
}
EventResponse::EventResponse(const EventResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sync_pb.EventResponse)
}

inline void EventResponse::SharedCtor() {
}

EventResponse::~EventResponse() {
  // @@protoc_insertion_point(destructor:sync_pb.EventResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EventResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void EventResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void EventResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.EventResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_metadata_.Clear<std::string>();
}

const char* EventResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EventResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.EventResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.EventResponse)
  return target;
}

size_t EventResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.EventResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void EventResponse::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const EventResponse*>(
      &from));
}

void EventResponse::MergeFrom(const EventResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.EventResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void EventResponse::CopyFrom(const EventResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.EventResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EventResponse::IsInitialized() const {
  return true;
}

void EventResponse::InternalSwap(EventResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
}

std::string EventResponse::GetTypeName() const {
  return "sync_pb.EventResponse";
}


// ===================================================================

class SyncDisabledEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<SyncDisabledEvent>()._has_bits_);
  static void set_has_cache_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_store_birthday(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

SyncDisabledEvent::SyncDisabledEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:sync_pb.SyncDisabledEvent)
}
SyncDisabledEvent::SyncDisabledEvent(const SyncDisabledEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  cache_guid_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cache_guid_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cache_guid()) {
    cache_guid_.Set(from._internal_cache_guid(), 
      GetArenaForAllocation());
  }
  store_birthday_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    store_birthday_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_store_birthday()) {
    store_birthday_.Set(from._internal_store_birthday(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:sync_pb.SyncDisabledEvent)
}

inline void SyncDisabledEvent::SharedCtor() {
cache_guid_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cache_guid_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
store_birthday_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  store_birthday_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SyncDisabledEvent::~SyncDisabledEvent() {
  // @@protoc_insertion_point(destructor:sync_pb.SyncDisabledEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SyncDisabledEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  cache_guid_.Destroy();
  store_birthday_.Destroy();
}

void SyncDisabledEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SyncDisabledEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:sync_pb.SyncDisabledEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      cache_guid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      store_birthday_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* SyncDisabledEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cache_guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cache_guid();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string store_birthday = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_store_birthday();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SyncDisabledEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sync_pb.SyncDisabledEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cache_guid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cache_guid(), target);
  }

  // optional string store_birthday = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_store_birthday(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sync_pb.SyncDisabledEvent)
  return target;
}

size_t SyncDisabledEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sync_pb.SyncDisabledEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string cache_guid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cache_guid());
    }

    // optional string store_birthday = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_store_birthday());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void SyncDisabledEvent::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const SyncDisabledEvent*>(
      &from));
}

void SyncDisabledEvent::MergeFrom(const SyncDisabledEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:sync_pb.SyncDisabledEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_cache_guid(from._internal_cache_guid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_store_birthday(from._internal_store_birthday());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void SyncDisabledEvent::CopyFrom(const SyncDisabledEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sync_pb.SyncDisabledEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SyncDisabledEvent::IsInitialized() const {
  return true;
}

void SyncDisabledEvent::InternalSwap(SyncDisabledEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &cache_guid_, lhs_arena,
      &other->cache_guid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &store_birthday_, lhs_arena,
      &other->store_birthday_, rhs_arena
  );
}

std::string SyncDisabledEvent::GetTypeName() const {
  return "sync_pb.SyncDisabledEvent";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sync_pb::ChromiumExtensionsActivity*
Arena::CreateMaybeMessage< ::sync_pb::ChromiumExtensionsActivity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ChromiumExtensionsActivity >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClientConfigParams*
Arena::CreateMaybeMessage< ::sync_pb::ClientConfigParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClientConfigParams >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::CommitMessage*
Arena::CreateMaybeMessage< ::sync_pb::CommitMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::CommitMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::GetUpdatesMessage*
Arena::CreateMaybeMessage< ::sync_pb::GetUpdatesMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::GetUpdatesMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClearServerDataMessage*
Arena::CreateMaybeMessage< ::sync_pb::ClearServerDataMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClearServerDataMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClearServerDataResponse*
Arena::CreateMaybeMessage< ::sync_pb::ClearServerDataResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClearServerDataResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ChipBag*
Arena::CreateMaybeMessage< ::sync_pb::ChipBag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ChipBag >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClientStatus*
Arena::CreateMaybeMessage< ::sync_pb::ClientStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClientStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClientToServerMessage*
Arena::CreateMaybeMessage< ::sync_pb::ClientToServerMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClientToServerMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError*
Arena::CreateMaybeMessage< ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::CommitResponse_EntryResponse*
Arena::CreateMaybeMessage< ::sync_pb::CommitResponse_EntryResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::CommitResponse_EntryResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::CommitResponse*
Arena::CreateMaybeMessage< ::sync_pb::CommitResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::CommitResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::GetUpdatesResponse*
Arena::CreateMaybeMessage< ::sync_pb::GetUpdatesResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::GetUpdatesResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClientToServerResponse_Error*
Arena::CreateMaybeMessage< ::sync_pb::ClientToServerResponse_Error >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClientToServerResponse_Error >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::ClientToServerResponse*
Arena::CreateMaybeMessage< ::sync_pb::ClientToServerResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::ClientToServerResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::EventRequest*
Arena::CreateMaybeMessage< ::sync_pb::EventRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::EventRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::EventResponse*
Arena::CreateMaybeMessage< ::sync_pb::EventResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::EventResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::sync_pb::SyncDisabledEvent*
Arena::CreateMaybeMessage< ::sync_pb::SyncDisabledEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sync_pb::SyncDisabledEvent >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
