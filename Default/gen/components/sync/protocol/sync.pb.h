// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/sync/protocol/sync.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsync_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsync_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/sync/protocol/client_commands.pb.h"
#include "components/sync/protocol/client_debug_info.pb.h"
#include "components/sync/protocol/data_type_progress_marker.pb.h"
#include "components/sync/protocol/get_updates_caller_info.pb.h"
#include "components/sync/protocol/sync_entity.pb.h"
#include "components/sync/protocol/sync_enums.pb.h"
#include "components/sync/protocol/sharing_message_specifics.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fsync_2fprotocol_2fsync_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fsync_2fprotocol_2fsync_2eproto {
  static const uint32_t offsets[];
};
namespace sync_pb {
class ChipBag;
struct ChipBagDefaultTypeInternal;
extern ChipBagDefaultTypeInternal _ChipBag_default_instance_;
class ChromiumExtensionsActivity;
struct ChromiumExtensionsActivityDefaultTypeInternal;
extern ChromiumExtensionsActivityDefaultTypeInternal _ChromiumExtensionsActivity_default_instance_;
class ClearServerDataMessage;
struct ClearServerDataMessageDefaultTypeInternal;
extern ClearServerDataMessageDefaultTypeInternal _ClearServerDataMessage_default_instance_;
class ClearServerDataResponse;
struct ClearServerDataResponseDefaultTypeInternal;
extern ClearServerDataResponseDefaultTypeInternal _ClearServerDataResponse_default_instance_;
class ClientConfigParams;
struct ClientConfigParamsDefaultTypeInternal;
extern ClientConfigParamsDefaultTypeInternal _ClientConfigParams_default_instance_;
class ClientStatus;
struct ClientStatusDefaultTypeInternal;
extern ClientStatusDefaultTypeInternal _ClientStatus_default_instance_;
class ClientToServerMessage;
struct ClientToServerMessageDefaultTypeInternal;
extern ClientToServerMessageDefaultTypeInternal _ClientToServerMessage_default_instance_;
class ClientToServerResponse;
struct ClientToServerResponseDefaultTypeInternal;
extern ClientToServerResponseDefaultTypeInternal _ClientToServerResponse_default_instance_;
class ClientToServerResponse_Error;
struct ClientToServerResponse_ErrorDefaultTypeInternal;
extern ClientToServerResponse_ErrorDefaultTypeInternal _ClientToServerResponse_Error_default_instance_;
class CommitMessage;
struct CommitMessageDefaultTypeInternal;
extern CommitMessageDefaultTypeInternal _CommitMessage_default_instance_;
class CommitResponse;
struct CommitResponseDefaultTypeInternal;
extern CommitResponseDefaultTypeInternal _CommitResponse_default_instance_;
class CommitResponse_EntryResponse;
struct CommitResponse_EntryResponseDefaultTypeInternal;
extern CommitResponse_EntryResponseDefaultTypeInternal _CommitResponse_EntryResponse_default_instance_;
class CommitResponse_EntryResponse_DatatypeSpecificError;
struct CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal;
extern CommitResponse_EntryResponse_DatatypeSpecificErrorDefaultTypeInternal _CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_;
class EventRequest;
struct EventRequestDefaultTypeInternal;
extern EventRequestDefaultTypeInternal _EventRequest_default_instance_;
class EventResponse;
struct EventResponseDefaultTypeInternal;
extern EventResponseDefaultTypeInternal _EventResponse_default_instance_;
class GetUpdatesMessage;
struct GetUpdatesMessageDefaultTypeInternal;
extern GetUpdatesMessageDefaultTypeInternal _GetUpdatesMessage_default_instance_;
class GetUpdatesResponse;
struct GetUpdatesResponseDefaultTypeInternal;
extern GetUpdatesResponseDefaultTypeInternal _GetUpdatesResponse_default_instance_;
class SyncDisabledEvent;
struct SyncDisabledEventDefaultTypeInternal;
extern SyncDisabledEventDefaultTypeInternal _SyncDisabledEvent_default_instance_;
}  // namespace sync_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::sync_pb::ChipBag* Arena::CreateMaybeMessage<::sync_pb::ChipBag>(Arena*);
template<> ::sync_pb::ChromiumExtensionsActivity* Arena::CreateMaybeMessage<::sync_pb::ChromiumExtensionsActivity>(Arena*);
template<> ::sync_pb::ClearServerDataMessage* Arena::CreateMaybeMessage<::sync_pb::ClearServerDataMessage>(Arena*);
template<> ::sync_pb::ClearServerDataResponse* Arena::CreateMaybeMessage<::sync_pb::ClearServerDataResponse>(Arena*);
template<> ::sync_pb::ClientConfigParams* Arena::CreateMaybeMessage<::sync_pb::ClientConfigParams>(Arena*);
template<> ::sync_pb::ClientStatus* Arena::CreateMaybeMessage<::sync_pb::ClientStatus>(Arena*);
template<> ::sync_pb::ClientToServerMessage* Arena::CreateMaybeMessage<::sync_pb::ClientToServerMessage>(Arena*);
template<> ::sync_pb::ClientToServerResponse* Arena::CreateMaybeMessage<::sync_pb::ClientToServerResponse>(Arena*);
template<> ::sync_pb::ClientToServerResponse_Error* Arena::CreateMaybeMessage<::sync_pb::ClientToServerResponse_Error>(Arena*);
template<> ::sync_pb::CommitMessage* Arena::CreateMaybeMessage<::sync_pb::CommitMessage>(Arena*);
template<> ::sync_pb::CommitResponse* Arena::CreateMaybeMessage<::sync_pb::CommitResponse>(Arena*);
template<> ::sync_pb::CommitResponse_EntryResponse* Arena::CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse>(Arena*);
template<> ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* Arena::CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError>(Arena*);
template<> ::sync_pb::EventRequest* Arena::CreateMaybeMessage<::sync_pb::EventRequest>(Arena*);
template<> ::sync_pb::EventResponse* Arena::CreateMaybeMessage<::sync_pb::EventResponse>(Arena*);
template<> ::sync_pb::GetUpdatesMessage* Arena::CreateMaybeMessage<::sync_pb::GetUpdatesMessage>(Arena*);
template<> ::sync_pb::GetUpdatesResponse* Arena::CreateMaybeMessage<::sync_pb::GetUpdatesResponse>(Arena*);
template<> ::sync_pb::SyncDisabledEvent* Arena::CreateMaybeMessage<::sync_pb::SyncDisabledEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sync_pb {

enum ClientToServerMessage_Contents : int {
  ClientToServerMessage_Contents_COMMIT = 1,
  ClientToServerMessage_Contents_GET_UPDATES = 2,
  ClientToServerMessage_Contents_DEPRECATED_3 = 3,
  ClientToServerMessage_Contents_DEPRECATED_4 = 4,
  ClientToServerMessage_Contents_CLEAR_SERVER_DATA = 5
};
bool ClientToServerMessage_Contents_IsValid(int value);
constexpr ClientToServerMessage_Contents ClientToServerMessage_Contents_Contents_MIN = ClientToServerMessage_Contents_COMMIT;
constexpr ClientToServerMessage_Contents ClientToServerMessage_Contents_Contents_MAX = ClientToServerMessage_Contents_CLEAR_SERVER_DATA;
constexpr int ClientToServerMessage_Contents_Contents_ARRAYSIZE = ClientToServerMessage_Contents_Contents_MAX + 1;

const std::string& ClientToServerMessage_Contents_Name(ClientToServerMessage_Contents value);
template<typename T>
inline const std::string& ClientToServerMessage_Contents_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClientToServerMessage_Contents>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClientToServerMessage_Contents_Name.");
  return ClientToServerMessage_Contents_Name(static_cast<ClientToServerMessage_Contents>(enum_t_value));
}
bool ClientToServerMessage_Contents_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClientToServerMessage_Contents* value);
enum CommitResponse_ResponseType : int {
  CommitResponse_ResponseType_SUCCESS = 1,
  CommitResponse_ResponseType_CONFLICT = 2,
  CommitResponse_ResponseType_RETRY = 3,
  CommitResponse_ResponseType_INVALID_MESSAGE = 4,
  CommitResponse_ResponseType_OVER_QUOTA = 5,
  CommitResponse_ResponseType_TRANSIENT_ERROR = 6
};
bool CommitResponse_ResponseType_IsValid(int value);
constexpr CommitResponse_ResponseType CommitResponse_ResponseType_ResponseType_MIN = CommitResponse_ResponseType_SUCCESS;
constexpr CommitResponse_ResponseType CommitResponse_ResponseType_ResponseType_MAX = CommitResponse_ResponseType_TRANSIENT_ERROR;
constexpr int CommitResponse_ResponseType_ResponseType_ARRAYSIZE = CommitResponse_ResponseType_ResponseType_MAX + 1;

const std::string& CommitResponse_ResponseType_Name(CommitResponse_ResponseType value);
template<typename T>
inline const std::string& CommitResponse_ResponseType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CommitResponse_ResponseType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CommitResponse_ResponseType_Name.");
  return CommitResponse_ResponseType_Name(static_cast<CommitResponse_ResponseType>(enum_t_value));
}
bool CommitResponse_ResponseType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CommitResponse_ResponseType* value);
// ===================================================================

class ChromiumExtensionsActivity final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ChromiumExtensionsActivity) */ {
 public:
  inline ChromiumExtensionsActivity() : ChromiumExtensionsActivity(nullptr) {}
  ~ChromiumExtensionsActivity() override;
  explicit PROTOBUF_CONSTEXPR ChromiumExtensionsActivity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChromiumExtensionsActivity(const ChromiumExtensionsActivity& from);
  ChromiumExtensionsActivity(ChromiumExtensionsActivity&& from) noexcept
    : ChromiumExtensionsActivity() {
    *this = ::std::move(from);
  }

  inline ChromiumExtensionsActivity& operator=(const ChromiumExtensionsActivity& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChromiumExtensionsActivity& operator=(ChromiumExtensionsActivity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChromiumExtensionsActivity& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChromiumExtensionsActivity* internal_default_instance() {
    return reinterpret_cast<const ChromiumExtensionsActivity*>(
               &_ChromiumExtensionsActivity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(ChromiumExtensionsActivity& a, ChromiumExtensionsActivity& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ChromiumExtensionsActivity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChromiumExtensionsActivity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChromiumExtensionsActivity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChromiumExtensionsActivity>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChromiumExtensionsActivity& from);
  void MergeFrom(const ChromiumExtensionsActivity& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChromiumExtensionsActivity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ChromiumExtensionsActivity";
  }
  protected:
  explicit ChromiumExtensionsActivity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExtensionIdFieldNumber = 1,
    kBookmarkWritesSinceLastCommitFieldNumber = 2,
  };
  // optional string extension_id = 1;
  bool has_extension_id() const;
  private:
  bool _internal_has_extension_id() const;
  public:
  void clear_extension_id();
  const std::string& extension_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extension_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extension_id();
  PROTOBUF_NODISCARD std::string* release_extension_id();
  void set_allocated_extension_id(std::string* extension_id);
  private:
  const std::string& _internal_extension_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extension_id(const std::string& value);
  std::string* _internal_mutable_extension_id();
  public:

  // optional uint32 bookmark_writes_since_last_commit = 2;
  bool has_bookmark_writes_since_last_commit() const;
  private:
  bool _internal_has_bookmark_writes_since_last_commit() const;
  public:
  void clear_bookmark_writes_since_last_commit();
  uint32_t bookmark_writes_since_last_commit() const;
  void set_bookmark_writes_since_last_commit(uint32_t value);
  private:
  uint32_t _internal_bookmark_writes_since_last_commit() const;
  void _internal_set_bookmark_writes_since_last_commit(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ChromiumExtensionsActivity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_id_;
  uint32_t bookmark_writes_since_last_commit_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientConfigParams final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientConfigParams) */ {
 public:
  inline ClientConfigParams() : ClientConfigParams(nullptr) {}
  ~ClientConfigParams() override;
  explicit PROTOBUF_CONSTEXPR ClientConfigParams(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientConfigParams(const ClientConfigParams& from);
  ClientConfigParams(ClientConfigParams&& from) noexcept
    : ClientConfigParams() {
    *this = ::std::move(from);
  }

  inline ClientConfigParams& operator=(const ClientConfigParams& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientConfigParams& operator=(ClientConfigParams&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientConfigParams& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientConfigParams* internal_default_instance() {
    return reinterpret_cast<const ClientConfigParams*>(
               &_ClientConfigParams_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ClientConfigParams& a, ClientConfigParams& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientConfigParams* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientConfigParams* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientConfigParams* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientConfigParams>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientConfigParams& from);
  void MergeFrom(const ClientConfigParams& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientConfigParams* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClientConfigParams";
  }
  protected:
  explicit ClientConfigParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledTypeIdsFieldNumber = 1,
    kDevicesFcmRegistrationTokensFieldNumber = 5,
    kFcmRegistrationTokensForInterestedClientsFieldNumber = 7,
    kTabsDatatypeEnabledFieldNumber = 2,
    kCookieJarMismatchFieldNumber = 3,
    kSingleClientFieldNumber = 4,
    kSingleClientWithStandaloneInvalidationsFieldNumber = 6,
  };
  // repeated int32 enabled_type_ids = 1;
  int enabled_type_ids_size() const;
  private:
  int _internal_enabled_type_ids_size() const;
  public:
  void clear_enabled_type_ids();
  private:
  int32_t _internal_enabled_type_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_enabled_type_ids() const;
  void _internal_add_enabled_type_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_enabled_type_ids();
  public:
  int32_t enabled_type_ids(int index) const;
  void set_enabled_type_ids(int index, int32_t value);
  void add_enabled_type_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      enabled_type_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_enabled_type_ids();

  // repeated string devices_fcm_registration_tokens = 5;
  int devices_fcm_registration_tokens_size() const;
  private:
  int _internal_devices_fcm_registration_tokens_size() const;
  public:
  void clear_devices_fcm_registration_tokens();
  const std::string& devices_fcm_registration_tokens(int index) const;
  std::string* mutable_devices_fcm_registration_tokens(int index);
  void set_devices_fcm_registration_tokens(int index, const std::string& value);
  void set_devices_fcm_registration_tokens(int index, std::string&& value);
  void set_devices_fcm_registration_tokens(int index, const char* value);
  void set_devices_fcm_registration_tokens(int index, const char* value, size_t size);
  std::string* add_devices_fcm_registration_tokens();
  void add_devices_fcm_registration_tokens(const std::string& value);
  void add_devices_fcm_registration_tokens(std::string&& value);
  void add_devices_fcm_registration_tokens(const char* value);
  void add_devices_fcm_registration_tokens(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& devices_fcm_registration_tokens() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_devices_fcm_registration_tokens();
  private:
  const std::string& _internal_devices_fcm_registration_tokens(int index) const;
  std::string* _internal_add_devices_fcm_registration_tokens();
  public:

  // repeated string fcm_registration_tokens_for_interested_clients = 7;
  int fcm_registration_tokens_for_interested_clients_size() const;
  private:
  int _internal_fcm_registration_tokens_for_interested_clients_size() const;
  public:
  void clear_fcm_registration_tokens_for_interested_clients();
  const std::string& fcm_registration_tokens_for_interested_clients(int index) const;
  std::string* mutable_fcm_registration_tokens_for_interested_clients(int index);
  void set_fcm_registration_tokens_for_interested_clients(int index, const std::string& value);
  void set_fcm_registration_tokens_for_interested_clients(int index, std::string&& value);
  void set_fcm_registration_tokens_for_interested_clients(int index, const char* value);
  void set_fcm_registration_tokens_for_interested_clients(int index, const char* value, size_t size);
  std::string* add_fcm_registration_tokens_for_interested_clients();
  void add_fcm_registration_tokens_for_interested_clients(const std::string& value);
  void add_fcm_registration_tokens_for_interested_clients(std::string&& value);
  void add_fcm_registration_tokens_for_interested_clients(const char* value);
  void add_fcm_registration_tokens_for_interested_clients(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& fcm_registration_tokens_for_interested_clients() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_fcm_registration_tokens_for_interested_clients();
  private:
  const std::string& _internal_fcm_registration_tokens_for_interested_clients(int index) const;
  std::string* _internal_add_fcm_registration_tokens_for_interested_clients();
  public:

  // optional bool tabs_datatype_enabled = 2;
  bool has_tabs_datatype_enabled() const;
  private:
  bool _internal_has_tabs_datatype_enabled() const;
  public:
  void clear_tabs_datatype_enabled();
  bool tabs_datatype_enabled() const;
  void set_tabs_datatype_enabled(bool value);
  private:
  bool _internal_tabs_datatype_enabled() const;
  void _internal_set_tabs_datatype_enabled(bool value);
  public:

  // optional bool cookie_jar_mismatch = 3;
  bool has_cookie_jar_mismatch() const;
  private:
  bool _internal_has_cookie_jar_mismatch() const;
  public:
  void clear_cookie_jar_mismatch();
  bool cookie_jar_mismatch() const;
  void set_cookie_jar_mismatch(bool value);
  private:
  bool _internal_cookie_jar_mismatch() const;
  void _internal_set_cookie_jar_mismatch(bool value);
  public:

  // optional bool single_client = 4;
  bool has_single_client() const;
  private:
  bool _internal_has_single_client() const;
  public:
  void clear_single_client();
  bool single_client() const;
  void set_single_client(bool value);
  private:
  bool _internal_single_client() const;
  void _internal_set_single_client(bool value);
  public:

  // optional bool single_client_with_standalone_invalidations = 6;
  bool has_single_client_with_standalone_invalidations() const;
  private:
  bool _internal_has_single_client_with_standalone_invalidations() const;
  public:
  void clear_single_client_with_standalone_invalidations();
  bool single_client_with_standalone_invalidations() const;
  void set_single_client_with_standalone_invalidations(bool value);
  private:
  bool _internal_single_client_with_standalone_invalidations() const;
  void _internal_set_single_client_with_standalone_invalidations(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ClientConfigParams)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > enabled_type_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> devices_fcm_registration_tokens_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> fcm_registration_tokens_for_interested_clients_;
  bool tabs_datatype_enabled_;
  bool cookie_jar_mismatch_;
  bool single_client_;
  bool single_client_with_standalone_invalidations_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitMessage) */ {
 public:
  inline CommitMessage() : CommitMessage(nullptr) {}
  ~CommitMessage() override;
  explicit PROTOBUF_CONSTEXPR CommitMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitMessage(const CommitMessage& from);
  CommitMessage(CommitMessage&& from) noexcept
    : CommitMessage() {
    *this = ::std::move(from);
  }

  inline CommitMessage& operator=(const CommitMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitMessage& operator=(CommitMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommitMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitMessage* internal_default_instance() {
    return reinterpret_cast<const CommitMessage*>(
               &_CommitMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CommitMessage& a, CommitMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CommitMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommitMessage& from);
  void MergeFrom(const CommitMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.CommitMessage";
  }
  protected:
  explicit CommitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kExtensionsActivityFieldNumber = 3,
    kClientContextsFieldNumber = 5,
    kCacheGuidFieldNumber = 2,
    kPaddingFieldNumber = 6,
    kConfigParamsFieldNumber = 4,
  };
  // repeated .sync_pb.SyncEntity entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::sync_pb::SyncEntity* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >*
      mutable_entries();
  private:
  const ::sync_pb::SyncEntity& _internal_entries(int index) const;
  ::sync_pb::SyncEntity* _internal_add_entries();
  public:
  const ::sync_pb::SyncEntity& entries(int index) const;
  ::sync_pb::SyncEntity* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >&
      entries() const;

  // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
  int extensions_activity_size() const;
  private:
  int _internal_extensions_activity_size() const;
  public:
  void clear_extensions_activity();
  ::sync_pb::ChromiumExtensionsActivity* mutable_extensions_activity(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >*
      mutable_extensions_activity();
  private:
  const ::sync_pb::ChromiumExtensionsActivity& _internal_extensions_activity(int index) const;
  ::sync_pb::ChromiumExtensionsActivity* _internal_add_extensions_activity();
  public:
  const ::sync_pb::ChromiumExtensionsActivity& extensions_activity(int index) const;
  ::sync_pb::ChromiumExtensionsActivity* add_extensions_activity();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >&
      extensions_activity() const;

  // repeated .sync_pb.DataTypeContext client_contexts = 5;
  int client_contexts_size() const;
  private:
  int _internal_client_contexts_size() const;
  public:
  void clear_client_contexts();
  ::sync_pb::DataTypeContext* mutable_client_contexts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >*
      mutable_client_contexts();
  private:
  const ::sync_pb::DataTypeContext& _internal_client_contexts(int index) const;
  ::sync_pb::DataTypeContext* _internal_add_client_contexts();
  public:
  const ::sync_pb::DataTypeContext& client_contexts(int index) const;
  ::sync_pb::DataTypeContext* add_client_contexts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >&
      client_contexts() const;

  // optional string cache_guid = 2;
  bool has_cache_guid() const;
  private:
  bool _internal_has_cache_guid() const;
  public:
  void clear_cache_guid();
  const std::string& cache_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_guid();
  PROTOBUF_NODISCARD std::string* release_cache_guid();
  void set_allocated_cache_guid(std::string* cache_guid);
  private:
  const std::string& _internal_cache_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_guid(const std::string& value);
  std::string* _internal_mutable_cache_guid();
  public:

  // optional string padding = 6;
  bool has_padding() const;
  private:
  bool _internal_has_padding() const;
  public:
  void clear_padding();
  const std::string& padding() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_padding(ArgT0&& arg0, ArgT... args);
  std::string* mutable_padding();
  PROTOBUF_NODISCARD std::string* release_padding();
  void set_allocated_padding(std::string* padding);
  private:
  const std::string& _internal_padding() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_padding(const std::string& value);
  std::string* _internal_mutable_padding();
  public:

  // optional .sync_pb.ClientConfigParams config_params = 4;
  bool has_config_params() const;
  private:
  bool _internal_has_config_params() const;
  public:
  void clear_config_params();
  const ::sync_pb::ClientConfigParams& config_params() const;
  PROTOBUF_NODISCARD ::sync_pb::ClientConfigParams* release_config_params();
  ::sync_pb::ClientConfigParams* mutable_config_params();
  void set_allocated_config_params(::sync_pb::ClientConfigParams* config_params);
  private:
  const ::sync_pb::ClientConfigParams& _internal_config_params() const;
  ::sync_pb::ClientConfigParams* _internal_mutable_config_params();
  public:
  void unsafe_arena_set_allocated_config_params(
      ::sync_pb::ClientConfigParams* config_params);
  ::sync_pb::ClientConfigParams* unsafe_arena_release_config_params();

  // @@protoc_insertion_point(class_scope:sync_pb.CommitMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity > entries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity > extensions_activity_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext > client_contexts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr padding_;
  ::sync_pb::ClientConfigParams* config_params_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class GetUpdatesMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.GetUpdatesMessage) */ {
 public:
  inline GetUpdatesMessage() : GetUpdatesMessage(nullptr) {}
  ~GetUpdatesMessage() override;
  explicit PROTOBUF_CONSTEXPR GetUpdatesMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUpdatesMessage(const GetUpdatesMessage& from);
  GetUpdatesMessage(GetUpdatesMessage&& from) noexcept
    : GetUpdatesMessage() {
    *this = ::std::move(from);
  }

  inline GetUpdatesMessage& operator=(const GetUpdatesMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUpdatesMessage& operator=(GetUpdatesMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetUpdatesMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUpdatesMessage* internal_default_instance() {
    return reinterpret_cast<const GetUpdatesMessage*>(
               &_GetUpdatesMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetUpdatesMessage& a, GetUpdatesMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetUpdatesMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUpdatesMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUpdatesMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUpdatesMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetUpdatesMessage& from);
  void MergeFrom(const GetUpdatesMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetUpdatesMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.GetUpdatesMessage";
  }
  protected:
  explicit GetUpdatesMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromProgressMarkerFieldNumber = 6,
    kClientContextsFieldNumber = 11,
    kCallerInfoFieldNumber = 2,
    kGetUpdatesOriginFieldNumber = 9,
    kStreamingFieldNumber = 7,
    kNeedEncryptionKeyFieldNumber = 8,
    kCreateMobileBookmarksFolderFieldNumber = 1000,
    kIsRetryFieldNumber = 10,
    kFetchFoldersFieldNumber = 3,
  };
  // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
  int from_progress_marker_size() const;
  private:
  int _internal_from_progress_marker_size() const;
  public:
  void clear_from_progress_marker();
  ::sync_pb::DataTypeProgressMarker* mutable_from_progress_marker(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
      mutable_from_progress_marker();
  private:
  const ::sync_pb::DataTypeProgressMarker& _internal_from_progress_marker(int index) const;
  ::sync_pb::DataTypeProgressMarker* _internal_add_from_progress_marker();
  public:
  const ::sync_pb::DataTypeProgressMarker& from_progress_marker(int index) const;
  ::sync_pb::DataTypeProgressMarker* add_from_progress_marker();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
      from_progress_marker() const;

  // repeated .sync_pb.DataTypeContext client_contexts = 11;
  int client_contexts_size() const;
  private:
  int _internal_client_contexts_size() const;
  public:
  void clear_client_contexts();
  ::sync_pb::DataTypeContext* mutable_client_contexts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >*
      mutable_client_contexts();
  private:
  const ::sync_pb::DataTypeContext& _internal_client_contexts(int index) const;
  ::sync_pb::DataTypeContext* _internal_add_client_contexts();
  public:
  const ::sync_pb::DataTypeContext& client_contexts(int index) const;
  ::sync_pb::DataTypeContext* add_client_contexts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >&
      client_contexts() const;

  // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
  bool has_caller_info() const;
  private:
  bool _internal_has_caller_info() const;
  public:
  void clear_caller_info();
  const ::sync_pb::GetUpdatesCallerInfo& caller_info() const;
  PROTOBUF_NODISCARD ::sync_pb::GetUpdatesCallerInfo* release_caller_info();
  ::sync_pb::GetUpdatesCallerInfo* mutable_caller_info();
  void set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info);
  private:
  const ::sync_pb::GetUpdatesCallerInfo& _internal_caller_info() const;
  ::sync_pb::GetUpdatesCallerInfo* _internal_mutable_caller_info();
  public:
  void unsafe_arena_set_allocated_caller_info(
      ::sync_pb::GetUpdatesCallerInfo* caller_info);
  ::sync_pb::GetUpdatesCallerInfo* unsafe_arena_release_caller_info();

  // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
  bool has_get_updates_origin() const;
  private:
  bool _internal_has_get_updates_origin() const;
  public:
  void clear_get_updates_origin();
  ::sync_pb::SyncEnums_GetUpdatesOrigin get_updates_origin() const;
  void set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value);
  private:
  ::sync_pb::SyncEnums_GetUpdatesOrigin _internal_get_updates_origin() const;
  void _internal_set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value);
  public:

  // optional bool streaming = 7 [default = false];
  bool has_streaming() const;
  private:
  bool _internal_has_streaming() const;
  public:
  void clear_streaming();
  bool streaming() const;
  void set_streaming(bool value);
  private:
  bool _internal_streaming() const;
  void _internal_set_streaming(bool value);
  public:

  // optional bool need_encryption_key = 8 [default = false];
  bool has_need_encryption_key() const;
  private:
  bool _internal_has_need_encryption_key() const;
  public:
  void clear_need_encryption_key();
  bool need_encryption_key() const;
  void set_need_encryption_key(bool value);
  private:
  bool _internal_need_encryption_key() const;
  void _internal_set_need_encryption_key(bool value);
  public:

  // optional bool create_mobile_bookmarks_folder = 1000 [default = false, deprecated = true];
  PROTOBUF_DEPRECATED bool has_create_mobile_bookmarks_folder() const;
  private:
  bool _internal_has_create_mobile_bookmarks_folder() const;
  public:
  PROTOBUF_DEPRECATED void clear_create_mobile_bookmarks_folder();
  PROTOBUF_DEPRECATED bool create_mobile_bookmarks_folder() const;
  PROTOBUF_DEPRECATED void set_create_mobile_bookmarks_folder(bool value);
  private:
  bool _internal_create_mobile_bookmarks_folder() const;
  void _internal_set_create_mobile_bookmarks_folder(bool value);
  public:

  // optional bool is_retry = 10 [default = false];
  bool has_is_retry() const;
  private:
  bool _internal_has_is_retry() const;
  public:
  void clear_is_retry();
  bool is_retry() const;
  void set_is_retry(bool value);
  private:
  bool _internal_is_retry() const;
  void _internal_set_is_retry(bool value);
  public:

  // optional bool fetch_folders = 3 [default = true];
  bool has_fetch_folders() const;
  private:
  bool _internal_has_fetch_folders() const;
  public:
  void clear_fetch_folders();
  bool fetch_folders() const;
  void set_fetch_folders(bool value);
  private:
  bool _internal_fetch_folders() const;
  void _internal_set_fetch_folders(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker > from_progress_marker_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext > client_contexts_;
  ::sync_pb::GetUpdatesCallerInfo* caller_info_;
  int get_updates_origin_;
  bool streaming_;
  bool need_encryption_key_;
  bool create_mobile_bookmarks_folder_;
  bool is_retry_;
  bool fetch_folders_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClearServerDataMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClearServerDataMessage) */ {
 public:
  inline ClearServerDataMessage() : ClearServerDataMessage(nullptr) {}
  ~ClearServerDataMessage() override;
  explicit PROTOBUF_CONSTEXPR ClearServerDataMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearServerDataMessage(const ClearServerDataMessage& from);
  ClearServerDataMessage(ClearServerDataMessage&& from) noexcept
    : ClearServerDataMessage() {
    *this = ::std::move(from);
  }

  inline ClearServerDataMessage& operator=(const ClearServerDataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearServerDataMessage& operator=(ClearServerDataMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClearServerDataMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearServerDataMessage* internal_default_instance() {
    return reinterpret_cast<const ClearServerDataMessage*>(
               &_ClearServerDataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClearServerDataMessage& a, ClearServerDataMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClearServerDataMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearServerDataMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearServerDataMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearServerDataMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClearServerDataMessage& from);
  void MergeFrom(const ClearServerDataMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearServerDataMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClearServerDataMessage";
  }
  protected:
  explicit ClearServerDataMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sync_pb.ClearServerDataMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClearServerDataResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClearServerDataResponse) */ {
 public:
  inline ClearServerDataResponse() : ClearServerDataResponse(nullptr) {}
  ~ClearServerDataResponse() override;
  explicit PROTOBUF_CONSTEXPR ClearServerDataResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClearServerDataResponse(const ClearServerDataResponse& from);
  ClearServerDataResponse(ClearServerDataResponse&& from) noexcept
    : ClearServerDataResponse() {
    *this = ::std::move(from);
  }

  inline ClearServerDataResponse& operator=(const ClearServerDataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClearServerDataResponse& operator=(ClearServerDataResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClearServerDataResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClearServerDataResponse* internal_default_instance() {
    return reinterpret_cast<const ClearServerDataResponse*>(
               &_ClearServerDataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClearServerDataResponse& a, ClearServerDataResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClearServerDataResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClearServerDataResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClearServerDataResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClearServerDataResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClearServerDataResponse& from);
  void MergeFrom(const ClearServerDataResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearServerDataResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClearServerDataResponse";
  }
  protected:
  explicit ClearServerDataResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sync_pb.ClearServerDataResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ChipBag final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ChipBag) */ {
 public:
  inline ChipBag() : ChipBag(nullptr) {}
  ~ChipBag() override;
  explicit PROTOBUF_CONSTEXPR ChipBag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChipBag(const ChipBag& from);
  ChipBag(ChipBag&& from) noexcept
    : ChipBag() {
    *this = ::std::move(from);
  }

  inline ChipBag& operator=(const ChipBag& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChipBag& operator=(ChipBag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ChipBag& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChipBag* internal_default_instance() {
    return reinterpret_cast<const ChipBag*>(
               &_ChipBag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ChipBag& a, ChipBag& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ChipBag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChipBag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChipBag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChipBag>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ChipBag& from);
  void MergeFrom(const ChipBag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ChipBag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ChipBag";
  }
  protected:
  explicit ChipBag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServerChipsFieldNumber = 1,
  };
  // optional bytes server_chips = 1;
  bool has_server_chips() const;
  private:
  bool _internal_has_server_chips() const;
  public:
  void clear_server_chips();
  const std::string& server_chips() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_chips(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_chips();
  PROTOBUF_NODISCARD std::string* release_server_chips();
  void set_allocated_server_chips(std::string* server_chips);
  private:
  const std::string& _internal_server_chips() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_chips(const std::string& value);
  std::string* _internal_mutable_server_chips();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ChipBag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_chips_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientStatus final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientStatus) */ {
 public:
  inline ClientStatus() : ClientStatus(nullptr) {}
  ~ClientStatus() override;
  explicit PROTOBUF_CONSTEXPR ClientStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientStatus(const ClientStatus& from);
  ClientStatus(ClientStatus&& from) noexcept
    : ClientStatus() {
    *this = ::std::move(from);
  }

  inline ClientStatus& operator=(const ClientStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientStatus& operator=(ClientStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientStatus* internal_default_instance() {
    return reinterpret_cast<const ClientStatus*>(
               &_ClientStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(ClientStatus& a, ClientStatus& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientStatus>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientStatus& from);
  void MergeFrom(const ClientStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClientStatus";
  }
  protected:
  explicit ClientStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHierarchyConflictDetectedFieldNumber = 1,
    kIsSyncFeatureEnabledFieldNumber = 2,
  };
  // optional bool hierarchy_conflict_detected = 1 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_hierarchy_conflict_detected() const;
  private:
  bool _internal_has_hierarchy_conflict_detected() const;
  public:
  PROTOBUF_DEPRECATED void clear_hierarchy_conflict_detected();
  PROTOBUF_DEPRECATED bool hierarchy_conflict_detected() const;
  PROTOBUF_DEPRECATED void set_hierarchy_conflict_detected(bool value);
  private:
  bool _internal_hierarchy_conflict_detected() const;
  void _internal_set_hierarchy_conflict_detected(bool value);
  public:

  // optional bool is_sync_feature_enabled = 2;
  bool has_is_sync_feature_enabled() const;
  private:
  bool _internal_has_is_sync_feature_enabled() const;
  public:
  void clear_is_sync_feature_enabled();
  bool is_sync_feature_enabled() const;
  void set_is_sync_feature_enabled(bool value);
  private:
  bool _internal_is_sync_feature_enabled() const;
  void _internal_set_is_sync_feature_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ClientStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool hierarchy_conflict_detected_;
  bool is_sync_feature_enabled_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientToServerMessage) */ {
 public:
  inline ClientToServerMessage() : ClientToServerMessage(nullptr) {}
  ~ClientToServerMessage() override;
  explicit PROTOBUF_CONSTEXPR ClientToServerMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToServerMessage(const ClientToServerMessage& from);
  ClientToServerMessage(ClientToServerMessage&& from) noexcept
    : ClientToServerMessage() {
    *this = ::std::move(from);
  }

  inline ClientToServerMessage& operator=(const ClientToServerMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServerMessage& operator=(ClientToServerMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientToServerMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToServerMessage* internal_default_instance() {
    return reinterpret_cast<const ClientToServerMessage*>(
               &_ClientToServerMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ClientToServerMessage& a, ClientToServerMessage& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientToServerMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServerMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToServerMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToServerMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientToServerMessage& from);
  void MergeFrom(const ClientToServerMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToServerMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClientToServerMessage";
  }
  protected:
  explicit ClientToServerMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServerMessage_Contents Contents;
  static constexpr Contents COMMIT =
    ClientToServerMessage_Contents_COMMIT;
  static constexpr Contents GET_UPDATES =
    ClientToServerMessage_Contents_GET_UPDATES;
  static constexpr Contents DEPRECATED_3 =
    ClientToServerMessage_Contents_DEPRECATED_3;
  static constexpr Contents DEPRECATED_4 =
    ClientToServerMessage_Contents_DEPRECATED_4;
  static constexpr Contents CLEAR_SERVER_DATA =
    ClientToServerMessage_Contents_CLEAR_SERVER_DATA;
  static inline bool Contents_IsValid(int value) {
    return ClientToServerMessage_Contents_IsValid(value);
  }
  static constexpr Contents Contents_MIN =
    ClientToServerMessage_Contents_Contents_MIN;
  static constexpr Contents Contents_MAX =
    ClientToServerMessage_Contents_Contents_MAX;
  static constexpr int Contents_ARRAYSIZE =
    ClientToServerMessage_Contents_Contents_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Contents_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Contents>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Contents_Name.");
    return ClientToServerMessage_Contents_Name(enum_t_value);
  }
  static inline bool Contents_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Contents* value) {
    return ClientToServerMessage_Contents_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kShareFieldNumber = 1,
    kStoreBirthdayFieldNumber = 7,
    kApiKeyFieldNumber = 12,
    kInvalidatorClientIdFieldNumber = 14,
    kCommitFieldNumber = 4,
    kGetUpdatesFieldNumber = 5,
    kDebugInfoFieldNumber = 10,
    kBagOfChipsFieldNumber = 11,
    kClientStatusFieldNumber = 13,
    kClearServerDataFieldNumber = 15,
    kSyncProblemDetectedFieldNumber = 8,
    kProtocolVersionFieldNumber = 2,
    kMessageContentsFieldNumber = 3,
  };
  // required string share = 1;
  bool has_share() const;
  private:
  bool _internal_has_share() const;
  public:
  void clear_share();
  const std::string& share() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_share(ArgT0&& arg0, ArgT... args);
  std::string* mutable_share();
  PROTOBUF_NODISCARD std::string* release_share();
  void set_allocated_share(std::string* share);
  private:
  const std::string& _internal_share() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_share(const std::string& value);
  std::string* _internal_mutable_share();
  public:

  // optional string store_birthday = 7;
  bool has_store_birthday() const;
  private:
  bool _internal_has_store_birthday() const;
  public:
  void clear_store_birthday();
  const std::string& store_birthday() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_birthday(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_birthday();
  PROTOBUF_NODISCARD std::string* release_store_birthday();
  void set_allocated_store_birthday(std::string* store_birthday);
  private:
  const std::string& _internal_store_birthday() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_birthday(const std::string& value);
  std::string* _internal_mutable_store_birthday();
  public:

  // optional string api_key = 12;
  bool has_api_key() const;
  private:
  bool _internal_has_api_key() const;
  public:
  void clear_api_key();
  const std::string& api_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_api_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_api_key();
  PROTOBUF_NODISCARD std::string* release_api_key();
  void set_allocated_api_key(std::string* api_key);
  private:
  const std::string& _internal_api_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_api_key(const std::string& value);
  std::string* _internal_mutable_api_key();
  public:

  // optional string invalidator_client_id = 14;
  bool has_invalidator_client_id() const;
  private:
  bool _internal_has_invalidator_client_id() const;
  public:
  void clear_invalidator_client_id();
  const std::string& invalidator_client_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_invalidator_client_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_invalidator_client_id();
  PROTOBUF_NODISCARD std::string* release_invalidator_client_id();
  void set_allocated_invalidator_client_id(std::string* invalidator_client_id);
  private:
  const std::string& _internal_invalidator_client_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_invalidator_client_id(const std::string& value);
  std::string* _internal_mutable_invalidator_client_id();
  public:

  // optional .sync_pb.CommitMessage commit = 4;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::sync_pb::CommitMessage& commit() const;
  PROTOBUF_NODISCARD ::sync_pb::CommitMessage* release_commit();
  ::sync_pb::CommitMessage* mutable_commit();
  void set_allocated_commit(::sync_pb::CommitMessage* commit);
  private:
  const ::sync_pb::CommitMessage& _internal_commit() const;
  ::sync_pb::CommitMessage* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::sync_pb::CommitMessage* commit);
  ::sync_pb::CommitMessage* unsafe_arena_release_commit();

  // optional .sync_pb.GetUpdatesMessage get_updates = 5;
  bool has_get_updates() const;
  private:
  bool _internal_has_get_updates() const;
  public:
  void clear_get_updates();
  const ::sync_pb::GetUpdatesMessage& get_updates() const;
  PROTOBUF_NODISCARD ::sync_pb::GetUpdatesMessage* release_get_updates();
  ::sync_pb::GetUpdatesMessage* mutable_get_updates();
  void set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates);
  private:
  const ::sync_pb::GetUpdatesMessage& _internal_get_updates() const;
  ::sync_pb::GetUpdatesMessage* _internal_mutable_get_updates();
  public:
  void unsafe_arena_set_allocated_get_updates(
      ::sync_pb::GetUpdatesMessage* get_updates);
  ::sync_pb::GetUpdatesMessage* unsafe_arena_release_get_updates();

  // optional .sync_pb.DebugInfo debug_info = 10;
  bool has_debug_info() const;
  private:
  bool _internal_has_debug_info() const;
  public:
  void clear_debug_info();
  const ::sync_pb::DebugInfo& debug_info() const;
  PROTOBUF_NODISCARD ::sync_pb::DebugInfo* release_debug_info();
  ::sync_pb::DebugInfo* mutable_debug_info();
  void set_allocated_debug_info(::sync_pb::DebugInfo* debug_info);
  private:
  const ::sync_pb::DebugInfo& _internal_debug_info() const;
  ::sync_pb::DebugInfo* _internal_mutable_debug_info();
  public:
  void unsafe_arena_set_allocated_debug_info(
      ::sync_pb::DebugInfo* debug_info);
  ::sync_pb::DebugInfo* unsafe_arena_release_debug_info();

  // optional .sync_pb.ChipBag bag_of_chips = 11;
  bool has_bag_of_chips() const;
  private:
  bool _internal_has_bag_of_chips() const;
  public:
  void clear_bag_of_chips();
  const ::sync_pb::ChipBag& bag_of_chips() const;
  PROTOBUF_NODISCARD ::sync_pb::ChipBag* release_bag_of_chips();
  ::sync_pb::ChipBag* mutable_bag_of_chips();
  void set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips);
  private:
  const ::sync_pb::ChipBag& _internal_bag_of_chips() const;
  ::sync_pb::ChipBag* _internal_mutable_bag_of_chips();
  public:
  void unsafe_arena_set_allocated_bag_of_chips(
      ::sync_pb::ChipBag* bag_of_chips);
  ::sync_pb::ChipBag* unsafe_arena_release_bag_of_chips();

  // optional .sync_pb.ClientStatus client_status = 13;
  bool has_client_status() const;
  private:
  bool _internal_has_client_status() const;
  public:
  void clear_client_status();
  const ::sync_pb::ClientStatus& client_status() const;
  PROTOBUF_NODISCARD ::sync_pb::ClientStatus* release_client_status();
  ::sync_pb::ClientStatus* mutable_client_status();
  void set_allocated_client_status(::sync_pb::ClientStatus* client_status);
  private:
  const ::sync_pb::ClientStatus& _internal_client_status() const;
  ::sync_pb::ClientStatus* _internal_mutable_client_status();
  public:
  void unsafe_arena_set_allocated_client_status(
      ::sync_pb::ClientStatus* client_status);
  ::sync_pb::ClientStatus* unsafe_arena_release_client_status();

  // optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
  bool has_clear_server_data() const;
  private:
  bool _internal_has_clear_server_data() const;
  public:
  void clear_clear_server_data();
  const ::sync_pb::ClearServerDataMessage& clear_server_data() const;
  PROTOBUF_NODISCARD ::sync_pb::ClearServerDataMessage* release_clear_server_data();
  ::sync_pb::ClearServerDataMessage* mutable_clear_server_data();
  void set_allocated_clear_server_data(::sync_pb::ClearServerDataMessage* clear_server_data);
  private:
  const ::sync_pb::ClearServerDataMessage& _internal_clear_server_data() const;
  ::sync_pb::ClearServerDataMessage* _internal_mutable_clear_server_data();
  public:
  void unsafe_arena_set_allocated_clear_server_data(
      ::sync_pb::ClearServerDataMessage* clear_server_data);
  ::sync_pb::ClearServerDataMessage* unsafe_arena_release_clear_server_data();

  // optional bool sync_problem_detected = 8 [default = false];
  bool has_sync_problem_detected() const;
  private:
  bool _internal_has_sync_problem_detected() const;
  public:
  void clear_sync_problem_detected();
  bool sync_problem_detected() const;
  void set_sync_problem_detected(bool value);
  private:
  bool _internal_sync_problem_detected() const;
  void _internal_set_sync_problem_detected(bool value);
  public:

  // optional int32 protocol_version = 2 [default = 99];
  bool has_protocol_version() const;
  private:
  bool _internal_has_protocol_version() const;
  public:
  void clear_protocol_version();
  int32_t protocol_version() const;
  void set_protocol_version(int32_t value);
  private:
  int32_t _internal_protocol_version() const;
  void _internal_set_protocol_version(int32_t value);
  public:

  // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
  bool has_message_contents() const;
  private:
  bool _internal_has_message_contents() const;
  public:
  void clear_message_contents();
  ::sync_pb::ClientToServerMessage_Contents message_contents() const;
  void set_message_contents(::sync_pb::ClientToServerMessage_Contents value);
  private:
  ::sync_pb::ClientToServerMessage_Contents _internal_message_contents() const;
  void _internal_set_message_contents(::sync_pb::ClientToServerMessage_Contents value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerMessage)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr share_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_birthday_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr api_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr invalidator_client_id_;
  ::sync_pb::CommitMessage* commit_;
  ::sync_pb::GetUpdatesMessage* get_updates_;
  ::sync_pb::DebugInfo* debug_info_;
  ::sync_pb::ChipBag* bag_of_chips_;
  ::sync_pb::ClientStatus* client_status_;
  ::sync_pb::ClearServerDataMessage* clear_server_data_;
  bool sync_problem_detected_;
  int32_t protocol_version_;
  int message_contents_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse_EntryResponse_DatatypeSpecificError final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError) */ {
 public:
  inline CommitResponse_EntryResponse_DatatypeSpecificError() : CommitResponse_EntryResponse_DatatypeSpecificError(nullptr) {}
  ~CommitResponse_EntryResponse_DatatypeSpecificError() override;
  explicit PROTOBUF_CONSTEXPR CommitResponse_EntryResponse_DatatypeSpecificError(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitResponse_EntryResponse_DatatypeSpecificError(const CommitResponse_EntryResponse_DatatypeSpecificError& from);
  CommitResponse_EntryResponse_DatatypeSpecificError(CommitResponse_EntryResponse_DatatypeSpecificError&& from) noexcept
    : CommitResponse_EntryResponse_DatatypeSpecificError() {
    *this = ::std::move(from);
  }

  inline CommitResponse_EntryResponse_DatatypeSpecificError& operator=(const CommitResponse_EntryResponse_DatatypeSpecificError& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitResponse_EntryResponse_DatatypeSpecificError& operator=(CommitResponse_EntryResponse_DatatypeSpecificError&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommitResponse_EntryResponse_DatatypeSpecificError& default_instance() {
    return *internal_default_instance();
  }
  enum DatatypeErrorCase {
    kSharingMessageError = 1,
    DATATYPE_ERROR_NOT_SET = 0,
  };

  static inline const CommitResponse_EntryResponse_DatatypeSpecificError* internal_default_instance() {
    return reinterpret_cast<const CommitResponse_EntryResponse_DatatypeSpecificError*>(
               &_CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CommitResponse_EntryResponse_DatatypeSpecificError& a, CommitResponse_EntryResponse_DatatypeSpecificError& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CommitResponse_EntryResponse_DatatypeSpecificError* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitResponse_EntryResponse_DatatypeSpecificError* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitResponse_EntryResponse_DatatypeSpecificError* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitResponse_EntryResponse_DatatypeSpecificError>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from);
  void MergeFrom(const CommitResponse_EntryResponse_DatatypeSpecificError& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitResponse_EntryResponse_DatatypeSpecificError* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError";
  }
  protected:
  explicit CommitResponse_EntryResponse_DatatypeSpecificError(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSharingMessageErrorFieldNumber = 1,
  };
  // .sync_pb.SharingMessageCommitError sharing_message_error = 1;
  bool has_sharing_message_error() const;
  private:
  bool _internal_has_sharing_message_error() const;
  public:
  void clear_sharing_message_error();
  const ::sync_pb::SharingMessageCommitError& sharing_message_error() const;
  PROTOBUF_NODISCARD ::sync_pb::SharingMessageCommitError* release_sharing_message_error();
  ::sync_pb::SharingMessageCommitError* mutable_sharing_message_error();
  void set_allocated_sharing_message_error(::sync_pb::SharingMessageCommitError* sharing_message_error);
  private:
  const ::sync_pb::SharingMessageCommitError& _internal_sharing_message_error() const;
  ::sync_pb::SharingMessageCommitError* _internal_mutable_sharing_message_error();
  public:
  void unsafe_arena_set_allocated_sharing_message_error(
      ::sync_pb::SharingMessageCommitError* sharing_message_error);
  ::sync_pb::SharingMessageCommitError* unsafe_arena_release_sharing_message_error();

  void clear_datatype_error();
  DatatypeErrorCase datatype_error_case() const;
  // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError)
 private:
  class _Internal;
  void set_has_sharing_message_error();

  inline bool has_datatype_error() const;
  inline void clear_has_datatype_error();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DatatypeErrorUnion {
    constexpr DatatypeErrorUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::sync_pb::SharingMessageCommitError* sharing_message_error_;
  } datatype_error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse_EntryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitResponse.EntryResponse) */ {
 public:
  inline CommitResponse_EntryResponse() : CommitResponse_EntryResponse(nullptr) {}
  ~CommitResponse_EntryResponse() override;
  explicit PROTOBUF_CONSTEXPR CommitResponse_EntryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitResponse_EntryResponse(const CommitResponse_EntryResponse& from);
  CommitResponse_EntryResponse(CommitResponse_EntryResponse&& from) noexcept
    : CommitResponse_EntryResponse() {
    *this = ::std::move(from);
  }

  inline CommitResponse_EntryResponse& operator=(const CommitResponse_EntryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitResponse_EntryResponse& operator=(CommitResponse_EntryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommitResponse_EntryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitResponse_EntryResponse* internal_default_instance() {
    return reinterpret_cast<const CommitResponse_EntryResponse*>(
               &_CommitResponse_EntryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CommitResponse_EntryResponse& a, CommitResponse_EntryResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CommitResponse_EntryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitResponse_EntryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitResponse_EntryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitResponse_EntryResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommitResponse_EntryResponse& from);
  void MergeFrom(const CommitResponse_EntryResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitResponse_EntryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.CommitResponse.EntryResponse";
  }
  protected:
  explicit CommitResponse_EntryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommitResponse_EntryResponse_DatatypeSpecificError DatatypeSpecificError;

  // accessors -------------------------------------------------------

  enum : int {
    kIdStringFieldNumber = 3,
    kErrorMessageFieldNumber = 9,
    kDatatypeSpecificErrorFieldNumber = 11,
    kVersionFieldNumber = 6,
    kMtimeFieldNumber = 10,
    kResponseTypeFieldNumber = 2,
  };
  // optional string id_string = 3;
  bool has_id_string() const;
  private:
  bool _internal_has_id_string() const;
  public:
  void clear_id_string();
  const std::string& id_string() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id_string(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id_string();
  PROTOBUF_NODISCARD std::string* release_id_string();
  void set_allocated_id_string(std::string* id_string);
  private:
  const std::string& _internal_id_string() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id_string(const std::string& value);
  std::string* _internal_mutable_id_string();
  public:

  // optional string error_message = 9;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
  bool has_datatype_specific_error() const;
  private:
  bool _internal_has_datatype_specific_error() const;
  public:
  void clear_datatype_specific_error();
  const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& datatype_specific_error() const;
  PROTOBUF_NODISCARD ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* release_datatype_specific_error();
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* mutable_datatype_specific_error();
  void set_allocated_datatype_specific_error(::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error);
  private:
  const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& _internal_datatype_specific_error() const;
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* _internal_mutable_datatype_specific_error();
  public:
  void unsafe_arena_set_allocated_datatype_specific_error(
      ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error);
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* unsafe_arena_release_datatype_specific_error();

  // optional int64 version = 6;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // optional int64 mtime = 10 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_mtime() const;
  private:
  bool _internal_has_mtime() const;
  public:
  PROTOBUF_DEPRECATED void clear_mtime();
  PROTOBUF_DEPRECATED int64_t mtime() const;
  PROTOBUF_DEPRECATED void set_mtime(int64_t value);
  private:
  int64_t _internal_mtime() const;
  void _internal_set_mtime(int64_t value);
  public:

  // required .sync_pb.CommitResponse.ResponseType response_type = 2;
  bool has_response_type() const;
  private:
  bool _internal_has_response_type() const;
  public:
  void clear_response_type();
  ::sync_pb::CommitResponse_ResponseType response_type() const;
  void set_response_type(::sync_pb::CommitResponse_ResponseType value);
  private:
  ::sync_pb::CommitResponse_ResponseType _internal_response_type() const;
  void _internal_set_response_type(::sync_pb::CommitResponse_ResponseType value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse.EntryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_string_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error_;
  int64_t version_;
  int64_t mtime_;
  int response_type_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class CommitResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.CommitResponse) */ {
 public:
  inline CommitResponse() : CommitResponse(nullptr) {}
  ~CommitResponse() override;
  explicit PROTOBUF_CONSTEXPR CommitResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CommitResponse(const CommitResponse& from);
  CommitResponse(CommitResponse&& from) noexcept
    : CommitResponse() {
    *this = ::std::move(from);
  }

  inline CommitResponse& operator=(const CommitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CommitResponse& operator=(CommitResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const CommitResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CommitResponse* internal_default_instance() {
    return reinterpret_cast<const CommitResponse*>(
               &_CommitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CommitResponse& a, CommitResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(CommitResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CommitResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CommitResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CommitResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CommitResponse& from);
  void MergeFrom(const CommitResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CommitResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.CommitResponse";
  }
  protected:
  explicit CommitResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CommitResponse_EntryResponse EntryResponse;

  typedef CommitResponse_ResponseType ResponseType;
  static constexpr ResponseType SUCCESS =
    CommitResponse_ResponseType_SUCCESS;
  static constexpr ResponseType CONFLICT =
    CommitResponse_ResponseType_CONFLICT;
  static constexpr ResponseType RETRY =
    CommitResponse_ResponseType_RETRY;
  static constexpr ResponseType INVALID_MESSAGE =
    CommitResponse_ResponseType_INVALID_MESSAGE;
  static constexpr ResponseType OVER_QUOTA =
    CommitResponse_ResponseType_OVER_QUOTA;
  static constexpr ResponseType TRANSIENT_ERROR =
    CommitResponse_ResponseType_TRANSIENT_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return CommitResponse_ResponseType_IsValid(value);
  }
  static constexpr ResponseType ResponseType_MIN =
    CommitResponse_ResponseType_ResponseType_MIN;
  static constexpr ResponseType ResponseType_MAX =
    CommitResponse_ResponseType_ResponseType_MAX;
  static constexpr int ResponseType_ARRAYSIZE =
    CommitResponse_ResponseType_ResponseType_ARRAYSIZE;
  template<typename T>
  static inline const std::string& ResponseType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ResponseType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ResponseType_Name.");
    return CommitResponse_ResponseType_Name(enum_t_value);
  }
  static inline bool ResponseType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ResponseType* value) {
    return CommitResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kEntryresponseFieldNumber = 1,
  };
  // repeated group EntryResponse = 1 { ... };
  int entryresponse_size() const;
  private:
  int _internal_entryresponse_size() const;
  public:
  void clear_entryresponse();
  ::sync_pb::CommitResponse_EntryResponse* mutable_entryresponse(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >*
      mutable_entryresponse();
  private:
  const ::sync_pb::CommitResponse_EntryResponse& _internal_entryresponse(int index) const;
  ::sync_pb::CommitResponse_EntryResponse* _internal_add_entryresponse();
  public:
  const ::sync_pb::CommitResponse_EntryResponse& entryresponse(int index) const;
  ::sync_pb::CommitResponse_EntryResponse* add_entryresponse();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >&
      entryresponse() const;

  // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse > entryresponse_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class GetUpdatesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.GetUpdatesResponse) */ {
 public:
  inline GetUpdatesResponse() : GetUpdatesResponse(nullptr) {}
  ~GetUpdatesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUpdatesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUpdatesResponse(const GetUpdatesResponse& from);
  GetUpdatesResponse(GetUpdatesResponse&& from) noexcept
    : GetUpdatesResponse() {
    *this = ::std::move(from);
  }

  inline GetUpdatesResponse& operator=(const GetUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUpdatesResponse& operator=(GetUpdatesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetUpdatesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUpdatesResponse* internal_default_instance() {
    return reinterpret_cast<const GetUpdatesResponse*>(
               &_GetUpdatesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetUpdatesResponse& a, GetUpdatesResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetUpdatesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUpdatesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUpdatesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUpdatesResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetUpdatesResponse& from);
  void MergeFrom(const GetUpdatesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetUpdatesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.GetUpdatesResponse";
  }
  protected:
  explicit GetUpdatesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kNewProgressMarkerFieldNumber = 5,
    kEncryptionKeysFieldNumber = 6,
    kContextMutationsFieldNumber = 7,
    kChangesRemainingFieldNumber = 4,
  };
  // repeated .sync_pb.SyncEntity entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::sync_pb::SyncEntity* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >*
      mutable_entries();
  private:
  const ::sync_pb::SyncEntity& _internal_entries(int index) const;
  ::sync_pb::SyncEntity* _internal_add_entries();
  public:
  const ::sync_pb::SyncEntity& entries(int index) const;
  ::sync_pb::SyncEntity* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >&
      entries() const;

  // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
  int new_progress_marker_size() const;
  private:
  int _internal_new_progress_marker_size() const;
  public:
  void clear_new_progress_marker();
  ::sync_pb::DataTypeProgressMarker* mutable_new_progress_marker(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
      mutable_new_progress_marker();
  private:
  const ::sync_pb::DataTypeProgressMarker& _internal_new_progress_marker(int index) const;
  ::sync_pb::DataTypeProgressMarker* _internal_add_new_progress_marker();
  public:
  const ::sync_pb::DataTypeProgressMarker& new_progress_marker(int index) const;
  ::sync_pb::DataTypeProgressMarker* add_new_progress_marker();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
      new_progress_marker() const;

  // repeated bytes encryption_keys = 6;
  int encryption_keys_size() const;
  private:
  int _internal_encryption_keys_size() const;
  public:
  void clear_encryption_keys();
  const std::string& encryption_keys(int index) const;
  std::string* mutable_encryption_keys(int index);
  void set_encryption_keys(int index, const std::string& value);
  void set_encryption_keys(int index, std::string&& value);
  void set_encryption_keys(int index, const char* value);
  void set_encryption_keys(int index, const void* value, size_t size);
  std::string* add_encryption_keys();
  void add_encryption_keys(const std::string& value);
  void add_encryption_keys(std::string&& value);
  void add_encryption_keys(const char* value);
  void add_encryption_keys(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& encryption_keys() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_encryption_keys();
  private:
  const std::string& _internal_encryption_keys(int index) const;
  std::string* _internal_add_encryption_keys();
  public:

  // repeated .sync_pb.DataTypeContext context_mutations = 7;
  int context_mutations_size() const;
  private:
  int _internal_context_mutations_size() const;
  public:
  void clear_context_mutations();
  ::sync_pb::DataTypeContext* mutable_context_mutations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >*
      mutable_context_mutations();
  private:
  const ::sync_pb::DataTypeContext& _internal_context_mutations(int index) const;
  ::sync_pb::DataTypeContext* _internal_add_context_mutations();
  public:
  const ::sync_pb::DataTypeContext& context_mutations(int index) const;
  ::sync_pb::DataTypeContext* add_context_mutations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >&
      context_mutations() const;

  // optional int64 changes_remaining = 4;
  bool has_changes_remaining() const;
  private:
  bool _internal_has_changes_remaining() const;
  public:
  void clear_changes_remaining();
  int64_t changes_remaining() const;
  void set_changes_remaining(int64_t value);
  private:
  int64_t _internal_changes_remaining() const;
  void _internal_set_changes_remaining(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity > entries_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker > new_progress_marker_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> encryption_keys_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext > context_mutations_;
  int64_t changes_remaining_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerResponse_Error final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientToServerResponse.Error) */ {
 public:
  inline ClientToServerResponse_Error() : ClientToServerResponse_Error(nullptr) {}
  ~ClientToServerResponse_Error() override;
  explicit PROTOBUF_CONSTEXPR ClientToServerResponse_Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToServerResponse_Error(const ClientToServerResponse_Error& from);
  ClientToServerResponse_Error(ClientToServerResponse_Error&& from) noexcept
    : ClientToServerResponse_Error() {
    *this = ::std::move(from);
  }

  inline ClientToServerResponse_Error& operator=(const ClientToServerResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServerResponse_Error& operator=(ClientToServerResponse_Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientToServerResponse_Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToServerResponse_Error* internal_default_instance() {
    return reinterpret_cast<const ClientToServerResponse_Error*>(
               &_ClientToServerResponse_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ClientToServerResponse_Error& a, ClientToServerResponse_Error& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientToServerResponse_Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServerResponse_Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToServerResponse_Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToServerResponse_Error>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientToServerResponse_Error& from);
  void MergeFrom(const ClientToServerResponse_Error& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToServerResponse_Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClientToServerResponse.Error";
  }
  protected:
  explicit ClientToServerResponse_Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorDataTypeIdsFieldNumber = 5,
    kErrorDescriptionFieldNumber = 2,
    kErrorTypeFieldNumber = 1,
    kActionFieldNumber = 4,
  };
  // repeated int32 error_data_type_ids = 5;
  int error_data_type_ids_size() const;
  private:
  int _internal_error_data_type_ids_size() const;
  public:
  void clear_error_data_type_ids();
  private:
  int32_t _internal_error_data_type_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_error_data_type_ids() const;
  void _internal_add_error_data_type_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_error_data_type_ids();
  public:
  int32_t error_data_type_ids(int index) const;
  void set_error_data_type_ids(int index, int32_t value);
  void add_error_data_type_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      error_data_type_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_error_data_type_ids();

  // optional string error_description = 2;
  bool has_error_description() const;
  private:
  bool _internal_has_error_description() const;
  public:
  void clear_error_description();
  const std::string& error_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_description();
  PROTOBUF_NODISCARD std::string* release_error_description();
  void set_allocated_error_description(std::string* error_description);
  private:
  const std::string& _internal_error_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_description(const std::string& value);
  std::string* _internal_mutable_error_description();
  public:

  // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
  bool has_error_type() const;
  private:
  bool _internal_has_error_type() const;
  public:
  void clear_error_type();
  ::sync_pb::SyncEnums_ErrorType error_type() const;
  void set_error_type(::sync_pb::SyncEnums_ErrorType value);
  private:
  ::sync_pb::SyncEnums_ErrorType _internal_error_type() const;
  void _internal_set_error_type(::sync_pb::SyncEnums_ErrorType value);
  public:

  // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  ::sync_pb::SyncEnums_Action action() const;
  void set_action(::sync_pb::SyncEnums_Action value);
  private:
  ::sync_pb::SyncEnums_Action _internal_action() const;
  void _internal_set_action(::sync_pb::SyncEnums_Action value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerResponse.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > error_data_type_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_description_;
  int error_type_;
  int action_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class ClientToServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.ClientToServerResponse) */ {
 public:
  inline ClientToServerResponse() : ClientToServerResponse(nullptr) {}
  ~ClientToServerResponse() override;
  explicit PROTOBUF_CONSTEXPR ClientToServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientToServerResponse(const ClientToServerResponse& from);
  ClientToServerResponse(ClientToServerResponse&& from) noexcept
    : ClientToServerResponse() {
    *this = ::std::move(from);
  }

  inline ClientToServerResponse& operator=(const ClientToServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientToServerResponse& operator=(ClientToServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ClientToServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientToServerResponse* internal_default_instance() {
    return reinterpret_cast<const ClientToServerResponse*>(
               &_ClientToServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ClientToServerResponse& a, ClientToServerResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ClientToServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientToServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientToServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientToServerResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientToServerResponse& from);
  void MergeFrom(const ClientToServerResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientToServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.ClientToServerResponse";
  }
  protected:
  explicit ClientToServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef ClientToServerResponse_Error Error;

  // accessors -------------------------------------------------------

  enum : int {
    kMigratedDataTypeIdFieldNumber = 12,
    kErrorMessageFieldNumber = 5,
    kStoreBirthdayFieldNumber = 6,
    kCommitFieldNumber = 1,
    kGetUpdatesFieldNumber = 2,
    kClientCommandFieldNumber = 7,
    kErrorFieldNumber = 13,
    kNewBagOfChipsFieldNumber = 14,
    kClearServerDataFieldNumber = 15,
    kErrorCodeFieldNumber = 4,
  };
  // repeated int32 migrated_data_type_id = 12;
  int migrated_data_type_id_size() const;
  private:
  int _internal_migrated_data_type_id_size() const;
  public:
  void clear_migrated_data_type_id();
  private:
  int32_t _internal_migrated_data_type_id(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_migrated_data_type_id() const;
  void _internal_add_migrated_data_type_id(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_migrated_data_type_id();
  public:
  int32_t migrated_data_type_id(int index) const;
  void set_migrated_data_type_id(int index, int32_t value);
  void add_migrated_data_type_id(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      migrated_data_type_id() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_migrated_data_type_id();

  // optional string error_message = 5;
  bool has_error_message() const;
  private:
  bool _internal_has_error_message() const;
  public:
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_NODISCARD std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // optional string store_birthday = 6;
  bool has_store_birthday() const;
  private:
  bool _internal_has_store_birthday() const;
  public:
  void clear_store_birthday();
  const std::string& store_birthday() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_birthday(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_birthday();
  PROTOBUF_NODISCARD std::string* release_store_birthday();
  void set_allocated_store_birthday(std::string* store_birthday);
  private:
  const std::string& _internal_store_birthday() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_birthday(const std::string& value);
  std::string* _internal_mutable_store_birthday();
  public:

  // optional .sync_pb.CommitResponse commit = 1;
  bool has_commit() const;
  private:
  bool _internal_has_commit() const;
  public:
  void clear_commit();
  const ::sync_pb::CommitResponse& commit() const;
  PROTOBUF_NODISCARD ::sync_pb::CommitResponse* release_commit();
  ::sync_pb::CommitResponse* mutable_commit();
  void set_allocated_commit(::sync_pb::CommitResponse* commit);
  private:
  const ::sync_pb::CommitResponse& _internal_commit() const;
  ::sync_pb::CommitResponse* _internal_mutable_commit();
  public:
  void unsafe_arena_set_allocated_commit(
      ::sync_pb::CommitResponse* commit);
  ::sync_pb::CommitResponse* unsafe_arena_release_commit();

  // optional .sync_pb.GetUpdatesResponse get_updates = 2;
  bool has_get_updates() const;
  private:
  bool _internal_has_get_updates() const;
  public:
  void clear_get_updates();
  const ::sync_pb::GetUpdatesResponse& get_updates() const;
  PROTOBUF_NODISCARD ::sync_pb::GetUpdatesResponse* release_get_updates();
  ::sync_pb::GetUpdatesResponse* mutable_get_updates();
  void set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates);
  private:
  const ::sync_pb::GetUpdatesResponse& _internal_get_updates() const;
  ::sync_pb::GetUpdatesResponse* _internal_mutable_get_updates();
  public:
  void unsafe_arena_set_allocated_get_updates(
      ::sync_pb::GetUpdatesResponse* get_updates);
  ::sync_pb::GetUpdatesResponse* unsafe_arena_release_get_updates();

  // optional .sync_pb.ClientCommand client_command = 7;
  bool has_client_command() const;
  private:
  bool _internal_has_client_command() const;
  public:
  void clear_client_command();
  const ::sync_pb::ClientCommand& client_command() const;
  PROTOBUF_NODISCARD ::sync_pb::ClientCommand* release_client_command();
  ::sync_pb::ClientCommand* mutable_client_command();
  void set_allocated_client_command(::sync_pb::ClientCommand* client_command);
  private:
  const ::sync_pb::ClientCommand& _internal_client_command() const;
  ::sync_pb::ClientCommand* _internal_mutable_client_command();
  public:
  void unsafe_arena_set_allocated_client_command(
      ::sync_pb::ClientCommand* client_command);
  ::sync_pb::ClientCommand* unsafe_arena_release_client_command();

  // optional .sync_pb.ClientToServerResponse.Error error = 13;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const ::sync_pb::ClientToServerResponse_Error& error() const;
  PROTOBUF_NODISCARD ::sync_pb::ClientToServerResponse_Error* release_error();
  ::sync_pb::ClientToServerResponse_Error* mutable_error();
  void set_allocated_error(::sync_pb::ClientToServerResponse_Error* error);
  private:
  const ::sync_pb::ClientToServerResponse_Error& _internal_error() const;
  ::sync_pb::ClientToServerResponse_Error* _internal_mutable_error();
  public:
  void unsafe_arena_set_allocated_error(
      ::sync_pb::ClientToServerResponse_Error* error);
  ::sync_pb::ClientToServerResponse_Error* unsafe_arena_release_error();

  // optional .sync_pb.ChipBag new_bag_of_chips = 14;
  bool has_new_bag_of_chips() const;
  private:
  bool _internal_has_new_bag_of_chips() const;
  public:
  void clear_new_bag_of_chips();
  const ::sync_pb::ChipBag& new_bag_of_chips() const;
  PROTOBUF_NODISCARD ::sync_pb::ChipBag* release_new_bag_of_chips();
  ::sync_pb::ChipBag* mutable_new_bag_of_chips();
  void set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips);
  private:
  const ::sync_pb::ChipBag& _internal_new_bag_of_chips() const;
  ::sync_pb::ChipBag* _internal_mutable_new_bag_of_chips();
  public:
  void unsafe_arena_set_allocated_new_bag_of_chips(
      ::sync_pb::ChipBag* new_bag_of_chips);
  ::sync_pb::ChipBag* unsafe_arena_release_new_bag_of_chips();

  // optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
  bool has_clear_server_data() const;
  private:
  bool _internal_has_clear_server_data() const;
  public:
  void clear_clear_server_data();
  const ::sync_pb::ClearServerDataResponse& clear_server_data() const;
  PROTOBUF_NODISCARD ::sync_pb::ClearServerDataResponse* release_clear_server_data();
  ::sync_pb::ClearServerDataResponse* mutable_clear_server_data();
  void set_allocated_clear_server_data(::sync_pb::ClearServerDataResponse* clear_server_data);
  private:
  const ::sync_pb::ClearServerDataResponse& _internal_clear_server_data() const;
  ::sync_pb::ClearServerDataResponse* _internal_mutable_clear_server_data();
  public:
  void unsafe_arena_set_allocated_clear_server_data(
      ::sync_pb::ClearServerDataResponse* clear_server_data);
  ::sync_pb::ClearServerDataResponse* unsafe_arena_release_clear_server_data();

  // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
  bool has_error_code() const;
  private:
  bool _internal_has_error_code() const;
  public:
  void clear_error_code();
  ::sync_pb::SyncEnums_ErrorType error_code() const;
  void set_error_code(::sync_pb::SyncEnums_ErrorType value);
  private:
  ::sync_pb::SyncEnums_ErrorType _internal_error_code() const;
  void _internal_set_error_code(::sync_pb::SyncEnums_ErrorType value);
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > migrated_data_type_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_birthday_;
  ::sync_pb::CommitResponse* commit_;
  ::sync_pb::GetUpdatesResponse* get_updates_;
  ::sync_pb::ClientCommand* client_command_;
  ::sync_pb::ClientToServerResponse_Error* error_;
  ::sync_pb::ChipBag* new_bag_of_chips_;
  ::sync_pb::ClearServerDataResponse* clear_server_data_;
  int error_code_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class EventRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EventRequest) */ {
 public:
  inline EventRequest() : EventRequest(nullptr) {}
  ~EventRequest() override;
  explicit PROTOBUF_CONSTEXPR EventRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventRequest(const EventRequest& from);
  EventRequest(EventRequest&& from) noexcept
    : EventRequest() {
    *this = ::std::move(from);
  }

  inline EventRequest& operator=(const EventRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventRequest& operator=(EventRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EventRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventRequest* internal_default_instance() {
    return reinterpret_cast<const EventRequest*>(
               &_EventRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(EventRequest& a, EventRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EventRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventRequest& from);
  void MergeFrom(const EventRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.EventRequest";
  }
  protected:
  explicit EventRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSyncDisabledFieldNumber = 1,
  };
  // optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
  bool has_sync_disabled() const;
  private:
  bool _internal_has_sync_disabled() const;
  public:
  void clear_sync_disabled();
  const ::sync_pb::SyncDisabledEvent& sync_disabled() const;
  PROTOBUF_NODISCARD ::sync_pb::SyncDisabledEvent* release_sync_disabled();
  ::sync_pb::SyncDisabledEvent* mutable_sync_disabled();
  void set_allocated_sync_disabled(::sync_pb::SyncDisabledEvent* sync_disabled);
  private:
  const ::sync_pb::SyncDisabledEvent& _internal_sync_disabled() const;
  ::sync_pb::SyncDisabledEvent* _internal_mutable_sync_disabled();
  public:
  void unsafe_arena_set_allocated_sync_disabled(
      ::sync_pb::SyncDisabledEvent* sync_disabled);
  ::sync_pb::SyncDisabledEvent* unsafe_arena_release_sync_disabled();

  // @@protoc_insertion_point(class_scope:sync_pb.EventRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::sync_pb::SyncDisabledEvent* sync_disabled_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class EventResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.EventResponse) */ {
 public:
  inline EventResponse() : EventResponse(nullptr) {}
  ~EventResponse() override;
  explicit PROTOBUF_CONSTEXPR EventResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventResponse(const EventResponse& from);
  EventResponse(EventResponse&& from) noexcept
    : EventResponse() {
    *this = ::std::move(from);
  }

  inline EventResponse& operator=(const EventResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventResponse& operator=(EventResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const EventResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventResponse* internal_default_instance() {
    return reinterpret_cast<const EventResponse*>(
               &_EventResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(EventResponse& a, EventResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(EventResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EventResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EventResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const EventResponse& from);
  void MergeFrom(const EventResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(EventResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.EventResponse";
  }
  protected:
  explicit EventResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sync_pb.EventResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// -------------------------------------------------------------------

class SyncDisabledEvent final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:sync_pb.SyncDisabledEvent) */ {
 public:
  inline SyncDisabledEvent() : SyncDisabledEvent(nullptr) {}
  ~SyncDisabledEvent() override;
  explicit PROTOBUF_CONSTEXPR SyncDisabledEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SyncDisabledEvent(const SyncDisabledEvent& from);
  SyncDisabledEvent(SyncDisabledEvent&& from) noexcept
    : SyncDisabledEvent() {
    *this = ::std::move(from);
  }

  inline SyncDisabledEvent& operator=(const SyncDisabledEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline SyncDisabledEvent& operator=(SyncDisabledEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const SyncDisabledEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const SyncDisabledEvent* internal_default_instance() {
    return reinterpret_cast<const SyncDisabledEvent*>(
               &_SyncDisabledEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SyncDisabledEvent& a, SyncDisabledEvent& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SyncDisabledEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SyncDisabledEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SyncDisabledEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SyncDisabledEvent>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SyncDisabledEvent& from);
  void MergeFrom(const SyncDisabledEvent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SyncDisabledEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sync_pb.SyncDisabledEvent";
  }
  protected:
  explicit SyncDisabledEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCacheGuidFieldNumber = 1,
    kStoreBirthdayFieldNumber = 2,
  };
  // optional string cache_guid = 1;
  bool has_cache_guid() const;
  private:
  bool _internal_has_cache_guid() const;
  public:
  void clear_cache_guid();
  const std::string& cache_guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cache_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cache_guid();
  PROTOBUF_NODISCARD std::string* release_cache_guid();
  void set_allocated_cache_guid(std::string* cache_guid);
  private:
  const std::string& _internal_cache_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cache_guid(const std::string& value);
  std::string* _internal_mutable_cache_guid();
  public:

  // optional string store_birthday = 2;
  bool has_store_birthday() const;
  private:
  bool _internal_has_store_birthday() const;
  public:
  void clear_store_birthday();
  const std::string& store_birthday() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_birthday(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_birthday();
  PROTOBUF_NODISCARD std::string* release_store_birthday();
  void set_allocated_store_birthday(std::string* store_birthday);
  private:
  const std::string& _internal_store_birthday() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_birthday(const std::string& value);
  std::string* _internal_mutable_store_birthday();
  public:

  // @@protoc_insertion_point(class_scope:sync_pb.SyncDisabledEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cache_guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_birthday_;
  friend struct ::TableStruct_components_2fsync_2fprotocol_2fsync_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ChromiumExtensionsActivity

// optional string extension_id = 1;
inline bool ChromiumExtensionsActivity::_internal_has_extension_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChromiumExtensionsActivity::has_extension_id() const {
  return _internal_has_extension_id();
}
inline void ChromiumExtensionsActivity::clear_extension_id() {
  extension_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChromiumExtensionsActivity::extension_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.ChromiumExtensionsActivity.extension_id)
  return _internal_extension_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChromiumExtensionsActivity::set_extension_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 extension_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ChromiumExtensionsActivity.extension_id)
}
inline std::string* ChromiumExtensionsActivity::mutable_extension_id() {
  std::string* _s = _internal_mutable_extension_id();
  // @@protoc_insertion_point(field_mutable:sync_pb.ChromiumExtensionsActivity.extension_id)
  return _s;
}
inline const std::string& ChromiumExtensionsActivity::_internal_extension_id() const {
  return extension_id_.Get();
}
inline void ChromiumExtensionsActivity::_internal_set_extension_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  extension_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ChromiumExtensionsActivity::_internal_mutable_extension_id() {
  _has_bits_[0] |= 0x00000001u;
  return extension_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ChromiumExtensionsActivity::release_extension_id() {
  // @@protoc_insertion_point(field_release:sync_pb.ChromiumExtensionsActivity.extension_id)
  if (!_internal_has_extension_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = extension_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extension_id_.IsDefault()) {
    extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChromiumExtensionsActivity::set_allocated_extension_id(std::string* extension_id) {
  if (extension_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  extension_id_.SetAllocated(extension_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extension_id_.IsDefault()) {
    extension_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ChromiumExtensionsActivity.extension_id)
}

// optional uint32 bookmark_writes_since_last_commit = 2;
inline bool ChromiumExtensionsActivity::_internal_has_bookmark_writes_since_last_commit() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ChromiumExtensionsActivity::has_bookmark_writes_since_last_commit() const {
  return _internal_has_bookmark_writes_since_last_commit();
}
inline void ChromiumExtensionsActivity::clear_bookmark_writes_since_last_commit() {
  bookmark_writes_since_last_commit_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t ChromiumExtensionsActivity::_internal_bookmark_writes_since_last_commit() const {
  return bookmark_writes_since_last_commit_;
}
inline uint32_t ChromiumExtensionsActivity::bookmark_writes_since_last_commit() const {
  // @@protoc_insertion_point(field_get:sync_pb.ChromiumExtensionsActivity.bookmark_writes_since_last_commit)
  return _internal_bookmark_writes_since_last_commit();
}
inline void ChromiumExtensionsActivity::_internal_set_bookmark_writes_since_last_commit(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  bookmark_writes_since_last_commit_ = value;
}
inline void ChromiumExtensionsActivity::set_bookmark_writes_since_last_commit(uint32_t value) {
  _internal_set_bookmark_writes_since_last_commit(value);
  // @@protoc_insertion_point(field_set:sync_pb.ChromiumExtensionsActivity.bookmark_writes_since_last_commit)
}

// -------------------------------------------------------------------

// ClientConfigParams

// repeated int32 enabled_type_ids = 1;
inline int ClientConfigParams::_internal_enabled_type_ids_size() const {
  return enabled_type_ids_.size();
}
inline int ClientConfigParams::enabled_type_ids_size() const {
  return _internal_enabled_type_ids_size();
}
inline void ClientConfigParams::clear_enabled_type_ids() {
  enabled_type_ids_.Clear();
}
inline int32_t ClientConfigParams::_internal_enabled_type_ids(int index) const {
  return enabled_type_ids_.Get(index);
}
inline int32_t ClientConfigParams::enabled_type_ids(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.enabled_type_ids)
  return _internal_enabled_type_ids(index);
}
inline void ClientConfigParams::set_enabled_type_ids(int index, int32_t value) {
  enabled_type_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.enabled_type_ids)
}
inline void ClientConfigParams::_internal_add_enabled_type_ids(int32_t value) {
  enabled_type_ids_.Add(value);
}
inline void ClientConfigParams::add_enabled_type_ids(int32_t value) {
  _internal_add_enabled_type_ids(value);
  // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.enabled_type_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ClientConfigParams::_internal_enabled_type_ids() const {
  return enabled_type_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ClientConfigParams::enabled_type_ids() const {
  // @@protoc_insertion_point(field_list:sync_pb.ClientConfigParams.enabled_type_ids)
  return _internal_enabled_type_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ClientConfigParams::_internal_mutable_enabled_type_ids() {
  return &enabled_type_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ClientConfigParams::mutable_enabled_type_ids() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientConfigParams.enabled_type_ids)
  return _internal_mutable_enabled_type_ids();
}

// optional bool tabs_datatype_enabled = 2;
inline bool ClientConfigParams::_internal_has_tabs_datatype_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientConfigParams::has_tabs_datatype_enabled() const {
  return _internal_has_tabs_datatype_enabled();
}
inline void ClientConfigParams::clear_tabs_datatype_enabled() {
  tabs_datatype_enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ClientConfigParams::_internal_tabs_datatype_enabled() const {
  return tabs_datatype_enabled_;
}
inline bool ClientConfigParams::tabs_datatype_enabled() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.tabs_datatype_enabled)
  return _internal_tabs_datatype_enabled();
}
inline void ClientConfigParams::_internal_set_tabs_datatype_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  tabs_datatype_enabled_ = value;
}
inline void ClientConfigParams::set_tabs_datatype_enabled(bool value) {
  _internal_set_tabs_datatype_enabled(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.tabs_datatype_enabled)
}

// optional bool cookie_jar_mismatch = 3;
inline bool ClientConfigParams::_internal_has_cookie_jar_mismatch() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientConfigParams::has_cookie_jar_mismatch() const {
  return _internal_has_cookie_jar_mismatch();
}
inline void ClientConfigParams::clear_cookie_jar_mismatch() {
  cookie_jar_mismatch_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ClientConfigParams::_internal_cookie_jar_mismatch() const {
  return cookie_jar_mismatch_;
}
inline bool ClientConfigParams::cookie_jar_mismatch() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.cookie_jar_mismatch)
  return _internal_cookie_jar_mismatch();
}
inline void ClientConfigParams::_internal_set_cookie_jar_mismatch(bool value) {
  _has_bits_[0] |= 0x00000002u;
  cookie_jar_mismatch_ = value;
}
inline void ClientConfigParams::set_cookie_jar_mismatch(bool value) {
  _internal_set_cookie_jar_mismatch(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.cookie_jar_mismatch)
}

// optional bool single_client = 4;
inline bool ClientConfigParams::_internal_has_single_client() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientConfigParams::has_single_client() const {
  return _internal_has_single_client();
}
inline void ClientConfigParams::clear_single_client() {
  single_client_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ClientConfigParams::_internal_single_client() const {
  return single_client_;
}
inline bool ClientConfigParams::single_client() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.single_client)
  return _internal_single_client();
}
inline void ClientConfigParams::_internal_set_single_client(bool value) {
  _has_bits_[0] |= 0x00000004u;
  single_client_ = value;
}
inline void ClientConfigParams::set_single_client(bool value) {
  _internal_set_single_client(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.single_client)
}

// repeated string devices_fcm_registration_tokens = 5;
inline int ClientConfigParams::_internal_devices_fcm_registration_tokens_size() const {
  return devices_fcm_registration_tokens_.size();
}
inline int ClientConfigParams::devices_fcm_registration_tokens_size() const {
  return _internal_devices_fcm_registration_tokens_size();
}
inline void ClientConfigParams::clear_devices_fcm_registration_tokens() {
  devices_fcm_registration_tokens_.Clear();
}
inline std::string* ClientConfigParams::add_devices_fcm_registration_tokens() {
  std::string* _s = _internal_add_devices_fcm_registration_tokens();
  // @@protoc_insertion_point(field_add_mutable:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
  return _s;
}
inline const std::string& ClientConfigParams::_internal_devices_fcm_registration_tokens(int index) const {
  return devices_fcm_registration_tokens_.Get(index);
}
inline const std::string& ClientConfigParams::devices_fcm_registration_tokens(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
  return _internal_devices_fcm_registration_tokens(index);
}
inline std::string* ClientConfigParams::mutable_devices_fcm_registration_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
  return devices_fcm_registration_tokens_.Mutable(index);
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, const std::string& value) {
  devices_fcm_registration_tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, std::string&& value) {
  devices_fcm_registration_tokens_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  devices_fcm_registration_tokens_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::set_devices_fcm_registration_tokens(int index, const char* value, size_t size) {
  devices_fcm_registration_tokens_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline std::string* ClientConfigParams::_internal_add_devices_fcm_registration_tokens() {
  return devices_fcm_registration_tokens_.Add();
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(const std::string& value) {
  devices_fcm_registration_tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(std::string&& value) {
  devices_fcm_registration_tokens_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  devices_fcm_registration_tokens_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline void ClientConfigParams::add_devices_fcm_registration_tokens(const char* value, size_t size) {
  devices_fcm_registration_tokens_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClientConfigParams::devices_fcm_registration_tokens() const {
  // @@protoc_insertion_point(field_list:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
  return devices_fcm_registration_tokens_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClientConfigParams::mutable_devices_fcm_registration_tokens() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientConfigParams.devices_fcm_registration_tokens)
  return &devices_fcm_registration_tokens_;
}

// optional bool single_client_with_standalone_invalidations = 6;
inline bool ClientConfigParams::_internal_has_single_client_with_standalone_invalidations() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientConfigParams::has_single_client_with_standalone_invalidations() const {
  return _internal_has_single_client_with_standalone_invalidations();
}
inline void ClientConfigParams::clear_single_client_with_standalone_invalidations() {
  single_client_with_standalone_invalidations_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool ClientConfigParams::_internal_single_client_with_standalone_invalidations() const {
  return single_client_with_standalone_invalidations_;
}
inline bool ClientConfigParams::single_client_with_standalone_invalidations() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.single_client_with_standalone_invalidations)
  return _internal_single_client_with_standalone_invalidations();
}
inline void ClientConfigParams::_internal_set_single_client_with_standalone_invalidations(bool value) {
  _has_bits_[0] |= 0x00000008u;
  single_client_with_standalone_invalidations_ = value;
}
inline void ClientConfigParams::set_single_client_with_standalone_invalidations(bool value) {
  _internal_set_single_client_with_standalone_invalidations(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.single_client_with_standalone_invalidations)
}

// repeated string fcm_registration_tokens_for_interested_clients = 7;
inline int ClientConfigParams::_internal_fcm_registration_tokens_for_interested_clients_size() const {
  return fcm_registration_tokens_for_interested_clients_.size();
}
inline int ClientConfigParams::fcm_registration_tokens_for_interested_clients_size() const {
  return _internal_fcm_registration_tokens_for_interested_clients_size();
}
inline void ClientConfigParams::clear_fcm_registration_tokens_for_interested_clients() {
  fcm_registration_tokens_for_interested_clients_.Clear();
}
inline std::string* ClientConfigParams::add_fcm_registration_tokens_for_interested_clients() {
  std::string* _s = _internal_add_fcm_registration_tokens_for_interested_clients();
  // @@protoc_insertion_point(field_add_mutable:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
  return _s;
}
inline const std::string& ClientConfigParams::_internal_fcm_registration_tokens_for_interested_clients(int index) const {
  return fcm_registration_tokens_for_interested_clients_.Get(index);
}
inline const std::string& ClientConfigParams::fcm_registration_tokens_for_interested_clients(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
  return _internal_fcm_registration_tokens_for_interested_clients(index);
}
inline std::string* ClientConfigParams::mutable_fcm_registration_tokens_for_interested_clients(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
  return fcm_registration_tokens_for_interested_clients_.Mutable(index);
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, const std::string& value) {
  fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, std::string&& value) {
  fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::set_fcm_registration_tokens_for_interested_clients(int index, const char* value, size_t size) {
  fcm_registration_tokens_for_interested_clients_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline std::string* ClientConfigParams::_internal_add_fcm_registration_tokens_for_interested_clients() {
  return fcm_registration_tokens_for_interested_clients_.Add();
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(const std::string& value) {
  fcm_registration_tokens_for_interested_clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(std::string&& value) {
  fcm_registration_tokens_for_interested_clients_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  fcm_registration_tokens_for_interested_clients_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline void ClientConfigParams::add_fcm_registration_tokens_for_interested_clients(const char* value, size_t size) {
  fcm_registration_tokens_for_interested_clients_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ClientConfigParams::fcm_registration_tokens_for_interested_clients() const {
  // @@protoc_insertion_point(field_list:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
  return fcm_registration_tokens_for_interested_clients_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ClientConfigParams::mutable_fcm_registration_tokens_for_interested_clients() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientConfigParams.fcm_registration_tokens_for_interested_clients)
  return &fcm_registration_tokens_for_interested_clients_;
}

// -------------------------------------------------------------------

// CommitMessage

// repeated .sync_pb.SyncEntity entries = 1;
inline int CommitMessage::_internal_entries_size() const {
  return entries_.size();
}
inline int CommitMessage::entries_size() const {
  return _internal_entries_size();
}
inline ::sync_pb::SyncEntity* CommitMessage::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >*
CommitMessage::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitMessage.entries)
  return &entries_;
}
inline const ::sync_pb::SyncEntity& CommitMessage::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::sync_pb::SyncEntity& CommitMessage::entries(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.entries)
  return _internal_entries(index);
}
inline ::sync_pb::SyncEntity* CommitMessage::_internal_add_entries() {
  return entries_.Add();
}
inline ::sync_pb::SyncEntity* CommitMessage::add_entries() {
  ::sync_pb::SyncEntity* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:sync_pb.CommitMessage.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >&
CommitMessage::entries() const {
  // @@protoc_insertion_point(field_list:sync_pb.CommitMessage.entries)
  return entries_;
}

// optional string cache_guid = 2;
inline bool CommitMessage::_internal_has_cache_guid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommitMessage::has_cache_guid() const {
  return _internal_has_cache_guid();
}
inline void CommitMessage::clear_cache_guid() {
  cache_guid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommitMessage::cache_guid() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.cache_guid)
  return _internal_cache_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommitMessage::set_cache_guid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cache_guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.CommitMessage.cache_guid)
}
inline std::string* CommitMessage::mutable_cache_guid() {
  std::string* _s = _internal_mutable_cache_guid();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.cache_guid)
  return _s;
}
inline const std::string& CommitMessage::_internal_cache_guid() const {
  return cache_guid_.Get();
}
inline void CommitMessage::_internal_set_cache_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cache_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitMessage::_internal_mutable_cache_guid() {
  _has_bits_[0] |= 0x00000001u;
  return cache_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitMessage::release_cache_guid() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitMessage.cache_guid)
  if (!_internal_has_cache_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cache_guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_guid_.IsDefault()) {
    cache_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommitMessage::set_allocated_cache_guid(std::string* cache_guid) {
  if (cache_guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cache_guid_.SetAllocated(cache_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_guid_.IsDefault()) {
    cache_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitMessage.cache_guid)
}

// repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
inline int CommitMessage::_internal_extensions_activity_size() const {
  return extensions_activity_.size();
}
inline int CommitMessage::extensions_activity_size() const {
  return _internal_extensions_activity_size();
}
inline void CommitMessage::clear_extensions_activity() {
  extensions_activity_.Clear();
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::mutable_extensions_activity(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.extensions_activity)
  return extensions_activity_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >*
CommitMessage::mutable_extensions_activity() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitMessage.extensions_activity)
  return &extensions_activity_;
}
inline const ::sync_pb::ChromiumExtensionsActivity& CommitMessage::_internal_extensions_activity(int index) const {
  return extensions_activity_.Get(index);
}
inline const ::sync_pb::ChromiumExtensionsActivity& CommitMessage::extensions_activity(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.extensions_activity)
  return _internal_extensions_activity(index);
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::_internal_add_extensions_activity() {
  return extensions_activity_.Add();
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::add_extensions_activity() {
  ::sync_pb::ChromiumExtensionsActivity* _add = _internal_add_extensions_activity();
  // @@protoc_insertion_point(field_add:sync_pb.CommitMessage.extensions_activity)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >&
CommitMessage::extensions_activity() const {
  // @@protoc_insertion_point(field_list:sync_pb.CommitMessage.extensions_activity)
  return extensions_activity_;
}

// optional .sync_pb.ClientConfigParams config_params = 4;
inline bool CommitMessage::_internal_has_config_params() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || config_params_ != nullptr);
  return value;
}
inline bool CommitMessage::has_config_params() const {
  return _internal_has_config_params();
}
inline void CommitMessage::clear_config_params() {
  if (config_params_ != nullptr) config_params_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::ClientConfigParams& CommitMessage::_internal_config_params() const {
  const ::sync_pb::ClientConfigParams* p = config_params_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientConfigParams&>(
      ::sync_pb::_ClientConfigParams_default_instance_);
}
inline const ::sync_pb::ClientConfigParams& CommitMessage::config_params() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.config_params)
  return _internal_config_params();
}
inline void CommitMessage::unsafe_arena_set_allocated_config_params(
    ::sync_pb::ClientConfigParams* config_params) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_params_);
  }
  config_params_ = config_params;
  if (config_params) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitMessage.config_params)
}
inline ::sync_pb::ClientConfigParams* CommitMessage::release_config_params() {
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::ClientConfigParams* temp = config_params_;
  config_params_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::unsafe_arena_release_config_params() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitMessage.config_params)
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::ClientConfigParams* temp = config_params_;
  config_params_ = nullptr;
  return temp;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::_internal_mutable_config_params() {
  _has_bits_[0] |= 0x00000004u;
  if (config_params_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ClientConfigParams>(GetArenaForAllocation());
    config_params_ = p;
  }
  return config_params_;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::mutable_config_params() {
  ::sync_pb::ClientConfigParams* _msg = _internal_mutable_config_params();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.config_params)
  return _msg;
}
inline void CommitMessage::set_allocated_config_params(::sync_pb::ClientConfigParams* config_params) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_params_;
  }
  if (config_params) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(config_params);
    if (message_arena != submessage_arena) {
      config_params = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config_params, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  config_params_ = config_params;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitMessage.config_params)
}

// repeated .sync_pb.DataTypeContext client_contexts = 5;
inline int CommitMessage::_internal_client_contexts_size() const {
  return client_contexts_.size();
}
inline int CommitMessage::client_contexts_size() const {
  return _internal_client_contexts_size();
}
inline ::sync_pb::DataTypeContext* CommitMessage::mutable_client_contexts(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.client_contexts)
  return client_contexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >*
CommitMessage::mutable_client_contexts() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitMessage.client_contexts)
  return &client_contexts_;
}
inline const ::sync_pb::DataTypeContext& CommitMessage::_internal_client_contexts(int index) const {
  return client_contexts_.Get(index);
}
inline const ::sync_pb::DataTypeContext& CommitMessage::client_contexts(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.client_contexts)
  return _internal_client_contexts(index);
}
inline ::sync_pb::DataTypeContext* CommitMessage::_internal_add_client_contexts() {
  return client_contexts_.Add();
}
inline ::sync_pb::DataTypeContext* CommitMessage::add_client_contexts() {
  ::sync_pb::DataTypeContext* _add = _internal_add_client_contexts();
  // @@protoc_insertion_point(field_add:sync_pb.CommitMessage.client_contexts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >&
CommitMessage::client_contexts() const {
  // @@protoc_insertion_point(field_list:sync_pb.CommitMessage.client_contexts)
  return client_contexts_;
}

// optional string padding = 6;
inline bool CommitMessage::_internal_has_padding() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommitMessage::has_padding() const {
  return _internal_has_padding();
}
inline void CommitMessage::clear_padding() {
  padding_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommitMessage::padding() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitMessage.padding)
  return _internal_padding();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommitMessage::set_padding(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 padding_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.CommitMessage.padding)
}
inline std::string* CommitMessage::mutable_padding() {
  std::string* _s = _internal_mutable_padding();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitMessage.padding)
  return _s;
}
inline const std::string& CommitMessage::_internal_padding() const {
  return padding_.Get();
}
inline void CommitMessage::_internal_set_padding(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  padding_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitMessage::_internal_mutable_padding() {
  _has_bits_[0] |= 0x00000002u;
  return padding_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitMessage::release_padding() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitMessage.padding)
  if (!_internal_has_padding()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = padding_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (padding_.IsDefault()) {
    padding_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommitMessage::set_allocated_padding(std::string* padding) {
  if (padding != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  padding_.SetAllocated(padding, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (padding_.IsDefault()) {
    padding_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitMessage.padding)
}

// -------------------------------------------------------------------

// GetUpdatesMessage

// optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
inline bool GetUpdatesMessage::_internal_has_caller_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || caller_info_ != nullptr);
  return value;
}
inline bool GetUpdatesMessage::has_caller_info() const {
  return _internal_has_caller_info();
}
inline const ::sync_pb::GetUpdatesCallerInfo& GetUpdatesMessage::_internal_caller_info() const {
  const ::sync_pb::GetUpdatesCallerInfo* p = caller_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::GetUpdatesCallerInfo&>(
      ::sync_pb::_GetUpdatesCallerInfo_default_instance_);
}
inline const ::sync_pb::GetUpdatesCallerInfo& GetUpdatesMessage::caller_info() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.caller_info)
  return _internal_caller_info();
}
inline void GetUpdatesMessage::unsafe_arena_set_allocated_caller_info(
    ::sync_pb::GetUpdatesCallerInfo* caller_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller_info_);
  }
  caller_info_ = caller_info;
  if (caller_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.GetUpdatesMessage.caller_info)
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::release_caller_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::sync_pb::GetUpdatesCallerInfo* temp = caller_info_;
  caller_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::unsafe_arena_release_caller_info() {
  // @@protoc_insertion_point(field_release:sync_pb.GetUpdatesMessage.caller_info)
  _has_bits_[0] &= ~0x00000001u;
  ::sync_pb::GetUpdatesCallerInfo* temp = caller_info_;
  caller_info_ = nullptr;
  return temp;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::_internal_mutable_caller_info() {
  _has_bits_[0] |= 0x00000001u;
  if (caller_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::GetUpdatesCallerInfo>(GetArenaForAllocation());
    caller_info_ = p;
  }
  return caller_info_;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::mutable_caller_info() {
  ::sync_pb::GetUpdatesCallerInfo* _msg = _internal_mutable_caller_info();
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesMessage.caller_info)
  return _msg;
}
inline void GetUpdatesMessage::set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller_info_);
  }
  if (caller_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(caller_info));
    if (message_arena != submessage_arena) {
      caller_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, caller_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  caller_info_ = caller_info;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.GetUpdatesMessage.caller_info)
}

// optional bool fetch_folders = 3 [default = true];
inline bool GetUpdatesMessage::_internal_has_fetch_folders() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GetUpdatesMessage::has_fetch_folders() const {
  return _internal_has_fetch_folders();
}
inline void GetUpdatesMessage::clear_fetch_folders() {
  fetch_folders_ = true;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool GetUpdatesMessage::_internal_fetch_folders() const {
  return fetch_folders_;
}
inline bool GetUpdatesMessage::fetch_folders() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.fetch_folders)
  return _internal_fetch_folders();
}
inline void GetUpdatesMessage::_internal_set_fetch_folders(bool value) {
  _has_bits_[0] |= 0x00000040u;
  fetch_folders_ = value;
}
inline void GetUpdatesMessage::set_fetch_folders(bool value) {
  _internal_set_fetch_folders(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.fetch_folders)
}

// repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
inline int GetUpdatesMessage::_internal_from_progress_marker_size() const {
  return from_progress_marker_.size();
}
inline int GetUpdatesMessage::from_progress_marker_size() const {
  return _internal_from_progress_marker_size();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::mutable_from_progress_marker(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesMessage.from_progress_marker)
  return from_progress_marker_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
GetUpdatesMessage::mutable_from_progress_marker() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesMessage.from_progress_marker)
  return &from_progress_marker_;
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesMessage::_internal_from_progress_marker(int index) const {
  return from_progress_marker_.Get(index);
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesMessage::from_progress_marker(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.from_progress_marker)
  return _internal_from_progress_marker(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::_internal_add_from_progress_marker() {
  return from_progress_marker_.Add();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::add_from_progress_marker() {
  ::sync_pb::DataTypeProgressMarker* _add = _internal_add_from_progress_marker();
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesMessage.from_progress_marker)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
GetUpdatesMessage::from_progress_marker() const {
  // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesMessage.from_progress_marker)
  return from_progress_marker_;
}

// optional bool streaming = 7 [default = false];
inline bool GetUpdatesMessage::_internal_has_streaming() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetUpdatesMessage::has_streaming() const {
  return _internal_has_streaming();
}
inline void GetUpdatesMessage::clear_streaming() {
  streaming_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool GetUpdatesMessage::_internal_streaming() const {
  return streaming_;
}
inline bool GetUpdatesMessage::streaming() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.streaming)
  return _internal_streaming();
}
inline void GetUpdatesMessage::_internal_set_streaming(bool value) {
  _has_bits_[0] |= 0x00000004u;
  streaming_ = value;
}
inline void GetUpdatesMessage::set_streaming(bool value) {
  _internal_set_streaming(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.streaming)
}

// optional bool need_encryption_key = 8 [default = false];
inline bool GetUpdatesMessage::_internal_has_need_encryption_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetUpdatesMessage::has_need_encryption_key() const {
  return _internal_has_need_encryption_key();
}
inline void GetUpdatesMessage::clear_need_encryption_key() {
  need_encryption_key_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool GetUpdatesMessage::_internal_need_encryption_key() const {
  return need_encryption_key_;
}
inline bool GetUpdatesMessage::need_encryption_key() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.need_encryption_key)
  return _internal_need_encryption_key();
}
inline void GetUpdatesMessage::_internal_set_need_encryption_key(bool value) {
  _has_bits_[0] |= 0x00000008u;
  need_encryption_key_ = value;
}
inline void GetUpdatesMessage::set_need_encryption_key(bool value) {
  _internal_set_need_encryption_key(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.need_encryption_key)
}

// optional bool create_mobile_bookmarks_folder = 1000 [default = false, deprecated = true];
inline bool GetUpdatesMessage::_internal_has_create_mobile_bookmarks_folder() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetUpdatesMessage::has_create_mobile_bookmarks_folder() const {
  return _internal_has_create_mobile_bookmarks_folder();
}
inline void GetUpdatesMessage::clear_create_mobile_bookmarks_folder() {
  create_mobile_bookmarks_folder_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool GetUpdatesMessage::_internal_create_mobile_bookmarks_folder() const {
  return create_mobile_bookmarks_folder_;
}
inline bool GetUpdatesMessage::create_mobile_bookmarks_folder() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.create_mobile_bookmarks_folder)
  return _internal_create_mobile_bookmarks_folder();
}
inline void GetUpdatesMessage::_internal_set_create_mobile_bookmarks_folder(bool value) {
  _has_bits_[0] |= 0x00000010u;
  create_mobile_bookmarks_folder_ = value;
}
inline void GetUpdatesMessage::set_create_mobile_bookmarks_folder(bool value) {
  _internal_set_create_mobile_bookmarks_folder(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.create_mobile_bookmarks_folder)
}

// optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
inline bool GetUpdatesMessage::_internal_has_get_updates_origin() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetUpdatesMessage::has_get_updates_origin() const {
  return _internal_has_get_updates_origin();
}
inline void GetUpdatesMessage::clear_get_updates_origin() {
  get_updates_origin_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::SyncEnums_GetUpdatesOrigin GetUpdatesMessage::_internal_get_updates_origin() const {
  return static_cast< ::sync_pb::SyncEnums_GetUpdatesOrigin >(get_updates_origin_);
}
inline ::sync_pb::SyncEnums_GetUpdatesOrigin GetUpdatesMessage::get_updates_origin() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.get_updates_origin)
  return _internal_get_updates_origin();
}
inline void GetUpdatesMessage::_internal_set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value) {
  assert(::sync_pb::SyncEnums_GetUpdatesOrigin_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  get_updates_origin_ = value;
}
inline void GetUpdatesMessage::set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value) {
  _internal_set_get_updates_origin(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.get_updates_origin)
}

// optional bool is_retry = 10 [default = false];
inline bool GetUpdatesMessage::_internal_has_is_retry() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetUpdatesMessage::has_is_retry() const {
  return _internal_has_is_retry();
}
inline void GetUpdatesMessage::clear_is_retry() {
  is_retry_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool GetUpdatesMessage::_internal_is_retry() const {
  return is_retry_;
}
inline bool GetUpdatesMessage::is_retry() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.is_retry)
  return _internal_is_retry();
}
inline void GetUpdatesMessage::_internal_set_is_retry(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_retry_ = value;
}
inline void GetUpdatesMessage::set_is_retry(bool value) {
  _internal_set_is_retry(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesMessage.is_retry)
}

// repeated .sync_pb.DataTypeContext client_contexts = 11;
inline int GetUpdatesMessage::_internal_client_contexts_size() const {
  return client_contexts_.size();
}
inline int GetUpdatesMessage::client_contexts_size() const {
  return _internal_client_contexts_size();
}
inline ::sync_pb::DataTypeContext* GetUpdatesMessage::mutable_client_contexts(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesMessage.client_contexts)
  return client_contexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >*
GetUpdatesMessage::mutable_client_contexts() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesMessage.client_contexts)
  return &client_contexts_;
}
inline const ::sync_pb::DataTypeContext& GetUpdatesMessage::_internal_client_contexts(int index) const {
  return client_contexts_.Get(index);
}
inline const ::sync_pb::DataTypeContext& GetUpdatesMessage::client_contexts(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesMessage.client_contexts)
  return _internal_client_contexts(index);
}
inline ::sync_pb::DataTypeContext* GetUpdatesMessage::_internal_add_client_contexts() {
  return client_contexts_.Add();
}
inline ::sync_pb::DataTypeContext* GetUpdatesMessage::add_client_contexts() {
  ::sync_pb::DataTypeContext* _add = _internal_add_client_contexts();
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesMessage.client_contexts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >&
GetUpdatesMessage::client_contexts() const {
  // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesMessage.client_contexts)
  return client_contexts_;
}

// -------------------------------------------------------------------

// ClearServerDataMessage

// -------------------------------------------------------------------

// ClearServerDataResponse

// -------------------------------------------------------------------

// ChipBag

// optional bytes server_chips = 1;
inline bool ChipBag::_internal_has_server_chips() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ChipBag::has_server_chips() const {
  return _internal_has_server_chips();
}
inline void ChipBag::clear_server_chips() {
  server_chips_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ChipBag::server_chips() const {
  // @@protoc_insertion_point(field_get:sync_pb.ChipBag.server_chips)
  return _internal_server_chips();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ChipBag::set_server_chips(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 server_chips_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ChipBag.server_chips)
}
inline std::string* ChipBag::mutable_server_chips() {
  std::string* _s = _internal_mutable_server_chips();
  // @@protoc_insertion_point(field_mutable:sync_pb.ChipBag.server_chips)
  return _s;
}
inline const std::string& ChipBag::_internal_server_chips() const {
  return server_chips_.Get();
}
inline void ChipBag::_internal_set_server_chips(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  server_chips_.Set(value, GetArenaForAllocation());
}
inline std::string* ChipBag::_internal_mutable_server_chips() {
  _has_bits_[0] |= 0x00000001u;
  return server_chips_.Mutable(GetArenaForAllocation());
}
inline std::string* ChipBag::release_server_chips() {
  // @@protoc_insertion_point(field_release:sync_pb.ChipBag.server_chips)
  if (!_internal_has_server_chips()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = server_chips_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_chips_.IsDefault()) {
    server_chips_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ChipBag::set_allocated_server_chips(std::string* server_chips) {
  if (server_chips != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  server_chips_.SetAllocated(server_chips, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_chips_.IsDefault()) {
    server_chips_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ChipBag.server_chips)
}

// -------------------------------------------------------------------

// ClientStatus

// optional bool hierarchy_conflict_detected = 1 [deprecated = true];
inline bool ClientStatus::_internal_has_hierarchy_conflict_detected() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientStatus::has_hierarchy_conflict_detected() const {
  return _internal_has_hierarchy_conflict_detected();
}
inline void ClientStatus::clear_hierarchy_conflict_detected() {
  hierarchy_conflict_detected_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool ClientStatus::_internal_hierarchy_conflict_detected() const {
  return hierarchy_conflict_detected_;
}
inline bool ClientStatus::hierarchy_conflict_detected() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientStatus.hierarchy_conflict_detected)
  return _internal_hierarchy_conflict_detected();
}
inline void ClientStatus::_internal_set_hierarchy_conflict_detected(bool value) {
  _has_bits_[0] |= 0x00000001u;
  hierarchy_conflict_detected_ = value;
}
inline void ClientStatus::set_hierarchy_conflict_detected(bool value) {
  _internal_set_hierarchy_conflict_detected(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientStatus.hierarchy_conflict_detected)
}

// optional bool is_sync_feature_enabled = 2;
inline bool ClientStatus::_internal_has_is_sync_feature_enabled() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientStatus::has_is_sync_feature_enabled() const {
  return _internal_has_is_sync_feature_enabled();
}
inline void ClientStatus::clear_is_sync_feature_enabled() {
  is_sync_feature_enabled_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool ClientStatus::_internal_is_sync_feature_enabled() const {
  return is_sync_feature_enabled_;
}
inline bool ClientStatus::is_sync_feature_enabled() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientStatus.is_sync_feature_enabled)
  return _internal_is_sync_feature_enabled();
}
inline void ClientStatus::_internal_set_is_sync_feature_enabled(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_sync_feature_enabled_ = value;
}
inline void ClientStatus::set_is_sync_feature_enabled(bool value) {
  _internal_set_is_sync_feature_enabled(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientStatus.is_sync_feature_enabled)
}

// -------------------------------------------------------------------

// ClientToServerMessage

// required string share = 1;
inline bool ClientToServerMessage::_internal_has_share() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_share() const {
  return _internal_has_share();
}
inline void ClientToServerMessage::clear_share() {
  share_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientToServerMessage::share() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.share)
  return _internal_share();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerMessage::set_share(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 share_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.share)
}
inline std::string* ClientToServerMessage::mutable_share() {
  std::string* _s = _internal_mutable_share();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.share)
  return _s;
}
inline const std::string& ClientToServerMessage::_internal_share() const {
  return share_.Get();
}
inline void ClientToServerMessage::_internal_set_share(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  share_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_share() {
  _has_bits_[0] |= 0x00000001u;
  return share_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_share() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.share)
  if (!_internal_has_share()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = share_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (share_.IsDefault()) {
    share_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerMessage::set_allocated_share(std::string* share) {
  if (share != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  share_.SetAllocated(share, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (share_.IsDefault()) {
    share_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.share)
}

// optional int32 protocol_version = 2 [default = 99];
inline bool ClientToServerMessage::_internal_has_protocol_version() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_protocol_version() const {
  return _internal_has_protocol_version();
}
inline void ClientToServerMessage::clear_protocol_version() {
  protocol_version_ = 99;
  _has_bits_[0] &= ~0x00000800u;
}
inline int32_t ClientToServerMessage::_internal_protocol_version() const {
  return protocol_version_;
}
inline int32_t ClientToServerMessage::protocol_version() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.protocol_version)
  return _internal_protocol_version();
}
inline void ClientToServerMessage::_internal_set_protocol_version(int32_t value) {
  _has_bits_[0] |= 0x00000800u;
  protocol_version_ = value;
}
inline void ClientToServerMessage::set_protocol_version(int32_t value) {
  _internal_set_protocol_version(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.protocol_version)
}

// required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
inline bool ClientToServerMessage::_internal_has_message_contents() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_message_contents() const {
  return _internal_has_message_contents();
}
inline void ClientToServerMessage::clear_message_contents() {
  message_contents_ = 1;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::sync_pb::ClientToServerMessage_Contents ClientToServerMessage::_internal_message_contents() const {
  return static_cast< ::sync_pb::ClientToServerMessage_Contents >(message_contents_);
}
inline ::sync_pb::ClientToServerMessage_Contents ClientToServerMessage::message_contents() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.message_contents)
  return _internal_message_contents();
}
inline void ClientToServerMessage::_internal_set_message_contents(::sync_pb::ClientToServerMessage_Contents value) {
  assert(::sync_pb::ClientToServerMessage_Contents_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  message_contents_ = value;
}
inline void ClientToServerMessage::set_message_contents(::sync_pb::ClientToServerMessage_Contents value) {
  _internal_set_message_contents(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.message_contents)
}

// optional .sync_pb.CommitMessage commit = 4;
inline bool ClientToServerMessage::_internal_has_commit() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || commit_ != nullptr);
  return value;
}
inline bool ClientToServerMessage::has_commit() const {
  return _internal_has_commit();
}
inline void ClientToServerMessage::clear_commit() {
  if (commit_ != nullptr) commit_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::sync_pb::CommitMessage& ClientToServerMessage::_internal_commit() const {
  const ::sync_pb::CommitMessage* p = commit_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::CommitMessage&>(
      ::sync_pb::_CommitMessage_default_instance_);
}
inline const ::sync_pb::CommitMessage& ClientToServerMessage::commit() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.commit)
  return _internal_commit();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_commit(
    ::sync_pb::CommitMessage* commit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_);
  }
  commit_ = commit;
  if (commit) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.commit)
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::release_commit() {
  _has_bits_[0] &= ~0x00000010u;
  ::sync_pb::CommitMessage* temp = commit_;
  commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.commit)
  _has_bits_[0] &= ~0x00000010u;
  ::sync_pb::CommitMessage* temp = commit_;
  commit_ = nullptr;
  return temp;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::_internal_mutable_commit() {
  _has_bits_[0] |= 0x00000010u;
  if (commit_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::CommitMessage>(GetArenaForAllocation());
    commit_ = p;
  }
  return commit_;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::mutable_commit() {
  ::sync_pb::CommitMessage* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.commit)
  return _msg;
}
inline void ClientToServerMessage::set_allocated_commit(::sync_pb::CommitMessage* commit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commit_;
  }
  if (commit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commit);
    if (message_arena != submessage_arena) {
      commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  commit_ = commit;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.commit)
}

// optional .sync_pb.GetUpdatesMessage get_updates = 5;
inline bool ClientToServerMessage::_internal_has_get_updates() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || get_updates_ != nullptr);
  return value;
}
inline bool ClientToServerMessage::has_get_updates() const {
  return _internal_has_get_updates();
}
inline void ClientToServerMessage::clear_get_updates() {
  if (get_updates_ != nullptr) get_updates_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::sync_pb::GetUpdatesMessage& ClientToServerMessage::_internal_get_updates() const {
  const ::sync_pb::GetUpdatesMessage* p = get_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::GetUpdatesMessage&>(
      ::sync_pb::_GetUpdatesMessage_default_instance_);
}
inline const ::sync_pb::GetUpdatesMessage& ClientToServerMessage::get_updates() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.get_updates)
  return _internal_get_updates();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_get_updates(
    ::sync_pb::GetUpdatesMessage* get_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(get_updates_);
  }
  get_updates_ = get_updates;
  if (get_updates) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.get_updates)
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::release_get_updates() {
  _has_bits_[0] &= ~0x00000020u;
  ::sync_pb::GetUpdatesMessage* temp = get_updates_;
  get_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::unsafe_arena_release_get_updates() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.get_updates)
  _has_bits_[0] &= ~0x00000020u;
  ::sync_pb::GetUpdatesMessage* temp = get_updates_;
  get_updates_ = nullptr;
  return temp;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::_internal_mutable_get_updates() {
  _has_bits_[0] |= 0x00000020u;
  if (get_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::GetUpdatesMessage>(GetArenaForAllocation());
    get_updates_ = p;
  }
  return get_updates_;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::mutable_get_updates() {
  ::sync_pb::GetUpdatesMessage* _msg = _internal_mutable_get_updates();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.get_updates)
  return _msg;
}
inline void ClientToServerMessage::set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete get_updates_;
  }
  if (get_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_updates);
    if (message_arena != submessage_arena) {
      get_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_updates, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  get_updates_ = get_updates;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.get_updates)
}

// optional string store_birthday = 7;
inline bool ClientToServerMessage::_internal_has_store_birthday() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_store_birthday() const {
  return _internal_has_store_birthday();
}
inline void ClientToServerMessage::clear_store_birthday() {
  store_birthday_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientToServerMessage::store_birthday() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.store_birthday)
  return _internal_store_birthday();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerMessage::set_store_birthday(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 store_birthday_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.store_birthday)
}
inline std::string* ClientToServerMessage::mutable_store_birthday() {
  std::string* _s = _internal_mutable_store_birthday();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.store_birthday)
  return _s;
}
inline const std::string& ClientToServerMessage::_internal_store_birthday() const {
  return store_birthday_.Get();
}
inline void ClientToServerMessage::_internal_set_store_birthday(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  store_birthday_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_store_birthday() {
  _has_bits_[0] |= 0x00000002u;
  return store_birthday_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_store_birthday() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.store_birthday)
  if (!_internal_has_store_birthday()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = store_birthday_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_birthday_.IsDefault()) {
    store_birthday_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerMessage::set_allocated_store_birthday(std::string* store_birthday) {
  if (store_birthday != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_birthday_.SetAllocated(store_birthday, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_birthday_.IsDefault()) {
    store_birthday_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.store_birthday)
}

// optional bool sync_problem_detected = 8 [default = false];
inline bool ClientToServerMessage::_internal_has_sync_problem_detected() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_sync_problem_detected() const {
  return _internal_has_sync_problem_detected();
}
inline void ClientToServerMessage::clear_sync_problem_detected() {
  sync_problem_detected_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool ClientToServerMessage::_internal_sync_problem_detected() const {
  return sync_problem_detected_;
}
inline bool ClientToServerMessage::sync_problem_detected() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.sync_problem_detected)
  return _internal_sync_problem_detected();
}
inline void ClientToServerMessage::_internal_set_sync_problem_detected(bool value) {
  _has_bits_[0] |= 0x00000400u;
  sync_problem_detected_ = value;
}
inline void ClientToServerMessage::set_sync_problem_detected(bool value) {
  _internal_set_sync_problem_detected(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.sync_problem_detected)
}

// optional .sync_pb.DebugInfo debug_info = 10;
inline bool ClientToServerMessage::_internal_has_debug_info() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || debug_info_ != nullptr);
  return value;
}
inline bool ClientToServerMessage::has_debug_info() const {
  return _internal_has_debug_info();
}
inline const ::sync_pb::DebugInfo& ClientToServerMessage::_internal_debug_info() const {
  const ::sync_pb::DebugInfo* p = debug_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::DebugInfo&>(
      ::sync_pb::_DebugInfo_default_instance_);
}
inline const ::sync_pb::DebugInfo& ClientToServerMessage::debug_info() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.debug_info)
  return _internal_debug_info();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_debug_info(
    ::sync_pb::DebugInfo* debug_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_info_);
  }
  debug_info_ = debug_info;
  if (debug_info) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.debug_info)
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::release_debug_info() {
  _has_bits_[0] &= ~0x00000040u;
  ::sync_pb::DebugInfo* temp = debug_info_;
  debug_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::unsafe_arena_release_debug_info() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.debug_info)
  _has_bits_[0] &= ~0x00000040u;
  ::sync_pb::DebugInfo* temp = debug_info_;
  debug_info_ = nullptr;
  return temp;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::_internal_mutable_debug_info() {
  _has_bits_[0] |= 0x00000040u;
  if (debug_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::DebugInfo>(GetArenaForAllocation());
    debug_info_ = p;
  }
  return debug_info_;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::mutable_debug_info() {
  ::sync_pb::DebugInfo* _msg = _internal_mutable_debug_info();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.debug_info)
  return _msg;
}
inline void ClientToServerMessage::set_allocated_debug_info(::sync_pb::DebugInfo* debug_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_info_);
  }
  if (debug_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(debug_info));
    if (message_arena != submessage_arena) {
      debug_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, debug_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  debug_info_ = debug_info;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.debug_info)
}

// optional .sync_pb.ChipBag bag_of_chips = 11;
inline bool ClientToServerMessage::_internal_has_bag_of_chips() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || bag_of_chips_ != nullptr);
  return value;
}
inline bool ClientToServerMessage::has_bag_of_chips() const {
  return _internal_has_bag_of_chips();
}
inline void ClientToServerMessage::clear_bag_of_chips() {
  if (bag_of_chips_ != nullptr) bag_of_chips_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::ChipBag& ClientToServerMessage::_internal_bag_of_chips() const {
  const ::sync_pb::ChipBag* p = bag_of_chips_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ChipBag&>(
      ::sync_pb::_ChipBag_default_instance_);
}
inline const ::sync_pb::ChipBag& ClientToServerMessage::bag_of_chips() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.bag_of_chips)
  return _internal_bag_of_chips();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_bag_of_chips(
    ::sync_pb::ChipBag* bag_of_chips) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(bag_of_chips_);
  }
  bag_of_chips_ = bag_of_chips;
  if (bag_of_chips) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.bag_of_chips)
}
inline ::sync_pb::ChipBag* ClientToServerMessage::release_bag_of_chips() {
  _has_bits_[0] &= ~0x00000080u;
  ::sync_pb::ChipBag* temp = bag_of_chips_;
  bag_of_chips_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::unsafe_arena_release_bag_of_chips() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.bag_of_chips)
  _has_bits_[0] &= ~0x00000080u;
  ::sync_pb::ChipBag* temp = bag_of_chips_;
  bag_of_chips_ = nullptr;
  return temp;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::_internal_mutable_bag_of_chips() {
  _has_bits_[0] |= 0x00000080u;
  if (bag_of_chips_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ChipBag>(GetArenaForAllocation());
    bag_of_chips_ = p;
  }
  return bag_of_chips_;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::mutable_bag_of_chips() {
  ::sync_pb::ChipBag* _msg = _internal_mutable_bag_of_chips();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.bag_of_chips)
  return _msg;
}
inline void ClientToServerMessage::set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete bag_of_chips_;
  }
  if (bag_of_chips) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bag_of_chips);
    if (message_arena != submessage_arena) {
      bag_of_chips = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bag_of_chips, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  bag_of_chips_ = bag_of_chips;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.bag_of_chips)
}

// optional string api_key = 12;
inline bool ClientToServerMessage::_internal_has_api_key() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_api_key() const {
  return _internal_has_api_key();
}
inline void ClientToServerMessage::clear_api_key() {
  api_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& ClientToServerMessage::api_key() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.api_key)
  return _internal_api_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerMessage::set_api_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 api_key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.api_key)
}
inline std::string* ClientToServerMessage::mutable_api_key() {
  std::string* _s = _internal_mutable_api_key();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.api_key)
  return _s;
}
inline const std::string& ClientToServerMessage::_internal_api_key() const {
  return api_key_.Get();
}
inline void ClientToServerMessage::_internal_set_api_key(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  api_key_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_api_key() {
  _has_bits_[0] |= 0x00000004u;
  return api_key_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_api_key() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.api_key)
  if (!_internal_has_api_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = api_key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_key_.IsDefault()) {
    api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerMessage::set_allocated_api_key(std::string* api_key) {
  if (api_key != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  api_key_.SetAllocated(api_key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (api_key_.IsDefault()) {
    api_key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.api_key)
}

// optional .sync_pb.ClientStatus client_status = 13;
inline bool ClientToServerMessage::_internal_has_client_status() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || client_status_ != nullptr);
  return value;
}
inline bool ClientToServerMessage::has_client_status() const {
  return _internal_has_client_status();
}
inline void ClientToServerMessage::clear_client_status() {
  if (client_status_ != nullptr) client_status_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::sync_pb::ClientStatus& ClientToServerMessage::_internal_client_status() const {
  const ::sync_pb::ClientStatus* p = client_status_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientStatus&>(
      ::sync_pb::_ClientStatus_default_instance_);
}
inline const ::sync_pb::ClientStatus& ClientToServerMessage::client_status() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.client_status)
  return _internal_client_status();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_client_status(
    ::sync_pb::ClientStatus* client_status) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_status_);
  }
  client_status_ = client_status;
  if (client_status) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.client_status)
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::release_client_status() {
  _has_bits_[0] &= ~0x00000100u;
  ::sync_pb::ClientStatus* temp = client_status_;
  client_status_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::unsafe_arena_release_client_status() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.client_status)
  _has_bits_[0] &= ~0x00000100u;
  ::sync_pb::ClientStatus* temp = client_status_;
  client_status_ = nullptr;
  return temp;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::_internal_mutable_client_status() {
  _has_bits_[0] |= 0x00000100u;
  if (client_status_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ClientStatus>(GetArenaForAllocation());
    client_status_ = p;
  }
  return client_status_;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::mutable_client_status() {
  ::sync_pb::ClientStatus* _msg = _internal_mutable_client_status();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.client_status)
  return _msg;
}
inline void ClientToServerMessage::set_allocated_client_status(::sync_pb::ClientStatus* client_status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete client_status_;
  }
  if (client_status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_status);
    if (message_arena != submessage_arena) {
      client_status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_status, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  client_status_ = client_status;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.client_status)
}

// optional string invalidator_client_id = 14;
inline bool ClientToServerMessage::_internal_has_invalidator_client_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ClientToServerMessage::has_invalidator_client_id() const {
  return _internal_has_invalidator_client_id();
}
inline void ClientToServerMessage::clear_invalidator_client_id() {
  invalidator_client_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& ClientToServerMessage::invalidator_client_id() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.invalidator_client_id)
  return _internal_invalidator_client_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerMessage::set_invalidator_client_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 invalidator_client_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerMessage.invalidator_client_id)
}
inline std::string* ClientToServerMessage::mutable_invalidator_client_id() {
  std::string* _s = _internal_mutable_invalidator_client_id();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.invalidator_client_id)
  return _s;
}
inline const std::string& ClientToServerMessage::_internal_invalidator_client_id() const {
  return invalidator_client_id_.Get();
}
inline void ClientToServerMessage::_internal_set_invalidator_client_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  invalidator_client_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::_internal_mutable_invalidator_client_id() {
  _has_bits_[0] |= 0x00000008u;
  return invalidator_client_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerMessage::release_invalidator_client_id() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.invalidator_client_id)
  if (!_internal_has_invalidator_client_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = invalidator_client_id_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (invalidator_client_id_.IsDefault()) {
    invalidator_client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerMessage::set_allocated_invalidator_client_id(std::string* invalidator_client_id) {
  if (invalidator_client_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  invalidator_client_id_.SetAllocated(invalidator_client_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (invalidator_client_id_.IsDefault()) {
    invalidator_client_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.invalidator_client_id)
}

// optional .sync_pb.ClearServerDataMessage clear_server_data = 15;
inline bool ClientToServerMessage::_internal_has_clear_server_data() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || clear_server_data_ != nullptr);
  return value;
}
inline bool ClientToServerMessage::has_clear_server_data() const {
  return _internal_has_clear_server_data();
}
inline void ClientToServerMessage::clear_clear_server_data() {
  if (clear_server_data_ != nullptr) clear_server_data_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::sync_pb::ClearServerDataMessage& ClientToServerMessage::_internal_clear_server_data() const {
  const ::sync_pb::ClearServerDataMessage* p = clear_server_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClearServerDataMessage&>(
      ::sync_pb::_ClearServerDataMessage_default_instance_);
}
inline const ::sync_pb::ClearServerDataMessage& ClientToServerMessage::clear_server_data() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerMessage.clear_server_data)
  return _internal_clear_server_data();
}
inline void ClientToServerMessage::unsafe_arena_set_allocated_clear_server_data(
    ::sync_pb::ClearServerDataMessage* clear_server_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clear_server_data_);
  }
  clear_server_data_ = clear_server_data;
  if (clear_server_data) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerMessage.clear_server_data)
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::release_clear_server_data() {
  _has_bits_[0] &= ~0x00000200u;
  ::sync_pb::ClearServerDataMessage* temp = clear_server_data_;
  clear_server_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::unsafe_arena_release_clear_server_data() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerMessage.clear_server_data)
  _has_bits_[0] &= ~0x00000200u;
  ::sync_pb::ClearServerDataMessage* temp = clear_server_data_;
  clear_server_data_ = nullptr;
  return temp;
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::_internal_mutable_clear_server_data() {
  _has_bits_[0] |= 0x00000200u;
  if (clear_server_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ClearServerDataMessage>(GetArenaForAllocation());
    clear_server_data_ = p;
  }
  return clear_server_data_;
}
inline ::sync_pb::ClearServerDataMessage* ClientToServerMessage::mutable_clear_server_data() {
  ::sync_pb::ClearServerDataMessage* _msg = _internal_mutable_clear_server_data();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerMessage.clear_server_data)
  return _msg;
}
inline void ClientToServerMessage::set_allocated_clear_server_data(::sync_pb::ClearServerDataMessage* clear_server_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clear_server_data_;
  }
  if (clear_server_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_server_data);
    if (message_arena != submessage_arena) {
      clear_server_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_server_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  clear_server_data_ = clear_server_data;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerMessage.clear_server_data)
}

// -------------------------------------------------------------------

// CommitResponse_EntryResponse_DatatypeSpecificError

// .sync_pb.SharingMessageCommitError sharing_message_error = 1;
inline bool CommitResponse_EntryResponse_DatatypeSpecificError::_internal_has_sharing_message_error() const {
  return datatype_error_case() == kSharingMessageError;
}
inline bool CommitResponse_EntryResponse_DatatypeSpecificError::has_sharing_message_error() const {
  return _internal_has_sharing_message_error();
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::set_has_sharing_message_error() {
  _oneof_case_[0] = kSharingMessageError;
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::release_sharing_message_error() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
  if (_internal_has_sharing_message_error()) {
    clear_has_datatype_error();
    ::sync_pb::SharingMessageCommitError* temp = datatype_error_.sharing_message_error_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    datatype_error_.sharing_message_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::sync_pb::SharingMessageCommitError& CommitResponse_EntryResponse_DatatypeSpecificError::_internal_sharing_message_error() const {
  return _internal_has_sharing_message_error()
      ? *datatype_error_.sharing_message_error_
      : reinterpret_cast< ::sync_pb::SharingMessageCommitError&>(::sync_pb::_SharingMessageCommitError_default_instance_);
}
inline const ::sync_pb::SharingMessageCommitError& CommitResponse_EntryResponse_DatatypeSpecificError::sharing_message_error() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
  return _internal_sharing_message_error();
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::unsafe_arena_release_sharing_message_error() {
  // @@protoc_insertion_point(field_unsafe_arena_release:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
  if (_internal_has_sharing_message_error()) {
    clear_has_datatype_error();
    ::sync_pb::SharingMessageCommitError* temp = datatype_error_.sharing_message_error_;
    datatype_error_.sharing_message_error_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::unsafe_arena_set_allocated_sharing_message_error(::sync_pb::SharingMessageCommitError* sharing_message_error) {
  clear_datatype_error();
  if (sharing_message_error) {
    set_has_sharing_message_error();
    datatype_error_.sharing_message_error_ = sharing_message_error;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::_internal_mutable_sharing_message_error() {
  if (!_internal_has_sharing_message_error()) {
    clear_datatype_error();
    set_has_sharing_message_error();
    datatype_error_.sharing_message_error_ = CreateMaybeMessage< ::sync_pb::SharingMessageCommitError >(GetArenaForAllocation());
  }
  return datatype_error_.sharing_message_error_;
}
inline ::sync_pb::SharingMessageCommitError* CommitResponse_EntryResponse_DatatypeSpecificError::mutable_sharing_message_error() {
  ::sync_pb::SharingMessageCommitError* _msg = _internal_mutable_sharing_message_error();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError.sharing_message_error)
  return _msg;
}

inline bool CommitResponse_EntryResponse_DatatypeSpecificError::has_datatype_error() const {
  return datatype_error_case() != DATATYPE_ERROR_NOT_SET;
}
inline void CommitResponse_EntryResponse_DatatypeSpecificError::clear_has_datatype_error() {
  _oneof_case_[0] = DATATYPE_ERROR_NOT_SET;
}
inline CommitResponse_EntryResponse_DatatypeSpecificError::DatatypeErrorCase CommitResponse_EntryResponse_DatatypeSpecificError::datatype_error_case() const {
  return CommitResponse_EntryResponse_DatatypeSpecificError::DatatypeErrorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CommitResponse_EntryResponse

// required .sync_pb.CommitResponse.ResponseType response_type = 2;
inline bool CommitResponse_EntryResponse::_internal_has_response_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CommitResponse_EntryResponse::has_response_type() const {
  return _internal_has_response_type();
}
inline void CommitResponse_EntryResponse::clear_response_type() {
  response_type_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::sync_pb::CommitResponse_ResponseType CommitResponse_EntryResponse::_internal_response_type() const {
  return static_cast< ::sync_pb::CommitResponse_ResponseType >(response_type_);
}
inline ::sync_pb::CommitResponse_ResponseType CommitResponse_EntryResponse::response_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.response_type)
  return _internal_response_type();
}
inline void CommitResponse_EntryResponse::_internal_set_response_type(::sync_pb::CommitResponse_ResponseType value) {
  assert(::sync_pb::CommitResponse_ResponseType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  response_type_ = value;
}
inline void CommitResponse_EntryResponse::set_response_type(::sync_pb::CommitResponse_ResponseType value) {
  _internal_set_response_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.response_type)
}

// optional string id_string = 3;
inline bool CommitResponse_EntryResponse::_internal_has_id_string() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CommitResponse_EntryResponse::has_id_string() const {
  return _internal_has_id_string();
}
inline void CommitResponse_EntryResponse::clear_id_string() {
  id_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CommitResponse_EntryResponse::id_string() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.id_string)
  return _internal_id_string();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommitResponse_EntryResponse::set_id_string(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 id_string_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.id_string)
}
inline std::string* CommitResponse_EntryResponse::mutable_id_string() {
  std::string* _s = _internal_mutable_id_string();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.id_string)
  return _s;
}
inline const std::string& CommitResponse_EntryResponse::_internal_id_string() const {
  return id_string_.Get();
}
inline void CommitResponse_EntryResponse::_internal_set_id_string(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_string_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::_internal_mutable_id_string() {
  _has_bits_[0] |= 0x00000001u;
  return id_string_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::release_id_string() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.id_string)
  if (!_internal_has_id_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = id_string_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_string_.IsDefault()) {
    id_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommitResponse_EntryResponse::set_allocated_id_string(std::string* id_string) {
  if (id_string != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_string_.SetAllocated(id_string, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (id_string_.IsDefault()) {
    id_string_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.id_string)
}

// optional int64 version = 6;
inline bool CommitResponse_EntryResponse::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CommitResponse_EntryResponse::has_version() const {
  return _internal_has_version();
}
inline void CommitResponse_EntryResponse::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000008u;
}
inline int64_t CommitResponse_EntryResponse::_internal_version() const {
  return version_;
}
inline int64_t CommitResponse_EntryResponse::version() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.version)
  return _internal_version();
}
inline void CommitResponse_EntryResponse::_internal_set_version(int64_t value) {
  _has_bits_[0] |= 0x00000008u;
  version_ = value;
}
inline void CommitResponse_EntryResponse::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.version)
}

// optional string error_message = 9;
inline bool CommitResponse_EntryResponse::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CommitResponse_EntryResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void CommitResponse_EntryResponse::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CommitResponse_EntryResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CommitResponse_EntryResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.error_message)
}
inline std::string* CommitResponse_EntryResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.error_message)
  return _s;
}
inline const std::string& CommitResponse_EntryResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void CommitResponse_EntryResponse::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000002u;
  return error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* CommitResponse_EntryResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault()) {
    error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CommitResponse_EntryResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault()) {
    error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.error_message)
}

// optional int64 mtime = 10 [deprecated = true];
inline bool CommitResponse_EntryResponse::_internal_has_mtime() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CommitResponse_EntryResponse::has_mtime() const {
  return _internal_has_mtime();
}
inline void CommitResponse_EntryResponse::clear_mtime() {
  mtime_ = int64_t{0};
  _has_bits_[0] &= ~0x00000010u;
}
inline int64_t CommitResponse_EntryResponse::_internal_mtime() const {
  return mtime_;
}
inline int64_t CommitResponse_EntryResponse::mtime() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.mtime)
  return _internal_mtime();
}
inline void CommitResponse_EntryResponse::_internal_set_mtime(int64_t value) {
  _has_bits_[0] |= 0x00000010u;
  mtime_ = value;
}
inline void CommitResponse_EntryResponse::set_mtime(int64_t value) {
  _internal_set_mtime(value);
  // @@protoc_insertion_point(field_set:sync_pb.CommitResponse.EntryResponse.mtime)
}

// optional .sync_pb.CommitResponse.EntryResponse.DatatypeSpecificError datatype_specific_error = 11;
inline bool CommitResponse_EntryResponse::_internal_has_datatype_specific_error() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || datatype_specific_error_ != nullptr);
  return value;
}
inline bool CommitResponse_EntryResponse::has_datatype_specific_error() const {
  return _internal_has_datatype_specific_error();
}
inline void CommitResponse_EntryResponse::clear_datatype_specific_error() {
  if (datatype_specific_error_ != nullptr) datatype_specific_error_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& CommitResponse_EntryResponse::_internal_datatype_specific_error() const {
  const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* p = datatype_specific_error_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError&>(
      ::sync_pb::_CommitResponse_EntryResponse_DatatypeSpecificError_default_instance_);
}
inline const ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError& CommitResponse_EntryResponse::datatype_specific_error() const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
  return _internal_datatype_specific_error();
}
inline void CommitResponse_EntryResponse::unsafe_arena_set_allocated_datatype_specific_error(
    ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datatype_specific_error_);
  }
  datatype_specific_error_ = datatype_specific_error;
  if (datatype_specific_error) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::release_datatype_specific_error() {
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* temp = datatype_specific_error_;
  datatype_specific_error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::unsafe_arena_release_datatype_specific_error() {
  // @@protoc_insertion_point(field_release:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* temp = datatype_specific_error_;
  datatype_specific_error_ = nullptr;
  return temp;
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::_internal_mutable_datatype_specific_error() {
  _has_bits_[0] |= 0x00000004u;
  if (datatype_specific_error_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError>(GetArenaForAllocation());
    datatype_specific_error_ = p;
  }
  return datatype_specific_error_;
}
inline ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* CommitResponse_EntryResponse::mutable_datatype_specific_error() {
  ::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* _msg = _internal_mutable_datatype_specific_error();
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
  return _msg;
}
inline void CommitResponse_EntryResponse::set_allocated_datatype_specific_error(::sync_pb::CommitResponse_EntryResponse_DatatypeSpecificError* datatype_specific_error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete datatype_specific_error_;
  }
  if (datatype_specific_error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(datatype_specific_error);
    if (message_arena != submessage_arena) {
      datatype_specific_error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datatype_specific_error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  datatype_specific_error_ = datatype_specific_error;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.CommitResponse.EntryResponse.datatype_specific_error)
}

// -------------------------------------------------------------------

// CommitResponse

// repeated group EntryResponse = 1 { ... };
inline int CommitResponse::_internal_entryresponse_size() const {
  return entryresponse_.size();
}
inline int CommitResponse::entryresponse_size() const {
  return _internal_entryresponse_size();
}
inline void CommitResponse::clear_entryresponse() {
  entryresponse_.Clear();
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::mutable_entryresponse(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.CommitResponse.entryresponse)
  return entryresponse_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >*
CommitResponse::mutable_entryresponse() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.CommitResponse.entryresponse)
  return &entryresponse_;
}
inline const ::sync_pb::CommitResponse_EntryResponse& CommitResponse::_internal_entryresponse(int index) const {
  return entryresponse_.Get(index);
}
inline const ::sync_pb::CommitResponse_EntryResponse& CommitResponse::entryresponse(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.CommitResponse.entryresponse)
  return _internal_entryresponse(index);
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::_internal_add_entryresponse() {
  return entryresponse_.Add();
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::add_entryresponse() {
  ::sync_pb::CommitResponse_EntryResponse* _add = _internal_add_entryresponse();
  // @@protoc_insertion_point(field_add:sync_pb.CommitResponse.entryresponse)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >&
CommitResponse::entryresponse() const {
  // @@protoc_insertion_point(field_list:sync_pb.CommitResponse.entryresponse)
  return entryresponse_;
}

// -------------------------------------------------------------------

// GetUpdatesResponse

// repeated .sync_pb.SyncEntity entries = 1;
inline int GetUpdatesResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int GetUpdatesResponse::entries_size() const {
  return _internal_entries_size();
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >*
GetUpdatesResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.entries)
  return &entries_;
}
inline const ::sync_pb::SyncEntity& GetUpdatesResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::sync_pb::SyncEntity& GetUpdatesResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.entries)
  return _internal_entries(index);
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::add_entries() {
  ::sync_pb::SyncEntity* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::SyncEntity >&
GetUpdatesResponse::entries() const {
  // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.entries)
  return entries_;
}

// optional int64 changes_remaining = 4;
inline bool GetUpdatesResponse::_internal_has_changes_remaining() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetUpdatesResponse::has_changes_remaining() const {
  return _internal_has_changes_remaining();
}
inline void GetUpdatesResponse::clear_changes_remaining() {
  changes_remaining_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t GetUpdatesResponse::_internal_changes_remaining() const {
  return changes_remaining_;
}
inline int64_t GetUpdatesResponse::changes_remaining() const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.changes_remaining)
  return _internal_changes_remaining();
}
inline void GetUpdatesResponse::_internal_set_changes_remaining(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  changes_remaining_ = value;
}
inline void GetUpdatesResponse::set_changes_remaining(int64_t value) {
  _internal_set_changes_remaining(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesResponse.changes_remaining)
}

// repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
inline int GetUpdatesResponse::_internal_new_progress_marker_size() const {
  return new_progress_marker_.size();
}
inline int GetUpdatesResponse::new_progress_marker_size() const {
  return _internal_new_progress_marker_size();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::mutable_new_progress_marker(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.new_progress_marker)
  return new_progress_marker_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
GetUpdatesResponse::mutable_new_progress_marker() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.new_progress_marker)
  return &new_progress_marker_;
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesResponse::_internal_new_progress_marker(int index) const {
  return new_progress_marker_.Get(index);
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesResponse::new_progress_marker(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.new_progress_marker)
  return _internal_new_progress_marker(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::_internal_add_new_progress_marker() {
  return new_progress_marker_.Add();
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::add_new_progress_marker() {
  ::sync_pb::DataTypeProgressMarker* _add = _internal_add_new_progress_marker();
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.new_progress_marker)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
GetUpdatesResponse::new_progress_marker() const {
  // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.new_progress_marker)
  return new_progress_marker_;
}

// repeated bytes encryption_keys = 6;
inline int GetUpdatesResponse::_internal_encryption_keys_size() const {
  return encryption_keys_.size();
}
inline int GetUpdatesResponse::encryption_keys_size() const {
  return _internal_encryption_keys_size();
}
inline void GetUpdatesResponse::clear_encryption_keys() {
  encryption_keys_.Clear();
}
inline std::string* GetUpdatesResponse::add_encryption_keys() {
  std::string* _s = _internal_add_encryption_keys();
  // @@protoc_insertion_point(field_add_mutable:sync_pb.GetUpdatesResponse.encryption_keys)
  return _s;
}
inline const std::string& GetUpdatesResponse::_internal_encryption_keys(int index) const {
  return encryption_keys_.Get(index);
}
inline const std::string& GetUpdatesResponse::encryption_keys(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.encryption_keys)
  return _internal_encryption_keys(index);
}
inline std::string* GetUpdatesResponse::mutable_encryption_keys(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.encryption_keys)
  return encryption_keys_.Mutable(index);
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const std::string& value) {
  encryption_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::set_encryption_keys(int index, std::string&& value) {
  encryption_keys_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  encryption_keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const void* value, size_t size) {
  encryption_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline std::string* GetUpdatesResponse::_internal_add_encryption_keys() {
  return encryption_keys_.Add();
}
inline void GetUpdatesResponse::add_encryption_keys(const std::string& value) {
  encryption_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::add_encryption_keys(std::string&& value) {
  encryption_keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::add_encryption_keys(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  encryption_keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline void GetUpdatesResponse::add_encryption_keys(const void* value, size_t size) {
  encryption_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sync_pb.GetUpdatesResponse.encryption_keys)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetUpdatesResponse::encryption_keys() const {
  // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.encryption_keys)
  return encryption_keys_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetUpdatesResponse::mutable_encryption_keys() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.encryption_keys)
  return &encryption_keys_;
}

// repeated .sync_pb.DataTypeContext context_mutations = 7;
inline int GetUpdatesResponse::_internal_context_mutations_size() const {
  return context_mutations_.size();
}
inline int GetUpdatesResponse::context_mutations_size() const {
  return _internal_context_mutations_size();
}
inline ::sync_pb::DataTypeContext* GetUpdatesResponse::mutable_context_mutations(int index) {
  // @@protoc_insertion_point(field_mutable:sync_pb.GetUpdatesResponse.context_mutations)
  return context_mutations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >*
GetUpdatesResponse::mutable_context_mutations() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.GetUpdatesResponse.context_mutations)
  return &context_mutations_;
}
inline const ::sync_pb::DataTypeContext& GetUpdatesResponse::_internal_context_mutations(int index) const {
  return context_mutations_.Get(index);
}
inline const ::sync_pb::DataTypeContext& GetUpdatesResponse::context_mutations(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.GetUpdatesResponse.context_mutations)
  return _internal_context_mutations(index);
}
inline ::sync_pb::DataTypeContext* GetUpdatesResponse::_internal_add_context_mutations() {
  return context_mutations_.Add();
}
inline ::sync_pb::DataTypeContext* GetUpdatesResponse::add_context_mutations() {
  ::sync_pb::DataTypeContext* _add = _internal_add_context_mutations();
  // @@protoc_insertion_point(field_add:sync_pb.GetUpdatesResponse.context_mutations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sync_pb::DataTypeContext >&
GetUpdatesResponse::context_mutations() const {
  // @@protoc_insertion_point(field_list:sync_pb.GetUpdatesResponse.context_mutations)
  return context_mutations_;
}

// -------------------------------------------------------------------

// ClientToServerResponse_Error

// optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
inline bool ClientToServerResponse_Error::_internal_has_error_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientToServerResponse_Error::has_error_type() const {
  return _internal_has_error_type();
}
inline void ClientToServerResponse_Error::clear_error_type() {
  error_type_ = 100;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse_Error::_internal_error_type() const {
  return static_cast< ::sync_pb::SyncEnums_ErrorType >(error_type_);
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse_Error::error_type() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.error_type)
  return _internal_error_type();
}
inline void ClientToServerResponse_Error::_internal_set_error_type(::sync_pb::SyncEnums_ErrorType value) {
  assert(::sync_pb::SyncEnums_ErrorType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  error_type_ = value;
}
inline void ClientToServerResponse_Error::set_error_type(::sync_pb::SyncEnums_ErrorType value) {
  _internal_set_error_type(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.error_type)
}

// optional string error_description = 2;
inline bool ClientToServerResponse_Error::_internal_has_error_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientToServerResponse_Error::has_error_description() const {
  return _internal_has_error_description();
}
inline void ClientToServerResponse_Error::clear_error_description() {
  error_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientToServerResponse_Error::error_description() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.error_description)
  return _internal_error_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerResponse_Error::set_error_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_description_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.error_description)
}
inline std::string* ClientToServerResponse_Error::mutable_error_description() {
  std::string* _s = _internal_mutable_error_description();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.Error.error_description)
  return _s;
}
inline const std::string& ClientToServerResponse_Error::_internal_error_description() const {
  return error_description_.Get();
}
inline void ClientToServerResponse_Error::_internal_set_error_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_description_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerResponse_Error::_internal_mutable_error_description() {
  _has_bits_[0] |= 0x00000001u;
  return error_description_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerResponse_Error::release_error_description() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.Error.error_description)
  if (!_internal_has_error_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = error_description_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_description_.IsDefault()) {
    error_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerResponse_Error::set_allocated_error_description(std::string* error_description) {
  if (error_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_description_.SetAllocated(error_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_description_.IsDefault()) {
    error_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.Error.error_description)
}

// optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
inline bool ClientToServerResponse_Error::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ClientToServerResponse_Error::has_action() const {
  return _internal_has_action();
}
inline void ClientToServerResponse_Error::clear_action() {
  action_ = 5;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::sync_pb::SyncEnums_Action ClientToServerResponse_Error::_internal_action() const {
  return static_cast< ::sync_pb::SyncEnums_Action >(action_);
}
inline ::sync_pb::SyncEnums_Action ClientToServerResponse_Error::action() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.action)
  return _internal_action();
}
inline void ClientToServerResponse_Error::_internal_set_action(::sync_pb::SyncEnums_Action value) {
  assert(::sync_pb::SyncEnums_Action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  action_ = value;
}
inline void ClientToServerResponse_Error::set_action(::sync_pb::SyncEnums_Action value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.action)
}

// repeated int32 error_data_type_ids = 5;
inline int ClientToServerResponse_Error::_internal_error_data_type_ids_size() const {
  return error_data_type_ids_.size();
}
inline int ClientToServerResponse_Error::error_data_type_ids_size() const {
  return _internal_error_data_type_ids_size();
}
inline void ClientToServerResponse_Error::clear_error_data_type_ids() {
  error_data_type_ids_.Clear();
}
inline int32_t ClientToServerResponse_Error::_internal_error_data_type_ids(int index) const {
  return error_data_type_ids_.Get(index);
}
inline int32_t ClientToServerResponse_Error::error_data_type_ids(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
  return _internal_error_data_type_ids(index);
}
inline void ClientToServerResponse_Error::set_error_data_type_ids(int index, int32_t value) {
  error_data_type_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
}
inline void ClientToServerResponse_Error::_internal_add_error_data_type_ids(int32_t value) {
  error_data_type_ids_.Add(value);
}
inline void ClientToServerResponse_Error::add_error_data_type_ids(int32_t value) {
  _internal_add_error_data_type_ids(value);
  // @@protoc_insertion_point(field_add:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ClientToServerResponse_Error::_internal_error_data_type_ids() const {
  return error_data_type_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ClientToServerResponse_Error::error_data_type_ids() const {
  // @@protoc_insertion_point(field_list:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
  return _internal_error_data_type_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ClientToServerResponse_Error::_internal_mutable_error_data_type_ids() {
  return &error_data_type_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ClientToServerResponse_Error::mutable_error_data_type_ids() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientToServerResponse.Error.error_data_type_ids)
  return _internal_mutable_error_data_type_ids();
}

// -------------------------------------------------------------------

// ClientToServerResponse

// optional .sync_pb.CommitResponse commit = 1;
inline bool ClientToServerResponse::_internal_has_commit() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || commit_ != nullptr);
  return value;
}
inline bool ClientToServerResponse::has_commit() const {
  return _internal_has_commit();
}
inline void ClientToServerResponse::clear_commit() {
  if (commit_ != nullptr) commit_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::sync_pb::CommitResponse& ClientToServerResponse::_internal_commit() const {
  const ::sync_pb::CommitResponse* p = commit_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::CommitResponse&>(
      ::sync_pb::_CommitResponse_default_instance_);
}
inline const ::sync_pb::CommitResponse& ClientToServerResponse::commit() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.commit)
  return _internal_commit();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_commit(
    ::sync_pb::CommitResponse* commit) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(commit_);
  }
  commit_ = commit;
  if (commit) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.commit)
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::release_commit() {
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::CommitResponse* temp = commit_;
  commit_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::unsafe_arena_release_commit() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.commit)
  _has_bits_[0] &= ~0x00000004u;
  ::sync_pb::CommitResponse* temp = commit_;
  commit_ = nullptr;
  return temp;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::_internal_mutable_commit() {
  _has_bits_[0] |= 0x00000004u;
  if (commit_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::CommitResponse>(GetArenaForAllocation());
    commit_ = p;
  }
  return commit_;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::mutable_commit() {
  ::sync_pb::CommitResponse* _msg = _internal_mutable_commit();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.commit)
  return _msg;
}
inline void ClientToServerResponse::set_allocated_commit(::sync_pb::CommitResponse* commit) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete commit_;
  }
  if (commit) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(commit);
    if (message_arena != submessage_arena) {
      commit = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, commit, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  commit_ = commit;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.commit)
}

// optional .sync_pb.GetUpdatesResponse get_updates = 2;
inline bool ClientToServerResponse::_internal_has_get_updates() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || get_updates_ != nullptr);
  return value;
}
inline bool ClientToServerResponse::has_get_updates() const {
  return _internal_has_get_updates();
}
inline void ClientToServerResponse::clear_get_updates() {
  if (get_updates_ != nullptr) get_updates_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::sync_pb::GetUpdatesResponse& ClientToServerResponse::_internal_get_updates() const {
  const ::sync_pb::GetUpdatesResponse* p = get_updates_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::GetUpdatesResponse&>(
      ::sync_pb::_GetUpdatesResponse_default_instance_);
}
inline const ::sync_pb::GetUpdatesResponse& ClientToServerResponse::get_updates() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.get_updates)
  return _internal_get_updates();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_get_updates(
    ::sync_pb::GetUpdatesResponse* get_updates) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(get_updates_);
  }
  get_updates_ = get_updates;
  if (get_updates) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.get_updates)
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::release_get_updates() {
  _has_bits_[0] &= ~0x00000008u;
  ::sync_pb::GetUpdatesResponse* temp = get_updates_;
  get_updates_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::unsafe_arena_release_get_updates() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.get_updates)
  _has_bits_[0] &= ~0x00000008u;
  ::sync_pb::GetUpdatesResponse* temp = get_updates_;
  get_updates_ = nullptr;
  return temp;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::_internal_mutable_get_updates() {
  _has_bits_[0] |= 0x00000008u;
  if (get_updates_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::GetUpdatesResponse>(GetArenaForAllocation());
    get_updates_ = p;
  }
  return get_updates_;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::mutable_get_updates() {
  ::sync_pb::GetUpdatesResponse* _msg = _internal_mutable_get_updates();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.get_updates)
  return _msg;
}
inline void ClientToServerResponse::set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete get_updates_;
  }
  if (get_updates) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_updates);
    if (message_arena != submessage_arena) {
      get_updates = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_updates, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  get_updates_ = get_updates;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.get_updates)
}

// optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
inline bool ClientToServerResponse::_internal_has_error_code() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool ClientToServerResponse::has_error_code() const {
  return _internal_has_error_code();
}
inline void ClientToServerResponse::clear_error_code() {
  error_code_ = 100;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse::_internal_error_code() const {
  return static_cast< ::sync_pb::SyncEnums_ErrorType >(error_code_);
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse::error_code() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.error_code)
  return _internal_error_code();
}
inline void ClientToServerResponse::_internal_set_error_code(::sync_pb::SyncEnums_ErrorType value) {
  assert(::sync_pb::SyncEnums_ErrorType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  error_code_ = value;
}
inline void ClientToServerResponse::set_error_code(::sync_pb::SyncEnums_ErrorType value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.error_code)
}

// optional string error_message = 5;
inline bool ClientToServerResponse::_internal_has_error_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ClientToServerResponse::has_error_message() const {
  return _internal_has_error_message();
}
inline void ClientToServerResponse::clear_error_message() {
  error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ClientToServerResponse::error_message() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.error_message)
}
inline std::string* ClientToServerResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.error_message)
  return _s;
}
inline const std::string& ClientToServerResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void ClientToServerResponse::_internal_set_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_message_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::_internal_mutable_error_message() {
  _has_bits_[0] |= 0x00000001u;
  return error_message_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.error_message)
  if (!_internal_has_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = error_message_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault()) {
    error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_message_.SetAllocated(error_message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_message_.IsDefault()) {
    error_message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.error_message)
}

// optional string store_birthday = 6;
inline bool ClientToServerResponse::_internal_has_store_birthday() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ClientToServerResponse::has_store_birthday() const {
  return _internal_has_store_birthday();
}
inline void ClientToServerResponse::clear_store_birthday() {
  store_birthday_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& ClientToServerResponse::store_birthday() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.store_birthday)
  return _internal_store_birthday();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientToServerResponse::set_store_birthday(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 store_birthday_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.store_birthday)
}
inline std::string* ClientToServerResponse::mutable_store_birthday() {
  std::string* _s = _internal_mutable_store_birthday();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.store_birthday)
  return _s;
}
inline const std::string& ClientToServerResponse::_internal_store_birthday() const {
  return store_birthday_.Get();
}
inline void ClientToServerResponse::_internal_set_store_birthday(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  store_birthday_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::_internal_mutable_store_birthday() {
  _has_bits_[0] |= 0x00000002u;
  return store_birthday_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientToServerResponse::release_store_birthday() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.store_birthday)
  if (!_internal_has_store_birthday()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = store_birthday_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_birthday_.IsDefault()) {
    store_birthday_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ClientToServerResponse::set_allocated_store_birthday(std::string* store_birthday) {
  if (store_birthday != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_birthday_.SetAllocated(store_birthday, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_birthday_.IsDefault()) {
    store_birthday_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.store_birthday)
}

// optional .sync_pb.ClientCommand client_command = 7;
inline bool ClientToServerResponse::_internal_has_client_command() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || client_command_ != nullptr);
  return value;
}
inline bool ClientToServerResponse::has_client_command() const {
  return _internal_has_client_command();
}
inline const ::sync_pb::ClientCommand& ClientToServerResponse::_internal_client_command() const {
  const ::sync_pb::ClientCommand* p = client_command_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientCommand&>(
      ::sync_pb::_ClientCommand_default_instance_);
}
inline const ::sync_pb::ClientCommand& ClientToServerResponse::client_command() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.client_command)
  return _internal_client_command();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_client_command(
    ::sync_pb::ClientCommand* client_command) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_command_);
  }
  client_command_ = client_command;
  if (client_command) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.client_command)
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::release_client_command() {
  _has_bits_[0] &= ~0x00000010u;
  ::sync_pb::ClientCommand* temp = client_command_;
  client_command_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::unsafe_arena_release_client_command() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.client_command)
  _has_bits_[0] &= ~0x00000010u;
  ::sync_pb::ClientCommand* temp = client_command_;
  client_command_ = nullptr;
  return temp;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::_internal_mutable_client_command() {
  _has_bits_[0] |= 0x00000010u;
  if (client_command_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ClientCommand>(GetArenaForAllocation());
    client_command_ = p;
  }
  return client_command_;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::mutable_client_command() {
  ::sync_pb::ClientCommand* _msg = _internal_mutable_client_command();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.client_command)
  return _msg;
}
inline void ClientToServerResponse::set_allocated_client_command(::sync_pb::ClientCommand* client_command) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_command_);
  }
  if (client_command) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(client_command));
    if (message_arena != submessage_arena) {
      client_command = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_command, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  client_command_ = client_command;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.client_command)
}

// repeated int32 migrated_data_type_id = 12;
inline int ClientToServerResponse::_internal_migrated_data_type_id_size() const {
  return migrated_data_type_id_.size();
}
inline int ClientToServerResponse::migrated_data_type_id_size() const {
  return _internal_migrated_data_type_id_size();
}
inline void ClientToServerResponse::clear_migrated_data_type_id() {
  migrated_data_type_id_.Clear();
}
inline int32_t ClientToServerResponse::_internal_migrated_data_type_id(int index) const {
  return migrated_data_type_id_.Get(index);
}
inline int32_t ClientToServerResponse::migrated_data_type_id(int index) const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.migrated_data_type_id)
  return _internal_migrated_data_type_id(index);
}
inline void ClientToServerResponse::set_migrated_data_type_id(int index, int32_t value) {
  migrated_data_type_id_.Set(index, value);
  // @@protoc_insertion_point(field_set:sync_pb.ClientToServerResponse.migrated_data_type_id)
}
inline void ClientToServerResponse::_internal_add_migrated_data_type_id(int32_t value) {
  migrated_data_type_id_.Add(value);
}
inline void ClientToServerResponse::add_migrated_data_type_id(int32_t value) {
  _internal_add_migrated_data_type_id(value);
  // @@protoc_insertion_point(field_add:sync_pb.ClientToServerResponse.migrated_data_type_id)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ClientToServerResponse::_internal_migrated_data_type_id() const {
  return migrated_data_type_id_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
ClientToServerResponse::migrated_data_type_id() const {
  // @@protoc_insertion_point(field_list:sync_pb.ClientToServerResponse.migrated_data_type_id)
  return _internal_migrated_data_type_id();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ClientToServerResponse::_internal_mutable_migrated_data_type_id() {
  return &migrated_data_type_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
ClientToServerResponse::mutable_migrated_data_type_id() {
  // @@protoc_insertion_point(field_mutable_list:sync_pb.ClientToServerResponse.migrated_data_type_id)
  return _internal_mutable_migrated_data_type_id();
}

// optional .sync_pb.ClientToServerResponse.Error error = 13;
inline bool ClientToServerResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || error_ != nullptr);
  return value;
}
inline bool ClientToServerResponse::has_error() const {
  return _internal_has_error();
}
inline void ClientToServerResponse::clear_error() {
  if (error_ != nullptr) error_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::sync_pb::ClientToServerResponse_Error& ClientToServerResponse::_internal_error() const {
  const ::sync_pb::ClientToServerResponse_Error* p = error_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClientToServerResponse_Error&>(
      ::sync_pb::_ClientToServerResponse_Error_default_instance_);
}
inline const ::sync_pb::ClientToServerResponse_Error& ClientToServerResponse::error() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.error)
  return _internal_error();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_error(
    ::sync_pb::ClientToServerResponse_Error* error) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(error_);
  }
  error_ = error;
  if (error) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.error)
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::release_error() {
  _has_bits_[0] &= ~0x00000020u;
  ::sync_pb::ClientToServerResponse_Error* temp = error_;
  error_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::unsafe_arena_release_error() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.error)
  _has_bits_[0] &= ~0x00000020u;
  ::sync_pb::ClientToServerResponse_Error* temp = error_;
  error_ = nullptr;
  return temp;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000020u;
  if (error_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ClientToServerResponse_Error>(GetArenaForAllocation());
    error_ = p;
  }
  return error_;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::mutable_error() {
  ::sync_pb::ClientToServerResponse_Error* _msg = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.error)
  return _msg;
}
inline void ClientToServerResponse::set_allocated_error(::sync_pb::ClientToServerResponse_Error* error) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete error_;
  }
  if (error) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(error);
    if (message_arena != submessage_arena) {
      error = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, error, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  error_ = error;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.error)
}

// optional .sync_pb.ChipBag new_bag_of_chips = 14;
inline bool ClientToServerResponse::_internal_has_new_bag_of_chips() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || new_bag_of_chips_ != nullptr);
  return value;
}
inline bool ClientToServerResponse::has_new_bag_of_chips() const {
  return _internal_has_new_bag_of_chips();
}
inline void ClientToServerResponse::clear_new_bag_of_chips() {
  if (new_bag_of_chips_ != nullptr) new_bag_of_chips_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::sync_pb::ChipBag& ClientToServerResponse::_internal_new_bag_of_chips() const {
  const ::sync_pb::ChipBag* p = new_bag_of_chips_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ChipBag&>(
      ::sync_pb::_ChipBag_default_instance_);
}
inline const ::sync_pb::ChipBag& ClientToServerResponse::new_bag_of_chips() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.new_bag_of_chips)
  return _internal_new_bag_of_chips();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_new_bag_of_chips(
    ::sync_pb::ChipBag* new_bag_of_chips) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(new_bag_of_chips_);
  }
  new_bag_of_chips_ = new_bag_of_chips;
  if (new_bag_of_chips) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.new_bag_of_chips)
}
inline ::sync_pb::ChipBag* ClientToServerResponse::release_new_bag_of_chips() {
  _has_bits_[0] &= ~0x00000040u;
  ::sync_pb::ChipBag* temp = new_bag_of_chips_;
  new_bag_of_chips_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::unsafe_arena_release_new_bag_of_chips() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.new_bag_of_chips)
  _has_bits_[0] &= ~0x00000040u;
  ::sync_pb::ChipBag* temp = new_bag_of_chips_;
  new_bag_of_chips_ = nullptr;
  return temp;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::_internal_mutable_new_bag_of_chips() {
  _has_bits_[0] |= 0x00000040u;
  if (new_bag_of_chips_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ChipBag>(GetArenaForAllocation());
    new_bag_of_chips_ = p;
  }
  return new_bag_of_chips_;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::mutable_new_bag_of_chips() {
  ::sync_pb::ChipBag* _msg = _internal_mutable_new_bag_of_chips();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.new_bag_of_chips)
  return _msg;
}
inline void ClientToServerResponse::set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete new_bag_of_chips_;
  }
  if (new_bag_of_chips) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(new_bag_of_chips);
    if (message_arena != submessage_arena) {
      new_bag_of_chips = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, new_bag_of_chips, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  new_bag_of_chips_ = new_bag_of_chips;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.new_bag_of_chips)
}

// optional .sync_pb.ClearServerDataResponse clear_server_data = 15;
inline bool ClientToServerResponse::_internal_has_clear_server_data() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || clear_server_data_ != nullptr);
  return value;
}
inline bool ClientToServerResponse::has_clear_server_data() const {
  return _internal_has_clear_server_data();
}
inline void ClientToServerResponse::clear_clear_server_data() {
  if (clear_server_data_ != nullptr) clear_server_data_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::sync_pb::ClearServerDataResponse& ClientToServerResponse::_internal_clear_server_data() const {
  const ::sync_pb::ClearServerDataResponse* p = clear_server_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::ClearServerDataResponse&>(
      ::sync_pb::_ClearServerDataResponse_default_instance_);
}
inline const ::sync_pb::ClearServerDataResponse& ClientToServerResponse::clear_server_data() const {
  // @@protoc_insertion_point(field_get:sync_pb.ClientToServerResponse.clear_server_data)
  return _internal_clear_server_data();
}
inline void ClientToServerResponse::unsafe_arena_set_allocated_clear_server_data(
    ::sync_pb::ClearServerDataResponse* clear_server_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(clear_server_data_);
  }
  clear_server_data_ = clear_server_data;
  if (clear_server_data) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.ClientToServerResponse.clear_server_data)
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::release_clear_server_data() {
  _has_bits_[0] &= ~0x00000080u;
  ::sync_pb::ClearServerDataResponse* temp = clear_server_data_;
  clear_server_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::unsafe_arena_release_clear_server_data() {
  // @@protoc_insertion_point(field_release:sync_pb.ClientToServerResponse.clear_server_data)
  _has_bits_[0] &= ~0x00000080u;
  ::sync_pb::ClearServerDataResponse* temp = clear_server_data_;
  clear_server_data_ = nullptr;
  return temp;
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::_internal_mutable_clear_server_data() {
  _has_bits_[0] |= 0x00000080u;
  if (clear_server_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::ClearServerDataResponse>(GetArenaForAllocation());
    clear_server_data_ = p;
  }
  return clear_server_data_;
}
inline ::sync_pb::ClearServerDataResponse* ClientToServerResponse::mutable_clear_server_data() {
  ::sync_pb::ClearServerDataResponse* _msg = _internal_mutable_clear_server_data();
  // @@protoc_insertion_point(field_mutable:sync_pb.ClientToServerResponse.clear_server_data)
  return _msg;
}
inline void ClientToServerResponse::set_allocated_clear_server_data(::sync_pb::ClearServerDataResponse* clear_server_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete clear_server_data_;
  }
  if (clear_server_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(clear_server_data);
    if (message_arena != submessage_arena) {
      clear_server_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, clear_server_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  clear_server_data_ = clear_server_data;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.ClientToServerResponse.clear_server_data)
}

// -------------------------------------------------------------------

// EventRequest

// optional .sync_pb.SyncDisabledEvent sync_disabled = 1;
inline bool EventRequest::_internal_has_sync_disabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || sync_disabled_ != nullptr);
  return value;
}
inline bool EventRequest::has_sync_disabled() const {
  return _internal_has_sync_disabled();
}
inline void EventRequest::clear_sync_disabled() {
  if (sync_disabled_ != nullptr) sync_disabled_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::sync_pb::SyncDisabledEvent& EventRequest::_internal_sync_disabled() const {
  const ::sync_pb::SyncDisabledEvent* p = sync_disabled_;
  return p != nullptr ? *p : reinterpret_cast<const ::sync_pb::SyncDisabledEvent&>(
      ::sync_pb::_SyncDisabledEvent_default_instance_);
}
inline const ::sync_pb::SyncDisabledEvent& EventRequest::sync_disabled() const {
  // @@protoc_insertion_point(field_get:sync_pb.EventRequest.sync_disabled)
  return _internal_sync_disabled();
}
inline void EventRequest::unsafe_arena_set_allocated_sync_disabled(
    ::sync_pb::SyncDisabledEvent* sync_disabled) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(sync_disabled_);
  }
  sync_disabled_ = sync_disabled;
  if (sync_disabled) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sync_pb.EventRequest.sync_disabled)
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::release_sync_disabled() {
  _has_bits_[0] &= ~0x00000001u;
  ::sync_pb::SyncDisabledEvent* temp = sync_disabled_;
  sync_disabled_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::unsafe_arena_release_sync_disabled() {
  // @@protoc_insertion_point(field_release:sync_pb.EventRequest.sync_disabled)
  _has_bits_[0] &= ~0x00000001u;
  ::sync_pb::SyncDisabledEvent* temp = sync_disabled_;
  sync_disabled_ = nullptr;
  return temp;
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::_internal_mutable_sync_disabled() {
  _has_bits_[0] |= 0x00000001u;
  if (sync_disabled_ == nullptr) {
    auto* p = CreateMaybeMessage<::sync_pb::SyncDisabledEvent>(GetArenaForAllocation());
    sync_disabled_ = p;
  }
  return sync_disabled_;
}
inline ::sync_pb::SyncDisabledEvent* EventRequest::mutable_sync_disabled() {
  ::sync_pb::SyncDisabledEvent* _msg = _internal_mutable_sync_disabled();
  // @@protoc_insertion_point(field_mutable:sync_pb.EventRequest.sync_disabled)
  return _msg;
}
inline void EventRequest::set_allocated_sync_disabled(::sync_pb::SyncDisabledEvent* sync_disabled) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete sync_disabled_;
  }
  if (sync_disabled) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sync_disabled);
    if (message_arena != submessage_arena) {
      sync_disabled = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sync_disabled, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sync_disabled_ = sync_disabled;
  // @@protoc_insertion_point(field_set_allocated:sync_pb.EventRequest.sync_disabled)
}

// -------------------------------------------------------------------

// EventResponse

// -------------------------------------------------------------------

// SyncDisabledEvent

// optional string cache_guid = 1;
inline bool SyncDisabledEvent::_internal_has_cache_guid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SyncDisabledEvent::has_cache_guid() const {
  return _internal_has_cache_guid();
}
inline void SyncDisabledEvent::clear_cache_guid() {
  cache_guid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SyncDisabledEvent::cache_guid() const {
  // @@protoc_insertion_point(field_get:sync_pb.SyncDisabledEvent.cache_guid)
  return _internal_cache_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncDisabledEvent::set_cache_guid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 cache_guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SyncDisabledEvent.cache_guid)
}
inline std::string* SyncDisabledEvent::mutable_cache_guid() {
  std::string* _s = _internal_mutable_cache_guid();
  // @@protoc_insertion_point(field_mutable:sync_pb.SyncDisabledEvent.cache_guid)
  return _s;
}
inline const std::string& SyncDisabledEvent::_internal_cache_guid() const {
  return cache_guid_.Get();
}
inline void SyncDisabledEvent::_internal_set_cache_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  cache_guid_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::_internal_mutable_cache_guid() {
  _has_bits_[0] |= 0x00000001u;
  return cache_guid_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::release_cache_guid() {
  // @@protoc_insertion_point(field_release:sync_pb.SyncDisabledEvent.cache_guid)
  if (!_internal_has_cache_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = cache_guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_guid_.IsDefault()) {
    cache_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncDisabledEvent::set_allocated_cache_guid(std::string* cache_guid) {
  if (cache_guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cache_guid_.SetAllocated(cache_guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cache_guid_.IsDefault()) {
    cache_guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SyncDisabledEvent.cache_guid)
}

// optional string store_birthday = 2;
inline bool SyncDisabledEvent::_internal_has_store_birthday() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SyncDisabledEvent::has_store_birthday() const {
  return _internal_has_store_birthday();
}
inline void SyncDisabledEvent::clear_store_birthday() {
  store_birthday_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SyncDisabledEvent::store_birthday() const {
  // @@protoc_insertion_point(field_get:sync_pb.SyncDisabledEvent.store_birthday)
  return _internal_store_birthday();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SyncDisabledEvent::set_store_birthday(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 store_birthday_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sync_pb.SyncDisabledEvent.store_birthday)
}
inline std::string* SyncDisabledEvent::mutable_store_birthday() {
  std::string* _s = _internal_mutable_store_birthday();
  // @@protoc_insertion_point(field_mutable:sync_pb.SyncDisabledEvent.store_birthday)
  return _s;
}
inline const std::string& SyncDisabledEvent::_internal_store_birthday() const {
  return store_birthday_.Get();
}
inline void SyncDisabledEvent::_internal_set_store_birthday(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  store_birthday_.Set(value, GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::_internal_mutable_store_birthday() {
  _has_bits_[0] |= 0x00000002u;
  return store_birthday_.Mutable(GetArenaForAllocation());
}
inline std::string* SyncDisabledEvent::release_store_birthday() {
  // @@protoc_insertion_point(field_release:sync_pb.SyncDisabledEvent.store_birthday)
  if (!_internal_has_store_birthday()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = store_birthday_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_birthday_.IsDefault()) {
    store_birthday_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SyncDisabledEvent::set_allocated_store_birthday(std::string* store_birthday) {
  if (store_birthday != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_birthday_.SetAllocated(store_birthday, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_birthday_.IsDefault()) {
    store_birthday_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sync_pb.SyncDisabledEvent.store_birthday)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sync_pb::ClientToServerMessage_Contents> : ::std::true_type {};
template <> struct is_proto_enum< ::sync_pb::CommitResponse_ResponseType> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fsync_2fprotocol_2fsync_2eproto
