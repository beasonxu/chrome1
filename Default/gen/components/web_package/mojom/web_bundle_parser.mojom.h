// components/web_package/mojom/web_bundle_parser.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_H_
#define COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/web_package/mojom/web_bundle_parser.mojom-shared.h"
#include "components/web_package/mojom/web_bundle_parser.mojom-forward.h"
#include "mojo/public/mojom/base/read_only_file.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"






namespace web_package {
namespace mojom {

class WebBundleParserFactoryProxy;

template <typename ImplRefTraits>
class WebBundleParserFactoryStub;

class WebBundleParserFactoryRequestValidator;


class  WebBundleParserFactory
    : public WebBundleParserFactoryInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = WebBundleParserFactoryInterfaceBase;
  using Proxy_ = WebBundleParserFactoryProxy;

  template <typename ImplRefTraits>
  using Stub_ = WebBundleParserFactoryStub<ImplRefTraits>;

  using RequestValidator_ = WebBundleParserFactoryRequestValidator;
  using ResponseValidator_ = mojo::PassThroughFilter;
  enum MethodMinVersions : uint32_t {
    kGetParserForFileMinVersion = 0,
    kGetParserForDataSourceMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct GetParserForFile_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetParserForDataSource_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~WebBundleParserFactory() = default;

  
  virtual void GetParserForFile(::mojo::PendingReceiver<WebBundleParser> receiver, ::base::File file) = 0;

  
  virtual void GetParserForDataSource(::mojo::PendingReceiver<WebBundleParser> receiver, ::mojo::PendingRemote<BundleDataSource> data_source) = 0;
};

class WebBundleParserProxy;

template <typename ImplRefTraits>
class WebBundleParserStub;

class WebBundleParserRequestValidator;
class WebBundleParserResponseValidator;


class  WebBundleParser
    : public WebBundleParserInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = WebBundleParserInterfaceBase;
  using Proxy_ = WebBundleParserProxy;

  template <typename ImplRefTraits>
  using Stub_ = WebBundleParserStub<ImplRefTraits>;

  using RequestValidator_ = WebBundleParserRequestValidator;
  using ResponseValidator_ = WebBundleParserResponseValidator;
  enum MethodMinVersions : uint32_t {
    kParseIntegrityBlockMinVersion = 0,
    kParseMetadataMinVersion = 0,
    kParseResponseMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct ParseIntegrityBlock_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ParseMetadata_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct ParseResponse_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~WebBundleParser() = default;


  using ParseIntegrityBlockCallback = base::OnceCallback<void(BundleIntegrityBlockPtr, BundleIntegrityBlockParseErrorPtr)>;
  
  virtual void ParseIntegrityBlock(ParseIntegrityBlockCallback callback) = 0;


  using ParseMetadataCallback = base::OnceCallback<void(BundleMetadataPtr, BundleMetadataParseErrorPtr)>;
  
  virtual void ParseMetadata(int64_t offset, ParseMetadataCallback callback) = 0;


  using ParseResponseCallback = base::OnceCallback<void(BundleResponsePtr, BundleResponseParseErrorPtr)>;
  
  virtual void ParseResponse(uint64_t response_offset, uint64_t response_length, ParseResponseCallback callback) = 0;
};

class BundleDataSourceProxy;

template <typename ImplRefTraits>
class BundleDataSourceStub;

class BundleDataSourceRequestValidator;
class BundleDataSourceResponseValidator;


class  BundleDataSource
    : public BundleDataSourceInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = BundleDataSourceInterfaceBase;
  using Proxy_ = BundleDataSourceProxy;

  template <typename ImplRefTraits>
  using Stub_ = BundleDataSourceStub<ImplRefTraits>;

  using RequestValidator_ = BundleDataSourceRequestValidator;
  using ResponseValidator_ = BundleDataSourceResponseValidator;
  enum MethodMinVersions : uint32_t {
    kReadMinVersion = 0,
    kLengthMinVersion = 0,
    kIsRandomAccessContextMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct Read_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct Length_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct IsRandomAccessContext_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~BundleDataSource() = default;


  using ReadCallback = base::OnceCallback<void(const absl::optional<std::vector<uint8_t>>&)>;
  
  virtual void Read(uint64_t offset, uint64_t length, ReadCallback callback) = 0;


  using LengthCallback = base::OnceCallback<void(int64_t)>;
  
  virtual void Length(LengthCallback callback) = 0;


  using IsRandomAccessContextCallback = base::OnceCallback<void(bool)>;
  
  virtual void IsRandomAccessContext(IsRandomAccessContextCallback callback) = 0;
};



class  WebBundleParserFactoryProxy
    : public WebBundleParserFactory {
 public:
  using InterfaceType = WebBundleParserFactory;

  explicit WebBundleParserFactoryProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void GetParserForFile(::mojo::PendingReceiver<WebBundleParser> receiver, ::base::File file) final;
  
  void GetParserForDataSource(::mojo::PendingReceiver<WebBundleParser> receiver, ::mojo::PendingRemote<BundleDataSource> data_source) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  WebBundleParserProxy
    : public WebBundleParser {
 public:
  using InterfaceType = WebBundleParser;

  explicit WebBundleParserProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void ParseIntegrityBlock(ParseIntegrityBlockCallback callback) final;
  
  void ParseMetadata(int64_t offset, ParseMetadataCallback callback) final;
  
  void ParseResponse(uint64_t response_offset, uint64_t response_length, ParseResponseCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  BundleDataSourceProxy
    : public BundleDataSource {
 public:
  using InterfaceType = BundleDataSource;

  explicit BundleDataSourceProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void Read(uint64_t offset, uint64_t length, ReadCallback callback) final;
  
  void Length(LengthCallback callback) final;
  
  void IsRandomAccessContext(IsRandomAccessContextCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  WebBundleParserFactoryStubDispatch {
 public:
  static bool Accept(WebBundleParserFactory* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      WebBundleParserFactory* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<WebBundleParserFactory>>
class WebBundleParserFactoryStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WebBundleParserFactoryStub() = default;
  ~WebBundleParserFactoryStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WebBundleParserFactoryStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WebBundleParserFactoryStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  WebBundleParserStubDispatch {
 public:
  static bool Accept(WebBundleParser* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      WebBundleParser* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<WebBundleParser>>
class WebBundleParserStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  WebBundleParserStub() = default;
  ~WebBundleParserStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WebBundleParserStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return WebBundleParserStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  BundleDataSourceStubDispatch {
 public:
  static bool Accept(BundleDataSource* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      BundleDataSource* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<BundleDataSource>>
class BundleDataSourceStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  BundleDataSourceStub() = default;
  ~BundleDataSourceStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return BundleDataSourceStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return BundleDataSourceStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  WebBundleParserFactoryRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  WebBundleParserRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  BundleDataSourceRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  WebBundleParserResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  BundleDataSourceResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};





class  BundleIntegrityBlockParseError {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleIntegrityBlockParseError, T>::value>;
  using DataView = BundleIntegrityBlockParseErrorDataView;
  using Data_ = internal::BundleIntegrityBlockParseError_Data;

  template <typename... Args>
  static BundleIntegrityBlockParseErrorPtr New(Args&&... args) {
    return BundleIntegrityBlockParseErrorPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleIntegrityBlockParseErrorPtr From(const U& u) {
    return mojo::TypeConverter<BundleIntegrityBlockParseErrorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleIntegrityBlockParseError>::Convert(*this);
  }


  BundleIntegrityBlockParseError();

  BundleIntegrityBlockParseError(
      BundleParseErrorType type,
      const std::string& message);


  ~BundleIntegrityBlockParseError();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleIntegrityBlockParseErrorPtr>
  BundleIntegrityBlockParseErrorPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleIntegrityBlockParseError::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleIntegrityBlockParseError::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleIntegrityBlockParseError_UnserializedMessageContext<
            UserType, BundleIntegrityBlockParseError::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleIntegrityBlockParseError::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleIntegrityBlockParseError::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleIntegrityBlockParseError_UnserializedMessageContext<
            UserType, BundleIntegrityBlockParseError::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleIntegrityBlockParseError::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  BundleParseErrorType type;
  
  std::string message;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BundleMetadataParseError {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleMetadataParseError, T>::value>;
  using DataView = BundleMetadataParseErrorDataView;
  using Data_ = internal::BundleMetadataParseError_Data;

  template <typename... Args>
  static BundleMetadataParseErrorPtr New(Args&&... args) {
    return BundleMetadataParseErrorPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleMetadataParseErrorPtr From(const U& u) {
    return mojo::TypeConverter<BundleMetadataParseErrorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleMetadataParseError>::Convert(*this);
  }


  BundleMetadataParseError();

  BundleMetadataParseError(
      BundleParseErrorType type,
      const std::string& message);


  ~BundleMetadataParseError();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleMetadataParseErrorPtr>
  BundleMetadataParseErrorPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleMetadataParseError::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleMetadataParseError::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleMetadataParseError::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleMetadataParseError::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleMetadataParseError_UnserializedMessageContext<
            UserType, BundleMetadataParseError::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleMetadataParseError::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleMetadataParseError::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleMetadataParseError_UnserializedMessageContext<
            UserType, BundleMetadataParseError::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleMetadataParseError::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  BundleParseErrorType type;
  
  std::string message;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleMetadataParseError::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleMetadataParseError::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleMetadataParseError::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleMetadataParseError::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BundleResponseParseError {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleResponseParseError, T>::value>;
  using DataView = BundleResponseParseErrorDataView;
  using Data_ = internal::BundleResponseParseError_Data;

  template <typename... Args>
  static BundleResponseParseErrorPtr New(Args&&... args) {
    return BundleResponseParseErrorPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleResponseParseErrorPtr From(const U& u) {
    return mojo::TypeConverter<BundleResponseParseErrorPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleResponseParseError>::Convert(*this);
  }


  BundleResponseParseError();

  BundleResponseParseError(
      BundleParseErrorType type,
      const std::string& message);


  ~BundleResponseParseError();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleResponseParseErrorPtr>
  BundleResponseParseErrorPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleResponseParseError::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleResponseParseError::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleResponseParseError::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleResponseParseError::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleResponseParseError_UnserializedMessageContext<
            UserType, BundleResponseParseError::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleResponseParseError::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleResponseParseError::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleResponseParseError_UnserializedMessageContext<
            UserType, BundleResponseParseError::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleResponseParseError::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  BundleParseErrorType type;
  
  std::string message;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleResponseParseError::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleResponseParseError::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleResponseParseError::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleResponseParseError::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}








class  BundleResponseLocation {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleResponseLocation, T>::value>;
  using DataView = BundleResponseLocationDataView;
  using Data_ = internal::BundleResponseLocation_Data;

  template <typename... Args>
  static BundleResponseLocationPtr New(Args&&... args) {
    return BundleResponseLocationPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleResponseLocationPtr From(const U& u) {
    return mojo::TypeConverter<BundleResponseLocationPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleResponseLocation>::Convert(*this);
  }


  BundleResponseLocation();

  BundleResponseLocation(
      uint64_t offset,
      uint64_t length);


  ~BundleResponseLocation();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleResponseLocationPtr>
  BundleResponseLocationPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleResponseLocation::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleResponseLocation::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleResponseLocation::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleResponseLocation::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleResponseLocation_UnserializedMessageContext<
            UserType, BundleResponseLocation::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleResponseLocation::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleResponseLocation::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleResponseLocation_UnserializedMessageContext<
            UserType, BundleResponseLocation::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleResponseLocation::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t offset;
  
  uint64_t length;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleResponseLocation::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleResponseLocation::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleResponseLocation::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleResponseLocation::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}
















class  BundleIntegrityBlock {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleIntegrityBlock, T>::value>;
  using DataView = BundleIntegrityBlockDataView;
  using Data_ = internal::BundleIntegrityBlock_Data;

  template <typename... Args>
  static BundleIntegrityBlockPtr New(Args&&... args) {
    return BundleIntegrityBlockPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleIntegrityBlockPtr From(const U& u) {
    return mojo::TypeConverter<BundleIntegrityBlockPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleIntegrityBlock>::Convert(*this);
  }


  BundleIntegrityBlock();

  BundleIntegrityBlock(
      uint64_t size,
      std::vector<BundleIntegrityBlockSignatureStackEntryPtr> signature_stack);

BundleIntegrityBlock(const BundleIntegrityBlock&) = delete;
BundleIntegrityBlock& operator=(const BundleIntegrityBlock&) = delete;

  ~BundleIntegrityBlock();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleIntegrityBlockPtr>
  BundleIntegrityBlockPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleIntegrityBlock::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleIntegrityBlock::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleIntegrityBlock::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleIntegrityBlock::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleIntegrityBlock_UnserializedMessageContext<
            UserType, BundleIntegrityBlock::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleIntegrityBlock::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleIntegrityBlock::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleIntegrityBlock_UnserializedMessageContext<
            UserType, BundleIntegrityBlock::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleIntegrityBlock::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t size;
  
  std::vector<BundleIntegrityBlockSignatureStackEntryPtr> signature_stack;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleIntegrityBlock::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleIntegrityBlock::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleIntegrityBlock::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleIntegrityBlock::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BundleIntegrityBlockSignatureStackEntry {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleIntegrityBlockSignatureStackEntry, T>::value>;
  using DataView = BundleIntegrityBlockSignatureStackEntryDataView;
  using Data_ = internal::BundleIntegrityBlockSignatureStackEntry_Data;

  template <typename... Args>
  static BundleIntegrityBlockSignatureStackEntryPtr New(Args&&... args) {
    return BundleIntegrityBlockSignatureStackEntryPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleIntegrityBlockSignatureStackEntryPtr From(const U& u) {
    return mojo::TypeConverter<BundleIntegrityBlockSignatureStackEntryPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleIntegrityBlockSignatureStackEntry>::Convert(*this);
  }


  BundleIntegrityBlockSignatureStackEntry();

  BundleIntegrityBlockSignatureStackEntry(
      std::vector<uint8_t> complete_entry_cbor,
      std::vector<uint8_t> attributes_cbor,
      std::vector<uint8_t> public_key,
      std::vector<uint8_t> signature);


  ~BundleIntegrityBlockSignatureStackEntry();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleIntegrityBlockSignatureStackEntryPtr>
  BundleIntegrityBlockSignatureStackEntryPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleIntegrityBlockSignatureStackEntry::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleIntegrityBlockSignatureStackEntry::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleIntegrityBlockSignatureStackEntry_UnserializedMessageContext<
            UserType, BundleIntegrityBlockSignatureStackEntry::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleIntegrityBlockSignatureStackEntry::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleIntegrityBlockSignatureStackEntry::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleIntegrityBlockSignatureStackEntry_UnserializedMessageContext<
            UserType, BundleIntegrityBlockSignatureStackEntry::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleIntegrityBlockSignatureStackEntry::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<uint8_t> complete_entry_cbor;
  
  std::vector<uint8_t> attributes_cbor;
  
  std::vector<uint8_t> public_key;
  
  std::vector<uint8_t> signature;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BundleMetadata {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleMetadata, T>::value>;
  using DataView = BundleMetadataDataView;
  using Data_ = internal::BundleMetadata_Data;

  template <typename... Args>
  static BundleMetadataPtr New(Args&&... args) {
    return BundleMetadataPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleMetadataPtr From(const U& u) {
    return mojo::TypeConverter<BundleMetadataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleMetadata>::Convert(*this);
  }


  BundleMetadata();

  BundleMetadata(
      BundleFormatVersion version,
      const ::GURL& primary_url,
      base::flat_map<::GURL, BundleResponseLocationPtr> requests,
      std::vector<AugmentedCertificatePtr> authorities,
      std::vector<VouchedSubsetPtr> vouched_subsets);

BundleMetadata(const BundleMetadata&) = delete;
BundleMetadata& operator=(const BundleMetadata&) = delete;

  ~BundleMetadata();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleMetadataPtr>
  BundleMetadataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleMetadata::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleMetadata::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleMetadata::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleMetadata::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleMetadata_UnserializedMessageContext<
            UserType, BundleMetadata::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleMetadata::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleMetadata::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleMetadata_UnserializedMessageContext<
            UserType, BundleMetadata::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleMetadata::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  BundleFormatVersion version;
  
  ::GURL primary_url;
  
  base::flat_map<::GURL, BundleResponseLocationPtr> requests;
  
  std::vector<AugmentedCertificatePtr> authorities;
  
  std::vector<VouchedSubsetPtr> vouched_subsets;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleMetadata::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleMetadata::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleMetadata::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleMetadata::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  AugmentedCertificate {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<AugmentedCertificate, T>::value>;
  using DataView = AugmentedCertificateDataView;
  using Data_ = internal::AugmentedCertificate_Data;

  template <typename... Args>
  static AugmentedCertificatePtr New(Args&&... args) {
    return AugmentedCertificatePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static AugmentedCertificatePtr From(const U& u) {
    return mojo::TypeConverter<AugmentedCertificatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, AugmentedCertificate>::Convert(*this);
  }


  AugmentedCertificate();

  AugmentedCertificate(
      std::vector<uint8_t> cert,
      absl::optional<std::vector<uint8_t>> ocsp,
      absl::optional<std::vector<uint8_t>> sct);


  ~AugmentedCertificate();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = AugmentedCertificatePtr>
  AugmentedCertificatePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, AugmentedCertificate::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, AugmentedCertificate::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        AugmentedCertificate::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        AugmentedCertificate::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::AugmentedCertificate_UnserializedMessageContext<
            UserType, AugmentedCertificate::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<AugmentedCertificate::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return AugmentedCertificate::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::AugmentedCertificate_UnserializedMessageContext<
            UserType, AugmentedCertificate::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<AugmentedCertificate::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<uint8_t> cert;
  
  absl::optional<std::vector<uint8_t>> ocsp;
  
  absl::optional<std::vector<uint8_t>> sct;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, AugmentedCertificate::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, AugmentedCertificate::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, AugmentedCertificate::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, AugmentedCertificate::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  VouchedSubset {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<VouchedSubset, T>::value>;
  using DataView = VouchedSubsetDataView;
  using Data_ = internal::VouchedSubset_Data;

  template <typename... Args>
  static VouchedSubsetPtr New(Args&&... args) {
    return VouchedSubsetPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static VouchedSubsetPtr From(const U& u) {
    return mojo::TypeConverter<VouchedSubsetPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, VouchedSubset>::Convert(*this);
  }


  VouchedSubset();

  VouchedSubset(
      uint64_t authority,
      std::vector<uint8_t> sig,
      std::vector<uint8_t> raw_signed,
      SignedSubsetPtr parsed_signed);

VouchedSubset(const VouchedSubset&) = delete;
VouchedSubset& operator=(const VouchedSubset&) = delete;

  ~VouchedSubset();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = VouchedSubsetPtr>
  VouchedSubsetPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, VouchedSubset::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, VouchedSubset::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        VouchedSubset::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        VouchedSubset::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::VouchedSubset_UnserializedMessageContext<
            UserType, VouchedSubset::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<VouchedSubset::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return VouchedSubset::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::VouchedSubset_UnserializedMessageContext<
            UserType, VouchedSubset::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<VouchedSubset::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  uint64_t authority;
  
  std::vector<uint8_t> sig;
  
  std::vector<uint8_t> raw_signed;
  
  SignedSubsetPtr parsed_signed;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, VouchedSubset::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, VouchedSubset::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, VouchedSubset::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, VouchedSubset::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  SignedSubset {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SignedSubset, T>::value>;
  using DataView = SignedSubsetDataView;
  using Data_ = internal::SignedSubset_Data;

  template <typename... Args>
  static SignedSubsetPtr New(Args&&... args) {
    return SignedSubsetPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SignedSubsetPtr From(const U& u) {
    return mojo::TypeConverter<SignedSubsetPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SignedSubset>::Convert(*this);
  }


  SignedSubset();

  SignedSubset(
      const ::GURL& validity_url,
      std::vector<uint8_t> auth_sha256,
      uint64_t date,
      uint64_t expires,
      base::flat_map<::GURL, SubsetHashesValuePtr> subset_hashes);

SignedSubset(const SignedSubset&) = delete;
SignedSubset& operator=(const SignedSubset&) = delete;

  ~SignedSubset();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SignedSubsetPtr>
  SignedSubsetPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SignedSubset::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SignedSubset::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SignedSubset::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SignedSubset::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SignedSubset_UnserializedMessageContext<
            UserType, SignedSubset::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SignedSubset::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SignedSubset::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SignedSubset_UnserializedMessageContext<
            UserType, SignedSubset::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SignedSubset::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::GURL validity_url;
  
  std::vector<uint8_t> auth_sha256;
  
  uint64_t date;
  
  uint64_t expires;
  
  base::flat_map<::GURL, SubsetHashesValuePtr> subset_hashes;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SignedSubset::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SignedSubset::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SignedSubset::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SignedSubset::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  SubsetHashesValue {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<SubsetHashesValue, T>::value>;
  using DataView = SubsetHashesValueDataView;
  using Data_ = internal::SubsetHashesValue_Data;

  template <typename... Args>
  static SubsetHashesValuePtr New(Args&&... args) {
    return SubsetHashesValuePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static SubsetHashesValuePtr From(const U& u) {
    return mojo::TypeConverter<SubsetHashesValuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, SubsetHashesValue>::Convert(*this);
  }


  SubsetHashesValue();

  SubsetHashesValue(
      const std::string& variants_value,
      std::vector<ResourceIntegrityPtr> resource_integrities);

SubsetHashesValue(const SubsetHashesValue&) = delete;
SubsetHashesValue& operator=(const SubsetHashesValue&) = delete;

  ~SubsetHashesValue();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = SubsetHashesValuePtr>
  SubsetHashesValuePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, SubsetHashesValue::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, SubsetHashesValue::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        SubsetHashesValue::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        SubsetHashesValue::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::SubsetHashesValue_UnserializedMessageContext<
            UserType, SubsetHashesValue::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<SubsetHashesValue::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return SubsetHashesValue::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::SubsetHashesValue_UnserializedMessageContext<
            UserType, SubsetHashesValue::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<SubsetHashesValue::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string variants_value;
  
  std::vector<ResourceIntegrityPtr> resource_integrities;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, SubsetHashesValue::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, SubsetHashesValue::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, SubsetHashesValue::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, SubsetHashesValue::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  ResourceIntegrity {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<ResourceIntegrity, T>::value>;
  using DataView = ResourceIntegrityDataView;
  using Data_ = internal::ResourceIntegrity_Data;

  template <typename... Args>
  static ResourceIntegrityPtr New(Args&&... args) {
    return ResourceIntegrityPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static ResourceIntegrityPtr From(const U& u) {
    return mojo::TypeConverter<ResourceIntegrityPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ResourceIntegrity>::Convert(*this);
  }


  ResourceIntegrity();

  ResourceIntegrity(
      std::vector<uint8_t> header_sha256,
      const std::string& payload_integrity_header);


  ~ResourceIntegrity();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = ResourceIntegrityPtr>
  ResourceIntegrityPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, ResourceIntegrity::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, ResourceIntegrity::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        ResourceIntegrity::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ResourceIntegrity::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::ResourceIntegrity_UnserializedMessageContext<
            UserType, ResourceIntegrity::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<ResourceIntegrity::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return ResourceIntegrity::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::ResourceIntegrity_UnserializedMessageContext<
            UserType, ResourceIntegrity::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<ResourceIntegrity::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<uint8_t> header_sha256;
  
  std::string payload_integrity_header;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, ResourceIntegrity::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, ResourceIntegrity::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, ResourceIntegrity::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, ResourceIntegrity::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  BundleResponse {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<BundleResponse, T>::value>;
  using DataView = BundleResponseDataView;
  using Data_ = internal::BundleResponse_Data;

  template <typename... Args>
  static BundleResponsePtr New(Args&&... args) {
    return BundleResponsePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static BundleResponsePtr From(const U& u) {
    return mojo::TypeConverter<BundleResponsePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, BundleResponse>::Convert(*this);
  }


  BundleResponse();

  BundleResponse(
      int32_t response_code,
      const base::flat_map<std::string, std::string>& response_headers,
      uint64_t payload_offset,
      uint64_t payload_length);


  ~BundleResponse();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = BundleResponsePtr>
  BundleResponsePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, BundleResponse::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, BundleResponse::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        BundleResponse::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        BundleResponse::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::BundleResponse_UnserializedMessageContext<
            UserType, BundleResponse::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<BundleResponse::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return BundleResponse::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::BundleResponse_UnserializedMessageContext<
            UserType, BundleResponse::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<BundleResponse::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  int32_t response_code;
  
  base::flat_map<std::string, std::string> response_headers;
  
  uint64_t payload_offset;
  
  uint64_t payload_length;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, BundleResponse::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, BundleResponse::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, BundleResponse::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, BundleResponse::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename StructPtrType>
BundleIntegrityBlockParseErrorPtr BundleIntegrityBlockParseError::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(message)
  );
}

template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>*>
bool BundleIntegrityBlockParseError::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  return true;
}

template <typename T, BundleIntegrityBlockParseError::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  return false;
}
template <typename StructPtrType>
BundleMetadataParseErrorPtr BundleMetadataParseError::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(message)
  );
}

template <typename T, BundleMetadataParseError::EnableIfSame<T>*>
bool BundleMetadataParseError::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  return true;
}

template <typename T, BundleMetadataParseError::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  return false;
}
template <typename StructPtrType>
BundleResponseParseErrorPtr BundleResponseParseError::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(message)
  );
}

template <typename T, BundleResponseParseError::EnableIfSame<T>*>
bool BundleResponseParseError::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  return true;
}

template <typename T, BundleResponseParseError::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  return false;
}
template <typename StructPtrType>
BundleIntegrityBlockPtr BundleIntegrityBlock::Clone() const {
  return New(
      mojo::Clone(size),
      mojo::Clone(signature_stack)
  );
}

template <typename T, BundleIntegrityBlock::EnableIfSame<T>*>
bool BundleIntegrityBlock::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->size, other_struct.size))
    return false;
  if (!mojo::Equals(this->signature_stack, other_struct.signature_stack))
    return false;
  return true;
}

template <typename T, BundleIntegrityBlock::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.size < rhs.size)
    return true;
  if (rhs.size < lhs.size)
    return false;
  if (lhs.signature_stack < rhs.signature_stack)
    return true;
  if (rhs.signature_stack < lhs.signature_stack)
    return false;
  return false;
}
template <typename StructPtrType>
BundleIntegrityBlockSignatureStackEntryPtr BundleIntegrityBlockSignatureStackEntry::Clone() const {
  return New(
      mojo::Clone(complete_entry_cbor),
      mojo::Clone(attributes_cbor),
      mojo::Clone(public_key),
      mojo::Clone(signature)
  );
}

template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>*>
bool BundleIntegrityBlockSignatureStackEntry::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->complete_entry_cbor, other_struct.complete_entry_cbor))
    return false;
  if (!mojo::Equals(this->attributes_cbor, other_struct.attributes_cbor))
    return false;
  if (!mojo::Equals(this->public_key, other_struct.public_key))
    return false;
  if (!mojo::Equals(this->signature, other_struct.signature))
    return false;
  return true;
}

template <typename T, BundleIntegrityBlockSignatureStackEntry::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.complete_entry_cbor < rhs.complete_entry_cbor)
    return true;
  if (rhs.complete_entry_cbor < lhs.complete_entry_cbor)
    return false;
  if (lhs.attributes_cbor < rhs.attributes_cbor)
    return true;
  if (rhs.attributes_cbor < lhs.attributes_cbor)
    return false;
  if (lhs.public_key < rhs.public_key)
    return true;
  if (rhs.public_key < lhs.public_key)
    return false;
  if (lhs.signature < rhs.signature)
    return true;
  if (rhs.signature < lhs.signature)
    return false;
  return false;
}
template <typename StructPtrType>
BundleMetadataPtr BundleMetadata::Clone() const {
  return New(
      mojo::Clone(version),
      mojo::Clone(primary_url),
      mojo::Clone(requests),
      mojo::Clone(authorities),
      mojo::Clone(vouched_subsets)
  );
}

template <typename T, BundleMetadata::EnableIfSame<T>*>
bool BundleMetadata::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->version, other_struct.version))
    return false;
  if (!mojo::Equals(this->primary_url, other_struct.primary_url))
    return false;
  if (!mojo::Equals(this->requests, other_struct.requests))
    return false;
  if (!mojo::Equals(this->authorities, other_struct.authorities))
    return false;
  if (!mojo::Equals(this->vouched_subsets, other_struct.vouched_subsets))
    return false;
  return true;
}

template <typename T, BundleMetadata::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.version < rhs.version)
    return true;
  if (rhs.version < lhs.version)
    return false;
  if (lhs.primary_url < rhs.primary_url)
    return true;
  if (rhs.primary_url < lhs.primary_url)
    return false;
  if (lhs.requests < rhs.requests)
    return true;
  if (rhs.requests < lhs.requests)
    return false;
  if (lhs.authorities < rhs.authorities)
    return true;
  if (rhs.authorities < lhs.authorities)
    return false;
  if (lhs.vouched_subsets < rhs.vouched_subsets)
    return true;
  if (rhs.vouched_subsets < lhs.vouched_subsets)
    return false;
  return false;
}
template <typename StructPtrType>
BundleResponseLocationPtr BundleResponseLocation::Clone() const {
  return New(
      mojo::Clone(offset),
      mojo::Clone(length)
  );
}

template <typename T, BundleResponseLocation::EnableIfSame<T>*>
bool BundleResponseLocation::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->offset, other_struct.offset))
    return false;
  if (!mojo::Equals(this->length, other_struct.length))
    return false;
  return true;
}

template <typename T, BundleResponseLocation::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.offset < rhs.offset)
    return true;
  if (rhs.offset < lhs.offset)
    return false;
  if (lhs.length < rhs.length)
    return true;
  if (rhs.length < lhs.length)
    return false;
  return false;
}
template <typename StructPtrType>
AugmentedCertificatePtr AugmentedCertificate::Clone() const {
  return New(
      mojo::Clone(cert),
      mojo::Clone(ocsp),
      mojo::Clone(sct)
  );
}

template <typename T, AugmentedCertificate::EnableIfSame<T>*>
bool AugmentedCertificate::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->cert, other_struct.cert))
    return false;
  if (!mojo::Equals(this->ocsp, other_struct.ocsp))
    return false;
  if (!mojo::Equals(this->sct, other_struct.sct))
    return false;
  return true;
}

template <typename T, AugmentedCertificate::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.cert < rhs.cert)
    return true;
  if (rhs.cert < lhs.cert)
    return false;
  if (lhs.ocsp < rhs.ocsp)
    return true;
  if (rhs.ocsp < lhs.ocsp)
    return false;
  if (lhs.sct < rhs.sct)
    return true;
  if (rhs.sct < lhs.sct)
    return false;
  return false;
}
template <typename StructPtrType>
VouchedSubsetPtr VouchedSubset::Clone() const {
  return New(
      mojo::Clone(authority),
      mojo::Clone(sig),
      mojo::Clone(raw_signed),
      mojo::Clone(parsed_signed)
  );
}

template <typename T, VouchedSubset::EnableIfSame<T>*>
bool VouchedSubset::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->authority, other_struct.authority))
    return false;
  if (!mojo::Equals(this->sig, other_struct.sig))
    return false;
  if (!mojo::Equals(this->raw_signed, other_struct.raw_signed))
    return false;
  if (!mojo::Equals(this->parsed_signed, other_struct.parsed_signed))
    return false;
  return true;
}

template <typename T, VouchedSubset::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.authority < rhs.authority)
    return true;
  if (rhs.authority < lhs.authority)
    return false;
  if (lhs.sig < rhs.sig)
    return true;
  if (rhs.sig < lhs.sig)
    return false;
  if (lhs.raw_signed < rhs.raw_signed)
    return true;
  if (rhs.raw_signed < lhs.raw_signed)
    return false;
  if (lhs.parsed_signed < rhs.parsed_signed)
    return true;
  if (rhs.parsed_signed < lhs.parsed_signed)
    return false;
  return false;
}
template <typename StructPtrType>
SignedSubsetPtr SignedSubset::Clone() const {
  return New(
      mojo::Clone(validity_url),
      mojo::Clone(auth_sha256),
      mojo::Clone(date),
      mojo::Clone(expires),
      mojo::Clone(subset_hashes)
  );
}

template <typename T, SignedSubset::EnableIfSame<T>*>
bool SignedSubset::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->validity_url, other_struct.validity_url))
    return false;
  if (!mojo::Equals(this->auth_sha256, other_struct.auth_sha256))
    return false;
  if (!mojo::Equals(this->date, other_struct.date))
    return false;
  if (!mojo::Equals(this->expires, other_struct.expires))
    return false;
  if (!mojo::Equals(this->subset_hashes, other_struct.subset_hashes))
    return false;
  return true;
}

template <typename T, SignedSubset::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.validity_url < rhs.validity_url)
    return true;
  if (rhs.validity_url < lhs.validity_url)
    return false;
  if (lhs.auth_sha256 < rhs.auth_sha256)
    return true;
  if (rhs.auth_sha256 < lhs.auth_sha256)
    return false;
  if (lhs.date < rhs.date)
    return true;
  if (rhs.date < lhs.date)
    return false;
  if (lhs.expires < rhs.expires)
    return true;
  if (rhs.expires < lhs.expires)
    return false;
  if (lhs.subset_hashes < rhs.subset_hashes)
    return true;
  if (rhs.subset_hashes < lhs.subset_hashes)
    return false;
  return false;
}
template <typename StructPtrType>
SubsetHashesValuePtr SubsetHashesValue::Clone() const {
  return New(
      mojo::Clone(variants_value),
      mojo::Clone(resource_integrities)
  );
}

template <typename T, SubsetHashesValue::EnableIfSame<T>*>
bool SubsetHashesValue::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->variants_value, other_struct.variants_value))
    return false;
  if (!mojo::Equals(this->resource_integrities, other_struct.resource_integrities))
    return false;
  return true;
}

template <typename T, SubsetHashesValue::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.variants_value < rhs.variants_value)
    return true;
  if (rhs.variants_value < lhs.variants_value)
    return false;
  if (lhs.resource_integrities < rhs.resource_integrities)
    return true;
  if (rhs.resource_integrities < lhs.resource_integrities)
    return false;
  return false;
}
template <typename StructPtrType>
ResourceIntegrityPtr ResourceIntegrity::Clone() const {
  return New(
      mojo::Clone(header_sha256),
      mojo::Clone(payload_integrity_header)
  );
}

template <typename T, ResourceIntegrity::EnableIfSame<T>*>
bool ResourceIntegrity::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->header_sha256, other_struct.header_sha256))
    return false;
  if (!mojo::Equals(this->payload_integrity_header, other_struct.payload_integrity_header))
    return false;
  return true;
}

template <typename T, ResourceIntegrity::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.header_sha256 < rhs.header_sha256)
    return true;
  if (rhs.header_sha256 < lhs.header_sha256)
    return false;
  if (lhs.payload_integrity_header < rhs.payload_integrity_header)
    return true;
  if (rhs.payload_integrity_header < lhs.payload_integrity_header)
    return false;
  return false;
}
template <typename StructPtrType>
BundleResponsePtr BundleResponse::Clone() const {
  return New(
      mojo::Clone(response_code),
      mojo::Clone(response_headers),
      mojo::Clone(payload_offset),
      mojo::Clone(payload_length)
  );
}

template <typename T, BundleResponse::EnableIfSame<T>*>
bool BundleResponse::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->response_code, other_struct.response_code))
    return false;
  if (!mojo::Equals(this->response_headers, other_struct.response_headers))
    return false;
  if (!mojo::Equals(this->payload_offset, other_struct.payload_offset))
    return false;
  if (!mojo::Equals(this->payload_length, other_struct.payload_length))
    return false;
  return true;
}

template <typename T, BundleResponse::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.response_code < rhs.response_code)
    return true;
  if (rhs.response_code < lhs.response_code)
    return false;
  if (lhs.response_headers < rhs.response_headers)
    return true;
  if (rhs.response_headers < lhs.response_headers)
    return false;
  if (lhs.payload_offset < rhs.payload_offset)
    return true;
  if (rhs.payload_offset < lhs.payload_offset)
    return false;
  if (lhs.payload_length < rhs.payload_length)
    return true;
  if (rhs.payload_length < lhs.payload_length)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace web_package

namespace mojo {


template <>
struct  StructTraits<::web_package::mojom::BundleIntegrityBlockParseError::DataView,
                                         ::web_package::mojom::BundleIntegrityBlockParseErrorPtr> {
  static bool IsNull(const ::web_package::mojom::BundleIntegrityBlockParseErrorPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleIntegrityBlockParseErrorPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleIntegrityBlockParseError::type) type(
      const ::web_package::mojom::BundleIntegrityBlockParseErrorPtr& input) {
    return input->type;
  }

  static const decltype(::web_package::mojom::BundleIntegrityBlockParseError::message)& message(
      const ::web_package::mojom::BundleIntegrityBlockParseErrorPtr& input) {
    return input->message;
  }

  static bool Read(::web_package::mojom::BundleIntegrityBlockParseError::DataView input, ::web_package::mojom::BundleIntegrityBlockParseErrorPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleMetadataParseError::DataView,
                                         ::web_package::mojom::BundleMetadataParseErrorPtr> {
  static bool IsNull(const ::web_package::mojom::BundleMetadataParseErrorPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleMetadataParseErrorPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleMetadataParseError::type) type(
      const ::web_package::mojom::BundleMetadataParseErrorPtr& input) {
    return input->type;
  }

  static const decltype(::web_package::mojom::BundleMetadataParseError::message)& message(
      const ::web_package::mojom::BundleMetadataParseErrorPtr& input) {
    return input->message;
  }

  static bool Read(::web_package::mojom::BundleMetadataParseError::DataView input, ::web_package::mojom::BundleMetadataParseErrorPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleResponseParseError::DataView,
                                         ::web_package::mojom::BundleResponseParseErrorPtr> {
  static bool IsNull(const ::web_package::mojom::BundleResponseParseErrorPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleResponseParseErrorPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleResponseParseError::type) type(
      const ::web_package::mojom::BundleResponseParseErrorPtr& input) {
    return input->type;
  }

  static const decltype(::web_package::mojom::BundleResponseParseError::message)& message(
      const ::web_package::mojom::BundleResponseParseErrorPtr& input) {
    return input->message;
  }

  static bool Read(::web_package::mojom::BundleResponseParseError::DataView input, ::web_package::mojom::BundleResponseParseErrorPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleIntegrityBlock::DataView,
                                         ::web_package::mojom::BundleIntegrityBlockPtr> {
  static bool IsNull(const ::web_package::mojom::BundleIntegrityBlockPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleIntegrityBlockPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleIntegrityBlock::size) size(
      const ::web_package::mojom::BundleIntegrityBlockPtr& input) {
    return input->size;
  }

  static const decltype(::web_package::mojom::BundleIntegrityBlock::signature_stack)& signature_stack(
      const ::web_package::mojom::BundleIntegrityBlockPtr& input) {
    return input->signature_stack;
  }

  static bool Read(::web_package::mojom::BundleIntegrityBlock::DataView input, ::web_package::mojom::BundleIntegrityBlockPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleIntegrityBlockSignatureStackEntry::DataView,
                                         ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr> {
  static bool IsNull(const ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr* output) { output->reset(); }

  static const decltype(::web_package::mojom::BundleIntegrityBlockSignatureStackEntry::complete_entry_cbor)& complete_entry_cbor(
      const ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr& input) {
    return input->complete_entry_cbor;
  }

  static const decltype(::web_package::mojom::BundleIntegrityBlockSignatureStackEntry::attributes_cbor)& attributes_cbor(
      const ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr& input) {
    return input->attributes_cbor;
  }

  static const decltype(::web_package::mojom::BundleIntegrityBlockSignatureStackEntry::public_key)& public_key(
      const ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr& input) {
    return input->public_key;
  }

  static const decltype(::web_package::mojom::BundleIntegrityBlockSignatureStackEntry::signature)& signature(
      const ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr& input) {
    return input->signature;
  }

  static bool Read(::web_package::mojom::BundleIntegrityBlockSignatureStackEntry::DataView input, ::web_package::mojom::BundleIntegrityBlockSignatureStackEntryPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleMetadata::DataView,
                                         ::web_package::mojom::BundleMetadataPtr> {
  static bool IsNull(const ::web_package::mojom::BundleMetadataPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleMetadataPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleMetadata::version) version(
      const ::web_package::mojom::BundleMetadataPtr& input) {
    return input->version;
  }

  static const decltype(::web_package::mojom::BundleMetadata::primary_url)& primary_url(
      const ::web_package::mojom::BundleMetadataPtr& input) {
    return input->primary_url;
  }

  static const decltype(::web_package::mojom::BundleMetadata::requests)& requests(
      const ::web_package::mojom::BundleMetadataPtr& input) {
    return input->requests;
  }

  static const decltype(::web_package::mojom::BundleMetadata::authorities)& authorities(
      const ::web_package::mojom::BundleMetadataPtr& input) {
    return input->authorities;
  }

  static const decltype(::web_package::mojom::BundleMetadata::vouched_subsets)& vouched_subsets(
      const ::web_package::mojom::BundleMetadataPtr& input) {
    return input->vouched_subsets;
  }

  static bool Read(::web_package::mojom::BundleMetadata::DataView input, ::web_package::mojom::BundleMetadataPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleResponseLocation::DataView,
                                         ::web_package::mojom::BundleResponseLocationPtr> {
  static bool IsNull(const ::web_package::mojom::BundleResponseLocationPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleResponseLocationPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleResponseLocation::offset) offset(
      const ::web_package::mojom::BundleResponseLocationPtr& input) {
    return input->offset;
  }

  static decltype(::web_package::mojom::BundleResponseLocation::length) length(
      const ::web_package::mojom::BundleResponseLocationPtr& input) {
    return input->length;
  }

  static bool Read(::web_package::mojom::BundleResponseLocation::DataView input, ::web_package::mojom::BundleResponseLocationPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::AugmentedCertificate::DataView,
                                         ::web_package::mojom::AugmentedCertificatePtr> {
  static bool IsNull(const ::web_package::mojom::AugmentedCertificatePtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::AugmentedCertificatePtr* output) { output->reset(); }

  static const decltype(::web_package::mojom::AugmentedCertificate::cert)& cert(
      const ::web_package::mojom::AugmentedCertificatePtr& input) {
    return input->cert;
  }

  static const decltype(::web_package::mojom::AugmentedCertificate::ocsp)& ocsp(
      const ::web_package::mojom::AugmentedCertificatePtr& input) {
    return input->ocsp;
  }

  static const decltype(::web_package::mojom::AugmentedCertificate::sct)& sct(
      const ::web_package::mojom::AugmentedCertificatePtr& input) {
    return input->sct;
  }

  static bool Read(::web_package::mojom::AugmentedCertificate::DataView input, ::web_package::mojom::AugmentedCertificatePtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::VouchedSubset::DataView,
                                         ::web_package::mojom::VouchedSubsetPtr> {
  static bool IsNull(const ::web_package::mojom::VouchedSubsetPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::VouchedSubsetPtr* output) { output->reset(); }

  static decltype(::web_package::mojom::VouchedSubset::authority) authority(
      const ::web_package::mojom::VouchedSubsetPtr& input) {
    return input->authority;
  }

  static const decltype(::web_package::mojom::VouchedSubset::sig)& sig(
      const ::web_package::mojom::VouchedSubsetPtr& input) {
    return input->sig;
  }

  static const decltype(::web_package::mojom::VouchedSubset::raw_signed)& raw_signed(
      const ::web_package::mojom::VouchedSubsetPtr& input) {
    return input->raw_signed;
  }

  static const decltype(::web_package::mojom::VouchedSubset::parsed_signed)& parsed_signed(
      const ::web_package::mojom::VouchedSubsetPtr& input) {
    return input->parsed_signed;
  }

  static bool Read(::web_package::mojom::VouchedSubset::DataView input, ::web_package::mojom::VouchedSubsetPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::SignedSubset::DataView,
                                         ::web_package::mojom::SignedSubsetPtr> {
  static bool IsNull(const ::web_package::mojom::SignedSubsetPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::SignedSubsetPtr* output) { output->reset(); }

  static const decltype(::web_package::mojom::SignedSubset::validity_url)& validity_url(
      const ::web_package::mojom::SignedSubsetPtr& input) {
    return input->validity_url;
  }

  static const decltype(::web_package::mojom::SignedSubset::auth_sha256)& auth_sha256(
      const ::web_package::mojom::SignedSubsetPtr& input) {
    return input->auth_sha256;
  }

  static decltype(::web_package::mojom::SignedSubset::date) date(
      const ::web_package::mojom::SignedSubsetPtr& input) {
    return input->date;
  }

  static decltype(::web_package::mojom::SignedSubset::expires) expires(
      const ::web_package::mojom::SignedSubsetPtr& input) {
    return input->expires;
  }

  static const decltype(::web_package::mojom::SignedSubset::subset_hashes)& subset_hashes(
      const ::web_package::mojom::SignedSubsetPtr& input) {
    return input->subset_hashes;
  }

  static bool Read(::web_package::mojom::SignedSubset::DataView input, ::web_package::mojom::SignedSubsetPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::SubsetHashesValue::DataView,
                                         ::web_package::mojom::SubsetHashesValuePtr> {
  static bool IsNull(const ::web_package::mojom::SubsetHashesValuePtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::SubsetHashesValuePtr* output) { output->reset(); }

  static const decltype(::web_package::mojom::SubsetHashesValue::variants_value)& variants_value(
      const ::web_package::mojom::SubsetHashesValuePtr& input) {
    return input->variants_value;
  }

  static const decltype(::web_package::mojom::SubsetHashesValue::resource_integrities)& resource_integrities(
      const ::web_package::mojom::SubsetHashesValuePtr& input) {
    return input->resource_integrities;
  }

  static bool Read(::web_package::mojom::SubsetHashesValue::DataView input, ::web_package::mojom::SubsetHashesValuePtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::ResourceIntegrity::DataView,
                                         ::web_package::mojom::ResourceIntegrityPtr> {
  static bool IsNull(const ::web_package::mojom::ResourceIntegrityPtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::ResourceIntegrityPtr* output) { output->reset(); }

  static const decltype(::web_package::mojom::ResourceIntegrity::header_sha256)& header_sha256(
      const ::web_package::mojom::ResourceIntegrityPtr& input) {
    return input->header_sha256;
  }

  static const decltype(::web_package::mojom::ResourceIntegrity::payload_integrity_header)& payload_integrity_header(
      const ::web_package::mojom::ResourceIntegrityPtr& input) {
    return input->payload_integrity_header;
  }

  static bool Read(::web_package::mojom::ResourceIntegrity::DataView input, ::web_package::mojom::ResourceIntegrityPtr* output);
};


template <>
struct  StructTraits<::web_package::mojom::BundleResponse::DataView,
                                         ::web_package::mojom::BundleResponsePtr> {
  static bool IsNull(const ::web_package::mojom::BundleResponsePtr& input) { return !input; }
  static void SetToNull(::web_package::mojom::BundleResponsePtr* output) { output->reset(); }

  static decltype(::web_package::mojom::BundleResponse::response_code) response_code(
      const ::web_package::mojom::BundleResponsePtr& input) {
    return input->response_code;
  }

  static const decltype(::web_package::mojom::BundleResponse::response_headers)& response_headers(
      const ::web_package::mojom::BundleResponsePtr& input) {
    return input->response_headers;
  }

  static decltype(::web_package::mojom::BundleResponse::payload_offset) payload_offset(
      const ::web_package::mojom::BundleResponsePtr& input) {
    return input->payload_offset;
  }

  static decltype(::web_package::mojom::BundleResponse::payload_length) payload_length(
      const ::web_package::mojom::BundleResponsePtr& input) {
    return input->payload_length;
  }

  static bool Read(::web_package::mojom::BundleResponse::DataView input, ::web_package::mojom::BundleResponsePtr* output);
};

}  // namespace mojo

#endif  // COMPONENTS_WEB_PACKAGE_MOJOM_WEB_BUNDLE_PARSER_MOJOM_H_