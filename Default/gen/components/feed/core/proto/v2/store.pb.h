// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/feed/core/proto/v2/store.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/feed/core/proto/v2/wire/content_id.pb.h"
#include "components/feed/core/proto/v2/wire/feed_action.pb.h"
#include "components/feed/core/proto/v2/wire/stream_structure.pb.h"
#include "components/feed/core/proto/v2/wire/web_feed_matcher.pb.h"
#include "components/feed/core/proto/v2/wire/web_feeds.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto {
  static const uint32_t offsets[];
};
namespace feedstore {
class Content;
struct ContentDefaultTypeInternal;
extern ContentDefaultTypeInternal _Content_default_instance_;
class ContentInfo;
struct ContentInfoDefaultTypeInternal;
extern ContentInfoDefaultTypeInternal _ContentInfo_default_instance_;
class DataOperation;
struct DataOperationDefaultTypeInternal;
extern DataOperationDefaultTypeInternal _DataOperation_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Metadata;
struct MetadataDefaultTypeInternal;
extern MetadataDefaultTypeInternal _Metadata_default_instance_;
class Metadata_SessionID;
struct Metadata_SessionIDDefaultTypeInternal;
extern Metadata_SessionIDDefaultTypeInternal _Metadata_SessionID_default_instance_;
class Metadata_StreamMetadata;
struct Metadata_StreamMetadataDefaultTypeInternal;
extern Metadata_StreamMetadataDefaultTypeInternal _Metadata_StreamMetadata_default_instance_;
class Metadata_StreamMetadata_ContentLifetime;
struct Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal;
extern Metadata_StreamMetadata_ContentLifetimeDefaultTypeInternal _Metadata_StreamMetadata_ContentLifetime_default_instance_;
class PendingWebFeedOperation;
struct PendingWebFeedOperationDefaultTypeInternal;
extern PendingWebFeedOperationDefaultTypeInternal _PendingWebFeedOperation_default_instance_;
class RecommendedWebFeedIndex;
struct RecommendedWebFeedIndexDefaultTypeInternal;
extern RecommendedWebFeedIndexDefaultTypeInternal _RecommendedWebFeedIndex_default_instance_;
class RecommendedWebFeedIndex_Entry;
struct RecommendedWebFeedIndex_EntryDefaultTypeInternal;
extern RecommendedWebFeedIndex_EntryDefaultTypeInternal _RecommendedWebFeedIndex_Entry_default_instance_;
class Record;
struct RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class StoredAction;
struct StoredActionDefaultTypeInternal;
extern StoredActionDefaultTypeInternal _StoredAction_default_instance_;
class StreamData;
struct StreamDataDefaultTypeInternal;
extern StreamDataDefaultTypeInternal _StreamData_default_instance_;
class StreamSharedState;
struct StreamSharedStateDefaultTypeInternal;
extern StreamSharedStateDefaultTypeInternal _StreamSharedState_default_instance_;
class StreamStructure;
struct StreamStructureDefaultTypeInternal;
extern StreamStructureDefaultTypeInternal _StreamStructure_default_instance_;
class StreamStructureSet;
struct StreamStructureSetDefaultTypeInternal;
extern StreamStructureSetDefaultTypeInternal _StreamStructureSet_default_instance_;
class SubscribedWebFeeds;
struct SubscribedWebFeedsDefaultTypeInternal;
extern SubscribedWebFeedsDefaultTypeInternal _SubscribedWebFeeds_default_instance_;
class WebFeedInfo;
struct WebFeedInfoDefaultTypeInternal;
extern WebFeedInfoDefaultTypeInternal _WebFeedInfo_default_instance_;
}  // namespace feedstore
PROTOBUF_NAMESPACE_OPEN
template<> ::feedstore::Content* Arena::CreateMaybeMessage<::feedstore::Content>(Arena*);
template<> ::feedstore::ContentInfo* Arena::CreateMaybeMessage<::feedstore::ContentInfo>(Arena*);
template<> ::feedstore::DataOperation* Arena::CreateMaybeMessage<::feedstore::DataOperation>(Arena*);
template<> ::feedstore::Image* Arena::CreateMaybeMessage<::feedstore::Image>(Arena*);
template<> ::feedstore::Metadata* Arena::CreateMaybeMessage<::feedstore::Metadata>(Arena*);
template<> ::feedstore::Metadata_SessionID* Arena::CreateMaybeMessage<::feedstore::Metadata_SessionID>(Arena*);
template<> ::feedstore::Metadata_StreamMetadata* Arena::CreateMaybeMessage<::feedstore::Metadata_StreamMetadata>(Arena*);
template<> ::feedstore::Metadata_StreamMetadata_ContentLifetime* Arena::CreateMaybeMessage<::feedstore::Metadata_StreamMetadata_ContentLifetime>(Arena*);
template<> ::feedstore::PendingWebFeedOperation* Arena::CreateMaybeMessage<::feedstore::PendingWebFeedOperation>(Arena*);
template<> ::feedstore::RecommendedWebFeedIndex* Arena::CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex>(Arena*);
template<> ::feedstore::RecommendedWebFeedIndex_Entry* Arena::CreateMaybeMessage<::feedstore::RecommendedWebFeedIndex_Entry>(Arena*);
template<> ::feedstore::Record* Arena::CreateMaybeMessage<::feedstore::Record>(Arena*);
template<> ::feedstore::StoredAction* Arena::CreateMaybeMessage<::feedstore::StoredAction>(Arena*);
template<> ::feedstore::StreamData* Arena::CreateMaybeMessage<::feedstore::StreamData>(Arena*);
template<> ::feedstore::StreamSharedState* Arena::CreateMaybeMessage<::feedstore::StreamSharedState>(Arena*);
template<> ::feedstore::StreamStructure* Arena::CreateMaybeMessage<::feedstore::StreamStructure>(Arena*);
template<> ::feedstore::StreamStructureSet* Arena::CreateMaybeMessage<::feedstore::StreamStructureSet>(Arena*);
template<> ::feedstore::SubscribedWebFeeds* Arena::CreateMaybeMessage<::feedstore::SubscribedWebFeeds>(Arena*);
template<> ::feedstore::WebFeedInfo* Arena::CreateMaybeMessage<::feedstore::WebFeedInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace feedstore {

enum StreamStructure_Operation : int {
  StreamStructure_Operation_UNKNOWN = 0,
  StreamStructure_Operation_CLEAR_ALL = 1,
  StreamStructure_Operation_UPDATE_OR_APPEND = 2,
  StreamStructure_Operation_REMOVE = 3,
  StreamStructure_Operation_StreamStructure_Operation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StreamStructure_Operation_StreamStructure_Operation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamStructure_Operation_IsValid(int value);
constexpr StreamStructure_Operation StreamStructure_Operation_Operation_MIN = StreamStructure_Operation_UNKNOWN;
constexpr StreamStructure_Operation StreamStructure_Operation_Operation_MAX = StreamStructure_Operation_REMOVE;
constexpr int StreamStructure_Operation_Operation_ARRAYSIZE = StreamStructure_Operation_Operation_MAX + 1;

const std::string& StreamStructure_Operation_Name(StreamStructure_Operation value);
template<typename T>
inline const std::string& StreamStructure_Operation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamStructure_Operation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamStructure_Operation_Name.");
  return StreamStructure_Operation_Name(static_cast<StreamStructure_Operation>(enum_t_value));
}
bool StreamStructure_Operation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamStructure_Operation* value);
enum StreamStructure_Type : int {
  StreamStructure_Type_UNKNOWN_TYPE = 0,
  StreamStructure_Type_STREAM = 1,
  StreamStructure_Type_CARD = 2,
  StreamStructure_Type_CONTENT = 3,
  StreamStructure_Type_CLUSTER = 4,
  StreamStructure_Type_StreamStructure_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  StreamStructure_Type_StreamStructure_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool StreamStructure_Type_IsValid(int value);
constexpr StreamStructure_Type StreamStructure_Type_Type_MIN = StreamStructure_Type_UNKNOWN_TYPE;
constexpr StreamStructure_Type StreamStructure_Type_Type_MAX = StreamStructure_Type_CLUSTER;
constexpr int StreamStructure_Type_Type_ARRAYSIZE = StreamStructure_Type_Type_MAX + 1;

const std::string& StreamStructure_Type_Name(StreamStructure_Type value);
template<typename T>
inline const std::string& StreamStructure_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, StreamStructure_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function StreamStructure_Type_Name.");
  return StreamStructure_Type_Name(static_cast<StreamStructure_Type>(enum_t_value));
}
bool StreamStructure_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, StreamStructure_Type* value);
enum WebFeedInfo_State : int {
  WebFeedInfo_State_STATE_UNSPECIFIED = 0,
  WebFeedInfo_State_INACTIVE = 1,
  WebFeedInfo_State_ACTIVE = 2,
  WebFeedInfo_State_WAITING_FOR_CONTENT = 4,
  WebFeedInfo_State_WebFeedInfo_State_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  WebFeedInfo_State_WebFeedInfo_State_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool WebFeedInfo_State_IsValid(int value);
constexpr WebFeedInfo_State WebFeedInfo_State_State_MIN = WebFeedInfo_State_STATE_UNSPECIFIED;
constexpr WebFeedInfo_State WebFeedInfo_State_State_MAX = WebFeedInfo_State_WAITING_FOR_CONTENT;
constexpr int WebFeedInfo_State_State_ARRAYSIZE = WebFeedInfo_State_State_MAX + 1;

const std::string& WebFeedInfo_State_Name(WebFeedInfo_State value);
template<typename T>
inline const std::string& WebFeedInfo_State_Name(T enum_t_value) {
  static_assert(::std::is_same<T, WebFeedInfo_State>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function WebFeedInfo_State_Name.");
  return WebFeedInfo_State_Name(static_cast<WebFeedInfo_State>(enum_t_value));
}
bool WebFeedInfo_State_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, WebFeedInfo_State* value);
enum PendingWebFeedOperation_Kind : int {
  PendingWebFeedOperation_Kind_KIND_UNSPECIFIED = 0,
  PendingWebFeedOperation_Kind_SUBSCRIBE = 1,
  PendingWebFeedOperation_Kind_UNSUBSCRIBE = 2,
  PendingWebFeedOperation_Kind_PendingWebFeedOperation_Kind_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PendingWebFeedOperation_Kind_PendingWebFeedOperation_Kind_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PendingWebFeedOperation_Kind_IsValid(int value);
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation_Kind_Kind_MIN = PendingWebFeedOperation_Kind_KIND_UNSPECIFIED;
constexpr PendingWebFeedOperation_Kind PendingWebFeedOperation_Kind_Kind_MAX = PendingWebFeedOperation_Kind_UNSUBSCRIBE;
constexpr int PendingWebFeedOperation_Kind_Kind_ARRAYSIZE = PendingWebFeedOperation_Kind_Kind_MAX + 1;

const std::string& PendingWebFeedOperation_Kind_Name(PendingWebFeedOperation_Kind value);
template<typename T>
inline const std::string& PendingWebFeedOperation_Kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PendingWebFeedOperation_Kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PendingWebFeedOperation_Kind_Name.");
  return PendingWebFeedOperation_Kind_Name(static_cast<PendingWebFeedOperation_Kind>(enum_t_value));
}
bool PendingWebFeedOperation_Kind_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PendingWebFeedOperation_Kind* value);
// ===================================================================

class Record final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Record) */ {
 public:
  inline Record() : Record(nullptr) {}
  ~Record() override;
  explicit PROTOBUF_CONSTEXPR Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Record& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kStreamData = 1,
    kStreamStructures = 2,
    kContent = 3,
    kLocalAction = 4,
    kSharedState = 5,
    kMetadata = 6,
    kSubscribedWebFeeds = 7,
    kRecommendedWebFeed = 8,
    kRecommendedWebFeedIndex = 9,
    kPendingWebFeedOperation = 10,
    DATA_NOT_SET = 0,
  };

  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Record* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Record& from);
  void MergeFrom(const Record& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Record* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Record";
  }
  protected:
  explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamDataFieldNumber = 1,
    kStreamStructuresFieldNumber = 2,
    kContentFieldNumber = 3,
    kLocalActionFieldNumber = 4,
    kSharedStateFieldNumber = 5,
    kMetadataFieldNumber = 6,
    kSubscribedWebFeedsFieldNumber = 7,
    kRecommendedWebFeedFieldNumber = 8,
    kRecommendedWebFeedIndexFieldNumber = 9,
    kPendingWebFeedOperationFieldNumber = 10,
  };
  // .feedstore.StreamData stream_data = 1;
  bool has_stream_data() const;
  private:
  bool _internal_has_stream_data() const;
  public:
  void clear_stream_data();
  const ::feedstore::StreamData& stream_data() const;
  PROTOBUF_NODISCARD ::feedstore::StreamData* release_stream_data();
  ::feedstore::StreamData* mutable_stream_data();
  void set_allocated_stream_data(::feedstore::StreamData* stream_data);
  private:
  const ::feedstore::StreamData& _internal_stream_data() const;
  ::feedstore::StreamData* _internal_mutable_stream_data();
  public:
  void unsafe_arena_set_allocated_stream_data(
      ::feedstore::StreamData* stream_data);
  ::feedstore::StreamData* unsafe_arena_release_stream_data();

  // .feedstore.StreamStructureSet stream_structures = 2;
  bool has_stream_structures() const;
  private:
  bool _internal_has_stream_structures() const;
  public:
  void clear_stream_structures();
  const ::feedstore::StreamStructureSet& stream_structures() const;
  PROTOBUF_NODISCARD ::feedstore::StreamStructureSet* release_stream_structures();
  ::feedstore::StreamStructureSet* mutable_stream_structures();
  void set_allocated_stream_structures(::feedstore::StreamStructureSet* stream_structures);
  private:
  const ::feedstore::StreamStructureSet& _internal_stream_structures() const;
  ::feedstore::StreamStructureSet* _internal_mutable_stream_structures();
  public:
  void unsafe_arena_set_allocated_stream_structures(
      ::feedstore::StreamStructureSet* stream_structures);
  ::feedstore::StreamStructureSet* unsafe_arena_release_stream_structures();

  // .feedstore.Content content = 3;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::feedstore::Content& content() const;
  PROTOBUF_NODISCARD ::feedstore::Content* release_content();
  ::feedstore::Content* mutable_content();
  void set_allocated_content(::feedstore::Content* content);
  private:
  const ::feedstore::Content& _internal_content() const;
  ::feedstore::Content* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::feedstore::Content* content);
  ::feedstore::Content* unsafe_arena_release_content();

  // .feedstore.StoredAction local_action = 4;
  bool has_local_action() const;
  private:
  bool _internal_has_local_action() const;
  public:
  void clear_local_action();
  const ::feedstore::StoredAction& local_action() const;
  PROTOBUF_NODISCARD ::feedstore::StoredAction* release_local_action();
  ::feedstore::StoredAction* mutable_local_action();
  void set_allocated_local_action(::feedstore::StoredAction* local_action);
  private:
  const ::feedstore::StoredAction& _internal_local_action() const;
  ::feedstore::StoredAction* _internal_mutable_local_action();
  public:
  void unsafe_arena_set_allocated_local_action(
      ::feedstore::StoredAction* local_action);
  ::feedstore::StoredAction* unsafe_arena_release_local_action();

  // .feedstore.StreamSharedState shared_state = 5;
  bool has_shared_state() const;
  private:
  bool _internal_has_shared_state() const;
  public:
  void clear_shared_state();
  const ::feedstore::StreamSharedState& shared_state() const;
  PROTOBUF_NODISCARD ::feedstore::StreamSharedState* release_shared_state();
  ::feedstore::StreamSharedState* mutable_shared_state();
  void set_allocated_shared_state(::feedstore::StreamSharedState* shared_state);
  private:
  const ::feedstore::StreamSharedState& _internal_shared_state() const;
  ::feedstore::StreamSharedState* _internal_mutable_shared_state();
  public:
  void unsafe_arena_set_allocated_shared_state(
      ::feedstore::StreamSharedState* shared_state);
  ::feedstore::StreamSharedState* unsafe_arena_release_shared_state();

  // .feedstore.Metadata metadata = 6;
  bool has_metadata() const;
  private:
  bool _internal_has_metadata() const;
  public:
  void clear_metadata();
  const ::feedstore::Metadata& metadata() const;
  PROTOBUF_NODISCARD ::feedstore::Metadata* release_metadata();
  ::feedstore::Metadata* mutable_metadata();
  void set_allocated_metadata(::feedstore::Metadata* metadata);
  private:
  const ::feedstore::Metadata& _internal_metadata() const;
  ::feedstore::Metadata* _internal_mutable_metadata();
  public:
  void unsafe_arena_set_allocated_metadata(
      ::feedstore::Metadata* metadata);
  ::feedstore::Metadata* unsafe_arena_release_metadata();

  // .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
  bool has_subscribed_web_feeds() const;
  private:
  bool _internal_has_subscribed_web_feeds() const;
  public:
  void clear_subscribed_web_feeds();
  const ::feedstore::SubscribedWebFeeds& subscribed_web_feeds() const;
  PROTOBUF_NODISCARD ::feedstore::SubscribedWebFeeds* release_subscribed_web_feeds();
  ::feedstore::SubscribedWebFeeds* mutable_subscribed_web_feeds();
  void set_allocated_subscribed_web_feeds(::feedstore::SubscribedWebFeeds* subscribed_web_feeds);
  private:
  const ::feedstore::SubscribedWebFeeds& _internal_subscribed_web_feeds() const;
  ::feedstore::SubscribedWebFeeds* _internal_mutable_subscribed_web_feeds();
  public:
  void unsafe_arena_set_allocated_subscribed_web_feeds(
      ::feedstore::SubscribedWebFeeds* subscribed_web_feeds);
  ::feedstore::SubscribedWebFeeds* unsafe_arena_release_subscribed_web_feeds();

  // .feedstore.WebFeedInfo recommended_web_feed = 8;
  bool has_recommended_web_feed() const;
  private:
  bool _internal_has_recommended_web_feed() const;
  public:
  void clear_recommended_web_feed();
  const ::feedstore::WebFeedInfo& recommended_web_feed() const;
  PROTOBUF_NODISCARD ::feedstore::WebFeedInfo* release_recommended_web_feed();
  ::feedstore::WebFeedInfo* mutable_recommended_web_feed();
  void set_allocated_recommended_web_feed(::feedstore::WebFeedInfo* recommended_web_feed);
  private:
  const ::feedstore::WebFeedInfo& _internal_recommended_web_feed() const;
  ::feedstore::WebFeedInfo* _internal_mutable_recommended_web_feed();
  public:
  void unsafe_arena_set_allocated_recommended_web_feed(
      ::feedstore::WebFeedInfo* recommended_web_feed);
  ::feedstore::WebFeedInfo* unsafe_arena_release_recommended_web_feed();

  // .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
  bool has_recommended_web_feed_index() const;
  private:
  bool _internal_has_recommended_web_feed_index() const;
  public:
  void clear_recommended_web_feed_index();
  const ::feedstore::RecommendedWebFeedIndex& recommended_web_feed_index() const;
  PROTOBUF_NODISCARD ::feedstore::RecommendedWebFeedIndex* release_recommended_web_feed_index();
  ::feedstore::RecommendedWebFeedIndex* mutable_recommended_web_feed_index();
  void set_allocated_recommended_web_feed_index(::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index);
  private:
  const ::feedstore::RecommendedWebFeedIndex& _internal_recommended_web_feed_index() const;
  ::feedstore::RecommendedWebFeedIndex* _internal_mutable_recommended_web_feed_index();
  public:
  void unsafe_arena_set_allocated_recommended_web_feed_index(
      ::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index);
  ::feedstore::RecommendedWebFeedIndex* unsafe_arena_release_recommended_web_feed_index();

  // .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
  bool has_pending_web_feed_operation() const;
  private:
  bool _internal_has_pending_web_feed_operation() const;
  public:
  void clear_pending_web_feed_operation();
  const ::feedstore::PendingWebFeedOperation& pending_web_feed_operation() const;
  PROTOBUF_NODISCARD ::feedstore::PendingWebFeedOperation* release_pending_web_feed_operation();
  ::feedstore::PendingWebFeedOperation* mutable_pending_web_feed_operation();
  void set_allocated_pending_web_feed_operation(::feedstore::PendingWebFeedOperation* pending_web_feed_operation);
  private:
  const ::feedstore::PendingWebFeedOperation& _internal_pending_web_feed_operation() const;
  ::feedstore::PendingWebFeedOperation* _internal_mutable_pending_web_feed_operation();
  public:
  void unsafe_arena_set_allocated_pending_web_feed_operation(
      ::feedstore::PendingWebFeedOperation* pending_web_feed_operation);
  ::feedstore::PendingWebFeedOperation* unsafe_arena_release_pending_web_feed_operation();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:feedstore.Record)
 private:
  class _Internal;
  void set_has_stream_data();
  void set_has_stream_structures();
  void set_has_content();
  void set_has_local_action();
  void set_has_shared_state();
  void set_has_metadata();
  void set_has_subscribed_web_feeds();
  void set_has_recommended_web_feed();
  void set_has_recommended_web_feed_index();
  void set_has_pending_web_feed_operation();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::feedstore::StreamData* stream_data_;
    ::feedstore::StreamStructureSet* stream_structures_;
    ::feedstore::Content* content_;
    ::feedstore::StoredAction* local_action_;
    ::feedstore::StreamSharedState* shared_state_;
    ::feedstore::Metadata* metadata_;
    ::feedstore::SubscribedWebFeeds* subscribed_web_feeds_;
    ::feedstore::WebFeedInfo* recommended_web_feed_;
    ::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index_;
    ::feedstore::PendingWebFeedOperation* pending_web_feed_operation_;
  } data_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamData final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamData) */ {
 public:
  inline StreamData() : StreamData(nullptr) {}
  ~StreamData() override;
  explicit PROTOBUF_CONSTEXPR StreamData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamData(const StreamData& from);
  StreamData(StreamData&& from) noexcept
    : StreamData() {
    *this = ::std::move(from);
  }

  inline StreamData& operator=(const StreamData& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamData& operator=(StreamData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StreamData& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamData* internal_default_instance() {
    return reinterpret_cast<const StreamData*>(
               &_StreamData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StreamData& a, StreamData& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamData>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreamData& from);
  void MergeFrom(const StreamData& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.StreamData";
  }
  protected:
  explicit StreamData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSharedStateIdsFieldNumber = 6,
    kContentHashesFieldNumber = 11,
    kNextPageTokenFieldNumber = 2,
    kStreamIdFieldNumber = 10,
    kRootEventIdFieldNumber = 12,
    kGaiaFieldNumber = 13,
    kEmailFieldNumber = 14,
    kContentIdFieldNumber = 1,
    kLastAddedTimeMillisFieldNumber = 4,
    kSignedInFieldNumber = 7,
    kLoggingEnabledFieldNumber = 8,
    kPrivacyNoticeFulfilledFieldNumber = 9,
  };
  // repeated .feedwire.ContentId shared_state_ids = 6;
  int shared_state_ids_size() const;
  private:
  int _internal_shared_state_ids_size() const;
  public:
  void clear_shared_state_ids();
  ::feedwire::ContentId* mutable_shared_state_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::ContentId >*
      mutable_shared_state_ids();
  private:
  const ::feedwire::ContentId& _internal_shared_state_ids(int index) const;
  ::feedwire::ContentId* _internal_add_shared_state_ids();
  public:
  const ::feedwire::ContentId& shared_state_ids(int index) const;
  ::feedwire::ContentId* add_shared_state_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::ContentId >&
      shared_state_ids() const;

  // repeated uint32 content_hashes = 11;
  int content_hashes_size() const;
  private:
  int _internal_content_hashes_size() const;
  public:
  void clear_content_hashes();
  private:
  uint32_t _internal_content_hashes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_content_hashes() const;
  void _internal_add_content_hashes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_content_hashes();
  public:
  uint32_t content_hashes(int index) const;
  void set_content_hashes(int index, uint32_t value);
  void add_content_hashes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      content_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_content_hashes();

  // bytes next_page_token = 2;
  void clear_next_page_token();
  const std::string& next_page_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_next_page_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_next_page_token();
  PROTOBUF_NODISCARD std::string* release_next_page_token();
  void set_allocated_next_page_token(std::string* next_page_token);
  private:
  const std::string& _internal_next_page_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_next_page_token(const std::string& value);
  std::string* _internal_mutable_next_page_token();
  public:

  // string stream_id = 10;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // bytes root_event_id = 12;
  void clear_root_event_id();
  const std::string& root_event_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_root_event_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_root_event_id();
  PROTOBUF_NODISCARD std::string* release_root_event_id();
  void set_allocated_root_event_id(std::string* root_event_id);
  private:
  const std::string& _internal_root_event_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root_event_id(const std::string& value);
  std::string* _internal_mutable_root_event_id();
  public:

  // string gaia = 13;
  void clear_gaia();
  const std::string& gaia() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gaia(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gaia();
  PROTOBUF_NODISCARD std::string* release_gaia();
  void set_allocated_gaia(std::string* gaia);
  private:
  const std::string& _internal_gaia() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia(const std::string& value);
  std::string* _internal_mutable_gaia();
  public:

  // string email = 14;
  void clear_email();
  const std::string& email() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_email(ArgT0&& arg0, ArgT... args);
  std::string* mutable_email();
  PROTOBUF_NODISCARD std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // .feedwire.ContentId content_id = 1;
  bool has_content_id() const;
  private:
  bool _internal_has_content_id() const;
  public:
  void clear_content_id();
  const ::feedwire::ContentId& content_id() const;
  PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
  ::feedwire::ContentId* mutable_content_id();
  void set_allocated_content_id(::feedwire::ContentId* content_id);
  private:
  const ::feedwire::ContentId& _internal_content_id() const;
  ::feedwire::ContentId* _internal_mutable_content_id();
  public:
  void unsafe_arena_set_allocated_content_id(
      ::feedwire::ContentId* content_id);
  ::feedwire::ContentId* unsafe_arena_release_content_id();

  // int64 last_added_time_millis = 4;
  void clear_last_added_time_millis();
  int64_t last_added_time_millis() const;
  void set_last_added_time_millis(int64_t value);
  private:
  int64_t _internal_last_added_time_millis() const;
  void _internal_set_last_added_time_millis(int64_t value);
  public:

  // bool signed_in = 7;
  void clear_signed_in();
  bool signed_in() const;
  void set_signed_in(bool value);
  private:
  bool _internal_signed_in() const;
  void _internal_set_signed_in(bool value);
  public:

  // bool logging_enabled = 8;
  void clear_logging_enabled();
  bool logging_enabled() const;
  void set_logging_enabled(bool value);
  private:
  bool _internal_logging_enabled() const;
  void _internal_set_logging_enabled(bool value);
  public:

  // bool privacy_notice_fulfilled = 9;
  void clear_privacy_notice_fulfilled();
  bool privacy_notice_fulfilled() const;
  void set_privacy_notice_fulfilled(bool value);
  private:
  bool _internal_privacy_notice_fulfilled() const;
  void _internal_set_privacy_notice_fulfilled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.StreamData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::ContentId > shared_state_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > content_hashes_;
  mutable std::atomic<int> _content_hashes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_page_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr root_event_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::feedwire::ContentId* content_id_;
  int64_t last_added_time_millis_;
  bool signed_in_;
  bool logging_enabled_;
  bool privacy_notice_fulfilled_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata_SessionID final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata.SessionID) */ {
 public:
  inline Metadata_SessionID() : Metadata_SessionID(nullptr) {}
  ~Metadata_SessionID() override;
  explicit PROTOBUF_CONSTEXPR Metadata_SessionID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata_SessionID(const Metadata_SessionID& from);
  Metadata_SessionID(Metadata_SessionID&& from) noexcept
    : Metadata_SessionID() {
    *this = ::std::move(from);
  }

  inline Metadata_SessionID& operator=(const Metadata_SessionID& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata_SessionID& operator=(Metadata_SessionID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Metadata_SessionID& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata_SessionID* internal_default_instance() {
    return reinterpret_cast<const Metadata_SessionID*>(
               &_Metadata_SessionID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Metadata_SessionID& a, Metadata_SessionID& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Metadata_SessionID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata_SessionID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata_SessionID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata_SessionID>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Metadata_SessionID& from);
  void MergeFrom(const Metadata_SessionID& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata_SessionID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Metadata.SessionID";
  }
  protected:
  explicit Metadata_SessionID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kExpiryTimeMsFieldNumber = 2,
  };
  // string token = 1;
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // int64 expiry_time_ms = 2;
  void clear_expiry_time_ms();
  int64_t expiry_time_ms() const;
  void set_expiry_time_ms(int64_t value);
  private:
  int64_t _internal_expiry_time_ms() const;
  void _internal_set_expiry_time_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.Metadata.SessionID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  int64_t expiry_time_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata_StreamMetadata_ContentLifetime final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata.StreamMetadata.ContentLifetime) */ {
 public:
  inline Metadata_StreamMetadata_ContentLifetime() : Metadata_StreamMetadata_ContentLifetime(nullptr) {}
  ~Metadata_StreamMetadata_ContentLifetime() override;
  explicit PROTOBUF_CONSTEXPR Metadata_StreamMetadata_ContentLifetime(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata_StreamMetadata_ContentLifetime(const Metadata_StreamMetadata_ContentLifetime& from);
  Metadata_StreamMetadata_ContentLifetime(Metadata_StreamMetadata_ContentLifetime&& from) noexcept
    : Metadata_StreamMetadata_ContentLifetime() {
    *this = ::std::move(from);
  }

  inline Metadata_StreamMetadata_ContentLifetime& operator=(const Metadata_StreamMetadata_ContentLifetime& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata_StreamMetadata_ContentLifetime& operator=(Metadata_StreamMetadata_ContentLifetime&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Metadata_StreamMetadata_ContentLifetime& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata_StreamMetadata_ContentLifetime* internal_default_instance() {
    return reinterpret_cast<const Metadata_StreamMetadata_ContentLifetime*>(
               &_Metadata_StreamMetadata_ContentLifetime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Metadata_StreamMetadata_ContentLifetime& a, Metadata_StreamMetadata_ContentLifetime& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Metadata_StreamMetadata_ContentLifetime* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata_StreamMetadata_ContentLifetime* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata_StreamMetadata_ContentLifetime* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata_StreamMetadata_ContentLifetime>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Metadata_StreamMetadata_ContentLifetime& from);
  void MergeFrom(const Metadata_StreamMetadata_ContentLifetime& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata_StreamMetadata_ContentLifetime* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Metadata.StreamMetadata.ContentLifetime";
  }
  protected:
  explicit Metadata_StreamMetadata_ContentLifetime(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStaleAgeMsFieldNumber = 1,
    kInvalidAgeMsFieldNumber = 2,
  };
  // int64 stale_age_ms = 1;
  void clear_stale_age_ms();
  int64_t stale_age_ms() const;
  void set_stale_age_ms(int64_t value);
  private:
  int64_t _internal_stale_age_ms() const;
  void _internal_set_stale_age_ms(int64_t value);
  public:

  // int64 invalid_age_ms = 2;
  void clear_invalid_age_ms();
  int64_t invalid_age_ms() const;
  void set_invalid_age_ms(int64_t value);
  private:
  int64_t _internal_invalid_age_ms() const;
  void _internal_set_invalid_age_ms(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.Metadata.StreamMetadata.ContentLifetime)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t stale_age_ms_;
  int64_t invalid_age_ms_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata_StreamMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata.StreamMetadata) */ {
 public:
  inline Metadata_StreamMetadata() : Metadata_StreamMetadata(nullptr) {}
  ~Metadata_StreamMetadata() override;
  explicit PROTOBUF_CONSTEXPR Metadata_StreamMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata_StreamMetadata(const Metadata_StreamMetadata& from);
  Metadata_StreamMetadata(Metadata_StreamMetadata&& from) noexcept
    : Metadata_StreamMetadata() {
    *this = ::std::move(from);
  }

  inline Metadata_StreamMetadata& operator=(const Metadata_StreamMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata_StreamMetadata& operator=(Metadata_StreamMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Metadata_StreamMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata_StreamMetadata* internal_default_instance() {
    return reinterpret_cast<const Metadata_StreamMetadata*>(
               &_Metadata_StreamMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Metadata_StreamMetadata& a, Metadata_StreamMetadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Metadata_StreamMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata_StreamMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata_StreamMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata_StreamMetadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Metadata_StreamMetadata& from);
  void MergeFrom(const Metadata_StreamMetadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata_StreamMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Metadata.StreamMetadata";
  }
  protected:
  explicit Metadata_StreamMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Metadata_StreamMetadata_ContentLifetime ContentLifetime;

  // accessors -------------------------------------------------------

  enum : int {
    kViewContentHashesFieldNumber = 4,
    kStreamIdFieldNumber = 1,
    kContentLifetimeFieldNumber = 5,
    kLastFetchTimeMillisFieldNumber = 6,
    kLastServerResponseTimeMillisFieldNumber = 7,
    kIsKnownStaleFieldNumber = 3,
  };
  // repeated uint32 view_content_hashes = 4;
  int view_content_hashes_size() const;
  private:
  int _internal_view_content_hashes_size() const;
  public:
  void clear_view_content_hashes();
  private:
  uint32_t _internal_view_content_hashes(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_view_content_hashes() const;
  void _internal_add_view_content_hashes(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_view_content_hashes();
  public:
  uint32_t view_content_hashes(int index) const;
  void set_view_content_hashes(int index, uint32_t value);
  void add_view_content_hashes(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      view_content_hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_view_content_hashes();

  // string stream_id = 1;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
  bool has_content_lifetime() const;
  private:
  bool _internal_has_content_lifetime() const;
  public:
  void clear_content_lifetime();
  const ::feedstore::Metadata_StreamMetadata_ContentLifetime& content_lifetime() const;
  PROTOBUF_NODISCARD ::feedstore::Metadata_StreamMetadata_ContentLifetime* release_content_lifetime();
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* mutable_content_lifetime();
  void set_allocated_content_lifetime(::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime);
  private:
  const ::feedstore::Metadata_StreamMetadata_ContentLifetime& _internal_content_lifetime() const;
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* _internal_mutable_content_lifetime();
  public:
  void unsafe_arena_set_allocated_content_lifetime(
      ::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime);
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* unsafe_arena_release_content_lifetime();

  // int64 last_fetch_time_millis = 6;
  void clear_last_fetch_time_millis();
  int64_t last_fetch_time_millis() const;
  void set_last_fetch_time_millis(int64_t value);
  private:
  int64_t _internal_last_fetch_time_millis() const;
  void _internal_set_last_fetch_time_millis(int64_t value);
  public:

  // int64 last_server_response_time_millis = 7;
  void clear_last_server_response_time_millis();
  int64_t last_server_response_time_millis() const;
  void set_last_server_response_time_millis(int64_t value);
  private:
  int64_t _internal_last_server_response_time_millis() const;
  void _internal_set_last_server_response_time_millis(int64_t value);
  public:

  // bool is_known_stale = 3;
  void clear_is_known_stale();
  bool is_known_stale() const;
  void set_is_known_stale(bool value);
  private:
  bool _internal_is_known_stale() const;
  void _internal_set_is_known_stale(bool value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.Metadata.StreamMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > view_content_hashes_;
  mutable std::atomic<int> _view_content_hashes_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime_;
  int64_t last_fetch_time_millis_;
  int64_t last_server_response_time_millis_;
  bool is_known_stale_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Metadata final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Metadata) */ {
 public:
  inline Metadata() : Metadata(nullptr) {}
  ~Metadata() override;
  explicit PROTOBUF_CONSTEXPR Metadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Metadata(const Metadata& from);
  Metadata(Metadata&& from) noexcept
    : Metadata() {
    *this = ::std::move(from);
  }

  inline Metadata& operator=(const Metadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline Metadata& operator=(Metadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Metadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const Metadata* internal_default_instance() {
    return reinterpret_cast<const Metadata*>(
               &_Metadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Metadata& a, Metadata& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Metadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Metadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Metadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Metadata>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Metadata& from);
  void MergeFrom(const Metadata& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Metadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Metadata";
  }
  protected:
  explicit Metadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Metadata_SessionID SessionID;
  typedef Metadata_StreamMetadata StreamMetadata;

  // accessors -------------------------------------------------------

  enum : int {
    kStreamMetadataFieldNumber = 5,
    kConsistencyTokenFieldNumber = 1,
    kGaiaFieldNumber = 6,
    kSessionIdFieldNumber = 3,
    kNextActionIdFieldNumber = 2,
    kStreamSchemaVersionFieldNumber = 4,
    kWebAndAppActivityEnabledFieldNumber = 7,
    kDiscoverPersonalizationEnabledFieldNumber = 8,
    kFollowedFromWebPageMenuCountFieldNumber = 9,
  };
  // repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
  int stream_metadata_size() const;
  private:
  int _internal_stream_metadata_size() const;
  public:
  void clear_stream_metadata();
  ::feedstore::Metadata_StreamMetadata* mutable_stream_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::Metadata_StreamMetadata >*
      mutable_stream_metadata();
  private:
  const ::feedstore::Metadata_StreamMetadata& _internal_stream_metadata(int index) const;
  ::feedstore::Metadata_StreamMetadata* _internal_add_stream_metadata();
  public:
  const ::feedstore::Metadata_StreamMetadata& stream_metadata(int index) const;
  ::feedstore::Metadata_StreamMetadata* add_stream_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::Metadata_StreamMetadata >&
      stream_metadata() const;

  // bytes consistency_token = 1;
  void clear_consistency_token();
  const std::string& consistency_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_consistency_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_consistency_token();
  PROTOBUF_NODISCARD std::string* release_consistency_token();
  void set_allocated_consistency_token(std::string* consistency_token);
  private:
  const std::string& _internal_consistency_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_consistency_token(const std::string& value);
  std::string* _internal_mutable_consistency_token();
  public:

  // string gaia = 6;
  void clear_gaia();
  const std::string& gaia() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gaia(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gaia();
  PROTOBUF_NODISCARD std::string* release_gaia();
  void set_allocated_gaia(std::string* gaia);
  private:
  const std::string& _internal_gaia() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gaia(const std::string& value);
  std::string* _internal_mutable_gaia();
  public:

  // .feedstore.Metadata.SessionID session_id = 3;
  bool has_session_id() const;
  private:
  bool _internal_has_session_id() const;
  public:
  void clear_session_id();
  const ::feedstore::Metadata_SessionID& session_id() const;
  PROTOBUF_NODISCARD ::feedstore::Metadata_SessionID* release_session_id();
  ::feedstore::Metadata_SessionID* mutable_session_id();
  void set_allocated_session_id(::feedstore::Metadata_SessionID* session_id);
  private:
  const ::feedstore::Metadata_SessionID& _internal_session_id() const;
  ::feedstore::Metadata_SessionID* _internal_mutable_session_id();
  public:
  void unsafe_arena_set_allocated_session_id(
      ::feedstore::Metadata_SessionID* session_id);
  ::feedstore::Metadata_SessionID* unsafe_arena_release_session_id();

  // int32 next_action_id = 2;
  void clear_next_action_id();
  int32_t next_action_id() const;
  void set_next_action_id(int32_t value);
  private:
  int32_t _internal_next_action_id() const;
  void _internal_set_next_action_id(int32_t value);
  public:

  // int32 stream_schema_version = 4;
  void clear_stream_schema_version();
  int32_t stream_schema_version() const;
  void set_stream_schema_version(int32_t value);
  private:
  int32_t _internal_stream_schema_version() const;
  void _internal_set_stream_schema_version(int32_t value);
  public:

  // bool web_and_app_activity_enabled = 7;
  void clear_web_and_app_activity_enabled();
  bool web_and_app_activity_enabled() const;
  void set_web_and_app_activity_enabled(bool value);
  private:
  bool _internal_web_and_app_activity_enabled() const;
  void _internal_set_web_and_app_activity_enabled(bool value);
  public:

  // bool discover_personalization_enabled = 8;
  void clear_discover_personalization_enabled();
  bool discover_personalization_enabled() const;
  void set_discover_personalization_enabled(bool value);
  private:
  bool _internal_discover_personalization_enabled() const;
  void _internal_set_discover_personalization_enabled(bool value);
  public:

  // int32 followed_from_web_page_menu_count = 9;
  void clear_followed_from_web_page_menu_count();
  int32_t followed_from_web_page_menu_count() const;
  void set_followed_from_web_page_menu_count(int32_t value);
  private:
  int32_t _internal_followed_from_web_page_menu_count() const;
  void _internal_set_followed_from_web_page_menu_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.Metadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::Metadata_StreamMetadata > stream_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr consistency_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gaia_;
  ::feedstore::Metadata_SessionID* session_id_;
  int32_t next_action_id_;
  int32_t stream_schema_version_;
  bool web_and_app_activity_enabled_;
  bool discover_personalization_enabled_;
  int32_t followed_from_web_page_menu_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamStructureSet final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamStructureSet) */ {
 public:
  inline StreamStructureSet() : StreamStructureSet(nullptr) {}
  ~StreamStructureSet() override;
  explicit PROTOBUF_CONSTEXPR StreamStructureSet(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStructureSet(const StreamStructureSet& from);
  StreamStructureSet(StreamStructureSet&& from) noexcept
    : StreamStructureSet() {
    *this = ::std::move(from);
  }

  inline StreamStructureSet& operator=(const StreamStructureSet& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStructureSet& operator=(StreamStructureSet&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StreamStructureSet& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStructureSet* internal_default_instance() {
    return reinterpret_cast<const StreamStructureSet*>(
               &_StreamStructureSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StreamStructureSet& a, StreamStructureSet& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamStructureSet* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStructureSet* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStructureSet* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStructureSet>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreamStructureSet& from);
  void MergeFrom(const StreamStructureSet& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamStructureSet* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.StreamStructureSet";
  }
  protected:
  explicit StreamStructureSet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructuresFieldNumber = 3,
    kStreamIdFieldNumber = 1,
    kSequenceNumberFieldNumber = 2,
  };
  // repeated .feedstore.StreamStructure structures = 3;
  int structures_size() const;
  private:
  int _internal_structures_size() const;
  public:
  void clear_structures();
  ::feedstore::StreamStructure* mutable_structures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::StreamStructure >*
      mutable_structures();
  private:
  const ::feedstore::StreamStructure& _internal_structures(int index) const;
  ::feedstore::StreamStructure* _internal_add_structures();
  public:
  const ::feedstore::StreamStructure& structures(int index) const;
  ::feedstore::StreamStructure* add_structures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::StreamStructure >&
      structures() const;

  // string stream_id = 1;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // int32 sequence_number = 2;
  void clear_sequence_number();
  int32_t sequence_number() const;
  void set_sequence_number(int32_t value);
  private:
  int32_t _internal_sequence_number() const;
  void _internal_set_sequence_number(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.StreamStructureSet)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::StreamStructure > structures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
  int32_t sequence_number_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamStructure final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamStructure) */ {
 public:
  inline StreamStructure() : StreamStructure(nullptr) {}
  ~StreamStructure() override;
  explicit PROTOBUF_CONSTEXPR StreamStructure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamStructure(const StreamStructure& from);
  StreamStructure(StreamStructure&& from) noexcept
    : StreamStructure() {
    *this = ::std::move(from);
  }

  inline StreamStructure& operator=(const StreamStructure& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamStructure& operator=(StreamStructure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StreamStructure& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamStructure* internal_default_instance() {
    return reinterpret_cast<const StreamStructure*>(
               &_StreamStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StreamStructure& a, StreamStructure& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamStructure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamStructure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamStructure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamStructure>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreamStructure& from);
  void MergeFrom(const StreamStructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamStructure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.StreamStructure";
  }
  protected:
  explicit StreamStructure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef StreamStructure_Operation Operation;
  static constexpr Operation UNKNOWN =
    StreamStructure_Operation_UNKNOWN;
  static constexpr Operation CLEAR_ALL =
    StreamStructure_Operation_CLEAR_ALL;
  static constexpr Operation UPDATE_OR_APPEND =
    StreamStructure_Operation_UPDATE_OR_APPEND;
  static constexpr Operation REMOVE =
    StreamStructure_Operation_REMOVE;
  static inline bool Operation_IsValid(int value) {
    return StreamStructure_Operation_IsValid(value);
  }
  static constexpr Operation Operation_MIN =
    StreamStructure_Operation_Operation_MIN;
  static constexpr Operation Operation_MAX =
    StreamStructure_Operation_Operation_MAX;
  static constexpr int Operation_ARRAYSIZE =
    StreamStructure_Operation_Operation_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Operation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Operation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Operation_Name.");
    return StreamStructure_Operation_Name(enum_t_value);
  }
  static inline bool Operation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Operation* value) {
    return StreamStructure_Operation_Parse(name, value);
  }

  typedef StreamStructure_Type Type;
  static constexpr Type UNKNOWN_TYPE =
    StreamStructure_Type_UNKNOWN_TYPE;
  static constexpr Type STREAM =
    StreamStructure_Type_STREAM;
  static constexpr Type CARD =
    StreamStructure_Type_CARD;
  static constexpr Type CONTENT =
    StreamStructure_Type_CONTENT;
  static constexpr Type CLUSTER =
    StreamStructure_Type_CLUSTER;
  static inline bool Type_IsValid(int value) {
    return StreamStructure_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    StreamStructure_Type_Type_MIN;
  static constexpr Type Type_MAX =
    StreamStructure_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    StreamStructure_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return StreamStructure_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return StreamStructure_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kContentIdFieldNumber = 2,
    kParentIdFieldNumber = 3,
    kContentInfoFieldNumber = 5,
    kOperationFieldNumber = 1,
    kTypeFieldNumber = 4,
    kIsRootFieldNumber = 6,
  };
  // .feedwire.ContentId content_id = 2;
  bool has_content_id() const;
  private:
  bool _internal_has_content_id() const;
  public:
  void clear_content_id();
  const ::feedwire::ContentId& content_id() const;
  PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
  ::feedwire::ContentId* mutable_content_id();
  void set_allocated_content_id(::feedwire::ContentId* content_id);
  private:
  const ::feedwire::ContentId& _internal_content_id() const;
  ::feedwire::ContentId* _internal_mutable_content_id();
  public:
  void unsafe_arena_set_allocated_content_id(
      ::feedwire::ContentId* content_id);
  ::feedwire::ContentId* unsafe_arena_release_content_id();

  // .feedwire.ContentId parent_id = 3;
  bool has_parent_id() const;
  private:
  bool _internal_has_parent_id() const;
  public:
  void clear_parent_id();
  const ::feedwire::ContentId& parent_id() const;
  PROTOBUF_NODISCARD ::feedwire::ContentId* release_parent_id();
  ::feedwire::ContentId* mutable_parent_id();
  void set_allocated_parent_id(::feedwire::ContentId* parent_id);
  private:
  const ::feedwire::ContentId& _internal_parent_id() const;
  ::feedwire::ContentId* _internal_mutable_parent_id();
  public:
  void unsafe_arena_set_allocated_parent_id(
      ::feedwire::ContentId* parent_id);
  ::feedwire::ContentId* unsafe_arena_release_parent_id();

  // .feedstore.ContentInfo content_info = 5;
  bool has_content_info() const;
  private:
  bool _internal_has_content_info() const;
  public:
  void clear_content_info();
  const ::feedstore::ContentInfo& content_info() const;
  PROTOBUF_NODISCARD ::feedstore::ContentInfo* release_content_info();
  ::feedstore::ContentInfo* mutable_content_info();
  void set_allocated_content_info(::feedstore::ContentInfo* content_info);
  private:
  const ::feedstore::ContentInfo& _internal_content_info() const;
  ::feedstore::ContentInfo* _internal_mutable_content_info();
  public:
  void unsafe_arena_set_allocated_content_info(
      ::feedstore::ContentInfo* content_info);
  ::feedstore::ContentInfo* unsafe_arena_release_content_info();

  // .feedstore.StreamStructure.Operation operation = 1;
  void clear_operation();
  ::feedstore::StreamStructure_Operation operation() const;
  void set_operation(::feedstore::StreamStructure_Operation value);
  private:
  ::feedstore::StreamStructure_Operation _internal_operation() const;
  void _internal_set_operation(::feedstore::StreamStructure_Operation value);
  public:

  // .feedstore.StreamStructure.Type type = 4;
  void clear_type();
  ::feedstore::StreamStructure_Type type() const;
  void set_type(::feedstore::StreamStructure_Type value);
  private:
  ::feedstore::StreamStructure_Type _internal_type() const;
  void _internal_set_type(::feedstore::StreamStructure_Type value);
  public:

  // bool is_root = 6;
  void clear_is_root();
  bool is_root() const;
  void set_is_root(bool value);
  private:
  bool _internal_is_root() const;
  void _internal_set_is_root(bool value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.StreamStructure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::feedwire::ContentId* content_id_;
  ::feedwire::ContentId* parent_id_;
  ::feedstore::ContentInfo* content_info_;
  int operation_;
  int type_;
  bool is_root_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class DataOperation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.DataOperation) */ {
 public:
  inline DataOperation() : DataOperation(nullptr) {}
  ~DataOperation() override;
  explicit PROTOBUF_CONSTEXPR DataOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataOperation(const DataOperation& from);
  DataOperation(DataOperation&& from) noexcept
    : DataOperation() {
    *this = ::std::move(from);
  }

  inline DataOperation& operator=(const DataOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataOperation& operator=(DataOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DataOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataOperation* internal_default_instance() {
    return reinterpret_cast<const DataOperation*>(
               &_DataOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DataOperation& a, DataOperation& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DataOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DataOperation& from);
  void MergeFrom(const DataOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DataOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.DataOperation";
  }
  protected:
  explicit DataOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStructureFieldNumber = 1,
    kContentFieldNumber = 2,
  };
  // .feedstore.StreamStructure structure = 1;
  bool has_structure() const;
  private:
  bool _internal_has_structure() const;
  public:
  void clear_structure();
  const ::feedstore::StreamStructure& structure() const;
  PROTOBUF_NODISCARD ::feedstore::StreamStructure* release_structure();
  ::feedstore::StreamStructure* mutable_structure();
  void set_allocated_structure(::feedstore::StreamStructure* structure);
  private:
  const ::feedstore::StreamStructure& _internal_structure() const;
  ::feedstore::StreamStructure* _internal_mutable_structure();
  public:
  void unsafe_arena_set_allocated_structure(
      ::feedstore::StreamStructure* structure);
  ::feedstore::StreamStructure* unsafe_arena_release_structure();

  // .feedstore.Content content = 2;
  bool has_content() const;
  private:
  bool _internal_has_content() const;
  public:
  void clear_content();
  const ::feedstore::Content& content() const;
  PROTOBUF_NODISCARD ::feedstore::Content* release_content();
  ::feedstore::Content* mutable_content();
  void set_allocated_content(::feedstore::Content* content);
  private:
  const ::feedstore::Content& _internal_content() const;
  ::feedstore::Content* _internal_mutable_content();
  public:
  void unsafe_arena_set_allocated_content(
      ::feedstore::Content* content);
  ::feedstore::Content* unsafe_arena_release_content();

  // @@protoc_insertion_point(class_scope:feedstore.DataOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::feedstore::StreamStructure* structure_;
  ::feedstore::Content* content_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class ContentInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.ContentInfo) */ {
 public:
  inline ContentInfo() : ContentInfo(nullptr) {}
  ~ContentInfo() override;
  explicit PROTOBUF_CONSTEXPR ContentInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ContentInfo(const ContentInfo& from);
  ContentInfo(ContentInfo&& from) noexcept
    : ContentInfo() {
    *this = ::std::move(from);
  }

  inline ContentInfo& operator=(const ContentInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ContentInfo& operator=(ContentInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ContentInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ContentInfo* internal_default_instance() {
    return reinterpret_cast<const ContentInfo*>(
               &_ContentInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ContentInfo& a, ContentInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ContentInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ContentInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ContentInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ContentInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ContentInfo& from);
  void MergeFrom(const ContentInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ContentInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.ContentInfo";
  }
  protected:
  explicit ContentInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailabilityTimeSecondsFieldNumber = 2,
    kScoreFieldNumber = 1,
  };
  // int64 availability_time_seconds = 2;
  void clear_availability_time_seconds();
  int64_t availability_time_seconds() const;
  void set_availability_time_seconds(int64_t value);
  private:
  int64_t _internal_availability_time_seconds() const;
  void _internal_set_availability_time_seconds(int64_t value);
  public:

  // float score = 1;
  void clear_score();
  float score() const;
  void set_score(float value);
  private:
  float _internal_score() const;
  void _internal_set_score(float value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.ContentInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t availability_time_seconds_;
  float score_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Content final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Content) */ {
 public:
  inline Content() : Content(nullptr) {}
  ~Content() override;
  explicit PROTOBUF_CONSTEXPR Content(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Content(const Content& from);
  Content(Content&& from) noexcept
    : Content() {
    *this = ::std::move(from);
  }

  inline Content& operator=(const Content& from) {
    CopyFrom(from);
    return *this;
  }
  inline Content& operator=(Content&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Content& default_instance() {
    return *internal_default_instance();
  }
  static inline const Content* internal_default_instance() {
    return reinterpret_cast<const Content*>(
               &_Content_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Content& a, Content& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Content* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Content* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Content* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Content>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Content& from);
  void MergeFrom(const Content& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Content* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Content";
  }
  protected:
  explicit Content(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPrefetchMetadataFieldNumber = 3,
    kFrameFieldNumber = 2,
    kStreamIdFieldNumber = 4,
    kContentIdFieldNumber = 1,
  };
  // repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
  int prefetch_metadata_size() const;
  private:
  int _internal_prefetch_metadata_size() const;
  public:
  void clear_prefetch_metadata();
  ::feedwire::PrefetchMetadata* mutable_prefetch_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::PrefetchMetadata >*
      mutable_prefetch_metadata();
  private:
  const ::feedwire::PrefetchMetadata& _internal_prefetch_metadata(int index) const;
  ::feedwire::PrefetchMetadata* _internal_add_prefetch_metadata();
  public:
  const ::feedwire::PrefetchMetadata& prefetch_metadata(int index) const;
  ::feedwire::PrefetchMetadata* add_prefetch_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::PrefetchMetadata >&
      prefetch_metadata() const;

  // bytes frame = 2;
  void clear_frame();
  const std::string& frame() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_frame(ArgT0&& arg0, ArgT... args);
  std::string* mutable_frame();
  PROTOBUF_NODISCARD std::string* release_frame();
  void set_allocated_frame(std::string* frame);
  private:
  const std::string& _internal_frame() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_frame(const std::string& value);
  std::string* _internal_mutable_frame();
  public:

  // string stream_id = 4;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // .feedwire.ContentId content_id = 1;
  bool has_content_id() const;
  private:
  bool _internal_has_content_id() const;
  public:
  void clear_content_id();
  const ::feedwire::ContentId& content_id() const;
  PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
  ::feedwire::ContentId* mutable_content_id();
  void set_allocated_content_id(::feedwire::ContentId* content_id);
  private:
  const ::feedwire::ContentId& _internal_content_id() const;
  ::feedwire::ContentId* _internal_mutable_content_id();
  public:
  void unsafe_arena_set_allocated_content_id(
      ::feedwire::ContentId* content_id);
  ::feedwire::ContentId* unsafe_arena_release_content_id();

  // @@protoc_insertion_point(class_scope:feedstore.Content)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::PrefetchMetadata > prefetch_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr frame_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
  ::feedwire::ContentId* content_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StreamSharedState final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StreamSharedState) */ {
 public:
  inline StreamSharedState() : StreamSharedState(nullptr) {}
  ~StreamSharedState() override;
  explicit PROTOBUF_CONSTEXPR StreamSharedState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StreamSharedState(const StreamSharedState& from);
  StreamSharedState(StreamSharedState&& from) noexcept
    : StreamSharedState() {
    *this = ::std::move(from);
  }

  inline StreamSharedState& operator=(const StreamSharedState& from) {
    CopyFrom(from);
    return *this;
  }
  inline StreamSharedState& operator=(StreamSharedState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StreamSharedState& default_instance() {
    return *internal_default_instance();
  }
  static inline const StreamSharedState* internal_default_instance() {
    return reinterpret_cast<const StreamSharedState*>(
               &_StreamSharedState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StreamSharedState& a, StreamSharedState& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StreamSharedState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StreamSharedState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StreamSharedState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StreamSharedState>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StreamSharedState& from);
  void MergeFrom(const StreamSharedState& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StreamSharedState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.StreamSharedState";
  }
  protected:
  explicit StreamSharedState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSharedStateDataFieldNumber = 2,
    kStreamIdFieldNumber = 3,
    kContentIdFieldNumber = 1,
  };
  // bytes shared_state_data = 2;
  void clear_shared_state_data();
  const std::string& shared_state_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_shared_state_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_shared_state_data();
  PROTOBUF_NODISCARD std::string* release_shared_state_data();
  void set_allocated_shared_state_data(std::string* shared_state_data);
  private:
  const std::string& _internal_shared_state_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shared_state_data(const std::string& value);
  std::string* _internal_mutable_shared_state_data();
  public:

  // string stream_id = 3;
  void clear_stream_id();
  const std::string& stream_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_stream_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_stream_id();
  PROTOBUF_NODISCARD std::string* release_stream_id();
  void set_allocated_stream_id(std::string* stream_id);
  private:
  const std::string& _internal_stream_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_stream_id(const std::string& value);
  std::string* _internal_mutable_stream_id();
  public:

  // .feedwire.ContentId content_id = 1;
  bool has_content_id() const;
  private:
  bool _internal_has_content_id() const;
  public:
  void clear_content_id();
  const ::feedwire::ContentId& content_id() const;
  PROTOBUF_NODISCARD ::feedwire::ContentId* release_content_id();
  ::feedwire::ContentId* mutable_content_id();
  void set_allocated_content_id(::feedwire::ContentId* content_id);
  private:
  const ::feedwire::ContentId& _internal_content_id() const;
  ::feedwire::ContentId* _internal_mutable_content_id();
  public:
  void unsafe_arena_set_allocated_content_id(
      ::feedwire::ContentId* content_id);
  ::feedwire::ContentId* unsafe_arena_release_content_id();

  // @@protoc_insertion_point(class_scope:feedstore.StreamSharedState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr shared_state_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr stream_id_;
  ::feedwire::ContentId* content_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class StoredAction final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.StoredAction) */ {
 public:
  inline StoredAction() : StoredAction(nullptr) {}
  ~StoredAction() override;
  explicit PROTOBUF_CONSTEXPR StoredAction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoredAction(const StoredAction& from);
  StoredAction(StoredAction&& from) noexcept
    : StoredAction() {
    *this = ::std::move(from);
  }

  inline StoredAction& operator=(const StoredAction& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoredAction& operator=(StoredAction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StoredAction& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoredAction* internal_default_instance() {
    return reinterpret_cast<const StoredAction*>(
               &_StoredAction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StoredAction& a, StoredAction& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(StoredAction* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoredAction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoredAction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoredAction>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StoredAction& from);
  void MergeFrom(const StoredAction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StoredAction* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.StoredAction";
  }
  protected:
  explicit StoredAction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionFieldNumber = 3,
    kIdFieldNumber = 1,
    kUploadAttemptCountFieldNumber = 2,
  };
  // .feedwire.FeedAction action = 3;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::feedwire::FeedAction& action() const;
  PROTOBUF_NODISCARD ::feedwire::FeedAction* release_action();
  ::feedwire::FeedAction* mutable_action();
  void set_allocated_action(::feedwire::FeedAction* action);
  private:
  const ::feedwire::FeedAction& _internal_action() const;
  ::feedwire::FeedAction* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::feedwire::FeedAction* action);
  ::feedwire::FeedAction* unsafe_arena_release_action();

  // int32 id = 1;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // int32 upload_attempt_count = 2;
  void clear_upload_attempt_count();
  int32_t upload_attempt_count() const;
  void set_upload_attempt_count(int32_t value);
  private:
  int32_t _internal_upload_attempt_count() const;
  void _internal_set_upload_attempt_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.StoredAction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::feedwire::FeedAction* action_;
  int32_t id_;
  int32_t upload_attempt_count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class SubscribedWebFeeds final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.SubscribedWebFeeds) */ {
 public:
  inline SubscribedWebFeeds() : SubscribedWebFeeds(nullptr) {}
  ~SubscribedWebFeeds() override;
  explicit PROTOBUF_CONSTEXPR SubscribedWebFeeds(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SubscribedWebFeeds(const SubscribedWebFeeds& from);
  SubscribedWebFeeds(SubscribedWebFeeds&& from) noexcept
    : SubscribedWebFeeds() {
    *this = ::std::move(from);
  }

  inline SubscribedWebFeeds& operator=(const SubscribedWebFeeds& from) {
    CopyFrom(from);
    return *this;
  }
  inline SubscribedWebFeeds& operator=(SubscribedWebFeeds&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const SubscribedWebFeeds& default_instance() {
    return *internal_default_instance();
  }
  static inline const SubscribedWebFeeds* internal_default_instance() {
    return reinterpret_cast<const SubscribedWebFeeds*>(
               &_SubscribedWebFeeds_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SubscribedWebFeeds& a, SubscribedWebFeeds& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(SubscribedWebFeeds* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SubscribedWebFeeds* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SubscribedWebFeeds* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SubscribedWebFeeds>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const SubscribedWebFeeds& from);
  void MergeFrom(const SubscribedWebFeeds& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SubscribedWebFeeds* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.SubscribedWebFeeds";
  }
  protected:
  explicit SubscribedWebFeeds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeedsFieldNumber = 1,
    kUpdateTimeMillisFieldNumber = 2,
  };
  // repeated .feedstore.WebFeedInfo feeds = 1;
  int feeds_size() const;
  private:
  int _internal_feeds_size() const;
  public:
  void clear_feeds();
  ::feedstore::WebFeedInfo* mutable_feeds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::WebFeedInfo >*
      mutable_feeds();
  private:
  const ::feedstore::WebFeedInfo& _internal_feeds(int index) const;
  ::feedstore::WebFeedInfo* _internal_add_feeds();
  public:
  const ::feedstore::WebFeedInfo& feeds(int index) const;
  ::feedstore::WebFeedInfo* add_feeds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::WebFeedInfo >&
      feeds() const;

  // int64 update_time_millis = 2;
  void clear_update_time_millis();
  int64_t update_time_millis() const;
  void set_update_time_millis(int64_t value);
  private:
  int64_t _internal_update_time_millis() const;
  void _internal_set_update_time_millis(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.SubscribedWebFeeds)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::WebFeedInfo > feeds_;
  int64_t update_time_millis_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class RecommendedWebFeedIndex_Entry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.RecommendedWebFeedIndex.Entry) */ {
 public:
  inline RecommendedWebFeedIndex_Entry() : RecommendedWebFeedIndex_Entry(nullptr) {}
  ~RecommendedWebFeedIndex_Entry() override;
  explicit PROTOBUF_CONSTEXPR RecommendedWebFeedIndex_Entry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecommendedWebFeedIndex_Entry(const RecommendedWebFeedIndex_Entry& from);
  RecommendedWebFeedIndex_Entry(RecommendedWebFeedIndex_Entry&& from) noexcept
    : RecommendedWebFeedIndex_Entry() {
    *this = ::std::move(from);
  }

  inline RecommendedWebFeedIndex_Entry& operator=(const RecommendedWebFeedIndex_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendedWebFeedIndex_Entry& operator=(RecommendedWebFeedIndex_Entry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RecommendedWebFeedIndex_Entry& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecommendedWebFeedIndex_Entry* internal_default_instance() {
    return reinterpret_cast<const RecommendedWebFeedIndex_Entry*>(
               &_RecommendedWebFeedIndex_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(RecommendedWebFeedIndex_Entry& a, RecommendedWebFeedIndex_Entry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RecommendedWebFeedIndex_Entry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendedWebFeedIndex_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendedWebFeedIndex_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecommendedWebFeedIndex_Entry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecommendedWebFeedIndex_Entry& from);
  void MergeFrom(const RecommendedWebFeedIndex_Entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecommendedWebFeedIndex_Entry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.RecommendedWebFeedIndex.Entry";
  }
  protected:
  explicit RecommendedWebFeedIndex_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchersFieldNumber = 2,
    kWebFeedIdFieldNumber = 1,
  };
  // repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
  int matchers_size() const;
  private:
  int _internal_matchers_size() const;
  public:
  void clear_matchers();
  ::feedwire::webfeed::WebFeedMatcher* mutable_matchers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >*
      mutable_matchers();
  private:
  const ::feedwire::webfeed::WebFeedMatcher& _internal_matchers(int index) const;
  ::feedwire::webfeed::WebFeedMatcher* _internal_add_matchers();
  public:
  const ::feedwire::webfeed::WebFeedMatcher& matchers(int index) const;
  ::feedwire::webfeed::WebFeedMatcher* add_matchers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >&
      matchers() const;

  // string web_feed_id = 1;
  void clear_web_feed_id();
  const std::string& web_feed_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_web_feed_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_web_feed_id();
  PROTOBUF_NODISCARD std::string* release_web_feed_id();
  void set_allocated_web_feed_id(std::string* web_feed_id);
  private:
  const std::string& _internal_web_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_feed_id(const std::string& value);
  std::string* _internal_mutable_web_feed_id();
  public:

  // @@protoc_insertion_point(class_scope:feedstore.RecommendedWebFeedIndex.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher > matchers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_feed_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class RecommendedWebFeedIndex final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.RecommendedWebFeedIndex) */ {
 public:
  inline RecommendedWebFeedIndex() : RecommendedWebFeedIndex(nullptr) {}
  ~RecommendedWebFeedIndex() override;
  explicit PROTOBUF_CONSTEXPR RecommendedWebFeedIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecommendedWebFeedIndex(const RecommendedWebFeedIndex& from);
  RecommendedWebFeedIndex(RecommendedWebFeedIndex&& from) noexcept
    : RecommendedWebFeedIndex() {
    *this = ::std::move(from);
  }

  inline RecommendedWebFeedIndex& operator=(const RecommendedWebFeedIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecommendedWebFeedIndex& operator=(RecommendedWebFeedIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const RecommendedWebFeedIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecommendedWebFeedIndex* internal_default_instance() {
    return reinterpret_cast<const RecommendedWebFeedIndex*>(
               &_RecommendedWebFeedIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RecommendedWebFeedIndex& a, RecommendedWebFeedIndex& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(RecommendedWebFeedIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecommendedWebFeedIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecommendedWebFeedIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecommendedWebFeedIndex>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const RecommendedWebFeedIndex& from);
  void MergeFrom(const RecommendedWebFeedIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RecommendedWebFeedIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.RecommendedWebFeedIndex";
  }
  protected:
  explicit RecommendedWebFeedIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef RecommendedWebFeedIndex_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kUpdateTimeMillisFieldNumber = 2,
  };
  // repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::feedstore::RecommendedWebFeedIndex_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::RecommendedWebFeedIndex_Entry >*
      mutable_entries();
  private:
  const ::feedstore::RecommendedWebFeedIndex_Entry& _internal_entries(int index) const;
  ::feedstore::RecommendedWebFeedIndex_Entry* _internal_add_entries();
  public:
  const ::feedstore::RecommendedWebFeedIndex_Entry& entries(int index) const;
  ::feedstore::RecommendedWebFeedIndex_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::RecommendedWebFeedIndex_Entry >&
      entries() const;

  // int64 update_time_millis = 2;
  void clear_update_time_millis();
  int64_t update_time_millis() const;
  void set_update_time_millis(int64_t value);
  private:
  int64_t _internal_update_time_millis() const;
  void _internal_set_update_time_millis(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.RecommendedWebFeedIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::RecommendedWebFeedIndex_Entry > entries_;
  int64_t update_time_millis_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class Image final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  ~Image() override;
  explicit PROTOBUF_CONSTEXPR Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Image* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // @@protoc_insertion_point(class_scope:feedstore.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class WebFeedInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.WebFeedInfo) */ {
 public:
  inline WebFeedInfo() : WebFeedInfo(nullptr) {}
  ~WebFeedInfo() override;
  explicit PROTOBUF_CONSTEXPR WebFeedInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WebFeedInfo(const WebFeedInfo& from);
  WebFeedInfo(WebFeedInfo&& from) noexcept
    : WebFeedInfo() {
    *this = ::std::move(from);
  }

  inline WebFeedInfo& operator=(const WebFeedInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline WebFeedInfo& operator=(WebFeedInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const WebFeedInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const WebFeedInfo* internal_default_instance() {
    return reinterpret_cast<const WebFeedInfo*>(
               &_WebFeedInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WebFeedInfo& a, WebFeedInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(WebFeedInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WebFeedInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WebFeedInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WebFeedInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const WebFeedInfo& from);
  void MergeFrom(const WebFeedInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(WebFeedInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.WebFeedInfo";
  }
  protected:
  explicit WebFeedInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef WebFeedInfo_State State;
  static constexpr State STATE_UNSPECIFIED =
    WebFeedInfo_State_STATE_UNSPECIFIED;
  static constexpr State INACTIVE =
    WebFeedInfo_State_INACTIVE;
  static constexpr State ACTIVE =
    WebFeedInfo_State_ACTIVE;
  static constexpr State WAITING_FOR_CONTENT =
    WebFeedInfo_State_WAITING_FOR_CONTENT;
  static inline bool State_IsValid(int value) {
    return WebFeedInfo_State_IsValid(value);
  }
  static constexpr State State_MIN =
    WebFeedInfo_State_State_MIN;
  static constexpr State State_MAX =
    WebFeedInfo_State_State_MAX;
  static constexpr int State_ARRAYSIZE =
    WebFeedInfo_State_State_ARRAYSIZE;
  template<typename T>
  static inline const std::string& State_Name(T enum_t_value) {
    static_assert(::std::is_same<T, State>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function State_Name.");
    return WebFeedInfo_State_Name(enum_t_value);
  }
  static inline bool State_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      State* value) {
    return WebFeedInfo_State_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMatchersFieldNumber = 10,
    kWebFeedIdFieldNumber = 1,
    kTitleFieldNumber = 2,
    kSubtitleFieldNumber = 3,
    kDetailTextFieldNumber = 4,
    kVisitUriFieldNumber = 5,
    kRssUriFieldNumber = 6,
    kFaviconFieldNumber = 7,
    kFollowerCountFieldNumber = 8,
    kStateFieldNumber = 9,
  };
  // repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
  int matchers_size() const;
  private:
  int _internal_matchers_size() const;
  public:
  void clear_matchers();
  ::feedwire::webfeed::WebFeedMatcher* mutable_matchers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >*
      mutable_matchers();
  private:
  const ::feedwire::webfeed::WebFeedMatcher& _internal_matchers(int index) const;
  ::feedwire::webfeed::WebFeedMatcher* _internal_add_matchers();
  public:
  const ::feedwire::webfeed::WebFeedMatcher& matchers(int index) const;
  ::feedwire::webfeed::WebFeedMatcher* add_matchers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >&
      matchers() const;

  // string web_feed_id = 1;
  void clear_web_feed_id();
  const std::string& web_feed_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_web_feed_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_web_feed_id();
  PROTOBUF_NODISCARD std::string* release_web_feed_id();
  void set_allocated_web_feed_id(std::string* web_feed_id);
  private:
  const std::string& _internal_web_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_feed_id(const std::string& value);
  std::string* _internal_mutable_web_feed_id();
  public:

  // string title = 2;
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string subtitle = 3;
  void clear_subtitle();
  const std::string& subtitle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_subtitle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_subtitle();
  PROTOBUF_NODISCARD std::string* release_subtitle();
  void set_allocated_subtitle(std::string* subtitle);
  private:
  const std::string& _internal_subtitle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_subtitle(const std::string& value);
  std::string* _internal_mutable_subtitle();
  public:

  // string detail_text = 4;
  void clear_detail_text();
  const std::string& detail_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_detail_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_detail_text();
  PROTOBUF_NODISCARD std::string* release_detail_text();
  void set_allocated_detail_text(std::string* detail_text);
  private:
  const std::string& _internal_detail_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_detail_text(const std::string& value);
  std::string* _internal_mutable_detail_text();
  public:

  // string visit_uri = 5;
  void clear_visit_uri();
  const std::string& visit_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_visit_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_visit_uri();
  PROTOBUF_NODISCARD std::string* release_visit_uri();
  void set_allocated_visit_uri(std::string* visit_uri);
  private:
  const std::string& _internal_visit_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_visit_uri(const std::string& value);
  std::string* _internal_mutable_visit_uri();
  public:

  // string rss_uri = 6;
  void clear_rss_uri();
  const std::string& rss_uri() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rss_uri(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rss_uri();
  PROTOBUF_NODISCARD std::string* release_rss_uri();
  void set_allocated_rss_uri(std::string* rss_uri);
  private:
  const std::string& _internal_rss_uri() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rss_uri(const std::string& value);
  std::string* _internal_mutable_rss_uri();
  public:

  // .feedstore.Image favicon = 7;
  bool has_favicon() const;
  private:
  bool _internal_has_favicon() const;
  public:
  void clear_favicon();
  const ::feedstore::Image& favicon() const;
  PROTOBUF_NODISCARD ::feedstore::Image* release_favicon();
  ::feedstore::Image* mutable_favicon();
  void set_allocated_favicon(::feedstore::Image* favicon);
  private:
  const ::feedstore::Image& _internal_favicon() const;
  ::feedstore::Image* _internal_mutable_favicon();
  public:
  void unsafe_arena_set_allocated_favicon(
      ::feedstore::Image* favicon);
  ::feedstore::Image* unsafe_arena_release_favicon();

  // int64 follower_count = 8;
  void clear_follower_count();
  int64_t follower_count() const;
  void set_follower_count(int64_t value);
  private:
  int64_t _internal_follower_count() const;
  void _internal_set_follower_count(int64_t value);
  public:

  // .feedstore.WebFeedInfo.State state = 9;
  void clear_state();
  ::feedstore::WebFeedInfo_State state() const;
  void set_state(::feedstore::WebFeedInfo_State value);
  private:
  ::feedstore::WebFeedInfo_State _internal_state() const;
  void _internal_set_state(::feedstore::WebFeedInfo_State value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.WebFeedInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher > matchers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_feed_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr subtitle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr detail_text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr visit_uri_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rss_uri_;
  ::feedstore::Image* favicon_;
  int64_t follower_count_;
  int state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// -------------------------------------------------------------------

class PendingWebFeedOperation final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:feedstore.PendingWebFeedOperation) */ {
 public:
  inline PendingWebFeedOperation() : PendingWebFeedOperation(nullptr) {}
  ~PendingWebFeedOperation() override;
  explicit PROTOBUF_CONSTEXPR PendingWebFeedOperation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PendingWebFeedOperation(const PendingWebFeedOperation& from);
  PendingWebFeedOperation(PendingWebFeedOperation&& from) noexcept
    : PendingWebFeedOperation() {
    *this = ::std::move(from);
  }

  inline PendingWebFeedOperation& operator=(const PendingWebFeedOperation& from) {
    CopyFrom(from);
    return *this;
  }
  inline PendingWebFeedOperation& operator=(PendingWebFeedOperation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const PendingWebFeedOperation& default_instance() {
    return *internal_default_instance();
  }
  static inline const PendingWebFeedOperation* internal_default_instance() {
    return reinterpret_cast<const PendingWebFeedOperation*>(
               &_PendingWebFeedOperation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(PendingWebFeedOperation& a, PendingWebFeedOperation& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PendingWebFeedOperation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PendingWebFeedOperation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PendingWebFeedOperation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PendingWebFeedOperation>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PendingWebFeedOperation& from);
  void MergeFrom(const PendingWebFeedOperation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PendingWebFeedOperation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "feedstore.PendingWebFeedOperation";
  }
  protected:
  explicit PendingWebFeedOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef PendingWebFeedOperation_Kind Kind;
  static constexpr Kind KIND_UNSPECIFIED =
    PendingWebFeedOperation_Kind_KIND_UNSPECIFIED;
  static constexpr Kind SUBSCRIBE =
    PendingWebFeedOperation_Kind_SUBSCRIBE;
  static constexpr Kind UNSUBSCRIBE =
    PendingWebFeedOperation_Kind_UNSUBSCRIBE;
  static inline bool Kind_IsValid(int value) {
    return PendingWebFeedOperation_Kind_IsValid(value);
  }
  static constexpr Kind Kind_MIN =
    PendingWebFeedOperation_Kind_Kind_MIN;
  static constexpr Kind Kind_MAX =
    PendingWebFeedOperation_Kind_Kind_MAX;
  static constexpr int Kind_ARRAYSIZE =
    PendingWebFeedOperation_Kind_Kind_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Kind_Name.");
    return PendingWebFeedOperation_Kind_Name(enum_t_value);
  }
  static inline bool Kind_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Kind* value) {
    return PendingWebFeedOperation_Kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kWebFeedIdFieldNumber = 3,
    kIdFieldNumber = 1,
    kKindFieldNumber = 2,
    kAttemptsFieldNumber = 4,
    kChangeReasonFieldNumber = 5,
  };
  // string web_feed_id = 3;
  void clear_web_feed_id();
  const std::string& web_feed_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_web_feed_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_web_feed_id();
  PROTOBUF_NODISCARD std::string* release_web_feed_id();
  void set_allocated_web_feed_id(std::string* web_feed_id);
  private:
  const std::string& _internal_web_feed_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_web_feed_id(const std::string& value);
  std::string* _internal_mutable_web_feed_id();
  public:

  // int64 id = 1;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // .feedstore.PendingWebFeedOperation.Kind kind = 2;
  void clear_kind();
  ::feedstore::PendingWebFeedOperation_Kind kind() const;
  void set_kind(::feedstore::PendingWebFeedOperation_Kind value);
  private:
  ::feedstore::PendingWebFeedOperation_Kind _internal_kind() const;
  void _internal_set_kind(::feedstore::PendingWebFeedOperation_Kind value);
  public:

  // int32 attempts = 4;
  void clear_attempts();
  int32_t attempts() const;
  void set_attempts(int32_t value);
  private:
  int32_t _internal_attempts() const;
  void _internal_set_attempts(int32_t value);
  public:

  // .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
  void clear_change_reason();
  ::feedwire::webfeed::WebFeedChangeReason change_reason() const;
  void set_change_reason(::feedwire::webfeed::WebFeedChangeReason value);
  private:
  ::feedwire::webfeed::WebFeedChangeReason _internal_change_reason() const;
  void _internal_set_change_reason(::feedwire::webfeed::WebFeedChangeReason value);
  public:

  // @@protoc_insertion_point(class_scope:feedstore.PendingWebFeedOperation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr web_feed_id_;
  int64_t id_;
  int kind_;
  int32_t attempts_;
  int change_reason_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Record

// .feedstore.StreamData stream_data = 1;
inline bool Record::_internal_has_stream_data() const {
  return data_case() == kStreamData;
}
inline bool Record::has_stream_data() const {
  return _internal_has_stream_data();
}
inline void Record::set_has_stream_data() {
  _oneof_case_[0] = kStreamData;
}
inline void Record::clear_stream_data() {
  if (_internal_has_stream_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.stream_data_;
    }
    clear_has_data();
  }
}
inline ::feedstore::StreamData* Record::release_stream_data() {
  // @@protoc_insertion_point(field_release:feedstore.Record.stream_data)
  if (_internal_has_stream_data()) {
    clear_has_data();
    ::feedstore::StreamData* temp = data_.stream_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.stream_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::StreamData& Record::_internal_stream_data() const {
  return _internal_has_stream_data()
      ? *data_.stream_data_
      : reinterpret_cast< ::feedstore::StreamData&>(::feedstore::_StreamData_default_instance_);
}
inline const ::feedstore::StreamData& Record::stream_data() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.stream_data)
  return _internal_stream_data();
}
inline ::feedstore::StreamData* Record::unsafe_arena_release_stream_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.stream_data)
  if (_internal_has_stream_data()) {
    clear_has_data();
    ::feedstore::StreamData* temp = data_.stream_data_;
    data_.stream_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_stream_data(::feedstore::StreamData* stream_data) {
  clear_data();
  if (stream_data) {
    set_has_stream_data();
    data_.stream_data_ = stream_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.stream_data)
}
inline ::feedstore::StreamData* Record::_internal_mutable_stream_data() {
  if (!_internal_has_stream_data()) {
    clear_data();
    set_has_stream_data();
    data_.stream_data_ = CreateMaybeMessage< ::feedstore::StreamData >(GetArenaForAllocation());
  }
  return data_.stream_data_;
}
inline ::feedstore::StreamData* Record::mutable_stream_data() {
  ::feedstore::StreamData* _msg = _internal_mutable_stream_data();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.stream_data)
  return _msg;
}

// .feedstore.StreamStructureSet stream_structures = 2;
inline bool Record::_internal_has_stream_structures() const {
  return data_case() == kStreamStructures;
}
inline bool Record::has_stream_structures() const {
  return _internal_has_stream_structures();
}
inline void Record::set_has_stream_structures() {
  _oneof_case_[0] = kStreamStructures;
}
inline void Record::clear_stream_structures() {
  if (_internal_has_stream_structures()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.stream_structures_;
    }
    clear_has_data();
  }
}
inline ::feedstore::StreamStructureSet* Record::release_stream_structures() {
  // @@protoc_insertion_point(field_release:feedstore.Record.stream_structures)
  if (_internal_has_stream_structures()) {
    clear_has_data();
    ::feedstore::StreamStructureSet* temp = data_.stream_structures_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.stream_structures_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::StreamStructureSet& Record::_internal_stream_structures() const {
  return _internal_has_stream_structures()
      ? *data_.stream_structures_
      : reinterpret_cast< ::feedstore::StreamStructureSet&>(::feedstore::_StreamStructureSet_default_instance_);
}
inline const ::feedstore::StreamStructureSet& Record::stream_structures() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.stream_structures)
  return _internal_stream_structures();
}
inline ::feedstore::StreamStructureSet* Record::unsafe_arena_release_stream_structures() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.stream_structures)
  if (_internal_has_stream_structures()) {
    clear_has_data();
    ::feedstore::StreamStructureSet* temp = data_.stream_structures_;
    data_.stream_structures_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_stream_structures(::feedstore::StreamStructureSet* stream_structures) {
  clear_data();
  if (stream_structures) {
    set_has_stream_structures();
    data_.stream_structures_ = stream_structures;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.stream_structures)
}
inline ::feedstore::StreamStructureSet* Record::_internal_mutable_stream_structures() {
  if (!_internal_has_stream_structures()) {
    clear_data();
    set_has_stream_structures();
    data_.stream_structures_ = CreateMaybeMessage< ::feedstore::StreamStructureSet >(GetArenaForAllocation());
  }
  return data_.stream_structures_;
}
inline ::feedstore::StreamStructureSet* Record::mutable_stream_structures() {
  ::feedstore::StreamStructureSet* _msg = _internal_mutable_stream_structures();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.stream_structures)
  return _msg;
}

// .feedstore.Content content = 3;
inline bool Record::_internal_has_content() const {
  return data_case() == kContent;
}
inline bool Record::has_content() const {
  return _internal_has_content();
}
inline void Record::set_has_content() {
  _oneof_case_[0] = kContent;
}
inline void Record::clear_content() {
  if (_internal_has_content()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.content_;
    }
    clear_has_data();
  }
}
inline ::feedstore::Content* Record::release_content() {
  // @@protoc_insertion_point(field_release:feedstore.Record.content)
  if (_internal_has_content()) {
    clear_has_data();
    ::feedstore::Content* temp = data_.content_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.content_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::Content& Record::_internal_content() const {
  return _internal_has_content()
      ? *data_.content_
      : reinterpret_cast< ::feedstore::Content&>(::feedstore::_Content_default_instance_);
}
inline const ::feedstore::Content& Record::content() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.content)
  return _internal_content();
}
inline ::feedstore::Content* Record::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.content)
  if (_internal_has_content()) {
    clear_has_data();
    ::feedstore::Content* temp = data_.content_;
    data_.content_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_content(::feedstore::Content* content) {
  clear_data();
  if (content) {
    set_has_content();
    data_.content_ = content;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.content)
}
inline ::feedstore::Content* Record::_internal_mutable_content() {
  if (!_internal_has_content()) {
    clear_data();
    set_has_content();
    data_.content_ = CreateMaybeMessage< ::feedstore::Content >(GetArenaForAllocation());
  }
  return data_.content_;
}
inline ::feedstore::Content* Record::mutable_content() {
  ::feedstore::Content* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.content)
  return _msg;
}

// .feedstore.StoredAction local_action = 4;
inline bool Record::_internal_has_local_action() const {
  return data_case() == kLocalAction;
}
inline bool Record::has_local_action() const {
  return _internal_has_local_action();
}
inline void Record::set_has_local_action() {
  _oneof_case_[0] = kLocalAction;
}
inline void Record::clear_local_action() {
  if (_internal_has_local_action()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.local_action_;
    }
    clear_has_data();
  }
}
inline ::feedstore::StoredAction* Record::release_local_action() {
  // @@protoc_insertion_point(field_release:feedstore.Record.local_action)
  if (_internal_has_local_action()) {
    clear_has_data();
    ::feedstore::StoredAction* temp = data_.local_action_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.local_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::StoredAction& Record::_internal_local_action() const {
  return _internal_has_local_action()
      ? *data_.local_action_
      : reinterpret_cast< ::feedstore::StoredAction&>(::feedstore::_StoredAction_default_instance_);
}
inline const ::feedstore::StoredAction& Record::local_action() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.local_action)
  return _internal_local_action();
}
inline ::feedstore::StoredAction* Record::unsafe_arena_release_local_action() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.local_action)
  if (_internal_has_local_action()) {
    clear_has_data();
    ::feedstore::StoredAction* temp = data_.local_action_;
    data_.local_action_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_local_action(::feedstore::StoredAction* local_action) {
  clear_data();
  if (local_action) {
    set_has_local_action();
    data_.local_action_ = local_action;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.local_action)
}
inline ::feedstore::StoredAction* Record::_internal_mutable_local_action() {
  if (!_internal_has_local_action()) {
    clear_data();
    set_has_local_action();
    data_.local_action_ = CreateMaybeMessage< ::feedstore::StoredAction >(GetArenaForAllocation());
  }
  return data_.local_action_;
}
inline ::feedstore::StoredAction* Record::mutable_local_action() {
  ::feedstore::StoredAction* _msg = _internal_mutable_local_action();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.local_action)
  return _msg;
}

// .feedstore.StreamSharedState shared_state = 5;
inline bool Record::_internal_has_shared_state() const {
  return data_case() == kSharedState;
}
inline bool Record::has_shared_state() const {
  return _internal_has_shared_state();
}
inline void Record::set_has_shared_state() {
  _oneof_case_[0] = kSharedState;
}
inline void Record::clear_shared_state() {
  if (_internal_has_shared_state()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.shared_state_;
    }
    clear_has_data();
  }
}
inline ::feedstore::StreamSharedState* Record::release_shared_state() {
  // @@protoc_insertion_point(field_release:feedstore.Record.shared_state)
  if (_internal_has_shared_state()) {
    clear_has_data();
    ::feedstore::StreamSharedState* temp = data_.shared_state_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.shared_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::StreamSharedState& Record::_internal_shared_state() const {
  return _internal_has_shared_state()
      ? *data_.shared_state_
      : reinterpret_cast< ::feedstore::StreamSharedState&>(::feedstore::_StreamSharedState_default_instance_);
}
inline const ::feedstore::StreamSharedState& Record::shared_state() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.shared_state)
  return _internal_shared_state();
}
inline ::feedstore::StreamSharedState* Record::unsafe_arena_release_shared_state() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.shared_state)
  if (_internal_has_shared_state()) {
    clear_has_data();
    ::feedstore::StreamSharedState* temp = data_.shared_state_;
    data_.shared_state_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_shared_state(::feedstore::StreamSharedState* shared_state) {
  clear_data();
  if (shared_state) {
    set_has_shared_state();
    data_.shared_state_ = shared_state;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.shared_state)
}
inline ::feedstore::StreamSharedState* Record::_internal_mutable_shared_state() {
  if (!_internal_has_shared_state()) {
    clear_data();
    set_has_shared_state();
    data_.shared_state_ = CreateMaybeMessage< ::feedstore::StreamSharedState >(GetArenaForAllocation());
  }
  return data_.shared_state_;
}
inline ::feedstore::StreamSharedState* Record::mutable_shared_state() {
  ::feedstore::StreamSharedState* _msg = _internal_mutable_shared_state();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.shared_state)
  return _msg;
}

// .feedstore.Metadata metadata = 6;
inline bool Record::_internal_has_metadata() const {
  return data_case() == kMetadata;
}
inline bool Record::has_metadata() const {
  return _internal_has_metadata();
}
inline void Record::set_has_metadata() {
  _oneof_case_[0] = kMetadata;
}
inline void Record::clear_metadata() {
  if (_internal_has_metadata()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.metadata_;
    }
    clear_has_data();
  }
}
inline ::feedstore::Metadata* Record::release_metadata() {
  // @@protoc_insertion_point(field_release:feedstore.Record.metadata)
  if (_internal_has_metadata()) {
    clear_has_data();
    ::feedstore::Metadata* temp = data_.metadata_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::Metadata& Record::_internal_metadata() const {
  return _internal_has_metadata()
      ? *data_.metadata_
      : reinterpret_cast< ::feedstore::Metadata&>(::feedstore::_Metadata_default_instance_);
}
inline const ::feedstore::Metadata& Record::metadata() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.metadata)
  return _internal_metadata();
}
inline ::feedstore::Metadata* Record::unsafe_arena_release_metadata() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.metadata)
  if (_internal_has_metadata()) {
    clear_has_data();
    ::feedstore::Metadata* temp = data_.metadata_;
    data_.metadata_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_metadata(::feedstore::Metadata* metadata) {
  clear_data();
  if (metadata) {
    set_has_metadata();
    data_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.metadata)
}
inline ::feedstore::Metadata* Record::_internal_mutable_metadata() {
  if (!_internal_has_metadata()) {
    clear_data();
    set_has_metadata();
    data_.metadata_ = CreateMaybeMessage< ::feedstore::Metadata >(GetArenaForAllocation());
  }
  return data_.metadata_;
}
inline ::feedstore::Metadata* Record::mutable_metadata() {
  ::feedstore::Metadata* _msg = _internal_mutable_metadata();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.metadata)
  return _msg;
}

// .feedstore.SubscribedWebFeeds subscribed_web_feeds = 7;
inline bool Record::_internal_has_subscribed_web_feeds() const {
  return data_case() == kSubscribedWebFeeds;
}
inline bool Record::has_subscribed_web_feeds() const {
  return _internal_has_subscribed_web_feeds();
}
inline void Record::set_has_subscribed_web_feeds() {
  _oneof_case_[0] = kSubscribedWebFeeds;
}
inline void Record::clear_subscribed_web_feeds() {
  if (_internal_has_subscribed_web_feeds()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.subscribed_web_feeds_;
    }
    clear_has_data();
  }
}
inline ::feedstore::SubscribedWebFeeds* Record::release_subscribed_web_feeds() {
  // @@protoc_insertion_point(field_release:feedstore.Record.subscribed_web_feeds)
  if (_internal_has_subscribed_web_feeds()) {
    clear_has_data();
    ::feedstore::SubscribedWebFeeds* temp = data_.subscribed_web_feeds_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.subscribed_web_feeds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::SubscribedWebFeeds& Record::_internal_subscribed_web_feeds() const {
  return _internal_has_subscribed_web_feeds()
      ? *data_.subscribed_web_feeds_
      : reinterpret_cast< ::feedstore::SubscribedWebFeeds&>(::feedstore::_SubscribedWebFeeds_default_instance_);
}
inline const ::feedstore::SubscribedWebFeeds& Record::subscribed_web_feeds() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.subscribed_web_feeds)
  return _internal_subscribed_web_feeds();
}
inline ::feedstore::SubscribedWebFeeds* Record::unsafe_arena_release_subscribed_web_feeds() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.subscribed_web_feeds)
  if (_internal_has_subscribed_web_feeds()) {
    clear_has_data();
    ::feedstore::SubscribedWebFeeds* temp = data_.subscribed_web_feeds_;
    data_.subscribed_web_feeds_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_subscribed_web_feeds(::feedstore::SubscribedWebFeeds* subscribed_web_feeds) {
  clear_data();
  if (subscribed_web_feeds) {
    set_has_subscribed_web_feeds();
    data_.subscribed_web_feeds_ = subscribed_web_feeds;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.subscribed_web_feeds)
}
inline ::feedstore::SubscribedWebFeeds* Record::_internal_mutable_subscribed_web_feeds() {
  if (!_internal_has_subscribed_web_feeds()) {
    clear_data();
    set_has_subscribed_web_feeds();
    data_.subscribed_web_feeds_ = CreateMaybeMessage< ::feedstore::SubscribedWebFeeds >(GetArenaForAllocation());
  }
  return data_.subscribed_web_feeds_;
}
inline ::feedstore::SubscribedWebFeeds* Record::mutable_subscribed_web_feeds() {
  ::feedstore::SubscribedWebFeeds* _msg = _internal_mutable_subscribed_web_feeds();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.subscribed_web_feeds)
  return _msg;
}

// .feedstore.WebFeedInfo recommended_web_feed = 8;
inline bool Record::_internal_has_recommended_web_feed() const {
  return data_case() == kRecommendedWebFeed;
}
inline bool Record::has_recommended_web_feed() const {
  return _internal_has_recommended_web_feed();
}
inline void Record::set_has_recommended_web_feed() {
  _oneof_case_[0] = kRecommendedWebFeed;
}
inline void Record::clear_recommended_web_feed() {
  if (_internal_has_recommended_web_feed()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.recommended_web_feed_;
    }
    clear_has_data();
  }
}
inline ::feedstore::WebFeedInfo* Record::release_recommended_web_feed() {
  // @@protoc_insertion_point(field_release:feedstore.Record.recommended_web_feed)
  if (_internal_has_recommended_web_feed()) {
    clear_has_data();
    ::feedstore::WebFeedInfo* temp = data_.recommended_web_feed_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.recommended_web_feed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::WebFeedInfo& Record::_internal_recommended_web_feed() const {
  return _internal_has_recommended_web_feed()
      ? *data_.recommended_web_feed_
      : reinterpret_cast< ::feedstore::WebFeedInfo&>(::feedstore::_WebFeedInfo_default_instance_);
}
inline const ::feedstore::WebFeedInfo& Record::recommended_web_feed() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.recommended_web_feed)
  return _internal_recommended_web_feed();
}
inline ::feedstore::WebFeedInfo* Record::unsafe_arena_release_recommended_web_feed() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.recommended_web_feed)
  if (_internal_has_recommended_web_feed()) {
    clear_has_data();
    ::feedstore::WebFeedInfo* temp = data_.recommended_web_feed_;
    data_.recommended_web_feed_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_recommended_web_feed(::feedstore::WebFeedInfo* recommended_web_feed) {
  clear_data();
  if (recommended_web_feed) {
    set_has_recommended_web_feed();
    data_.recommended_web_feed_ = recommended_web_feed;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.recommended_web_feed)
}
inline ::feedstore::WebFeedInfo* Record::_internal_mutable_recommended_web_feed() {
  if (!_internal_has_recommended_web_feed()) {
    clear_data();
    set_has_recommended_web_feed();
    data_.recommended_web_feed_ = CreateMaybeMessage< ::feedstore::WebFeedInfo >(GetArenaForAllocation());
  }
  return data_.recommended_web_feed_;
}
inline ::feedstore::WebFeedInfo* Record::mutable_recommended_web_feed() {
  ::feedstore::WebFeedInfo* _msg = _internal_mutable_recommended_web_feed();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.recommended_web_feed)
  return _msg;
}

// .feedstore.RecommendedWebFeedIndex recommended_web_feed_index = 9;
inline bool Record::_internal_has_recommended_web_feed_index() const {
  return data_case() == kRecommendedWebFeedIndex;
}
inline bool Record::has_recommended_web_feed_index() const {
  return _internal_has_recommended_web_feed_index();
}
inline void Record::set_has_recommended_web_feed_index() {
  _oneof_case_[0] = kRecommendedWebFeedIndex;
}
inline void Record::clear_recommended_web_feed_index() {
  if (_internal_has_recommended_web_feed_index()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.recommended_web_feed_index_;
    }
    clear_has_data();
  }
}
inline ::feedstore::RecommendedWebFeedIndex* Record::release_recommended_web_feed_index() {
  // @@protoc_insertion_point(field_release:feedstore.Record.recommended_web_feed_index)
  if (_internal_has_recommended_web_feed_index()) {
    clear_has_data();
    ::feedstore::RecommendedWebFeedIndex* temp = data_.recommended_web_feed_index_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.recommended_web_feed_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::RecommendedWebFeedIndex& Record::_internal_recommended_web_feed_index() const {
  return _internal_has_recommended_web_feed_index()
      ? *data_.recommended_web_feed_index_
      : reinterpret_cast< ::feedstore::RecommendedWebFeedIndex&>(::feedstore::_RecommendedWebFeedIndex_default_instance_);
}
inline const ::feedstore::RecommendedWebFeedIndex& Record::recommended_web_feed_index() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.recommended_web_feed_index)
  return _internal_recommended_web_feed_index();
}
inline ::feedstore::RecommendedWebFeedIndex* Record::unsafe_arena_release_recommended_web_feed_index() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.recommended_web_feed_index)
  if (_internal_has_recommended_web_feed_index()) {
    clear_has_data();
    ::feedstore::RecommendedWebFeedIndex* temp = data_.recommended_web_feed_index_;
    data_.recommended_web_feed_index_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_recommended_web_feed_index(::feedstore::RecommendedWebFeedIndex* recommended_web_feed_index) {
  clear_data();
  if (recommended_web_feed_index) {
    set_has_recommended_web_feed_index();
    data_.recommended_web_feed_index_ = recommended_web_feed_index;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.recommended_web_feed_index)
}
inline ::feedstore::RecommendedWebFeedIndex* Record::_internal_mutable_recommended_web_feed_index() {
  if (!_internal_has_recommended_web_feed_index()) {
    clear_data();
    set_has_recommended_web_feed_index();
    data_.recommended_web_feed_index_ = CreateMaybeMessage< ::feedstore::RecommendedWebFeedIndex >(GetArenaForAllocation());
  }
  return data_.recommended_web_feed_index_;
}
inline ::feedstore::RecommendedWebFeedIndex* Record::mutable_recommended_web_feed_index() {
  ::feedstore::RecommendedWebFeedIndex* _msg = _internal_mutable_recommended_web_feed_index();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.recommended_web_feed_index)
  return _msg;
}

// .feedstore.PendingWebFeedOperation pending_web_feed_operation = 10;
inline bool Record::_internal_has_pending_web_feed_operation() const {
  return data_case() == kPendingWebFeedOperation;
}
inline bool Record::has_pending_web_feed_operation() const {
  return _internal_has_pending_web_feed_operation();
}
inline void Record::set_has_pending_web_feed_operation() {
  _oneof_case_[0] = kPendingWebFeedOperation;
}
inline void Record::clear_pending_web_feed_operation() {
  if (_internal_has_pending_web_feed_operation()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.pending_web_feed_operation_;
    }
    clear_has_data();
  }
}
inline ::feedstore::PendingWebFeedOperation* Record::release_pending_web_feed_operation() {
  // @@protoc_insertion_point(field_release:feedstore.Record.pending_web_feed_operation)
  if (_internal_has_pending_web_feed_operation()) {
    clear_has_data();
    ::feedstore::PendingWebFeedOperation* temp = data_.pending_web_feed_operation_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.pending_web_feed_operation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::feedstore::PendingWebFeedOperation& Record::_internal_pending_web_feed_operation() const {
  return _internal_has_pending_web_feed_operation()
      ? *data_.pending_web_feed_operation_
      : reinterpret_cast< ::feedstore::PendingWebFeedOperation&>(::feedstore::_PendingWebFeedOperation_default_instance_);
}
inline const ::feedstore::PendingWebFeedOperation& Record::pending_web_feed_operation() const {
  // @@protoc_insertion_point(field_get:feedstore.Record.pending_web_feed_operation)
  return _internal_pending_web_feed_operation();
}
inline ::feedstore::PendingWebFeedOperation* Record::unsafe_arena_release_pending_web_feed_operation() {
  // @@protoc_insertion_point(field_unsafe_arena_release:feedstore.Record.pending_web_feed_operation)
  if (_internal_has_pending_web_feed_operation()) {
    clear_has_data();
    ::feedstore::PendingWebFeedOperation* temp = data_.pending_web_feed_operation_;
    data_.pending_web_feed_operation_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Record::unsafe_arena_set_allocated_pending_web_feed_operation(::feedstore::PendingWebFeedOperation* pending_web_feed_operation) {
  clear_data();
  if (pending_web_feed_operation) {
    set_has_pending_web_feed_operation();
    data_.pending_web_feed_operation_ = pending_web_feed_operation;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Record.pending_web_feed_operation)
}
inline ::feedstore::PendingWebFeedOperation* Record::_internal_mutable_pending_web_feed_operation() {
  if (!_internal_has_pending_web_feed_operation()) {
    clear_data();
    set_has_pending_web_feed_operation();
    data_.pending_web_feed_operation_ = CreateMaybeMessage< ::feedstore::PendingWebFeedOperation >(GetArenaForAllocation());
  }
  return data_.pending_web_feed_operation_;
}
inline ::feedstore::PendingWebFeedOperation* Record::mutable_pending_web_feed_operation() {
  ::feedstore::PendingWebFeedOperation* _msg = _internal_mutable_pending_web_feed_operation();
  // @@protoc_insertion_point(field_mutable:feedstore.Record.pending_web_feed_operation)
  return _msg;
}

inline bool Record::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Record::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Record::DataCase Record::data_case() const {
  return Record::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StreamData

// .feedwire.ContentId content_id = 1;
inline bool StreamData::_internal_has_content_id() const {
  return this != internal_default_instance() && content_id_ != nullptr;
}
inline bool StreamData::has_content_id() const {
  return _internal_has_content_id();
}
inline const ::feedwire::ContentId& StreamData::_internal_content_id() const {
  const ::feedwire::ContentId* p = content_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(
      ::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamData::content_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.content_id)
  return _internal_content_id();
}
inline void StreamData::unsafe_arena_set_allocated_content_id(
    ::feedwire::ContentId* content_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  content_id_ = content_id;
  if (content_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamData.content_id)
}
inline ::feedwire::ContentId* StreamData::release_content_id() {
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedwire::ContentId* StreamData::unsafe_arena_release_content_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamData.content_id)
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
  return temp;
}
inline ::feedwire::ContentId* StreamData::_internal_mutable_content_id() {
  
  if (content_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
    content_id_ = p;
  }
  return content_id_;
}
inline ::feedwire::ContentId* StreamData::mutable_content_id() {
  ::feedwire::ContentId* _msg = _internal_mutable_content_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.content_id)
  return _msg;
}
inline void StreamData::set_allocated_content_id(::feedwire::ContentId* content_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  if (content_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
    if (message_arena != submessage_arena) {
      content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_id, submessage_arena);
    }
    
  } else {
    
  }
  content_id_ = content_id;
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.content_id)
}

// bytes next_page_token = 2;
inline void StreamData::clear_next_page_token() {
  next_page_token_.ClearToEmpty();
}
inline const std::string& StreamData::next_page_token() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.next_page_token)
  return _internal_next_page_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamData::set_next_page_token(ArgT0&& arg0, ArgT... args) {
 
 next_page_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamData.next_page_token)
}
inline std::string* StreamData::mutable_next_page_token() {
  std::string* _s = _internal_mutable_next_page_token();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.next_page_token)
  return _s;
}
inline const std::string& StreamData::_internal_next_page_token() const {
  return next_page_token_.Get();
}
inline void StreamData::_internal_set_next_page_token(const std::string& value) {
  
  next_page_token_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_next_page_token() {
  
  return next_page_token_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_next_page_token() {
  // @@protoc_insertion_point(field_release:feedstore.StreamData.next_page_token)
  return next_page_token_.Release();
}
inline void StreamData::set_allocated_next_page_token(std::string* next_page_token) {
  if (next_page_token != nullptr) {
    
  } else {
    
  }
  next_page_token_.SetAllocated(next_page_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (next_page_token_.IsDefault()) {
    next_page_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.next_page_token)
}

// int64 last_added_time_millis = 4;
inline void StreamData::clear_last_added_time_millis() {
  last_added_time_millis_ = int64_t{0};
}
inline int64_t StreamData::_internal_last_added_time_millis() const {
  return last_added_time_millis_;
}
inline int64_t StreamData::last_added_time_millis() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.last_added_time_millis)
  return _internal_last_added_time_millis();
}
inline void StreamData::_internal_set_last_added_time_millis(int64_t value) {
  
  last_added_time_millis_ = value;
}
inline void StreamData::set_last_added_time_millis(int64_t value) {
  _internal_set_last_added_time_millis(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamData.last_added_time_millis)
}

// repeated .feedwire.ContentId shared_state_ids = 6;
inline int StreamData::_internal_shared_state_ids_size() const {
  return shared_state_ids_.size();
}
inline int StreamData::shared_state_ids_size() const {
  return _internal_shared_state_ids_size();
}
inline ::feedwire::ContentId* StreamData::mutable_shared_state_ids(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.shared_state_ids)
  return shared_state_ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::ContentId >*
StreamData::mutable_shared_state_ids() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.StreamData.shared_state_ids)
  return &shared_state_ids_;
}
inline const ::feedwire::ContentId& StreamData::_internal_shared_state_ids(int index) const {
  return shared_state_ids_.Get(index);
}
inline const ::feedwire::ContentId& StreamData::shared_state_ids(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.shared_state_ids)
  return _internal_shared_state_ids(index);
}
inline ::feedwire::ContentId* StreamData::_internal_add_shared_state_ids() {
  return shared_state_ids_.Add();
}
inline ::feedwire::ContentId* StreamData::add_shared_state_ids() {
  ::feedwire::ContentId* _add = _internal_add_shared_state_ids();
  // @@protoc_insertion_point(field_add:feedstore.StreamData.shared_state_ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::ContentId >&
StreamData::shared_state_ids() const {
  // @@protoc_insertion_point(field_list:feedstore.StreamData.shared_state_ids)
  return shared_state_ids_;
}

// bool signed_in = 7;
inline void StreamData::clear_signed_in() {
  signed_in_ = false;
}
inline bool StreamData::_internal_signed_in() const {
  return signed_in_;
}
inline bool StreamData::signed_in() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.signed_in)
  return _internal_signed_in();
}
inline void StreamData::_internal_set_signed_in(bool value) {
  
  signed_in_ = value;
}
inline void StreamData::set_signed_in(bool value) {
  _internal_set_signed_in(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamData.signed_in)
}

// string gaia = 13;
inline void StreamData::clear_gaia() {
  gaia_.ClearToEmpty();
}
inline const std::string& StreamData::gaia() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.gaia)
  return _internal_gaia();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamData::set_gaia(ArgT0&& arg0, ArgT... args) {
 
 gaia_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamData.gaia)
}
inline std::string* StreamData::mutable_gaia() {
  std::string* _s = _internal_mutable_gaia();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.gaia)
  return _s;
}
inline const std::string& StreamData::_internal_gaia() const {
  return gaia_.Get();
}
inline void StreamData::_internal_set_gaia(const std::string& value) {
  
  gaia_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_gaia() {
  
  return gaia_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_gaia() {
  // @@protoc_insertion_point(field_release:feedstore.StreamData.gaia)
  return gaia_.Release();
}
inline void StreamData::set_allocated_gaia(std::string* gaia) {
  if (gaia != nullptr) {
    
  } else {
    
  }
  gaia_.SetAllocated(gaia, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gaia_.IsDefault()) {
    gaia_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.gaia)
}

// string email = 14;
inline void StreamData::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& StreamData::email() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.email)
  return _internal_email();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamData::set_email(ArgT0&& arg0, ArgT... args) {
 
 email_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamData.email)
}
inline std::string* StreamData::mutable_email() {
  std::string* _s = _internal_mutable_email();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.email)
  return _s;
}
inline const std::string& StreamData::_internal_email() const {
  return email_.Get();
}
inline void StreamData::_internal_set_email(const std::string& value) {
  
  email_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_email() {
  
  return email_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_email() {
  // @@protoc_insertion_point(field_release:feedstore.StreamData.email)
  return email_.Release();
}
inline void StreamData::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(email, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (email_.IsDefault()) {
    email_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.email)
}

// bool logging_enabled = 8;
inline void StreamData::clear_logging_enabled() {
  logging_enabled_ = false;
}
inline bool StreamData::_internal_logging_enabled() const {
  return logging_enabled_;
}
inline bool StreamData::logging_enabled() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.logging_enabled)
  return _internal_logging_enabled();
}
inline void StreamData::_internal_set_logging_enabled(bool value) {
  
  logging_enabled_ = value;
}
inline void StreamData::set_logging_enabled(bool value) {
  _internal_set_logging_enabled(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamData.logging_enabled)
}

// bool privacy_notice_fulfilled = 9;
inline void StreamData::clear_privacy_notice_fulfilled() {
  privacy_notice_fulfilled_ = false;
}
inline bool StreamData::_internal_privacy_notice_fulfilled() const {
  return privacy_notice_fulfilled_;
}
inline bool StreamData::privacy_notice_fulfilled() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.privacy_notice_fulfilled)
  return _internal_privacy_notice_fulfilled();
}
inline void StreamData::_internal_set_privacy_notice_fulfilled(bool value) {
  
  privacy_notice_fulfilled_ = value;
}
inline void StreamData::set_privacy_notice_fulfilled(bool value) {
  _internal_set_privacy_notice_fulfilled(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamData.privacy_notice_fulfilled)
}

// string stream_id = 10;
inline void StreamData::clear_stream_id() {
  stream_id_.ClearToEmpty();
}
inline const std::string& StreamData::stream_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamData::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamData.stream_id)
}
inline std::string* StreamData::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.stream_id)
  return _s;
}
inline const std::string& StreamData::_internal_stream_id() const {
  return stream_id_.Get();
}
inline void StreamData::_internal_set_stream_id(const std::string& value) {
  
  stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_stream_id() {
  
  return stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_stream_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamData.stream_id)
  return stream_id_.Release();
}
inline void StreamData::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stream_id_.IsDefault()) {
    stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.stream_id)
}

// repeated uint32 content_hashes = 11;
inline int StreamData::_internal_content_hashes_size() const {
  return content_hashes_.size();
}
inline int StreamData::content_hashes_size() const {
  return _internal_content_hashes_size();
}
inline void StreamData::clear_content_hashes() {
  content_hashes_.Clear();
}
inline uint32_t StreamData::_internal_content_hashes(int index) const {
  return content_hashes_.Get(index);
}
inline uint32_t StreamData::content_hashes(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.content_hashes)
  return _internal_content_hashes(index);
}
inline void StreamData::set_content_hashes(int index, uint32_t value) {
  content_hashes_.Set(index, value);
  // @@protoc_insertion_point(field_set:feedstore.StreamData.content_hashes)
}
inline void StreamData::_internal_add_content_hashes(uint32_t value) {
  content_hashes_.Add(value);
}
inline void StreamData::add_content_hashes(uint32_t value) {
  _internal_add_content_hashes(value);
  // @@protoc_insertion_point(field_add:feedstore.StreamData.content_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StreamData::_internal_content_hashes() const {
  return content_hashes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StreamData::content_hashes() const {
  // @@protoc_insertion_point(field_list:feedstore.StreamData.content_hashes)
  return _internal_content_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StreamData::_internal_mutable_content_hashes() {
  return &content_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StreamData::mutable_content_hashes() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.StreamData.content_hashes)
  return _internal_mutable_content_hashes();
}

// bytes root_event_id = 12;
inline void StreamData::clear_root_event_id() {
  root_event_id_.ClearToEmpty();
}
inline const std::string& StreamData::root_event_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamData.root_event_id)
  return _internal_root_event_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamData::set_root_event_id(ArgT0&& arg0, ArgT... args) {
 
 root_event_id_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamData.root_event_id)
}
inline std::string* StreamData::mutable_root_event_id() {
  std::string* _s = _internal_mutable_root_event_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamData.root_event_id)
  return _s;
}
inline const std::string& StreamData::_internal_root_event_id() const {
  return root_event_id_.Get();
}
inline void StreamData::_internal_set_root_event_id(const std::string& value) {
  
  root_event_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamData::_internal_mutable_root_event_id() {
  
  return root_event_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamData::release_root_event_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamData.root_event_id)
  return root_event_id_.Release();
}
inline void StreamData::set_allocated_root_event_id(std::string* root_event_id) {
  if (root_event_id != nullptr) {
    
  } else {
    
  }
  root_event_id_.SetAllocated(root_event_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (root_event_id_.IsDefault()) {
    root_event_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamData.root_event_id)
}

// -------------------------------------------------------------------

// Metadata_SessionID

// string token = 1;
inline void Metadata_SessionID::clear_token() {
  token_.ClearToEmpty();
}
inline const std::string& Metadata_SessionID::token() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.SessionID.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata_SessionID::set_token(ArgT0&& arg0, ArgT... args) {
 
 token_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Metadata.SessionID.token)
}
inline std::string* Metadata_SessionID::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.SessionID.token)
  return _s;
}
inline const std::string& Metadata_SessionID::_internal_token() const {
  return token_.Get();
}
inline void Metadata_SessionID::_internal_set_token(const std::string& value) {
  
  token_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata_SessionID::_internal_mutable_token() {
  
  return token_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata_SessionID::release_token() {
  // @@protoc_insertion_point(field_release:feedstore.Metadata.SessionID.token)
  return token_.Release();
}
inline void Metadata_SessionID::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocated(token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault()) {
    token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.SessionID.token)
}

// int64 expiry_time_ms = 2;
inline void Metadata_SessionID::clear_expiry_time_ms() {
  expiry_time_ms_ = int64_t{0};
}
inline int64_t Metadata_SessionID::_internal_expiry_time_ms() const {
  return expiry_time_ms_;
}
inline int64_t Metadata_SessionID::expiry_time_ms() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.SessionID.expiry_time_ms)
  return _internal_expiry_time_ms();
}
inline void Metadata_SessionID::_internal_set_expiry_time_ms(int64_t value) {
  
  expiry_time_ms_ = value;
}
inline void Metadata_SessionID::set_expiry_time_ms(int64_t value) {
  _internal_set_expiry_time_ms(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.SessionID.expiry_time_ms)
}

// -------------------------------------------------------------------

// Metadata_StreamMetadata_ContentLifetime

// int64 stale_age_ms = 1;
inline void Metadata_StreamMetadata_ContentLifetime::clear_stale_age_ms() {
  stale_age_ms_ = int64_t{0};
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::_internal_stale_age_ms() const {
  return stale_age_ms_;
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::stale_age_ms() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.ContentLifetime.stale_age_ms)
  return _internal_stale_age_ms();
}
inline void Metadata_StreamMetadata_ContentLifetime::_internal_set_stale_age_ms(int64_t value) {
  
  stale_age_ms_ = value;
}
inline void Metadata_StreamMetadata_ContentLifetime::set_stale_age_ms(int64_t value) {
  _internal_set_stale_age_ms(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.ContentLifetime.stale_age_ms)
}

// int64 invalid_age_ms = 2;
inline void Metadata_StreamMetadata_ContentLifetime::clear_invalid_age_ms() {
  invalid_age_ms_ = int64_t{0};
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::_internal_invalid_age_ms() const {
  return invalid_age_ms_;
}
inline int64_t Metadata_StreamMetadata_ContentLifetime::invalid_age_ms() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.ContentLifetime.invalid_age_ms)
  return _internal_invalid_age_ms();
}
inline void Metadata_StreamMetadata_ContentLifetime::_internal_set_invalid_age_ms(int64_t value) {
  
  invalid_age_ms_ = value;
}
inline void Metadata_StreamMetadata_ContentLifetime::set_invalid_age_ms(int64_t value) {
  _internal_set_invalid_age_ms(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.ContentLifetime.invalid_age_ms)
}

// -------------------------------------------------------------------

// Metadata_StreamMetadata

// string stream_id = 1;
inline void Metadata_StreamMetadata::clear_stream_id() {
  stream_id_.ClearToEmpty();
}
inline const std::string& Metadata_StreamMetadata::stream_id() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata_StreamMetadata::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.stream_id)
}
inline std::string* Metadata_StreamMetadata::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.StreamMetadata.stream_id)
  return _s;
}
inline const std::string& Metadata_StreamMetadata::_internal_stream_id() const {
  return stream_id_.Get();
}
inline void Metadata_StreamMetadata::_internal_set_stream_id(const std::string& value) {
  
  stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata_StreamMetadata::_internal_mutable_stream_id() {
  
  return stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata_StreamMetadata::release_stream_id() {
  // @@protoc_insertion_point(field_release:feedstore.Metadata.StreamMetadata.stream_id)
  return stream_id_.Release();
}
inline void Metadata_StreamMetadata::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stream_id_.IsDefault()) {
    stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.StreamMetadata.stream_id)
}

// bool is_known_stale = 3;
inline void Metadata_StreamMetadata::clear_is_known_stale() {
  is_known_stale_ = false;
}
inline bool Metadata_StreamMetadata::_internal_is_known_stale() const {
  return is_known_stale_;
}
inline bool Metadata_StreamMetadata::is_known_stale() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.is_known_stale)
  return _internal_is_known_stale();
}
inline void Metadata_StreamMetadata::_internal_set_is_known_stale(bool value) {
  
  is_known_stale_ = value;
}
inline void Metadata_StreamMetadata::set_is_known_stale(bool value) {
  _internal_set_is_known_stale(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.is_known_stale)
}

// repeated uint32 view_content_hashes = 4;
inline int Metadata_StreamMetadata::_internal_view_content_hashes_size() const {
  return view_content_hashes_.size();
}
inline int Metadata_StreamMetadata::view_content_hashes_size() const {
  return _internal_view_content_hashes_size();
}
inline void Metadata_StreamMetadata::clear_view_content_hashes() {
  view_content_hashes_.Clear();
}
inline uint32_t Metadata_StreamMetadata::_internal_view_content_hashes(int index) const {
  return view_content_hashes_.Get(index);
}
inline uint32_t Metadata_StreamMetadata::view_content_hashes(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.view_content_hashes)
  return _internal_view_content_hashes(index);
}
inline void Metadata_StreamMetadata::set_view_content_hashes(int index, uint32_t value) {
  view_content_hashes_.Set(index, value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.view_content_hashes)
}
inline void Metadata_StreamMetadata::_internal_add_view_content_hashes(uint32_t value) {
  view_content_hashes_.Add(value);
}
inline void Metadata_StreamMetadata::add_view_content_hashes(uint32_t value) {
  _internal_add_view_content_hashes(value);
  // @@protoc_insertion_point(field_add:feedstore.Metadata.StreamMetadata.view_content_hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Metadata_StreamMetadata::_internal_view_content_hashes() const {
  return view_content_hashes_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
Metadata_StreamMetadata::view_content_hashes() const {
  // @@protoc_insertion_point(field_list:feedstore.Metadata.StreamMetadata.view_content_hashes)
  return _internal_view_content_hashes();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Metadata_StreamMetadata::_internal_mutable_view_content_hashes() {
  return &view_content_hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
Metadata_StreamMetadata::mutable_view_content_hashes() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.Metadata.StreamMetadata.view_content_hashes)
  return _internal_mutable_view_content_hashes();
}

// .feedstore.Metadata.StreamMetadata.ContentLifetime content_lifetime = 5;
inline bool Metadata_StreamMetadata::_internal_has_content_lifetime() const {
  return this != internal_default_instance() && content_lifetime_ != nullptr;
}
inline bool Metadata_StreamMetadata::has_content_lifetime() const {
  return _internal_has_content_lifetime();
}
inline void Metadata_StreamMetadata::clear_content_lifetime() {
  if (GetArenaForAllocation() == nullptr && content_lifetime_ != nullptr) {
    delete content_lifetime_;
  }
  content_lifetime_ = nullptr;
}
inline const ::feedstore::Metadata_StreamMetadata_ContentLifetime& Metadata_StreamMetadata::_internal_content_lifetime() const {
  const ::feedstore::Metadata_StreamMetadata_ContentLifetime* p = content_lifetime_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Metadata_StreamMetadata_ContentLifetime&>(
      ::feedstore::_Metadata_StreamMetadata_ContentLifetime_default_instance_);
}
inline const ::feedstore::Metadata_StreamMetadata_ContentLifetime& Metadata_StreamMetadata::content_lifetime() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.content_lifetime)
  return _internal_content_lifetime();
}
inline void Metadata_StreamMetadata::unsafe_arena_set_allocated_content_lifetime(
    ::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_lifetime_);
  }
  content_lifetime_ = content_lifetime;
  if (content_lifetime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Metadata.StreamMetadata.content_lifetime)
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::release_content_lifetime() {
  
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* temp = content_lifetime_;
  content_lifetime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::unsafe_arena_release_content_lifetime() {
  // @@protoc_insertion_point(field_release:feedstore.Metadata.StreamMetadata.content_lifetime)
  
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* temp = content_lifetime_;
  content_lifetime_ = nullptr;
  return temp;
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::_internal_mutable_content_lifetime() {
  
  if (content_lifetime_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedstore::Metadata_StreamMetadata_ContentLifetime>(GetArenaForAllocation());
    content_lifetime_ = p;
  }
  return content_lifetime_;
}
inline ::feedstore::Metadata_StreamMetadata_ContentLifetime* Metadata_StreamMetadata::mutable_content_lifetime() {
  ::feedstore::Metadata_StreamMetadata_ContentLifetime* _msg = _internal_mutable_content_lifetime();
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.StreamMetadata.content_lifetime)
  return _msg;
}
inline void Metadata_StreamMetadata::set_allocated_content_lifetime(::feedstore::Metadata_StreamMetadata_ContentLifetime* content_lifetime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete content_lifetime_;
  }
  if (content_lifetime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content_lifetime);
    if (message_arena != submessage_arena) {
      content_lifetime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_lifetime, submessage_arena);
    }
    
  } else {
    
  }
  content_lifetime_ = content_lifetime;
  // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.StreamMetadata.content_lifetime)
}

// int64 last_fetch_time_millis = 6;
inline void Metadata_StreamMetadata::clear_last_fetch_time_millis() {
  last_fetch_time_millis_ = int64_t{0};
}
inline int64_t Metadata_StreamMetadata::_internal_last_fetch_time_millis() const {
  return last_fetch_time_millis_;
}
inline int64_t Metadata_StreamMetadata::last_fetch_time_millis() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.last_fetch_time_millis)
  return _internal_last_fetch_time_millis();
}
inline void Metadata_StreamMetadata::_internal_set_last_fetch_time_millis(int64_t value) {
  
  last_fetch_time_millis_ = value;
}
inline void Metadata_StreamMetadata::set_last_fetch_time_millis(int64_t value) {
  _internal_set_last_fetch_time_millis(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.last_fetch_time_millis)
}

// int64 last_server_response_time_millis = 7;
inline void Metadata_StreamMetadata::clear_last_server_response_time_millis() {
  last_server_response_time_millis_ = int64_t{0};
}
inline int64_t Metadata_StreamMetadata::_internal_last_server_response_time_millis() const {
  return last_server_response_time_millis_;
}
inline int64_t Metadata_StreamMetadata::last_server_response_time_millis() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.StreamMetadata.last_server_response_time_millis)
  return _internal_last_server_response_time_millis();
}
inline void Metadata_StreamMetadata::_internal_set_last_server_response_time_millis(int64_t value) {
  
  last_server_response_time_millis_ = value;
}
inline void Metadata_StreamMetadata::set_last_server_response_time_millis(int64_t value) {
  _internal_set_last_server_response_time_millis(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.StreamMetadata.last_server_response_time_millis)
}

// -------------------------------------------------------------------

// Metadata

// bytes consistency_token = 1;
inline void Metadata::clear_consistency_token() {
  consistency_token_.ClearToEmpty();
}
inline const std::string& Metadata::consistency_token() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.consistency_token)
  return _internal_consistency_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_consistency_token(ArgT0&& arg0, ArgT... args) {
 
 consistency_token_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Metadata.consistency_token)
}
inline std::string* Metadata::mutable_consistency_token() {
  std::string* _s = _internal_mutable_consistency_token();
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.consistency_token)
  return _s;
}
inline const std::string& Metadata::_internal_consistency_token() const {
  return consistency_token_.Get();
}
inline void Metadata::_internal_set_consistency_token(const std::string& value) {
  
  consistency_token_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_consistency_token() {
  
  return consistency_token_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_consistency_token() {
  // @@protoc_insertion_point(field_release:feedstore.Metadata.consistency_token)
  return consistency_token_.Release();
}
inline void Metadata::set_allocated_consistency_token(std::string* consistency_token) {
  if (consistency_token != nullptr) {
    
  } else {
    
  }
  consistency_token_.SetAllocated(consistency_token, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (consistency_token_.IsDefault()) {
    consistency_token_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.consistency_token)
}

// int32 next_action_id = 2;
inline void Metadata::clear_next_action_id() {
  next_action_id_ = 0;
}
inline int32_t Metadata::_internal_next_action_id() const {
  return next_action_id_;
}
inline int32_t Metadata::next_action_id() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.next_action_id)
  return _internal_next_action_id();
}
inline void Metadata::_internal_set_next_action_id(int32_t value) {
  
  next_action_id_ = value;
}
inline void Metadata::set_next_action_id(int32_t value) {
  _internal_set_next_action_id(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.next_action_id)
}

// .feedstore.Metadata.SessionID session_id = 3;
inline bool Metadata::_internal_has_session_id() const {
  return this != internal_default_instance() && session_id_ != nullptr;
}
inline bool Metadata::has_session_id() const {
  return _internal_has_session_id();
}
inline void Metadata::clear_session_id() {
  if (GetArenaForAllocation() == nullptr && session_id_ != nullptr) {
    delete session_id_;
  }
  session_id_ = nullptr;
}
inline const ::feedstore::Metadata_SessionID& Metadata::_internal_session_id() const {
  const ::feedstore::Metadata_SessionID* p = session_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Metadata_SessionID&>(
      ::feedstore::_Metadata_SessionID_default_instance_);
}
inline const ::feedstore::Metadata_SessionID& Metadata::session_id() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.session_id)
  return _internal_session_id();
}
inline void Metadata::unsafe_arena_set_allocated_session_id(
    ::feedstore::Metadata_SessionID* session_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(session_id_);
  }
  session_id_ = session_id;
  if (session_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Metadata.session_id)
}
inline ::feedstore::Metadata_SessionID* Metadata::release_session_id() {
  
  ::feedstore::Metadata_SessionID* temp = session_id_;
  session_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedstore::Metadata_SessionID* Metadata::unsafe_arena_release_session_id() {
  // @@protoc_insertion_point(field_release:feedstore.Metadata.session_id)
  
  ::feedstore::Metadata_SessionID* temp = session_id_;
  session_id_ = nullptr;
  return temp;
}
inline ::feedstore::Metadata_SessionID* Metadata::_internal_mutable_session_id() {
  
  if (session_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedstore::Metadata_SessionID>(GetArenaForAllocation());
    session_id_ = p;
  }
  return session_id_;
}
inline ::feedstore::Metadata_SessionID* Metadata::mutable_session_id() {
  ::feedstore::Metadata_SessionID* _msg = _internal_mutable_session_id();
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.session_id)
  return _msg;
}
inline void Metadata::set_allocated_session_id(::feedstore::Metadata_SessionID* session_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete session_id_;
  }
  if (session_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(session_id);
    if (message_arena != submessage_arena) {
      session_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, session_id, submessage_arena);
    }
    
  } else {
    
  }
  session_id_ = session_id;
  // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.session_id)
}

// int32 stream_schema_version = 4;
inline void Metadata::clear_stream_schema_version() {
  stream_schema_version_ = 0;
}
inline int32_t Metadata::_internal_stream_schema_version() const {
  return stream_schema_version_;
}
inline int32_t Metadata::stream_schema_version() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.stream_schema_version)
  return _internal_stream_schema_version();
}
inline void Metadata::_internal_set_stream_schema_version(int32_t value) {
  
  stream_schema_version_ = value;
}
inline void Metadata::set_stream_schema_version(int32_t value) {
  _internal_set_stream_schema_version(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.stream_schema_version)
}

// repeated .feedstore.Metadata.StreamMetadata stream_metadata = 5;
inline int Metadata::_internal_stream_metadata_size() const {
  return stream_metadata_.size();
}
inline int Metadata::stream_metadata_size() const {
  return _internal_stream_metadata_size();
}
inline void Metadata::clear_stream_metadata() {
  stream_metadata_.Clear();
}
inline ::feedstore::Metadata_StreamMetadata* Metadata::mutable_stream_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.stream_metadata)
  return stream_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::Metadata_StreamMetadata >*
Metadata::mutable_stream_metadata() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.Metadata.stream_metadata)
  return &stream_metadata_;
}
inline const ::feedstore::Metadata_StreamMetadata& Metadata::_internal_stream_metadata(int index) const {
  return stream_metadata_.Get(index);
}
inline const ::feedstore::Metadata_StreamMetadata& Metadata::stream_metadata(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.stream_metadata)
  return _internal_stream_metadata(index);
}
inline ::feedstore::Metadata_StreamMetadata* Metadata::_internal_add_stream_metadata() {
  return stream_metadata_.Add();
}
inline ::feedstore::Metadata_StreamMetadata* Metadata::add_stream_metadata() {
  ::feedstore::Metadata_StreamMetadata* _add = _internal_add_stream_metadata();
  // @@protoc_insertion_point(field_add:feedstore.Metadata.stream_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::Metadata_StreamMetadata >&
Metadata::stream_metadata() const {
  // @@protoc_insertion_point(field_list:feedstore.Metadata.stream_metadata)
  return stream_metadata_;
}

// string gaia = 6;
inline void Metadata::clear_gaia() {
  gaia_.ClearToEmpty();
}
inline const std::string& Metadata::gaia() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.gaia)
  return _internal_gaia();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Metadata::set_gaia(ArgT0&& arg0, ArgT... args) {
 
 gaia_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Metadata.gaia)
}
inline std::string* Metadata::mutable_gaia() {
  std::string* _s = _internal_mutable_gaia();
  // @@protoc_insertion_point(field_mutable:feedstore.Metadata.gaia)
  return _s;
}
inline const std::string& Metadata::_internal_gaia() const {
  return gaia_.Get();
}
inline void Metadata::_internal_set_gaia(const std::string& value) {
  
  gaia_.Set(value, GetArenaForAllocation());
}
inline std::string* Metadata::_internal_mutable_gaia() {
  
  return gaia_.Mutable(GetArenaForAllocation());
}
inline std::string* Metadata::release_gaia() {
  // @@protoc_insertion_point(field_release:feedstore.Metadata.gaia)
  return gaia_.Release();
}
inline void Metadata::set_allocated_gaia(std::string* gaia) {
  if (gaia != nullptr) {
    
  } else {
    
  }
  gaia_.SetAllocated(gaia, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gaia_.IsDefault()) {
    gaia_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Metadata.gaia)
}

// bool web_and_app_activity_enabled = 7;
inline void Metadata::clear_web_and_app_activity_enabled() {
  web_and_app_activity_enabled_ = false;
}
inline bool Metadata::_internal_web_and_app_activity_enabled() const {
  return web_and_app_activity_enabled_;
}
inline bool Metadata::web_and_app_activity_enabled() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.web_and_app_activity_enabled)
  return _internal_web_and_app_activity_enabled();
}
inline void Metadata::_internal_set_web_and_app_activity_enabled(bool value) {
  
  web_and_app_activity_enabled_ = value;
}
inline void Metadata::set_web_and_app_activity_enabled(bool value) {
  _internal_set_web_and_app_activity_enabled(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.web_and_app_activity_enabled)
}

// bool discover_personalization_enabled = 8;
inline void Metadata::clear_discover_personalization_enabled() {
  discover_personalization_enabled_ = false;
}
inline bool Metadata::_internal_discover_personalization_enabled() const {
  return discover_personalization_enabled_;
}
inline bool Metadata::discover_personalization_enabled() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.discover_personalization_enabled)
  return _internal_discover_personalization_enabled();
}
inline void Metadata::_internal_set_discover_personalization_enabled(bool value) {
  
  discover_personalization_enabled_ = value;
}
inline void Metadata::set_discover_personalization_enabled(bool value) {
  _internal_set_discover_personalization_enabled(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.discover_personalization_enabled)
}

// int32 followed_from_web_page_menu_count = 9;
inline void Metadata::clear_followed_from_web_page_menu_count() {
  followed_from_web_page_menu_count_ = 0;
}
inline int32_t Metadata::_internal_followed_from_web_page_menu_count() const {
  return followed_from_web_page_menu_count_;
}
inline int32_t Metadata::followed_from_web_page_menu_count() const {
  // @@protoc_insertion_point(field_get:feedstore.Metadata.followed_from_web_page_menu_count)
  return _internal_followed_from_web_page_menu_count();
}
inline void Metadata::_internal_set_followed_from_web_page_menu_count(int32_t value) {
  
  followed_from_web_page_menu_count_ = value;
}
inline void Metadata::set_followed_from_web_page_menu_count(int32_t value) {
  _internal_set_followed_from_web_page_menu_count(value);
  // @@protoc_insertion_point(field_set:feedstore.Metadata.followed_from_web_page_menu_count)
}

// -------------------------------------------------------------------

// StreamStructureSet

// string stream_id = 1;
inline void StreamStructureSet::clear_stream_id() {
  stream_id_.ClearToEmpty();
}
inline const std::string& StreamStructureSet::stream_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructureSet.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamStructureSet::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamStructureSet.stream_id)
}
inline std::string* StreamStructureSet::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamStructureSet.stream_id)
  return _s;
}
inline const std::string& StreamStructureSet::_internal_stream_id() const {
  return stream_id_.Get();
}
inline void StreamStructureSet::_internal_set_stream_id(const std::string& value) {
  
  stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamStructureSet::_internal_mutable_stream_id() {
  
  return stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamStructureSet::release_stream_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamStructureSet.stream_id)
  return stream_id_.Release();
}
inline void StreamStructureSet::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stream_id_.IsDefault()) {
    stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructureSet.stream_id)
}

// int32 sequence_number = 2;
inline void StreamStructureSet::clear_sequence_number() {
  sequence_number_ = 0;
}
inline int32_t StreamStructureSet::_internal_sequence_number() const {
  return sequence_number_;
}
inline int32_t StreamStructureSet::sequence_number() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructureSet.sequence_number)
  return _internal_sequence_number();
}
inline void StreamStructureSet::_internal_set_sequence_number(int32_t value) {
  
  sequence_number_ = value;
}
inline void StreamStructureSet::set_sequence_number(int32_t value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamStructureSet.sequence_number)
}

// repeated .feedstore.StreamStructure structures = 3;
inline int StreamStructureSet::_internal_structures_size() const {
  return structures_.size();
}
inline int StreamStructureSet::structures_size() const {
  return _internal_structures_size();
}
inline void StreamStructureSet::clear_structures() {
  structures_.Clear();
}
inline ::feedstore::StreamStructure* StreamStructureSet::mutable_structures(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.StreamStructureSet.structures)
  return structures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::StreamStructure >*
StreamStructureSet::mutable_structures() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.StreamStructureSet.structures)
  return &structures_;
}
inline const ::feedstore::StreamStructure& StreamStructureSet::_internal_structures(int index) const {
  return structures_.Get(index);
}
inline const ::feedstore::StreamStructure& StreamStructureSet::structures(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructureSet.structures)
  return _internal_structures(index);
}
inline ::feedstore::StreamStructure* StreamStructureSet::_internal_add_structures() {
  return structures_.Add();
}
inline ::feedstore::StreamStructure* StreamStructureSet::add_structures() {
  ::feedstore::StreamStructure* _add = _internal_add_structures();
  // @@protoc_insertion_point(field_add:feedstore.StreamStructureSet.structures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::StreamStructure >&
StreamStructureSet::structures() const {
  // @@protoc_insertion_point(field_list:feedstore.StreamStructureSet.structures)
  return structures_;
}

// -------------------------------------------------------------------

// StreamStructure

// .feedstore.StreamStructure.Operation operation = 1;
inline void StreamStructure::clear_operation() {
  operation_ = 0;
}
inline ::feedstore::StreamStructure_Operation StreamStructure::_internal_operation() const {
  return static_cast< ::feedstore::StreamStructure_Operation >(operation_);
}
inline ::feedstore::StreamStructure_Operation StreamStructure::operation() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructure.operation)
  return _internal_operation();
}
inline void StreamStructure::_internal_set_operation(::feedstore::StreamStructure_Operation value) {
  
  operation_ = value;
}
inline void StreamStructure::set_operation(::feedstore::StreamStructure_Operation value) {
  _internal_set_operation(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamStructure.operation)
}

// .feedwire.ContentId content_id = 2;
inline bool StreamStructure::_internal_has_content_id() const {
  return this != internal_default_instance() && content_id_ != nullptr;
}
inline bool StreamStructure::has_content_id() const {
  return _internal_has_content_id();
}
inline const ::feedwire::ContentId& StreamStructure::_internal_content_id() const {
  const ::feedwire::ContentId* p = content_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(
      ::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamStructure::content_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructure.content_id)
  return _internal_content_id();
}
inline void StreamStructure::unsafe_arena_set_allocated_content_id(
    ::feedwire::ContentId* content_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  content_id_ = content_id;
  if (content_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamStructure.content_id)
}
inline ::feedwire::ContentId* StreamStructure::release_content_id() {
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedwire::ContentId* StreamStructure::unsafe_arena_release_content_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamStructure.content_id)
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
  return temp;
}
inline ::feedwire::ContentId* StreamStructure::_internal_mutable_content_id() {
  
  if (content_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
    content_id_ = p;
  }
  return content_id_;
}
inline ::feedwire::ContentId* StreamStructure::mutable_content_id() {
  ::feedwire::ContentId* _msg = _internal_mutable_content_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamStructure.content_id)
  return _msg;
}
inline void StreamStructure::set_allocated_content_id(::feedwire::ContentId* content_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  if (content_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
    if (message_arena != submessage_arena) {
      content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_id, submessage_arena);
    }
    
  } else {
    
  }
  content_id_ = content_id;
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructure.content_id)
}

// .feedwire.ContentId parent_id = 3;
inline bool StreamStructure::_internal_has_parent_id() const {
  return this != internal_default_instance() && parent_id_ != nullptr;
}
inline bool StreamStructure::has_parent_id() const {
  return _internal_has_parent_id();
}
inline const ::feedwire::ContentId& StreamStructure::_internal_parent_id() const {
  const ::feedwire::ContentId* p = parent_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(
      ::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamStructure::parent_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructure.parent_id)
  return _internal_parent_id();
}
inline void StreamStructure::unsafe_arena_set_allocated_parent_id(
    ::feedwire::ContentId* parent_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_id_);
  }
  parent_id_ = parent_id;
  if (parent_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamStructure.parent_id)
}
inline ::feedwire::ContentId* StreamStructure::release_parent_id() {
  
  ::feedwire::ContentId* temp = parent_id_;
  parent_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedwire::ContentId* StreamStructure::unsafe_arena_release_parent_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamStructure.parent_id)
  
  ::feedwire::ContentId* temp = parent_id_;
  parent_id_ = nullptr;
  return temp;
}
inline ::feedwire::ContentId* StreamStructure::_internal_mutable_parent_id() {
  
  if (parent_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
    parent_id_ = p;
  }
  return parent_id_;
}
inline ::feedwire::ContentId* StreamStructure::mutable_parent_id() {
  ::feedwire::ContentId* _msg = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamStructure.parent_id)
  return _msg;
}
inline void StreamStructure::set_allocated_parent_id(::feedwire::ContentId* parent_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_id_);
  }
  if (parent_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(parent_id));
    if (message_arena != submessage_arena) {
      parent_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, parent_id, submessage_arena);
    }
    
  } else {
    
  }
  parent_id_ = parent_id;
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructure.parent_id)
}

// .feedstore.StreamStructure.Type type = 4;
inline void StreamStructure::clear_type() {
  type_ = 0;
}
inline ::feedstore::StreamStructure_Type StreamStructure::_internal_type() const {
  return static_cast< ::feedstore::StreamStructure_Type >(type_);
}
inline ::feedstore::StreamStructure_Type StreamStructure::type() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructure.type)
  return _internal_type();
}
inline void StreamStructure::_internal_set_type(::feedstore::StreamStructure_Type value) {
  
  type_ = value;
}
inline void StreamStructure::set_type(::feedstore::StreamStructure_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamStructure.type)
}

// .feedstore.ContentInfo content_info = 5;
inline bool StreamStructure::_internal_has_content_info() const {
  return this != internal_default_instance() && content_info_ != nullptr;
}
inline bool StreamStructure::has_content_info() const {
  return _internal_has_content_info();
}
inline void StreamStructure::clear_content_info() {
  if (GetArenaForAllocation() == nullptr && content_info_ != nullptr) {
    delete content_info_;
  }
  content_info_ = nullptr;
}
inline const ::feedstore::ContentInfo& StreamStructure::_internal_content_info() const {
  const ::feedstore::ContentInfo* p = content_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedstore::ContentInfo&>(
      ::feedstore::_ContentInfo_default_instance_);
}
inline const ::feedstore::ContentInfo& StreamStructure::content_info() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructure.content_info)
  return _internal_content_info();
}
inline void StreamStructure::unsafe_arena_set_allocated_content_info(
    ::feedstore::ContentInfo* content_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_info_);
  }
  content_info_ = content_info;
  if (content_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamStructure.content_info)
}
inline ::feedstore::ContentInfo* StreamStructure::release_content_info() {
  
  ::feedstore::ContentInfo* temp = content_info_;
  content_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedstore::ContentInfo* StreamStructure::unsafe_arena_release_content_info() {
  // @@protoc_insertion_point(field_release:feedstore.StreamStructure.content_info)
  
  ::feedstore::ContentInfo* temp = content_info_;
  content_info_ = nullptr;
  return temp;
}
inline ::feedstore::ContentInfo* StreamStructure::_internal_mutable_content_info() {
  
  if (content_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedstore::ContentInfo>(GetArenaForAllocation());
    content_info_ = p;
  }
  return content_info_;
}
inline ::feedstore::ContentInfo* StreamStructure::mutable_content_info() {
  ::feedstore::ContentInfo* _msg = _internal_mutable_content_info();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamStructure.content_info)
  return _msg;
}
inline void StreamStructure::set_allocated_content_info(::feedstore::ContentInfo* content_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete content_info_;
  }
  if (content_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content_info);
    if (message_arena != submessage_arena) {
      content_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_info, submessage_arena);
    }
    
  } else {
    
  }
  content_info_ = content_info;
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamStructure.content_info)
}

// bool is_root = 6;
inline void StreamStructure::clear_is_root() {
  is_root_ = false;
}
inline bool StreamStructure::_internal_is_root() const {
  return is_root_;
}
inline bool StreamStructure::is_root() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamStructure.is_root)
  return _internal_is_root();
}
inline void StreamStructure::_internal_set_is_root(bool value) {
  
  is_root_ = value;
}
inline void StreamStructure::set_is_root(bool value) {
  _internal_set_is_root(value);
  // @@protoc_insertion_point(field_set:feedstore.StreamStructure.is_root)
}

// -------------------------------------------------------------------

// DataOperation

// .feedstore.StreamStructure structure = 1;
inline bool DataOperation::_internal_has_structure() const {
  return this != internal_default_instance() && structure_ != nullptr;
}
inline bool DataOperation::has_structure() const {
  return _internal_has_structure();
}
inline void DataOperation::clear_structure() {
  if (GetArenaForAllocation() == nullptr && structure_ != nullptr) {
    delete structure_;
  }
  structure_ = nullptr;
}
inline const ::feedstore::StreamStructure& DataOperation::_internal_structure() const {
  const ::feedstore::StreamStructure* p = structure_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedstore::StreamStructure&>(
      ::feedstore::_StreamStructure_default_instance_);
}
inline const ::feedstore::StreamStructure& DataOperation::structure() const {
  // @@protoc_insertion_point(field_get:feedstore.DataOperation.structure)
  return _internal_structure();
}
inline void DataOperation::unsafe_arena_set_allocated_structure(
    ::feedstore::StreamStructure* structure) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(structure_);
  }
  structure_ = structure;
  if (structure) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.DataOperation.structure)
}
inline ::feedstore::StreamStructure* DataOperation::release_structure() {
  
  ::feedstore::StreamStructure* temp = structure_;
  structure_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedstore::StreamStructure* DataOperation::unsafe_arena_release_structure() {
  // @@protoc_insertion_point(field_release:feedstore.DataOperation.structure)
  
  ::feedstore::StreamStructure* temp = structure_;
  structure_ = nullptr;
  return temp;
}
inline ::feedstore::StreamStructure* DataOperation::_internal_mutable_structure() {
  
  if (structure_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedstore::StreamStructure>(GetArenaForAllocation());
    structure_ = p;
  }
  return structure_;
}
inline ::feedstore::StreamStructure* DataOperation::mutable_structure() {
  ::feedstore::StreamStructure* _msg = _internal_mutable_structure();
  // @@protoc_insertion_point(field_mutable:feedstore.DataOperation.structure)
  return _msg;
}
inline void DataOperation::set_allocated_structure(::feedstore::StreamStructure* structure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete structure_;
  }
  if (structure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(structure);
    if (message_arena != submessage_arena) {
      structure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, structure, submessage_arena);
    }
    
  } else {
    
  }
  structure_ = structure;
  // @@protoc_insertion_point(field_set_allocated:feedstore.DataOperation.structure)
}

// .feedstore.Content content = 2;
inline bool DataOperation::_internal_has_content() const {
  return this != internal_default_instance() && content_ != nullptr;
}
inline bool DataOperation::has_content() const {
  return _internal_has_content();
}
inline void DataOperation::clear_content() {
  if (GetArenaForAllocation() == nullptr && content_ != nullptr) {
    delete content_;
  }
  content_ = nullptr;
}
inline const ::feedstore::Content& DataOperation::_internal_content() const {
  const ::feedstore::Content* p = content_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Content&>(
      ::feedstore::_Content_default_instance_);
}
inline const ::feedstore::Content& DataOperation::content() const {
  // @@protoc_insertion_point(field_get:feedstore.DataOperation.content)
  return _internal_content();
}
inline void DataOperation::unsafe_arena_set_allocated_content(
    ::feedstore::Content* content) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_);
  }
  content_ = content;
  if (content) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.DataOperation.content)
}
inline ::feedstore::Content* DataOperation::release_content() {
  
  ::feedstore::Content* temp = content_;
  content_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedstore::Content* DataOperation::unsafe_arena_release_content() {
  // @@protoc_insertion_point(field_release:feedstore.DataOperation.content)
  
  ::feedstore::Content* temp = content_;
  content_ = nullptr;
  return temp;
}
inline ::feedstore::Content* DataOperation::_internal_mutable_content() {
  
  if (content_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedstore::Content>(GetArenaForAllocation());
    content_ = p;
  }
  return content_;
}
inline ::feedstore::Content* DataOperation::mutable_content() {
  ::feedstore::Content* _msg = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:feedstore.DataOperation.content)
  return _msg;
}
inline void DataOperation::set_allocated_content(::feedstore::Content* content) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete content_;
  }
  if (content) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(content);
    if (message_arena != submessage_arena) {
      content = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content, submessage_arena);
    }
    
  } else {
    
  }
  content_ = content;
  // @@protoc_insertion_point(field_set_allocated:feedstore.DataOperation.content)
}

// -------------------------------------------------------------------

// ContentInfo

// float score = 1;
inline void ContentInfo::clear_score() {
  score_ = 0;
}
inline float ContentInfo::_internal_score() const {
  return score_;
}
inline float ContentInfo::score() const {
  // @@protoc_insertion_point(field_get:feedstore.ContentInfo.score)
  return _internal_score();
}
inline void ContentInfo::_internal_set_score(float value) {
  
  score_ = value;
}
inline void ContentInfo::set_score(float value) {
  _internal_set_score(value);
  // @@protoc_insertion_point(field_set:feedstore.ContentInfo.score)
}

// int64 availability_time_seconds = 2;
inline void ContentInfo::clear_availability_time_seconds() {
  availability_time_seconds_ = int64_t{0};
}
inline int64_t ContentInfo::_internal_availability_time_seconds() const {
  return availability_time_seconds_;
}
inline int64_t ContentInfo::availability_time_seconds() const {
  // @@protoc_insertion_point(field_get:feedstore.ContentInfo.availability_time_seconds)
  return _internal_availability_time_seconds();
}
inline void ContentInfo::_internal_set_availability_time_seconds(int64_t value) {
  
  availability_time_seconds_ = value;
}
inline void ContentInfo::set_availability_time_seconds(int64_t value) {
  _internal_set_availability_time_seconds(value);
  // @@protoc_insertion_point(field_set:feedstore.ContentInfo.availability_time_seconds)
}

// -------------------------------------------------------------------

// Content

// .feedwire.ContentId content_id = 1;
inline bool Content::_internal_has_content_id() const {
  return this != internal_default_instance() && content_id_ != nullptr;
}
inline bool Content::has_content_id() const {
  return _internal_has_content_id();
}
inline const ::feedwire::ContentId& Content::_internal_content_id() const {
  const ::feedwire::ContentId* p = content_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(
      ::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& Content::content_id() const {
  // @@protoc_insertion_point(field_get:feedstore.Content.content_id)
  return _internal_content_id();
}
inline void Content::unsafe_arena_set_allocated_content_id(
    ::feedwire::ContentId* content_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  content_id_ = content_id;
  if (content_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.Content.content_id)
}
inline ::feedwire::ContentId* Content::release_content_id() {
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedwire::ContentId* Content::unsafe_arena_release_content_id() {
  // @@protoc_insertion_point(field_release:feedstore.Content.content_id)
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
  return temp;
}
inline ::feedwire::ContentId* Content::_internal_mutable_content_id() {
  
  if (content_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
    content_id_ = p;
  }
  return content_id_;
}
inline ::feedwire::ContentId* Content::mutable_content_id() {
  ::feedwire::ContentId* _msg = _internal_mutable_content_id();
  // @@protoc_insertion_point(field_mutable:feedstore.Content.content_id)
  return _msg;
}
inline void Content::set_allocated_content_id(::feedwire::ContentId* content_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  if (content_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
    if (message_arena != submessage_arena) {
      content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_id, submessage_arena);
    }
    
  } else {
    
  }
  content_id_ = content_id;
  // @@protoc_insertion_point(field_set_allocated:feedstore.Content.content_id)
}

// bytes frame = 2;
inline void Content::clear_frame() {
  frame_.ClearToEmpty();
}
inline const std::string& Content::frame() const {
  // @@protoc_insertion_point(field_get:feedstore.Content.frame)
  return _internal_frame();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Content::set_frame(ArgT0&& arg0, ArgT... args) {
 
 frame_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Content.frame)
}
inline std::string* Content::mutable_frame() {
  std::string* _s = _internal_mutable_frame();
  // @@protoc_insertion_point(field_mutable:feedstore.Content.frame)
  return _s;
}
inline const std::string& Content::_internal_frame() const {
  return frame_.Get();
}
inline void Content::_internal_set_frame(const std::string& value) {
  
  frame_.Set(value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_frame() {
  
  return frame_.Mutable(GetArenaForAllocation());
}
inline std::string* Content::release_frame() {
  // @@protoc_insertion_point(field_release:feedstore.Content.frame)
  return frame_.Release();
}
inline void Content::set_allocated_frame(std::string* frame) {
  if (frame != nullptr) {
    
  } else {
    
  }
  frame_.SetAllocated(frame, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (frame_.IsDefault()) {
    frame_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Content.frame)
}

// repeated .feedwire.PrefetchMetadata prefetch_metadata = 3;
inline int Content::_internal_prefetch_metadata_size() const {
  return prefetch_metadata_.size();
}
inline int Content::prefetch_metadata_size() const {
  return _internal_prefetch_metadata_size();
}
inline ::feedwire::PrefetchMetadata* Content::mutable_prefetch_metadata(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.Content.prefetch_metadata)
  return prefetch_metadata_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::PrefetchMetadata >*
Content::mutable_prefetch_metadata() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.Content.prefetch_metadata)
  return &prefetch_metadata_;
}
inline const ::feedwire::PrefetchMetadata& Content::_internal_prefetch_metadata(int index) const {
  return prefetch_metadata_.Get(index);
}
inline const ::feedwire::PrefetchMetadata& Content::prefetch_metadata(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.Content.prefetch_metadata)
  return _internal_prefetch_metadata(index);
}
inline ::feedwire::PrefetchMetadata* Content::_internal_add_prefetch_metadata() {
  return prefetch_metadata_.Add();
}
inline ::feedwire::PrefetchMetadata* Content::add_prefetch_metadata() {
  ::feedwire::PrefetchMetadata* _add = _internal_add_prefetch_metadata();
  // @@protoc_insertion_point(field_add:feedstore.Content.prefetch_metadata)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::PrefetchMetadata >&
Content::prefetch_metadata() const {
  // @@protoc_insertion_point(field_list:feedstore.Content.prefetch_metadata)
  return prefetch_metadata_;
}

// string stream_id = 4;
inline void Content::clear_stream_id() {
  stream_id_.ClearToEmpty();
}
inline const std::string& Content::stream_id() const {
  // @@protoc_insertion_point(field_get:feedstore.Content.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Content::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Content.stream_id)
}
inline std::string* Content::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:feedstore.Content.stream_id)
  return _s;
}
inline const std::string& Content::_internal_stream_id() const {
  return stream_id_.Get();
}
inline void Content::_internal_set_stream_id(const std::string& value) {
  
  stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Content::_internal_mutable_stream_id() {
  
  return stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Content::release_stream_id() {
  // @@protoc_insertion_point(field_release:feedstore.Content.stream_id)
  return stream_id_.Release();
}
inline void Content::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stream_id_.IsDefault()) {
    stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Content.stream_id)
}

// -------------------------------------------------------------------

// StreamSharedState

// .feedwire.ContentId content_id = 1;
inline bool StreamSharedState::_internal_has_content_id() const {
  return this != internal_default_instance() && content_id_ != nullptr;
}
inline bool StreamSharedState::has_content_id() const {
  return _internal_has_content_id();
}
inline const ::feedwire::ContentId& StreamSharedState::_internal_content_id() const {
  const ::feedwire::ContentId* p = content_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedwire::ContentId&>(
      ::feedwire::_ContentId_default_instance_);
}
inline const ::feedwire::ContentId& StreamSharedState::content_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamSharedState.content_id)
  return _internal_content_id();
}
inline void StreamSharedState::unsafe_arena_set_allocated_content_id(
    ::feedwire::ContentId* content_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  content_id_ = content_id;
  if (content_id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StreamSharedState.content_id)
}
inline ::feedwire::ContentId* StreamSharedState::release_content_id() {
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedwire::ContentId* StreamSharedState::unsafe_arena_release_content_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamSharedState.content_id)
  
  ::feedwire::ContentId* temp = content_id_;
  content_id_ = nullptr;
  return temp;
}
inline ::feedwire::ContentId* StreamSharedState::_internal_mutable_content_id() {
  
  if (content_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedwire::ContentId>(GetArenaForAllocation());
    content_id_ = p;
  }
  return content_id_;
}
inline ::feedwire::ContentId* StreamSharedState::mutable_content_id() {
  ::feedwire::ContentId* _msg = _internal_mutable_content_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamSharedState.content_id)
  return _msg;
}
inline void StreamSharedState::set_allocated_content_id(::feedwire::ContentId* content_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id_);
  }
  if (content_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_id));
    if (message_arena != submessage_arena) {
      content_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_id, submessage_arena);
    }
    
  } else {
    
  }
  content_id_ = content_id;
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamSharedState.content_id)
}

// bytes shared_state_data = 2;
inline void StreamSharedState::clear_shared_state_data() {
  shared_state_data_.ClearToEmpty();
}
inline const std::string& StreamSharedState::shared_state_data() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamSharedState.shared_state_data)
  return _internal_shared_state_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamSharedState::set_shared_state_data(ArgT0&& arg0, ArgT... args) {
 
 shared_state_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamSharedState.shared_state_data)
}
inline std::string* StreamSharedState::mutable_shared_state_data() {
  std::string* _s = _internal_mutable_shared_state_data();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamSharedState.shared_state_data)
  return _s;
}
inline const std::string& StreamSharedState::_internal_shared_state_data() const {
  return shared_state_data_.Get();
}
inline void StreamSharedState::_internal_set_shared_state_data(const std::string& value) {
  
  shared_state_data_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamSharedState::_internal_mutable_shared_state_data() {
  
  return shared_state_data_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamSharedState::release_shared_state_data() {
  // @@protoc_insertion_point(field_release:feedstore.StreamSharedState.shared_state_data)
  return shared_state_data_.Release();
}
inline void StreamSharedState::set_allocated_shared_state_data(std::string* shared_state_data) {
  if (shared_state_data != nullptr) {
    
  } else {
    
  }
  shared_state_data_.SetAllocated(shared_state_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (shared_state_data_.IsDefault()) {
    shared_state_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamSharedState.shared_state_data)
}

// string stream_id = 3;
inline void StreamSharedState::clear_stream_id() {
  stream_id_.ClearToEmpty();
}
inline const std::string& StreamSharedState::stream_id() const {
  // @@protoc_insertion_point(field_get:feedstore.StreamSharedState.stream_id)
  return _internal_stream_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StreamSharedState::set_stream_id(ArgT0&& arg0, ArgT... args) {
 
 stream_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.StreamSharedState.stream_id)
}
inline std::string* StreamSharedState::mutable_stream_id() {
  std::string* _s = _internal_mutable_stream_id();
  // @@protoc_insertion_point(field_mutable:feedstore.StreamSharedState.stream_id)
  return _s;
}
inline const std::string& StreamSharedState::_internal_stream_id() const {
  return stream_id_.Get();
}
inline void StreamSharedState::_internal_set_stream_id(const std::string& value) {
  
  stream_id_.Set(value, GetArenaForAllocation());
}
inline std::string* StreamSharedState::_internal_mutable_stream_id() {
  
  return stream_id_.Mutable(GetArenaForAllocation());
}
inline std::string* StreamSharedState::release_stream_id() {
  // @@protoc_insertion_point(field_release:feedstore.StreamSharedState.stream_id)
  return stream_id_.Release();
}
inline void StreamSharedState::set_allocated_stream_id(std::string* stream_id) {
  if (stream_id != nullptr) {
    
  } else {
    
  }
  stream_id_.SetAllocated(stream_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (stream_id_.IsDefault()) {
    stream_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.StreamSharedState.stream_id)
}

// -------------------------------------------------------------------

// StoredAction

// int32 id = 1;
inline void StoredAction::clear_id() {
  id_ = 0;
}
inline int32_t StoredAction::_internal_id() const {
  return id_;
}
inline int32_t StoredAction::id() const {
  // @@protoc_insertion_point(field_get:feedstore.StoredAction.id)
  return _internal_id();
}
inline void StoredAction::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void StoredAction::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:feedstore.StoredAction.id)
}

// int32 upload_attempt_count = 2;
inline void StoredAction::clear_upload_attempt_count() {
  upload_attempt_count_ = 0;
}
inline int32_t StoredAction::_internal_upload_attempt_count() const {
  return upload_attempt_count_;
}
inline int32_t StoredAction::upload_attempt_count() const {
  // @@protoc_insertion_point(field_get:feedstore.StoredAction.upload_attempt_count)
  return _internal_upload_attempt_count();
}
inline void StoredAction::_internal_set_upload_attempt_count(int32_t value) {
  
  upload_attempt_count_ = value;
}
inline void StoredAction::set_upload_attempt_count(int32_t value) {
  _internal_set_upload_attempt_count(value);
  // @@protoc_insertion_point(field_set:feedstore.StoredAction.upload_attempt_count)
}

// .feedwire.FeedAction action = 3;
inline bool StoredAction::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool StoredAction::has_action() const {
  return _internal_has_action();
}
inline const ::feedwire::FeedAction& StoredAction::_internal_action() const {
  const ::feedwire::FeedAction* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedwire::FeedAction&>(
      ::feedwire::_FeedAction_default_instance_);
}
inline const ::feedwire::FeedAction& StoredAction::action() const {
  // @@protoc_insertion_point(field_get:feedstore.StoredAction.action)
  return _internal_action();
}
inline void StoredAction::unsafe_arena_set_allocated_action(
    ::feedwire::FeedAction* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.StoredAction.action)
}
inline ::feedwire::FeedAction* StoredAction::release_action() {
  
  ::feedwire::FeedAction* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedwire::FeedAction* StoredAction::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:feedstore.StoredAction.action)
  
  ::feedwire::FeedAction* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::feedwire::FeedAction* StoredAction::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedwire::FeedAction>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::feedwire::FeedAction* StoredAction::mutable_action() {
  ::feedwire::FeedAction* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:feedstore.StoredAction.action)
  return _msg;
}
inline void StoredAction::set_allocated_action(::feedwire::FeedAction* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action));
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:feedstore.StoredAction.action)
}

// -------------------------------------------------------------------

// SubscribedWebFeeds

// repeated .feedstore.WebFeedInfo feeds = 1;
inline int SubscribedWebFeeds::_internal_feeds_size() const {
  return feeds_.size();
}
inline int SubscribedWebFeeds::feeds_size() const {
  return _internal_feeds_size();
}
inline void SubscribedWebFeeds::clear_feeds() {
  feeds_.Clear();
}
inline ::feedstore::WebFeedInfo* SubscribedWebFeeds::mutable_feeds(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.SubscribedWebFeeds.feeds)
  return feeds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::WebFeedInfo >*
SubscribedWebFeeds::mutable_feeds() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.SubscribedWebFeeds.feeds)
  return &feeds_;
}
inline const ::feedstore::WebFeedInfo& SubscribedWebFeeds::_internal_feeds(int index) const {
  return feeds_.Get(index);
}
inline const ::feedstore::WebFeedInfo& SubscribedWebFeeds::feeds(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.SubscribedWebFeeds.feeds)
  return _internal_feeds(index);
}
inline ::feedstore::WebFeedInfo* SubscribedWebFeeds::_internal_add_feeds() {
  return feeds_.Add();
}
inline ::feedstore::WebFeedInfo* SubscribedWebFeeds::add_feeds() {
  ::feedstore::WebFeedInfo* _add = _internal_add_feeds();
  // @@protoc_insertion_point(field_add:feedstore.SubscribedWebFeeds.feeds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::WebFeedInfo >&
SubscribedWebFeeds::feeds() const {
  // @@protoc_insertion_point(field_list:feedstore.SubscribedWebFeeds.feeds)
  return feeds_;
}

// int64 update_time_millis = 2;
inline void SubscribedWebFeeds::clear_update_time_millis() {
  update_time_millis_ = int64_t{0};
}
inline int64_t SubscribedWebFeeds::_internal_update_time_millis() const {
  return update_time_millis_;
}
inline int64_t SubscribedWebFeeds::update_time_millis() const {
  // @@protoc_insertion_point(field_get:feedstore.SubscribedWebFeeds.update_time_millis)
  return _internal_update_time_millis();
}
inline void SubscribedWebFeeds::_internal_set_update_time_millis(int64_t value) {
  
  update_time_millis_ = value;
}
inline void SubscribedWebFeeds::set_update_time_millis(int64_t value) {
  _internal_set_update_time_millis(value);
  // @@protoc_insertion_point(field_set:feedstore.SubscribedWebFeeds.update_time_millis)
}

// -------------------------------------------------------------------

// RecommendedWebFeedIndex_Entry

// string web_feed_id = 1;
inline void RecommendedWebFeedIndex_Entry::clear_web_feed_id() {
  web_feed_id_.ClearToEmpty();
}
inline const std::string& RecommendedWebFeedIndex_Entry::web_feed_id() const {
  // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
  return _internal_web_feed_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecommendedWebFeedIndex_Entry::set_web_feed_id(ArgT0&& arg0, ArgT... args) {
 
 web_feed_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
}
inline std::string* RecommendedWebFeedIndex_Entry::mutable_web_feed_id() {
  std::string* _s = _internal_mutable_web_feed_id();
  // @@protoc_insertion_point(field_mutable:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
  return _s;
}
inline const std::string& RecommendedWebFeedIndex_Entry::_internal_web_feed_id() const {
  return web_feed_id_.Get();
}
inline void RecommendedWebFeedIndex_Entry::_internal_set_web_feed_id(const std::string& value) {
  
  web_feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* RecommendedWebFeedIndex_Entry::_internal_mutable_web_feed_id() {
  
  return web_feed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* RecommendedWebFeedIndex_Entry::release_web_feed_id() {
  // @@protoc_insertion_point(field_release:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
  return web_feed_id_.Release();
}
inline void RecommendedWebFeedIndex_Entry::set_allocated_web_feed_id(std::string* web_feed_id) {
  if (web_feed_id != nullptr) {
    
  } else {
    
  }
  web_feed_id_.SetAllocated(web_feed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (web_feed_id_.IsDefault()) {
    web_feed_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.RecommendedWebFeedIndex.Entry.web_feed_id)
}

// repeated .feedwire.webfeed.WebFeedMatcher matchers = 2;
inline int RecommendedWebFeedIndex_Entry::_internal_matchers_size() const {
  return matchers_.size();
}
inline int RecommendedWebFeedIndex_Entry::matchers_size() const {
  return _internal_matchers_size();
}
inline ::feedwire::webfeed::WebFeedMatcher* RecommendedWebFeedIndex_Entry::mutable_matchers(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.RecommendedWebFeedIndex.Entry.matchers)
  return matchers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >*
RecommendedWebFeedIndex_Entry::mutable_matchers() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.RecommendedWebFeedIndex.Entry.matchers)
  return &matchers_;
}
inline const ::feedwire::webfeed::WebFeedMatcher& RecommendedWebFeedIndex_Entry::_internal_matchers(int index) const {
  return matchers_.Get(index);
}
inline const ::feedwire::webfeed::WebFeedMatcher& RecommendedWebFeedIndex_Entry::matchers(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.Entry.matchers)
  return _internal_matchers(index);
}
inline ::feedwire::webfeed::WebFeedMatcher* RecommendedWebFeedIndex_Entry::_internal_add_matchers() {
  return matchers_.Add();
}
inline ::feedwire::webfeed::WebFeedMatcher* RecommendedWebFeedIndex_Entry::add_matchers() {
  ::feedwire::webfeed::WebFeedMatcher* _add = _internal_add_matchers();
  // @@protoc_insertion_point(field_add:feedstore.RecommendedWebFeedIndex.Entry.matchers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >&
RecommendedWebFeedIndex_Entry::matchers() const {
  // @@protoc_insertion_point(field_list:feedstore.RecommendedWebFeedIndex.Entry.matchers)
  return matchers_;
}

// -------------------------------------------------------------------

// RecommendedWebFeedIndex

// repeated .feedstore.RecommendedWebFeedIndex.Entry entries = 1;
inline int RecommendedWebFeedIndex::_internal_entries_size() const {
  return entries_.size();
}
inline int RecommendedWebFeedIndex::entries_size() const {
  return _internal_entries_size();
}
inline void RecommendedWebFeedIndex::clear_entries() {
  entries_.Clear();
}
inline ::feedstore::RecommendedWebFeedIndex_Entry* RecommendedWebFeedIndex::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.RecommendedWebFeedIndex.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::RecommendedWebFeedIndex_Entry >*
RecommendedWebFeedIndex::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.RecommendedWebFeedIndex.entries)
  return &entries_;
}
inline const ::feedstore::RecommendedWebFeedIndex_Entry& RecommendedWebFeedIndex::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::feedstore::RecommendedWebFeedIndex_Entry& RecommendedWebFeedIndex::entries(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.entries)
  return _internal_entries(index);
}
inline ::feedstore::RecommendedWebFeedIndex_Entry* RecommendedWebFeedIndex::_internal_add_entries() {
  return entries_.Add();
}
inline ::feedstore::RecommendedWebFeedIndex_Entry* RecommendedWebFeedIndex::add_entries() {
  ::feedstore::RecommendedWebFeedIndex_Entry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:feedstore.RecommendedWebFeedIndex.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedstore::RecommendedWebFeedIndex_Entry >&
RecommendedWebFeedIndex::entries() const {
  // @@protoc_insertion_point(field_list:feedstore.RecommendedWebFeedIndex.entries)
  return entries_;
}

// int64 update_time_millis = 2;
inline void RecommendedWebFeedIndex::clear_update_time_millis() {
  update_time_millis_ = int64_t{0};
}
inline int64_t RecommendedWebFeedIndex::_internal_update_time_millis() const {
  return update_time_millis_;
}
inline int64_t RecommendedWebFeedIndex::update_time_millis() const {
  // @@protoc_insertion_point(field_get:feedstore.RecommendedWebFeedIndex.update_time_millis)
  return _internal_update_time_millis();
}
inline void RecommendedWebFeedIndex::_internal_set_update_time_millis(int64_t value) {
  
  update_time_millis_ = value;
}
inline void RecommendedWebFeedIndex::set_update_time_millis(int64_t value) {
  _internal_set_update_time_millis(value);
  // @@protoc_insertion_point(field_set:feedstore.RecommendedWebFeedIndex.update_time_millis)
}

// -------------------------------------------------------------------

// Image

// string url = 1;
inline void Image::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Image::url() const {
  // @@protoc_insertion_point(field_get:feedstore.Image.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Image::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.Image.url)
}
inline std::string* Image::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:feedstore.Image.url)
  return _s;
}
inline const std::string& Image::_internal_url() const {
  return url_.Get();
}
inline void Image::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* Image::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* Image::release_url() {
  // @@protoc_insertion_point(field_release:feedstore.Image.url)
  return url_.Release();
}
inline void Image::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.Image.url)
}

// -------------------------------------------------------------------

// WebFeedInfo

// string web_feed_id = 1;
inline void WebFeedInfo::clear_web_feed_id() {
  web_feed_id_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::web_feed_id() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.web_feed_id)
  return _internal_web_feed_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebFeedInfo::set_web_feed_id(ArgT0&& arg0, ArgT... args) {
 
 web_feed_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.web_feed_id)
}
inline std::string* WebFeedInfo::mutable_web_feed_id() {
  std::string* _s = _internal_mutable_web_feed_id();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.web_feed_id)
  return _s;
}
inline const std::string& WebFeedInfo::_internal_web_feed_id() const {
  return web_feed_id_.Get();
}
inline void WebFeedInfo::_internal_set_web_feed_id(const std::string& value) {
  
  web_feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_web_feed_id() {
  
  return web_feed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_web_feed_id() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.web_feed_id)
  return web_feed_id_.Release();
}
inline void WebFeedInfo::set_allocated_web_feed_id(std::string* web_feed_id) {
  if (web_feed_id != nullptr) {
    
  } else {
    
  }
  web_feed_id_.SetAllocated(web_feed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (web_feed_id_.IsDefault()) {
    web_feed_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.web_feed_id)
}

// string title = 2;
inline void WebFeedInfo::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::title() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebFeedInfo::set_title(ArgT0&& arg0, ArgT... args) {
 
 title_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.title)
}
inline std::string* WebFeedInfo::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.title)
  return _s;
}
inline const std::string& WebFeedInfo::_internal_title() const {
  return title_.Get();
}
inline void WebFeedInfo::_internal_set_title(const std::string& value) {
  
  title_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_title() {
  
  return title_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_title() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.title)
  return title_.Release();
}
inline void WebFeedInfo::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(title, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault()) {
    title_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.title)
}

// string subtitle = 3;
inline void WebFeedInfo::clear_subtitle() {
  subtitle_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::subtitle() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.subtitle)
  return _internal_subtitle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebFeedInfo::set_subtitle(ArgT0&& arg0, ArgT... args) {
 
 subtitle_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.subtitle)
}
inline std::string* WebFeedInfo::mutable_subtitle() {
  std::string* _s = _internal_mutable_subtitle();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.subtitle)
  return _s;
}
inline const std::string& WebFeedInfo::_internal_subtitle() const {
  return subtitle_.Get();
}
inline void WebFeedInfo::_internal_set_subtitle(const std::string& value) {
  
  subtitle_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_subtitle() {
  
  return subtitle_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_subtitle() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.subtitle)
  return subtitle_.Release();
}
inline void WebFeedInfo::set_allocated_subtitle(std::string* subtitle) {
  if (subtitle != nullptr) {
    
  } else {
    
  }
  subtitle_.SetAllocated(subtitle, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (subtitle_.IsDefault()) {
    subtitle_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.subtitle)
}

// string detail_text = 4;
inline void WebFeedInfo::clear_detail_text() {
  detail_text_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::detail_text() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.detail_text)
  return _internal_detail_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebFeedInfo::set_detail_text(ArgT0&& arg0, ArgT... args) {
 
 detail_text_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.detail_text)
}
inline std::string* WebFeedInfo::mutable_detail_text() {
  std::string* _s = _internal_mutable_detail_text();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.detail_text)
  return _s;
}
inline const std::string& WebFeedInfo::_internal_detail_text() const {
  return detail_text_.Get();
}
inline void WebFeedInfo::_internal_set_detail_text(const std::string& value) {
  
  detail_text_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_detail_text() {
  
  return detail_text_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_detail_text() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.detail_text)
  return detail_text_.Release();
}
inline void WebFeedInfo::set_allocated_detail_text(std::string* detail_text) {
  if (detail_text != nullptr) {
    
  } else {
    
  }
  detail_text_.SetAllocated(detail_text, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (detail_text_.IsDefault()) {
    detail_text_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.detail_text)
}

// string visit_uri = 5;
inline void WebFeedInfo::clear_visit_uri() {
  visit_uri_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::visit_uri() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.visit_uri)
  return _internal_visit_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebFeedInfo::set_visit_uri(ArgT0&& arg0, ArgT... args) {
 
 visit_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.visit_uri)
}
inline std::string* WebFeedInfo::mutable_visit_uri() {
  std::string* _s = _internal_mutable_visit_uri();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.visit_uri)
  return _s;
}
inline const std::string& WebFeedInfo::_internal_visit_uri() const {
  return visit_uri_.Get();
}
inline void WebFeedInfo::_internal_set_visit_uri(const std::string& value) {
  
  visit_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_visit_uri() {
  
  return visit_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_visit_uri() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.visit_uri)
  return visit_uri_.Release();
}
inline void WebFeedInfo::set_allocated_visit_uri(std::string* visit_uri) {
  if (visit_uri != nullptr) {
    
  } else {
    
  }
  visit_uri_.SetAllocated(visit_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (visit_uri_.IsDefault()) {
    visit_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.visit_uri)
}

// string rss_uri = 6;
inline void WebFeedInfo::clear_rss_uri() {
  rss_uri_.ClearToEmpty();
}
inline const std::string& WebFeedInfo::rss_uri() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.rss_uri)
  return _internal_rss_uri();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WebFeedInfo::set_rss_uri(ArgT0&& arg0, ArgT... args) {
 
 rss_uri_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.rss_uri)
}
inline std::string* WebFeedInfo::mutable_rss_uri() {
  std::string* _s = _internal_mutable_rss_uri();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.rss_uri)
  return _s;
}
inline const std::string& WebFeedInfo::_internal_rss_uri() const {
  return rss_uri_.Get();
}
inline void WebFeedInfo::_internal_set_rss_uri(const std::string& value) {
  
  rss_uri_.Set(value, GetArenaForAllocation());
}
inline std::string* WebFeedInfo::_internal_mutable_rss_uri() {
  
  return rss_uri_.Mutable(GetArenaForAllocation());
}
inline std::string* WebFeedInfo::release_rss_uri() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.rss_uri)
  return rss_uri_.Release();
}
inline void WebFeedInfo::set_allocated_rss_uri(std::string* rss_uri) {
  if (rss_uri != nullptr) {
    
  } else {
    
  }
  rss_uri_.SetAllocated(rss_uri, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rss_uri_.IsDefault()) {
    rss_uri_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.rss_uri)
}

// .feedstore.Image favicon = 7;
inline bool WebFeedInfo::_internal_has_favicon() const {
  return this != internal_default_instance() && favicon_ != nullptr;
}
inline bool WebFeedInfo::has_favicon() const {
  return _internal_has_favicon();
}
inline void WebFeedInfo::clear_favicon() {
  if (GetArenaForAllocation() == nullptr && favicon_ != nullptr) {
    delete favicon_;
  }
  favicon_ = nullptr;
}
inline const ::feedstore::Image& WebFeedInfo::_internal_favicon() const {
  const ::feedstore::Image* p = favicon_;
  return p != nullptr ? *p : reinterpret_cast<const ::feedstore::Image&>(
      ::feedstore::_Image_default_instance_);
}
inline const ::feedstore::Image& WebFeedInfo::favicon() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.favicon)
  return _internal_favicon();
}
inline void WebFeedInfo::unsafe_arena_set_allocated_favicon(
    ::feedstore::Image* favicon) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(favicon_);
  }
  favicon_ = favicon;
  if (favicon) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:feedstore.WebFeedInfo.favicon)
}
inline ::feedstore::Image* WebFeedInfo::release_favicon() {
  
  ::feedstore::Image* temp = favicon_;
  favicon_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::feedstore::Image* WebFeedInfo::unsafe_arena_release_favicon() {
  // @@protoc_insertion_point(field_release:feedstore.WebFeedInfo.favicon)
  
  ::feedstore::Image* temp = favicon_;
  favicon_ = nullptr;
  return temp;
}
inline ::feedstore::Image* WebFeedInfo::_internal_mutable_favicon() {
  
  if (favicon_ == nullptr) {
    auto* p = CreateMaybeMessage<::feedstore::Image>(GetArenaForAllocation());
    favicon_ = p;
  }
  return favicon_;
}
inline ::feedstore::Image* WebFeedInfo::mutable_favicon() {
  ::feedstore::Image* _msg = _internal_mutable_favicon();
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.favicon)
  return _msg;
}
inline void WebFeedInfo::set_allocated_favicon(::feedstore::Image* favicon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete favicon_;
  }
  if (favicon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(favicon);
    if (message_arena != submessage_arena) {
      favicon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, favicon, submessage_arena);
    }
    
  } else {
    
  }
  favicon_ = favicon;
  // @@protoc_insertion_point(field_set_allocated:feedstore.WebFeedInfo.favicon)
}

// int64 follower_count = 8;
inline void WebFeedInfo::clear_follower_count() {
  follower_count_ = int64_t{0};
}
inline int64_t WebFeedInfo::_internal_follower_count() const {
  return follower_count_;
}
inline int64_t WebFeedInfo::follower_count() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.follower_count)
  return _internal_follower_count();
}
inline void WebFeedInfo::_internal_set_follower_count(int64_t value) {
  
  follower_count_ = value;
}
inline void WebFeedInfo::set_follower_count(int64_t value) {
  _internal_set_follower_count(value);
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.follower_count)
}

// .feedstore.WebFeedInfo.State state = 9;
inline void WebFeedInfo::clear_state() {
  state_ = 0;
}
inline ::feedstore::WebFeedInfo_State WebFeedInfo::_internal_state() const {
  return static_cast< ::feedstore::WebFeedInfo_State >(state_);
}
inline ::feedstore::WebFeedInfo_State WebFeedInfo::state() const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.state)
  return _internal_state();
}
inline void WebFeedInfo::_internal_set_state(::feedstore::WebFeedInfo_State value) {
  
  state_ = value;
}
inline void WebFeedInfo::set_state(::feedstore::WebFeedInfo_State value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:feedstore.WebFeedInfo.state)
}

// repeated .feedwire.webfeed.WebFeedMatcher matchers = 10;
inline int WebFeedInfo::_internal_matchers_size() const {
  return matchers_.size();
}
inline int WebFeedInfo::matchers_size() const {
  return _internal_matchers_size();
}
inline ::feedwire::webfeed::WebFeedMatcher* WebFeedInfo::mutable_matchers(int index) {
  // @@protoc_insertion_point(field_mutable:feedstore.WebFeedInfo.matchers)
  return matchers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >*
WebFeedInfo::mutable_matchers() {
  // @@protoc_insertion_point(field_mutable_list:feedstore.WebFeedInfo.matchers)
  return &matchers_;
}
inline const ::feedwire::webfeed::WebFeedMatcher& WebFeedInfo::_internal_matchers(int index) const {
  return matchers_.Get(index);
}
inline const ::feedwire::webfeed::WebFeedMatcher& WebFeedInfo::matchers(int index) const {
  // @@protoc_insertion_point(field_get:feedstore.WebFeedInfo.matchers)
  return _internal_matchers(index);
}
inline ::feedwire::webfeed::WebFeedMatcher* WebFeedInfo::_internal_add_matchers() {
  return matchers_.Add();
}
inline ::feedwire::webfeed::WebFeedMatcher* WebFeedInfo::add_matchers() {
  ::feedwire::webfeed::WebFeedMatcher* _add = _internal_add_matchers();
  // @@protoc_insertion_point(field_add:feedstore.WebFeedInfo.matchers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::feedwire::webfeed::WebFeedMatcher >&
WebFeedInfo::matchers() const {
  // @@protoc_insertion_point(field_list:feedstore.WebFeedInfo.matchers)
  return matchers_;
}

// -------------------------------------------------------------------

// PendingWebFeedOperation

// int64 id = 1;
inline void PendingWebFeedOperation::clear_id() {
  id_ = int64_t{0};
}
inline int64_t PendingWebFeedOperation::_internal_id() const {
  return id_;
}
inline int64_t PendingWebFeedOperation::id() const {
  // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.id)
  return _internal_id();
}
inline void PendingWebFeedOperation::_internal_set_id(int64_t value) {
  
  id_ = value;
}
inline void PendingWebFeedOperation::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.id)
}

// .feedstore.PendingWebFeedOperation.Kind kind = 2;
inline void PendingWebFeedOperation::clear_kind() {
  kind_ = 0;
}
inline ::feedstore::PendingWebFeedOperation_Kind PendingWebFeedOperation::_internal_kind() const {
  return static_cast< ::feedstore::PendingWebFeedOperation_Kind >(kind_);
}
inline ::feedstore::PendingWebFeedOperation_Kind PendingWebFeedOperation::kind() const {
  // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.kind)
  return _internal_kind();
}
inline void PendingWebFeedOperation::_internal_set_kind(::feedstore::PendingWebFeedOperation_Kind value) {
  
  kind_ = value;
}
inline void PendingWebFeedOperation::set_kind(::feedstore::PendingWebFeedOperation_Kind value) {
  _internal_set_kind(value);
  // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.kind)
}

// string web_feed_id = 3;
inline void PendingWebFeedOperation::clear_web_feed_id() {
  web_feed_id_.ClearToEmpty();
}
inline const std::string& PendingWebFeedOperation::web_feed_id() const {
  // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.web_feed_id)
  return _internal_web_feed_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PendingWebFeedOperation::set_web_feed_id(ArgT0&& arg0, ArgT... args) {
 
 web_feed_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.web_feed_id)
}
inline std::string* PendingWebFeedOperation::mutable_web_feed_id() {
  std::string* _s = _internal_mutable_web_feed_id();
  // @@protoc_insertion_point(field_mutable:feedstore.PendingWebFeedOperation.web_feed_id)
  return _s;
}
inline const std::string& PendingWebFeedOperation::_internal_web_feed_id() const {
  return web_feed_id_.Get();
}
inline void PendingWebFeedOperation::_internal_set_web_feed_id(const std::string& value) {
  
  web_feed_id_.Set(value, GetArenaForAllocation());
}
inline std::string* PendingWebFeedOperation::_internal_mutable_web_feed_id() {
  
  return web_feed_id_.Mutable(GetArenaForAllocation());
}
inline std::string* PendingWebFeedOperation::release_web_feed_id() {
  // @@protoc_insertion_point(field_release:feedstore.PendingWebFeedOperation.web_feed_id)
  return web_feed_id_.Release();
}
inline void PendingWebFeedOperation::set_allocated_web_feed_id(std::string* web_feed_id) {
  if (web_feed_id != nullptr) {
    
  } else {
    
  }
  web_feed_id_.SetAllocated(web_feed_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (web_feed_id_.IsDefault()) {
    web_feed_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:feedstore.PendingWebFeedOperation.web_feed_id)
}

// int32 attempts = 4;
inline void PendingWebFeedOperation::clear_attempts() {
  attempts_ = 0;
}
inline int32_t PendingWebFeedOperation::_internal_attempts() const {
  return attempts_;
}
inline int32_t PendingWebFeedOperation::attempts() const {
  // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.attempts)
  return _internal_attempts();
}
inline void PendingWebFeedOperation::_internal_set_attempts(int32_t value) {
  
  attempts_ = value;
}
inline void PendingWebFeedOperation::set_attempts(int32_t value) {
  _internal_set_attempts(value);
  // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.attempts)
}

// .feedwire.webfeed.WebFeedChangeReason change_reason = 5;
inline void PendingWebFeedOperation::clear_change_reason() {
  change_reason_ = 0;
}
inline ::feedwire::webfeed::WebFeedChangeReason PendingWebFeedOperation::_internal_change_reason() const {
  return static_cast< ::feedwire::webfeed::WebFeedChangeReason >(change_reason_);
}
inline ::feedwire::webfeed::WebFeedChangeReason PendingWebFeedOperation::change_reason() const {
  // @@protoc_insertion_point(field_get:feedstore.PendingWebFeedOperation.change_reason)
  return _internal_change_reason();
}
inline void PendingWebFeedOperation::_internal_set_change_reason(::feedwire::webfeed::WebFeedChangeReason value) {
  
  change_reason_ = value;
}
inline void PendingWebFeedOperation::set_change_reason(::feedwire::webfeed::WebFeedChangeReason value) {
  _internal_set_change_reason(value);
  // @@protoc_insertion_point(field_set:feedstore.PendingWebFeedOperation.change_reason)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace feedstore

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::feedstore::StreamStructure_Operation> : ::std::true_type {};
template <> struct is_proto_enum< ::feedstore::StreamStructure_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::feedstore::WebFeedInfo_State> : ::std::true_type {};
template <> struct is_proto_enum< ::feedstore::PendingWebFeedOperation_Kind> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2ffeed_2fcore_2fproto_2fv2_2fstore_2eproto
