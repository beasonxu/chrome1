// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/download/database/proto/download_entry.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include "components/download/database/proto/download_source.pb.h"
#include "components/enterprise/common/proto/download_item_reroute_info.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto {
  static const uint32_t offsets[];
};
namespace download_pb {
class DownloadDBEntry;
struct DownloadDBEntryDefaultTypeInternal;
extern DownloadDBEntryDefaultTypeInternal _DownloadDBEntry_default_instance_;
class DownloadEntries;
struct DownloadEntriesDefaultTypeInternal;
extern DownloadEntriesDefaultTypeInternal _DownloadEntries_default_instance_;
class DownloadEntry;
struct DownloadEntryDefaultTypeInternal;
extern DownloadEntryDefaultTypeInternal _DownloadEntry_default_instance_;
class DownloadInfo;
struct DownloadInfoDefaultTypeInternal;
extern DownloadInfoDefaultTypeInternal _DownloadInfo_default_instance_;
class DownloadSchedule;
struct DownloadScheduleDefaultTypeInternal;
extern DownloadScheduleDefaultTypeInternal _DownloadSchedule_default_instance_;
class HttpRequestHeader;
struct HttpRequestHeaderDefaultTypeInternal;
extern HttpRequestHeaderDefaultTypeInternal _HttpRequestHeader_default_instance_;
class InProgressInfo;
struct InProgressInfoDefaultTypeInternal;
extern InProgressInfoDefaultTypeInternal _InProgressInfo_default_instance_;
class ReceivedSlice;
struct ReceivedSliceDefaultTypeInternal;
extern ReceivedSliceDefaultTypeInternal _ReceivedSlice_default_instance_;
class UkmInfo;
struct UkmInfoDefaultTypeInternal;
extern UkmInfoDefaultTypeInternal _UkmInfo_default_instance_;
}  // namespace download_pb
PROTOBUF_NAMESPACE_OPEN
template<> ::download_pb::DownloadDBEntry* Arena::CreateMaybeMessage<::download_pb::DownloadDBEntry>(Arena*);
template<> ::download_pb::DownloadEntries* Arena::CreateMaybeMessage<::download_pb::DownloadEntries>(Arena*);
template<> ::download_pb::DownloadEntry* Arena::CreateMaybeMessage<::download_pb::DownloadEntry>(Arena*);
template<> ::download_pb::DownloadInfo* Arena::CreateMaybeMessage<::download_pb::DownloadInfo>(Arena*);
template<> ::download_pb::DownloadSchedule* Arena::CreateMaybeMessage<::download_pb::DownloadSchedule>(Arena*);
template<> ::download_pb::HttpRequestHeader* Arena::CreateMaybeMessage<::download_pb::HttpRequestHeader>(Arena*);
template<> ::download_pb::InProgressInfo* Arena::CreateMaybeMessage<::download_pb::InProgressInfo>(Arena*);
template<> ::download_pb::ReceivedSlice* Arena::CreateMaybeMessage<::download_pb::ReceivedSlice>(Arena*);
template<> ::download_pb::UkmInfo* Arena::CreateMaybeMessage<::download_pb::UkmInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace download_pb {

// ===================================================================

class HttpRequestHeader final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.HttpRequestHeader) */ {
 public:
  inline HttpRequestHeader() : HttpRequestHeader(nullptr) {}
  ~HttpRequestHeader() override;
  explicit PROTOBUF_CONSTEXPR HttpRequestHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HttpRequestHeader(const HttpRequestHeader& from);
  HttpRequestHeader(HttpRequestHeader&& from) noexcept
    : HttpRequestHeader() {
    *this = ::std::move(from);
  }

  inline HttpRequestHeader& operator=(const HttpRequestHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline HttpRequestHeader& operator=(HttpRequestHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HttpRequestHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const HttpRequestHeader* internal_default_instance() {
    return reinterpret_cast<const HttpRequestHeader*>(
               &_HttpRequestHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(HttpRequestHeader& a, HttpRequestHeader& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(HttpRequestHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HttpRequestHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HttpRequestHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HttpRequestHeader>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HttpRequestHeader& from);
  void MergeFrom(const HttpRequestHeader& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HttpRequestHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.HttpRequestHeader";
  }
  protected:
  explicit HttpRequestHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kValueFieldNumber = 2,
  };
  // optional string key = 1;
  bool has_key() const;
  private:
  bool _internal_has_key() const;
  public:
  void clear_key();
  const std::string& key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_key();
  PROTOBUF_NODISCARD std::string* release_key();
  void set_allocated_key(std::string* key);
  private:
  const std::string& _internal_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_key(const std::string& value);
  std::string* _internal_mutable_key();
  public:

  // optional string value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_NODISCARD std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:download_pb.HttpRequestHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class ReceivedSlice final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.ReceivedSlice) */ {
 public:
  inline ReceivedSlice() : ReceivedSlice(nullptr) {}
  ~ReceivedSlice() override;
  explicit PROTOBUF_CONSTEXPR ReceivedSlice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReceivedSlice(const ReceivedSlice& from);
  ReceivedSlice(ReceivedSlice&& from) noexcept
    : ReceivedSlice() {
    *this = ::std::move(from);
  }

  inline ReceivedSlice& operator=(const ReceivedSlice& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReceivedSlice& operator=(ReceivedSlice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ReceivedSlice& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReceivedSlice* internal_default_instance() {
    return reinterpret_cast<const ReceivedSlice*>(
               &_ReceivedSlice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ReceivedSlice& a, ReceivedSlice& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ReceivedSlice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReceivedSlice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReceivedSlice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReceivedSlice>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ReceivedSlice& from);
  void MergeFrom(const ReceivedSlice& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceivedSlice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.ReceivedSlice";
  }
  protected:
  explicit ReceivedSlice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetFieldNumber = 1,
    kReceivedBytesFieldNumber = 2,
    kFinishedFieldNumber = 3,
  };
  // optional int64 offset = 1;
  bool has_offset() const;
  private:
  bool _internal_has_offset() const;
  public:
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // optional int64 received_bytes = 2;
  bool has_received_bytes() const;
  private:
  bool _internal_has_received_bytes() const;
  public:
  void clear_received_bytes();
  int64_t received_bytes() const;
  void set_received_bytes(int64_t value);
  private:
  int64_t _internal_received_bytes() const;
  void _internal_set_received_bytes(int64_t value);
  public:

  // optional bool finished = 3;
  bool has_finished() const;
  private:
  bool _internal_has_finished() const;
  public:
  void clear_finished();
  bool finished() const;
  void set_finished(bool value);
  private:
  bool _internal_finished() const;
  void _internal_set_finished(bool value);
  public:

  // @@protoc_insertion_point(class_scope:download_pb.ReceivedSlice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t offset_;
  int64_t received_bytes_;
  bool finished_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadEntry) */ {
 public:
  inline DownloadEntry() : DownloadEntry(nullptr) {}
  ~DownloadEntry() override;
  explicit PROTOBUF_CONSTEXPR DownloadEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadEntry(const DownloadEntry& from);
  DownloadEntry(DownloadEntry&& from) noexcept
    : DownloadEntry() {
    *this = ::std::move(from);
  }

  inline DownloadEntry& operator=(const DownloadEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadEntry& operator=(DownloadEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadEntry* internal_default_instance() {
    return reinterpret_cast<const DownloadEntry*>(
               &_DownloadEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DownloadEntry& a, DownloadEntry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DownloadEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadEntry& from);
  void MergeFrom(const DownloadEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadEntry";
  }
  protected:
  explicit DownloadEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestHeadersFieldNumber = 7,
    kGuidFieldNumber = 1,
    kRequestOriginFieldNumber = 2,
    kUkmDownloadIdFieldNumber = 4,
    kDownloadSourceFieldNumber = 3,
    kFetchErrorBodyFieldNumber = 6,
    kBytesWastedFieldNumber = 5,
  };
  // repeated .download_pb.HttpRequestHeader request_headers = 7;
  int request_headers_size() const;
  private:
  int _internal_request_headers_size() const;
  public:
  void clear_request_headers();
  ::download_pb::HttpRequestHeader* mutable_request_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
      mutable_request_headers();
  private:
  const ::download_pb::HttpRequestHeader& _internal_request_headers(int index) const;
  ::download_pb::HttpRequestHeader* _internal_add_request_headers();
  public:
  const ::download_pb::HttpRequestHeader& request_headers(int index) const;
  ::download_pb::HttpRequestHeader* add_request_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
      request_headers() const;

  // optional string guid = 1;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // optional string request_origin = 2;
  bool has_request_origin() const;
  private:
  bool _internal_has_request_origin() const;
  public:
  void clear_request_origin();
  const std::string& request_origin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_origin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_origin();
  PROTOBUF_NODISCARD std::string* release_request_origin();
  void set_allocated_request_origin(std::string* request_origin);
  private:
  const std::string& _internal_request_origin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_origin(const std::string& value);
  std::string* _internal_mutable_request_origin();
  public:

  // optional int64 ukm_download_id = 4;
  bool has_ukm_download_id() const;
  private:
  bool _internal_has_ukm_download_id() const;
  public:
  void clear_ukm_download_id();
  int64_t ukm_download_id() const;
  void set_ukm_download_id(int64_t value);
  private:
  int64_t _internal_ukm_download_id() const;
  void _internal_set_ukm_download_id(int64_t value);
  public:

  // optional .download_pb.DownloadSource download_source = 3;
  bool has_download_source() const;
  private:
  bool _internal_has_download_source() const;
  public:
  void clear_download_source();
  ::download_pb::DownloadSource download_source() const;
  void set_download_source(::download_pb::DownloadSource value);
  private:
  ::download_pb::DownloadSource _internal_download_source() const;
  void _internal_set_download_source(::download_pb::DownloadSource value);
  public:

  // optional bool fetch_error_body = 6;
  bool has_fetch_error_body() const;
  private:
  bool _internal_has_fetch_error_body() const;
  public:
  void clear_fetch_error_body();
  bool fetch_error_body() const;
  void set_fetch_error_body(bool value);
  private:
  bool _internal_fetch_error_body() const;
  void _internal_set_fetch_error_body(bool value);
  public:

  // optional int64 bytes_wasted = 5;
  bool has_bytes_wasted() const;
  private:
  bool _internal_has_bytes_wasted() const;
  public:
  void clear_bytes_wasted();
  int64_t bytes_wasted() const;
  void set_bytes_wasted(int64_t value);
  private:
  int64_t _internal_bytes_wasted() const;
  void _internal_set_bytes_wasted(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:download_pb.DownloadEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader > request_headers_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_origin_;
  int64_t ukm_download_id_;
  int download_source_;
  bool fetch_error_body_;
  int64_t bytes_wasted_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadEntries final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadEntries) */ {
 public:
  inline DownloadEntries() : DownloadEntries(nullptr) {}
  ~DownloadEntries() override;
  explicit PROTOBUF_CONSTEXPR DownloadEntries(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadEntries(const DownloadEntries& from);
  DownloadEntries(DownloadEntries&& from) noexcept
    : DownloadEntries() {
    *this = ::std::move(from);
  }

  inline DownloadEntries& operator=(const DownloadEntries& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadEntries& operator=(DownloadEntries&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadEntries& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadEntries* internal_default_instance() {
    return reinterpret_cast<const DownloadEntries*>(
               &_DownloadEntries_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownloadEntries& a, DownloadEntries& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DownloadEntries* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadEntries* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadEntries* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadEntries>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadEntries& from);
  void MergeFrom(const DownloadEntries& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadEntries* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadEntries";
  }
  protected:
  explicit DownloadEntries(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .download_pb.DownloadEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::download_pb::DownloadEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >*
      mutable_entries();
  private:
  const ::download_pb::DownloadEntry& _internal_entries(int index) const;
  ::download_pb::DownloadEntry* _internal_add_entries();
  public:
  const ::download_pb::DownloadEntry& entries(int index) const;
  ::download_pb::DownloadEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:download_pb.DownloadEntries)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class UkmInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.UkmInfo) */ {
 public:
  inline UkmInfo() : UkmInfo(nullptr) {}
  ~UkmInfo() override;
  explicit PROTOBUF_CONSTEXPR UkmInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  UkmInfo(const UkmInfo& from);
  UkmInfo(UkmInfo&& from) noexcept
    : UkmInfo() {
    *this = ::std::move(from);
  }

  inline UkmInfo& operator=(const UkmInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline UkmInfo& operator=(UkmInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const UkmInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const UkmInfo* internal_default_instance() {
    return reinterpret_cast<const UkmInfo*>(
               &_UkmInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(UkmInfo& a, UkmInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(UkmInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(UkmInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  UkmInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<UkmInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const UkmInfo& from);
  void MergeFrom(const UkmInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(UkmInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.UkmInfo";
  }
  protected:
  explicit UkmInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUkmDownloadIdFieldNumber = 2,
    kDownloadSourceFieldNumber = 1,
  };
  // optional int64 ukm_download_id = 2;
  bool has_ukm_download_id() const;
  private:
  bool _internal_has_ukm_download_id() const;
  public:
  void clear_ukm_download_id();
  int64_t ukm_download_id() const;
  void set_ukm_download_id(int64_t value);
  private:
  int64_t _internal_ukm_download_id() const;
  void _internal_set_ukm_download_id(int64_t value);
  public:

  // optional .download_pb.DownloadSource download_source = 1;
  bool has_download_source() const;
  private:
  bool _internal_has_download_source() const;
  public:
  void clear_download_source();
  ::download_pb::DownloadSource download_source() const;
  void set_download_source(::download_pb::DownloadSource value);
  private:
  ::download_pb::DownloadSource _internal_download_source() const;
  void _internal_set_download_source(::download_pb::DownloadSource value);
  public:

  // @@protoc_insertion_point(class_scope:download_pb.UkmInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t ukm_download_id_;
  int download_source_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadSchedule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadSchedule) */ {
 public:
  inline DownloadSchedule() : DownloadSchedule(nullptr) {}
  ~DownloadSchedule() override;
  explicit PROTOBUF_CONSTEXPR DownloadSchedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadSchedule(const DownloadSchedule& from);
  DownloadSchedule(DownloadSchedule&& from) noexcept
    : DownloadSchedule() {
    *this = ::std::move(from);
  }

  inline DownloadSchedule& operator=(const DownloadSchedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadSchedule& operator=(DownloadSchedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadSchedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadSchedule* internal_default_instance() {
    return reinterpret_cast<const DownloadSchedule*>(
               &_DownloadSchedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(DownloadSchedule& a, DownloadSchedule& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DownloadSchedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadSchedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadSchedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadSchedule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadSchedule& from);
  void MergeFrom(const DownloadSchedule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadSchedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadSchedule";
  }
  protected:
  explicit DownloadSchedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartTimeFieldNumber = 1,
  };
  // optional int64 start_time = 1;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:download_pb.DownloadSchedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int64_t start_time_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class InProgressInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.InProgressInfo) */ {
 public:
  inline InProgressInfo() : InProgressInfo(nullptr) {}
  ~InProgressInfo() override;
  explicit PROTOBUF_CONSTEXPR InProgressInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InProgressInfo(const InProgressInfo& from);
  InProgressInfo(InProgressInfo&& from) noexcept
    : InProgressInfo() {
    *this = ::std::move(from);
  }

  inline InProgressInfo& operator=(const InProgressInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline InProgressInfo& operator=(InProgressInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InProgressInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const InProgressInfo* internal_default_instance() {
    return reinterpret_cast<const InProgressInfo*>(
               &_InProgressInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(InProgressInfo& a, InProgressInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InProgressInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InProgressInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InProgressInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InProgressInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InProgressInfo& from);
  void MergeFrom(const InProgressInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InProgressInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.InProgressInfo";
  }
  protected:
  explicit InProgressInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlChainFieldNumber = 1,
    kRequestHeadersFieldNumber = 7,
    kReceivedSlicesFieldNumber = 18,
    kReferrerUrlFieldNumber = 2,
    kSiteUrlFieldNumber = 3,
    kTabUrlFieldNumber = 4,
    kTabReferrerUrlFieldNumber = 5,
    kEtagFieldNumber = 8,
    kLastModifiedFieldNumber = 9,
    kMimeTypeFieldNumber = 11,
    kOriginalMimeTypeFieldNumber = 12,
    kCurrentPathFieldNumber = 13,
    kTargetPathFieldNumber = 14,
    kHashFieldNumber = 19,
    kSerializedEmbedderDownloadDataFieldNumber = 33,
    kDownloadScheduleFieldNumber = 28,
    kRerouteInfoFieldNumber = 29,
    kTotalBytesFieldNumber = 10,
    kReceivedBytesFieldNumber = 15,
    kStartTimeFieldNumber = 16,
    kEndTimeFieldNumber = 17,
    kFetchErrorBodyFieldNumber = 6,
    kTransientFieldNumber = 20,
    kPausedFieldNumber = 24,
    kMeteredFieldNumber = 25,
    kStateFieldNumber = 21,
    kDangerTypeFieldNumber = 22,
    kInterruptReasonFieldNumber = 23,
    kBytesWastedFieldNumber = 26,
    kAutoResumeCountFieldNumber = 27,
    kCredentialsModeFieldNumber = 30,
    kRangeRequestFromFieldNumber = 31,
    kRangeRequestToFieldNumber = 32,
  };
  // repeated string url_chain = 1;
  int url_chain_size() const;
  private:
  int _internal_url_chain_size() const;
  public:
  void clear_url_chain();
  const std::string& url_chain(int index) const;
  std::string* mutable_url_chain(int index);
  void set_url_chain(int index, const std::string& value);
  void set_url_chain(int index, std::string&& value);
  void set_url_chain(int index, const char* value);
  void set_url_chain(int index, const char* value, size_t size);
  std::string* add_url_chain();
  void add_url_chain(const std::string& value);
  void add_url_chain(std::string&& value);
  void add_url_chain(const char* value);
  void add_url_chain(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& url_chain() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_url_chain();
  private:
  const std::string& _internal_url_chain(int index) const;
  std::string* _internal_add_url_chain();
  public:

  // repeated .download_pb.HttpRequestHeader request_headers = 7;
  int request_headers_size() const;
  private:
  int _internal_request_headers_size() const;
  public:
  void clear_request_headers();
  ::download_pb::HttpRequestHeader* mutable_request_headers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
      mutable_request_headers();
  private:
  const ::download_pb::HttpRequestHeader& _internal_request_headers(int index) const;
  ::download_pb::HttpRequestHeader* _internal_add_request_headers();
  public:
  const ::download_pb::HttpRequestHeader& request_headers(int index) const;
  ::download_pb::HttpRequestHeader* add_request_headers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
      request_headers() const;

  // repeated .download_pb.ReceivedSlice received_slices = 18;
  int received_slices_size() const;
  private:
  int _internal_received_slices_size() const;
  public:
  void clear_received_slices();
  ::download_pb::ReceivedSlice* mutable_received_slices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >*
      mutable_received_slices();
  private:
  const ::download_pb::ReceivedSlice& _internal_received_slices(int index) const;
  ::download_pb::ReceivedSlice* _internal_add_received_slices();
  public:
  const ::download_pb::ReceivedSlice& received_slices(int index) const;
  ::download_pb::ReceivedSlice* add_received_slices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >&
      received_slices() const;

  // optional string referrer_url = 2;
  bool has_referrer_url() const;
  private:
  bool _internal_has_referrer_url() const;
  public:
  void clear_referrer_url();
  const std::string& referrer_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_referrer_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_referrer_url();
  PROTOBUF_NODISCARD std::string* release_referrer_url();
  void set_allocated_referrer_url(std::string* referrer_url);
  private:
  const std::string& _internal_referrer_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_referrer_url(const std::string& value);
  std::string* _internal_mutable_referrer_url();
  public:

  // optional string site_url = 3;
  bool has_site_url() const;
  private:
  bool _internal_has_site_url() const;
  public:
  void clear_site_url();
  const std::string& site_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_site_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_site_url();
  PROTOBUF_NODISCARD std::string* release_site_url();
  void set_allocated_site_url(std::string* site_url);
  private:
  const std::string& _internal_site_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_site_url(const std::string& value);
  std::string* _internal_mutable_site_url();
  public:

  // optional string tab_url = 4;
  bool has_tab_url() const;
  private:
  bool _internal_has_tab_url() const;
  public:
  void clear_tab_url();
  const std::string& tab_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tab_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tab_url();
  PROTOBUF_NODISCARD std::string* release_tab_url();
  void set_allocated_tab_url(std::string* tab_url);
  private:
  const std::string& _internal_tab_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_url(const std::string& value);
  std::string* _internal_mutable_tab_url();
  public:

  // optional string tab_referrer_url = 5;
  bool has_tab_referrer_url() const;
  private:
  bool _internal_has_tab_referrer_url() const;
  public:
  void clear_tab_referrer_url();
  const std::string& tab_referrer_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tab_referrer_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tab_referrer_url();
  PROTOBUF_NODISCARD std::string* release_tab_referrer_url();
  void set_allocated_tab_referrer_url(std::string* tab_referrer_url);
  private:
  const std::string& _internal_tab_referrer_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tab_referrer_url(const std::string& value);
  std::string* _internal_mutable_tab_referrer_url();
  public:

  // optional string etag = 8;
  bool has_etag() const;
  private:
  bool _internal_has_etag() const;
  public:
  void clear_etag();
  const std::string& etag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_etag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_etag();
  PROTOBUF_NODISCARD std::string* release_etag();
  void set_allocated_etag(std::string* etag);
  private:
  const std::string& _internal_etag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_etag(const std::string& value);
  std::string* _internal_mutable_etag();
  public:

  // optional string last_modified = 9;
  bool has_last_modified() const;
  private:
  bool _internal_has_last_modified() const;
  public:
  void clear_last_modified();
  const std::string& last_modified() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_modified(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_modified();
  PROTOBUF_NODISCARD std::string* release_last_modified();
  void set_allocated_last_modified(std::string* last_modified);
  private:
  const std::string& _internal_last_modified() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_modified(const std::string& value);
  std::string* _internal_mutable_last_modified();
  public:

  // optional string mime_type = 11;
  bool has_mime_type() const;
  private:
  bool _internal_has_mime_type() const;
  public:
  void clear_mime_type();
  const std::string& mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_type();
  PROTOBUF_NODISCARD std::string* release_mime_type();
  void set_allocated_mime_type(std::string* mime_type);
  private:
  const std::string& _internal_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_type(const std::string& value);
  std::string* _internal_mutable_mime_type();
  public:

  // optional string original_mime_type = 12;
  bool has_original_mime_type() const;
  private:
  bool _internal_has_original_mime_type() const;
  public:
  void clear_original_mime_type();
  const std::string& original_mime_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_original_mime_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_original_mime_type();
  PROTOBUF_NODISCARD std::string* release_original_mime_type();
  void set_allocated_original_mime_type(std::string* original_mime_type);
  private:
  const std::string& _internal_original_mime_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_original_mime_type(const std::string& value);
  std::string* _internal_mutable_original_mime_type();
  public:

  // optional bytes current_path = 13;
  bool has_current_path() const;
  private:
  bool _internal_has_current_path() const;
  public:
  void clear_current_path();
  const std::string& current_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_current_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_current_path();
  PROTOBUF_NODISCARD std::string* release_current_path();
  void set_allocated_current_path(std::string* current_path);
  private:
  const std::string& _internal_current_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_current_path(const std::string& value);
  std::string* _internal_mutable_current_path();
  public:

  // optional bytes target_path = 14;
  bool has_target_path() const;
  private:
  bool _internal_has_target_path() const;
  public:
  void clear_target_path();
  const std::string& target_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_target_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_target_path();
  PROTOBUF_NODISCARD std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);
  private:
  const std::string& _internal_target_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_target_path(const std::string& value);
  std::string* _internal_mutable_target_path();
  public:

  // optional string hash = 19;
  bool has_hash() const;
  private:
  bool _internal_has_hash() const;
  public:
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // optional string serialized_embedder_download_data = 33;
  bool has_serialized_embedder_download_data() const;
  private:
  bool _internal_has_serialized_embedder_download_data() const;
  public:
  void clear_serialized_embedder_download_data();
  const std::string& serialized_embedder_download_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_embedder_download_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_embedder_download_data();
  PROTOBUF_NODISCARD std::string* release_serialized_embedder_download_data();
  void set_allocated_serialized_embedder_download_data(std::string* serialized_embedder_download_data);
  private:
  const std::string& _internal_serialized_embedder_download_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_embedder_download_data(const std::string& value);
  std::string* _internal_mutable_serialized_embedder_download_data();
  public:

  // optional .download_pb.DownloadSchedule download_schedule = 28;
  bool has_download_schedule() const;
  private:
  bool _internal_has_download_schedule() const;
  public:
  void clear_download_schedule();
  const ::download_pb::DownloadSchedule& download_schedule() const;
  PROTOBUF_NODISCARD ::download_pb::DownloadSchedule* release_download_schedule();
  ::download_pb::DownloadSchedule* mutable_download_schedule();
  void set_allocated_download_schedule(::download_pb::DownloadSchedule* download_schedule);
  private:
  const ::download_pb::DownloadSchedule& _internal_download_schedule() const;
  ::download_pb::DownloadSchedule* _internal_mutable_download_schedule();
  public:
  void unsafe_arena_set_allocated_download_schedule(
      ::download_pb::DownloadSchedule* download_schedule);
  ::download_pb::DownloadSchedule* unsafe_arena_release_download_schedule();

  // optional .enterprise_connectors.DownloadItemRerouteInfo reroute_info = 29;
  bool has_reroute_info() const;
  private:
  bool _internal_has_reroute_info() const;
  public:
  void clear_reroute_info();
  const ::enterprise_connectors::DownloadItemRerouteInfo& reroute_info() const;
  PROTOBUF_NODISCARD ::enterprise_connectors::DownloadItemRerouteInfo* release_reroute_info();
  ::enterprise_connectors::DownloadItemRerouteInfo* mutable_reroute_info();
  void set_allocated_reroute_info(::enterprise_connectors::DownloadItemRerouteInfo* reroute_info);
  private:
  const ::enterprise_connectors::DownloadItemRerouteInfo& _internal_reroute_info() const;
  ::enterprise_connectors::DownloadItemRerouteInfo* _internal_mutable_reroute_info();
  public:
  void unsafe_arena_set_allocated_reroute_info(
      ::enterprise_connectors::DownloadItemRerouteInfo* reroute_info);
  ::enterprise_connectors::DownloadItemRerouteInfo* unsafe_arena_release_reroute_info();

  // optional int64 total_bytes = 10;
  bool has_total_bytes() const;
  private:
  bool _internal_has_total_bytes() const;
  public:
  void clear_total_bytes();
  int64_t total_bytes() const;
  void set_total_bytes(int64_t value);
  private:
  int64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(int64_t value);
  public:

  // optional int64 received_bytes = 15;
  bool has_received_bytes() const;
  private:
  bool _internal_has_received_bytes() const;
  public:
  void clear_received_bytes();
  int64_t received_bytes() const;
  void set_received_bytes(int64_t value);
  private:
  int64_t _internal_received_bytes() const;
  void _internal_set_received_bytes(int64_t value);
  public:

  // optional int64 start_time = 16;
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  int64_t start_time() const;
  void set_start_time(int64_t value);
  private:
  int64_t _internal_start_time() const;
  void _internal_set_start_time(int64_t value);
  public:

  // optional int64 end_time = 17;
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  int64_t end_time() const;
  void set_end_time(int64_t value);
  private:
  int64_t _internal_end_time() const;
  void _internal_set_end_time(int64_t value);
  public:

  // optional bool fetch_error_body = 6;
  bool has_fetch_error_body() const;
  private:
  bool _internal_has_fetch_error_body() const;
  public:
  void clear_fetch_error_body();
  bool fetch_error_body() const;
  void set_fetch_error_body(bool value);
  private:
  bool _internal_fetch_error_body() const;
  void _internal_set_fetch_error_body(bool value);
  public:

  // optional bool transient = 20;
  bool has_transient() const;
  private:
  bool _internal_has_transient() const;
  public:
  void clear_transient();
  bool transient() const;
  void set_transient(bool value);
  private:
  bool _internal_transient() const;
  void _internal_set_transient(bool value);
  public:

  // optional bool paused = 24;
  bool has_paused() const;
  private:
  bool _internal_has_paused() const;
  public:
  void clear_paused();
  bool paused() const;
  void set_paused(bool value);
  private:
  bool _internal_paused() const;
  void _internal_set_paused(bool value);
  public:

  // optional bool metered = 25;
  bool has_metered() const;
  private:
  bool _internal_has_metered() const;
  public:
  void clear_metered();
  bool metered() const;
  void set_metered(bool value);
  private:
  bool _internal_metered() const;
  void _internal_set_metered(bool value);
  public:

  // optional int32 state = 21;
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // optional int32 danger_type = 22;
  bool has_danger_type() const;
  private:
  bool _internal_has_danger_type() const;
  public:
  void clear_danger_type();
  int32_t danger_type() const;
  void set_danger_type(int32_t value);
  private:
  int32_t _internal_danger_type() const;
  void _internal_set_danger_type(int32_t value);
  public:

  // optional int32 interrupt_reason = 23;
  bool has_interrupt_reason() const;
  private:
  bool _internal_has_interrupt_reason() const;
  public:
  void clear_interrupt_reason();
  int32_t interrupt_reason() const;
  void set_interrupt_reason(int32_t value);
  private:
  int32_t _internal_interrupt_reason() const;
  void _internal_set_interrupt_reason(int32_t value);
  public:

  // optional int64 bytes_wasted = 26;
  bool has_bytes_wasted() const;
  private:
  bool _internal_has_bytes_wasted() const;
  public:
  void clear_bytes_wasted();
  int64_t bytes_wasted() const;
  void set_bytes_wasted(int64_t value);
  private:
  int64_t _internal_bytes_wasted() const;
  void _internal_set_bytes_wasted(int64_t value);
  public:

  // optional int32 auto_resume_count = 27;
  bool has_auto_resume_count() const;
  private:
  bool _internal_has_auto_resume_count() const;
  public:
  void clear_auto_resume_count();
  int32_t auto_resume_count() const;
  void set_auto_resume_count(int32_t value);
  private:
  int32_t _internal_auto_resume_count() const;
  void _internal_set_auto_resume_count(int32_t value);
  public:

  // optional int32 credentials_mode = 30;
  bool has_credentials_mode() const;
  private:
  bool _internal_has_credentials_mode() const;
  public:
  void clear_credentials_mode();
  int32_t credentials_mode() const;
  void set_credentials_mode(int32_t value);
  private:
  int32_t _internal_credentials_mode() const;
  void _internal_set_credentials_mode(int32_t value);
  public:

  // optional int64 range_request_from = 31;
  bool has_range_request_from() const;
  private:
  bool _internal_has_range_request_from() const;
  public:
  void clear_range_request_from();
  int64_t range_request_from() const;
  void set_range_request_from(int64_t value);
  private:
  int64_t _internal_range_request_from() const;
  void _internal_set_range_request_from(int64_t value);
  public:

  // optional int64 range_request_to = 32;
  bool has_range_request_to() const;
  private:
  bool _internal_has_range_request_to() const;
  public:
  void clear_range_request_to();
  int64_t range_request_to() const;
  void set_range_request_to(int64_t value);
  private:
  int64_t _internal_range_request_to() const;
  void _internal_set_range_request_to(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:download_pb.InProgressInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> url_chain_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader > request_headers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice > received_slices_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr referrer_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr site_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tab_referrer_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr etag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_modified_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_mime_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr current_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_embedder_download_data_;
  ::download_pb::DownloadSchedule* download_schedule_;
  ::enterprise_connectors::DownloadItemRerouteInfo* reroute_info_;
  int64_t total_bytes_;
  int64_t received_bytes_;
  int64_t start_time_;
  int64_t end_time_;
  bool fetch_error_body_;
  bool transient_;
  bool paused_;
  bool metered_;
  int32_t state_;
  int32_t danger_type_;
  int32_t interrupt_reason_;
  int64_t bytes_wasted_;
  int32_t auto_resume_count_;
  int32_t credentials_mode_;
  int64_t range_request_from_;
  int64_t range_request_to_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadInfo) */ {
 public:
  inline DownloadInfo() : DownloadInfo(nullptr) {}
  ~DownloadInfo() override;
  explicit PROTOBUF_CONSTEXPR DownloadInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadInfo(const DownloadInfo& from);
  DownloadInfo(DownloadInfo&& from) noexcept
    : DownloadInfo() {
    *this = ::std::move(from);
  }

  inline DownloadInfo& operator=(const DownloadInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadInfo& operator=(DownloadInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadInfo* internal_default_instance() {
    return reinterpret_cast<const DownloadInfo*>(
               &_DownloadInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(DownloadInfo& a, DownloadInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DownloadInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadInfo& from);
  void MergeFrom(const DownloadInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadInfo";
  }
  protected:
  explicit DownloadInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGuidFieldNumber = 1,
    kUkmInfoFieldNumber = 3,
    kInProgressInfoFieldNumber = 4,
    kIdFieldNumber = 2,
  };
  // optional string guid = 1;
  bool has_guid() const;
  private:
  bool _internal_has_guid() const;
  public:
  void clear_guid();
  const std::string& guid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guid();
  PROTOBUF_NODISCARD std::string* release_guid();
  void set_allocated_guid(std::string* guid);
  private:
  const std::string& _internal_guid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guid(const std::string& value);
  std::string* _internal_mutable_guid();
  public:

  // optional .download_pb.UkmInfo ukm_info = 3;
  bool has_ukm_info() const;
  private:
  bool _internal_has_ukm_info() const;
  public:
  void clear_ukm_info();
  const ::download_pb::UkmInfo& ukm_info() const;
  PROTOBUF_NODISCARD ::download_pb::UkmInfo* release_ukm_info();
  ::download_pb::UkmInfo* mutable_ukm_info();
  void set_allocated_ukm_info(::download_pb::UkmInfo* ukm_info);
  private:
  const ::download_pb::UkmInfo& _internal_ukm_info() const;
  ::download_pb::UkmInfo* _internal_mutable_ukm_info();
  public:
  void unsafe_arena_set_allocated_ukm_info(
      ::download_pb::UkmInfo* ukm_info);
  ::download_pb::UkmInfo* unsafe_arena_release_ukm_info();

  // optional .download_pb.InProgressInfo in_progress_info = 4;
  bool has_in_progress_info() const;
  private:
  bool _internal_has_in_progress_info() const;
  public:
  void clear_in_progress_info();
  const ::download_pb::InProgressInfo& in_progress_info() const;
  PROTOBUF_NODISCARD ::download_pb::InProgressInfo* release_in_progress_info();
  ::download_pb::InProgressInfo* mutable_in_progress_info();
  void set_allocated_in_progress_info(::download_pb::InProgressInfo* in_progress_info);
  private:
  const ::download_pb::InProgressInfo& _internal_in_progress_info() const;
  ::download_pb::InProgressInfo* _internal_mutable_in_progress_info();
  public:
  void unsafe_arena_set_allocated_in_progress_info(
      ::download_pb::InProgressInfo* in_progress_info);
  ::download_pb::InProgressInfo* unsafe_arena_release_in_progress_info();

  // optional int32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:download_pb.DownloadInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guid_;
  ::download_pb::UkmInfo* ukm_info_;
  ::download_pb::InProgressInfo* in_progress_info_;
  int32_t id_;
  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// -------------------------------------------------------------------

class DownloadDBEntry final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:download_pb.DownloadDBEntry) */ {
 public:
  inline DownloadDBEntry() : DownloadDBEntry(nullptr) {}
  ~DownloadDBEntry() override;
  explicit PROTOBUF_CONSTEXPR DownloadDBEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadDBEntry(const DownloadDBEntry& from);
  DownloadDBEntry(DownloadDBEntry&& from) noexcept
    : DownloadDBEntry() {
    *this = ::std::move(from);
  }

  inline DownloadDBEntry& operator=(const DownloadDBEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadDBEntry& operator=(DownloadDBEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DownloadDBEntry& default_instance() {
    return *internal_default_instance();
  }
  enum EntryCase {
    kDownloadInfo = 1,
    ENTRY_NOT_SET = 0,
  };

  static inline const DownloadDBEntry* internal_default_instance() {
    return reinterpret_cast<const DownloadDBEntry*>(
               &_DownloadDBEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DownloadDBEntry& a, DownloadDBEntry& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DownloadDBEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadDBEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadDBEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadDBEntry>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadDBEntry& from);
  void MergeFrom(const DownloadDBEntry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadDBEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "download_pb.DownloadDBEntry";
  }
  protected:
  explicit DownloadDBEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDownloadInfoFieldNumber = 1,
  };
  // .download_pb.DownloadInfo download_info = 1;
  bool has_download_info() const;
  private:
  bool _internal_has_download_info() const;
  public:
  void clear_download_info();
  const ::download_pb::DownloadInfo& download_info() const;
  PROTOBUF_NODISCARD ::download_pb::DownloadInfo* release_download_info();
  ::download_pb::DownloadInfo* mutable_download_info();
  void set_allocated_download_info(::download_pb::DownloadInfo* download_info);
  private:
  const ::download_pb::DownloadInfo& _internal_download_info() const;
  ::download_pb::DownloadInfo* _internal_mutable_download_info();
  public:
  void unsafe_arena_set_allocated_download_info(
      ::download_pb::DownloadInfo* download_info);
  ::download_pb::DownloadInfo* unsafe_arena_release_download_info();

  void clear_entry();
  EntryCase entry_case() const;
  // @@protoc_insertion_point(class_scope:download_pb.DownloadDBEntry)
 private:
  class _Internal;
  void set_has_download_info();

  inline bool has_entry() const;
  inline void clear_has_entry();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union EntryUnion {
    constexpr EntryUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::download_pb::DownloadInfo* download_info_;
  } entry_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HttpRequestHeader

// optional string key = 1;
inline bool HttpRequestHeader::_internal_has_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HttpRequestHeader::has_key() const {
  return _internal_has_key();
}
inline void HttpRequestHeader::clear_key() {
  key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HttpRequestHeader::key() const {
  // @@protoc_insertion_point(field_get:download_pb.HttpRequestHeader.key)
  return _internal_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRequestHeader::set_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 key_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.HttpRequestHeader.key)
}
inline std::string* HttpRequestHeader::mutable_key() {
  std::string* _s = _internal_mutable_key();
  // @@protoc_insertion_point(field_mutable:download_pb.HttpRequestHeader.key)
  return _s;
}
inline const std::string& HttpRequestHeader::_internal_key() const {
  return key_.Get();
}
inline void HttpRequestHeader::_internal_set_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  key_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRequestHeader::_internal_mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  return key_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRequestHeader::release_key() {
  // @@protoc_insertion_point(field_release:download_pb.HttpRequestHeader.key)
  if (!_internal_has_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = key_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpRequestHeader::set_allocated_key(std::string* key) {
  if (key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_.SetAllocated(key, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (key_.IsDefault()) {
    key_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.HttpRequestHeader.key)
}

// optional string value = 2;
inline bool HttpRequestHeader::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool HttpRequestHeader::has_value() const {
  return _internal_has_value();
}
inline void HttpRequestHeader::clear_value() {
  value_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& HttpRequestHeader::value() const {
  // @@protoc_insertion_point(field_get:download_pb.HttpRequestHeader.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HttpRequestHeader::set_value(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.HttpRequestHeader.value)
}
inline std::string* HttpRequestHeader::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:download_pb.HttpRequestHeader.value)
  return _s;
}
inline const std::string& HttpRequestHeader::_internal_value() const {
  return value_.Get();
}
inline void HttpRequestHeader::_internal_set_value(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  value_.Set(value, GetArenaForAllocation());
}
inline std::string* HttpRequestHeader::_internal_mutable_value() {
  _has_bits_[0] |= 0x00000002u;
  return value_.Mutable(GetArenaForAllocation());
}
inline std::string* HttpRequestHeader::release_value() {
  // @@protoc_insertion_point(field_release:download_pb.HttpRequestHeader.value)
  if (!_internal_has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HttpRequestHeader::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  value_.SetAllocated(value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (value_.IsDefault()) {
    value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.HttpRequestHeader.value)
}

// -------------------------------------------------------------------

// ReceivedSlice

// optional int64 offset = 1;
inline bool ReceivedSlice::_internal_has_offset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ReceivedSlice::has_offset() const {
  return _internal_has_offset();
}
inline void ReceivedSlice::clear_offset() {
  offset_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t ReceivedSlice::_internal_offset() const {
  return offset_;
}
inline int64_t ReceivedSlice::offset() const {
  // @@protoc_insertion_point(field_get:download_pb.ReceivedSlice.offset)
  return _internal_offset();
}
inline void ReceivedSlice::_internal_set_offset(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  offset_ = value;
}
inline void ReceivedSlice::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:download_pb.ReceivedSlice.offset)
}

// optional int64 received_bytes = 2;
inline bool ReceivedSlice::_internal_has_received_bytes() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool ReceivedSlice::has_received_bytes() const {
  return _internal_has_received_bytes();
}
inline void ReceivedSlice::clear_received_bytes() {
  received_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t ReceivedSlice::_internal_received_bytes() const {
  return received_bytes_;
}
inline int64_t ReceivedSlice::received_bytes() const {
  // @@protoc_insertion_point(field_get:download_pb.ReceivedSlice.received_bytes)
  return _internal_received_bytes();
}
inline void ReceivedSlice::_internal_set_received_bytes(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  received_bytes_ = value;
}
inline void ReceivedSlice::set_received_bytes(int64_t value) {
  _internal_set_received_bytes(value);
  // @@protoc_insertion_point(field_set:download_pb.ReceivedSlice.received_bytes)
}

// optional bool finished = 3;
inline bool ReceivedSlice::_internal_has_finished() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ReceivedSlice::has_finished() const {
  return _internal_has_finished();
}
inline void ReceivedSlice::clear_finished() {
  finished_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool ReceivedSlice::_internal_finished() const {
  return finished_;
}
inline bool ReceivedSlice::finished() const {
  // @@protoc_insertion_point(field_get:download_pb.ReceivedSlice.finished)
  return _internal_finished();
}
inline void ReceivedSlice::_internal_set_finished(bool value) {
  _has_bits_[0] |= 0x00000004u;
  finished_ = value;
}
inline void ReceivedSlice::set_finished(bool value) {
  _internal_set_finished(value);
  // @@protoc_insertion_point(field_set:download_pb.ReceivedSlice.finished)
}

// -------------------------------------------------------------------

// DownloadEntry

// optional string guid = 1;
inline bool DownloadEntry::_internal_has_guid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DownloadEntry::has_guid() const {
  return _internal_has_guid();
}
inline void DownloadEntry::clear_guid() {
  guid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadEntry::guid() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadEntry::set_guid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.guid)
}
inline std::string* DownloadEntry::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntry.guid)
  return _s;
}
inline const std::string& DownloadEntry::_internal_guid() const {
  return guid_.Get();
}
inline void DownloadEntry::_internal_set_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadEntry::_internal_mutable_guid() {
  _has_bits_[0] |= 0x00000001u;
  return guid_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadEntry::release_guid() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadEntry.guid)
  if (!_internal_has_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guid_.IsDefault()) {
    guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DownloadEntry::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guid_.IsDefault()) {
    guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadEntry.guid)
}

// optional string request_origin = 2;
inline bool DownloadEntry::_internal_has_request_origin() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool DownloadEntry::has_request_origin() const {
  return _internal_has_request_origin();
}
inline void DownloadEntry::clear_request_origin() {
  request_origin_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& DownloadEntry::request_origin() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.request_origin)
  return _internal_request_origin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadEntry::set_request_origin(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 request_origin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.request_origin)
}
inline std::string* DownloadEntry::mutable_request_origin() {
  std::string* _s = _internal_mutable_request_origin();
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntry.request_origin)
  return _s;
}
inline const std::string& DownloadEntry::_internal_request_origin() const {
  return request_origin_.Get();
}
inline void DownloadEntry::_internal_set_request_origin(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  request_origin_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadEntry::_internal_mutable_request_origin() {
  _has_bits_[0] |= 0x00000002u;
  return request_origin_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadEntry::release_request_origin() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadEntry.request_origin)
  if (!_internal_has_request_origin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = request_origin_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_origin_.IsDefault()) {
    request_origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DownloadEntry::set_allocated_request_origin(std::string* request_origin) {
  if (request_origin != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  request_origin_.SetAllocated(request_origin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_origin_.IsDefault()) {
    request_origin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadEntry.request_origin)
}

// optional .download_pb.DownloadSource download_source = 3;
inline bool DownloadEntry::_internal_has_download_source() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DownloadEntry::has_download_source() const {
  return _internal_has_download_source();
}
inline void DownloadEntry::clear_download_source() {
  download_source_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::download_pb::DownloadSource DownloadEntry::_internal_download_source() const {
  return static_cast< ::download_pb::DownloadSource >(download_source_);
}
inline ::download_pb::DownloadSource DownloadEntry::download_source() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.download_source)
  return _internal_download_source();
}
inline void DownloadEntry::_internal_set_download_source(::download_pb::DownloadSource value) {
  assert(::download_pb::DownloadSource_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  download_source_ = value;
}
inline void DownloadEntry::set_download_source(::download_pb::DownloadSource value) {
  _internal_set_download_source(value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.download_source)
}

// optional int64 ukm_download_id = 4;
inline bool DownloadEntry::_internal_has_ukm_download_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool DownloadEntry::has_ukm_download_id() const {
  return _internal_has_ukm_download_id();
}
inline void DownloadEntry::clear_ukm_download_id() {
  ukm_download_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t DownloadEntry::_internal_ukm_download_id() const {
  return ukm_download_id_;
}
inline int64_t DownloadEntry::ukm_download_id() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.ukm_download_id)
  return _internal_ukm_download_id();
}
inline void DownloadEntry::_internal_set_ukm_download_id(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  ukm_download_id_ = value;
}
inline void DownloadEntry::set_ukm_download_id(int64_t value) {
  _internal_set_ukm_download_id(value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.ukm_download_id)
}

// optional int64 bytes_wasted = 5;
inline bool DownloadEntry::_internal_has_bytes_wasted() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool DownloadEntry::has_bytes_wasted() const {
  return _internal_has_bytes_wasted();
}
inline void DownloadEntry::clear_bytes_wasted() {
  bytes_wasted_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t DownloadEntry::_internal_bytes_wasted() const {
  return bytes_wasted_;
}
inline int64_t DownloadEntry::bytes_wasted() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.bytes_wasted)
  return _internal_bytes_wasted();
}
inline void DownloadEntry::_internal_set_bytes_wasted(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  bytes_wasted_ = value;
}
inline void DownloadEntry::set_bytes_wasted(int64_t value) {
  _internal_set_bytes_wasted(value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.bytes_wasted)
}

// optional bool fetch_error_body = 6;
inline bool DownloadEntry::_internal_has_fetch_error_body() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool DownloadEntry::has_fetch_error_body() const {
  return _internal_has_fetch_error_body();
}
inline void DownloadEntry::clear_fetch_error_body() {
  fetch_error_body_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool DownloadEntry::_internal_fetch_error_body() const {
  return fetch_error_body_;
}
inline bool DownloadEntry::fetch_error_body() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.fetch_error_body)
  return _internal_fetch_error_body();
}
inline void DownloadEntry::_internal_set_fetch_error_body(bool value) {
  _has_bits_[0] |= 0x00000010u;
  fetch_error_body_ = value;
}
inline void DownloadEntry::set_fetch_error_body(bool value) {
  _internal_set_fetch_error_body(value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadEntry.fetch_error_body)
}

// repeated .download_pb.HttpRequestHeader request_headers = 7;
inline int DownloadEntry::_internal_request_headers_size() const {
  return request_headers_.size();
}
inline int DownloadEntry::request_headers_size() const {
  return _internal_request_headers_size();
}
inline void DownloadEntry::clear_request_headers() {
  request_headers_.Clear();
}
inline ::download_pb::HttpRequestHeader* DownloadEntry::mutable_request_headers(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntry.request_headers)
  return request_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
DownloadEntry::mutable_request_headers() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.DownloadEntry.request_headers)
  return &request_headers_;
}
inline const ::download_pb::HttpRequestHeader& DownloadEntry::_internal_request_headers(int index) const {
  return request_headers_.Get(index);
}
inline const ::download_pb::HttpRequestHeader& DownloadEntry::request_headers(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntry.request_headers)
  return _internal_request_headers(index);
}
inline ::download_pb::HttpRequestHeader* DownloadEntry::_internal_add_request_headers() {
  return request_headers_.Add();
}
inline ::download_pb::HttpRequestHeader* DownloadEntry::add_request_headers() {
  ::download_pb::HttpRequestHeader* _add = _internal_add_request_headers();
  // @@protoc_insertion_point(field_add:download_pb.DownloadEntry.request_headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
DownloadEntry::request_headers() const {
  // @@protoc_insertion_point(field_list:download_pb.DownloadEntry.request_headers)
  return request_headers_;
}

// -------------------------------------------------------------------

// DownloadEntries

// repeated .download_pb.DownloadEntry entries = 1;
inline int DownloadEntries::_internal_entries_size() const {
  return entries_.size();
}
inline int DownloadEntries::entries_size() const {
  return _internal_entries_size();
}
inline void DownloadEntries::clear_entries() {
  entries_.Clear();
}
inline ::download_pb::DownloadEntry* DownloadEntries::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadEntries.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >*
DownloadEntries::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.DownloadEntries.entries)
  return &entries_;
}
inline const ::download_pb::DownloadEntry& DownloadEntries::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::download_pb::DownloadEntry& DownloadEntries::entries(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadEntries.entries)
  return _internal_entries(index);
}
inline ::download_pb::DownloadEntry* DownloadEntries::_internal_add_entries() {
  return entries_.Add();
}
inline ::download_pb::DownloadEntry* DownloadEntries::add_entries() {
  ::download_pb::DownloadEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:download_pb.DownloadEntries.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::DownloadEntry >&
DownloadEntries::entries() const {
  // @@protoc_insertion_point(field_list:download_pb.DownloadEntries.entries)
  return entries_;
}

// -------------------------------------------------------------------

// UkmInfo

// optional .download_pb.DownloadSource download_source = 1;
inline bool UkmInfo::_internal_has_download_source() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool UkmInfo::has_download_source() const {
  return _internal_has_download_source();
}
inline void UkmInfo::clear_download_source() {
  download_source_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::download_pb::DownloadSource UkmInfo::_internal_download_source() const {
  return static_cast< ::download_pb::DownloadSource >(download_source_);
}
inline ::download_pb::DownloadSource UkmInfo::download_source() const {
  // @@protoc_insertion_point(field_get:download_pb.UkmInfo.download_source)
  return _internal_download_source();
}
inline void UkmInfo::_internal_set_download_source(::download_pb::DownloadSource value) {
  assert(::download_pb::DownloadSource_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  download_source_ = value;
}
inline void UkmInfo::set_download_source(::download_pb::DownloadSource value) {
  _internal_set_download_source(value);
  // @@protoc_insertion_point(field_set:download_pb.UkmInfo.download_source)
}

// optional int64 ukm_download_id = 2;
inline bool UkmInfo::_internal_has_ukm_download_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool UkmInfo::has_ukm_download_id() const {
  return _internal_has_ukm_download_id();
}
inline void UkmInfo::clear_ukm_download_id() {
  ukm_download_id_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t UkmInfo::_internal_ukm_download_id() const {
  return ukm_download_id_;
}
inline int64_t UkmInfo::ukm_download_id() const {
  // @@protoc_insertion_point(field_get:download_pb.UkmInfo.ukm_download_id)
  return _internal_ukm_download_id();
}
inline void UkmInfo::_internal_set_ukm_download_id(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  ukm_download_id_ = value;
}
inline void UkmInfo::set_ukm_download_id(int64_t value) {
  _internal_set_ukm_download_id(value);
  // @@protoc_insertion_point(field_set:download_pb.UkmInfo.ukm_download_id)
}

// -------------------------------------------------------------------

// DownloadSchedule

// optional int64 start_time = 1;
inline bool DownloadSchedule::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DownloadSchedule::has_start_time() const {
  return _internal_has_start_time();
}
inline void DownloadSchedule::clear_start_time() {
  start_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00000001u;
}
inline int64_t DownloadSchedule::_internal_start_time() const {
  return start_time_;
}
inline int64_t DownloadSchedule::start_time() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadSchedule.start_time)
  return _internal_start_time();
}
inline void DownloadSchedule::_internal_set_start_time(int64_t value) {
  _has_bits_[0] |= 0x00000001u;
  start_time_ = value;
}
inline void DownloadSchedule::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadSchedule.start_time)
}

// -------------------------------------------------------------------

// InProgressInfo

// repeated string url_chain = 1;
inline int InProgressInfo::_internal_url_chain_size() const {
  return url_chain_.size();
}
inline int InProgressInfo::url_chain_size() const {
  return _internal_url_chain_size();
}
inline void InProgressInfo::clear_url_chain() {
  url_chain_.Clear();
}
inline std::string* InProgressInfo::add_url_chain() {
  std::string* _s = _internal_add_url_chain();
  // @@protoc_insertion_point(field_add_mutable:download_pb.InProgressInfo.url_chain)
  return _s;
}
inline const std::string& InProgressInfo::_internal_url_chain(int index) const {
  return url_chain_.Get(index);
}
inline const std::string& InProgressInfo::url_chain(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.url_chain)
  return _internal_url_chain(index);
}
inline std::string* InProgressInfo::mutable_url_chain(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.url_chain)
  return url_chain_.Mutable(index);
}
inline void InProgressInfo::set_url_chain(int index, const std::string& value) {
  url_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::set_url_chain(int index, std::string&& value) {
  url_chain_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::set_url_chain(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  url_chain_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::set_url_chain(int index, const char* value, size_t size) {
  url_chain_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:download_pb.InProgressInfo.url_chain)
}
inline std::string* InProgressInfo::_internal_add_url_chain() {
  return url_chain_.Add();
}
inline void InProgressInfo::add_url_chain(const std::string& value) {
  url_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::add_url_chain(std::string&& value) {
  url_chain_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::add_url_chain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  url_chain_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:download_pb.InProgressInfo.url_chain)
}
inline void InProgressInfo::add_url_chain(const char* value, size_t size) {
  url_chain_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:download_pb.InProgressInfo.url_chain)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
InProgressInfo::url_chain() const {
  // @@protoc_insertion_point(field_list:download_pb.InProgressInfo.url_chain)
  return url_chain_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
InProgressInfo::mutable_url_chain() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.InProgressInfo.url_chain)
  return &url_chain_;
}

// optional string referrer_url = 2;
inline bool InProgressInfo::_internal_has_referrer_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool InProgressInfo::has_referrer_url() const {
  return _internal_has_referrer_url();
}
inline void InProgressInfo::clear_referrer_url() {
  referrer_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& InProgressInfo::referrer_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.referrer_url)
  return _internal_referrer_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_referrer_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 referrer_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.referrer_url)
}
inline std::string* InProgressInfo::mutable_referrer_url() {
  std::string* _s = _internal_mutable_referrer_url();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.referrer_url)
  return _s;
}
inline const std::string& InProgressInfo::_internal_referrer_url() const {
  return referrer_url_.Get();
}
inline void InProgressInfo::_internal_set_referrer_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  referrer_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_referrer_url() {
  _has_bits_[0] |= 0x00000001u;
  return referrer_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_referrer_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.referrer_url)
  if (!_internal_has_referrer_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = referrer_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (referrer_url_.IsDefault()) {
    referrer_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_referrer_url(std::string* referrer_url) {
  if (referrer_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  referrer_url_.SetAllocated(referrer_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (referrer_url_.IsDefault()) {
    referrer_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.referrer_url)
}

// optional string site_url = 3;
inline bool InProgressInfo::_internal_has_site_url() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool InProgressInfo::has_site_url() const {
  return _internal_has_site_url();
}
inline void InProgressInfo::clear_site_url() {
  site_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& InProgressInfo::site_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.site_url)
  return _internal_site_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_site_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 site_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.site_url)
}
inline std::string* InProgressInfo::mutable_site_url() {
  std::string* _s = _internal_mutable_site_url();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.site_url)
  return _s;
}
inline const std::string& InProgressInfo::_internal_site_url() const {
  return site_url_.Get();
}
inline void InProgressInfo::_internal_set_site_url(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  site_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_site_url() {
  _has_bits_[0] |= 0x00000002u;
  return site_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_site_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.site_url)
  if (!_internal_has_site_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = site_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (site_url_.IsDefault()) {
    site_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_site_url(std::string* site_url) {
  if (site_url != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  site_url_.SetAllocated(site_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (site_url_.IsDefault()) {
    site_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.site_url)
}

// optional string tab_url = 4;
inline bool InProgressInfo::_internal_has_tab_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InProgressInfo::has_tab_url() const {
  return _internal_has_tab_url();
}
inline void InProgressInfo::clear_tab_url() {
  tab_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& InProgressInfo::tab_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.tab_url)
  return _internal_tab_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_tab_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 tab_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.tab_url)
}
inline std::string* InProgressInfo::mutable_tab_url() {
  std::string* _s = _internal_mutable_tab_url();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.tab_url)
  return _s;
}
inline const std::string& InProgressInfo::_internal_tab_url() const {
  return tab_url_.Get();
}
inline void InProgressInfo::_internal_set_tab_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  tab_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_tab_url() {
  _has_bits_[0] |= 0x00000004u;
  return tab_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_tab_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.tab_url)
  if (!_internal_has_tab_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = tab_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tab_url_.IsDefault()) {
    tab_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_tab_url(std::string* tab_url) {
  if (tab_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  tab_url_.SetAllocated(tab_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tab_url_.IsDefault()) {
    tab_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.tab_url)
}

// optional string tab_referrer_url = 5;
inline bool InProgressInfo::_internal_has_tab_referrer_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool InProgressInfo::has_tab_referrer_url() const {
  return _internal_has_tab_referrer_url();
}
inline void InProgressInfo::clear_tab_referrer_url() {
  tab_referrer_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& InProgressInfo::tab_referrer_url() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.tab_referrer_url)
  return _internal_tab_referrer_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_tab_referrer_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 tab_referrer_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.tab_referrer_url)
}
inline std::string* InProgressInfo::mutable_tab_referrer_url() {
  std::string* _s = _internal_mutable_tab_referrer_url();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.tab_referrer_url)
  return _s;
}
inline const std::string& InProgressInfo::_internal_tab_referrer_url() const {
  return tab_referrer_url_.Get();
}
inline void InProgressInfo::_internal_set_tab_referrer_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  tab_referrer_url_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_tab_referrer_url() {
  _has_bits_[0] |= 0x00000008u;
  return tab_referrer_url_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_tab_referrer_url() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.tab_referrer_url)
  if (!_internal_has_tab_referrer_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = tab_referrer_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tab_referrer_url_.IsDefault()) {
    tab_referrer_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_tab_referrer_url(std::string* tab_referrer_url) {
  if (tab_referrer_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  tab_referrer_url_.SetAllocated(tab_referrer_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tab_referrer_url_.IsDefault()) {
    tab_referrer_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.tab_referrer_url)
}

// optional bool fetch_error_body = 6;
inline bool InProgressInfo::_internal_has_fetch_error_body() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool InProgressInfo::has_fetch_error_body() const {
  return _internal_has_fetch_error_body();
}
inline void InProgressInfo::clear_fetch_error_body() {
  fetch_error_body_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool InProgressInfo::_internal_fetch_error_body() const {
  return fetch_error_body_;
}
inline bool InProgressInfo::fetch_error_body() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.fetch_error_body)
  return _internal_fetch_error_body();
}
inline void InProgressInfo::_internal_set_fetch_error_body(bool value) {
  _has_bits_[0] |= 0x00040000u;
  fetch_error_body_ = value;
}
inline void InProgressInfo::set_fetch_error_body(bool value) {
  _internal_set_fetch_error_body(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.fetch_error_body)
}

// repeated .download_pb.HttpRequestHeader request_headers = 7;
inline int InProgressInfo::_internal_request_headers_size() const {
  return request_headers_.size();
}
inline int InProgressInfo::request_headers_size() const {
  return _internal_request_headers_size();
}
inline void InProgressInfo::clear_request_headers() {
  request_headers_.Clear();
}
inline ::download_pb::HttpRequestHeader* InProgressInfo::mutable_request_headers(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.request_headers)
  return request_headers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >*
InProgressInfo::mutable_request_headers() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.InProgressInfo.request_headers)
  return &request_headers_;
}
inline const ::download_pb::HttpRequestHeader& InProgressInfo::_internal_request_headers(int index) const {
  return request_headers_.Get(index);
}
inline const ::download_pb::HttpRequestHeader& InProgressInfo::request_headers(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.request_headers)
  return _internal_request_headers(index);
}
inline ::download_pb::HttpRequestHeader* InProgressInfo::_internal_add_request_headers() {
  return request_headers_.Add();
}
inline ::download_pb::HttpRequestHeader* InProgressInfo::add_request_headers() {
  ::download_pb::HttpRequestHeader* _add = _internal_add_request_headers();
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.request_headers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::HttpRequestHeader >&
InProgressInfo::request_headers() const {
  // @@protoc_insertion_point(field_list:download_pb.InProgressInfo.request_headers)
  return request_headers_;
}

// optional string etag = 8;
inline bool InProgressInfo::_internal_has_etag() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool InProgressInfo::has_etag() const {
  return _internal_has_etag();
}
inline void InProgressInfo::clear_etag() {
  etag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& InProgressInfo::etag() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.etag)
  return _internal_etag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_etag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 etag_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.etag)
}
inline std::string* InProgressInfo::mutable_etag() {
  std::string* _s = _internal_mutable_etag();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.etag)
  return _s;
}
inline const std::string& InProgressInfo::_internal_etag() const {
  return etag_.Get();
}
inline void InProgressInfo::_internal_set_etag(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  etag_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_etag() {
  _has_bits_[0] |= 0x00000010u;
  return etag_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_etag() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.etag)
  if (!_internal_has_etag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = etag_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_etag(std::string* etag) {
  if (etag != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  etag_.SetAllocated(etag, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (etag_.IsDefault()) {
    etag_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.etag)
}

// optional string last_modified = 9;
inline bool InProgressInfo::_internal_has_last_modified() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool InProgressInfo::has_last_modified() const {
  return _internal_has_last_modified();
}
inline void InProgressInfo::clear_last_modified() {
  last_modified_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& InProgressInfo::last_modified() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.last_modified)
  return _internal_last_modified();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_last_modified(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 last_modified_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.last_modified)
}
inline std::string* InProgressInfo::mutable_last_modified() {
  std::string* _s = _internal_mutable_last_modified();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.last_modified)
  return _s;
}
inline const std::string& InProgressInfo::_internal_last_modified() const {
  return last_modified_.Get();
}
inline void InProgressInfo::_internal_set_last_modified(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  last_modified_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_last_modified() {
  _has_bits_[0] |= 0x00000020u;
  return last_modified_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_last_modified() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.last_modified)
  if (!_internal_has_last_modified()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = last_modified_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_modified_.IsDefault()) {
    last_modified_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_last_modified(std::string* last_modified) {
  if (last_modified != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  last_modified_.SetAllocated(last_modified, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (last_modified_.IsDefault()) {
    last_modified_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.last_modified)
}

// optional int64 total_bytes = 10;
inline bool InProgressInfo::_internal_has_total_bytes() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool InProgressInfo::has_total_bytes() const {
  return _internal_has_total_bytes();
}
inline void InProgressInfo::clear_total_bytes() {
  total_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00004000u;
}
inline int64_t InProgressInfo::_internal_total_bytes() const {
  return total_bytes_;
}
inline int64_t InProgressInfo::total_bytes() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.total_bytes)
  return _internal_total_bytes();
}
inline void InProgressInfo::_internal_set_total_bytes(int64_t value) {
  _has_bits_[0] |= 0x00004000u;
  total_bytes_ = value;
}
inline void InProgressInfo::set_total_bytes(int64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.total_bytes)
}

// optional string mime_type = 11;
inline bool InProgressInfo::_internal_has_mime_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool InProgressInfo::has_mime_type() const {
  return _internal_has_mime_type();
}
inline void InProgressInfo::clear_mime_type() {
  mime_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& InProgressInfo::mime_type() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.mime_type)
  return _internal_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_mime_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.mime_type)
}
inline std::string* InProgressInfo::mutable_mime_type() {
  std::string* _s = _internal_mutable_mime_type();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.mime_type)
  return _s;
}
inline const std::string& InProgressInfo::_internal_mime_type() const {
  return mime_type_.Get();
}
inline void InProgressInfo::_internal_set_mime_type(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_mime_type() {
  _has_bits_[0] |= 0x00000040u;
  return mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_mime_type() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.mime_type)
  if (!_internal_has_mime_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_mime_type(std::string* mime_type) {
  if (mime_type != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  mime_type_.SetAllocated(mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (mime_type_.IsDefault()) {
    mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.mime_type)
}

// optional string original_mime_type = 12;
inline bool InProgressInfo::_internal_has_original_mime_type() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool InProgressInfo::has_original_mime_type() const {
  return _internal_has_original_mime_type();
}
inline void InProgressInfo::clear_original_mime_type() {
  original_mime_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& InProgressInfo::original_mime_type() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.original_mime_type)
  return _internal_original_mime_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_original_mime_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 original_mime_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.original_mime_type)
}
inline std::string* InProgressInfo::mutable_original_mime_type() {
  std::string* _s = _internal_mutable_original_mime_type();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.original_mime_type)
  return _s;
}
inline const std::string& InProgressInfo::_internal_original_mime_type() const {
  return original_mime_type_.Get();
}
inline void InProgressInfo::_internal_set_original_mime_type(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  original_mime_type_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_original_mime_type() {
  _has_bits_[0] |= 0x00000080u;
  return original_mime_type_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_original_mime_type() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.original_mime_type)
  if (!_internal_has_original_mime_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = original_mime_type_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (original_mime_type_.IsDefault()) {
    original_mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_original_mime_type(std::string* original_mime_type) {
  if (original_mime_type != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  original_mime_type_.SetAllocated(original_mime_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (original_mime_type_.IsDefault()) {
    original_mime_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.original_mime_type)
}

// optional bytes current_path = 13;
inline bool InProgressInfo::_internal_has_current_path() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool InProgressInfo::has_current_path() const {
  return _internal_has_current_path();
}
inline void InProgressInfo::clear_current_path() {
  current_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& InProgressInfo::current_path() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.current_path)
  return _internal_current_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_current_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 current_path_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.current_path)
}
inline std::string* InProgressInfo::mutable_current_path() {
  std::string* _s = _internal_mutable_current_path();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.current_path)
  return _s;
}
inline const std::string& InProgressInfo::_internal_current_path() const {
  return current_path_.Get();
}
inline void InProgressInfo::_internal_set_current_path(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  current_path_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_current_path() {
  _has_bits_[0] |= 0x00000100u;
  return current_path_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_current_path() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.current_path)
  if (!_internal_has_current_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = current_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_path_.IsDefault()) {
    current_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_current_path(std::string* current_path) {
  if (current_path != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  current_path_.SetAllocated(current_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (current_path_.IsDefault()) {
    current_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.current_path)
}

// optional bytes target_path = 14;
inline bool InProgressInfo::_internal_has_target_path() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool InProgressInfo::has_target_path() const {
  return _internal_has_target_path();
}
inline void InProgressInfo::clear_target_path() {
  target_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& InProgressInfo::target_path() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.target_path)
  return _internal_target_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_target_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 target_path_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.target_path)
}
inline std::string* InProgressInfo::mutable_target_path() {
  std::string* _s = _internal_mutable_target_path();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.target_path)
  return _s;
}
inline const std::string& InProgressInfo::_internal_target_path() const {
  return target_path_.Get();
}
inline void InProgressInfo::_internal_set_target_path(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  target_path_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_target_path() {
  _has_bits_[0] |= 0x00000200u;
  return target_path_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_target_path() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.target_path)
  if (!_internal_has_target_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = target_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (target_path_.IsDefault()) {
    target_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  target_path_.SetAllocated(target_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (target_path_.IsDefault()) {
    target_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.target_path)
}

// optional int64 received_bytes = 15;
inline bool InProgressInfo::_internal_has_received_bytes() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool InProgressInfo::has_received_bytes() const {
  return _internal_has_received_bytes();
}
inline void InProgressInfo::clear_received_bytes() {
  received_bytes_ = int64_t{0};
  _has_bits_[0] &= ~0x00008000u;
}
inline int64_t InProgressInfo::_internal_received_bytes() const {
  return received_bytes_;
}
inline int64_t InProgressInfo::received_bytes() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.received_bytes)
  return _internal_received_bytes();
}
inline void InProgressInfo::_internal_set_received_bytes(int64_t value) {
  _has_bits_[0] |= 0x00008000u;
  received_bytes_ = value;
}
inline void InProgressInfo::set_received_bytes(int64_t value) {
  _internal_set_received_bytes(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.received_bytes)
}

// optional int64 start_time = 16;
inline bool InProgressInfo::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool InProgressInfo::has_start_time() const {
  return _internal_has_start_time();
}
inline void InProgressInfo::clear_start_time() {
  start_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00010000u;
}
inline int64_t InProgressInfo::_internal_start_time() const {
  return start_time_;
}
inline int64_t InProgressInfo::start_time() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.start_time)
  return _internal_start_time();
}
inline void InProgressInfo::_internal_set_start_time(int64_t value) {
  _has_bits_[0] |= 0x00010000u;
  start_time_ = value;
}
inline void InProgressInfo::set_start_time(int64_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.start_time)
}

// optional int64 end_time = 17;
inline bool InProgressInfo::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool InProgressInfo::has_end_time() const {
  return _internal_has_end_time();
}
inline void InProgressInfo::clear_end_time() {
  end_time_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline int64_t InProgressInfo::_internal_end_time() const {
  return end_time_;
}
inline int64_t InProgressInfo::end_time() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.end_time)
  return _internal_end_time();
}
inline void InProgressInfo::_internal_set_end_time(int64_t value) {
  _has_bits_[0] |= 0x00020000u;
  end_time_ = value;
}
inline void InProgressInfo::set_end_time(int64_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.end_time)
}

// repeated .download_pb.ReceivedSlice received_slices = 18;
inline int InProgressInfo::_internal_received_slices_size() const {
  return received_slices_.size();
}
inline int InProgressInfo::received_slices_size() const {
  return _internal_received_slices_size();
}
inline void InProgressInfo::clear_received_slices() {
  received_slices_.Clear();
}
inline ::download_pb::ReceivedSlice* InProgressInfo::mutable_received_slices(int index) {
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.received_slices)
  return received_slices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >*
InProgressInfo::mutable_received_slices() {
  // @@protoc_insertion_point(field_mutable_list:download_pb.InProgressInfo.received_slices)
  return &received_slices_;
}
inline const ::download_pb::ReceivedSlice& InProgressInfo::_internal_received_slices(int index) const {
  return received_slices_.Get(index);
}
inline const ::download_pb::ReceivedSlice& InProgressInfo::received_slices(int index) const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.received_slices)
  return _internal_received_slices(index);
}
inline ::download_pb::ReceivedSlice* InProgressInfo::_internal_add_received_slices() {
  return received_slices_.Add();
}
inline ::download_pb::ReceivedSlice* InProgressInfo::add_received_slices() {
  ::download_pb::ReceivedSlice* _add = _internal_add_received_slices();
  // @@protoc_insertion_point(field_add:download_pb.InProgressInfo.received_slices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::download_pb::ReceivedSlice >&
InProgressInfo::received_slices() const {
  // @@protoc_insertion_point(field_list:download_pb.InProgressInfo.received_slices)
  return received_slices_;
}

// optional string hash = 19;
inline bool InProgressInfo::_internal_has_hash() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool InProgressInfo::has_hash() const {
  return _internal_has_hash();
}
inline void InProgressInfo::clear_hash() {
  hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& InProgressInfo::hash() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.hash)
}
inline std::string* InProgressInfo::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.hash)
  return _s;
}
inline const std::string& InProgressInfo::_internal_hash() const {
  return hash_.Get();
}
inline void InProgressInfo::_internal_set_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  hash_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_hash() {
  _has_bits_[0] |= 0x00000400u;
  return hash_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_hash() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.hash)
  if (!_internal_has_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = hash_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault()) {
    hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hash_.IsDefault()) {
    hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.hash)
}

// optional bool transient = 20;
inline bool InProgressInfo::_internal_has_transient() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool InProgressInfo::has_transient() const {
  return _internal_has_transient();
}
inline void InProgressInfo::clear_transient() {
  transient_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool InProgressInfo::_internal_transient() const {
  return transient_;
}
inline bool InProgressInfo::transient() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.transient)
  return _internal_transient();
}
inline void InProgressInfo::_internal_set_transient(bool value) {
  _has_bits_[0] |= 0x00080000u;
  transient_ = value;
}
inline void InProgressInfo::set_transient(bool value) {
  _internal_set_transient(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.transient)
}

// optional int32 state = 21;
inline bool InProgressInfo::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool InProgressInfo::has_state() const {
  return _internal_has_state();
}
inline void InProgressInfo::clear_state() {
  state_ = 0;
  _has_bits_[0] &= ~0x00400000u;
}
inline int32_t InProgressInfo::_internal_state() const {
  return state_;
}
inline int32_t InProgressInfo::state() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.state)
  return _internal_state();
}
inline void InProgressInfo::_internal_set_state(int32_t value) {
  _has_bits_[0] |= 0x00400000u;
  state_ = value;
}
inline void InProgressInfo::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.state)
}

// optional int32 danger_type = 22;
inline bool InProgressInfo::_internal_has_danger_type() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool InProgressInfo::has_danger_type() const {
  return _internal_has_danger_type();
}
inline void InProgressInfo::clear_danger_type() {
  danger_type_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline int32_t InProgressInfo::_internal_danger_type() const {
  return danger_type_;
}
inline int32_t InProgressInfo::danger_type() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.danger_type)
  return _internal_danger_type();
}
inline void InProgressInfo::_internal_set_danger_type(int32_t value) {
  _has_bits_[0] |= 0x00800000u;
  danger_type_ = value;
}
inline void InProgressInfo::set_danger_type(int32_t value) {
  _internal_set_danger_type(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.danger_type)
}

// optional int32 interrupt_reason = 23;
inline bool InProgressInfo::_internal_has_interrupt_reason() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool InProgressInfo::has_interrupt_reason() const {
  return _internal_has_interrupt_reason();
}
inline void InProgressInfo::clear_interrupt_reason() {
  interrupt_reason_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline int32_t InProgressInfo::_internal_interrupt_reason() const {
  return interrupt_reason_;
}
inline int32_t InProgressInfo::interrupt_reason() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.interrupt_reason)
  return _internal_interrupt_reason();
}
inline void InProgressInfo::_internal_set_interrupt_reason(int32_t value) {
  _has_bits_[0] |= 0x01000000u;
  interrupt_reason_ = value;
}
inline void InProgressInfo::set_interrupt_reason(int32_t value) {
  _internal_set_interrupt_reason(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.interrupt_reason)
}

// optional bool paused = 24;
inline bool InProgressInfo::_internal_has_paused() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool InProgressInfo::has_paused() const {
  return _internal_has_paused();
}
inline void InProgressInfo::clear_paused() {
  paused_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool InProgressInfo::_internal_paused() const {
  return paused_;
}
inline bool InProgressInfo::paused() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.paused)
  return _internal_paused();
}
inline void InProgressInfo::_internal_set_paused(bool value) {
  _has_bits_[0] |= 0x00100000u;
  paused_ = value;
}
inline void InProgressInfo::set_paused(bool value) {
  _internal_set_paused(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.paused)
}

// optional bool metered = 25;
inline bool InProgressInfo::_internal_has_metered() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool InProgressInfo::has_metered() const {
  return _internal_has_metered();
}
inline void InProgressInfo::clear_metered() {
  metered_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool InProgressInfo::_internal_metered() const {
  return metered_;
}
inline bool InProgressInfo::metered() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.metered)
  return _internal_metered();
}
inline void InProgressInfo::_internal_set_metered(bool value) {
  _has_bits_[0] |= 0x00200000u;
  metered_ = value;
}
inline void InProgressInfo::set_metered(bool value) {
  _internal_set_metered(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.metered)
}

// optional int64 bytes_wasted = 26;
inline bool InProgressInfo::_internal_has_bytes_wasted() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool InProgressInfo::has_bytes_wasted() const {
  return _internal_has_bytes_wasted();
}
inline void InProgressInfo::clear_bytes_wasted() {
  bytes_wasted_ = int64_t{0};
  _has_bits_[0] &= ~0x02000000u;
}
inline int64_t InProgressInfo::_internal_bytes_wasted() const {
  return bytes_wasted_;
}
inline int64_t InProgressInfo::bytes_wasted() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.bytes_wasted)
  return _internal_bytes_wasted();
}
inline void InProgressInfo::_internal_set_bytes_wasted(int64_t value) {
  _has_bits_[0] |= 0x02000000u;
  bytes_wasted_ = value;
}
inline void InProgressInfo::set_bytes_wasted(int64_t value) {
  _internal_set_bytes_wasted(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.bytes_wasted)
}

// optional int32 auto_resume_count = 27;
inline bool InProgressInfo::_internal_has_auto_resume_count() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool InProgressInfo::has_auto_resume_count() const {
  return _internal_has_auto_resume_count();
}
inline void InProgressInfo::clear_auto_resume_count() {
  auto_resume_count_ = 0;
  _has_bits_[0] &= ~0x04000000u;
}
inline int32_t InProgressInfo::_internal_auto_resume_count() const {
  return auto_resume_count_;
}
inline int32_t InProgressInfo::auto_resume_count() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.auto_resume_count)
  return _internal_auto_resume_count();
}
inline void InProgressInfo::_internal_set_auto_resume_count(int32_t value) {
  _has_bits_[0] |= 0x04000000u;
  auto_resume_count_ = value;
}
inline void InProgressInfo::set_auto_resume_count(int32_t value) {
  _internal_set_auto_resume_count(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.auto_resume_count)
}

// optional .download_pb.DownloadSchedule download_schedule = 28;
inline bool InProgressInfo::_internal_has_download_schedule() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || download_schedule_ != nullptr);
  return value;
}
inline bool InProgressInfo::has_download_schedule() const {
  return _internal_has_download_schedule();
}
inline void InProgressInfo::clear_download_schedule() {
  if (download_schedule_ != nullptr) download_schedule_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::download_pb::DownloadSchedule& InProgressInfo::_internal_download_schedule() const {
  const ::download_pb::DownloadSchedule* p = download_schedule_;
  return p != nullptr ? *p : reinterpret_cast<const ::download_pb::DownloadSchedule&>(
      ::download_pb::_DownloadSchedule_default_instance_);
}
inline const ::download_pb::DownloadSchedule& InProgressInfo::download_schedule() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.download_schedule)
  return _internal_download_schedule();
}
inline void InProgressInfo::unsafe_arena_set_allocated_download_schedule(
    ::download_pb::DownloadSchedule* download_schedule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(download_schedule_);
  }
  download_schedule_ = download_schedule;
  if (download_schedule) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:download_pb.InProgressInfo.download_schedule)
}
inline ::download_pb::DownloadSchedule* InProgressInfo::release_download_schedule() {
  _has_bits_[0] &= ~0x00001000u;
  ::download_pb::DownloadSchedule* temp = download_schedule_;
  download_schedule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::download_pb::DownloadSchedule* InProgressInfo::unsafe_arena_release_download_schedule() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.download_schedule)
  _has_bits_[0] &= ~0x00001000u;
  ::download_pb::DownloadSchedule* temp = download_schedule_;
  download_schedule_ = nullptr;
  return temp;
}
inline ::download_pb::DownloadSchedule* InProgressInfo::_internal_mutable_download_schedule() {
  _has_bits_[0] |= 0x00001000u;
  if (download_schedule_ == nullptr) {
    auto* p = CreateMaybeMessage<::download_pb::DownloadSchedule>(GetArenaForAllocation());
    download_schedule_ = p;
  }
  return download_schedule_;
}
inline ::download_pb::DownloadSchedule* InProgressInfo::mutable_download_schedule() {
  ::download_pb::DownloadSchedule* _msg = _internal_mutable_download_schedule();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.download_schedule)
  return _msg;
}
inline void InProgressInfo::set_allocated_download_schedule(::download_pb::DownloadSchedule* download_schedule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete download_schedule_;
  }
  if (download_schedule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(download_schedule);
    if (message_arena != submessage_arena) {
      download_schedule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, download_schedule, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  download_schedule_ = download_schedule;
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.download_schedule)
}

// optional .enterprise_connectors.DownloadItemRerouteInfo reroute_info = 29;
inline bool InProgressInfo::_internal_has_reroute_info() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || reroute_info_ != nullptr);
  return value;
}
inline bool InProgressInfo::has_reroute_info() const {
  return _internal_has_reroute_info();
}
inline const ::enterprise_connectors::DownloadItemRerouteInfo& InProgressInfo::_internal_reroute_info() const {
  const ::enterprise_connectors::DownloadItemRerouteInfo* p = reroute_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::enterprise_connectors::DownloadItemRerouteInfo&>(
      ::enterprise_connectors::_DownloadItemRerouteInfo_default_instance_);
}
inline const ::enterprise_connectors::DownloadItemRerouteInfo& InProgressInfo::reroute_info() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.reroute_info)
  return _internal_reroute_info();
}
inline void InProgressInfo::unsafe_arena_set_allocated_reroute_info(
    ::enterprise_connectors::DownloadItemRerouteInfo* reroute_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reroute_info_);
  }
  reroute_info_ = reroute_info;
  if (reroute_info) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:download_pb.InProgressInfo.reroute_info)
}
inline ::enterprise_connectors::DownloadItemRerouteInfo* InProgressInfo::release_reroute_info() {
  _has_bits_[0] &= ~0x00002000u;
  ::enterprise_connectors::DownloadItemRerouteInfo* temp = reroute_info_;
  reroute_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::enterprise_connectors::DownloadItemRerouteInfo* InProgressInfo::unsafe_arena_release_reroute_info() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.reroute_info)
  _has_bits_[0] &= ~0x00002000u;
  ::enterprise_connectors::DownloadItemRerouteInfo* temp = reroute_info_;
  reroute_info_ = nullptr;
  return temp;
}
inline ::enterprise_connectors::DownloadItemRerouteInfo* InProgressInfo::_internal_mutable_reroute_info() {
  _has_bits_[0] |= 0x00002000u;
  if (reroute_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::enterprise_connectors::DownloadItemRerouteInfo>(GetArenaForAllocation());
    reroute_info_ = p;
  }
  return reroute_info_;
}
inline ::enterprise_connectors::DownloadItemRerouteInfo* InProgressInfo::mutable_reroute_info() {
  ::enterprise_connectors::DownloadItemRerouteInfo* _msg = _internal_mutable_reroute_info();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.reroute_info)
  return _msg;
}
inline void InProgressInfo::set_allocated_reroute_info(::enterprise_connectors::DownloadItemRerouteInfo* reroute_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(reroute_info_);
  }
  if (reroute_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reroute_info));
    if (message_arena != submessage_arena) {
      reroute_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reroute_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  reroute_info_ = reroute_info;
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.reroute_info)
}

// optional int32 credentials_mode = 30;
inline bool InProgressInfo::_internal_has_credentials_mode() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool InProgressInfo::has_credentials_mode() const {
  return _internal_has_credentials_mode();
}
inline void InProgressInfo::clear_credentials_mode() {
  credentials_mode_ = 0;
  _has_bits_[0] &= ~0x08000000u;
}
inline int32_t InProgressInfo::_internal_credentials_mode() const {
  return credentials_mode_;
}
inline int32_t InProgressInfo::credentials_mode() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.credentials_mode)
  return _internal_credentials_mode();
}
inline void InProgressInfo::_internal_set_credentials_mode(int32_t value) {
  _has_bits_[0] |= 0x08000000u;
  credentials_mode_ = value;
}
inline void InProgressInfo::set_credentials_mode(int32_t value) {
  _internal_set_credentials_mode(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.credentials_mode)
}

// optional int64 range_request_from = 31;
inline bool InProgressInfo::_internal_has_range_request_from() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool InProgressInfo::has_range_request_from() const {
  return _internal_has_range_request_from();
}
inline void InProgressInfo::clear_range_request_from() {
  range_request_from_ = int64_t{0};
  _has_bits_[0] &= ~0x10000000u;
}
inline int64_t InProgressInfo::_internal_range_request_from() const {
  return range_request_from_;
}
inline int64_t InProgressInfo::range_request_from() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.range_request_from)
  return _internal_range_request_from();
}
inline void InProgressInfo::_internal_set_range_request_from(int64_t value) {
  _has_bits_[0] |= 0x10000000u;
  range_request_from_ = value;
}
inline void InProgressInfo::set_range_request_from(int64_t value) {
  _internal_set_range_request_from(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.range_request_from)
}

// optional int64 range_request_to = 32;
inline bool InProgressInfo::_internal_has_range_request_to() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool InProgressInfo::has_range_request_to() const {
  return _internal_has_range_request_to();
}
inline void InProgressInfo::clear_range_request_to() {
  range_request_to_ = int64_t{0};
  _has_bits_[0] &= ~0x20000000u;
}
inline int64_t InProgressInfo::_internal_range_request_to() const {
  return range_request_to_;
}
inline int64_t InProgressInfo::range_request_to() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.range_request_to)
  return _internal_range_request_to();
}
inline void InProgressInfo::_internal_set_range_request_to(int64_t value) {
  _has_bits_[0] |= 0x20000000u;
  range_request_to_ = value;
}
inline void InProgressInfo::set_range_request_to(int64_t value) {
  _internal_set_range_request_to(value);
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.range_request_to)
}

// optional string serialized_embedder_download_data = 33;
inline bool InProgressInfo::_internal_has_serialized_embedder_download_data() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool InProgressInfo::has_serialized_embedder_download_data() const {
  return _internal_has_serialized_embedder_download_data();
}
inline void InProgressInfo::clear_serialized_embedder_download_data() {
  serialized_embedder_download_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& InProgressInfo::serialized_embedder_download_data() const {
  // @@protoc_insertion_point(field_get:download_pb.InProgressInfo.serialized_embedder_download_data)
  return _internal_serialized_embedder_download_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void InProgressInfo::set_serialized_embedder_download_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 serialized_embedder_download_data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.InProgressInfo.serialized_embedder_download_data)
}
inline std::string* InProgressInfo::mutable_serialized_embedder_download_data() {
  std::string* _s = _internal_mutable_serialized_embedder_download_data();
  // @@protoc_insertion_point(field_mutable:download_pb.InProgressInfo.serialized_embedder_download_data)
  return _s;
}
inline const std::string& InProgressInfo::_internal_serialized_embedder_download_data() const {
  return serialized_embedder_download_data_.Get();
}
inline void InProgressInfo::_internal_set_serialized_embedder_download_data(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  serialized_embedder_download_data_.Set(value, GetArenaForAllocation());
}
inline std::string* InProgressInfo::_internal_mutable_serialized_embedder_download_data() {
  _has_bits_[0] |= 0x00000800u;
  return serialized_embedder_download_data_.Mutable(GetArenaForAllocation());
}
inline std::string* InProgressInfo::release_serialized_embedder_download_data() {
  // @@protoc_insertion_point(field_release:download_pb.InProgressInfo.serialized_embedder_download_data)
  if (!_internal_has_serialized_embedder_download_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = serialized_embedder_download_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_embedder_download_data_.IsDefault()) {
    serialized_embedder_download_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void InProgressInfo::set_allocated_serialized_embedder_download_data(std::string* serialized_embedder_download_data) {
  if (serialized_embedder_download_data != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  serialized_embedder_download_data_.SetAllocated(serialized_embedder_download_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_embedder_download_data_.IsDefault()) {
    serialized_embedder_download_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.InProgressInfo.serialized_embedder_download_data)
}

// -------------------------------------------------------------------

// DownloadInfo

// optional string guid = 1;
inline bool DownloadInfo::_internal_has_guid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DownloadInfo::has_guid() const {
  return _internal_has_guid();
}
inline void DownloadInfo::clear_guid() {
  guid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& DownloadInfo::guid() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.guid)
  return _internal_guid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadInfo::set_guid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 guid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:download_pb.DownloadInfo.guid)
}
inline std::string* DownloadInfo::mutable_guid() {
  std::string* _s = _internal_mutable_guid();
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadInfo.guid)
  return _s;
}
inline const std::string& DownloadInfo::_internal_guid() const {
  return guid_.Get();
}
inline void DownloadInfo::_internal_set_guid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  guid_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadInfo::_internal_mutable_guid() {
  _has_bits_[0] |= 0x00000001u;
  return guid_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadInfo::release_guid() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadInfo.guid)
  if (!_internal_has_guid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = guid_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guid_.IsDefault()) {
    guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void DownloadInfo::set_allocated_guid(std::string* guid) {
  if (guid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  guid_.SetAllocated(guid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guid_.IsDefault()) {
    guid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadInfo.guid)
}

// optional int32 id = 2;
inline bool DownloadInfo::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool DownloadInfo::has_id() const {
  return _internal_has_id();
}
inline void DownloadInfo::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t DownloadInfo::_internal_id() const {
  return id_;
}
inline int32_t DownloadInfo::id() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.id)
  return _internal_id();
}
inline void DownloadInfo::_internal_set_id(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  id_ = value;
}
inline void DownloadInfo::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:download_pb.DownloadInfo.id)
}

// optional .download_pb.UkmInfo ukm_info = 3;
inline bool DownloadInfo::_internal_has_ukm_info() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || ukm_info_ != nullptr);
  return value;
}
inline bool DownloadInfo::has_ukm_info() const {
  return _internal_has_ukm_info();
}
inline void DownloadInfo::clear_ukm_info() {
  if (ukm_info_ != nullptr) ukm_info_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::download_pb::UkmInfo& DownloadInfo::_internal_ukm_info() const {
  const ::download_pb::UkmInfo* p = ukm_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::download_pb::UkmInfo&>(
      ::download_pb::_UkmInfo_default_instance_);
}
inline const ::download_pb::UkmInfo& DownloadInfo::ukm_info() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.ukm_info)
  return _internal_ukm_info();
}
inline void DownloadInfo::unsafe_arena_set_allocated_ukm_info(
    ::download_pb::UkmInfo* ukm_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ukm_info_);
  }
  ukm_info_ = ukm_info;
  if (ukm_info) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:download_pb.DownloadInfo.ukm_info)
}
inline ::download_pb::UkmInfo* DownloadInfo::release_ukm_info() {
  _has_bits_[0] &= ~0x00000002u;
  ::download_pb::UkmInfo* temp = ukm_info_;
  ukm_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::download_pb::UkmInfo* DownloadInfo::unsafe_arena_release_ukm_info() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadInfo.ukm_info)
  _has_bits_[0] &= ~0x00000002u;
  ::download_pb::UkmInfo* temp = ukm_info_;
  ukm_info_ = nullptr;
  return temp;
}
inline ::download_pb::UkmInfo* DownloadInfo::_internal_mutable_ukm_info() {
  _has_bits_[0] |= 0x00000002u;
  if (ukm_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::download_pb::UkmInfo>(GetArenaForAllocation());
    ukm_info_ = p;
  }
  return ukm_info_;
}
inline ::download_pb::UkmInfo* DownloadInfo::mutable_ukm_info() {
  ::download_pb::UkmInfo* _msg = _internal_mutable_ukm_info();
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadInfo.ukm_info)
  return _msg;
}
inline void DownloadInfo::set_allocated_ukm_info(::download_pb::UkmInfo* ukm_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ukm_info_;
  }
  if (ukm_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ukm_info);
    if (message_arena != submessage_arena) {
      ukm_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ukm_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  ukm_info_ = ukm_info;
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadInfo.ukm_info)
}

// optional .download_pb.InProgressInfo in_progress_info = 4;
inline bool DownloadInfo::_internal_has_in_progress_info() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || in_progress_info_ != nullptr);
  return value;
}
inline bool DownloadInfo::has_in_progress_info() const {
  return _internal_has_in_progress_info();
}
inline void DownloadInfo::clear_in_progress_info() {
  if (in_progress_info_ != nullptr) in_progress_info_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::download_pb::InProgressInfo& DownloadInfo::_internal_in_progress_info() const {
  const ::download_pb::InProgressInfo* p = in_progress_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::download_pb::InProgressInfo&>(
      ::download_pb::_InProgressInfo_default_instance_);
}
inline const ::download_pb::InProgressInfo& DownloadInfo::in_progress_info() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadInfo.in_progress_info)
  return _internal_in_progress_info();
}
inline void DownloadInfo::unsafe_arena_set_allocated_in_progress_info(
    ::download_pb::InProgressInfo* in_progress_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(in_progress_info_);
  }
  in_progress_info_ = in_progress_info;
  if (in_progress_info) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:download_pb.DownloadInfo.in_progress_info)
}
inline ::download_pb::InProgressInfo* DownloadInfo::release_in_progress_info() {
  _has_bits_[0] &= ~0x00000004u;
  ::download_pb::InProgressInfo* temp = in_progress_info_;
  in_progress_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::download_pb::InProgressInfo* DownloadInfo::unsafe_arena_release_in_progress_info() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadInfo.in_progress_info)
  _has_bits_[0] &= ~0x00000004u;
  ::download_pb::InProgressInfo* temp = in_progress_info_;
  in_progress_info_ = nullptr;
  return temp;
}
inline ::download_pb::InProgressInfo* DownloadInfo::_internal_mutable_in_progress_info() {
  _has_bits_[0] |= 0x00000004u;
  if (in_progress_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::download_pb::InProgressInfo>(GetArenaForAllocation());
    in_progress_info_ = p;
  }
  return in_progress_info_;
}
inline ::download_pb::InProgressInfo* DownloadInfo::mutable_in_progress_info() {
  ::download_pb::InProgressInfo* _msg = _internal_mutable_in_progress_info();
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadInfo.in_progress_info)
  return _msg;
}
inline void DownloadInfo::set_allocated_in_progress_info(::download_pb::InProgressInfo* in_progress_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete in_progress_info_;
  }
  if (in_progress_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(in_progress_info);
    if (message_arena != submessage_arena) {
      in_progress_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, in_progress_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  in_progress_info_ = in_progress_info;
  // @@protoc_insertion_point(field_set_allocated:download_pb.DownloadInfo.in_progress_info)
}

// -------------------------------------------------------------------

// DownloadDBEntry

// .download_pb.DownloadInfo download_info = 1;
inline bool DownloadDBEntry::_internal_has_download_info() const {
  return entry_case() == kDownloadInfo;
}
inline bool DownloadDBEntry::has_download_info() const {
  return _internal_has_download_info();
}
inline void DownloadDBEntry::set_has_download_info() {
  _oneof_case_[0] = kDownloadInfo;
}
inline void DownloadDBEntry::clear_download_info() {
  if (_internal_has_download_info()) {
    if (GetArenaForAllocation() == nullptr) {
      delete entry_.download_info_;
    }
    clear_has_entry();
  }
}
inline ::download_pb::DownloadInfo* DownloadDBEntry::release_download_info() {
  // @@protoc_insertion_point(field_release:download_pb.DownloadDBEntry.download_info)
  if (_internal_has_download_info()) {
    clear_has_entry();
    ::download_pb::DownloadInfo* temp = entry_.download_info_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    entry_.download_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::download_pb::DownloadInfo& DownloadDBEntry::_internal_download_info() const {
  return _internal_has_download_info()
      ? *entry_.download_info_
      : reinterpret_cast< ::download_pb::DownloadInfo&>(::download_pb::_DownloadInfo_default_instance_);
}
inline const ::download_pb::DownloadInfo& DownloadDBEntry::download_info() const {
  // @@protoc_insertion_point(field_get:download_pb.DownloadDBEntry.download_info)
  return _internal_download_info();
}
inline ::download_pb::DownloadInfo* DownloadDBEntry::unsafe_arena_release_download_info() {
  // @@protoc_insertion_point(field_unsafe_arena_release:download_pb.DownloadDBEntry.download_info)
  if (_internal_has_download_info()) {
    clear_has_entry();
    ::download_pb::DownloadInfo* temp = entry_.download_info_;
    entry_.download_info_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DownloadDBEntry::unsafe_arena_set_allocated_download_info(::download_pb::DownloadInfo* download_info) {
  clear_entry();
  if (download_info) {
    set_has_download_info();
    entry_.download_info_ = download_info;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:download_pb.DownloadDBEntry.download_info)
}
inline ::download_pb::DownloadInfo* DownloadDBEntry::_internal_mutable_download_info() {
  if (!_internal_has_download_info()) {
    clear_entry();
    set_has_download_info();
    entry_.download_info_ = CreateMaybeMessage< ::download_pb::DownloadInfo >(GetArenaForAllocation());
  }
  return entry_.download_info_;
}
inline ::download_pb::DownloadInfo* DownloadDBEntry::mutable_download_info() {
  ::download_pb::DownloadInfo* _msg = _internal_mutable_download_info();
  // @@protoc_insertion_point(field_mutable:download_pb.DownloadDBEntry.download_info)
  return _msg;
}

inline bool DownloadDBEntry::has_entry() const {
  return entry_case() != ENTRY_NOT_SET;
}
inline void DownloadDBEntry::clear_has_entry() {
  _oneof_case_[0] = ENTRY_NOT_SET;
}
inline DownloadDBEntry::EntryCase DownloadDBEntry::entry_case() const {
  return DownloadDBEntry::EntryCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace download_pb

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2fdownload_2fdatabase_2fproto_2fdownload_5fentry_2eproto
