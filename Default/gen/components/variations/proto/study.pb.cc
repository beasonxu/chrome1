// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: study.proto

#include "study.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace variations {
PROTOBUF_CONSTEXPR Study_Experiment_Param::Study_Experiment_Param(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct Study_Experiment_ParamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_Experiment_ParamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_Experiment_ParamDefaultTypeInternal() {}
  union {
    Study_Experiment_Param _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_ParamDefaultTypeInternal _Study_Experiment_Param_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(
    ::_pbi::ConstantInitialized)
  : enable_feature_()
  , disable_feature_()
  , forcing_feature_on_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , forcing_feature_off_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct Study_Experiment_FeatureAssociationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_Experiment_FeatureAssociationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_Experiment_FeatureAssociationDefaultTypeInternal() {}
  union {
    Study_Experiment_FeatureAssociation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_FeatureAssociationDefaultTypeInternal _Study_Experiment_FeatureAssociation_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(
    ::_pbi::ConstantInitialized)
  : value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , name_hash_(0u){}
struct Study_Experiment_OverrideUIStringDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_Experiment_OverrideUIStringDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_Experiment_OverrideUIStringDefaultTypeInternal() {}
  union {
    Study_Experiment_OverrideUIString _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_Experiment_OverrideUIStringDefaultTypeInternal _Study_Experiment_OverrideUIString_default_instance_;
PROTOBUF_CONSTEXPR Study_Experiment::Study_Experiment(
    ::_pbi::ConstantInitialized)
  : param_()
  , override_ui_string_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , forcing_flag_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , feature_association_(nullptr)
  , google_web_experiment_id_(uint64_t{0u})
  , probability_weight_(0u)
  , type_(0)

  , google_web_trigger_experiment_id_(uint64_t{0u})
  , chrome_sync_experiment_id_(uint64_t{0u})
  , google_app_experiment_id_(uint64_t{0u})
  , google_web_visibility_(0)
{}
struct Study_ExperimentDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_ExperimentDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_ExperimentDefaultTypeInternal() {}
  union {
    Study_Experiment _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_ExperimentDefaultTypeInternal _Study_Experiment_default_instance_;
PROTOBUF_CONSTEXPR Study_Filter::Study_Filter(
    ::_pbi::ConstantInitialized)
  : channel_()
  , platform_()
  , locale_()
  , form_factor_()
  , hardware_class_()
  , exclude_hardware_class_()
  , country_()
  , exclude_country_()
  , exclude_locale_()
  , exclude_form_factor_()
  , cpu_architecture_()
  , exclude_cpu_architecture_()
  , min_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , max_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , min_os_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , max_os_version_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , start_date_(int64_t{0})
  , end_date_(int64_t{0})
  , is_low_end_device_(false)
  , is_enterprise_(false)
  , policy_restriction_(0)
{}
struct Study_FilterDefaultTypeInternal {
  PROTOBUF_CONSTEXPR Study_FilterDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~Study_FilterDefaultTypeInternal() {}
  union {
    Study_Filter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 Study_FilterDefaultTypeInternal _Study_Filter_default_instance_;
PROTOBUF_CONSTEXPR Study::Study(
    ::_pbi::ConstantInitialized)
  : experiment_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , default_experiment_name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , filter_(nullptr)
  , layer_(nullptr)
  , expiry_date_(int64_t{0})
  , consistency_(0)

  , randomization_seed_(0u)
  , activation_type_(0)
{}
struct StudyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StudyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StudyDefaultTypeInternal() {}
  union {
    Study _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT_WITH_PTR PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StudyDefaultTypeInternal _Study_default_instance_;
}  // namespace variations
namespace variations {
bool Study_Experiment_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Experiment_Type_strings[4] = {};

static const char Study_Experiment_Type_names[] =
  "IGNORE_CHANGE"
  "KILL_BEST_EFFORT"
  "KILL_CRITICAL"
  "NORMAL";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Experiment_Type_entries[] = {
  { {Study_Experiment_Type_names + 0, 13}, 1 },
  { {Study_Experiment_Type_names + 13, 16}, 2 },
  { {Study_Experiment_Type_names + 29, 13}, 3 },
  { {Study_Experiment_Type_names + 42, 6}, 0 },
};

static const int Study_Experiment_Type_entries_by_number[] = {
  3, // 0 -> NORMAL
  0, // 1 -> IGNORE_CHANGE
  1, // 2 -> KILL_BEST_EFFORT
  2, // 3 -> KILL_CRITICAL
};

const std::string& Study_Experiment_Type_Name(
    Study_Experiment_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Experiment_Type_entries,
          Study_Experiment_Type_entries_by_number,
          4, Study_Experiment_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Experiment_Type_entries,
      Study_Experiment_Type_entries_by_number,
      4, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Experiment_Type_strings[idx].get();
}
bool Study_Experiment_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Experiment_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Experiment_Type_entries, 4, name, &int_value);
  if (success) {
    *value = static_cast<Study_Experiment_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Experiment_Type Study_Experiment::NORMAL;
constexpr Study_Experiment_Type Study_Experiment::IGNORE_CHANGE;
constexpr Study_Experiment_Type Study_Experiment::KILL_BEST_EFFORT;
constexpr Study_Experiment_Type Study_Experiment::KILL_CRITICAL;
constexpr Study_Experiment_Type Study_Experiment::Type_MIN;
constexpr Study_Experiment_Type Study_Experiment::Type_MAX;
constexpr int Study_Experiment::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Consistency_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Consistency_strings[2] = {};

static const char Study_Consistency_names[] =
  "PERMANENT"
  "SESSION";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Consistency_entries[] = {
  { {Study_Consistency_names + 0, 9}, 1 },
  { {Study_Consistency_names + 9, 7}, 0 },
};

static const int Study_Consistency_entries_by_number[] = {
  1, // 0 -> SESSION
  0, // 1 -> PERMANENT
};

const std::string& Study_Consistency_Name(
    Study_Consistency value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Consistency_entries,
          Study_Consistency_entries_by_number,
          2, Study_Consistency_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Consistency_entries,
      Study_Consistency_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Consistency_strings[idx].get();
}
bool Study_Consistency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Consistency* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Consistency_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Study_Consistency>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Consistency Study::SESSION;
constexpr Study_Consistency Study::PERMANENT;
constexpr Study_Consistency Study::Consistency_MIN;
constexpr Study_Consistency Study::Consistency_MAX;
constexpr int Study::Consistency_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_GoogleWebVisibility_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_GoogleWebVisibility_strings[2] = {};

static const char Study_GoogleWebVisibility_names[] =
  "ANY"
  "FIRST_PARTY";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_GoogleWebVisibility_entries[] = {
  { {Study_GoogleWebVisibility_names + 0, 3}, 0 },
  { {Study_GoogleWebVisibility_names + 3, 11}, 1 },
};

static const int Study_GoogleWebVisibility_entries_by_number[] = {
  0, // 0 -> ANY
  1, // 1 -> FIRST_PARTY
};

const std::string& Study_GoogleWebVisibility_Name(
    Study_GoogleWebVisibility value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_GoogleWebVisibility_entries,
          Study_GoogleWebVisibility_entries_by_number,
          2, Study_GoogleWebVisibility_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_GoogleWebVisibility_entries,
      Study_GoogleWebVisibility_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_GoogleWebVisibility_strings[idx].get();
}
bool Study_GoogleWebVisibility_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_GoogleWebVisibility* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_GoogleWebVisibility_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Study_GoogleWebVisibility>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_GoogleWebVisibility Study::ANY;
constexpr Study_GoogleWebVisibility Study::FIRST_PARTY;
constexpr Study_GoogleWebVisibility Study::GoogleWebVisibility_MIN;
constexpr Study_GoogleWebVisibility Study::GoogleWebVisibility_MAX;
constexpr int Study::GoogleWebVisibility_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Channel_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Channel_strings[5] = {};

static const char Study_Channel_names[] =
  "BETA"
  "CANARY"
  "DEV"
  "STABLE"
  "UNKNOWN";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Channel_entries[] = {
  { {Study_Channel_names + 0, 4}, 2 },
  { {Study_Channel_names + 4, 6}, 0 },
  { {Study_Channel_names + 10, 3}, 1 },
  { {Study_Channel_names + 13, 6}, 3 },
  { {Study_Channel_names + 19, 7}, -1 },
};

static const int Study_Channel_entries_by_number[] = {
  4, // -1 -> UNKNOWN
  1, // 0 -> CANARY
  2, // 1 -> DEV
  0, // 2 -> BETA
  3, // 3 -> STABLE
};

const std::string& Study_Channel_Name(
    Study_Channel value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Channel_entries,
          Study_Channel_entries_by_number,
          5, Study_Channel_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Channel_entries,
      Study_Channel_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Channel_strings[idx].get();
}
bool Study_Channel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Channel* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Channel_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Study_Channel>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Channel Study::UNKNOWN;
constexpr Study_Channel Study::CANARY;
constexpr Study_Channel Study::DEV;
constexpr Study_Channel Study::BETA;
constexpr Study_Channel Study::STABLE;
constexpr Study_Channel Study::Channel_MIN;
constexpr Study_Channel Study::Channel_MAX;
constexpr int Study::Channel_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_Platform_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_Platform_strings[10] = {};

static const char Study_Platform_names[] =
  "PLATFORM_ANDROID"
  "PLATFORM_ANDROID_WEBLAYER"
  "PLATFORM_ANDROID_WEBVIEW"
  "PLATFORM_CHROMEOS"
  "PLATFORM_CHROMEOS_LACROS"
  "PLATFORM_FUCHSIA"
  "PLATFORM_IOS"
  "PLATFORM_LINUX"
  "PLATFORM_MAC"
  "PLATFORM_WINDOWS";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_Platform_entries[] = {
  { {Study_Platform_names + 0, 16}, 4 },
  { {Study_Platform_names + 16, 25}, 8 },
  { {Study_Platform_names + 41, 24}, 6 },
  { {Study_Platform_names + 65, 17}, 3 },
  { {Study_Platform_names + 82, 24}, 9 },
  { {Study_Platform_names + 106, 16}, 7 },
  { {Study_Platform_names + 122, 12}, 5 },
  { {Study_Platform_names + 134, 14}, 2 },
  { {Study_Platform_names + 148, 12}, 1 },
  { {Study_Platform_names + 160, 16}, 0 },
};

static const int Study_Platform_entries_by_number[] = {
  9, // 0 -> PLATFORM_WINDOWS
  8, // 1 -> PLATFORM_MAC
  7, // 2 -> PLATFORM_LINUX
  3, // 3 -> PLATFORM_CHROMEOS
  0, // 4 -> PLATFORM_ANDROID
  6, // 5 -> PLATFORM_IOS
  2, // 6 -> PLATFORM_ANDROID_WEBVIEW
  5, // 7 -> PLATFORM_FUCHSIA
  1, // 8 -> PLATFORM_ANDROID_WEBLAYER
  4, // 9 -> PLATFORM_CHROMEOS_LACROS
};

const std::string& Study_Platform_Name(
    Study_Platform value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_Platform_entries,
          Study_Platform_entries_by_number,
          10, Study_Platform_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_Platform_entries,
      Study_Platform_entries_by_number,
      10, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_Platform_strings[idx].get();
}
bool Study_Platform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_Platform* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_Platform_entries, 10, name, &int_value);
  if (success) {
    *value = static_cast<Study_Platform>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_Platform Study::PLATFORM_WINDOWS;
constexpr Study_Platform Study::PLATFORM_MAC;
constexpr Study_Platform Study::PLATFORM_LINUX;
constexpr Study_Platform Study::PLATFORM_CHROMEOS;
constexpr Study_Platform Study::PLATFORM_ANDROID;
constexpr Study_Platform Study::PLATFORM_IOS;
constexpr Study_Platform Study::PLATFORM_ANDROID_WEBVIEW;
constexpr Study_Platform Study::PLATFORM_FUCHSIA;
constexpr Study_Platform Study::PLATFORM_ANDROID_WEBLAYER;
constexpr Study_Platform Study::PLATFORM_CHROMEOS_LACROS;
constexpr Study_Platform Study::Platform_MIN;
constexpr Study_Platform Study::Platform_MAX;
constexpr int Study::Platform_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_FormFactor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_FormFactor_strings[5] = {};

static const char Study_FormFactor_names[] =
  "DESKTOP"
  "KIOSK"
  "MEET_DEVICE"
  "PHONE"
  "TABLET";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_FormFactor_entries[] = {
  { {Study_FormFactor_names + 0, 7}, 0 },
  { {Study_FormFactor_names + 7, 5}, 3 },
  { {Study_FormFactor_names + 12, 11}, 4 },
  { {Study_FormFactor_names + 23, 5}, 1 },
  { {Study_FormFactor_names + 28, 6}, 2 },
};

static const int Study_FormFactor_entries_by_number[] = {
  0, // 0 -> DESKTOP
  3, // 1 -> PHONE
  4, // 2 -> TABLET
  1, // 3 -> KIOSK
  2, // 4 -> MEET_DEVICE
};

const std::string& Study_FormFactor_Name(
    Study_FormFactor value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_FormFactor_entries,
          Study_FormFactor_entries_by_number,
          5, Study_FormFactor_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_FormFactor_entries,
      Study_FormFactor_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_FormFactor_strings[idx].get();
}
bool Study_FormFactor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_FormFactor* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_FormFactor_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Study_FormFactor>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_FormFactor Study::DESKTOP;
constexpr Study_FormFactor Study::PHONE;
constexpr Study_FormFactor Study::TABLET;
constexpr Study_FormFactor Study::KIOSK;
constexpr Study_FormFactor Study::MEET_DEVICE;
constexpr Study_FormFactor Study::FormFactor_MIN;
constexpr Study_FormFactor Study::FormFactor_MAX;
constexpr int Study::FormFactor_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_CpuArchitecture_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_CpuArchitecture_strings[5] = {};

static const char Study_CpuArchitecture_names[] =
  "ARM32"
  "ARM64"
  "TRANSLATED_X86_64"
  "X86_32"
  "X86_64";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_CpuArchitecture_entries[] = {
  { {Study_CpuArchitecture_names + 0, 5}, 3 },
  { {Study_CpuArchitecture_names + 5, 5}, 1 },
  { {Study_CpuArchitecture_names + 10, 17}, 4 },
  { {Study_CpuArchitecture_names + 27, 6}, 2 },
  { {Study_CpuArchitecture_names + 33, 6}, 0 },
};

static const int Study_CpuArchitecture_entries_by_number[] = {
  4, // 0 -> X86_64
  1, // 1 -> ARM64
  3, // 2 -> X86_32
  0, // 3 -> ARM32
  2, // 4 -> TRANSLATED_X86_64
};

const std::string& Study_CpuArchitecture_Name(
    Study_CpuArchitecture value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_CpuArchitecture_entries,
          Study_CpuArchitecture_entries_by_number,
          5, Study_CpuArchitecture_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_CpuArchitecture_entries,
      Study_CpuArchitecture_entries_by_number,
      5, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_CpuArchitecture_strings[idx].get();
}
bool Study_CpuArchitecture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_CpuArchitecture* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_CpuArchitecture_entries, 5, name, &int_value);
  if (success) {
    *value = static_cast<Study_CpuArchitecture>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_CpuArchitecture Study::X86_64;
constexpr Study_CpuArchitecture Study::ARM64;
constexpr Study_CpuArchitecture Study::X86_32;
constexpr Study_CpuArchitecture Study::ARM32;
constexpr Study_CpuArchitecture Study::TRANSLATED_X86_64;
constexpr Study_CpuArchitecture Study::CpuArchitecture_MIN;
constexpr Study_CpuArchitecture Study::CpuArchitecture_MAX;
constexpr int Study::CpuArchitecture_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_OptionalBool_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_OptionalBool_strings[3] = {};

static const char Study_OptionalBool_names[] =
  "OPTIONAL_BOOL_FALSE"
  "OPTIONAL_BOOL_MISSING"
  "OPTIONAL_BOOL_TRUE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_OptionalBool_entries[] = {
  { {Study_OptionalBool_names + 0, 19}, 2 },
  { {Study_OptionalBool_names + 19, 21}, 0 },
  { {Study_OptionalBool_names + 40, 18}, 1 },
};

static const int Study_OptionalBool_entries_by_number[] = {
  1, // 0 -> OPTIONAL_BOOL_MISSING
  2, // 1 -> OPTIONAL_BOOL_TRUE
  0, // 2 -> OPTIONAL_BOOL_FALSE
};

const std::string& Study_OptionalBool_Name(
    Study_OptionalBool value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_OptionalBool_entries,
          Study_OptionalBool_entries_by_number,
          3, Study_OptionalBool_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_OptionalBool_entries,
      Study_OptionalBool_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_OptionalBool_strings[idx].get();
}
bool Study_OptionalBool_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_OptionalBool* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_OptionalBool_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Study_OptionalBool>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_MISSING;
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_TRUE;
constexpr Study_OptionalBool Study::OPTIONAL_BOOL_FALSE;
constexpr Study_OptionalBool Study::OptionalBool_MIN;
constexpr Study_OptionalBool Study::OptionalBool_MAX;
constexpr int Study::OptionalBool_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_PolicyRestriction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_PolicyRestriction_strings[3] = {};

static const char Study_PolicyRestriction_names[] =
  "CRITICAL"
  "CRITICAL_ONLY"
  "NONE";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_PolicyRestriction_entries[] = {
  { {Study_PolicyRestriction_names + 0, 8}, 1 },
  { {Study_PolicyRestriction_names + 8, 13}, 2 },
  { {Study_PolicyRestriction_names + 21, 4}, 0 },
};

static const int Study_PolicyRestriction_entries_by_number[] = {
  2, // 0 -> NONE
  0, // 1 -> CRITICAL
  1, // 2 -> CRITICAL_ONLY
};

const std::string& Study_PolicyRestriction_Name(
    Study_PolicyRestriction value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_PolicyRestriction_entries,
          Study_PolicyRestriction_entries_by_number,
          3, Study_PolicyRestriction_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_PolicyRestriction_entries,
      Study_PolicyRestriction_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_PolicyRestriction_strings[idx].get();
}
bool Study_PolicyRestriction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_PolicyRestriction* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_PolicyRestriction_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<Study_PolicyRestriction>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_PolicyRestriction Study::NONE;
constexpr Study_PolicyRestriction Study::CRITICAL;
constexpr Study_PolicyRestriction Study::CRITICAL_ONLY;
constexpr Study_PolicyRestriction Study::PolicyRestriction_MIN;
constexpr Study_PolicyRestriction Study::PolicyRestriction_MAX;
constexpr int Study::PolicyRestriction_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool Study_ActivationType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> Study_ActivationType_strings[2] = {};

static const char Study_ActivationType_names[] =
  "ACTIVATE_ON_QUERY"
  "ACTIVATE_ON_STARTUP";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry Study_ActivationType_entries[] = {
  { {Study_ActivationType_names + 0, 17}, 0 },
  { {Study_ActivationType_names + 17, 19}, 1 },
};

static const int Study_ActivationType_entries_by_number[] = {
  0, // 0 -> ACTIVATE_ON_QUERY
  1, // 1 -> ACTIVATE_ON_STARTUP
};

const std::string& Study_ActivationType_Name(
    Study_ActivationType value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          Study_ActivationType_entries,
          Study_ActivationType_entries_by_number,
          2, Study_ActivationType_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      Study_ActivationType_entries,
      Study_ActivationType_entries_by_number,
      2, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     Study_ActivationType_strings[idx].get();
}
bool Study_ActivationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Study_ActivationType* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      Study_ActivationType_entries, 2, name, &int_value);
  if (success) {
    *value = static_cast<Study_ActivationType>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr Study_ActivationType Study::ACTIVATE_ON_QUERY;
constexpr Study_ActivationType Study::ACTIVATE_ON_STARTUP;
constexpr Study_ActivationType Study::ActivationType_MIN;
constexpr Study_ActivationType Study::ActivationType_MAX;
constexpr int Study::ActivationType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class Study_Experiment_Param::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment_Param>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Study_Experiment_Param::Study_Experiment_Param(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.Param)
}
Study_Experiment_Param::Study_Experiment_Param(const Study_Experiment_Param& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.Param)
}

inline void Study_Experiment_Param::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_Param::~Study_Experiment_Param() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment.Param)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment_Param::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  value_.Destroy();
}

void Study_Experiment_Param::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Study_Experiment_Param::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.Param)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_Param::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_Param::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.Param)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.Param)
  return target;
}

size_t Study_Experiment_Param::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.Param)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment_Param::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment_Param*>(
      &from));
}

void Study_Experiment_Param::MergeFrom(const Study_Experiment_Param& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.Param)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_Param::CopyFrom(const Study_Experiment_Param& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.Param)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment_Param::IsInitialized() const {
  return true;
}

void Study_Experiment_Param::InternalSwap(Study_Experiment_Param* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

std::string Study_Experiment_Param::GetTypeName() const {
  return "variations.Study.Experiment.Param";
}


// ===================================================================

class Study_Experiment_FeatureAssociation::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment_FeatureAssociation>()._has_bits_);
  static void set_has_forcing_feature_on(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_forcing_feature_off(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  enable_feature_(arena),
  disable_feature_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.FeatureAssociation)
}
Study_Experiment_FeatureAssociation::Study_Experiment_FeatureAssociation(const Study_Experiment_FeatureAssociation& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      enable_feature_(from.enable_feature_),
      disable_feature_(from.disable_feature_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  forcing_feature_on_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    forcing_feature_on_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forcing_feature_on()) {
    forcing_feature_on_.Set(from._internal_forcing_feature_on(), 
      GetArenaForAllocation());
  }
  forcing_feature_off_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    forcing_feature_off_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forcing_feature_off()) {
    forcing_feature_off_.Set(from._internal_forcing_feature_off(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.FeatureAssociation)
}

inline void Study_Experiment_FeatureAssociation::SharedCtor() {
forcing_feature_on_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  forcing_feature_on_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
forcing_feature_off_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  forcing_feature_off_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Study_Experiment_FeatureAssociation::~Study_Experiment_FeatureAssociation() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment.FeatureAssociation)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment_FeatureAssociation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  forcing_feature_on_.Destroy();
  forcing_feature_off_.Destroy();
}

void Study_Experiment_FeatureAssociation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Study_Experiment_FeatureAssociation::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.FeatureAssociation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enable_feature_.Clear();
  disable_feature_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      forcing_feature_on_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      forcing_feature_off_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_FeatureAssociation::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string enable_feature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_enable_feature();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string disable_feature = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_disable_feature();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string forcing_feature_on = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_forcing_feature_on();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string forcing_feature_off = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_forcing_feature_off();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_FeatureAssociation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.FeatureAssociation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string enable_feature = 1;
  for (int i = 0, n = this->_internal_enable_feature_size(); i < n; i++) {
    const auto& s = this->_internal_enable_feature(i);
    target = stream->WriteString(1, s, target);
  }

  // repeated string disable_feature = 2;
  for (int i = 0, n = this->_internal_disable_feature_size(); i < n; i++) {
    const auto& s = this->_internal_disable_feature(i);
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string forcing_feature_on = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_forcing_feature_on(), target);
  }

  // optional string forcing_feature_off = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_forcing_feature_off(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.FeatureAssociation)
  return target;
}

size_t Study_Experiment_FeatureAssociation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.FeatureAssociation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string enable_feature = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(enable_feature_.size());
  for (int i = 0, n = enable_feature_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      enable_feature_.Get(i));
  }

  // repeated string disable_feature = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(disable_feature_.size());
  for (int i = 0, n = disable_feature_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      disable_feature_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string forcing_feature_on = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_forcing_feature_on());
    }

    // optional string forcing_feature_off = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_forcing_feature_off());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment_FeatureAssociation::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment_FeatureAssociation*>(
      &from));
}

void Study_Experiment_FeatureAssociation::MergeFrom(const Study_Experiment_FeatureAssociation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.FeatureAssociation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  enable_feature_.MergeFrom(from.enable_feature_);
  disable_feature_.MergeFrom(from.disable_feature_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_forcing_feature_on(from._internal_forcing_feature_on());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_forcing_feature_off(from._internal_forcing_feature_off());
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_FeatureAssociation::CopyFrom(const Study_Experiment_FeatureAssociation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.FeatureAssociation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment_FeatureAssociation::IsInitialized() const {
  return true;
}

void Study_Experiment_FeatureAssociation::InternalSwap(Study_Experiment_FeatureAssociation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  enable_feature_.InternalSwap(&other->enable_feature_);
  disable_feature_.InternalSwap(&other->disable_feature_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &forcing_feature_on_, lhs_arena,
      &other->forcing_feature_on_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &forcing_feature_off_, lhs_arena,
      &other->forcing_feature_off_, rhs_arena
  );
}

std::string Study_Experiment_FeatureAssociation::GetTypeName() const {
  return "variations.Study.Experiment.FeatureAssociation";
}


// ===================================================================

class Study_Experiment_OverrideUIString::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment_OverrideUIString>()._has_bits_);
  static void set_has_name_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment.OverrideUIString)
}
Study_Experiment_OverrideUIString::Study_Experiment_OverrideUIString(const Study_Experiment_OverrideUIString& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(from._internal_value(), 
      GetArenaForAllocation());
  }
  name_hash_ = from.name_hash_;
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment.OverrideUIString)
}

inline void Study_Experiment_OverrideUIString::SharedCtor() {
value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_hash_ = 0u;
}

Study_Experiment_OverrideUIString::~Study_Experiment_OverrideUIString() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment.OverrideUIString)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment_OverrideUIString::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  value_.Destroy();
}

void Study_Experiment_OverrideUIString::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Study_Experiment_OverrideUIString::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment.OverrideUIString)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    value_.ClearNonDefaultToEmpty();
  }
  name_hash_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment_OverrideUIString::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 name_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_name_hash(&has_bits);
          name_hash_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment_OverrideUIString::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment.OverrideUIString)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 name_hash = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_name_hash(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment.OverrideUIString)
  return target;
}

size_t Study_Experiment_OverrideUIString::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment.OverrideUIString)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional fixed32 name_hash = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment_OverrideUIString::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment_OverrideUIString*>(
      &from));
}

void Study_Experiment_OverrideUIString::MergeFrom(const Study_Experiment_OverrideUIString& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment.OverrideUIString)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000002u) {
      name_hash_ = from.name_hash_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment_OverrideUIString::CopyFrom(const Study_Experiment_OverrideUIString& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment.OverrideUIString)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment_OverrideUIString::IsInitialized() const {
  return true;
}

void Study_Experiment_OverrideUIString::InternalSwap(Study_Experiment_OverrideUIString* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
  swap(name_hash_, other->name_hash_);
}

std::string Study_Experiment_OverrideUIString::GetTypeName() const {
  return "variations.Study.Experiment.OverrideUIString";
}


// ===================================================================

class Study_Experiment::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Experiment>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_probability_weight(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_google_web_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_google_web_trigger_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_google_web_visibility(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_chrome_sync_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_google_app_experiment_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::variations::Study_Experiment_FeatureAssociation& feature_association(const Study_Experiment* msg);
  static void set_has_feature_association(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_forcing_flag(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000011) ^ 0x00000011) != 0;
  }
};

const ::variations::Study_Experiment_FeatureAssociation&
Study_Experiment::_Internal::feature_association(const Study_Experiment* msg) {
  return *msg->feature_association_;
}
Study_Experiment::Study_Experiment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  param_(arena),
  override_ui_string_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:variations.Study.Experiment)
}
Study_Experiment::Study_Experiment(const Study_Experiment& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      param_(from.param_),
      override_ui_string_(from.override_ui_string_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  forcing_flag_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    forcing_flag_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_forcing_flag()) {
    forcing_flag_.Set(from._internal_forcing_flag(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_feature_association()) {
    feature_association_ = new ::variations::Study_Experiment_FeatureAssociation(*from.feature_association_);
  } else {
    feature_association_ = nullptr;
  }
  ::memcpy(&google_web_experiment_id_, &from.google_web_experiment_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&google_web_visibility_) -
    reinterpret_cast<char*>(&google_web_experiment_id_)) + sizeof(google_web_visibility_));
  // @@protoc_insertion_point(copy_constructor:variations.Study.Experiment)
}

inline void Study_Experiment::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
forcing_flag_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  forcing_flag_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&feature_association_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&google_web_visibility_) -
    reinterpret_cast<char*>(&feature_association_)) + sizeof(google_web_visibility_));
}

Study_Experiment::~Study_Experiment() {
  // @@protoc_insertion_point(destructor:variations.Study.Experiment)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Experiment::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  forcing_flag_.Destroy();
  if (this != internal_default_instance()) delete feature_association_;
}

void Study_Experiment::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Study_Experiment::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Experiment)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  param_.Clear();
  override_ui_string_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      forcing_flag_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(feature_association_ != nullptr);
      feature_association_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&google_web_experiment_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&chrome_sync_experiment_id_) -
        reinterpret_cast<char*>(&google_web_experiment_id_)) + sizeof(chrome_sync_experiment_id_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&google_app_experiment_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&google_web_visibility_) -
        reinterpret_cast<char*>(&google_app_experiment_id_)) + sizeof(google_web_visibility_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Experiment::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 probability_weight = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_probability_weight(&has_bits);
          probability_weight_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 google_web_experiment_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_google_web_experiment_id(&has_bits);
          google_web_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string forcing_flag = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_forcing_flag();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Experiment.Param param = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_param(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_Experiment_Type_IsValid(val))) {
            _internal_set_type(static_cast<::variations::Study_Experiment_Type>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 google_web_trigger_experiment_id = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_google_web_trigger_experiment_id(&has_bits);
          google_web_trigger_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_override_ui_string(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 chrome_sync_experiment_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_chrome_sync_experiment_id(&has_bits);
          chrome_sync_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_feature_association(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 google_app_experiment_id = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_google_app_experiment_id(&has_bits);
          google_app_experiment_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_GoogleWebVisibility_IsValid(val))) {
            _internal_set_google_web_visibility(static_cast<::variations::Study_GoogleWebVisibility>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Experiment::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Experiment)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // required uint32 probability_weight = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_probability_weight(), target);
  }

  // optional uint64 google_web_experiment_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_google_web_experiment_id(), target);
  }

  // optional string forcing_flag = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_forcing_flag(), target);
  }

  // repeated .variations.Study.Experiment.Param param = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_param_size()); i < n; i++) {
    const auto& repfield = this->_internal_param(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_type(), target);
  }

  // optional uint64 google_web_trigger_experiment_id = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(8, this->_internal_google_web_trigger_experiment_id(), target);
  }

  // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_override_ui_string_size()); i < n; i++) {
    const auto& repfield = this->_internal_override_ui_string(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint64 chrome_sync_experiment_id = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(10, this->_internal_chrome_sync_experiment_id(), target);
  }

  // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::feature_association(this),
        _Internal::feature_association(this).GetCachedSize(), target, stream);
  }

  // optional uint64 google_app_experiment_id = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(15, this->_internal_google_app_experiment_id(), target);
  }

  // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      16, this->_internal_google_web_visibility(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Experiment)
  return target;
}

size_t Study_Experiment::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:variations.Study.Experiment)
  size_t total_size = 0;

  if (_internal_has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  if (_internal_has_probability_weight()) {
    // required uint32 probability_weight = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_probability_weight());
  }

  return total_size;
}
size_t Study_Experiment::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Experiment)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000011) ^ 0x00000011) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());

    // required uint32 probability_weight = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_probability_weight());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .variations.Study.Experiment.Param param = 6;
  total_size += 1UL * this->_internal_param_size();
  for (const auto& msg : this->param_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .variations.Study.Experiment.OverrideUIString override_ui_string = 9;
  total_size += 1UL * this->_internal_override_ui_string_size();
  for (const auto& msg : this->override_ui_string_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional string forcing_flag = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_forcing_flag());
    }

    // optional .variations.Study.Experiment.FeatureAssociation feature_association = 12;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *feature_association_);
    }

    // optional uint64 google_web_experiment_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_web_experiment_id());
    }

  }
  if (cached_has_bits & 0x000000e0u) {
    // optional .variations.Study.Experiment.Type type = 7 [default = NORMAL];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional uint64 google_web_trigger_experiment_id = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_web_trigger_experiment_id());
    }

    // optional uint64 chrome_sync_experiment_id = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_chrome_sync_experiment_id());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional uint64 google_app_experiment_id = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_google_app_experiment_id());
    }

    // optional .variations.Study.GoogleWebVisibility google_web_visibility = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_google_web_visibility());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Experiment::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Experiment*>(
      &from));
}

void Study_Experiment::MergeFrom(const Study_Experiment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Experiment)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  param_.MergeFrom(from.param_);
  override_ui_string_.MergeFrom(from.override_ui_string_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_forcing_flag(from._internal_forcing_flag());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_feature_association()->::variations::Study_Experiment_FeatureAssociation::MergeFrom(from._internal_feature_association());
    }
    if (cached_has_bits & 0x00000008u) {
      google_web_experiment_id_ = from.google_web_experiment_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      probability_weight_ = from.probability_weight_;
    }
    if (cached_has_bits & 0x00000020u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000040u) {
      google_web_trigger_experiment_id_ = from.google_web_trigger_experiment_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      chrome_sync_experiment_id_ = from.chrome_sync_experiment_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      google_app_experiment_id_ = from.google_app_experiment_id_;
    }
    if (cached_has_bits & 0x00000200u) {
      google_web_visibility_ = from.google_web_visibility_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Experiment::CopyFrom(const Study_Experiment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Experiment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Experiment::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Study_Experiment::InternalSwap(Study_Experiment* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  param_.InternalSwap(&other->param_);
  override_ui_string_.InternalSwap(&other->override_ui_string_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &forcing_flag_, lhs_arena,
      &other->forcing_flag_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Study_Experiment, google_web_visibility_)
      + sizeof(Study_Experiment::google_web_visibility_)
      - PROTOBUF_FIELD_OFFSET(Study_Experiment, feature_association_)>(
          reinterpret_cast<char*>(&feature_association_),
          reinterpret_cast<char*>(&other->feature_association_));
}

std::string Study_Experiment::GetTypeName() const {
  return "variations.Study.Experiment";
}


// ===================================================================

class Study_Filter::_Internal {
 public:
  using HasBits = decltype(std::declval<Study_Filter>()._has_bits_);
  static void set_has_start_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_end_date(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_min_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_max_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_min_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_os_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_low_end_device(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_enterprise(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_policy_restriction(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

Study_Filter::Study_Filter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  channel_(arena),
  platform_(arena),
  locale_(arena),
  form_factor_(arena),
  hardware_class_(arena),
  exclude_hardware_class_(arena),
  country_(arena),
  exclude_country_(arena),
  exclude_locale_(arena),
  exclude_form_factor_(arena),
  cpu_architecture_(arena),
  exclude_cpu_architecture_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:variations.Study.Filter)
}
Study_Filter::Study_Filter(const Study_Filter& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      channel_(from.channel_),
      platform_(from.platform_),
      locale_(from.locale_),
      form_factor_(from.form_factor_),
      hardware_class_(from.hardware_class_),
      exclude_hardware_class_(from.exclude_hardware_class_),
      country_(from.country_),
      exclude_country_(from.exclude_country_),
      exclude_locale_(from.exclude_locale_),
      exclude_form_factor_(from.exclude_form_factor_),
      cpu_architecture_(from.cpu_architecture_),
      exclude_cpu_architecture_(from.exclude_cpu_architecture_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  min_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    min_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_min_version()) {
    min_version_.Set(from._internal_min_version(), 
      GetArenaForAllocation());
  }
  max_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    max_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_max_version()) {
    max_version_.Set(from._internal_max_version(), 
      GetArenaForAllocation());
  }
  min_os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    min_os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_min_os_version()) {
    min_os_version_.Set(from._internal_min_os_version(), 
      GetArenaForAllocation());
  }
  max_os_version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    max_os_version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_max_os_version()) {
    max_os_version_.Set(from._internal_max_os_version(), 
      GetArenaForAllocation());
  }
  ::memcpy(&start_date_, &from.start_date_,
    static_cast<size_t>(reinterpret_cast<char*>(&policy_restriction_) -
    reinterpret_cast<char*>(&start_date_)) + sizeof(policy_restriction_));
  // @@protoc_insertion_point(copy_constructor:variations.Study.Filter)
}

inline void Study_Filter::SharedCtor() {
min_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  min_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
max_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  max_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
min_os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  min_os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
max_os_version_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  max_os_version_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&start_date_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&policy_restriction_) -
    reinterpret_cast<char*>(&start_date_)) + sizeof(policy_restriction_));
}

Study_Filter::~Study_Filter() {
  // @@protoc_insertion_point(destructor:variations.Study.Filter)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study_Filter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  min_version_.Destroy();
  max_version_.Destroy();
  min_os_version_.Destroy();
  max_os_version_.Destroy();
}

void Study_Filter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Study_Filter::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study.Filter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channel_.Clear();
  platform_.Clear();
  locale_.Clear();
  form_factor_.Clear();
  hardware_class_.Clear();
  exclude_hardware_class_.Clear();
  country_.Clear();
  exclude_country_.Clear();
  exclude_locale_.Clear();
  exclude_form_factor_.Clear();
  cpu_architecture_.Clear();
  exclude_cpu_architecture_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      min_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      max_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      min_os_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      max_os_version_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&start_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_enterprise_) -
        reinterpret_cast<char*>(&start_date_)) + sizeof(is_enterprise_));
  }
  policy_restriction_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study_Filter::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 start_date = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_start_date(&has_bits);
          start_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string min_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_min_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string max_version = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_max_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Channel channel = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_Channel_IsValid(val))) {
              _internal_add_channel(static_cast<::variations::Study_Channel>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_channel(), ptr, ctx, ::variations::Study_Channel_IsValid, &_internal_metadata_, 4);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Platform platform = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_Platform_IsValid(val))) {
              _internal_add_platform(static_cast<::variations::Study_Platform>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_platform(), ptr, ctx, ::variations::Study_Platform_IsValid, &_internal_metadata_, 5);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string locale = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_locale();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.FormFactor form_factor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_FormFactor_IsValid(val))) {
              _internal_add_form_factor(static_cast<::variations::Study_FormFactor>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<56>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_form_factor(), ptr, ctx, ::variations::Study_FormFactor_IsValid, &_internal_metadata_, 7);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string hardware_class = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hardware_class();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<66>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string exclude_hardware_class = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclude_hardware_class();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string country = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_country();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string exclude_country = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclude_country();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string exclude_locale = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_exclude_locale();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<98>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int64 end_date = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_end_date(&has_bits);
          end_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.FormFactor exclude_form_factor = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_FormFactor_IsValid(val))) {
              _internal_add_exclude_form_factor(static_cast<::variations::Study_FormFactor>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_exclude_form_factor(), ptr, ctx, ::variations::Study_FormFactor_IsValid, &_internal_metadata_, 14);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_low_end_device = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_low_end_device(&has_bits);
          is_low_end_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string min_os_version = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_min_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string max_os_version = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_max_os_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enterprise = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_enterprise(&has_bits);
          is_enterprise_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_PolicyRestriction_IsValid(val))) {
            _internal_set_policy_restriction(static_cast<::variations::Study_PolicyRestriction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_CpuArchitecture_IsValid(val))) {
              _internal_add_cpu_architecture(static_cast<::variations::Study_CpuArchitecture>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<160>(ptr));
        } else if (static_cast<uint8_t>(tag) == 162) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_cpu_architecture(), ptr, ctx, ::variations::Study_CpuArchitecture_IsValid, &_internal_metadata_, 20);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::variations::Study_CpuArchitecture_IsValid(val))) {
              _internal_add_exclude_cpu_architecture(static_cast<::variations::Study_CpuArchitecture>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(21, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<std::string>(_internal_mutable_exclude_cpu_architecture(), ptr, ctx, ::variations::Study_CpuArchitecture_IsValid, &_internal_metadata_, 21);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study_Filter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study.Filter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int64 start_date = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_start_date(), target);
  }

  // optional string min_version = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_min_version(), target);
  }

  // optional string max_version = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_max_version(), target);
  }

  // repeated .variations.Study.Channel channel = 4;
  for (int i = 0, n = this->_internal_channel_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_channel(i), target);
  }

  // repeated .variations.Study.Platform platform = 5;
  for (int i = 0, n = this->_internal_platform_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_platform(i), target);
  }

  // repeated string locale = 6;
  for (int i = 0, n = this->_internal_locale_size(); i < n; i++) {
    const auto& s = this->_internal_locale(i);
    target = stream->WriteString(6, s, target);
  }

  // repeated .variations.Study.FormFactor form_factor = 7;
  for (int i = 0, n = this->_internal_form_factor_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_form_factor(i), target);
  }

  // repeated string hardware_class = 8;
  for (int i = 0, n = this->_internal_hardware_class_size(); i < n; i++) {
    const auto& s = this->_internal_hardware_class(i);
    target = stream->WriteString(8, s, target);
  }

  // repeated string exclude_hardware_class = 9;
  for (int i = 0, n = this->_internal_exclude_hardware_class_size(); i < n; i++) {
    const auto& s = this->_internal_exclude_hardware_class(i);
    target = stream->WriteString(9, s, target);
  }

  // repeated string country = 10;
  for (int i = 0, n = this->_internal_country_size(); i < n; i++) {
    const auto& s = this->_internal_country(i);
    target = stream->WriteString(10, s, target);
  }

  // repeated string exclude_country = 11;
  for (int i = 0, n = this->_internal_exclude_country_size(); i < n; i++) {
    const auto& s = this->_internal_exclude_country(i);
    target = stream->WriteString(11, s, target);
  }

  // repeated string exclude_locale = 12;
  for (int i = 0, n = this->_internal_exclude_locale_size(); i < n; i++) {
    const auto& s = this->_internal_exclude_locale(i);
    target = stream->WriteString(12, s, target);
  }

  // optional int64 end_date = 13;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(13, this->_internal_end_date(), target);
  }

  // repeated .variations.Study.FormFactor exclude_form_factor = 14;
  for (int i = 0, n = this->_internal_exclude_form_factor_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        14, this->_internal_exclude_form_factor(i), target);
  }

  // optional bool is_low_end_device = 15;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(15, this->_internal_is_low_end_device(), target);
  }

  // optional string min_os_version = 16;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_min_os_version(), target);
  }

  // optional string max_os_version = 17;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_max_os_version(), target);
  }

  // optional bool is_enterprise = 18;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(18, this->_internal_is_enterprise(), target);
  }

  // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      19, this->_internal_policy_restriction(), target);
  }

  // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
  for (int i = 0, n = this->_internal_cpu_architecture_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        20, this->_internal_cpu_architecture(i), target);
  }

  // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
  for (int i = 0, n = this->_internal_exclude_cpu_architecture_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        21, this->_internal_exclude_cpu_architecture(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study.Filter)
  return target;
}

size_t Study_Filter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study.Filter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .variations.Study.Channel channel = 4;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_channel_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_channel(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .variations.Study.Platform platform = 5;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_platform_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_platform(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated string locale = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(locale_.size());
  for (int i = 0, n = locale_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      locale_.Get(i));
  }

  // repeated .variations.Study.FormFactor form_factor = 7;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_form_factor_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_form_factor(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated string hardware_class = 8;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(hardware_class_.size());
  for (int i = 0, n = hardware_class_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      hardware_class_.Get(i));
  }

  // repeated string exclude_hardware_class = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(exclude_hardware_class_.size());
  for (int i = 0, n = exclude_hardware_class_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      exclude_hardware_class_.Get(i));
  }

  // repeated string country = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(country_.size());
  for (int i = 0, n = country_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      country_.Get(i));
  }

  // repeated string exclude_country = 11;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(exclude_country_.size());
  for (int i = 0, n = exclude_country_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      exclude_country_.Get(i));
  }

  // repeated string exclude_locale = 12;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(exclude_locale_.size());
  for (int i = 0, n = exclude_locale_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      exclude_locale_.Get(i));
  }

  // repeated .variations.Study.FormFactor exclude_form_factor = 14;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_exclude_form_factor_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_exclude_form_factor(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .variations.Study.CpuArchitecture cpu_architecture = 20;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_cpu_architecture_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_cpu_architecture(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  // repeated .variations.Study.CpuArchitecture exclude_cpu_architecture = 21;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_exclude_cpu_architecture_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::_pbi::WireFormatLite::EnumSize(
        this->_internal_exclude_cpu_architecture(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string min_version = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_min_version());
    }

    // optional string max_version = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_max_version());
    }

    // optional string min_os_version = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_min_os_version());
    }

    // optional string max_os_version = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_max_os_version());
    }

    // optional int64 start_date = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_start_date());
    }

    // optional int64 end_date = 13;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_end_date());
    }

    // optional bool is_low_end_device = 15;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_enterprise = 18;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 + 1;
    }

  }
  // optional .variations.Study.PolicyRestriction policy_restriction = 19 [default = NONE];
  if (cached_has_bits & 0x00000100u) {
    total_size += 2 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_policy_restriction());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study_Filter::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study_Filter*>(
      &from));
}

void Study_Filter::MergeFrom(const Study_Filter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:variations.Study.Filter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  channel_.MergeFrom(from.channel_);
  platform_.MergeFrom(from.platform_);
  locale_.MergeFrom(from.locale_);
  form_factor_.MergeFrom(from.form_factor_);
  hardware_class_.MergeFrom(from.hardware_class_);
  exclude_hardware_class_.MergeFrom(from.exclude_hardware_class_);
  country_.MergeFrom(from.country_);
  exclude_country_.MergeFrom(from.exclude_country_);
  exclude_locale_.MergeFrom(from.exclude_locale_);
  exclude_form_factor_.MergeFrom(from.exclude_form_factor_);
  cpu_architecture_.MergeFrom(from.cpu_architecture_);
  exclude_cpu_architecture_.MergeFrom(from.exclude_cpu_architecture_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_min_version(from._internal_min_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_max_version(from._internal_max_version());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_min_os_version(from._internal_min_os_version());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_max_os_version(from._internal_max_os_version());
    }
    if (cached_has_bits & 0x00000010u) {
      start_date_ = from.start_date_;
    }
    if (cached_has_bits & 0x00000020u) {
      end_date_ = from.end_date_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_low_end_device_ = from.is_low_end_device_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_enterprise_ = from.is_enterprise_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_policy_restriction(from._internal_policy_restriction());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study_Filter::CopyFrom(const Study_Filter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study.Filter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study_Filter::IsInitialized() const {
  return true;
}

void Study_Filter::InternalSwap(Study_Filter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  channel_.InternalSwap(&other->channel_);
  platform_.InternalSwap(&other->platform_);
  locale_.InternalSwap(&other->locale_);
  form_factor_.InternalSwap(&other->form_factor_);
  hardware_class_.InternalSwap(&other->hardware_class_);
  exclude_hardware_class_.InternalSwap(&other->exclude_hardware_class_);
  country_.InternalSwap(&other->country_);
  exclude_country_.InternalSwap(&other->exclude_country_);
  exclude_locale_.InternalSwap(&other->exclude_locale_);
  exclude_form_factor_.InternalSwap(&other->exclude_form_factor_);
  cpu_architecture_.InternalSwap(&other->cpu_architecture_);
  exclude_cpu_architecture_.InternalSwap(&other->exclude_cpu_architecture_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &min_version_, lhs_arena,
      &other->min_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &max_version_, lhs_arena,
      &other->max_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &min_os_version_, lhs_arena,
      &other->min_os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &max_os_version_, lhs_arena,
      &other->max_os_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Study_Filter, policy_restriction_)
      + sizeof(Study_Filter::policy_restriction_)
      - PROTOBUF_FIELD_OFFSET(Study_Filter, start_date_)>(
          reinterpret_cast<char*>(&start_date_),
          reinterpret_cast<char*>(&other->start_date_));
}

std::string Study_Filter::GetTypeName() const {
  return "variations.Study.Filter";
}


// ===================================================================

class Study::_Internal {
 public:
  using HasBits = decltype(std::declval<Study>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiry_date(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_consistency(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::variations::LayerMemberReference& layer(const Study* msg);
  static void set_has_layer(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_default_experiment_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::variations::Study_Filter& filter(const Study* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_randomization_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_activation_type(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::variations::LayerMemberReference&
Study::_Internal::layer(const Study* msg) {
  return *msg->layer_;
}
const ::variations::Study_Filter&
Study::_Internal::filter(const Study* msg) {
  return *msg->filter_;
}
void Study::clear_layer() {
  if (layer_ != nullptr) layer_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
Study::Study(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  experiment_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:variations.Study)
}
Study::Study(const Study& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      _has_bits_(from._has_bits_),
      experiment_(from.experiment_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  default_experiment_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    default_experiment_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_default_experiment_name()) {
    default_experiment_name_.Set(from._internal_default_experiment_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_filter()) {
    filter_ = new ::variations::Study_Filter(*from.filter_);
  } else {
    filter_ = nullptr;
  }
  if (from._internal_has_layer()) {
    layer_ = new ::variations::LayerMemberReference(*from.layer_);
  } else {
    layer_ = nullptr;
  }
  ::memcpy(&expiry_date_, &from.expiry_date_,
    static_cast<size_t>(reinterpret_cast<char*>(&activation_type_) -
    reinterpret_cast<char*>(&expiry_date_)) + sizeof(activation_type_));
  // @@protoc_insertion_point(copy_constructor:variations.Study)
}

inline void Study::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
default_experiment_name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  default_experiment_name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&filter_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&activation_type_) -
    reinterpret_cast<char*>(&filter_)) + sizeof(activation_type_));
}

Study::~Study() {
  // @@protoc_insertion_point(destructor:variations.Study)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Study::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  default_experiment_name_.Destroy();
  if (this != internal_default_instance()) delete filter_;
  if (this != internal_default_instance()) delete layer_;
}

void Study::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void Study::Clear() {
// @@protoc_insertion_point(message_clear_start:variations.Study)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  experiment_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      default_experiment_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(filter_ != nullptr);
      filter_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(layer_ != nullptr);
      layer_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&expiry_date_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&activation_type_) -
        reinterpret_cast<char*>(&expiry_date_)) + sizeof(activation_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* Study::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 expiry_date = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_expiry_date(&has_bits);
          expiry_date_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_Consistency_IsValid(val))) {
            _internal_set_consistency(static_cast<::variations::Study_Consistency>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string default_experiment_name = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_default_experiment_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .variations.Study.Experiment experiment = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_experiment(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.Filter filter = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 randomization_seed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_randomization_seed(&has_bits);
          randomization_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .variations.Study.ActivationType activation_type = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::variations::Study_ActivationType_IsValid(val))) {
            _internal_set_activation_type(static_cast<::variations::Study_ActivationType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .variations.LayerMemberReference layer = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_layer(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Study::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:variations.Study)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string name = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int64 expiry_date = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_expiry_date(), target);
  }

  // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      7, this->_internal_consistency(), target);
  }

  // optional string default_experiment_name = 8;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_default_experiment_name(), target);
  }

  // repeated .variations.Study.Experiment experiment = 9;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_experiment_size()); i < n; i++) {
    const auto& repfield = this->_internal_experiment(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(9, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .variations.Study.Filter filter = 10;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::filter(this),
        _Internal::filter(this).GetCachedSize(), target, stream);
  }

  // optional uint32 randomization_seed = 11;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_randomization_seed(), target);
  }

  // optional .variations.Study.ActivationType activation_type = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      12, this->_internal_activation_type(), target);
  }

  // optional .variations.LayerMemberReference layer = 16;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::layer(this),
        _Internal::layer(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:variations.Study)
  return target;
}

size_t Study::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:variations.Study)
  size_t total_size = 0;

  // required string name = 1;
  if (_internal_has_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .variations.Study.Experiment experiment = 9;
  total_size += 1UL * this->_internal_experiment_size();
  for (const auto& msg : this->experiment_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional string default_experiment_name = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_default_experiment_name());
    }

    // optional .variations.Study.Filter filter = 10;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *filter_);
    }

    // optional .variations.LayerMemberReference layer = 16;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *layer_);
    }

    // optional int64 expiry_date = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_expiry_date());
    }

    // optional .variations.Study.Consistency consistency = 7 [default = SESSION];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_consistency());
    }

    // optional uint32 randomization_seed = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_randomization_seed());
    }

    // optional .variations.Study.ActivationType activation_type = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_activation_type());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Study::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const Study*>(
      &from));
}

void Study::MergeFrom(const Study& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:variations.Study)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  experiment_.MergeFrom(from.experiment_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_default_experiment_name(from._internal_default_experiment_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_filter()->::variations::Study_Filter::MergeFrom(from._internal_filter());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_layer()->::variations::LayerMemberReference::MergeFrom(from._internal_layer());
    }
    if (cached_has_bits & 0x00000010u) {
      expiry_date_ = from.expiry_date_;
    }
    if (cached_has_bits & 0x00000020u) {
      consistency_ = from.consistency_;
    }
    if (cached_has_bits & 0x00000040u) {
      randomization_seed_ = from.randomization_seed_;
    }
    if (cached_has_bits & 0x00000080u) {
      activation_type_ = from.activation_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void Study::CopyFrom(const Study& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:variations.Study)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Study::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(experiment_))
    return false;
  return true;
}

void Study::InternalSwap(Study* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  experiment_.InternalSwap(&other->experiment_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &default_experiment_name_, lhs_arena,
      &other->default_experiment_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Study, activation_type_)
      + sizeof(Study::activation_type_)
      - PROTOBUF_FIELD_OFFSET(Study, filter_)>(
          reinterpret_cast<char*>(&filter_),
          reinterpret_cast<char*>(&other->filter_));
}

std::string Study::GetTypeName() const {
  return "variations.Study";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace variations
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment_Param*
Arena::CreateMaybeMessage< ::variations::Study_Experiment_Param >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment_Param >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment_FeatureAssociation*
Arena::CreateMaybeMessage< ::variations::Study_Experiment_FeatureAssociation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment_FeatureAssociation >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment_OverrideUIString*
Arena::CreateMaybeMessage< ::variations::Study_Experiment_OverrideUIString >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment_OverrideUIString >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Experiment*
Arena::CreateMaybeMessage< ::variations::Study_Experiment >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Experiment >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study_Filter*
Arena::CreateMaybeMessage< ::variations::Study_Filter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study_Filter >(arena);
}
template<> PROTOBUF_NOINLINE ::variations::Study*
Arena::CreateMaybeMessage< ::variations::Study >(Arena* arena) {
  return Arena::CreateMessageInternal< ::variations::Study >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
