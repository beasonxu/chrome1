// components/media_router/common/mojom/media_router.mojom.h is auto generated by mojom_bindings_generator.py, do not edit

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef COMPONENTS_MEDIA_ROUTER_COMMON_MOJOM_MEDIA_ROUTER_MOJOM_H_
#define COMPONENTS_MEDIA_ROUTER_COMMON_MOJOM_MEDIA_ROUTER_MOJOM_H_

#include <stdint.h>

#include <limits>
#include <type_traits>
#include <utility>

#include "third_party/abseil-cpp/absl/types/optional.h"
#include "mojo/public/cpp/bindings/clone_traits.h"
#include "mojo/public/cpp/bindings/equals_traits.h"
#include "mojo/public/cpp/bindings/lib/serialization.h"
#include "mojo/public/cpp/bindings/struct_ptr.h"
#include "mojo/public/cpp/bindings/struct_traits.h"
#include "mojo/public/cpp/bindings/union_traits.h"

#include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"

#include "components/media_router/common/mojom/media_router.mojom-shared.h"
#include "components/media_router/common/mojom/media_router.mojom-forward.h"
#include "components/media_router/common/mojom/logger.mojom-forward.h"
#include "components/media_router/common/mojom/media_controller.mojom-forward.h"
#include "components/media_router/common/mojom/media_route_provider_id.mojom-forward.h"
#include "components/media_router/common/mojom/media_status.mojom-forward.h"
#include "components/media_router/common/mojom/route_request_result_code.mojom-forward.h"
#include "components/mirroring/mojom/mirroring_service_host.mojom-forward.h"
#include "mojo/public/mojom/base/time.mojom.h"
#include "services/network/public/mojom/ip_address.mojom.h"
#include "services/network/public/mojom/ip_endpoint.mojom.h"
#include "third_party/blink/public/mojom/presentation/presentation.mojom-forward.h"
#include "url/mojom/origin.mojom.h"
#include "url/mojom/url.mojom.h"
#include <string>
#include <vector>

#include "mojo/public/cpp/bindings/lib/control_message_handler.h"
#include "mojo/public/cpp/bindings/raw_ptr_impl_ref_traits.h"


#include "components/media_router/common/mojom/media_router_mojom_traits.h"




namespace media_router {
namespace mojom {

class MediaRouteProviderProxy;

template <typename ImplRefTraits>
class MediaRouteProviderStub;

class MediaRouteProviderRequestValidator;
class MediaRouteProviderResponseValidator;


class  MediaRouteProvider
    : public MediaRouteProviderInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = MediaRouteProviderInterfaceBase;
  using Proxy_ = MediaRouteProviderProxy;

  template <typename ImplRefTraits>
  using Stub_ = MediaRouteProviderStub<ImplRefTraits>;

  using RequestValidator_ = MediaRouteProviderRequestValidator;
  using ResponseValidator_ = MediaRouteProviderResponseValidator;
  enum MethodMinVersions : uint32_t {
    kCreateRouteMinVersion = 0,
    kJoinRouteMinVersion = 0,
    kTerminateRouteMinVersion = 0,
    kSendRouteMessageMinVersion = 0,
    kSendRouteBinaryMessageMinVersion = 0,
    kStartObservingMediaSinksMinVersion = 0,
    kStopObservingMediaSinksMinVersion = 0,
    kStartObservingMediaRoutesMinVersion = 0,
    kStartListeningForRouteMessagesMinVersion = 0,
    kStopListeningForRouteMessagesMinVersion = 0,
    kDetachRouteMinVersion = 0,
    kEnableMdnsDiscoveryMinVersion = 0,
    kUpdateMediaSinksMinVersion = 0,
    kCreateMediaRouteControllerMinVersion = 0,
    kGetStateMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct CreateRoute_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct JoinRoute_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct TerminateRoute_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SendRouteMessage_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct SendRouteBinaryMessage_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct StartObservingMediaSinks_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct StopObservingMediaSinks_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct StartObservingMediaRoutes_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct StartListeningForRouteMessages_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct StopListeningForRouteMessages_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct DetachRoute_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct EnableMdnsDiscovery_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct UpdateMediaSinks_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct CreateMediaRouteController_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetState_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~MediaRouteProvider() = default;


  using CreateRouteCallback = base::OnceCallback<void(const absl::optional<::media_router::MediaRoute>&, RoutePresentationConnectionPtr, const absl::optional<std::string>&, ::media_router::mojom::RouteRequestResultCode)>;
  
  virtual void CreateRoute(const std::string& media_source, const std::string& sink_id, const std::string& original_presentation_id, const ::url::Origin& origin, int32_t frame_tree_node_id, ::base::TimeDelta timeout, bool off_the_record, CreateRouteCallback callback) = 0;


  using JoinRouteCallback = base::OnceCallback<void(const absl::optional<::media_router::MediaRoute>&, RoutePresentationConnectionPtr, const absl::optional<std::string>&, ::media_router::mojom::RouteRequestResultCode)>;
  
  virtual void JoinRoute(const std::string& media_source, const std::string& presentation_id, const ::url::Origin& origin, int32_t frame_tree_node_id, ::base::TimeDelta timeout, bool off_the_record, JoinRouteCallback callback) = 0;


  using TerminateRouteCallback = base::OnceCallback<void(const absl::optional<std::string>&, ::media_router::mojom::RouteRequestResultCode)>;
  
  virtual void TerminateRoute(const std::string& route_id, TerminateRouteCallback callback) = 0;

  
  virtual void SendRouteMessage(const std::string& media_route_id, const std::string& message) = 0;

  
  virtual void SendRouteBinaryMessage(const std::string& media_route_id, const std::vector<uint8_t>& data) = 0;

  
  virtual void StartObservingMediaSinks(const std::string& media_source) = 0;

  
  virtual void StopObservingMediaSinks(const std::string& media_source) = 0;

  
  virtual void StartObservingMediaRoutes() = 0;

  
  virtual void StartListeningForRouteMessages(const std::string& route_id) = 0;

  
  virtual void StopListeningForRouteMessages(const std::string& route_id) = 0;

  
  virtual void DetachRoute(const std::string& route_id) = 0;

  
  virtual void EnableMdnsDiscovery() = 0;

  
  virtual void UpdateMediaSinks(const std::string& media_source) = 0;


  using CreateMediaRouteControllerCallback = base::OnceCallback<void(bool)>;
  
  virtual void CreateMediaRouteController(const std::string& route_id, ::mojo::PendingReceiver<::media_router::mojom::MediaController> media_controller, ::mojo::PendingRemote<::media_router::mojom::MediaStatusObserver> observer, CreateMediaRouteControllerCallback callback) = 0;


  using GetStateCallback = base::OnceCallback<void(ProviderStatePtr)>;
  
  virtual void GetState(GetStateCallback callback) = 0;
};

class MediaRouterProxy;

template <typename ImplRefTraits>
class MediaRouterStub;

class MediaRouterRequestValidator;
class MediaRouterResponseValidator;


class  MediaRouter
    : public MediaRouterInterfaceBase {
 public:
  using IPCStableHashFunction = uint32_t(*)();

  static const char Name_[];
  static IPCStableHashFunction MessageToMethodInfo_(mojo::Message& message);
  static const char* MessageToMethodName_(mojo::Message& message);
  static constexpr uint32_t Version_ = 0;
  static constexpr bool PassesAssociatedKinds_ = false;
  static constexpr bool HasSyncMethods_ = false;
  static constexpr bool HasUninterruptableMethods_ = false;

  using Base_ = MediaRouterInterfaceBase;
  using Proxy_ = MediaRouterProxy;

  template <typename ImplRefTraits>
  using Stub_ = MediaRouterStub<ImplRefTraits>;

  using RequestValidator_ = MediaRouterRequestValidator;
  using ResponseValidator_ = MediaRouterResponseValidator;
  enum MethodMinVersions : uint32_t {
    kRegisterMediaRouteProviderMinVersion = 0,
    kOnSinksReceivedMinVersion = 0,
    kOnIssueMinVersion = 0,
    kOnRoutesUpdatedMinVersion = 0,
    kOnPresentationConnectionStateChangedMinVersion = 0,
    kOnPresentationConnectionClosedMinVersion = 0,
    kOnRouteMessagesReceivedMinVersion = 0,
    kGetMediaSinkServiceStatusMinVersion = 0,
    kGetLoggerMinVersion = 0,
    kGetLogsAsStringMinVersion = 0,
    kGetMirroringServiceHostForTabMinVersion = 0,
    kGetMirroringServiceHostForDesktopMinVersion = 0,
    kGetMirroringServiceHostForOffscreenTabMinVersion = 0,
  };

// crbug.com/1340245 - this causes binary size bloat on Fuchsia, and we're OK
// with not having this data in traces there.
#if !BUILDFLAG(IS_FUCHSIA)
  struct RegisterMediaRouteProvider_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnSinksReceived_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnIssue_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnRoutesUpdated_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnPresentationConnectionStateChanged_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnPresentationConnectionClosed_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct OnRouteMessagesReceived_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetMediaSinkServiceStatus_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetLogger_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetLogsAsString_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetMirroringServiceHostForTab_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetMirroringServiceHostForDesktop_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
  struct GetMirroringServiceHostForOffscreenTab_Sym {
    NOINLINE static uint32_t IPCStableHash();
  };
#endif // !BUILDFLAG(IS_FUCHSIA)
  virtual ~MediaRouter() = default;

  
  virtual void RegisterMediaRouteProvider(::media_router::mojom::MediaRouteProviderId provider_id, ::mojo::PendingRemote<MediaRouteProvider> media_router_provider) = 0;

  
  virtual void OnSinksReceived(::media_router::mojom::MediaRouteProviderId provider_id, const std::string& media_source, const std::vector<::media_router::MediaSinkInternal>& sinks, const std::vector<::url::Origin>& origins) = 0;

  
  virtual void OnIssue(const ::media_router::IssueInfo& issue) = 0;

  
  virtual void OnRoutesUpdated(::media_router::mojom::MediaRouteProviderId provider_id, const std::vector<::media_router::MediaRoute>& routes) = 0;

  
  virtual void OnPresentationConnectionStateChanged(const std::string& route_id, ::blink::mojom::PresentationConnectionState state) = 0;

  
  virtual void OnPresentationConnectionClosed(const std::string& route_id, ::blink::mojom::PresentationConnectionCloseReason reason, const std::string& message) = 0;

  
  virtual void OnRouteMessagesReceived(const std::string& route_id, std::vector<RouteMessagePtr> messages) = 0;


  using GetMediaSinkServiceStatusCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetMediaSinkServiceStatus(GetMediaSinkServiceStatusCallback callback) = 0;

  
  virtual void GetLogger(::mojo::PendingReceiver<::media_router::mojom::Logger> receiver) = 0;


  using GetLogsAsStringCallback = base::OnceCallback<void(const std::string&)>;
  
  virtual void GetLogsAsString(GetLogsAsStringCallback callback) = 0;

  
  virtual void GetMirroringServiceHostForTab(int32_t frame_tree_node_id, ::mojo::PendingReceiver<::mirroring::mojom::MirroringServiceHost> receiver) = 0;

  
  virtual void GetMirroringServiceHostForDesktop(const std::string& desktop_stream_id, ::mojo::PendingReceiver<::mirroring::mojom::MirroringServiceHost> receiver) = 0;

  
  virtual void GetMirroringServiceHostForOffscreenTab(const ::GURL& presentation_url, const std::string& presentation_id, ::mojo::PendingReceiver<::mirroring::mojom::MirroringServiceHost> receiver) = 0;
};



class  MediaRouteProviderProxy
    : public MediaRouteProvider {
 public:
  using InterfaceType = MediaRouteProvider;

  explicit MediaRouteProviderProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void CreateRoute(const std::string& media_source, const std::string& sink_id, const std::string& original_presentation_id, const ::url::Origin& origin, int32_t frame_tree_node_id, ::base::TimeDelta timeout, bool off_the_record, CreateRouteCallback callback) final;
  
  void JoinRoute(const std::string& media_source, const std::string& presentation_id, const ::url::Origin& origin, int32_t frame_tree_node_id, ::base::TimeDelta timeout, bool off_the_record, JoinRouteCallback callback) final;
  
  void TerminateRoute(const std::string& route_id, TerminateRouteCallback callback) final;
  
  void SendRouteMessage(const std::string& media_route_id, const std::string& message) final;
  
  void SendRouteBinaryMessage(const std::string& media_route_id, const std::vector<uint8_t>& data) final;
  
  void StartObservingMediaSinks(const std::string& media_source) final;
  
  void StopObservingMediaSinks(const std::string& media_source) final;
  
  void StartObservingMediaRoutes() final;
  
  void StartListeningForRouteMessages(const std::string& route_id) final;
  
  void StopListeningForRouteMessages(const std::string& route_id) final;
  
  void DetachRoute(const std::string& route_id) final;
  
  void EnableMdnsDiscovery() final;
  
  void UpdateMediaSinks(const std::string& media_source) final;
  
  void CreateMediaRouteController(const std::string& route_id, ::mojo::PendingReceiver<::media_router::mojom::MediaController> media_controller, ::mojo::PendingRemote<::media_router::mojom::MediaStatusObserver> observer, CreateMediaRouteControllerCallback callback) final;
  
  void GetState(GetStateCallback callback) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};



class  MediaRouterProxy
    : public MediaRouter {
 public:
  using InterfaceType = MediaRouter;

  explicit MediaRouterProxy(mojo::MessageReceiverWithResponder* receiver);
  
  void RegisterMediaRouteProvider(::media_router::mojom::MediaRouteProviderId provider_id, ::mojo::PendingRemote<MediaRouteProvider> media_router_provider) final;
  
  void OnSinksReceived(::media_router::mojom::MediaRouteProviderId provider_id, const std::string& media_source, const std::vector<::media_router::MediaSinkInternal>& sinks, const std::vector<::url::Origin>& origins) final;
  
  void OnIssue(const ::media_router::IssueInfo& issue) final;
  
  void OnRoutesUpdated(::media_router::mojom::MediaRouteProviderId provider_id, const std::vector<::media_router::MediaRoute>& routes) final;
  
  void OnPresentationConnectionStateChanged(const std::string& route_id, ::blink::mojom::PresentationConnectionState state) final;
  
  void OnPresentationConnectionClosed(const std::string& route_id, ::blink::mojom::PresentationConnectionCloseReason reason, const std::string& message) final;
  
  void OnRouteMessagesReceived(const std::string& route_id, std::vector<RouteMessagePtr> messages) final;
  
  void GetMediaSinkServiceStatus(GetMediaSinkServiceStatusCallback callback) final;
  
  void GetLogger(::mojo::PendingReceiver<::media_router::mojom::Logger> receiver) final;
  
  void GetLogsAsString(GetLogsAsStringCallback callback) final;
  
  void GetMirroringServiceHostForTab(int32_t frame_tree_node_id, ::mojo::PendingReceiver<::mirroring::mojom::MirroringServiceHost> receiver) final;
  
  void GetMirroringServiceHostForDesktop(const std::string& desktop_stream_id, ::mojo::PendingReceiver<::mirroring::mojom::MirroringServiceHost> receiver) final;
  
  void GetMirroringServiceHostForOffscreenTab(const ::GURL& presentation_url, const std::string& presentation_id, ::mojo::PendingReceiver<::mirroring::mojom::MirroringServiceHost> receiver) final;

 private:
  mojo::MessageReceiverWithResponder* receiver_;
};
class  MediaRouteProviderStubDispatch {
 public:
  static bool Accept(MediaRouteProvider* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      MediaRouteProvider* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<MediaRouteProvider>>
class MediaRouteProviderStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  MediaRouteProviderStub() = default;
  ~MediaRouteProviderStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return MediaRouteProviderStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return MediaRouteProviderStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  MediaRouterStubDispatch {
 public:
  static bool Accept(MediaRouter* impl, mojo::Message* message);
  static bool AcceptWithResponder(
      MediaRouter* impl,
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder);
};

template <typename ImplRefTraits =
              mojo::RawPtrImplRefTraits<MediaRouter>>
class MediaRouterStub
    : public mojo::MessageReceiverWithResponderStatus {
 public:
  using ImplPointerType = typename ImplRefTraits::PointerType;

  MediaRouterStub() = default;
  ~MediaRouterStub() override = default;

  void set_sink(ImplPointerType sink) { sink_ = std::move(sink); }
  ImplPointerType& sink() { return sink_; }

  bool Accept(mojo::Message* message) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return MediaRouterStubDispatch::Accept(
        ImplRefTraits::GetRawPointer(&sink_), message);
  }

  bool AcceptWithResponder(
      mojo::Message* message,
      std::unique_ptr<mojo::MessageReceiverWithStatus> responder) override {
    if (ImplRefTraits::IsNull(sink_))
      return false;
    return MediaRouterStubDispatch::AcceptWithResponder(
        ImplRefTraits::GetRawPointer(&sink_), message, std::move(responder));
  }

 private:
  ImplPointerType sink_;
};
class  MediaRouteProviderRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  MediaRouterRequestValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  MediaRouteProviderResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};
class  MediaRouterResponseValidator : public mojo::MessageReceiver {
 public:
  bool Accept(mojo::Message* message) override;
};












class  CastSessionState {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CastSessionState, T>::value>;
  using DataView = CastSessionStateDataView;
  using Data_ = internal::CastSessionState_Data;

  template <typename... Args>
  static CastSessionStatePtr New(Args&&... args) {
    return CastSessionStatePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CastSessionStatePtr From(const U& u) {
    return mojo::TypeConverter<CastSessionStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CastSessionState>::Convert(*this);
  }


  CastSessionState();

  CastSessionState(
      const std::string& sink_id,
      const std::string& app_id,
      const std::string& session_id,
      const std::string& route_description);


  ~CastSessionState();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CastSessionStatePtr>
  CastSessionStatePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CastSessionState::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CastSessionState::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  size_t Hash(size_t seed) const;
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CastSessionState::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CastSessionState::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CastSessionState_UnserializedMessageContext<
            UserType, CastSessionState::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CastSessionState::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CastSessionState::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CastSessionState_UnserializedMessageContext<
            UserType, CastSessionState::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CastSessionState::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string sink_id;
  
  std::string app_id;
  
  std::string session_id;
  
  std::string route_description;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CastSessionState::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CastSessionState::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CastSessionState::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CastSessionState::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  MediaSinkExtraData {
 public:
  using DataView = MediaSinkExtraDataDataView;
  using Data_ = internal::MediaSinkExtraData_Data;
  using Tag = Data_::MediaSinkExtraData_Tag;

  template <typename... Args>
  static MediaSinkExtraDataPtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |dial_media_sink|.
  static MediaSinkExtraDataPtr
  NewDialMediaSink(
      DialMediaSinkPtr dial_media_sink) {
    auto result = MediaSinkExtraDataPtr(absl::in_place);
    result->set_dial_media_sink(std::move(dial_media_sink));
    return result;
  }
  // Construct an instance holding |cast_media_sink|.
  static MediaSinkExtraDataPtr
  NewCastMediaSink(
      CastMediaSinkPtr cast_media_sink) {
    auto result = MediaSinkExtraDataPtr(absl::in_place);
    result->set_cast_media_sink(std::move(cast_media_sink));
    return result;
  }

  template <typename U>
  static MediaSinkExtraDataPtr From(const U& u) {
    return mojo::TypeConverter<MediaSinkExtraDataPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MediaSinkExtraData>::Convert(*this);
  }

  MediaSinkExtraData();
  ~MediaSinkExtraData();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = MediaSinkExtraDataPtr>
  MediaSinkExtraDataPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, MediaSinkExtraData>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, MediaSinkExtraData>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_dial_media_sink() const { return tag_ == Tag::kDialMediaSink; }

  
  DialMediaSinkPtr& get_dial_media_sink() const {
    CHECK(tag_ == Tag::kDialMediaSink);
    return *(data_.dial_media_sink);
  }

  
  void set_dial_media_sink(
      DialMediaSinkPtr dial_media_sink);
  
  bool is_cast_media_sink() const { return tag_ == Tag::kCastMediaSink; }

  
  CastMediaSinkPtr& get_cast_media_sink() const {
    CHECK(tag_ == Tag::kCastMediaSink);
    return *(data_.cast_media_sink);
  }

  
  void set_cast_media_sink(
      CastMediaSinkPtr cast_media_sink);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MediaSinkExtraData::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<MediaSinkExtraData::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    DialMediaSinkPtr* dial_media_sink;
    CastMediaSinkPtr* cast_media_sink;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};



class  ProviderState {
 public:
  using DataView = ProviderStateDataView;
  using Data_ = internal::ProviderState_Data;
  using Tag = Data_::ProviderState_Tag;

  template <typename... Args>
  static ProviderStatePtr New(Args&&... args) {
    static_assert(
        sizeof...(args) < 0,
        "Do not use Union::New(); to create a union of a given subtype, use "
        "New<SubType>(), not New() followed by set_<sub_type>(). To represent "
        "an empty union, mark the field or parameter as nullable in the mojom "
        "definition.");
  }
  // Construct an instance holding |cast_provider_state|.
  static ProviderStatePtr
  NewCastProviderState(
      CastProviderStatePtr cast_provider_state) {
    auto result = ProviderStatePtr(absl::in_place);
    result->set_cast_provider_state(std::move(cast_provider_state));
    return result;
  }

  template <typename U>
  static ProviderStatePtr From(const U& u) {
    return mojo::TypeConverter<ProviderStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, ProviderState>::Convert(*this);
  }

  ProviderState();
  ~ProviderState();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename UnionPtrType = ProviderStatePtr>
  ProviderStatePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T,
            typename std::enable_if<std::is_same<
                T, ProviderState>::value>::type* = nullptr>
  bool Equals(const T& other) const;

  template <typename T,
            typename std::enable_if<std::is_same<
                T, ProviderState>::value>::type* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  Tag which() const {
    return tag_;
  }


  
  bool is_cast_provider_state() const { return tag_ == Tag::kCastProviderState; }

  
  CastProviderStatePtr& get_cast_provider_state() const {
    CHECK(tag_ == Tag::kCastProviderState);
    return *(data_.cast_provider_state);
  }

  
  void set_cast_provider_state(
      CastProviderStatePtr cast_provider_state);

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        ProviderState::DataView>(input);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    return mojo::internal::DeserializeImpl<ProviderState::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

 private:
  union Union_ {
    Union_() = default;
    ~Union_() = default;
    CastProviderStatePtr* cast_provider_state;
  };

  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);

  void DestroyActive();
  Tag tag_;
  Union_ data_;
};





class  MediaSink {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MediaSink, T>::value>;
  using DataView = MediaSinkDataView;
  using Data_ = internal::MediaSink_Data;

  template <typename... Args>
  static MediaSinkPtr New(Args&&... args) {
    return MediaSinkPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MediaSinkPtr From(const U& u) {
    return mojo::TypeConverter<MediaSinkPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MediaSink>::Convert(*this);
  }


  MediaSink();

  MediaSink(
      const std::string& sink_id,
      const std::string& name,
      const absl::optional<std::string>& description,
      const absl::optional<std::string>& domain,
      SinkIconType icon_type,
      ::media_router::mojom::MediaRouteProviderId provider_id,
      MediaSinkExtraDataPtr extra_data);

MediaSink(const MediaSink&) = delete;
MediaSink& operator=(const MediaSink&) = delete;

  ~MediaSink();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MediaSinkPtr>
  MediaSinkPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MediaSink::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MediaSink::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MediaSink::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MediaSink::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MediaSink_UnserializedMessageContext<
            UserType, MediaSink::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MediaSink::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MediaSink::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MediaSink_UnserializedMessageContext<
            UserType, MediaSink::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MediaSink::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string sink_id;
  
  std::string name;
  
  absl::optional<std::string> description;
  
  absl::optional<std::string> domain;
  
  SinkIconType icon_type;
  
  ::media_router::mojom::MediaRouteProviderId provider_id;
  
  MediaSinkExtraDataPtr extra_data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MediaSink::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MediaSink::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MediaSink::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MediaSink::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  DialMediaSink {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<DialMediaSink, T>::value>;
  using DataView = DialMediaSinkDataView;
  using Data_ = internal::DialMediaSink_Data;

  template <typename... Args>
  static DialMediaSinkPtr New(Args&&... args) {
    return DialMediaSinkPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static DialMediaSinkPtr From(const U& u) {
    return mojo::TypeConverter<DialMediaSinkPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, DialMediaSink>::Convert(*this);
  }


  DialMediaSink();

  DialMediaSink(
      const ::net::IPAddress& ip_address,
      const std::string& model_name,
      const ::GURL& app_url);


  ~DialMediaSink();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = DialMediaSinkPtr>
  DialMediaSinkPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, DialMediaSink::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, DialMediaSink::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        DialMediaSink::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        DialMediaSink::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::DialMediaSink_UnserializedMessageContext<
            UserType, DialMediaSink::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<DialMediaSink::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return DialMediaSink::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::DialMediaSink_UnserializedMessageContext<
            UserType, DialMediaSink::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<DialMediaSink::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::net::IPAddress ip_address;
  
  std::string model_name;
  
  ::GURL app_url;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, DialMediaSink::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, DialMediaSink::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, DialMediaSink::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, DialMediaSink::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  CastMediaSink {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CastMediaSink, T>::value>;
  using DataView = CastMediaSinkDataView;
  using Data_ = internal::CastMediaSink_Data;

  template <typename... Args>
  static CastMediaSinkPtr New(Args&&... args) {
    return CastMediaSinkPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CastMediaSinkPtr From(const U& u) {
    return mojo::TypeConverter<CastMediaSinkPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CastMediaSink>::Convert(*this);
  }


  CastMediaSink();

  CastMediaSink(
      const ::net::IPEndPoint& ip_endpoint,
      const std::string& model_name,
      uint8_t capabilities,
      int32_t cast_channel_id);


  ~CastMediaSink();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CastMediaSinkPtr>
  CastMediaSinkPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CastMediaSink::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CastMediaSink::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CastMediaSink::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CastMediaSink::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CastMediaSink_UnserializedMessageContext<
            UserType, CastMediaSink::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CastMediaSink::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CastMediaSink::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CastMediaSink_UnserializedMessageContext<
            UserType, CastMediaSink::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CastMediaSink::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::net::IPEndPoint ip_endpoint;
  
  std::string model_name;
  
  uint8_t capabilities;
  
  int32_t cast_channel_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CastMediaSink::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CastMediaSink::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CastMediaSink::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CastMediaSink::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  MediaRoute {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<MediaRoute, T>::value>;
  using DataView = MediaRouteDataView;
  using Data_ = internal::MediaRoute_Data;

  template <typename... Args>
  static MediaRoutePtr New(Args&&... args) {
    return MediaRoutePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static MediaRoutePtr From(const U& u) {
    return mojo::TypeConverter<MediaRoutePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, MediaRoute>::Convert(*this);
  }


  MediaRoute();

  MediaRoute(
      const std::string& media_route_id,
      const std::string& presentation_id,
      const absl::optional<std::string>& media_source,
      const std::string& media_sink_id,
      const std::string& media_sink_name,
      const std::string& description,
      bool is_local,
      RouteControllerType controller_type,
      bool is_off_the_record,
      bool is_local_presentation,
      bool is_connecting);


  ~MediaRoute();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = MediaRoutePtr>
  MediaRoutePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, MediaRoute::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, MediaRoute::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        MediaRoute::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        MediaRoute::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::MediaRoute_UnserializedMessageContext<
            UserType, MediaRoute::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<MediaRoute::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return MediaRoute::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::MediaRoute_UnserializedMessageContext<
            UserType, MediaRoute::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<MediaRoute::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string media_route_id;
  
  std::string presentation_id;
  
  absl::optional<std::string> media_source;
  
  std::string media_sink_id;
  
  std::string media_sink_name;
  
  std::string description;
  
  bool is_local;
  
  RouteControllerType controller_type;
  
  bool is_off_the_record;
  
  bool is_local_presentation;
  
  bool is_connecting;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, MediaRoute::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, MediaRoute::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, MediaRoute::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, MediaRoute::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  Issue {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<Issue, T>::value>;
  using DataView = IssueDataView;
  using Data_ = internal::Issue_Data;
  using Severity = Issue_Severity;
  using ActionType = Issue_ActionType;

  template <typename... Args>
  static IssuePtr New(Args&&... args) {
    return IssuePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static IssuePtr From(const U& u) {
    return mojo::TypeConverter<IssuePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, Issue>::Convert(*this);
  }


  Issue();

  Issue(
      const std::string& route_id,
      const std::string& sink_id,
      ::media_router::IssueInfo::Severity severity,
      bool is_blocking,
      const std::string& title,
      const absl::optional<std::string>& message,
      ::media_router::IssueInfo::Action default_action,
      std::vector<::media_router::IssueInfo::Action> secondary_actions,
      int32_t help_page_id);


  ~Issue();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = IssuePtr>
  IssuePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, Issue::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, Issue::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        Issue::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        Issue::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::Issue_UnserializedMessageContext<
            UserType, Issue::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<Issue::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return Issue::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::Issue_UnserializedMessageContext<
            UserType, Issue::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<Issue::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::string route_id;
  
  std::string sink_id;
  
  ::media_router::IssueInfo::Severity severity;
  
  bool is_blocking;
  
  std::string title;
  
  absl::optional<std::string> message;
  
  ::media_router::IssueInfo::Action default_action;
  
  std::vector<::media_router::IssueInfo::Action> secondary_actions;
  
  int32_t help_page_id;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, Issue::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, Issue::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, Issue::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, Issue::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  RouteMessage {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<RouteMessage, T>::value>;
  using DataView = RouteMessageDataView;
  using Data_ = internal::RouteMessage_Data;
  using Type = RouteMessage_Type;

  template <typename... Args>
  static RouteMessagePtr New(Args&&... args) {
    return RouteMessagePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RouteMessagePtr From(const U& u) {
    return mojo::TypeConverter<RouteMessagePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RouteMessage>::Convert(*this);
  }


  RouteMessage();

  RouteMessage(
      RouteMessage::Type type,
      const absl::optional<std::string>& message,
      absl::optional<std::vector<uint8_t>> data);


  ~RouteMessage();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RouteMessagePtr>
  RouteMessagePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, RouteMessage::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, RouteMessage::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        RouteMessage::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        RouteMessage::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::RouteMessage_UnserializedMessageContext<
            UserType, RouteMessage::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<RouteMessage::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return RouteMessage::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::RouteMessage_UnserializedMessageContext<
            UserType, RouteMessage::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<RouteMessage::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  RouteMessage::Type type;
  
  absl::optional<std::string> message;
  
  absl::optional<std::vector<uint8_t>> data;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RouteMessage::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, RouteMessage::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, RouteMessage::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, RouteMessage::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}





class  RoutePresentationConnection {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<RoutePresentationConnection, T>::value>;
  using DataView = RoutePresentationConnectionDataView;
  using Data_ = internal::RoutePresentationConnection_Data;

  template <typename... Args>
  static RoutePresentationConnectionPtr New(Args&&... args) {
    return RoutePresentationConnectionPtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static RoutePresentationConnectionPtr From(const U& u) {
    return mojo::TypeConverter<RoutePresentationConnectionPtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, RoutePresentationConnection>::Convert(*this);
  }


  RoutePresentationConnection();

  RoutePresentationConnection(
      ::mojo::PendingRemote<::blink::mojom::PresentationConnection> connection_remote,
      ::mojo::PendingReceiver<::blink::mojom::PresentationConnection> connection_receiver);

RoutePresentationConnection(const RoutePresentationConnection&) = delete;
RoutePresentationConnection& operator=(const RoutePresentationConnection&) = delete;

  ~RoutePresentationConnection();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = RoutePresentationConnectionPtr>
  RoutePresentationConnectionPtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, RoutePresentationConnection::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, RoutePresentationConnection::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        RoutePresentationConnection::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::RoutePresentationConnection_UnserializedMessageContext<
            UserType, RoutePresentationConnection::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<RoutePresentationConnection::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return RoutePresentationConnection::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::RoutePresentationConnection_UnserializedMessageContext<
            UserType, RoutePresentationConnection::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<RoutePresentationConnection::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  ::mojo::PendingRemote<::blink::mojom::PresentationConnection> connection_remote;
  
  ::mojo::PendingReceiver<::blink::mojom::PresentationConnection> connection_receiver;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, RoutePresentationConnection::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, RoutePresentationConnection::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, RoutePresentationConnection::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, RoutePresentationConnection::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}






class  CastProviderState {
 public:
  template <typename T>
  using EnableIfSame = std::enable_if_t<std::is_same<CastProviderState, T>::value>;
  using DataView = CastProviderStateDataView;
  using Data_ = internal::CastProviderState_Data;

  template <typename... Args>
  static CastProviderStatePtr New(Args&&... args) {
    return CastProviderStatePtr(
        absl::in_place, std::forward<Args>(args)...);
  }

  template <typename U>
  static CastProviderStatePtr From(const U& u) {
    return mojo::TypeConverter<CastProviderStatePtr, U>::Convert(u);
  }

  template <typename U>
  U To() const {
    return mojo::TypeConverter<U, CastProviderState>::Convert(*this);
  }


  CastProviderState();

  explicit CastProviderState(
      std::vector<CastSessionStatePtr> session_state);

CastProviderState(const CastProviderState&) = delete;
CastProviderState& operator=(const CastProviderState&) = delete;

  ~CastProviderState();

  // Clone() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Clone() or copy
  // constructor/assignment are available for members.
  template <typename StructPtrType = CastProviderStatePtr>
  CastProviderStatePtr Clone() const;

  // Equals() is a template so it is only instantiated if it is used. Thus, the
  // bindings generator does not need to know whether Equals() or == operator
  // are available for members.
  template <typename T, CastProviderState::EnableIfSame<T>* = nullptr>
  bool Equals(const T& other) const;

  template <typename T, CastProviderState::EnableIfSame<T>* = nullptr>
  bool operator==(const T& rhs) const { return Equals(rhs); }
  template <typename UserType>
  static std::vector<uint8_t> Serialize(UserType* input) {
    return mojo::internal::SerializeImpl<
        CastProviderState::DataView, std::vector<uint8_t>>(input);
  }

  template <typename UserType>
  static mojo::Message SerializeAsMessage(UserType* input) {
    return mojo::internal::SerializeAsMessageImpl<
        CastProviderState::DataView>(input);
  }

  // The returned Message is serialized only if the message is moved
  // cross-process or cross-language. Otherwise if the message is Deserialized
  // as the same UserType |input| will just be moved to |output| in
  // DeserializeFromMessage.
  template <typename UserType>
  static mojo::Message WrapAsMessage(UserType input) {
    return mojo::Message(std::make_unique<
        internal::CastProviderState_UnserializedMessageContext<
            UserType, CastProviderState::DataView>>(0, 0, std::move(input)),
        MOJO_CREATE_MESSAGE_FLAG_NONE);
  }

  template <typename UserType>
  static bool Deserialize(const void* data,
                          size_t data_num_bytes,
                          UserType* output) {
    mojo::Message message;
    return mojo::internal::DeserializeImpl<CastProviderState::DataView>(
        message, data, data_num_bytes, output, Validate);
  }

  template <typename UserType>
  static bool Deserialize(const std::vector<uint8_t>& input,
                          UserType* output) {
    return CastProviderState::Deserialize(
        input.size() == 0 ? nullptr : &input.front(), input.size(), output);
  }

  template <typename UserType>
  static bool DeserializeFromMessage(mojo::Message input,
                                     UserType* output) {
    auto context = input.TakeUnserializedContext<
        internal::CastProviderState_UnserializedMessageContext<
            UserType, CastProviderState::DataView>>();
    if (context) {
      *output = std::move(context->TakeData());
      return true;
    }
    input.SerializeIfNecessary();
    return mojo::internal::DeserializeImpl<CastProviderState::DataView>(
        input, input.payload(), input.payload_num_bytes(), output, Validate);
  }

  
  std::vector<CastSessionStatePtr> session_state;

  // Serialise this struct into a trace.
  void WriteIntoTrace(perfetto::TracedValue traced_context) const;

 private:
  static bool Validate(const void* data,
                       mojo::internal::ValidationContext* validation_context);
};

// The comparison operators are templates, so they are only instantiated if they
// are used. Thus, the bindings generator does not need to know whether
// comparison operators are available for members.
template <typename T, CastProviderState::EnableIfSame<T>* = nullptr>
bool operator<(const T& lhs, const T& rhs);

template <typename T, CastProviderState::EnableIfSame<T>* = nullptr>
bool operator<=(const T& lhs, const T& rhs) {
  return !(rhs < lhs);
}

template <typename T, CastProviderState::EnableIfSame<T>* = nullptr>
bool operator>(const T& lhs, const T& rhs) {
  return rhs < lhs;
}

template <typename T, CastProviderState::EnableIfSame<T>* = nullptr>
bool operator>=(const T& lhs, const T& rhs) {
  return !(lhs < rhs);
}

template <typename UnionPtrType>
MediaSinkExtraDataPtr MediaSinkExtraData::Clone() const {
  switch (tag_) {
    case Tag::kDialMediaSink:
      return NewDialMediaSink(
          mojo::Clone(*data_.dial_media_sink));
    case Tag::kCastMediaSink:
      return NewCastMediaSink(
          mojo::Clone(*data_.cast_media_sink));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, MediaSinkExtraData>::value>::type*>
bool MediaSinkExtraData::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kDialMediaSink:
      return mojo::Equals(*(data_.dial_media_sink), *(other.data_.dial_media_sink));
    case Tag::kCastMediaSink:
      return mojo::Equals(*(data_.cast_media_sink), *(other.data_.cast_media_sink));
  }

  return false;
}
template <typename UnionPtrType>
ProviderStatePtr ProviderState::Clone() const {
  switch (tag_) {
    case Tag::kCastProviderState:
      return NewCastProviderState(
          mojo::Clone(*data_.cast_provider_state));
  }
  return nullptr;
}

template <typename T,
          typename std::enable_if<std::is_same<
              T, ProviderState>::value>::type*>
bool ProviderState::Equals(const T& other) const {
  if (tag_ != other.which())
    return false;

  switch (tag_) {
    case Tag::kCastProviderState:
      return mojo::Equals(*(data_.cast_provider_state), *(other.data_.cast_provider_state));
  }

  return false;
}
template <typename StructPtrType>
MediaSinkPtr MediaSink::Clone() const {
  return New(
      mojo::Clone(sink_id),
      mojo::Clone(name),
      mojo::Clone(description),
      mojo::Clone(domain),
      mojo::Clone(icon_type),
      mojo::Clone(provider_id),
      mojo::Clone(extra_data)
  );
}

template <typename T, MediaSink::EnableIfSame<T>*>
bool MediaSink::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sink_id, other_struct.sink_id))
    return false;
  if (!mojo::Equals(this->name, other_struct.name))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  if (!mojo::Equals(this->domain, other_struct.domain))
    return false;
  if (!mojo::Equals(this->icon_type, other_struct.icon_type))
    return false;
  if (!mojo::Equals(this->provider_id, other_struct.provider_id))
    return false;
  if (!mojo::Equals(this->extra_data, other_struct.extra_data))
    return false;
  return true;
}

template <typename T, MediaSink::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sink_id < rhs.sink_id)
    return true;
  if (rhs.sink_id < lhs.sink_id)
    return false;
  if (lhs.name < rhs.name)
    return true;
  if (rhs.name < lhs.name)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  if (lhs.domain < rhs.domain)
    return true;
  if (rhs.domain < lhs.domain)
    return false;
  if (lhs.icon_type < rhs.icon_type)
    return true;
  if (rhs.icon_type < lhs.icon_type)
    return false;
  if (lhs.provider_id < rhs.provider_id)
    return true;
  if (rhs.provider_id < lhs.provider_id)
    return false;
  if (lhs.extra_data < rhs.extra_data)
    return true;
  if (rhs.extra_data < lhs.extra_data)
    return false;
  return false;
}
template <typename StructPtrType>
DialMediaSinkPtr DialMediaSink::Clone() const {
  return New(
      mojo::Clone(ip_address),
      mojo::Clone(model_name),
      mojo::Clone(app_url)
  );
}

template <typename T, DialMediaSink::EnableIfSame<T>*>
bool DialMediaSink::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->ip_address, other_struct.ip_address))
    return false;
  if (!mojo::Equals(this->model_name, other_struct.model_name))
    return false;
  if (!mojo::Equals(this->app_url, other_struct.app_url))
    return false;
  return true;
}

template <typename T, DialMediaSink::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.ip_address < rhs.ip_address)
    return true;
  if (rhs.ip_address < lhs.ip_address)
    return false;
  if (lhs.model_name < rhs.model_name)
    return true;
  if (rhs.model_name < lhs.model_name)
    return false;
  if (lhs.app_url < rhs.app_url)
    return true;
  if (rhs.app_url < lhs.app_url)
    return false;
  return false;
}
template <typename StructPtrType>
CastMediaSinkPtr CastMediaSink::Clone() const {
  return New(
      mojo::Clone(ip_endpoint),
      mojo::Clone(model_name),
      mojo::Clone(capabilities),
      mojo::Clone(cast_channel_id)
  );
}

template <typename T, CastMediaSink::EnableIfSame<T>*>
bool CastMediaSink::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->ip_endpoint, other_struct.ip_endpoint))
    return false;
  if (!mojo::Equals(this->model_name, other_struct.model_name))
    return false;
  if (!mojo::Equals(this->capabilities, other_struct.capabilities))
    return false;
  if (!mojo::Equals(this->cast_channel_id, other_struct.cast_channel_id))
    return false;
  return true;
}

template <typename T, CastMediaSink::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.ip_endpoint < rhs.ip_endpoint)
    return true;
  if (rhs.ip_endpoint < lhs.ip_endpoint)
    return false;
  if (lhs.model_name < rhs.model_name)
    return true;
  if (rhs.model_name < lhs.model_name)
    return false;
  if (lhs.capabilities < rhs.capabilities)
    return true;
  if (rhs.capabilities < lhs.capabilities)
    return false;
  if (lhs.cast_channel_id < rhs.cast_channel_id)
    return true;
  if (rhs.cast_channel_id < lhs.cast_channel_id)
    return false;
  return false;
}
template <typename StructPtrType>
MediaRoutePtr MediaRoute::Clone() const {
  return New(
      mojo::Clone(media_route_id),
      mojo::Clone(presentation_id),
      mojo::Clone(media_source),
      mojo::Clone(media_sink_id),
      mojo::Clone(media_sink_name),
      mojo::Clone(description),
      mojo::Clone(is_local),
      mojo::Clone(controller_type),
      mojo::Clone(is_off_the_record),
      mojo::Clone(is_local_presentation),
      mojo::Clone(is_connecting)
  );
}

template <typename T, MediaRoute::EnableIfSame<T>*>
bool MediaRoute::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->media_route_id, other_struct.media_route_id))
    return false;
  if (!mojo::Equals(this->presentation_id, other_struct.presentation_id))
    return false;
  if (!mojo::Equals(this->media_source, other_struct.media_source))
    return false;
  if (!mojo::Equals(this->media_sink_id, other_struct.media_sink_id))
    return false;
  if (!mojo::Equals(this->media_sink_name, other_struct.media_sink_name))
    return false;
  if (!mojo::Equals(this->description, other_struct.description))
    return false;
  if (!mojo::Equals(this->is_local, other_struct.is_local))
    return false;
  if (!mojo::Equals(this->controller_type, other_struct.controller_type))
    return false;
  if (!mojo::Equals(this->is_off_the_record, other_struct.is_off_the_record))
    return false;
  if (!mojo::Equals(this->is_local_presentation, other_struct.is_local_presentation))
    return false;
  if (!mojo::Equals(this->is_connecting, other_struct.is_connecting))
    return false;
  return true;
}

template <typename T, MediaRoute::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.media_route_id < rhs.media_route_id)
    return true;
  if (rhs.media_route_id < lhs.media_route_id)
    return false;
  if (lhs.presentation_id < rhs.presentation_id)
    return true;
  if (rhs.presentation_id < lhs.presentation_id)
    return false;
  if (lhs.media_source < rhs.media_source)
    return true;
  if (rhs.media_source < lhs.media_source)
    return false;
  if (lhs.media_sink_id < rhs.media_sink_id)
    return true;
  if (rhs.media_sink_id < lhs.media_sink_id)
    return false;
  if (lhs.media_sink_name < rhs.media_sink_name)
    return true;
  if (rhs.media_sink_name < lhs.media_sink_name)
    return false;
  if (lhs.description < rhs.description)
    return true;
  if (rhs.description < lhs.description)
    return false;
  if (lhs.is_local < rhs.is_local)
    return true;
  if (rhs.is_local < lhs.is_local)
    return false;
  if (lhs.controller_type < rhs.controller_type)
    return true;
  if (rhs.controller_type < lhs.controller_type)
    return false;
  if (lhs.is_off_the_record < rhs.is_off_the_record)
    return true;
  if (rhs.is_off_the_record < lhs.is_off_the_record)
    return false;
  if (lhs.is_local_presentation < rhs.is_local_presentation)
    return true;
  if (rhs.is_local_presentation < lhs.is_local_presentation)
    return false;
  if (lhs.is_connecting < rhs.is_connecting)
    return true;
  if (rhs.is_connecting < lhs.is_connecting)
    return false;
  return false;
}
template <typename StructPtrType>
IssuePtr Issue::Clone() const {
  return New(
      mojo::Clone(route_id),
      mojo::Clone(sink_id),
      mojo::Clone(severity),
      mojo::Clone(is_blocking),
      mojo::Clone(title),
      mojo::Clone(message),
      mojo::Clone(default_action),
      mojo::Clone(secondary_actions),
      mojo::Clone(help_page_id)
  );
}

template <typename T, Issue::EnableIfSame<T>*>
bool Issue::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->route_id, other_struct.route_id))
    return false;
  if (!mojo::Equals(this->sink_id, other_struct.sink_id))
    return false;
  if (!mojo::Equals(this->severity, other_struct.severity))
    return false;
  if (!mojo::Equals(this->is_blocking, other_struct.is_blocking))
    return false;
  if (!mojo::Equals(this->title, other_struct.title))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  if (!mojo::Equals(this->default_action, other_struct.default_action))
    return false;
  if (!mojo::Equals(this->secondary_actions, other_struct.secondary_actions))
    return false;
  if (!mojo::Equals(this->help_page_id, other_struct.help_page_id))
    return false;
  return true;
}

template <typename T, Issue::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.route_id < rhs.route_id)
    return true;
  if (rhs.route_id < lhs.route_id)
    return false;
  if (lhs.sink_id < rhs.sink_id)
    return true;
  if (rhs.sink_id < lhs.sink_id)
    return false;
  if (lhs.severity < rhs.severity)
    return true;
  if (rhs.severity < lhs.severity)
    return false;
  if (lhs.is_blocking < rhs.is_blocking)
    return true;
  if (rhs.is_blocking < lhs.is_blocking)
    return false;
  if (lhs.title < rhs.title)
    return true;
  if (rhs.title < lhs.title)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  if (lhs.default_action < rhs.default_action)
    return true;
  if (rhs.default_action < lhs.default_action)
    return false;
  if (lhs.secondary_actions < rhs.secondary_actions)
    return true;
  if (rhs.secondary_actions < lhs.secondary_actions)
    return false;
  if (lhs.help_page_id < rhs.help_page_id)
    return true;
  if (rhs.help_page_id < lhs.help_page_id)
    return false;
  return false;
}
template <typename StructPtrType>
RouteMessagePtr RouteMessage::Clone() const {
  return New(
      mojo::Clone(type),
      mojo::Clone(message),
      mojo::Clone(data)
  );
}

template <typename T, RouteMessage::EnableIfSame<T>*>
bool RouteMessage::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->type, other_struct.type))
    return false;
  if (!mojo::Equals(this->message, other_struct.message))
    return false;
  if (!mojo::Equals(this->data, other_struct.data))
    return false;
  return true;
}

template <typename T, RouteMessage::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.type < rhs.type)
    return true;
  if (rhs.type < lhs.type)
    return false;
  if (lhs.message < rhs.message)
    return true;
  if (rhs.message < lhs.message)
    return false;
  if (lhs.data < rhs.data)
    return true;
  if (rhs.data < lhs.data)
    return false;
  return false;
}
template <typename StructPtrType>
RoutePresentationConnectionPtr RoutePresentationConnection::Clone() const {
  return New(
      mojo::Clone(connection_remote),
      mojo::Clone(connection_receiver)
  );
}

template <typename T, RoutePresentationConnection::EnableIfSame<T>*>
bool RoutePresentationConnection::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->connection_remote, other_struct.connection_remote))
    return false;
  if (!mojo::Equals(this->connection_receiver, other_struct.connection_receiver))
    return false;
  return true;
}

template <typename T, RoutePresentationConnection::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.connection_remote < rhs.connection_remote)
    return true;
  if (rhs.connection_remote < lhs.connection_remote)
    return false;
  if (lhs.connection_receiver < rhs.connection_receiver)
    return true;
  if (rhs.connection_receiver < lhs.connection_receiver)
    return false;
  return false;
}
template <typename StructPtrType>
CastSessionStatePtr CastSessionState::Clone() const {
  return New(
      mojo::Clone(sink_id),
      mojo::Clone(app_id),
      mojo::Clone(session_id),
      mojo::Clone(route_description)
  );
}

template <typename T, CastSessionState::EnableIfSame<T>*>
bool CastSessionState::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->sink_id, other_struct.sink_id))
    return false;
  if (!mojo::Equals(this->app_id, other_struct.app_id))
    return false;
  if (!mojo::Equals(this->session_id, other_struct.session_id))
    return false;
  if (!mojo::Equals(this->route_description, other_struct.route_description))
    return false;
  return true;
}

template <typename T, CastSessionState::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.sink_id < rhs.sink_id)
    return true;
  if (rhs.sink_id < lhs.sink_id)
    return false;
  if (lhs.app_id < rhs.app_id)
    return true;
  if (rhs.app_id < lhs.app_id)
    return false;
  if (lhs.session_id < rhs.session_id)
    return true;
  if (rhs.session_id < lhs.session_id)
    return false;
  if (lhs.route_description < rhs.route_description)
    return true;
  if (rhs.route_description < lhs.route_description)
    return false;
  return false;
}
template <typename StructPtrType>
CastProviderStatePtr CastProviderState::Clone() const {
  return New(
      mojo::Clone(session_state)
  );
}

template <typename T, CastProviderState::EnableIfSame<T>*>
bool CastProviderState::Equals(const T& other_struct) const {
  if (!mojo::Equals(this->session_state, other_struct.session_state))
    return false;
  return true;
}

template <typename T, CastProviderState::EnableIfSame<T>*>
bool operator<(const T& lhs, const T& rhs) {
  if (lhs.session_state < rhs.session_state)
    return true;
  if (rhs.session_state < lhs.session_state)
    return false;
  return false;
}


}  // namespace mojom
}  // namespace media_router

namespace mojo {


template <>
struct  StructTraits<::media_router::mojom::MediaSink::DataView,
                                         ::media_router::mojom::MediaSinkPtr> {
  static bool IsNull(const ::media_router::mojom::MediaSinkPtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::MediaSinkPtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::MediaSink::sink_id)& sink_id(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->sink_id;
  }

  static const decltype(::media_router::mojom::MediaSink::name)& name(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->name;
  }

  static const decltype(::media_router::mojom::MediaSink::description)& description(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->description;
  }

  static const decltype(::media_router::mojom::MediaSink::domain)& domain(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->domain;
  }

  static decltype(::media_router::mojom::MediaSink::icon_type) icon_type(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->icon_type;
  }

  static decltype(::media_router::mojom::MediaSink::provider_id) provider_id(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->provider_id;
  }

  static const decltype(::media_router::mojom::MediaSink::extra_data)& extra_data(
      const ::media_router::mojom::MediaSinkPtr& input) {
    return input->extra_data;
  }

  static bool Read(::media_router::mojom::MediaSink::DataView input, ::media_router::mojom::MediaSinkPtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::DialMediaSink::DataView,
                                         ::media_router::mojom::DialMediaSinkPtr> {
  static bool IsNull(const ::media_router::mojom::DialMediaSinkPtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::DialMediaSinkPtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::DialMediaSink::ip_address)& ip_address(
      const ::media_router::mojom::DialMediaSinkPtr& input) {
    return input->ip_address;
  }

  static const decltype(::media_router::mojom::DialMediaSink::model_name)& model_name(
      const ::media_router::mojom::DialMediaSinkPtr& input) {
    return input->model_name;
  }

  static const decltype(::media_router::mojom::DialMediaSink::app_url)& app_url(
      const ::media_router::mojom::DialMediaSinkPtr& input) {
    return input->app_url;
  }

  static bool Read(::media_router::mojom::DialMediaSink::DataView input, ::media_router::mojom::DialMediaSinkPtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::CastMediaSink::DataView,
                                         ::media_router::mojom::CastMediaSinkPtr> {
  static bool IsNull(const ::media_router::mojom::CastMediaSinkPtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::CastMediaSinkPtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::CastMediaSink::ip_endpoint)& ip_endpoint(
      const ::media_router::mojom::CastMediaSinkPtr& input) {
    return input->ip_endpoint;
  }

  static const decltype(::media_router::mojom::CastMediaSink::model_name)& model_name(
      const ::media_router::mojom::CastMediaSinkPtr& input) {
    return input->model_name;
  }

  static decltype(::media_router::mojom::CastMediaSink::capabilities) capabilities(
      const ::media_router::mojom::CastMediaSinkPtr& input) {
    return input->capabilities;
  }

  static decltype(::media_router::mojom::CastMediaSink::cast_channel_id) cast_channel_id(
      const ::media_router::mojom::CastMediaSinkPtr& input) {
    return input->cast_channel_id;
  }

  static bool Read(::media_router::mojom::CastMediaSink::DataView input, ::media_router::mojom::CastMediaSinkPtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::MediaRoute::DataView,
                                         ::media_router::mojom::MediaRoutePtr> {
  static bool IsNull(const ::media_router::mojom::MediaRoutePtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::MediaRoutePtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::MediaRoute::media_route_id)& media_route_id(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->media_route_id;
  }

  static const decltype(::media_router::mojom::MediaRoute::presentation_id)& presentation_id(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->presentation_id;
  }

  static const decltype(::media_router::mojom::MediaRoute::media_source)& media_source(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->media_source;
  }

  static const decltype(::media_router::mojom::MediaRoute::media_sink_id)& media_sink_id(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->media_sink_id;
  }

  static const decltype(::media_router::mojom::MediaRoute::media_sink_name)& media_sink_name(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->media_sink_name;
  }

  static const decltype(::media_router::mojom::MediaRoute::description)& description(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->description;
  }

  static decltype(::media_router::mojom::MediaRoute::is_local) is_local(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->is_local;
  }

  static decltype(::media_router::mojom::MediaRoute::controller_type) controller_type(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->controller_type;
  }

  static decltype(::media_router::mojom::MediaRoute::is_off_the_record) is_off_the_record(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->is_off_the_record;
  }

  static decltype(::media_router::mojom::MediaRoute::is_local_presentation) is_local_presentation(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->is_local_presentation;
  }

  static decltype(::media_router::mojom::MediaRoute::is_connecting) is_connecting(
      const ::media_router::mojom::MediaRoutePtr& input) {
    return input->is_connecting;
  }

  static bool Read(::media_router::mojom::MediaRoute::DataView input, ::media_router::mojom::MediaRoutePtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::Issue::DataView,
                                         ::media_router::mojom::IssuePtr> {
  static bool IsNull(const ::media_router::mojom::IssuePtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::IssuePtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::Issue::route_id)& route_id(
      const ::media_router::mojom::IssuePtr& input) {
    return input->route_id;
  }

  static const decltype(::media_router::mojom::Issue::sink_id)& sink_id(
      const ::media_router::mojom::IssuePtr& input) {
    return input->sink_id;
  }

  static decltype(::media_router::mojom::Issue::severity) severity(
      const ::media_router::mojom::IssuePtr& input) {
    return input->severity;
  }

  static decltype(::media_router::mojom::Issue::is_blocking) is_blocking(
      const ::media_router::mojom::IssuePtr& input) {
    return input->is_blocking;
  }

  static const decltype(::media_router::mojom::Issue::title)& title(
      const ::media_router::mojom::IssuePtr& input) {
    return input->title;
  }

  static const decltype(::media_router::mojom::Issue::message)& message(
      const ::media_router::mojom::IssuePtr& input) {
    return input->message;
  }

  static decltype(::media_router::mojom::Issue::default_action) default_action(
      const ::media_router::mojom::IssuePtr& input) {
    return input->default_action;
  }

  static const decltype(::media_router::mojom::Issue::secondary_actions)& secondary_actions(
      const ::media_router::mojom::IssuePtr& input) {
    return input->secondary_actions;
  }

  static decltype(::media_router::mojom::Issue::help_page_id) help_page_id(
      const ::media_router::mojom::IssuePtr& input) {
    return input->help_page_id;
  }

  static bool Read(::media_router::mojom::Issue::DataView input, ::media_router::mojom::IssuePtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::RouteMessage::DataView,
                                         ::media_router::mojom::RouteMessagePtr> {
  static bool IsNull(const ::media_router::mojom::RouteMessagePtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::RouteMessagePtr* output) { output->reset(); }

  static decltype(::media_router::mojom::RouteMessage::type) type(
      const ::media_router::mojom::RouteMessagePtr& input) {
    return input->type;
  }

  static const decltype(::media_router::mojom::RouteMessage::message)& message(
      const ::media_router::mojom::RouteMessagePtr& input) {
    return input->message;
  }

  static const decltype(::media_router::mojom::RouteMessage::data)& data(
      const ::media_router::mojom::RouteMessagePtr& input) {
    return input->data;
  }

  static bool Read(::media_router::mojom::RouteMessage::DataView input, ::media_router::mojom::RouteMessagePtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::RoutePresentationConnection::DataView,
                                         ::media_router::mojom::RoutePresentationConnectionPtr> {
  static bool IsNull(const ::media_router::mojom::RoutePresentationConnectionPtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::RoutePresentationConnectionPtr* output) { output->reset(); }

  static  decltype(::media_router::mojom::RoutePresentationConnection::connection_remote)& connection_remote(
       ::media_router::mojom::RoutePresentationConnectionPtr& input) {
    return input->connection_remote;
  }

  static  decltype(::media_router::mojom::RoutePresentationConnection::connection_receiver)& connection_receiver(
       ::media_router::mojom::RoutePresentationConnectionPtr& input) {
    return input->connection_receiver;
  }

  static bool Read(::media_router::mojom::RoutePresentationConnection::DataView input, ::media_router::mojom::RoutePresentationConnectionPtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::CastSessionState::DataView,
                                         ::media_router::mojom::CastSessionStatePtr> {
  static bool IsNull(const ::media_router::mojom::CastSessionStatePtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::CastSessionStatePtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::CastSessionState::sink_id)& sink_id(
      const ::media_router::mojom::CastSessionStatePtr& input) {
    return input->sink_id;
  }

  static const decltype(::media_router::mojom::CastSessionState::app_id)& app_id(
      const ::media_router::mojom::CastSessionStatePtr& input) {
    return input->app_id;
  }

  static const decltype(::media_router::mojom::CastSessionState::session_id)& session_id(
      const ::media_router::mojom::CastSessionStatePtr& input) {
    return input->session_id;
  }

  static const decltype(::media_router::mojom::CastSessionState::route_description)& route_description(
      const ::media_router::mojom::CastSessionStatePtr& input) {
    return input->route_description;
  }

  static bool Read(::media_router::mojom::CastSessionState::DataView input, ::media_router::mojom::CastSessionStatePtr* output);
};


template <>
struct  StructTraits<::media_router::mojom::CastProviderState::DataView,
                                         ::media_router::mojom::CastProviderStatePtr> {
  static bool IsNull(const ::media_router::mojom::CastProviderStatePtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::CastProviderStatePtr* output) { output->reset(); }

  static const decltype(::media_router::mojom::CastProviderState::session_state)& session_state(
      const ::media_router::mojom::CastProviderStatePtr& input) {
    return input->session_state;
  }

  static bool Read(::media_router::mojom::CastProviderState::DataView input, ::media_router::mojom::CastProviderStatePtr* output);
};


template <>
struct  UnionTraits<::media_router::mojom::MediaSinkExtraData::DataView,
                                        ::media_router::mojom::MediaSinkExtraDataPtr> {
  static bool IsNull(const ::media_router::mojom::MediaSinkExtraDataPtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::MediaSinkExtraDataPtr* output) { output->reset(); }

  static ::media_router::mojom::MediaSinkExtraData::Tag GetTag(const ::media_router::mojom::MediaSinkExtraDataPtr& input) {
    return input->which();
  }

  static const ::media_router::mojom::DialMediaSinkPtr& dial_media_sink(const ::media_router::mojom::MediaSinkExtraDataPtr& input) {
    return input->get_dial_media_sink();
  }

  static const ::media_router::mojom::CastMediaSinkPtr& cast_media_sink(const ::media_router::mojom::MediaSinkExtraDataPtr& input) {
    return input->get_cast_media_sink();
  }

  static bool Read(::media_router::mojom::MediaSinkExtraData::DataView input, ::media_router::mojom::MediaSinkExtraDataPtr* output);
};


template <>
struct  UnionTraits<::media_router::mojom::ProviderState::DataView,
                                        ::media_router::mojom::ProviderStatePtr> {
  static bool IsNull(const ::media_router::mojom::ProviderStatePtr& input) { return !input; }
  static void SetToNull(::media_router::mojom::ProviderStatePtr* output) { output->reset(); }

  static ::media_router::mojom::ProviderState::Tag GetTag(const ::media_router::mojom::ProviderStatePtr& input) {
    return input->which();
  }

  static const ::media_router::mojom::CastProviderStatePtr& cast_provider_state(const ::media_router::mojom::ProviderStatePtr& input) {
    return input->get_cast_provider_state();
  }

  static bool Read(::media_router::mojom::ProviderState::DataView input, ::media_router::mojom::ProviderStatePtr* output);
};

}  // namespace mojo

#endif  // COMPONENTS_MEDIA_ROUTER_COMMON_MOJOM_MEDIA_ROUTER_MOJOM_H_