// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: components/optimization_guide/proto/models.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fmodels_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fmodels_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
#include "components/optimization_guide/proto/common_types.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_components_2foptimization_5fguide_2fproto_2fmodels_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto {
  static const uint32_t offsets[];
};
namespace optimization_guide {
namespace proto {
class AdditionalModelFile;
struct AdditionalModelFileDefaultTypeInternal;
extern AdditionalModelFileDefaultTypeInternal _AdditionalModelFile_default_instance_;
class BinaryNode;
struct BinaryNodeDefaultTypeInternal;
extern BinaryNodeDefaultTypeInternal _BinaryNode_default_instance_;
class DecisionTree;
struct DecisionTreeDefaultTypeInternal;
extern DecisionTreeDefaultTypeInternal _DecisionTree_default_instance_;
class DoubleValue;
struct DoubleValueDefaultTypeInternal;
extern DoubleValueDefaultTypeInternal _DoubleValue_default_instance_;
class Ensemble;
struct EnsembleDefaultTypeInternal;
extern EnsembleDefaultTypeInternal _Ensemble_default_instance_;
class Ensemble_Member;
struct Ensemble_MemberDefaultTypeInternal;
extern Ensemble_MemberDefaultTypeInternal _Ensemble_Member_default_instance_;
class FeatureId;
struct FeatureIdDefaultTypeInternal;
extern FeatureIdDefaultTypeInternal _FeatureId_default_instance_;
class GetModelsRequest;
struct GetModelsRequestDefaultTypeInternal;
extern GetModelsRequestDefaultTypeInternal _GetModelsRequest_default_instance_;
class GetModelsResponse;
struct GetModelsResponseDefaultTypeInternal;
extern GetModelsResponseDefaultTypeInternal _GetModelsResponse_default_instance_;
class HostModelFeatures;
struct HostModelFeaturesDefaultTypeInternal;
extern HostModelFeaturesDefaultTypeInternal _HostModelFeatures_default_instance_;
class InequalityTest;
struct InequalityTestDefaultTypeInternal;
extern InequalityTestDefaultTypeInternal _InequalityTest_default_instance_;
class Int32Value;
struct Int32ValueDefaultTypeInternal;
extern Int32ValueDefaultTypeInternal _Int32Value_default_instance_;
class Leaf;
struct LeafDefaultTypeInternal;
extern LeafDefaultTypeInternal _Leaf_default_instance_;
class Model;
struct ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class ModelFeature;
struct ModelFeatureDefaultTypeInternal;
extern ModelFeatureDefaultTypeInternal _ModelFeature_default_instance_;
class ModelInfo;
struct ModelInfoDefaultTypeInternal;
extern ModelInfoDefaultTypeInternal _ModelInfo_default_instance_;
class PredictionModel;
struct PredictionModelDefaultTypeInternal;
extern PredictionModelDefaultTypeInternal _PredictionModel_default_instance_;
class TreeNode;
struct TreeNodeDefaultTypeInternal;
extern TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
class Value;
struct ValueDefaultTypeInternal;
extern ValueDefaultTypeInternal _Value_default_instance_;
class Vector;
struct VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
}  // namespace proto
}  // namespace optimization_guide
PROTOBUF_NAMESPACE_OPEN
template<> ::optimization_guide::proto::AdditionalModelFile* Arena::CreateMaybeMessage<::optimization_guide::proto::AdditionalModelFile>(Arena*);
template<> ::optimization_guide::proto::BinaryNode* Arena::CreateMaybeMessage<::optimization_guide::proto::BinaryNode>(Arena*);
template<> ::optimization_guide::proto::DecisionTree* Arena::CreateMaybeMessage<::optimization_guide::proto::DecisionTree>(Arena*);
template<> ::optimization_guide::proto::DoubleValue* Arena::CreateMaybeMessage<::optimization_guide::proto::DoubleValue>(Arena*);
template<> ::optimization_guide::proto::Ensemble* Arena::CreateMaybeMessage<::optimization_guide::proto::Ensemble>(Arena*);
template<> ::optimization_guide::proto::Ensemble_Member* Arena::CreateMaybeMessage<::optimization_guide::proto::Ensemble_Member>(Arena*);
template<> ::optimization_guide::proto::FeatureId* Arena::CreateMaybeMessage<::optimization_guide::proto::FeatureId>(Arena*);
template<> ::optimization_guide::proto::GetModelsRequest* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsRequest>(Arena*);
template<> ::optimization_guide::proto::GetModelsResponse* Arena::CreateMaybeMessage<::optimization_guide::proto::GetModelsResponse>(Arena*);
template<> ::optimization_guide::proto::HostModelFeatures* Arena::CreateMaybeMessage<::optimization_guide::proto::HostModelFeatures>(Arena*);
template<> ::optimization_guide::proto::InequalityTest* Arena::CreateMaybeMessage<::optimization_guide::proto::InequalityTest>(Arena*);
template<> ::optimization_guide::proto::Int32Value* Arena::CreateMaybeMessage<::optimization_guide::proto::Int32Value>(Arena*);
template<> ::optimization_guide::proto::Leaf* Arena::CreateMaybeMessage<::optimization_guide::proto::Leaf>(Arena*);
template<> ::optimization_guide::proto::Model* Arena::CreateMaybeMessage<::optimization_guide::proto::Model>(Arena*);
template<> ::optimization_guide::proto::ModelFeature* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelFeature>(Arena*);
template<> ::optimization_guide::proto::ModelInfo* Arena::CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(Arena*);
template<> ::optimization_guide::proto::PredictionModel* Arena::CreateMaybeMessage<::optimization_guide::proto::PredictionModel>(Arena*);
template<> ::optimization_guide::proto::TreeNode* Arena::CreateMaybeMessage<::optimization_guide::proto::TreeNode>(Arena*);
template<> ::optimization_guide::proto::Value* Arena::CreateMaybeMessage<::optimization_guide::proto::Value>(Arena*);
template<> ::optimization_guide::proto::Vector* Arena::CreateMaybeMessage<::optimization_guide::proto::Vector>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace optimization_guide {
namespace proto {

enum BinaryNode_Direction : int {
  BinaryNode_Direction_LEFT = 0,
  BinaryNode_Direction_RIGHT = 1
};
bool BinaryNode_Direction_IsValid(int value);
constexpr BinaryNode_Direction BinaryNode_Direction_Direction_MIN = BinaryNode_Direction_LEFT;
constexpr BinaryNode_Direction BinaryNode_Direction_Direction_MAX = BinaryNode_Direction_RIGHT;
constexpr int BinaryNode_Direction_Direction_ARRAYSIZE = BinaryNode_Direction_Direction_MAX + 1;

const std::string& BinaryNode_Direction_Name(BinaryNode_Direction value);
template<typename T>
inline const std::string& BinaryNode_Direction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BinaryNode_Direction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BinaryNode_Direction_Name.");
  return BinaryNode_Direction_Name(static_cast<BinaryNode_Direction>(enum_t_value));
}
bool BinaryNode_Direction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BinaryNode_Direction* value);
enum InequalityTest_Type : int {
  InequalityTest_Type_LESS_OR_EQUAL = 0,
  InequalityTest_Type_LESS_THAN = 1,
  InequalityTest_Type_GREATER_OR_EQUAL = 2,
  InequalityTest_Type_GREATER_THAN = 3
};
bool InequalityTest_Type_IsValid(int value);
constexpr InequalityTest_Type InequalityTest_Type_Type_MIN = InequalityTest_Type_LESS_OR_EQUAL;
constexpr InequalityTest_Type InequalityTest_Type_Type_MAX = InequalityTest_Type_GREATER_THAN;
constexpr int InequalityTest_Type_Type_ARRAYSIZE = InequalityTest_Type_Type_MAX + 1;

const std::string& InequalityTest_Type_Name(InequalityTest_Type value);
template<typename T>
inline const std::string& InequalityTest_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, InequalityTest_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function InequalityTest_Type_Name.");
  return InequalityTest_Type_Name(static_cast<InequalityTest_Type>(enum_t_value));
}
bool InequalityTest_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, InequalityTest_Type* value);
enum OptimizationTarget : int {
  OPTIMIZATION_TARGET_UNKNOWN = 0,
  OPTIMIZATION_TARGET_PAINFUL_PAGE_LOAD = 1,
  OPTIMIZATION_TARGET_LANGUAGE_DETECTION = 2,
  OPTIMIZATION_TARGET_PAGE_TOPICS = 3,
  OPTIMIZATION_TARGET_SEGMENTATION_NEW_TAB = 4,
  OPTIMIZATION_TARGET_SEGMENTATION_SHARE = 5,
  OPTIMIZATION_TARGET_SEGMENTATION_VOICE = 6,
  OPTIMIZATION_TARGET_MODEL_VALIDATION = 7,
  OPTIMIZATION_TARGET_PAGE_ENTITIES = 8,
  OPTIMIZATION_TARGET_NOTIFICATION_PERMISSION_PREDICTIONS = 9,
  OPTIMIZATION_TARGET_SEGMENTATION_DUMMY = 10,
  OPTIMIZATION_TARGET_SEGMENTATION_CHROME_START_ANDROID = 11,
  OPTIMIZATION_TARGET_SEGMENTATION_QUERY_TILES = 12,
  OPTIMIZATION_TARGET_PAGE_VISIBILITY = 13,
  OPTIMIZATION_TARGET_AUTOFILL_ASSISTANT = 14,
  OPTIMIZATION_TARGET_PAGE_TOPICS_V2 = 15,
  OPTIMIZATION_TARGET_SEGMENTATION_CHROME_LOW_USER_ENGAGEMENT = 16,
  OPTIMIZATION_TARGET_SEGMENTATION_FEED_USER = 17,
  OPTIMIZATION_TARGET_CONTEXTUAL_PAGE_ACTION_PRICE_TRACKING = 18,
  OPTIMIZATION_TARGET_TEXT_CLASSIFIER = 19
};
bool OptimizationTarget_IsValid(int value);
constexpr OptimizationTarget OptimizationTarget_MIN = OPTIMIZATION_TARGET_UNKNOWN;
constexpr OptimizationTarget OptimizationTarget_MAX = OPTIMIZATION_TARGET_TEXT_CLASSIFIER;
constexpr int OptimizationTarget_ARRAYSIZE = OptimizationTarget_MAX + 1;

const std::string& OptimizationTarget_Name(OptimizationTarget value);
template<typename T>
inline const std::string& OptimizationTarget_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OptimizationTarget>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OptimizationTarget_Name.");
  return OptimizationTarget_Name(static_cast<OptimizationTarget>(enum_t_value));
}
bool OptimizationTarget_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OptimizationTarget* value);
enum ModelEngineVersion : int {
  MODEL_ENGINE_VERSION_UNKNOWN = 0,
  MODEL_ENGINE_VERSION_DECISION_TREE = 1,
  MODEL_ENGINE_VERSION_TFLITE_2_3_0 = 2,
  MODEL_ENGINE_VERSION_TFLITE_2_3_0_1 = 3,
  MODEL_ENGINE_VERSION_TFLITE_2_4 = 4,
  MODEL_ENGINE_VERSION_TFLITE_2_7 = 5,
  MODEL_ENGINE_VERSION_TFLITE_2_8 = 6,
  MODEL_ENGINE_VERSION_TFLITE_2_9 = 7,
  MODEL_ENGINE_VERSION_TFLITE_2_9_0_1 = 8,
  MODEL_ENGINE_VERSION_TFLITE_2_10 = 9,
  MODEL_ENGINE_VERSION_TFLITE_2_11 = 10
};
bool ModelEngineVersion_IsValid(int value);
constexpr ModelEngineVersion ModelEngineVersion_MIN = MODEL_ENGINE_VERSION_UNKNOWN;
constexpr ModelEngineVersion ModelEngineVersion_MAX = MODEL_ENGINE_VERSION_TFLITE_2_11;
constexpr int ModelEngineVersion_ARRAYSIZE = ModelEngineVersion_MAX + 1;

const std::string& ModelEngineVersion_Name(ModelEngineVersion value);
template<typename T>
inline const std::string& ModelEngineVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ModelEngineVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ModelEngineVersion_Name.");
  return ModelEngineVersion_Name(static_cast<ModelEngineVersion>(enum_t_value));
}
bool ModelEngineVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ModelEngineVersion* value);
// ===================================================================

class Model final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Model) */ {
 public:
  inline Model() : Model(nullptr) {}
  ~Model() override;
  explicit PROTOBUF_CONSTEXPR Model(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Model(const Model& from);
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  inline Model& operator=(Model&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Model& default_instance() {
    return *internal_default_instance();
  }
  enum ModelCase {
    kDecisionTree = 1,
    kEnsemble = 2,
    kDownloadUrl = 5,
    MODEL_NOT_SET = 0,
  };

  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Model* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Model* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Model* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Model>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Model* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Model";
  }
  protected:
  explicit Model(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThresholdFieldNumber = 123,
    kDecisionTreeFieldNumber = 1,
    kEnsembleFieldNumber = 2,
    kDownloadUrlFieldNumber = 5,
  };
  // optional .optimization_guide.proto.DoubleValue threshold = 123;
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  const ::optimization_guide::proto::DoubleValue& threshold() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::DoubleValue* release_threshold();
  ::optimization_guide::proto::DoubleValue* mutable_threshold();
  void set_allocated_threshold(::optimization_guide::proto::DoubleValue* threshold);
  private:
  const ::optimization_guide::proto::DoubleValue& _internal_threshold() const;
  ::optimization_guide::proto::DoubleValue* _internal_mutable_threshold();
  public:
  void unsafe_arena_set_allocated_threshold(
      ::optimization_guide::proto::DoubleValue* threshold);
  ::optimization_guide::proto::DoubleValue* unsafe_arena_release_threshold();

  // .optimization_guide.proto.DecisionTree decision_tree = 1;
  bool has_decision_tree() const;
  private:
  bool _internal_has_decision_tree() const;
  public:
  void clear_decision_tree();
  const ::optimization_guide::proto::DecisionTree& decision_tree() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::DecisionTree* release_decision_tree();
  ::optimization_guide::proto::DecisionTree* mutable_decision_tree();
  void set_allocated_decision_tree(::optimization_guide::proto::DecisionTree* decision_tree);
  private:
  const ::optimization_guide::proto::DecisionTree& _internal_decision_tree() const;
  ::optimization_guide::proto::DecisionTree* _internal_mutable_decision_tree();
  public:
  void unsafe_arena_set_allocated_decision_tree(
      ::optimization_guide::proto::DecisionTree* decision_tree);
  ::optimization_guide::proto::DecisionTree* unsafe_arena_release_decision_tree();

  // .optimization_guide.proto.Ensemble ensemble = 2;
  bool has_ensemble() const;
  private:
  bool _internal_has_ensemble() const;
  public:
  void clear_ensemble();
  const ::optimization_guide::proto::Ensemble& ensemble() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Ensemble* release_ensemble();
  ::optimization_guide::proto::Ensemble* mutable_ensemble();
  void set_allocated_ensemble(::optimization_guide::proto::Ensemble* ensemble);
  private:
  const ::optimization_guide::proto::Ensemble& _internal_ensemble() const;
  ::optimization_guide::proto::Ensemble* _internal_mutable_ensemble();
  public:
  void unsafe_arena_set_allocated_ensemble(
      ::optimization_guide::proto::Ensemble* ensemble);
  ::optimization_guide::proto::Ensemble* unsafe_arena_release_ensemble();

  // string download_url = 5;
  bool has_download_url() const;
  private:
  bool _internal_has_download_url() const;
  public:
  void clear_download_url();
  const std::string& download_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_download_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_download_url();
  PROTOBUF_NODISCARD std::string* release_download_url();
  void set_allocated_download_url(std::string* download_url);
  private:
  const std::string& _internal_download_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_download_url(const std::string& value);
  std::string* _internal_mutable_download_url();
  public:

  void clear_model();
  ModelCase model_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Model)
 private:
  class _Internal;
  void set_has_decision_tree();
  void set_has_ensemble();
  void set_has_download_url();

  inline bool has_model() const;
  inline void clear_has_model();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::DoubleValue* threshold_;
  union ModelUnion {
    constexpr ModelUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::optimization_guide::proto::DecisionTree* decision_tree_;
    ::optimization_guide::proto::Ensemble* ensemble_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr download_url_;
  } model_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Ensemble_Member final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Ensemble.Member) */ {
 public:
  inline Ensemble_Member() : Ensemble_Member(nullptr) {}
  ~Ensemble_Member() override;
  explicit PROTOBUF_CONSTEXPR Ensemble_Member(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ensemble_Member(const Ensemble_Member& from);
  Ensemble_Member(Ensemble_Member&& from) noexcept
    : Ensemble_Member() {
    *this = ::std::move(from);
  }

  inline Ensemble_Member& operator=(const Ensemble_Member& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ensemble_Member& operator=(Ensemble_Member&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Ensemble_Member& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ensemble_Member* internal_default_instance() {
    return reinterpret_cast<const Ensemble_Member*>(
               &_Ensemble_Member_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ensemble_Member& a, Ensemble_Member& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Ensemble_Member* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ensemble_Member* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ensemble_Member* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ensemble_Member>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Ensemble_Member& from);
  void MergeFrom(const Ensemble_Member& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ensemble_Member* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Ensemble.Member";
  }
  protected:
  explicit Ensemble_Member(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubmodelFieldNumber = 1,
  };
  // optional .optimization_guide.proto.Model submodel = 1;
  bool has_submodel() const;
  private:
  bool _internal_has_submodel() const;
  public:
  void clear_submodel();
  const ::optimization_guide::proto::Model& submodel() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Model* release_submodel();
  ::optimization_guide::proto::Model* mutable_submodel();
  void set_allocated_submodel(::optimization_guide::proto::Model* submodel);
  private:
  const ::optimization_guide::proto::Model& _internal_submodel() const;
  ::optimization_guide::proto::Model* _internal_mutable_submodel();
  public:
  void unsafe_arena_set_allocated_submodel(
      ::optimization_guide::proto::Model* submodel);
  ::optimization_guide::proto::Model* unsafe_arena_release_submodel();

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Ensemble.Member)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Model* submodel_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Ensemble final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Ensemble) */ {
 public:
  inline Ensemble() : Ensemble(nullptr) {}
  ~Ensemble() override;
  explicit PROTOBUF_CONSTEXPR Ensemble(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ensemble(const Ensemble& from);
  Ensemble(Ensemble&& from) noexcept
    : Ensemble() {
    *this = ::std::move(from);
  }

  inline Ensemble& operator=(const Ensemble& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ensemble& operator=(Ensemble&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Ensemble& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ensemble* internal_default_instance() {
    return reinterpret_cast<const Ensemble*>(
               &_Ensemble_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Ensemble& a, Ensemble& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Ensemble* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ensemble* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ensemble* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ensemble>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Ensemble& from);
  void MergeFrom(const Ensemble& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Ensemble* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Ensemble";
  }
  protected:
  explicit Ensemble(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef Ensemble_Member Member;

  // accessors -------------------------------------------------------

  enum : int {
    kMembersFieldNumber = 100,
  };
  // repeated .optimization_guide.proto.Ensemble.Member members = 100;
  int members_size() const;
  private:
  int _internal_members_size() const;
  public:
  void clear_members();
  ::optimization_guide::proto::Ensemble_Member* mutable_members(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >*
      mutable_members();
  private:
  const ::optimization_guide::proto::Ensemble_Member& _internal_members(int index) const;
  ::optimization_guide::proto::Ensemble_Member* _internal_add_members();
  public:
  const ::optimization_guide::proto::Ensemble_Member& members(int index) const;
  ::optimization_guide::proto::Ensemble_Member* add_members();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >&
      members() const;

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Ensemble)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member > members_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class DecisionTree final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.DecisionTree) */ {
 public:
  inline DecisionTree() : DecisionTree(nullptr) {}
  ~DecisionTree() override;
  explicit PROTOBUF_CONSTEXPR DecisionTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DecisionTree(const DecisionTree& from);
  DecisionTree(DecisionTree&& from) noexcept
    : DecisionTree() {
    *this = ::std::move(from);
  }

  inline DecisionTree& operator=(const DecisionTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline DecisionTree& operator=(DecisionTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DecisionTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const DecisionTree* internal_default_instance() {
    return reinterpret_cast<const DecisionTree*>(
               &_DecisionTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DecisionTree& a, DecisionTree& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DecisionTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DecisionTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DecisionTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DecisionTree>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DecisionTree& from);
  void MergeFrom(const DecisionTree& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DecisionTree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.DecisionTree";
  }
  protected:
  explicit DecisionTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodesFieldNumber = 1,
    kWeightFieldNumber = 3,
  };
  // repeated .optimization_guide.proto.TreeNode nodes = 1;
  int nodes_size() const;
  private:
  int _internal_nodes_size() const;
  public:
  void clear_nodes();
  ::optimization_guide::proto::TreeNode* mutable_nodes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >*
      mutable_nodes();
  private:
  const ::optimization_guide::proto::TreeNode& _internal_nodes(int index) const;
  ::optimization_guide::proto::TreeNode* _internal_add_nodes();
  public:
  const ::optimization_guide::proto::TreeNode& nodes(int index) const;
  ::optimization_guide::proto::TreeNode* add_nodes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >&
      nodes() const;

  // optional float weight = 3;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  float weight() const;
  void set_weight(float value);
  private:
  float _internal_weight() const;
  void _internal_set_weight(float value);
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.DecisionTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode > nodes_;
  float weight_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class TreeNode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.TreeNode) */ {
 public:
  inline TreeNode() : TreeNode(nullptr) {}
  ~TreeNode() override;
  explicit PROTOBUF_CONSTEXPR TreeNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TreeNode(const TreeNode& from);
  TreeNode(TreeNode&& from) noexcept
    : TreeNode() {
    *this = ::std::move(from);
  }

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline TreeNode& operator=(TreeNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const TreeNode& default_instance() {
    return *internal_default_instance();
  }
  enum NodeTypeCase {
    kBinaryNode = 4,
    kLeaf = 5,
    NODE_TYPE_NOT_SET = 0,
  };

  static inline const TreeNode* internal_default_instance() {
    return reinterpret_cast<const TreeNode*>(
               &_TreeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TreeNode& a, TreeNode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(TreeNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TreeNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TreeNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TreeNode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TreeNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.TreeNode";
  }
  protected:
  explicit TreeNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kDepthFieldNumber = 2,
    kSubtreeSizeFieldNumber = 3,
    kBinaryNodeFieldNumber = 4,
    kLeafFieldNumber = 5,
  };
  // optional .optimization_guide.proto.Int32Value node_id = 1;
  bool has_node_id() const;
  private:
  bool _internal_has_node_id() const;
  public:
  void clear_node_id();
  const ::optimization_guide::proto::Int32Value& node_id() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Int32Value* release_node_id();
  ::optimization_guide::proto::Int32Value* mutable_node_id();
  void set_allocated_node_id(::optimization_guide::proto::Int32Value* node_id);
  private:
  const ::optimization_guide::proto::Int32Value& _internal_node_id() const;
  ::optimization_guide::proto::Int32Value* _internal_mutable_node_id();
  public:
  void unsafe_arena_set_allocated_node_id(
      ::optimization_guide::proto::Int32Value* node_id);
  ::optimization_guide::proto::Int32Value* unsafe_arena_release_node_id();

  // optional .optimization_guide.proto.Int32Value depth = 2;
  bool has_depth() const;
  private:
  bool _internal_has_depth() const;
  public:
  void clear_depth();
  const ::optimization_guide::proto::Int32Value& depth() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Int32Value* release_depth();
  ::optimization_guide::proto::Int32Value* mutable_depth();
  void set_allocated_depth(::optimization_guide::proto::Int32Value* depth);
  private:
  const ::optimization_guide::proto::Int32Value& _internal_depth() const;
  ::optimization_guide::proto::Int32Value* _internal_mutable_depth();
  public:
  void unsafe_arena_set_allocated_depth(
      ::optimization_guide::proto::Int32Value* depth);
  ::optimization_guide::proto::Int32Value* unsafe_arena_release_depth();

  // optional .optimization_guide.proto.Int32Value subtree_size = 3;
  bool has_subtree_size() const;
  private:
  bool _internal_has_subtree_size() const;
  public:
  void clear_subtree_size();
  const ::optimization_guide::proto::Int32Value& subtree_size() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Int32Value* release_subtree_size();
  ::optimization_guide::proto::Int32Value* mutable_subtree_size();
  void set_allocated_subtree_size(::optimization_guide::proto::Int32Value* subtree_size);
  private:
  const ::optimization_guide::proto::Int32Value& _internal_subtree_size() const;
  ::optimization_guide::proto::Int32Value* _internal_mutable_subtree_size();
  public:
  void unsafe_arena_set_allocated_subtree_size(
      ::optimization_guide::proto::Int32Value* subtree_size);
  ::optimization_guide::proto::Int32Value* unsafe_arena_release_subtree_size();

  // .optimization_guide.proto.BinaryNode binary_node = 4;
  bool has_binary_node() const;
  private:
  bool _internal_has_binary_node() const;
  public:
  void clear_binary_node();
  const ::optimization_guide::proto::BinaryNode& binary_node() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::BinaryNode* release_binary_node();
  ::optimization_guide::proto::BinaryNode* mutable_binary_node();
  void set_allocated_binary_node(::optimization_guide::proto::BinaryNode* binary_node);
  private:
  const ::optimization_guide::proto::BinaryNode& _internal_binary_node() const;
  ::optimization_guide::proto::BinaryNode* _internal_mutable_binary_node();
  public:
  void unsafe_arena_set_allocated_binary_node(
      ::optimization_guide::proto::BinaryNode* binary_node);
  ::optimization_guide::proto::BinaryNode* unsafe_arena_release_binary_node();

  // .optimization_guide.proto.Leaf leaf = 5;
  bool has_leaf() const;
  private:
  bool _internal_has_leaf() const;
  public:
  void clear_leaf();
  const ::optimization_guide::proto::Leaf& leaf() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Leaf* release_leaf();
  ::optimization_guide::proto::Leaf* mutable_leaf();
  void set_allocated_leaf(::optimization_guide::proto::Leaf* leaf);
  private:
  const ::optimization_guide::proto::Leaf& _internal_leaf() const;
  ::optimization_guide::proto::Leaf* _internal_mutable_leaf();
  public:
  void unsafe_arena_set_allocated_leaf(
      ::optimization_guide::proto::Leaf* leaf);
  ::optimization_guide::proto::Leaf* unsafe_arena_release_leaf();

  void clear_node_type();
  NodeTypeCase node_type_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.TreeNode)
 private:
  class _Internal;
  void set_has_binary_node();
  void set_has_leaf();

  inline bool has_node_type() const;
  inline void clear_has_node_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Int32Value* node_id_;
  ::optimization_guide::proto::Int32Value* depth_;
  ::optimization_guide::proto::Int32Value* subtree_size_;
  union NodeTypeUnion {
    constexpr NodeTypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::optimization_guide::proto::BinaryNode* binary_node_;
    ::optimization_guide::proto::Leaf* leaf_;
  } node_type_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class BinaryNode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.BinaryNode) */ {
 public:
  inline BinaryNode() : BinaryNode(nullptr) {}
  ~BinaryNode() override;
  explicit PROTOBUF_CONSTEXPR BinaryNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BinaryNode(const BinaryNode& from);
  BinaryNode(BinaryNode&& from) noexcept
    : BinaryNode() {
    *this = ::std::move(from);
  }

  inline BinaryNode& operator=(const BinaryNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline BinaryNode& operator=(BinaryNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const BinaryNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const BinaryNode* internal_default_instance() {
    return reinterpret_cast<const BinaryNode*>(
               &_BinaryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BinaryNode& a, BinaryNode& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(BinaryNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BinaryNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BinaryNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BinaryNode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const BinaryNode& from);
  void MergeFrom(const BinaryNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BinaryNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.BinaryNode";
  }
  protected:
  explicit BinaryNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef BinaryNode_Direction Direction;
  static constexpr Direction LEFT =
    BinaryNode_Direction_LEFT;
  static constexpr Direction RIGHT =
    BinaryNode_Direction_RIGHT;
  static inline bool Direction_IsValid(int value) {
    return BinaryNode_Direction_IsValid(value);
  }
  static constexpr Direction Direction_MIN =
    BinaryNode_Direction_Direction_MIN;
  static constexpr Direction Direction_MAX =
    BinaryNode_Direction_Direction_MAX;
  static constexpr int Direction_ARRAYSIZE =
    BinaryNode_Direction_Direction_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Direction_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Direction>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Direction_Name.");
    return BinaryNode_Direction_Name(enum_t_value);
  }
  static inline bool Direction_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Direction* value) {
    return BinaryNode_Direction_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftChildIdFieldNumber = 1,
    kRightChildIdFieldNumber = 2,
    kInequalityLeftChildTestFieldNumber = 4,
  };
  // optional .optimization_guide.proto.Int32Value left_child_id = 1;
  bool has_left_child_id() const;
  private:
  bool _internal_has_left_child_id() const;
  public:
  void clear_left_child_id();
  const ::optimization_guide::proto::Int32Value& left_child_id() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Int32Value* release_left_child_id();
  ::optimization_guide::proto::Int32Value* mutable_left_child_id();
  void set_allocated_left_child_id(::optimization_guide::proto::Int32Value* left_child_id);
  private:
  const ::optimization_guide::proto::Int32Value& _internal_left_child_id() const;
  ::optimization_guide::proto::Int32Value* _internal_mutable_left_child_id();
  public:
  void unsafe_arena_set_allocated_left_child_id(
      ::optimization_guide::proto::Int32Value* left_child_id);
  ::optimization_guide::proto::Int32Value* unsafe_arena_release_left_child_id();

  // optional .optimization_guide.proto.Int32Value right_child_id = 2;
  bool has_right_child_id() const;
  private:
  bool _internal_has_right_child_id() const;
  public:
  void clear_right_child_id();
  const ::optimization_guide::proto::Int32Value& right_child_id() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Int32Value* release_right_child_id();
  ::optimization_guide::proto::Int32Value* mutable_right_child_id();
  void set_allocated_right_child_id(::optimization_guide::proto::Int32Value* right_child_id);
  private:
  const ::optimization_guide::proto::Int32Value& _internal_right_child_id() const;
  ::optimization_guide::proto::Int32Value* _internal_mutable_right_child_id();
  public:
  void unsafe_arena_set_allocated_right_child_id(
      ::optimization_guide::proto::Int32Value* right_child_id);
  ::optimization_guide::proto::Int32Value* unsafe_arena_release_right_child_id();

  // optional .optimization_guide.proto.InequalityTest inequality_left_child_test = 4;
  bool has_inequality_left_child_test() const;
  private:
  bool _internal_has_inequality_left_child_test() const;
  public:
  void clear_inequality_left_child_test();
  const ::optimization_guide::proto::InequalityTest& inequality_left_child_test() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::InequalityTest* release_inequality_left_child_test();
  ::optimization_guide::proto::InequalityTest* mutable_inequality_left_child_test();
  void set_allocated_inequality_left_child_test(::optimization_guide::proto::InequalityTest* inequality_left_child_test);
  private:
  const ::optimization_guide::proto::InequalityTest& _internal_inequality_left_child_test() const;
  ::optimization_guide::proto::InequalityTest* _internal_mutable_inequality_left_child_test();
  public:
  void unsafe_arena_set_allocated_inequality_left_child_test(
      ::optimization_guide::proto::InequalityTest* inequality_left_child_test);
  ::optimization_guide::proto::InequalityTest* unsafe_arena_release_inequality_left_child_test();

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.BinaryNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Int32Value* left_child_id_;
  ::optimization_guide::proto::Int32Value* right_child_id_;
  ::optimization_guide::proto::InequalityTest* inequality_left_child_test_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Vector final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Vector) */ {
 public:
  inline Vector() : Vector(nullptr) {}
  ~Vector() override;
  explicit PROTOBUF_CONSTEXPR Vector(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vector(const Vector& from);
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vector& operator=(Vector&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Vector& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Vector* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Vector* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Vector";
  }
  protected:
  explicit Vector(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // repeated .optimization_guide.proto.Value value = 1;
  int value_size() const;
  private:
  int _internal_value_size() const;
  public:
  void clear_value();
  ::optimization_guide::proto::Value* mutable_value(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >*
      mutable_value();
  private:
  const ::optimization_guide::proto::Value& _internal_value(int index) const;
  ::optimization_guide::proto::Value* _internal_add_value();
  public:
  const ::optimization_guide::proto::Value& value(int index) const;
  ::optimization_guide::proto::Value* add_value();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >&
      value() const;

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Vector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value > value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Leaf final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Leaf) */ {
 public:
  inline Leaf() : Leaf(nullptr) {}
  ~Leaf() override;
  explicit PROTOBUF_CONSTEXPR Leaf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Leaf(const Leaf& from);
  Leaf(Leaf&& from) noexcept
    : Leaf() {
    *this = ::std::move(from);
  }

  inline Leaf& operator=(const Leaf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Leaf& operator=(Leaf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Leaf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Leaf* internal_default_instance() {
    return reinterpret_cast<const Leaf*>(
               &_Leaf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Leaf& a, Leaf& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Leaf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Leaf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Leaf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Leaf>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Leaf& from);
  void MergeFrom(const Leaf& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Leaf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Leaf";
  }
  protected:
  explicit Leaf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVectorFieldNumber = 1,
  };
  // optional .optimization_guide.proto.Vector vector = 1;
  bool has_vector() const;
  private:
  bool _internal_has_vector() const;
  public:
  void clear_vector();
  const ::optimization_guide::proto::Vector& vector() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Vector* release_vector();
  ::optimization_guide::proto::Vector* mutable_vector();
  void set_allocated_vector(::optimization_guide::proto::Vector* vector);
  private:
  const ::optimization_guide::proto::Vector& _internal_vector() const;
  ::optimization_guide::proto::Vector* _internal_mutable_vector();
  public:
  void unsafe_arena_set_allocated_vector(
      ::optimization_guide::proto::Vector* vector);
  ::optimization_guide::proto::Vector* unsafe_arena_release_vector();

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Leaf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::Vector* vector_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class FeatureId final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.FeatureId) */ {
 public:
  inline FeatureId() : FeatureId(nullptr) {}
  ~FeatureId() override;
  explicit PROTOBUF_CONSTEXPR FeatureId(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FeatureId(const FeatureId& from);
  FeatureId(FeatureId&& from) noexcept
    : FeatureId() {
    *this = ::std::move(from);
  }

  inline FeatureId& operator=(const FeatureId& from) {
    CopyFrom(from);
    return *this;
  }
  inline FeatureId& operator=(FeatureId&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const FeatureId& default_instance() {
    return *internal_default_instance();
  }
  static inline const FeatureId* internal_default_instance() {
    return reinterpret_cast<const FeatureId*>(
               &_FeatureId_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FeatureId& a, FeatureId& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(FeatureId* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FeatureId* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FeatureId* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FeatureId>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const FeatureId& from);
  void MergeFrom(const FeatureId& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FeatureId* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.FeatureId";
  }
  protected:
  explicit FeatureId(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // optional .optimization_guide.proto.StringValue id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::optimization_guide::proto::StringValue& id() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::StringValue* release_id();
  ::optimization_guide::proto::StringValue* mutable_id();
  void set_allocated_id(::optimization_guide::proto::StringValue* id);
  private:
  const ::optimization_guide::proto::StringValue& _internal_id() const;
  ::optimization_guide::proto::StringValue* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::optimization_guide::proto::StringValue* id);
  ::optimization_guide::proto::StringValue* unsafe_arena_release_id();

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.FeatureId)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::StringValue* id_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class InequalityTest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.InequalityTest) */ {
 public:
  inline InequalityTest() : InequalityTest(nullptr) {}
  ~InequalityTest() override;
  explicit PROTOBUF_CONSTEXPR InequalityTest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  InequalityTest(const InequalityTest& from);
  InequalityTest(InequalityTest&& from) noexcept
    : InequalityTest() {
    *this = ::std::move(from);
  }

  inline InequalityTest& operator=(const InequalityTest& from) {
    CopyFrom(from);
    return *this;
  }
  inline InequalityTest& operator=(InequalityTest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const InequalityTest& default_instance() {
    return *internal_default_instance();
  }
  static inline const InequalityTest* internal_default_instance() {
    return reinterpret_cast<const InequalityTest*>(
               &_InequalityTest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(InequalityTest& a, InequalityTest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(InequalityTest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(InequalityTest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  InequalityTest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<InequalityTest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const InequalityTest& from);
  void MergeFrom(const InequalityTest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(InequalityTest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.InequalityTest";
  }
  protected:
  explicit InequalityTest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef InequalityTest_Type Type;
  static constexpr Type LESS_OR_EQUAL =
    InequalityTest_Type_LESS_OR_EQUAL;
  static constexpr Type LESS_THAN =
    InequalityTest_Type_LESS_THAN;
  static constexpr Type GREATER_OR_EQUAL =
    InequalityTest_Type_GREATER_OR_EQUAL;
  static constexpr Type GREATER_THAN =
    InequalityTest_Type_GREATER_THAN;
  static inline bool Type_IsValid(int value) {
    return InequalityTest_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    InequalityTest_Type_Type_MIN;
  static constexpr Type Type_MAX =
    InequalityTest_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    InequalityTest_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return InequalityTest_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return InequalityTest_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureIdFieldNumber = 1,
    kThresholdFieldNumber = 3,
    kTypeFieldNumber = 2,
  };
  // optional .optimization_guide.proto.FeatureId feature_id = 1;
  bool has_feature_id() const;
  private:
  bool _internal_has_feature_id() const;
  public:
  void clear_feature_id();
  const ::optimization_guide::proto::FeatureId& feature_id() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::FeatureId* release_feature_id();
  ::optimization_guide::proto::FeatureId* mutable_feature_id();
  void set_allocated_feature_id(::optimization_guide::proto::FeatureId* feature_id);
  private:
  const ::optimization_guide::proto::FeatureId& _internal_feature_id() const;
  ::optimization_guide::proto::FeatureId* _internal_mutable_feature_id();
  public:
  void unsafe_arena_set_allocated_feature_id(
      ::optimization_guide::proto::FeatureId* feature_id);
  ::optimization_guide::proto::FeatureId* unsafe_arena_release_feature_id();

  // optional .optimization_guide.proto.Value threshold = 3;
  bool has_threshold() const;
  private:
  bool _internal_has_threshold() const;
  public:
  void clear_threshold();
  const ::optimization_guide::proto::Value& threshold() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Value* release_threshold();
  ::optimization_guide::proto::Value* mutable_threshold();
  void set_allocated_threshold(::optimization_guide::proto::Value* threshold);
  private:
  const ::optimization_guide::proto::Value& _internal_threshold() const;
  ::optimization_guide::proto::Value* _internal_mutable_threshold();
  public:
  void unsafe_arena_set_allocated_threshold(
      ::optimization_guide::proto::Value* threshold);
  ::optimization_guide::proto::Value* unsafe_arena_release_threshold();

  // optional .optimization_guide.proto.InequalityTest.Type type = 2;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::optimization_guide::proto::InequalityTest_Type type() const;
  void set_type(::optimization_guide::proto::InequalityTest_Type value);
  private:
  ::optimization_guide::proto::InequalityTest_Type _internal_type() const;
  void _internal_set_type(::optimization_guide::proto::InequalityTest_Type value);
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.InequalityTest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::FeatureId* feature_id_;
  ::optimization_guide::proto::Value* threshold_;
  int type_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Value final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Value) */ {
 public:
  inline Value() : Value(nullptr) {}
  ~Value() override;
  explicit PROTOBUF_CONSTEXPR Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Value(const Value& from);
  Value(Value&& from) noexcept
    : Value() {
    *this = ::std::move(from);
  }

  inline Value& operator=(const Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Value& operator=(Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Value& default_instance() {
    return *internal_default_instance();
  }
  enum ValueCase {
    kFloatValue = 1,
    kDoubleValue = 2,
    kInt32Value = 3,
    kInt64Value = 4,
    VALUE_NOT_SET = 0,
  };

  static inline const Value* internal_default_instance() {
    return reinterpret_cast<const Value*>(
               &_Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Value& a, Value& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Value>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Value& from);
  void MergeFrom(const Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Value";
  }
  protected:
  explicit Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFloatValueFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kInt32ValueFieldNumber = 3,
    kInt64ValueFieldNumber = 4,
  };
  // float float_value = 1;
  bool has_float_value() const;
  private:
  bool _internal_has_float_value() const;
  public:
  void clear_float_value();
  float float_value() const;
  void set_float_value(float value);
  private:
  float _internal_float_value() const;
  void _internal_set_float_value(float value);
  public:

  // double double_value = 2;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // int32 int32_value = 3;
  bool has_int32_value() const;
  private:
  bool _internal_has_int32_value() const;
  public:
  void clear_int32_value();
  int32_t int32_value() const;
  void set_int32_value(int32_t value);
  private:
  int32_t _internal_int32_value() const;
  void _internal_set_int32_value(int32_t value);
  public:

  // int64 int64_value = 4;
  bool has_int64_value() const;
  private:
  bool _internal_has_int64_value() const;
  public:
  void clear_int64_value();
  int64_t int64_value() const;
  void set_int64_value(int64_t value);
  private:
  int64_t _internal_int64_value() const;
  void _internal_set_int64_value(int64_t value);
  public:

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Value)
 private:
  class _Internal;
  void set_has_float_value();
  void set_has_double_value();
  void set_has_int32_value();
  void set_has_int64_value();

  inline bool has_value() const;
  inline void clear_has_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union ValueUnion {
    constexpr ValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    float float_value_;
    double double_value_;
    int32_t int32_value_;
    int64_t int64_value_;
  } value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class Int32Value final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.Int32Value) */ {
 public:
  inline Int32Value() : Int32Value(nullptr) {}
  ~Int32Value() override;
  explicit PROTOBUF_CONSTEXPR Int32Value(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Int32Value(const Int32Value& from);
  Int32Value(Int32Value&& from) noexcept
    : Int32Value() {
    *this = ::std::move(from);
  }

  inline Int32Value& operator=(const Int32Value& from) {
    CopyFrom(from);
    return *this;
  }
  inline Int32Value& operator=(Int32Value&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const Int32Value& default_instance() {
    return *internal_default_instance();
  }
  static inline const Int32Value* internal_default_instance() {
    return reinterpret_cast<const Int32Value*>(
               &_Int32Value_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Int32Value& a, Int32Value& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(Int32Value* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Int32Value* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Int32Value* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Int32Value>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const Int32Value& from);
  void MergeFrom(const Int32Value& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Int32Value* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.Int32Value";
  }
  protected:
  explicit Int32Value(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional int32 value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.Int32Value)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t value_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class DoubleValue final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.DoubleValue) */ {
 public:
  inline DoubleValue() : DoubleValue(nullptr) {}
  ~DoubleValue() override;
  explicit PROTOBUF_CONSTEXPR DoubleValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DoubleValue(const DoubleValue& from);
  DoubleValue(DoubleValue&& from) noexcept
    : DoubleValue() {
    *this = ::std::move(from);
  }

  inline DoubleValue& operator=(const DoubleValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline DoubleValue& operator=(DoubleValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const DoubleValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const DoubleValue* internal_default_instance() {
    return reinterpret_cast<const DoubleValue*>(
               &_DoubleValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DoubleValue& a, DoubleValue& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(DoubleValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DoubleValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DoubleValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DoubleValue>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DoubleValue& from);
  void MergeFrom(const DoubleValue& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DoubleValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.DoubleValue";
  }
  protected:
  explicit DoubleValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional double value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  double value() const;
  void set_value(double value);
  private:
  double _internal_value() const;
  void _internal_set_value(double value);
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.DoubleValue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  double value_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class GetModelsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.GetModelsRequest) */ {
 public:
  inline GetModelsRequest() : GetModelsRequest(nullptr) {}
  ~GetModelsRequest() override;
  explicit PROTOBUF_CONSTEXPR GetModelsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsRequest(const GetModelsRequest& from);
  GetModelsRequest(GetModelsRequest&& from) noexcept
    : GetModelsRequest() {
    *this = ::std::move(from);
  }

  inline GetModelsRequest& operator=(const GetModelsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsRequest& operator=(GetModelsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetModelsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsRequest* internal_default_instance() {
    return reinterpret_cast<const GetModelsRequest*>(
               &_GetModelsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetModelsRequest& a, GetModelsRequest& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetModelsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModelsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModelsRequest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetModelsRequest& from);
  void MergeFrom(const GetModelsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetModelsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.GetModelsRequest";
  }
  protected:
  explicit GetModelsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestedModelsFieldNumber = 1,
    kLocaleFieldNumber = 5,
    kRequestContextFieldNumber = 3,
  };
  // repeated .optimization_guide.proto.ModelInfo requested_models = 1;
  int requested_models_size() const;
  private:
  int _internal_requested_models_size() const;
  public:
  void clear_requested_models();
  ::optimization_guide::proto::ModelInfo* mutable_requested_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >*
      mutable_requested_models();
  private:
  const ::optimization_guide::proto::ModelInfo& _internal_requested_models(int index) const;
  ::optimization_guide::proto::ModelInfo* _internal_add_requested_models();
  public:
  const ::optimization_guide::proto::ModelInfo& requested_models(int index) const;
  ::optimization_guide::proto::ModelInfo* add_requested_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >&
      requested_models() const;

  // optional string locale = 5;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional .optimization_guide.proto.RequestContext request_context = 3;
  bool has_request_context() const;
  private:
  bool _internal_has_request_context() const;
  public:
  void clear_request_context();
  ::optimization_guide::proto::RequestContext request_context() const;
  void set_request_context(::optimization_guide::proto::RequestContext value);
  private:
  ::optimization_guide::proto::RequestContext _internal_request_context() const;
  void _internal_set_request_context(::optimization_guide::proto::RequestContext value);
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.GetModelsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo > requested_models_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  int request_context_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class GetModelsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.GetModelsResponse) */ {
 public:
  inline GetModelsResponse() : GetModelsResponse(nullptr) {}
  ~GetModelsResponse() override;
  explicit PROTOBUF_CONSTEXPR GetModelsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetModelsResponse(const GetModelsResponse& from);
  GetModelsResponse(GetModelsResponse&& from) noexcept
    : GetModelsResponse() {
    *this = ::std::move(from);
  }

  inline GetModelsResponse& operator=(const GetModelsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetModelsResponse& operator=(GetModelsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const GetModelsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetModelsResponse* internal_default_instance() {
    return reinterpret_cast<const GetModelsResponse*>(
               &_GetModelsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetModelsResponse& a, GetModelsResponse& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(GetModelsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetModelsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetModelsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetModelsResponse>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const GetModelsResponse& from);
  void MergeFrom(const GetModelsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(GetModelsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.GetModelsResponse";
  }
  protected:
  explicit GetModelsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelsFieldNumber = 1,
    kHostModelFeaturesFieldNumber = 2,
  };
  // repeated .optimization_guide.proto.PredictionModel models = 1;
  int models_size() const;
  private:
  int _internal_models_size() const;
  public:
  void clear_models();
  ::optimization_guide::proto::PredictionModel* mutable_models(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >*
      mutable_models();
  private:
  const ::optimization_guide::proto::PredictionModel& _internal_models(int index) const;
  ::optimization_guide::proto::PredictionModel* _internal_add_models();
  public:
  const ::optimization_guide::proto::PredictionModel& models(int index) const;
  ::optimization_guide::proto::PredictionModel* add_models();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >&
      models() const;

  // repeated .optimization_guide.proto.HostModelFeatures host_model_features = 2;
  int host_model_features_size() const;
  private:
  int _internal_host_model_features_size() const;
  public:
  void clear_host_model_features();
  ::optimization_guide::proto::HostModelFeatures* mutable_host_model_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >*
      mutable_host_model_features();
  private:
  const ::optimization_guide::proto::HostModelFeatures& _internal_host_model_features(int index) const;
  ::optimization_guide::proto::HostModelFeatures* _internal_add_host_model_features();
  public:
  const ::optimization_guide::proto::HostModelFeatures& host_model_features(int index) const;
  ::optimization_guide::proto::HostModelFeatures* add_host_model_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >&
      host_model_features() const;

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.GetModelsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel > models_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures > host_model_features_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class PredictionModel final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.PredictionModel) */ {
 public:
  inline PredictionModel() : PredictionModel(nullptr) {}
  ~PredictionModel() override;
  explicit PROTOBUF_CONSTEXPR PredictionModel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PredictionModel(const PredictionModel& from);
  PredictionModel(PredictionModel&& from) noexcept
    : PredictionModel() {
    *this = ::std::move(from);
  }

  inline PredictionModel& operator=(const PredictionModel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PredictionModel& operator=(PredictionModel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const PredictionModel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PredictionModel* internal_default_instance() {
    return reinterpret_cast<const PredictionModel*>(
               &_PredictionModel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PredictionModel& a, PredictionModel& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(PredictionModel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PredictionModel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PredictionModel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PredictionModel>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const PredictionModel& from);
  void MergeFrom(const PredictionModel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PredictionModel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.PredictionModel";
  }
  protected:
  explicit PredictionModel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelInfoFieldNumber = 1,
    kModelFieldNumber = 2,
  };
  // optional .optimization_guide.proto.ModelInfo model_info = 1;
  bool has_model_info() const;
  private:
  bool _internal_has_model_info() const;
  public:
  void clear_model_info();
  const ::optimization_guide::proto::ModelInfo& model_info() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::ModelInfo* release_model_info();
  ::optimization_guide::proto::ModelInfo* mutable_model_info();
  void set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info);
  private:
  const ::optimization_guide::proto::ModelInfo& _internal_model_info() const;
  ::optimization_guide::proto::ModelInfo* _internal_mutable_model_info();
  public:
  void unsafe_arena_set_allocated_model_info(
      ::optimization_guide::proto::ModelInfo* model_info);
  ::optimization_guide::proto::ModelInfo* unsafe_arena_release_model_info();

  // optional .optimization_guide.proto.Model model = 2;
  bool has_model() const;
  private:
  bool _internal_has_model() const;
  public:
  void clear_model();
  const ::optimization_guide::proto::Model& model() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Model* release_model();
  ::optimization_guide::proto::Model* mutable_model();
  void set_allocated_model(::optimization_guide::proto::Model* model);
  private:
  const ::optimization_guide::proto::Model& _internal_model() const;
  ::optimization_guide::proto::Model* _internal_mutable_model();
  public:
  void unsafe_arena_set_allocated_model(
      ::optimization_guide::proto::Model* model);
  ::optimization_guide::proto::Model* unsafe_arena_release_model();

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.PredictionModel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::optimization_guide::proto::ModelInfo* model_info_;
  ::optimization_guide::proto::Model* model_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class AdditionalModelFile final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.AdditionalModelFile) */ {
 public:
  inline AdditionalModelFile() : AdditionalModelFile(nullptr) {}
  ~AdditionalModelFile() override;
  explicit PROTOBUF_CONSTEXPR AdditionalModelFile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AdditionalModelFile(const AdditionalModelFile& from);
  AdditionalModelFile(AdditionalModelFile&& from) noexcept
    : AdditionalModelFile() {
    *this = ::std::move(from);
  }

  inline AdditionalModelFile& operator=(const AdditionalModelFile& from) {
    CopyFrom(from);
    return *this;
  }
  inline AdditionalModelFile& operator=(AdditionalModelFile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const AdditionalModelFile& default_instance() {
    return *internal_default_instance();
  }
  static inline const AdditionalModelFile* internal_default_instance() {
    return reinterpret_cast<const AdditionalModelFile*>(
               &_AdditionalModelFile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(AdditionalModelFile& a, AdditionalModelFile& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(AdditionalModelFile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AdditionalModelFile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AdditionalModelFile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AdditionalModelFile>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const AdditionalModelFile& from);
  void MergeFrom(const AdditionalModelFile& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AdditionalModelFile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.AdditionalModelFile";
  }
  protected:
  explicit AdditionalModelFile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
  };
  // optional string file_path = 1;
  bool has_file_path() const;
  private:
  bool _internal_has_file_path() const;
  public:
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.AdditionalModelFile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class ModelInfo final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ModelInfo) */ {
 public:
  inline ModelInfo() : ModelInfo(nullptr) {}
  ~ModelInfo() override;
  explicit PROTOBUF_CONSTEXPR ModelInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelInfo(const ModelInfo& from);
  ModelInfo(ModelInfo&& from) noexcept
    : ModelInfo() {
    *this = ::std::move(from);
  }

  inline ModelInfo& operator=(const ModelInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelInfo& operator=(ModelInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ModelInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const ModelInfo* internal_default_instance() {
    return reinterpret_cast<const ModelInfo*>(
               &_ModelInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(ModelInfo& a, ModelInfo& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ModelInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelInfo>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelInfo& from);
  void MergeFrom(const ModelInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.ModelInfo";
  }
  protected:
  explicit ModelInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedModelEngineVersionsFieldNumber = 4,
    kSupportedHostModelFeaturesFieldNumber = 5,
    kAdditionalFilesFieldNumber = 7,
    kModelMetadataFieldNumber = 6,
    kValidDurationFieldNumber = 8,
    kVersionFieldNumber = 2,
    kOptimizationTargetFieldNumber = 1,
    kKeepBeyondValidDurationFieldNumber = 9,
  };
  // repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
  int supported_model_engine_versions_size() const;
  private:
  int _internal_supported_model_engine_versions_size() const;
  public:
  void clear_supported_model_engine_versions();
  private:
  ::optimization_guide::proto::ModelEngineVersion _internal_supported_model_engine_versions(int index) const;
  void _internal_add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_model_engine_versions();
  public:
  ::optimization_guide::proto::ModelEngineVersion supported_model_engine_versions(int index) const;
  void set_supported_model_engine_versions(int index, ::optimization_guide::proto::ModelEngineVersion value);
  void add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_model_engine_versions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_model_engine_versions();

  // repeated string supported_host_model_features = 5;
  int supported_host_model_features_size() const;
  private:
  int _internal_supported_host_model_features_size() const;
  public:
  void clear_supported_host_model_features();
  const std::string& supported_host_model_features(int index) const;
  std::string* mutable_supported_host_model_features(int index);
  void set_supported_host_model_features(int index, const std::string& value);
  void set_supported_host_model_features(int index, std::string&& value);
  void set_supported_host_model_features(int index, const char* value);
  void set_supported_host_model_features(int index, const char* value, size_t size);
  std::string* add_supported_host_model_features();
  void add_supported_host_model_features(const std::string& value);
  void add_supported_host_model_features(std::string&& value);
  void add_supported_host_model_features(const char* value);
  void add_supported_host_model_features(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& supported_host_model_features() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_supported_host_model_features();
  private:
  const std::string& _internal_supported_host_model_features(int index) const;
  std::string* _internal_add_supported_host_model_features();
  public:

  // repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
  int additional_files_size() const;
  private:
  int _internal_additional_files_size() const;
  public:
  void clear_additional_files();
  ::optimization_guide::proto::AdditionalModelFile* mutable_additional_files(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::AdditionalModelFile >*
      mutable_additional_files();
  private:
  const ::optimization_guide::proto::AdditionalModelFile& _internal_additional_files(int index) const;
  ::optimization_guide::proto::AdditionalModelFile* _internal_add_additional_files();
  public:
  const ::optimization_guide::proto::AdditionalModelFile& additional_files(int index) const;
  ::optimization_guide::proto::AdditionalModelFile* add_additional_files();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::AdditionalModelFile >&
      additional_files() const;

  // optional .optimization_guide.proto.Any model_metadata = 6;
  bool has_model_metadata() const;
  private:
  bool _internal_has_model_metadata() const;
  public:
  void clear_model_metadata();
  const ::optimization_guide::proto::Any& model_metadata() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Any* release_model_metadata();
  ::optimization_guide::proto::Any* mutable_model_metadata();
  void set_allocated_model_metadata(::optimization_guide::proto::Any* model_metadata);
  private:
  const ::optimization_guide::proto::Any& _internal_model_metadata() const;
  ::optimization_guide::proto::Any* _internal_mutable_model_metadata();
  public:
  void unsafe_arena_set_allocated_model_metadata(
      ::optimization_guide::proto::Any* model_metadata);
  ::optimization_guide::proto::Any* unsafe_arena_release_model_metadata();

  // optional .optimization_guide.proto.Duration valid_duration = 8;
  bool has_valid_duration() const;
  private:
  bool _internal_has_valid_duration() const;
  public:
  void clear_valid_duration();
  const ::optimization_guide::proto::Duration& valid_duration() const;
  PROTOBUF_NODISCARD ::optimization_guide::proto::Duration* release_valid_duration();
  ::optimization_guide::proto::Duration* mutable_valid_duration();
  void set_allocated_valid_duration(::optimization_guide::proto::Duration* valid_duration);
  private:
  const ::optimization_guide::proto::Duration& _internal_valid_duration() const;
  ::optimization_guide::proto::Duration* _internal_mutable_valid_duration();
  public:
  void unsafe_arena_set_allocated_valid_duration(
      ::optimization_guide::proto::Duration* valid_duration);
  ::optimization_guide::proto::Duration* unsafe_arena_release_valid_duration();

  // optional int64 version = 2;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int64_t version() const;
  void set_version(int64_t value);
  private:
  int64_t _internal_version() const;
  void _internal_set_version(int64_t value);
  public:

  // optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
  bool has_optimization_target() const;
  private:
  bool _internal_has_optimization_target() const;
  public:
  void clear_optimization_target();
  ::optimization_guide::proto::OptimizationTarget optimization_target() const;
  void set_optimization_target(::optimization_guide::proto::OptimizationTarget value);
  private:
  ::optimization_guide::proto::OptimizationTarget _internal_optimization_target() const;
  void _internal_set_optimization_target(::optimization_guide::proto::OptimizationTarget value);
  public:

  // optional bool keep_beyond_valid_duration = 9;
  bool has_keep_beyond_valid_duration() const;
  private:
  bool _internal_has_keep_beyond_valid_duration() const;
  public:
  void clear_keep_beyond_valid_duration();
  bool keep_beyond_valid_duration() const;
  void set_keep_beyond_valid_duration(bool value);
  private:
  bool _internal_keep_beyond_valid_duration() const;
  void _internal_set_keep_beyond_valid_duration(bool value);
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.ModelInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_model_engine_versions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> supported_host_model_features_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::AdditionalModelFile > additional_files_;
  ::optimization_guide::proto::Any* model_metadata_;
  ::optimization_guide::proto::Duration* valid_duration_;
  int64_t version_;
  int optimization_target_;
  bool keep_beyond_valid_duration_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class HostModelFeatures final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.HostModelFeatures) */ {
 public:
  inline HostModelFeatures() : HostModelFeatures(nullptr) {}
  ~HostModelFeatures() override;
  explicit PROTOBUF_CONSTEXPR HostModelFeatures(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HostModelFeatures(const HostModelFeatures& from);
  HostModelFeatures(HostModelFeatures&& from) noexcept
    : HostModelFeatures() {
    *this = ::std::move(from);
  }

  inline HostModelFeatures& operator=(const HostModelFeatures& from) {
    CopyFrom(from);
    return *this;
  }
  inline HostModelFeatures& operator=(HostModelFeatures&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const HostModelFeatures& default_instance() {
    return *internal_default_instance();
  }
  static inline const HostModelFeatures* internal_default_instance() {
    return reinterpret_cast<const HostModelFeatures*>(
               &_HostModelFeatures_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(HostModelFeatures& a, HostModelFeatures& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(HostModelFeatures* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HostModelFeatures* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HostModelFeatures* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HostModelFeatures>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const HostModelFeatures& from);
  void MergeFrom(const HostModelFeatures& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HostModelFeatures* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.HostModelFeatures";
  }
  protected:
  explicit HostModelFeatures(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModelFeaturesFieldNumber = 2,
    kHostFieldNumber = 1,
  };
  // repeated .optimization_guide.proto.ModelFeature model_features = 2;
  int model_features_size() const;
  private:
  int _internal_model_features_size() const;
  public:
  void clear_model_features();
  ::optimization_guide::proto::ModelFeature* mutable_model_features(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >*
      mutable_model_features();
  private:
  const ::optimization_guide::proto::ModelFeature& _internal_model_features(int index) const;
  ::optimization_guide::proto::ModelFeature* _internal_add_model_features();
  public:
  const ::optimization_guide::proto::ModelFeature& model_features(int index) const;
  ::optimization_guide::proto::ModelFeature* add_model_features();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >&
      model_features() const;

  // optional string host = 1;
  bool has_host() const;
  private:
  bool _internal_has_host() const;
  public:
  void clear_host();
  const std::string& host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_host();
  PROTOBUF_NODISCARD std::string* release_host();
  void set_allocated_host(std::string* host);
  private:
  const std::string& _internal_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_host(const std::string& value);
  std::string* _internal_mutable_host();
  public:

  // @@protoc_insertion_point(class_scope:optimization_guide.proto.HostModelFeatures)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature > model_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr host_;
  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// -------------------------------------------------------------------

class ModelFeature final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:optimization_guide.proto.ModelFeature) */ {
 public:
  inline ModelFeature() : ModelFeature(nullptr) {}
  ~ModelFeature() override;
  explicit PROTOBUF_CONSTEXPR ModelFeature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ModelFeature(const ModelFeature& from);
  ModelFeature(ModelFeature&& from) noexcept
    : ModelFeature() {
    *this = ::std::move(from);
  }

  inline ModelFeature& operator=(const ModelFeature& from) {
    CopyFrom(from);
    return *this;
  }
  inline ModelFeature& operator=(ModelFeature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const std::string& unknown_fields() const {
    return _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString);
  }
  inline std::string* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<std::string>();
  }

  static const ModelFeature& default_instance() {
    return *internal_default_instance();
  }
  enum FeatureValueCase {
    kDoubleValue = 2,
    kInt64Value = 3,
    FEATURE_VALUE_NOT_SET = 0,
  };

  static inline const ModelFeature* internal_default_instance() {
    return reinterpret_cast<const ModelFeature*>(
               &_ModelFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ModelFeature& a, ModelFeature& b) {
    a.Swap(&b);
  }
  PROTOBUF_NOINLINE void Swap(ModelFeature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ModelFeature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ModelFeature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ModelFeature>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ModelFeature& from);
  void MergeFrom(const ModelFeature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ModelFeature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "optimization_guide.proto.ModelFeature";
  }
  protected:
  explicit ModelFeature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFeatureNameFieldNumber = 1,
    kDoubleValueFieldNumber = 2,
    kInt64ValueFieldNumber = 3,
  };
  // optional string feature_name = 1;
  bool has_feature_name() const;
  private:
  bool _internal_has_feature_name() const;
  public:
  void clear_feature_name();
  const std::string& feature_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_feature_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_feature_name();
  PROTOBUF_NODISCARD std::string* release_feature_name();
  void set_allocated_feature_name(std::string* feature_name);
  private:
  const std::string& _internal_feature_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_feature_name(const std::string& value);
  std::string* _internal_mutable_feature_name();
  public:

  // double double_value = 2;
  bool has_double_value() const;
  private:
  bool _internal_has_double_value() const;
  public:
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // int64 int64_value = 3;
  bool has_int64_value() const;
  private:
  bool _internal_has_int64_value() const;
  public:
  void clear_int64_value();
  int64_t int64_value() const;
  void set_int64_value(int64_t value);
  private:
  int64_t _internal_int64_value() const;
  void _internal_set_int64_value(int64_t value);
  public:

  void clear_feature_value();
  FeatureValueCase feature_value_case() const;
  // @@protoc_insertion_point(class_scope:optimization_guide.proto.ModelFeature)
 private:
  class _Internal;
  void set_has_double_value();
  void set_has_int64_value();

  inline bool has_feature_value() const;
  inline void clear_has_feature_value();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr feature_name_;
  union FeatureValueUnion {
    constexpr FeatureValueUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    double double_value_;
    int64_t int64_value_;
  } feature_value_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_components_2foptimization_5fguide_2fproto_2fmodels_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Model

// .optimization_guide.proto.DecisionTree decision_tree = 1;
inline bool Model::_internal_has_decision_tree() const {
  return model_case() == kDecisionTree;
}
inline bool Model::has_decision_tree() const {
  return _internal_has_decision_tree();
}
inline void Model::set_has_decision_tree() {
  _oneof_case_[0] = kDecisionTree;
}
inline void Model::clear_decision_tree() {
  if (_internal_has_decision_tree()) {
    if (GetArenaForAllocation() == nullptr) {
      delete model_.decision_tree_;
    }
    clear_has_model();
  }
}
inline ::optimization_guide::proto::DecisionTree* Model::release_decision_tree() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.decision_tree)
  if (_internal_has_decision_tree()) {
    clear_has_model();
    ::optimization_guide::proto::DecisionTree* temp = model_.decision_tree_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.decision_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::DecisionTree& Model::_internal_decision_tree() const {
  return _internal_has_decision_tree()
      ? *model_.decision_tree_
      : reinterpret_cast< ::optimization_guide::proto::DecisionTree&>(::optimization_guide::proto::_DecisionTree_default_instance_);
}
inline const ::optimization_guide::proto::DecisionTree& Model::decision_tree() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.decision_tree)
  return _internal_decision_tree();
}
inline ::optimization_guide::proto::DecisionTree* Model::unsafe_arena_release_decision_tree() {
  // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.Model.decision_tree)
  if (_internal_has_decision_tree()) {
    clear_has_model();
    ::optimization_guide::proto::DecisionTree* temp = model_.decision_tree_;
    model_.decision_tree_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_decision_tree(::optimization_guide::proto::DecisionTree* decision_tree) {
  clear_model();
  if (decision_tree) {
    set_has_decision_tree();
    model_.decision_tree_ = decision_tree;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Model.decision_tree)
}
inline ::optimization_guide::proto::DecisionTree* Model::_internal_mutable_decision_tree() {
  if (!_internal_has_decision_tree()) {
    clear_model();
    set_has_decision_tree();
    model_.decision_tree_ = CreateMaybeMessage< ::optimization_guide::proto::DecisionTree >(GetArenaForAllocation());
  }
  return model_.decision_tree_;
}
inline ::optimization_guide::proto::DecisionTree* Model::mutable_decision_tree() {
  ::optimization_guide::proto::DecisionTree* _msg = _internal_mutable_decision_tree();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.decision_tree)
  return _msg;
}

// .optimization_guide.proto.Ensemble ensemble = 2;
inline bool Model::_internal_has_ensemble() const {
  return model_case() == kEnsemble;
}
inline bool Model::has_ensemble() const {
  return _internal_has_ensemble();
}
inline void Model::set_has_ensemble() {
  _oneof_case_[0] = kEnsemble;
}
inline void Model::clear_ensemble() {
  if (_internal_has_ensemble()) {
    if (GetArenaForAllocation() == nullptr) {
      delete model_.ensemble_;
    }
    clear_has_model();
  }
}
inline ::optimization_guide::proto::Ensemble* Model::release_ensemble() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.ensemble)
  if (_internal_has_ensemble()) {
    clear_has_model();
    ::optimization_guide::proto::Ensemble* temp = model_.ensemble_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    model_.ensemble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::Ensemble& Model::_internal_ensemble() const {
  return _internal_has_ensemble()
      ? *model_.ensemble_
      : reinterpret_cast< ::optimization_guide::proto::Ensemble&>(::optimization_guide::proto::_Ensemble_default_instance_);
}
inline const ::optimization_guide::proto::Ensemble& Model::ensemble() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.ensemble)
  return _internal_ensemble();
}
inline ::optimization_guide::proto::Ensemble* Model::unsafe_arena_release_ensemble() {
  // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.Model.ensemble)
  if (_internal_has_ensemble()) {
    clear_has_model();
    ::optimization_guide::proto::Ensemble* temp = model_.ensemble_;
    model_.ensemble_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Model::unsafe_arena_set_allocated_ensemble(::optimization_guide::proto::Ensemble* ensemble) {
  clear_model();
  if (ensemble) {
    set_has_ensemble();
    model_.ensemble_ = ensemble;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Model.ensemble)
}
inline ::optimization_guide::proto::Ensemble* Model::_internal_mutable_ensemble() {
  if (!_internal_has_ensemble()) {
    clear_model();
    set_has_ensemble();
    model_.ensemble_ = CreateMaybeMessage< ::optimization_guide::proto::Ensemble >(GetArenaForAllocation());
  }
  return model_.ensemble_;
}
inline ::optimization_guide::proto::Ensemble* Model::mutable_ensemble() {
  ::optimization_guide::proto::Ensemble* _msg = _internal_mutable_ensemble();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.ensemble)
  return _msg;
}

// string download_url = 5;
inline bool Model::_internal_has_download_url() const {
  return model_case() == kDownloadUrl;
}
inline bool Model::has_download_url() const {
  return _internal_has_download_url();
}
inline void Model::set_has_download_url() {
  _oneof_case_[0] = kDownloadUrl;
}
inline void Model::clear_download_url() {
  if (_internal_has_download_url()) {
    model_.download_url_.Destroy();
    clear_has_model();
  }
}
inline const std::string& Model::download_url() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.download_url)
  return _internal_download_url();
}
template <typename ArgT0, typename... ArgT>
inline void Model::set_download_url(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_download_url()) {
    clear_model();
    set_has_download_url();
    model_.download_url_.InitDefault();
  }
  model_.download_url_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Model.download_url)
}
inline std::string* Model::mutable_download_url() {
  std::string* _s = _internal_mutable_download_url();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.download_url)
  return _s;
}
inline const std::string& Model::_internal_download_url() const {
  if (_internal_has_download_url()) {
    return model_.download_url_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void Model::_internal_set_download_url(const std::string& value) {
  if (!_internal_has_download_url()) {
    clear_model();
    set_has_download_url();
    model_.download_url_.InitDefault();
  }
  model_.download_url_.Set(value, GetArenaForAllocation());
}
inline std::string* Model::_internal_mutable_download_url() {
  if (!_internal_has_download_url()) {
    clear_model();
    set_has_download_url();
    model_.download_url_.InitDefault();
  }
  return model_.download_url_.Mutable(      GetArenaForAllocation());
}
inline std::string* Model::release_download_url() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.download_url)
  if (_internal_has_download_url()) {
    clear_has_model();
    return model_.download_url_.Release();
  } else {
    return nullptr;
  }
}
inline void Model::set_allocated_download_url(std::string* download_url) {
  if (has_model()) {
    clear_model();
  }
  if (download_url != nullptr) {
    set_has_download_url();
    model_.download_url_.InitAllocated(download_url, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Model.download_url)
}

// optional .optimization_guide.proto.DoubleValue threshold = 123;
inline bool Model::_internal_has_threshold() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || threshold_ != nullptr);
  return value;
}
inline bool Model::has_threshold() const {
  return _internal_has_threshold();
}
inline void Model::clear_threshold() {
  if (threshold_ != nullptr) threshold_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::DoubleValue& Model::_internal_threshold() const {
  const ::optimization_guide::proto::DoubleValue* p = threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::DoubleValue&>(
      ::optimization_guide::proto::_DoubleValue_default_instance_);
}
inline const ::optimization_guide::proto::DoubleValue& Model::threshold() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Model.threshold)
  return _internal_threshold();
}
inline void Model::unsafe_arena_set_allocated_threshold(
    ::optimization_guide::proto::DoubleValue* threshold) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threshold_);
  }
  threshold_ = threshold;
  if (threshold) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Model.threshold)
}
inline ::optimization_guide::proto::DoubleValue* Model::release_threshold() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::DoubleValue* temp = threshold_;
  threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::DoubleValue* Model::unsafe_arena_release_threshold() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Model.threshold)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::DoubleValue* temp = threshold_;
  threshold_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::DoubleValue* Model::_internal_mutable_threshold() {
  _has_bits_[0] |= 0x00000001u;
  if (threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::DoubleValue>(GetArenaForAllocation());
    threshold_ = p;
  }
  return threshold_;
}
inline ::optimization_guide::proto::DoubleValue* Model::mutable_threshold() {
  ::optimization_guide::proto::DoubleValue* _msg = _internal_mutable_threshold();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Model.threshold)
  return _msg;
}
inline void Model::set_allocated_threshold(::optimization_guide::proto::DoubleValue* threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete threshold_;
  }
  if (threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(threshold);
    if (message_arena != submessage_arena) {
      threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Model.threshold)
}

inline bool Model::has_model() const {
  return model_case() != MODEL_NOT_SET;
}
inline void Model::clear_has_model() {
  _oneof_case_[0] = MODEL_NOT_SET;
}
inline Model::ModelCase Model::model_case() const {
  return Model::ModelCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Ensemble_Member

// optional .optimization_guide.proto.Model submodel = 1;
inline bool Ensemble_Member::_internal_has_submodel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || submodel_ != nullptr);
  return value;
}
inline bool Ensemble_Member::has_submodel() const {
  return _internal_has_submodel();
}
inline void Ensemble_Member::clear_submodel() {
  if (submodel_ != nullptr) submodel_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Model& Ensemble_Member::_internal_submodel() const {
  const ::optimization_guide::proto::Model* p = submodel_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Model&>(
      ::optimization_guide::proto::_Model_default_instance_);
}
inline const ::optimization_guide::proto::Model& Ensemble_Member::submodel() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Ensemble.Member.submodel)
  return _internal_submodel();
}
inline void Ensemble_Member::unsafe_arena_set_allocated_submodel(
    ::optimization_guide::proto::Model* submodel) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(submodel_);
  }
  submodel_ = submodel;
  if (submodel) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Ensemble.Member.submodel)
}
inline ::optimization_guide::proto::Model* Ensemble_Member::release_submodel() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Model* temp = submodel_;
  submodel_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Model* Ensemble_Member::unsafe_arena_release_submodel() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Ensemble.Member.submodel)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Model* temp = submodel_;
  submodel_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Model* Ensemble_Member::_internal_mutable_submodel() {
  _has_bits_[0] |= 0x00000001u;
  if (submodel_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Model>(GetArenaForAllocation());
    submodel_ = p;
  }
  return submodel_;
}
inline ::optimization_guide::proto::Model* Ensemble_Member::mutable_submodel() {
  ::optimization_guide::proto::Model* _msg = _internal_mutable_submodel();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Ensemble.Member.submodel)
  return _msg;
}
inline void Ensemble_Member::set_allocated_submodel(::optimization_guide::proto::Model* submodel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete submodel_;
  }
  if (submodel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(submodel);
    if (message_arena != submessage_arena) {
      submodel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, submodel, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  submodel_ = submodel;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Ensemble.Member.submodel)
}

// -------------------------------------------------------------------

// Ensemble

// repeated .optimization_guide.proto.Ensemble.Member members = 100;
inline int Ensemble::_internal_members_size() const {
  return members_.size();
}
inline int Ensemble::members_size() const {
  return _internal_members_size();
}
inline void Ensemble::clear_members() {
  members_.Clear();
}
inline ::optimization_guide::proto::Ensemble_Member* Ensemble::mutable_members(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Ensemble.members)
  return members_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >*
Ensemble::mutable_members() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.Ensemble.members)
  return &members_;
}
inline const ::optimization_guide::proto::Ensemble_Member& Ensemble::_internal_members(int index) const {
  return members_.Get(index);
}
inline const ::optimization_guide::proto::Ensemble_Member& Ensemble::members(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Ensemble.members)
  return _internal_members(index);
}
inline ::optimization_guide::proto::Ensemble_Member* Ensemble::_internal_add_members() {
  return members_.Add();
}
inline ::optimization_guide::proto::Ensemble_Member* Ensemble::add_members() {
  ::optimization_guide::proto::Ensemble_Member* _add = _internal_add_members();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.Ensemble.members)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Ensemble_Member >&
Ensemble::members() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.Ensemble.members)
  return members_;
}

// -------------------------------------------------------------------

// DecisionTree

// repeated .optimization_guide.proto.TreeNode nodes = 1;
inline int DecisionTree::_internal_nodes_size() const {
  return nodes_.size();
}
inline int DecisionTree::nodes_size() const {
  return _internal_nodes_size();
}
inline void DecisionTree::clear_nodes() {
  nodes_.Clear();
}
inline ::optimization_guide::proto::TreeNode* DecisionTree::mutable_nodes(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.DecisionTree.nodes)
  return nodes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >*
DecisionTree::mutable_nodes() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.DecisionTree.nodes)
  return &nodes_;
}
inline const ::optimization_guide::proto::TreeNode& DecisionTree::_internal_nodes(int index) const {
  return nodes_.Get(index);
}
inline const ::optimization_guide::proto::TreeNode& DecisionTree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.DecisionTree.nodes)
  return _internal_nodes(index);
}
inline ::optimization_guide::proto::TreeNode* DecisionTree::_internal_add_nodes() {
  return nodes_.Add();
}
inline ::optimization_guide::proto::TreeNode* DecisionTree::add_nodes() {
  ::optimization_guide::proto::TreeNode* _add = _internal_add_nodes();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.DecisionTree.nodes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::TreeNode >&
DecisionTree::nodes() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.DecisionTree.nodes)
  return nodes_;
}

// optional float weight = 3;
inline bool DecisionTree::_internal_has_weight() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DecisionTree::has_weight() const {
  return _internal_has_weight();
}
inline void DecisionTree::clear_weight() {
  weight_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float DecisionTree::_internal_weight() const {
  return weight_;
}
inline float DecisionTree::weight() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.DecisionTree.weight)
  return _internal_weight();
}
inline void DecisionTree::_internal_set_weight(float value) {
  _has_bits_[0] |= 0x00000001u;
  weight_ = value;
}
inline void DecisionTree::set_weight(float value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.DecisionTree.weight)
}

// -------------------------------------------------------------------

// TreeNode

// optional .optimization_guide.proto.Int32Value node_id = 1;
inline bool TreeNode::_internal_has_node_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || node_id_ != nullptr);
  return value;
}
inline bool TreeNode::has_node_id() const {
  return _internal_has_node_id();
}
inline void TreeNode::clear_node_id() {
  if (node_id_ != nullptr) node_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::_internal_node_id() const {
  const ::optimization_guide::proto::Int32Value* p = node_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Int32Value&>(
      ::optimization_guide::proto::_Int32Value_default_instance_);
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::node_id() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.node_id)
  return _internal_node_id();
}
inline void TreeNode::unsafe_arena_set_allocated_node_id(
    ::optimization_guide::proto::Int32Value* node_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_id_);
  }
  node_id_ = node_id;
  if (node_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.TreeNode.node_id)
}
inline ::optimization_guide::proto::Int32Value* TreeNode::release_node_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Int32Value* temp = node_id_;
  node_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.node_id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Int32Value* temp = node_id_;
  node_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::_internal_mutable_node_id() {
  _has_bits_[0] |= 0x00000001u;
  if (node_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaForAllocation());
    node_id_ = p;
  }
  return node_id_;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::mutable_node_id() {
  ::optimization_guide::proto::Int32Value* _msg = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.node_id)
  return _msg;
}
inline void TreeNode::set_allocated_node_id(::optimization_guide::proto::Int32Value* node_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_id_;
  }
  if (node_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node_id);
    if (message_arena != submessage_arena) {
      node_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  node_id_ = node_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TreeNode.node_id)
}

// optional .optimization_guide.proto.Int32Value depth = 2;
inline bool TreeNode::_internal_has_depth() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || depth_ != nullptr);
  return value;
}
inline bool TreeNode::has_depth() const {
  return _internal_has_depth();
}
inline void TreeNode::clear_depth() {
  if (depth_ != nullptr) depth_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::_internal_depth() const {
  const ::optimization_guide::proto::Int32Value* p = depth_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Int32Value&>(
      ::optimization_guide::proto::_Int32Value_default_instance_);
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::depth() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.depth)
  return _internal_depth();
}
inline void TreeNode::unsafe_arena_set_allocated_depth(
    ::optimization_guide::proto::Int32Value* depth) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(depth_);
  }
  depth_ = depth;
  if (depth) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.TreeNode.depth)
}
inline ::optimization_guide::proto::Int32Value* TreeNode::release_depth() {
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Int32Value* temp = depth_;
  depth_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::unsafe_arena_release_depth() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.depth)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Int32Value* temp = depth_;
  depth_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::_internal_mutable_depth() {
  _has_bits_[0] |= 0x00000002u;
  if (depth_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaForAllocation());
    depth_ = p;
  }
  return depth_;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::mutable_depth() {
  ::optimization_guide::proto::Int32Value* _msg = _internal_mutable_depth();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.depth)
  return _msg;
}
inline void TreeNode::set_allocated_depth(::optimization_guide::proto::Int32Value* depth) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete depth_;
  }
  if (depth) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(depth);
    if (message_arena != submessage_arena) {
      depth = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, depth, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  depth_ = depth;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TreeNode.depth)
}

// optional .optimization_guide.proto.Int32Value subtree_size = 3;
inline bool TreeNode::_internal_has_subtree_size() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || subtree_size_ != nullptr);
  return value;
}
inline bool TreeNode::has_subtree_size() const {
  return _internal_has_subtree_size();
}
inline void TreeNode::clear_subtree_size() {
  if (subtree_size_ != nullptr) subtree_size_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::_internal_subtree_size() const {
  const ::optimization_guide::proto::Int32Value* p = subtree_size_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Int32Value&>(
      ::optimization_guide::proto::_Int32Value_default_instance_);
}
inline const ::optimization_guide::proto::Int32Value& TreeNode::subtree_size() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.subtree_size)
  return _internal_subtree_size();
}
inline void TreeNode::unsafe_arena_set_allocated_subtree_size(
    ::optimization_guide::proto::Int32Value* subtree_size) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(subtree_size_);
  }
  subtree_size_ = subtree_size;
  if (subtree_size) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.TreeNode.subtree_size)
}
inline ::optimization_guide::proto::Int32Value* TreeNode::release_subtree_size() {
  _has_bits_[0] &= ~0x00000004u;
  ::optimization_guide::proto::Int32Value* temp = subtree_size_;
  subtree_size_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::unsafe_arena_release_subtree_size() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.subtree_size)
  _has_bits_[0] &= ~0x00000004u;
  ::optimization_guide::proto::Int32Value* temp = subtree_size_;
  subtree_size_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::_internal_mutable_subtree_size() {
  _has_bits_[0] |= 0x00000004u;
  if (subtree_size_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaForAllocation());
    subtree_size_ = p;
  }
  return subtree_size_;
}
inline ::optimization_guide::proto::Int32Value* TreeNode::mutable_subtree_size() {
  ::optimization_guide::proto::Int32Value* _msg = _internal_mutable_subtree_size();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.subtree_size)
  return _msg;
}
inline void TreeNode::set_allocated_subtree_size(::optimization_guide::proto::Int32Value* subtree_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete subtree_size_;
  }
  if (subtree_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(subtree_size);
    if (message_arena != submessage_arena) {
      subtree_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, subtree_size, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  subtree_size_ = subtree_size;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.TreeNode.subtree_size)
}

// .optimization_guide.proto.BinaryNode binary_node = 4;
inline bool TreeNode::_internal_has_binary_node() const {
  return node_type_case() == kBinaryNode;
}
inline bool TreeNode::has_binary_node() const {
  return _internal_has_binary_node();
}
inline void TreeNode::set_has_binary_node() {
  _oneof_case_[0] = kBinaryNode;
}
inline void TreeNode::clear_binary_node() {
  if (_internal_has_binary_node()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_type_.binary_node_;
    }
    clear_has_node_type();
  }
}
inline ::optimization_guide::proto::BinaryNode* TreeNode::release_binary_node() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.binary_node)
  if (_internal_has_binary_node()) {
    clear_has_node_type();
    ::optimization_guide::proto::BinaryNode* temp = node_type_.binary_node_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.binary_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::BinaryNode& TreeNode::_internal_binary_node() const {
  return _internal_has_binary_node()
      ? *node_type_.binary_node_
      : reinterpret_cast< ::optimization_guide::proto::BinaryNode&>(::optimization_guide::proto::_BinaryNode_default_instance_);
}
inline const ::optimization_guide::proto::BinaryNode& TreeNode::binary_node() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.binary_node)
  return _internal_binary_node();
}
inline ::optimization_guide::proto::BinaryNode* TreeNode::unsafe_arena_release_binary_node() {
  // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.TreeNode.binary_node)
  if (_internal_has_binary_node()) {
    clear_has_node_type();
    ::optimization_guide::proto::BinaryNode* temp = node_type_.binary_node_;
    node_type_.binary_node_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_binary_node(::optimization_guide::proto::BinaryNode* binary_node) {
  clear_node_type();
  if (binary_node) {
    set_has_binary_node();
    node_type_.binary_node_ = binary_node;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.TreeNode.binary_node)
}
inline ::optimization_guide::proto::BinaryNode* TreeNode::_internal_mutable_binary_node() {
  if (!_internal_has_binary_node()) {
    clear_node_type();
    set_has_binary_node();
    node_type_.binary_node_ = CreateMaybeMessage< ::optimization_guide::proto::BinaryNode >(GetArenaForAllocation());
  }
  return node_type_.binary_node_;
}
inline ::optimization_guide::proto::BinaryNode* TreeNode::mutable_binary_node() {
  ::optimization_guide::proto::BinaryNode* _msg = _internal_mutable_binary_node();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.binary_node)
  return _msg;
}

// .optimization_guide.proto.Leaf leaf = 5;
inline bool TreeNode::_internal_has_leaf() const {
  return node_type_case() == kLeaf;
}
inline bool TreeNode::has_leaf() const {
  return _internal_has_leaf();
}
inline void TreeNode::set_has_leaf() {
  _oneof_case_[0] = kLeaf;
}
inline void TreeNode::clear_leaf() {
  if (_internal_has_leaf()) {
    if (GetArenaForAllocation() == nullptr) {
      delete node_type_.leaf_;
    }
    clear_has_node_type();
  }
}
inline ::optimization_guide::proto::Leaf* TreeNode::release_leaf() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.TreeNode.leaf)
  if (_internal_has_leaf()) {
    clear_has_node_type();
    ::optimization_guide::proto::Leaf* temp = node_type_.leaf_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::optimization_guide::proto::Leaf& TreeNode::_internal_leaf() const {
  return _internal_has_leaf()
      ? *node_type_.leaf_
      : reinterpret_cast< ::optimization_guide::proto::Leaf&>(::optimization_guide::proto::_Leaf_default_instance_);
}
inline const ::optimization_guide::proto::Leaf& TreeNode::leaf() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.TreeNode.leaf)
  return _internal_leaf();
}
inline ::optimization_guide::proto::Leaf* TreeNode::unsafe_arena_release_leaf() {
  // @@protoc_insertion_point(field_unsafe_arena_release:optimization_guide.proto.TreeNode.leaf)
  if (_internal_has_leaf()) {
    clear_has_node_type();
    ::optimization_guide::proto::Leaf* temp = node_type_.leaf_;
    node_type_.leaf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void TreeNode::unsafe_arena_set_allocated_leaf(::optimization_guide::proto::Leaf* leaf) {
  clear_node_type();
  if (leaf) {
    set_has_leaf();
    node_type_.leaf_ = leaf;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.TreeNode.leaf)
}
inline ::optimization_guide::proto::Leaf* TreeNode::_internal_mutable_leaf() {
  if (!_internal_has_leaf()) {
    clear_node_type();
    set_has_leaf();
    node_type_.leaf_ = CreateMaybeMessage< ::optimization_guide::proto::Leaf >(GetArenaForAllocation());
  }
  return node_type_.leaf_;
}
inline ::optimization_guide::proto::Leaf* TreeNode::mutable_leaf() {
  ::optimization_guide::proto::Leaf* _msg = _internal_mutable_leaf();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.TreeNode.leaf)
  return _msg;
}

inline bool TreeNode::has_node_type() const {
  return node_type_case() != NODE_TYPE_NOT_SET;
}
inline void TreeNode::clear_has_node_type() {
  _oneof_case_[0] = NODE_TYPE_NOT_SET;
}
inline TreeNode::NodeTypeCase TreeNode::node_type_case() const {
  return TreeNode::NodeTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BinaryNode

// optional .optimization_guide.proto.Int32Value left_child_id = 1;
inline bool BinaryNode::_internal_has_left_child_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || left_child_id_ != nullptr);
  return value;
}
inline bool BinaryNode::has_left_child_id() const {
  return _internal_has_left_child_id();
}
inline void BinaryNode::clear_left_child_id() {
  if (left_child_id_ != nullptr) left_child_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Int32Value& BinaryNode::_internal_left_child_id() const {
  const ::optimization_guide::proto::Int32Value* p = left_child_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Int32Value&>(
      ::optimization_guide::proto::_Int32Value_default_instance_);
}
inline const ::optimization_guide::proto::Int32Value& BinaryNode::left_child_id() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.BinaryNode.left_child_id)
  return _internal_left_child_id();
}
inline void BinaryNode::unsafe_arena_set_allocated_left_child_id(
    ::optimization_guide::proto::Int32Value* left_child_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(left_child_id_);
  }
  left_child_id_ = left_child_id;
  if (left_child_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.BinaryNode.left_child_id)
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::release_left_child_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Int32Value* temp = left_child_id_;
  left_child_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::unsafe_arena_release_left_child_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.BinaryNode.left_child_id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Int32Value* temp = left_child_id_;
  left_child_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::_internal_mutable_left_child_id() {
  _has_bits_[0] |= 0x00000001u;
  if (left_child_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaForAllocation());
    left_child_id_ = p;
  }
  return left_child_id_;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::mutable_left_child_id() {
  ::optimization_guide::proto::Int32Value* _msg = _internal_mutable_left_child_id();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BinaryNode.left_child_id)
  return _msg;
}
inline void BinaryNode::set_allocated_left_child_id(::optimization_guide::proto::Int32Value* left_child_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete left_child_id_;
  }
  if (left_child_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(left_child_id);
    if (message_arena != submessage_arena) {
      left_child_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, left_child_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  left_child_id_ = left_child_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BinaryNode.left_child_id)
}

// optional .optimization_guide.proto.Int32Value right_child_id = 2;
inline bool BinaryNode::_internal_has_right_child_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || right_child_id_ != nullptr);
  return value;
}
inline bool BinaryNode::has_right_child_id() const {
  return _internal_has_right_child_id();
}
inline void BinaryNode::clear_right_child_id() {
  if (right_child_id_ != nullptr) right_child_id_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Int32Value& BinaryNode::_internal_right_child_id() const {
  const ::optimization_guide::proto::Int32Value* p = right_child_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Int32Value&>(
      ::optimization_guide::proto::_Int32Value_default_instance_);
}
inline const ::optimization_guide::proto::Int32Value& BinaryNode::right_child_id() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.BinaryNode.right_child_id)
  return _internal_right_child_id();
}
inline void BinaryNode::unsafe_arena_set_allocated_right_child_id(
    ::optimization_guide::proto::Int32Value* right_child_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(right_child_id_);
  }
  right_child_id_ = right_child_id;
  if (right_child_id) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.BinaryNode.right_child_id)
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::release_right_child_id() {
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Int32Value* temp = right_child_id_;
  right_child_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::unsafe_arena_release_right_child_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.BinaryNode.right_child_id)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Int32Value* temp = right_child_id_;
  right_child_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::_internal_mutable_right_child_id() {
  _has_bits_[0] |= 0x00000002u;
  if (right_child_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Int32Value>(GetArenaForAllocation());
    right_child_id_ = p;
  }
  return right_child_id_;
}
inline ::optimization_guide::proto::Int32Value* BinaryNode::mutable_right_child_id() {
  ::optimization_guide::proto::Int32Value* _msg = _internal_mutable_right_child_id();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BinaryNode.right_child_id)
  return _msg;
}
inline void BinaryNode::set_allocated_right_child_id(::optimization_guide::proto::Int32Value* right_child_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete right_child_id_;
  }
  if (right_child_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(right_child_id);
    if (message_arena != submessage_arena) {
      right_child_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, right_child_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  right_child_id_ = right_child_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BinaryNode.right_child_id)
}

// optional .optimization_guide.proto.InequalityTest inequality_left_child_test = 4;
inline bool BinaryNode::_internal_has_inequality_left_child_test() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || inequality_left_child_test_ != nullptr);
  return value;
}
inline bool BinaryNode::has_inequality_left_child_test() const {
  return _internal_has_inequality_left_child_test();
}
inline void BinaryNode::clear_inequality_left_child_test() {
  if (inequality_left_child_test_ != nullptr) inequality_left_child_test_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::optimization_guide::proto::InequalityTest& BinaryNode::_internal_inequality_left_child_test() const {
  const ::optimization_guide::proto::InequalityTest* p = inequality_left_child_test_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::InequalityTest&>(
      ::optimization_guide::proto::_InequalityTest_default_instance_);
}
inline const ::optimization_guide::proto::InequalityTest& BinaryNode::inequality_left_child_test() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.BinaryNode.inequality_left_child_test)
  return _internal_inequality_left_child_test();
}
inline void BinaryNode::unsafe_arena_set_allocated_inequality_left_child_test(
    ::optimization_guide::proto::InequalityTest* inequality_left_child_test) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(inequality_left_child_test_);
  }
  inequality_left_child_test_ = inequality_left_child_test;
  if (inequality_left_child_test) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.BinaryNode.inequality_left_child_test)
}
inline ::optimization_guide::proto::InequalityTest* BinaryNode::release_inequality_left_child_test() {
  _has_bits_[0] &= ~0x00000004u;
  ::optimization_guide::proto::InequalityTest* temp = inequality_left_child_test_;
  inequality_left_child_test_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::InequalityTest* BinaryNode::unsafe_arena_release_inequality_left_child_test() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.BinaryNode.inequality_left_child_test)
  _has_bits_[0] &= ~0x00000004u;
  ::optimization_guide::proto::InequalityTest* temp = inequality_left_child_test_;
  inequality_left_child_test_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::InequalityTest* BinaryNode::_internal_mutable_inequality_left_child_test() {
  _has_bits_[0] |= 0x00000004u;
  if (inequality_left_child_test_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::InequalityTest>(GetArenaForAllocation());
    inequality_left_child_test_ = p;
  }
  return inequality_left_child_test_;
}
inline ::optimization_guide::proto::InequalityTest* BinaryNode::mutable_inequality_left_child_test() {
  ::optimization_guide::proto::InequalityTest* _msg = _internal_mutable_inequality_left_child_test();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.BinaryNode.inequality_left_child_test)
  return _msg;
}
inline void BinaryNode::set_allocated_inequality_left_child_test(::optimization_guide::proto::InequalityTest* inequality_left_child_test) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete inequality_left_child_test_;
  }
  if (inequality_left_child_test) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inequality_left_child_test);
    if (message_arena != submessage_arena) {
      inequality_left_child_test = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inequality_left_child_test, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  inequality_left_child_test_ = inequality_left_child_test;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.BinaryNode.inequality_left_child_test)
}

// -------------------------------------------------------------------

// Vector

// repeated .optimization_guide.proto.Value value = 1;
inline int Vector::_internal_value_size() const {
  return value_.size();
}
inline int Vector::value_size() const {
  return _internal_value_size();
}
inline void Vector::clear_value() {
  value_.Clear();
}
inline ::optimization_guide::proto::Value* Vector::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Vector.value)
  return value_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >*
Vector::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.Vector.value)
  return &value_;
}
inline const ::optimization_guide::proto::Value& Vector::_internal_value(int index) const {
  return value_.Get(index);
}
inline const ::optimization_guide::proto::Value& Vector::value(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Vector.value)
  return _internal_value(index);
}
inline ::optimization_guide::proto::Value* Vector::_internal_add_value() {
  return value_.Add();
}
inline ::optimization_guide::proto::Value* Vector::add_value() {
  ::optimization_guide::proto::Value* _add = _internal_add_value();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.Vector.value)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::Value >&
Vector::value() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.Vector.value)
  return value_;
}

// -------------------------------------------------------------------

// Leaf

// optional .optimization_guide.proto.Vector vector = 1;
inline bool Leaf::_internal_has_vector() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || vector_ != nullptr);
  return value;
}
inline bool Leaf::has_vector() const {
  return _internal_has_vector();
}
inline void Leaf::clear_vector() {
  if (vector_ != nullptr) vector_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::Vector& Leaf::_internal_vector() const {
  const ::optimization_guide::proto::Vector* p = vector_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Vector&>(
      ::optimization_guide::proto::_Vector_default_instance_);
}
inline const ::optimization_guide::proto::Vector& Leaf::vector() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Leaf.vector)
  return _internal_vector();
}
inline void Leaf::unsafe_arena_set_allocated_vector(
    ::optimization_guide::proto::Vector* vector) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vector_);
  }
  vector_ = vector;
  if (vector) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.Leaf.vector)
}
inline ::optimization_guide::proto::Vector* Leaf::release_vector() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Vector* temp = vector_;
  vector_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Vector* Leaf::unsafe_arena_release_vector() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.Leaf.vector)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Vector* temp = vector_;
  vector_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Vector* Leaf::_internal_mutable_vector() {
  _has_bits_[0] |= 0x00000001u;
  if (vector_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Vector>(GetArenaForAllocation());
    vector_ = p;
  }
  return vector_;
}
inline ::optimization_guide::proto::Vector* Leaf::mutable_vector() {
  ::optimization_guide::proto::Vector* _msg = _internal_mutable_vector();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.Leaf.vector)
  return _msg;
}
inline void Leaf::set_allocated_vector(::optimization_guide::proto::Vector* vector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vector_;
  }
  if (vector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vector);
    if (message_arena != submessage_arena) {
      vector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vector_ = vector;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.Leaf.vector)
}

// -------------------------------------------------------------------

// FeatureId

// optional .optimization_guide.proto.StringValue id = 1;
inline bool FeatureId::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || id_ != nullptr);
  return value;
}
inline bool FeatureId::has_id() const {
  return _internal_has_id();
}
inline const ::optimization_guide::proto::StringValue& FeatureId::_internal_id() const {
  const ::optimization_guide::proto::StringValue* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::StringValue&>(
      ::optimization_guide::proto::_StringValue_default_instance_);
}
inline const ::optimization_guide::proto::StringValue& FeatureId::id() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.FeatureId.id)
  return _internal_id();
}
inline void FeatureId::unsafe_arena_set_allocated_id(
    ::optimization_guide::proto::StringValue* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.FeatureId.id)
}
inline ::optimization_guide::proto::StringValue* FeatureId::release_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::StringValue* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::StringValue* FeatureId::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.FeatureId.id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::StringValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::StringValue* FeatureId::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::StringValue>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::optimization_guide::proto::StringValue* FeatureId::mutable_id() {
  ::optimization_guide::proto::StringValue* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.FeatureId.id)
  return _msg;
}
inline void FeatureId::set_allocated_id(::optimization_guide::proto::StringValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.FeatureId.id)
}

// -------------------------------------------------------------------

// InequalityTest

// optional .optimization_guide.proto.FeatureId feature_id = 1;
inline bool InequalityTest::_internal_has_feature_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || feature_id_ != nullptr);
  return value;
}
inline bool InequalityTest::has_feature_id() const {
  return _internal_has_feature_id();
}
inline void InequalityTest::clear_feature_id() {
  if (feature_id_ != nullptr) feature_id_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::FeatureId& InequalityTest::_internal_feature_id() const {
  const ::optimization_guide::proto::FeatureId* p = feature_id_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::FeatureId&>(
      ::optimization_guide::proto::_FeatureId_default_instance_);
}
inline const ::optimization_guide::proto::FeatureId& InequalityTest::feature_id() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.InequalityTest.feature_id)
  return _internal_feature_id();
}
inline void InequalityTest::unsafe_arena_set_allocated_feature_id(
    ::optimization_guide::proto::FeatureId* feature_id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(feature_id_);
  }
  feature_id_ = feature_id;
  if (feature_id) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.InequalityTest.feature_id)
}
inline ::optimization_guide::proto::FeatureId* InequalityTest::release_feature_id() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::FeatureId* temp = feature_id_;
  feature_id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::FeatureId* InequalityTest::unsafe_arena_release_feature_id() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.InequalityTest.feature_id)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::FeatureId* temp = feature_id_;
  feature_id_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::FeatureId* InequalityTest::_internal_mutable_feature_id() {
  _has_bits_[0] |= 0x00000001u;
  if (feature_id_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::FeatureId>(GetArenaForAllocation());
    feature_id_ = p;
  }
  return feature_id_;
}
inline ::optimization_guide::proto::FeatureId* InequalityTest::mutable_feature_id() {
  ::optimization_guide::proto::FeatureId* _msg = _internal_mutable_feature_id();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.InequalityTest.feature_id)
  return _msg;
}
inline void InequalityTest::set_allocated_feature_id(::optimization_guide::proto::FeatureId* feature_id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete feature_id_;
  }
  if (feature_id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(feature_id);
    if (message_arena != submessage_arena) {
      feature_id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, feature_id, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  feature_id_ = feature_id;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.InequalityTest.feature_id)
}

// optional .optimization_guide.proto.InequalityTest.Type type = 2;
inline bool InequalityTest::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool InequalityTest::has_type() const {
  return _internal_has_type();
}
inline void InequalityTest::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::optimization_guide::proto::InequalityTest_Type InequalityTest::_internal_type() const {
  return static_cast< ::optimization_guide::proto::InequalityTest_Type >(type_);
}
inline ::optimization_guide::proto::InequalityTest_Type InequalityTest::type() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.InequalityTest.type)
  return _internal_type();
}
inline void InequalityTest::_internal_set_type(::optimization_guide::proto::InequalityTest_Type value) {
  assert(::optimization_guide::proto::InequalityTest_Type_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  type_ = value;
}
inline void InequalityTest::set_type(::optimization_guide::proto::InequalityTest_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.InequalityTest.type)
}

// optional .optimization_guide.proto.Value threshold = 3;
inline bool InequalityTest::_internal_has_threshold() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || threshold_ != nullptr);
  return value;
}
inline bool InequalityTest::has_threshold() const {
  return _internal_has_threshold();
}
inline void InequalityTest::clear_threshold() {
  if (threshold_ != nullptr) threshold_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Value& InequalityTest::_internal_threshold() const {
  const ::optimization_guide::proto::Value* p = threshold_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Value&>(
      ::optimization_guide::proto::_Value_default_instance_);
}
inline const ::optimization_guide::proto::Value& InequalityTest::threshold() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.InequalityTest.threshold)
  return _internal_threshold();
}
inline void InequalityTest::unsafe_arena_set_allocated_threshold(
    ::optimization_guide::proto::Value* threshold) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(threshold_);
  }
  threshold_ = threshold;
  if (threshold) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.InequalityTest.threshold)
}
inline ::optimization_guide::proto::Value* InequalityTest::release_threshold() {
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Value* temp = threshold_;
  threshold_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Value* InequalityTest::unsafe_arena_release_threshold() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.InequalityTest.threshold)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Value* temp = threshold_;
  threshold_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Value* InequalityTest::_internal_mutable_threshold() {
  _has_bits_[0] |= 0x00000002u;
  if (threshold_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Value>(GetArenaForAllocation());
    threshold_ = p;
  }
  return threshold_;
}
inline ::optimization_guide::proto::Value* InequalityTest::mutable_threshold() {
  ::optimization_guide::proto::Value* _msg = _internal_mutable_threshold();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.InequalityTest.threshold)
  return _msg;
}
inline void InequalityTest::set_allocated_threshold(::optimization_guide::proto::Value* threshold) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete threshold_;
  }
  if (threshold) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(threshold);
    if (message_arena != submessage_arena) {
      threshold = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, threshold, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  threshold_ = threshold;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.InequalityTest.threshold)
}

// -------------------------------------------------------------------

// Value

// float float_value = 1;
inline bool Value::_internal_has_float_value() const {
  return value_case() == kFloatValue;
}
inline bool Value::has_float_value() const {
  return _internal_has_float_value();
}
inline void Value::set_has_float_value() {
  _oneof_case_[0] = kFloatValue;
}
inline void Value::clear_float_value() {
  if (_internal_has_float_value()) {
    value_.float_value_ = 0;
    clear_has_value();
  }
}
inline float Value::_internal_float_value() const {
  if (_internal_has_float_value()) {
    return value_.float_value_;
  }
  return 0;
}
inline void Value::_internal_set_float_value(float value) {
  if (!_internal_has_float_value()) {
    clear_value();
    set_has_float_value();
  }
  value_.float_value_ = value;
}
inline float Value::float_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.float_value)
  return _internal_float_value();
}
inline void Value::set_float_value(float value) {
  _internal_set_float_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.float_value)
}

// double double_value = 2;
inline bool Value::_internal_has_double_value() const {
  return value_case() == kDoubleValue;
}
inline bool Value::has_double_value() const {
  return _internal_has_double_value();
}
inline void Value::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void Value::clear_double_value() {
  if (_internal_has_double_value()) {
    value_.double_value_ = 0;
    clear_has_value();
  }
}
inline double Value::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return value_.double_value_;
  }
  return 0;
}
inline void Value::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_value();
    set_has_double_value();
  }
  value_.double_value_ = value;
}
inline double Value::double_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.double_value)
  return _internal_double_value();
}
inline void Value::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.double_value)
}

// int32 int32_value = 3;
inline bool Value::_internal_has_int32_value() const {
  return value_case() == kInt32Value;
}
inline bool Value::has_int32_value() const {
  return _internal_has_int32_value();
}
inline void Value::set_has_int32_value() {
  _oneof_case_[0] = kInt32Value;
}
inline void Value::clear_int32_value() {
  if (_internal_has_int32_value()) {
    value_.int32_value_ = 0;
    clear_has_value();
  }
}
inline int32_t Value::_internal_int32_value() const {
  if (_internal_has_int32_value()) {
    return value_.int32_value_;
  }
  return 0;
}
inline void Value::_internal_set_int32_value(int32_t value) {
  if (!_internal_has_int32_value()) {
    clear_value();
    set_has_int32_value();
  }
  value_.int32_value_ = value;
}
inline int32_t Value::int32_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.int32_value)
  return _internal_int32_value();
}
inline void Value::set_int32_value(int32_t value) {
  _internal_set_int32_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.int32_value)
}

// int64 int64_value = 4;
inline bool Value::_internal_has_int64_value() const {
  return value_case() == kInt64Value;
}
inline bool Value::has_int64_value() const {
  return _internal_has_int64_value();
}
inline void Value::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void Value::clear_int64_value() {
  if (_internal_has_int64_value()) {
    value_.int64_value_ = int64_t{0};
    clear_has_value();
  }
}
inline int64_t Value::_internal_int64_value() const {
  if (_internal_has_int64_value()) {
    return value_.int64_value_;
  }
  return int64_t{0};
}
inline void Value::_internal_set_int64_value(int64_t value) {
  if (!_internal_has_int64_value()) {
    clear_value();
    set_has_int64_value();
  }
  value_.int64_value_ = value;
}
inline int64_t Value::int64_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Value.int64_value)
  return _internal_int64_value();
}
inline void Value::set_int64_value(int64_t value) {
  _internal_set_int64_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Value.int64_value)
}

inline bool Value::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void Value::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline Value::ValueCase Value::value_case() const {
  return Value::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Int32Value

// optional int32 value = 1;
inline bool Int32Value::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Int32Value::has_value() const {
  return _internal_has_value();
}
inline void Int32Value::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t Int32Value::_internal_value() const {
  return value_;
}
inline int32_t Int32Value::value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.Int32Value.value)
  return _internal_value();
}
inline void Int32Value::_internal_set_value(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
}
inline void Int32Value::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.Int32Value.value)
}

// -------------------------------------------------------------------

// DoubleValue

// optional double value = 1;
inline bool DoubleValue::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool DoubleValue::has_value() const {
  return _internal_has_value();
}
inline void DoubleValue::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DoubleValue::_internal_value() const {
  return value_;
}
inline double DoubleValue::value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.DoubleValue.value)
  return _internal_value();
}
inline void DoubleValue::_internal_set_value(double value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
}
inline void DoubleValue::set_value(double value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.DoubleValue.value)
}

// -------------------------------------------------------------------

// GetModelsRequest

// repeated .optimization_guide.proto.ModelInfo requested_models = 1;
inline int GetModelsRequest::_internal_requested_models_size() const {
  return requested_models_.size();
}
inline int GetModelsRequest::requested_models_size() const {
  return _internal_requested_models_size();
}
inline void GetModelsRequest::clear_requested_models() {
  requested_models_.Clear();
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::mutable_requested_models(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.requested_models)
  return requested_models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >*
GetModelsRequest::mutable_requested_models() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsRequest.requested_models)
  return &requested_models_;
}
inline const ::optimization_guide::proto::ModelInfo& GetModelsRequest::_internal_requested_models(int index) const {
  return requested_models_.Get(index);
}
inline const ::optimization_guide::proto::ModelInfo& GetModelsRequest::requested_models(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.requested_models)
  return _internal_requested_models(index);
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::_internal_add_requested_models() {
  return requested_models_.Add();
}
inline ::optimization_guide::proto::ModelInfo* GetModelsRequest::add_requested_models() {
  ::optimization_guide::proto::ModelInfo* _add = _internal_add_requested_models();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsRequest.requested_models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelInfo >&
GetModelsRequest::requested_models() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsRequest.requested_models)
  return requested_models_;
}

// optional .optimization_guide.proto.RequestContext request_context = 3;
inline bool GetModelsRequest::_internal_has_request_context() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetModelsRequest::has_request_context() const {
  return _internal_has_request_context();
}
inline void GetModelsRequest::clear_request_context() {
  request_context_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::optimization_guide::proto::RequestContext GetModelsRequest::_internal_request_context() const {
  return static_cast< ::optimization_guide::proto::RequestContext >(request_context_);
}
inline ::optimization_guide::proto::RequestContext GetModelsRequest::request_context() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.request_context)
  return _internal_request_context();
}
inline void GetModelsRequest::_internal_set_request_context(::optimization_guide::proto::RequestContext value) {
  assert(::optimization_guide::proto::RequestContext_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  request_context_ = value;
}
inline void GetModelsRequest::set_request_context(::optimization_guide::proto::RequestContext value) {
  _internal_set_request_context(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.request_context)
}

// optional string locale = 5;
inline bool GetModelsRequest::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetModelsRequest::has_locale() const {
  return _internal_has_locale();
}
inline void GetModelsRequest::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetModelsRequest::locale() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsRequest.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetModelsRequest::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:optimization_guide.proto.GetModelsRequest.locale)
}
inline std::string* GetModelsRequest::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsRequest.locale)
  return _s;
}
inline const std::string& GetModelsRequest::_internal_locale() const {
  return locale_.Get();
}
inline void GetModelsRequest::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(value, GetArenaForAllocation());
}
inline std::string* GetModelsRequest::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(GetArenaForAllocation());
}
inline std::string* GetModelsRequest::release_locale() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.GetModelsRequest.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetModelsRequest::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(locale, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault()) {
    locale_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.GetModelsRequest.locale)
}

// -------------------------------------------------------------------

// GetModelsResponse

// repeated .optimization_guide.proto.PredictionModel models = 1;
inline int GetModelsResponse::_internal_models_size() const {
  return models_.size();
}
inline int GetModelsResponse::models_size() const {
  return _internal_models_size();
}
inline void GetModelsResponse::clear_models() {
  models_.Clear();
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::mutable_models(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsResponse.models)
  return models_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >*
GetModelsResponse::mutable_models() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsResponse.models)
  return &models_;
}
inline const ::optimization_guide::proto::PredictionModel& GetModelsResponse::_internal_models(int index) const {
  return models_.Get(index);
}
inline const ::optimization_guide::proto::PredictionModel& GetModelsResponse::models(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsResponse.models)
  return _internal_models(index);
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::_internal_add_models() {
  return models_.Add();
}
inline ::optimization_guide::proto::PredictionModel* GetModelsResponse::add_models() {
  ::optimization_guide::proto::PredictionModel* _add = _internal_add_models();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsResponse.models)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::PredictionModel >&
GetModelsResponse::models() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsResponse.models)
  return models_;
}

// repeated .optimization_guide.proto.HostModelFeatures host_model_features = 2;
inline int GetModelsResponse::_internal_host_model_features_size() const {
  return host_model_features_.size();
}
inline int GetModelsResponse::host_model_features_size() const {
  return _internal_host_model_features_size();
}
inline void GetModelsResponse::clear_host_model_features() {
  host_model_features_.Clear();
}
inline ::optimization_guide::proto::HostModelFeatures* GetModelsResponse::mutable_host_model_features(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.GetModelsResponse.host_model_features)
  return host_model_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >*
GetModelsResponse::mutable_host_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.GetModelsResponse.host_model_features)
  return &host_model_features_;
}
inline const ::optimization_guide::proto::HostModelFeatures& GetModelsResponse::_internal_host_model_features(int index) const {
  return host_model_features_.Get(index);
}
inline const ::optimization_guide::proto::HostModelFeatures& GetModelsResponse::host_model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.GetModelsResponse.host_model_features)
  return _internal_host_model_features(index);
}
inline ::optimization_guide::proto::HostModelFeatures* GetModelsResponse::_internal_add_host_model_features() {
  return host_model_features_.Add();
}
inline ::optimization_guide::proto::HostModelFeatures* GetModelsResponse::add_host_model_features() {
  ::optimization_guide::proto::HostModelFeatures* _add = _internal_add_host_model_features();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.GetModelsResponse.host_model_features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::HostModelFeatures >&
GetModelsResponse::host_model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.GetModelsResponse.host_model_features)
  return host_model_features_;
}

// -------------------------------------------------------------------

// PredictionModel

// optional .optimization_guide.proto.ModelInfo model_info = 1;
inline bool PredictionModel::_internal_has_model_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || model_info_ != nullptr);
  return value;
}
inline bool PredictionModel::has_model_info() const {
  return _internal_has_model_info();
}
inline void PredictionModel::clear_model_info() {
  if (model_info_ != nullptr) model_info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::optimization_guide::proto::ModelInfo& PredictionModel::_internal_model_info() const {
  const ::optimization_guide::proto::ModelInfo* p = model_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::ModelInfo&>(
      ::optimization_guide::proto::_ModelInfo_default_instance_);
}
inline const ::optimization_guide::proto::ModelInfo& PredictionModel::model_info() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.PredictionModel.model_info)
  return _internal_model_info();
}
inline void PredictionModel::unsafe_arena_set_allocated_model_info(
    ::optimization_guide::proto::ModelInfo* model_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_info_);
  }
  model_info_ = model_info;
  if (model_info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.PredictionModel.model_info)
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::release_model_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::ModelInfo* temp = model_info_;
  model_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::unsafe_arena_release_model_info() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.PredictionModel.model_info)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::ModelInfo* temp = model_info_;
  model_info_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::_internal_mutable_model_info() {
  _has_bits_[0] |= 0x00000001u;
  if (model_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::ModelInfo>(GetArenaForAllocation());
    model_info_ = p;
  }
  return model_info_;
}
inline ::optimization_guide::proto::ModelInfo* PredictionModel::mutable_model_info() {
  ::optimization_guide::proto::ModelInfo* _msg = _internal_mutable_model_info();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PredictionModel.model_info)
  return _msg;
}
inline void PredictionModel::set_allocated_model_info(::optimization_guide::proto::ModelInfo* model_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete model_info_;
  }
  if (model_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model_info);
    if (message_arena != submessage_arena) {
      model_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_info_ = model_info;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PredictionModel.model_info)
}

// optional .optimization_guide.proto.Model model = 2;
inline bool PredictionModel::_internal_has_model() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || model_ != nullptr);
  return value;
}
inline bool PredictionModel::has_model() const {
  return _internal_has_model();
}
inline void PredictionModel::clear_model() {
  if (model_ != nullptr) model_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::optimization_guide::proto::Model& PredictionModel::_internal_model() const {
  const ::optimization_guide::proto::Model* p = model_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Model&>(
      ::optimization_guide::proto::_Model_default_instance_);
}
inline const ::optimization_guide::proto::Model& PredictionModel::model() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.PredictionModel.model)
  return _internal_model();
}
inline void PredictionModel::unsafe_arena_set_allocated_model(
    ::optimization_guide::proto::Model* model) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_);
  }
  model_ = model;
  if (model) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.PredictionModel.model)
}
inline ::optimization_guide::proto::Model* PredictionModel::release_model() {
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Model* temp = model_;
  model_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Model* PredictionModel::unsafe_arena_release_model() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.PredictionModel.model)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Model* temp = model_;
  model_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Model* PredictionModel::_internal_mutable_model() {
  _has_bits_[0] |= 0x00000002u;
  if (model_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Model>(GetArenaForAllocation());
    model_ = p;
  }
  return model_;
}
inline ::optimization_guide::proto::Model* PredictionModel::mutable_model() {
  ::optimization_guide::proto::Model* _msg = _internal_mutable_model();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.PredictionModel.model)
  return _msg;
}
inline void PredictionModel::set_allocated_model(::optimization_guide::proto::Model* model) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete model_;
  }
  if (model) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(model);
    if (message_arena != submessage_arena) {
      model = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  model_ = model;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.PredictionModel.model)
}

// -------------------------------------------------------------------

// AdditionalModelFile

// optional string file_path = 1;
inline bool AdditionalModelFile::_internal_has_file_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool AdditionalModelFile::has_file_path() const {
  return _internal_has_file_path();
}
inline void AdditionalModelFile::clear_file_path() {
  file_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& AdditionalModelFile::file_path() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.AdditionalModelFile.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AdditionalModelFile::set_file_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:optimization_guide.proto.AdditionalModelFile.file_path)
}
inline std::string* AdditionalModelFile::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.AdditionalModelFile.file_path)
  return _s;
}
inline const std::string& AdditionalModelFile::_internal_file_path() const {
  return file_path_.Get();
}
inline void AdditionalModelFile::_internal_set_file_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* AdditionalModelFile::_internal_mutable_file_path() {
  _has_bits_[0] |= 0x00000001u;
  return file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* AdditionalModelFile::release_file_path() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.AdditionalModelFile.file_path)
  if (!_internal_has_file_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = file_path_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_path_.IsDefault()) {
    file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void AdditionalModelFile::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_path_.IsDefault()) {
    file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.AdditionalModelFile.file_path)
}

// -------------------------------------------------------------------

// ModelInfo

// optional .optimization_guide.proto.OptimizationTarget optimization_target = 1;
inline bool ModelInfo::_internal_has_optimization_target() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool ModelInfo::has_optimization_target() const {
  return _internal_has_optimization_target();
}
inline void ModelInfo::clear_optimization_target() {
  optimization_target_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::optimization_guide::proto::OptimizationTarget ModelInfo::_internal_optimization_target() const {
  return static_cast< ::optimization_guide::proto::OptimizationTarget >(optimization_target_);
}
inline ::optimization_guide::proto::OptimizationTarget ModelInfo::optimization_target() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.optimization_target)
  return _internal_optimization_target();
}
inline void ModelInfo::_internal_set_optimization_target(::optimization_guide::proto::OptimizationTarget value) {
  assert(::optimization_guide::proto::OptimizationTarget_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  optimization_target_ = value;
}
inline void ModelInfo::set_optimization_target(::optimization_guide::proto::OptimizationTarget value) {
  _internal_set_optimization_target(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.optimization_target)
}

// optional int64 version = 2;
inline bool ModelInfo::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool ModelInfo::has_version() const {
  return _internal_has_version();
}
inline void ModelInfo::clear_version() {
  version_ = int64_t{0};
  _has_bits_[0] &= ~0x00000004u;
}
inline int64_t ModelInfo::_internal_version() const {
  return version_;
}
inline int64_t ModelInfo::version() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.version)
  return _internal_version();
}
inline void ModelInfo::_internal_set_version(int64_t value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void ModelInfo::set_version(int64_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.version)
}

// repeated .optimization_guide.proto.ModelEngineVersion supported_model_engine_versions = 4;
inline int ModelInfo::_internal_supported_model_engine_versions_size() const {
  return supported_model_engine_versions_.size();
}
inline int ModelInfo::supported_model_engine_versions_size() const {
  return _internal_supported_model_engine_versions_size();
}
inline void ModelInfo::clear_supported_model_engine_versions() {
  supported_model_engine_versions_.Clear();
}
inline ::optimization_guide::proto::ModelEngineVersion ModelInfo::_internal_supported_model_engine_versions(int index) const {
  return static_cast< ::optimization_guide::proto::ModelEngineVersion >(supported_model_engine_versions_.Get(index));
}
inline ::optimization_guide::proto::ModelEngineVersion ModelInfo::supported_model_engine_versions(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
  return _internal_supported_model_engine_versions(index);
}
inline void ModelInfo::set_supported_model_engine_versions(int index, ::optimization_guide::proto::ModelEngineVersion value) {
  assert(::optimization_guide::proto::ModelEngineVersion_IsValid(value));
  supported_model_engine_versions_.Set(index, value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
}
inline void ModelInfo::_internal_add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value) {
  assert(::optimization_guide::proto::ModelEngineVersion_IsValid(value));
  supported_model_engine_versions_.Add(value);
}
inline void ModelInfo::add_supported_model_engine_versions(::optimization_guide::proto::ModelEngineVersion value) {
  _internal_add_supported_model_engine_versions(value);
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
ModelInfo::supported_model_engine_versions() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
  return supported_model_engine_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ModelInfo::_internal_mutable_supported_model_engine_versions() {
  return &supported_model_engine_versions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
ModelInfo::mutable_supported_model_engine_versions() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_model_engine_versions)
  return _internal_mutable_supported_model_engine_versions();
}

// repeated string supported_host_model_features = 5;
inline int ModelInfo::_internal_supported_host_model_features_size() const {
  return supported_host_model_features_.size();
}
inline int ModelInfo::supported_host_model_features_size() const {
  return _internal_supported_host_model_features_size();
}
inline void ModelInfo::clear_supported_host_model_features() {
  supported_host_model_features_.Clear();
}
inline std::string* ModelInfo::add_supported_host_model_features() {
  std::string* _s = _internal_add_supported_host_model_features();
  // @@protoc_insertion_point(field_add_mutable:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return _s;
}
inline const std::string& ModelInfo::_internal_supported_host_model_features(int index) const {
  return supported_host_model_features_.Get(index);
}
inline const std::string& ModelInfo::supported_host_model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return _internal_supported_host_model_features(index);
}
inline std::string* ModelInfo::mutable_supported_host_model_features(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return supported_host_model_features_.Mutable(index);
}
inline void ModelInfo::set_supported_host_model_features(int index, const std::string& value) {
  supported_host_model_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, std::string&& value) {
  supported_host_model_features_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_host_model_features_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::set_supported_host_model_features(int index, const char* value, size_t size) {
  supported_host_model_features_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline std::string* ModelInfo::_internal_add_supported_host_model_features() {
  return supported_host_model_features_.Add();
}
inline void ModelInfo::add_supported_host_model_features(const std::string& value) {
  supported_host_model_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(std::string&& value) {
  supported_host_model_features_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  supported_host_model_features_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline void ModelInfo::add_supported_host_model_features(const char* value, size_t size) {
  supported_host_model_features_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:optimization_guide.proto.ModelInfo.supported_host_model_features)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ModelInfo::supported_host_model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return supported_host_model_features_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ModelInfo::mutable_supported_host_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.supported_host_model_features)
  return &supported_host_model_features_;
}

// repeated .optimization_guide.proto.AdditionalModelFile additional_files = 7;
inline int ModelInfo::_internal_additional_files_size() const {
  return additional_files_.size();
}
inline int ModelInfo::additional_files_size() const {
  return _internal_additional_files_size();
}
inline void ModelInfo::clear_additional_files() {
  additional_files_.Clear();
}
inline ::optimization_guide::proto::AdditionalModelFile* ModelInfo::mutable_additional_files(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.additional_files)
  return additional_files_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::AdditionalModelFile >*
ModelInfo::mutable_additional_files() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.ModelInfo.additional_files)
  return &additional_files_;
}
inline const ::optimization_guide::proto::AdditionalModelFile& ModelInfo::_internal_additional_files(int index) const {
  return additional_files_.Get(index);
}
inline const ::optimization_guide::proto::AdditionalModelFile& ModelInfo::additional_files(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.additional_files)
  return _internal_additional_files(index);
}
inline ::optimization_guide::proto::AdditionalModelFile* ModelInfo::_internal_add_additional_files() {
  return additional_files_.Add();
}
inline ::optimization_guide::proto::AdditionalModelFile* ModelInfo::add_additional_files() {
  ::optimization_guide::proto::AdditionalModelFile* _add = _internal_add_additional_files();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.ModelInfo.additional_files)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::AdditionalModelFile >&
ModelInfo::additional_files() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.ModelInfo.additional_files)
  return additional_files_;
}

// optional .optimization_guide.proto.Duration valid_duration = 8;
inline bool ModelInfo::_internal_has_valid_duration() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || valid_duration_ != nullptr);
  return value;
}
inline bool ModelInfo::has_valid_duration() const {
  return _internal_has_valid_duration();
}
inline const ::optimization_guide::proto::Duration& ModelInfo::_internal_valid_duration() const {
  const ::optimization_guide::proto::Duration* p = valid_duration_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Duration&>(
      ::optimization_guide::proto::_Duration_default_instance_);
}
inline const ::optimization_guide::proto::Duration& ModelInfo::valid_duration() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.valid_duration)
  return _internal_valid_duration();
}
inline void ModelInfo::unsafe_arena_set_allocated_valid_duration(
    ::optimization_guide::proto::Duration* valid_duration) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valid_duration_);
  }
  valid_duration_ = valid_duration;
  if (valid_duration) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.ModelInfo.valid_duration)
}
inline ::optimization_guide::proto::Duration* ModelInfo::release_valid_duration() {
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Duration* temp = valid_duration_;
  valid_duration_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Duration* ModelInfo::unsafe_arena_release_valid_duration() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelInfo.valid_duration)
  _has_bits_[0] &= ~0x00000002u;
  ::optimization_guide::proto::Duration* temp = valid_duration_;
  valid_duration_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Duration* ModelInfo::_internal_mutable_valid_duration() {
  _has_bits_[0] |= 0x00000002u;
  if (valid_duration_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Duration>(GetArenaForAllocation());
    valid_duration_ = p;
  }
  return valid_duration_;
}
inline ::optimization_guide::proto::Duration* ModelInfo::mutable_valid_duration() {
  ::optimization_guide::proto::Duration* _msg = _internal_mutable_valid_duration();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.valid_duration)
  return _msg;
}
inline void ModelInfo::set_allocated_valid_duration(::optimization_guide::proto::Duration* valid_duration) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(valid_duration_);
  }
  if (valid_duration) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(valid_duration));
    if (message_arena != submessage_arena) {
      valid_duration = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, valid_duration, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  valid_duration_ = valid_duration;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelInfo.valid_duration)
}

// optional bool keep_beyond_valid_duration = 9;
inline bool ModelInfo::_internal_has_keep_beyond_valid_duration() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool ModelInfo::has_keep_beyond_valid_duration() const {
  return _internal_has_keep_beyond_valid_duration();
}
inline void ModelInfo::clear_keep_beyond_valid_duration() {
  keep_beyond_valid_duration_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool ModelInfo::_internal_keep_beyond_valid_duration() const {
  return keep_beyond_valid_duration_;
}
inline bool ModelInfo::keep_beyond_valid_duration() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.keep_beyond_valid_duration)
  return _internal_keep_beyond_valid_duration();
}
inline void ModelInfo::_internal_set_keep_beyond_valid_duration(bool value) {
  _has_bits_[0] |= 0x00000010u;
  keep_beyond_valid_duration_ = value;
}
inline void ModelInfo::set_keep_beyond_valid_duration(bool value) {
  _internal_set_keep_beyond_valid_duration(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelInfo.keep_beyond_valid_duration)
}

// optional .optimization_guide.proto.Any model_metadata = 6;
inline bool ModelInfo::_internal_has_model_metadata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || model_metadata_ != nullptr);
  return value;
}
inline bool ModelInfo::has_model_metadata() const {
  return _internal_has_model_metadata();
}
inline const ::optimization_guide::proto::Any& ModelInfo::_internal_model_metadata() const {
  const ::optimization_guide::proto::Any* p = model_metadata_;
  return p != nullptr ? *p : reinterpret_cast<const ::optimization_guide::proto::Any&>(
      ::optimization_guide::proto::_Any_default_instance_);
}
inline const ::optimization_guide::proto::Any& ModelInfo::model_metadata() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelInfo.model_metadata)
  return _internal_model_metadata();
}
inline void ModelInfo::unsafe_arena_set_allocated_model_metadata(
    ::optimization_guide::proto::Any* model_metadata) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_metadata_);
  }
  model_metadata_ = model_metadata;
  if (model_metadata) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:optimization_guide.proto.ModelInfo.model_metadata)
}
inline ::optimization_guide::proto::Any* ModelInfo::release_model_metadata() {
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Any* temp = model_metadata_;
  model_metadata_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::optimization_guide::proto::Any* ModelInfo::unsafe_arena_release_model_metadata() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelInfo.model_metadata)
  _has_bits_[0] &= ~0x00000001u;
  ::optimization_guide::proto::Any* temp = model_metadata_;
  model_metadata_ = nullptr;
  return temp;
}
inline ::optimization_guide::proto::Any* ModelInfo::_internal_mutable_model_metadata() {
  _has_bits_[0] |= 0x00000001u;
  if (model_metadata_ == nullptr) {
    auto* p = CreateMaybeMessage<::optimization_guide::proto::Any>(GetArenaForAllocation());
    model_metadata_ = p;
  }
  return model_metadata_;
}
inline ::optimization_guide::proto::Any* ModelInfo::mutable_model_metadata() {
  ::optimization_guide::proto::Any* _msg = _internal_mutable_model_metadata();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelInfo.model_metadata)
  return _msg;
}
inline void ModelInfo::set_allocated_model_metadata(::optimization_guide::proto::Any* model_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_metadata_);
  }
  if (model_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(model_metadata));
    if (message_arena != submessage_arena) {
      model_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, model_metadata, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  model_metadata_ = model_metadata;
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelInfo.model_metadata)
}

// -------------------------------------------------------------------

// HostModelFeatures

// optional string host = 1;
inline bool HostModelFeatures::_internal_has_host() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool HostModelFeatures::has_host() const {
  return _internal_has_host();
}
inline void HostModelFeatures::clear_host() {
  host_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& HostModelFeatures::host() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.HostModelFeatures.host)
  return _internal_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HostModelFeatures::set_host(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 host_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:optimization_guide.proto.HostModelFeatures.host)
}
inline std::string* HostModelFeatures::mutable_host() {
  std::string* _s = _internal_mutable_host();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.HostModelFeatures.host)
  return _s;
}
inline const std::string& HostModelFeatures::_internal_host() const {
  return host_.Get();
}
inline void HostModelFeatures::_internal_set_host(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  host_.Set(value, GetArenaForAllocation());
}
inline std::string* HostModelFeatures::_internal_mutable_host() {
  _has_bits_[0] |= 0x00000001u;
  return host_.Mutable(GetArenaForAllocation());
}
inline std::string* HostModelFeatures::release_host() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.HostModelFeatures.host)
  if (!_internal_has_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = host_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault()) {
    host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void HostModelFeatures::set_allocated_host(std::string* host) {
  if (host != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  host_.SetAllocated(host, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (host_.IsDefault()) {
    host_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.HostModelFeatures.host)
}

// repeated .optimization_guide.proto.ModelFeature model_features = 2;
inline int HostModelFeatures::_internal_model_features_size() const {
  return model_features_.size();
}
inline int HostModelFeatures::model_features_size() const {
  return _internal_model_features_size();
}
inline void HostModelFeatures::clear_model_features() {
  model_features_.Clear();
}
inline ::optimization_guide::proto::ModelFeature* HostModelFeatures::mutable_model_features(int index) {
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.HostModelFeatures.model_features)
  return model_features_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >*
HostModelFeatures::mutable_model_features() {
  // @@protoc_insertion_point(field_mutable_list:optimization_guide.proto.HostModelFeatures.model_features)
  return &model_features_;
}
inline const ::optimization_guide::proto::ModelFeature& HostModelFeatures::_internal_model_features(int index) const {
  return model_features_.Get(index);
}
inline const ::optimization_guide::proto::ModelFeature& HostModelFeatures::model_features(int index) const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.HostModelFeatures.model_features)
  return _internal_model_features(index);
}
inline ::optimization_guide::proto::ModelFeature* HostModelFeatures::_internal_add_model_features() {
  return model_features_.Add();
}
inline ::optimization_guide::proto::ModelFeature* HostModelFeatures::add_model_features() {
  ::optimization_guide::proto::ModelFeature* _add = _internal_add_model_features();
  // @@protoc_insertion_point(field_add:optimization_guide.proto.HostModelFeatures.model_features)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::optimization_guide::proto::ModelFeature >&
HostModelFeatures::model_features() const {
  // @@protoc_insertion_point(field_list:optimization_guide.proto.HostModelFeatures.model_features)
  return model_features_;
}

// -------------------------------------------------------------------

// ModelFeature

// optional string feature_name = 1;
inline bool ModelFeature::_internal_has_feature_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool ModelFeature::has_feature_name() const {
  return _internal_has_feature_name();
}
inline void ModelFeature::clear_feature_name() {
  feature_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& ModelFeature::feature_name() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelFeature.feature_name)
  return _internal_feature_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ModelFeature::set_feature_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 feature_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelFeature.feature_name)
}
inline std::string* ModelFeature::mutable_feature_name() {
  std::string* _s = _internal_mutable_feature_name();
  // @@protoc_insertion_point(field_mutable:optimization_guide.proto.ModelFeature.feature_name)
  return _s;
}
inline const std::string& ModelFeature::_internal_feature_name() const {
  return feature_name_.Get();
}
inline void ModelFeature::_internal_set_feature_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  feature_name_.Set(value, GetArenaForAllocation());
}
inline std::string* ModelFeature::_internal_mutable_feature_name() {
  _has_bits_[0] |= 0x00000001u;
  return feature_name_.Mutable(GetArenaForAllocation());
}
inline std::string* ModelFeature::release_feature_name() {
  // @@protoc_insertion_point(field_release:optimization_guide.proto.ModelFeature.feature_name)
  if (!_internal_has_feature_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = feature_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (feature_name_.IsDefault()) {
    feature_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void ModelFeature::set_allocated_feature_name(std::string* feature_name) {
  if (feature_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  feature_name_.SetAllocated(feature_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (feature_name_.IsDefault()) {
    feature_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:optimization_guide.proto.ModelFeature.feature_name)
}

// double double_value = 2;
inline bool ModelFeature::_internal_has_double_value() const {
  return feature_value_case() == kDoubleValue;
}
inline bool ModelFeature::has_double_value() const {
  return _internal_has_double_value();
}
inline void ModelFeature::set_has_double_value() {
  _oneof_case_[0] = kDoubleValue;
}
inline void ModelFeature::clear_double_value() {
  if (_internal_has_double_value()) {
    feature_value_.double_value_ = 0;
    clear_has_feature_value();
  }
}
inline double ModelFeature::_internal_double_value() const {
  if (_internal_has_double_value()) {
    return feature_value_.double_value_;
  }
  return 0;
}
inline void ModelFeature::_internal_set_double_value(double value) {
  if (!_internal_has_double_value()) {
    clear_feature_value();
    set_has_double_value();
  }
  feature_value_.double_value_ = value;
}
inline double ModelFeature::double_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelFeature.double_value)
  return _internal_double_value();
}
inline void ModelFeature::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelFeature.double_value)
}

// int64 int64_value = 3;
inline bool ModelFeature::_internal_has_int64_value() const {
  return feature_value_case() == kInt64Value;
}
inline bool ModelFeature::has_int64_value() const {
  return _internal_has_int64_value();
}
inline void ModelFeature::set_has_int64_value() {
  _oneof_case_[0] = kInt64Value;
}
inline void ModelFeature::clear_int64_value() {
  if (_internal_has_int64_value()) {
    feature_value_.int64_value_ = int64_t{0};
    clear_has_feature_value();
  }
}
inline int64_t ModelFeature::_internal_int64_value() const {
  if (_internal_has_int64_value()) {
    return feature_value_.int64_value_;
  }
  return int64_t{0};
}
inline void ModelFeature::_internal_set_int64_value(int64_t value) {
  if (!_internal_has_int64_value()) {
    clear_feature_value();
    set_has_int64_value();
  }
  feature_value_.int64_value_ = value;
}
inline int64_t ModelFeature::int64_value() const {
  // @@protoc_insertion_point(field_get:optimization_guide.proto.ModelFeature.int64_value)
  return _internal_int64_value();
}
inline void ModelFeature::set_int64_value(int64_t value) {
  _internal_set_int64_value(value);
  // @@protoc_insertion_point(field_set:optimization_guide.proto.ModelFeature.int64_value)
}

inline bool ModelFeature::has_feature_value() const {
  return feature_value_case() != FEATURE_VALUE_NOT_SET;
}
inline void ModelFeature::clear_has_feature_value() {
  _oneof_case_[0] = FEATURE_VALUE_NOT_SET;
}
inline ModelFeature::FeatureValueCase ModelFeature::feature_value_case() const {
  return ModelFeature::FeatureValueCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace optimization_guide

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::optimization_guide::proto::BinaryNode_Direction> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::InequalityTest_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::OptimizationTarget> : ::std::true_type {};
template <> struct is_proto_enum< ::optimization_guide::proto::ModelEngineVersion> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_components_2foptimization_5fguide_2fproto_2fmodels_2eproto
